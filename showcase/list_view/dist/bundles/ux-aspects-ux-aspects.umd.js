(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/router'), require('rxjs/BehaviorSubject'), require('rxjs/observable/fromEvent'), require('rxjs/Subscription'), require('rxjs/operators'), require('@angular/forms'), require('rxjs/Subject'), require('rxjs/observable/combineLatest'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/cdk/observers'), require('rxjs/observable/from'), require('rxjs/observable/of'), require('dragula'), require('@angular/cdk/a11y'), require('rxjs/Observable'), require('@angular/platform-browser'), require('ngx-bootstrap/dropdown'), require('@angular/animations'), require('ngx-bootstrap/tooltip'), require('@angular/cdk/keycodes'), require('@angular/http'), require('rxjs/observable/concat'), require('rxjs/observable/timer'), require('rxjs/operators/map'), require('rxjs/operators/delay'), require('@angular/upgrade/static')) :
    typeof define === 'function' && define.amd ? define('@ux-aspects/ux-aspects', ['exports', '@angular/core', '@angular/common', '@angular/router', 'rxjs/BehaviorSubject', 'rxjs/observable/fromEvent', 'rxjs/Subscription', 'rxjs/operators', '@angular/forms', 'rxjs/Subject', 'rxjs/observable/combineLatest', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/cdk/observers', 'rxjs/observable/from', 'rxjs/observable/of', 'dragula', '@angular/cdk/a11y', 'rxjs/Observable', '@angular/platform-browser', 'ngx-bootstrap/dropdown', '@angular/animations', 'ngx-bootstrap/tooltip', '@angular/cdk/keycodes', '@angular/http', 'rxjs/observable/concat', 'rxjs/observable/timer', 'rxjs/operators/map', 'rxjs/operators/delay', '@angular/upgrade/static'], factory) :
    (factory((global['ux-aspects'] = global['ux-aspects'] || {}, global['ux-aspects']['ux-aspects'] = {}),global.ng.core,global.ng.common,global.ng.router,global.rxjs.BehaviorSubject,global.rxjs['observable/fromEvent'],global.rxjs.Subscription,global.rxjs.operators,global.ng.forms,global.rxjs.Subject,global.rxjs['observable/combineLatest'],global.ng.cdk.overlay,global.ng.cdk.portal,global.ng.cdk.observers,global.rxjs['observable/from'],global.rxjs['observable/of'],null,global.ng.cdk.a11y,global.rxjs.Observable,global.ng.platformBrowser,null,global.ng.animations,null,global.ng.cdk.keycodes,global.ng.http,global.rxjs['observable/concat'],global.rxjs['observable/timer'],global.rxjs['operators/map'],global.rxjs['operators/delay'],global.ng.upgrade.static));
}(this, (function (exports,core,common,router,BehaviorSubject,fromEvent,Subscription,operators,forms,Subject,combineLatest,overlay,portal,observers,from,of,dragulaNamespace,a11y,Observable,platformBrowser,dropdown,animations,tooltip,keycodes,http,concat,timer,map,delay,_static) { 'use strict';

    var dragulaNamespace__default = 'default' in dragulaNamespace ? dragulaNamespace['default'] : dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsComponent = (function () {
        function BreadcrumbsComponent() {
        }
        /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
        BreadcrumbsComponent.prototype.clickCrumb =
            function (event, crumb) {
                if (crumb.onClick) {
                    crumb.onClick.call(null, event);
                }
            };
        BreadcrumbsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-breadcrumbs',
                        template: "<nav aria-label=\"Breadcrumb\">\n    <ol class=\"breadcrumb\">\n        <li *ngFor=\"let crumb of crumbs\">\n\n            <!-- If there is a router link then use a tag -->\n            <a *ngIf=\"crumb.routerLink || crumb.onClick\"\n                tabindex=\"0\"\n                [routerLink]=\"crumb.routerLink\"\n                [fragment]=\"crumb.fragment\"\n                [queryParams]=\"crumb.queryParams\"\n                (click)=\"clickCrumb($event, crumb)\">\n                {{ crumb.title }}\n            </a>\n\n            <!-- If there is not router link then display text in a span -->\n            <span *ngIf=\"!crumb.routerLink && !crumb.onClick\">{{ crumb.title }}</span>\n        </li>\n    </ol>\n</nav>"
                    },] },
        ];
        /** @nocollapse */
        BreadcrumbsComponent.ctorParameters = function () { return []; };
        BreadcrumbsComponent.propDecorators = {
            "crumbs": [{ type: core.Input },],
        };
        return BreadcrumbsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsModule = (function () {
        function BreadcrumbsModule() {
        }
        BreadcrumbsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [BreadcrumbsComponent],
                        declarations: [BreadcrumbsComponent]
                    },] },
        ];
        /** @nocollapse */
        BreadcrumbsModule.ctorParameters = function () { return []; };
        return BreadcrumbsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeService = (function () {
        function ResizeService(rendererFactory, _ngZone) {
            this._ngZone = _ngZone;
            this._subscription = new Subscription.Subscription();
            this._renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * @return {?}
         */
        ResizeService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} nativeElement
         * @return {?}
         */
        ResizeService.prototype.addResizeListener =
            function (nativeElement) {
                var _this = this;
                // create a behavior subject subject
                var /** @type {?} */ subject = new BehaviorSubject.BehaviorSubject({ width: nativeElement.offsetWidth, height: nativeElement.offsetHeight });
                // determine the style of the element
                var /** @type {?} */ displayMode = window.getComputedStyle(nativeElement).getPropertyValue('display');
                // create the iframe element
                var /** @type {?} */ iframe = this._renderer.createElement('iframe');
                // style the iframe to be invisible but fill containing element
                this._renderer.setStyle(iframe, 'position', 'absolute');
                this._renderer.setStyle(iframe, 'width', '100%');
                this._renderer.setStyle(iframe, 'height', '100%');
                this._renderer.setStyle(iframe, 'top', '0');
                this._renderer.setStyle(iframe, 'right', '0');
                this._renderer.setStyle(iframe, 'bottom', '0');
                this._renderer.setStyle(iframe, 'left', '0');
                this._renderer.setStyle(iframe, 'z-index', '-1');
                this._renderer.setStyle(iframe, 'opacity', '0');
                this._renderer.setStyle(iframe, 'border', 'none');
                this._renderer.setStyle(iframe, 'margin', '0');
                this._renderer.setStyle(iframe, 'pointer-events', 'none');
                this._renderer.setStyle(iframe, 'overflow', 'hidden');
                // ensure the iframe ignores any tabbing
                this._renderer.setAttribute(iframe, 'tabindex', '-1');
                this._renderer.setAttribute(iframe, 'aria-hidden', 'true');
                // statically positioned elements need changed to relative for this method to work
                if (displayMode !== 'relative' && displayMode !== 'absolute' && displayMode !== 'fixed') {
                    this._renderer.setStyle(nativeElement, 'position', 'relative');
                }
                // add the iframe to the container element
                this._renderer.appendChild(nativeElement, iframe);
                this.waitUntilReady(iframe, function () {
                    var /** @type {?} */ iframeDoc = iframe.contentDocument || (iframe.contentWindow.document);
                    var /** @type {?} */ attachListener = function () {
                        // watch for any future resizes - run inside ngzone as an iframe event listener is not patched
                        // watch for any future resizes - run inside ngzone as an iframe event listener is not patched
                        _this._subscription.add(fromEvent.fromEvent(iframe.contentWindow, 'resize').subscribe(function (event) {
                            return _this._ngZone.run(function () { return subject.next({ width: nativeElement.offsetWidth, height: nativeElement.offsetHeight }); });
                        }));
                    };
                    if (iframeDoc.readyState === 'complete') {
                        attachListener();
                    }
                    else {
                        // wait for iframe to load
                        iframe.addEventListener('load', function () { return attachListener(); });
                    }
                });
                return subject;
            };
        /**
         * @param {?} iframe
         * @param {?} callback
         * @return {?}
         */
        ResizeService.prototype.waitUntilReady =
            function (iframe, callback) {
                var _this = this;
                if (iframe.contentDocument || iframe.contentWindow) {
                    callback.call(this);
                }
                else {
                    setTimeout(function () { return _this.waitUntilReady(iframe, callback); });
                }
            };
        ResizeService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ResizeService.ctorParameters = function () {
            return [
                { type: core.RendererFactory2, },
                { type: core.NgZone, },
            ];
        };
        return ResizeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeDirective = (function () {
        function ResizeDirective(_elementRef, _resizeService, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._ngZone = _ngZone;
            this.throttle = 0;
            this.uxResize = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this._resizeService.addResizeListener(this._elementRef.nativeElement)
                    .pipe(operators.debounceTime(this.throttle))
                    .subscribe(function (event) { return _this._ngZone.run(function () { return _this.uxResize.emit(event); }); });
            };
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        ResizeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxResize]',
                        providers: [ResizeService]
                    },] },
        ];
        /** @nocollapse */
        ResizeDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
                { type: core.NgZone, },
            ];
        };
        ResizeDirective.propDecorators = {
            "throttle": [{ type: core.Input },],
            "uxResize": [{ type: core.Output },],
        };
        return ResizeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeModule = (function () {
        function ResizeModule() {
        }
        ResizeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ResizeDirective],
                        declarations: [ResizeDirective],
                        providers: [ResizeService]
                    },] },
        ];
        /** @nocollapse */
        ResizeModule.ctorParameters = function () { return []; };
        return ResizeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabContentDirective = (function () {
        function CardTabContentDirective() {
        }
        CardTabContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxCardTabContent]'
                    },] },
        ];
        /** @nocollapse */
        CardTabContentDirective.ctorParameters = function () { return []; };
        return CardTabContentDirective;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsService = (function () {
        function CardTabsService() {
            var _this = this;
            this.tab$ = new BehaviorSubject.BehaviorSubject(null);
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.position$ = new BehaviorSubject.BehaviorSubject('top');
            // when a tab is added or removed ensure we always select one if any are available
            this._subscription = this.tabs$.pipe(operators.filter(function (tabs) { return !_this.tab$.value || !tabs.find(function (tab) { return tab === _this.tab$.value; }); })).subscribe(function (tabs) { return _this.tab$.next(tabs.length > 0 ? tabs[0] : null); });
        }
        /**
         * @return {?}
         */
        CardTabsService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Add a tab to the list of tabs
         */
        /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.addTab =
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
            };
        /**
         * Remove a tab from the list
         */
        /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.removeTab =
            function (tab) {
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * Select the tab
         */
        /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.select =
            function (tab) {
                this.tab$.next(tab);
            };
        /**
         * Set the position of the tab content
         */
        /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
        CardTabsService.prototype.setPosition =
            function (position) {
                this.position$.next(position);
            };
        CardTabsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        CardTabsService.ctorParameters = function () { return []; };
        return CardTabsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabComponent = (function () {
        function CardTabComponent(_tabService) {
            var _this = this;
            this._tabService = _tabService;
            this.active$ = this._tabService.tab$.pipe(operators.map(function (tab) { return tab === _this; }));
            this._tabService.addTab(this);
        }
        /**
         * @return {?}
         */
        CardTabComponent.prototype.ngOnDestroy =
            function () {
                this._tabService.removeTab(this);
            };
        CardTabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tab',
                        template: "<ng-content *ngIf=\"active$ | async\"></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        CardTabComponent.ctorParameters = function () {
            return [
                { type: CardTabsService, },
            ];
        };
        CardTabComponent.propDecorators = {
            "content": [{ type: core.ContentChild, args: [CardTabContentDirective, { read: core.TemplateRef },] },],
        };
        return CardTabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsetComponent = (function () {
        function CardTabsetComponent(tabService) {
            this.tabService = tabService;
            this.offset = 0;
            this.bounds = { lower: 0, upper: 0 };
        }
        Object.defineProperty(CardTabsetComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabService.position$.getValue();
            },
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this.tabService.setPosition(direction);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.select =
            function (tab, element) {
                // select the tab
                this.tabService.select(tab);
                // ensure the tab is moved into view if required
                this.moveIntoView(element);
            };
        /**
         * @param {?} dimensions
         * @return {?}
         */
        CardTabsetComponent.prototype.resize =
            function (dimensions) {
                this._width = dimensions.width;
                this._innerWidth = this.tablist.nativeElement.scrollWidth;
                this.bounds.lower = 0;
                this.bounds.upper = -(this._innerWidth - this._width);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.previous =
            function () {
                this.offset += this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.min(this.offset, this.bounds.lower);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.next =
            function () {
                this.offset -= this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.max(this.offset, this.bounds.upper);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.moveIntoView =
            function (element) {
                // if we dont have the dimensions we cant check
                if (!this._width || !this._innerWidth) {
                    return;
                }
                // get the current element bounds
                var offsetLeft = element.offsetLeft, offsetWidth = element.offsetWidth;
                var _a = getComputedStyle(element), marginLeft = _a.marginLeft, marginRight = _a.marginRight;
                // calculate the visible area
                var /** @type {?} */ viewportStart = Math.abs(this.offset);
                var /** @type {?} */ viewportEnd = viewportStart + this._width;
                var /** @type {?} */ cardWidth = parseFloat(marginLeft) + offsetWidth + parseFloat(marginRight);
                // if we need to move to the left - figure out how much
                if (offsetLeft < viewportStart) {
                    this.offset -= (offsetLeft - parseFloat(marginLeft)) - viewportStart;
                }
                // if we need to move to the right - figure out how much
                if ((offsetLeft + cardWidth) > viewportEnd) {
                    this.offset -= (offsetLeft + cardWidth) - viewportEnd;
                }
            };
        CardTabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tabset',
                        template: "<div class=\"card-tab-content\" role=\"tabpanel\" *ngIf=\"(tabService.tab$ | async)\">\n    <ng-content></ng-content>\n</div>\n\n<div class=\"card-tabs\" #tabs>\n\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-previous\" aria-label=\"Previous Tabs\" (click)=\"previous()\" *ngIf=\"offset < bounds.lower\">\n        <i class=\"hpe-icon hpe-previous\"></i>\n    </button>\n\n    <div class=\"card-tabs-list\" role=\"tablist\" #tablist (uxResize)=\"resize($event)\" [style.transform]=\"'translateX(' + offset + 'px)'\">\n\n        <div class=\"card-tab\"\n            role=\"tab\"\n            tabindex=\"0\" #card\n            *ngFor=\"let tab of tabService.tabs$ | async\"\n            [ngClass]=\"tabService.position$ | async\"\n            [class.active]=\"tab.active$ | async\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            (click)=\"select(tab, card)\"\n            (focus)=\"tabs.scrollLeft = 0\"\n            (keydown.enter)=\"select(tab, card)\">\n\n            <ng-container [ngTemplateOutlet]=\"tab.content\"></ng-container>\n        </div>\n\n    </div>\n\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-next\" aria-label=\"Next Tabs\" (click)=\"next()\" *ngIf=\"offset > bounds.upper\">\n        <i class=\"hpe-icon hpe-next\"></i>\n    </button>\n</div>",
                        providers: [CardTabsService]
                    },] },
        ];
        /** @nocollapse */
        CardTabsetComponent.ctorParameters = function () {
            return [
                { type: CardTabsService, },
            ];
        };
        CardTabsetComponent.propDecorators = {
            "position": [{ type: core.HostBinding, args: ['class',] }, { type: core.Input },],
            "tablist": [{ type: core.ViewChild, args: ['tablist',] },],
        };
        return CardTabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsModule = (function () {
        function CardTabsModule() {
        }
        CardTabsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        declarations: [CardTabsetComponent, CardTabComponent, CardTabContentDirective],
                        exports: [CardTabsetComponent, CardTabComponent, CardTabContentDirective]
                    },] },
        ];
        /** @nocollapse */
        CardTabsModule.ctorParameters = function () { return []; };
        return CardTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueCheckboxId = 0;
    var CheckboxComponent = (function () {
        function CheckboxComponent() {
            this._checkboxId = "ux-checkbox-" + ++uniqueCheckboxId;
            this.id = this._checkboxId;
            this.tabindex = 0;
            this.clickable = true;
            this.simplified = false;
            this.indeterminateValue = -1;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.indeterminate = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(CheckboxComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // determine if it is in the indeterminate state
                this.indeterminate = this._value === this.indeterminateValue;
                // determine the checked state
                this.ariaChecked = this.indeterminate ? 'mixed' : this._value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._checkboxId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.toggle =
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                if (this.value === this.indeterminateValue) {
                    this.value = true;
                    return;
                }
                // toggle the checked state
                this.value = !this.value;
            };
        // Functions required to update ngModel
        /**
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue =
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        CheckboxComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-checkbox',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-checkbox\"\n       [class.ux-checkbox-checked]=\"value === true\"\n       [class.ux-checkbox-indeterminate]=\"indeterminate\"\n       [class.ux-checkbox-simplified]=\"simplified\"\n       [class.ux-checkbox-disabled]=\"disabled\"\n       [class.ux-checkbox-focused]=\"focused\">\n\n    <div class=\"ux-checkbox-container\">\n        <input type=\"checkbox\"\n               class=\"ux-checkbox-input\"\n               [id]=\"inputId\"\n               [required]=\"required\"\n               [checked]=\"value\"\n               [attr.value]=\"value\"\n               [disabled]=\"disabled\"\n               [attr.name]=\"name\"\n               [tabindex]=\"tabindex\"\n               [indeterminate]=\"indeterminate\"\n               [attr.aria-label]=\"ariaLabel\"\n               [attr.aria-labelledby]=\"ariaLabelledby\"\n               [attr.aria-checked]=\"ariaChecked\"\n               (focus)=\"focused = true\"\n               (blur)=\"focused = false\"\n               (change)=\"$event.stopPropagation()\"\n               (click)=\"toggle()\">\n    </div>\n\n    <span class=\"ux-checkbox-label\">\n        <ng-content></ng-content>\n    </span>\n</label>\n",
                        providers: [CHECKBOX_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        CheckboxComponent.ctorParameters = function () { return []; };
        CheckboxComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "name": [{ type: core.Input },],
            "required": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "clickable": [{ type: core.Input },],
            "simplified": [{ type: core.Input },],
            "indeterminateValue": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
            "ariaLabelledby": [{ type: core.Input, args: ['aria-labelledby',] },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input },],
        };
        return CheckboxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CheckboxModule = (function () {
        function CheckboxModule() {
        }
        CheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [CheckboxComponent],
                        declarations: [CheckboxComponent]
                    },] },
        ];
        /** @nocollapse */
        CheckboxModule.ctorParameters = function () { return []; };
        return CheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingDirective = (function () {
        function ColumnSortingDirective() {
            this.events = new Subject.Subject();
            this.order = [];
        }
        /**
         * @return {?}
         */
        ColumnSortingDirective.prototype.ngOnDestroy =
            function () {
                this.events.complete();
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleColumn =
            function (sorting) {
                // apply sorting based on the single or multiple sort
                this.order = this.singleSort ? this.toggleSingleColumn(sorting) : this.toggleMultipleColumn(sorting);
                // emit the latest order
                this.events.next(this.order);
                return this.order;
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleSingleColumn =
            function (sorting) {
                return sorting.state === ColumnSortingState.NoSort ? [] : [{ key: sorting.key, state: sorting.state }];
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleMultipleColumn =
            function (sorting) {
                // reorder columns here
                var /** @type {?} */ idx = this.order.findIndex(function (column) { return column.key === sorting.key; });
                // if wasnt previously selected add to list
                if (idx === -1) {
                    return __spread(this.order, [{ key: sorting.key, state: sorting.state }]);
                }
                // if we are sorting it change the sorting order
                if (sorting.state === ColumnSortingState.Ascending || sorting.state === ColumnSortingState.Descending) {
                    return __spread(this.order.filter(function (_column) { return _column.key !== sorting.key; }), [{ key: sorting.key, state: sorting.state }]);
                }
                // Otherwise remove the item
                return this.order.filter(function (_column) { return _column.key !== sorting.key; });
            };
        ColumnSortingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxColumnSorting]'
                    },] },
        ];
        /** @nocollapse */
        ColumnSortingDirective.ctorParameters = function () { return []; };
        ColumnSortingDirective.propDecorators = {
            "singleSort": [{ type: core.Input },],
        };
        return ColumnSortingDirective;
    }());
    /** @enum {string} */
    var ColumnSortingState = {
        Ascending: 'ascending',
        Descending: 'descending',
        NoSort: 'none',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingComponent = (function () {
        function ColumnSortingComponent(_columnSorter) {
            var _this = this;
            this._columnSorter = _columnSorter;
            this.stateChange = new core.EventEmitter();
            this.columnSortingState = ColumnSortingState;
            this._onDestroy = new Subject.Subject();
            this._columnSorter.events.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (event) {
                // if we are sorting this column then find the matching data
                var /** @type {?} */ columnIdx = event.findIndex(function (_column) { return _column.key === _this.key; });
                // if we are not sorting this column then mark it as NoSort
                if (columnIdx === -1) {
                    _this.state = ColumnSortingState.NoSort;
                }
                // only store the number if we have 2 or more columns being sorted
                // only store the number if we have 2 or more columns being sorted
                _this.order = event.length < 2 || columnIdx === -1 ? null : columnIdx + 1;
                // Emit the latest change
                // Emit the latest change
                _this.stateChange.emit(_this.state);
            });
        }
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.changeState =
            function () {
                switch (this.state) {
                    case ColumnSortingState.Ascending:
                        this.state = ColumnSortingState.Descending;
                        break;
                    case ColumnSortingState.Descending:
                        this.state = ColumnSortingState.NoSort;
                        break;
                    default:
                        this.state = ColumnSortingState.Ascending;
                }
                // inform parent
                return this._columnSorter.toggleColumn({ key: this.key, state: this.state });
            };
        ColumnSortingComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-column-sorting',
                        template: "<div class=\"ux-column-sorting\">\n\n    <i class=\"ux-column-sorting-icon hpe-icon\"\n       [class.hpe-ascend]=\"state === columnSortingState.Ascending\"\n       [class.hpe-descend]=\"state === columnSortingState.Descending\"\n       [class.column-sorting-icon-hidden]=\"state === columnSortingState.NoSort\">\n    </i>\n\n    <p class=\"ux-column-sorting-number\" aria-hidden=\"true\">{{ order }}</p>\n</div>",
                        exportAs: 'ux-column-sorting'
                    },] },
        ];
        /** @nocollapse */
        ColumnSortingComponent.ctorParameters = function () {
            return [
                { type: ColumnSortingDirective, },
            ];
        };
        ColumnSortingComponent.propDecorators = {
            "state": [{ type: core.Input },],
            "key": [{ type: core.Input },],
            "stateChange": [{ type: core.Output },],
        };
        return ColumnSortingComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingModule = (function () {
        function ColumnSortingModule() {
        }
        ColumnSortingModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ColumnSortingComponent, ColumnSortingDirective],
                        declarations: [ColumnSortingComponent, ColumnSortingDirective]
                    },] },
        ];
        /** @nocollapse */
        ColumnSortingModule.ctorParameters = function () { return []; };
        return ColumnSortingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitSubject = (function () {
        function ConduitSubject(conduit, _zone, zoneId) {
            this.conduit = conduit;
            this._zone = _zone;
            this.zoneId = zoneId;
            this._onDestroy = new Subject.Subject();
            // store the target subject object
            this._subject = conduit.subject;
            // check if there are any conduits that have supplied an initial value
            this.getInitialValue();
            // subscribe to changes to the source subject
            this._subject.pipe(operators.distinctUntilChanged(conduit.changeDetection), operators.takeUntil(this._onDestroy))
                .subscribe(this.onOutput.bind(this));
            // subscribe to the zone events and root zone events
            _zone.getEvents().pipe(operators.filter(function (event) { return event.conduit.id === conduit.id; }), operators.takeUntil(this._onDestroy)).subscribe(this.onInput.bind(this));
        }
        /** Check all allow inputs to see if there is a value we should initially set the conduit to */
        /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
        ConduitSubject.prototype.getInitialValue =
            function () {
                var _this = this;
                // if we do not accept inputs then do nothing
                if (this.conduit.acceptsInput === false) {
                    return;
                }
                // return all subjects that are 1) Not itself 2) In a zone that is listed in acceptsInput 3) Have a currentValue set
                var /** @type {?} */ subjects = this._zone.getSubjects().filter(function (subject) {
                    // If this is itself or if it has not value to give us then do nothing
                    if (subject === _this || subject.conduit.id !== _this.conduit.id || !subject.conduit.hasOwnProperty('currentValue')) {
                        return false;
                    }
                    // if acceptsInput is true then we return every time
                    if (_this.conduit.acceptsInput === true) {
                        return true;
                    }
                    if (Array.isArray(_this.conduit.acceptsInput)) {
                        return _this.conduit.acceptsInput.indexOf(subject.zoneId) !== -1;
                    }
                });
                // if there are no matches then do nothing
                if (subjects.length === 0) {
                    return;
                }
                // otherwise sort by the last modified field
                subjects.sort(function (subjectOne, subjectTwo) { return subjectOne.conduit.lastModified.getTime() < subjectTwo.conduit.lastModified.getTime() ? 1 : -1; });
                // get the most recent value
                this._subject.next(subjects[0].conduit.currentValue);
            };
        /** This will be triggered when a conduits value has changed */
        /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
        ConduitSubject.prototype.onInput =
            function (event) {
                // if we dont accept input or we emitted this value then do nothing
                if (this.conduit.acceptsInput === false || event.conduit === this.conduit) {
                    return;
                }
                // check if the conduit produces output - if not we only do something if we are in the same zone
                if (event.conduit.producesOutput === false && event.zoneId !== this.zoneId) {
                    return;
                }
                // check if we only accept inputs from specific zones
                if (Array.isArray(this.conduit.acceptsInput)) {
                    // check if the event came from an acceptable zone
                    if (!this.conduit.acceptsInput.find(function (zone) { return zone === event.zoneId; })) {
                        return;
                    }
                }
                // if required transform the value
                var /** @type {?} */ outputValue = this.conduit.map ? this.conduit.map(event.value) : event.value;
                // update the subject
                this._subject.next(outputValue);
            };
        /** This will be fired when this conduit emits a new value */
        /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
        ConduitSubject.prototype.onOutput =
            function (value) {
                // store the most recent value and when it was modified - can be used for any new conduits to lookup a value
                this.conduit.currentValue = value;
                this.conduit.lastModified = new Date();
                // check if this should produce output
                if (this.conduit.producesOutput) {
                    this._zone.emit({ conduit: this.conduit, zoneId: this.zoneId, value: value });
                }
            };
        /** Unsubscribe once this subject is destroyed */
        /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
        ConduitSubject.prototype.destroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        return ConduitSubject;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This utility is to ensure a all functions with the specified name are called in all super classes
     * @param {?} target
     * @param {?} functionName
     * @return {?}
     */
    function invokeSuperFunction(target, functionName) {
        // get all instances of the function
        var /** @type {?} */ functionList = [];
        // store the current prototype we are checking
        var /** @type {?} */ prototype = target;
        // look through every base class and check it
        do {
            if (prototype.hasOwnProperty(functionName)) {
                functionList.push(prototype[functionName]);
            }
            prototype = prototype.__proto__;
        } while (prototype.__proto__);
        // augment the top level function to call all the functions
        target[functionName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            functionList.forEach(function (func) { return func.call.apply(func, __spread([target], args)); });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitZone = (function () {
        function ConduitZone() {
        }
        /**
         * @return {?}
         */
        ConduitZone.prototype.ngOnDestroy =
            function () {
                var _this = this;
                // find all conduit subjects that are part of this zone
                ConduitZone.subjects.filter(function (_subject) { return _subject.zoneId === _this._zoneId; })
                    .forEach(function (_subject) { return _this.unregisterConduit(_subject.conduit); });
            };
        /** Store reference to the repository and begin watching for and emitting changes */
        /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.registerConduit =
            function (conduit) {
                ConduitZone.subjects.push(new ConduitSubject(conduit, this, this._zoneId));
            };
        /** Destroy a conduit */
        /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduit =
            function (conduit) {
                var /** @type {?} */ subject = this.getConduitSubject(conduit.subject);
                if (subject) {
                    // remove the subject from the internal list of conduit subjects
                    ConduitZone.subjects = ConduitZone.subjects.filter(function (_subject) { return _subject !== subject; });
                    // perform all unsubscriptions
                    subject.destroy();
                }
            };
        /** Provide the zone with an ID */
        /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
        ConduitZone.prototype.setZoneId =
            function (zoneId) {
                this._zoneId = zoneId;
            };
        /** Emit a value to all zones for checking */
        /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
        ConduitZone.prototype.emit =
            function (event) {
                ConduitZone.events.next(event);
            };
        /** Retrieve a conduit subsject object from the rxjs subject */
        /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
        ConduitZone.prototype.getConduitSubject =
            function (subject) {
                return ConduitZone.subjects.find(function (_subject) { return _subject.conduit.subject === subject; });
            };
        /** Get all subjects from all zones */
        /**
         * Get all subjects from all zones
         * @return {?}
         */
        ConduitZone.prototype.getSubjects =
            function () {
                return ConduitZone.subjects;
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.setConduitProperties =
            function (subject, properties) {
                // find the conduit with the matching subject
                var /** @type {?} */ conduitSubject = this.getSubjects().find(function (_conduit) { return _conduit.conduit.subject === subject; });
                // if a match was found update the properties
                if (conduitSubject) {
                    // update each specified property
                    for (var /** @type {?} */ prop in properties) {
                        conduitSubject.conduit[prop] = properties[prop];
                    }
                }
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.createConduit =
            function (subject, properties) {
                // register the conduit with the zone
                this.registerConduit(__assign({}, properties, { subject: subject }));
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.registerConduits =
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.registerConduit(__assign({}, conduit, { subject: component[conduit.propertyKey] })); });
                }
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduits =
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.unregisterConduit(conduit); });
                }
            };
        /** Return the global event stream */
        /**
         * Return the global event stream
         * @return {?}
         */
        ConduitZone.prototype.getEvents =
            function () {
                return ConduitZone.events;
            };
        /**
         * Create a global subject store
         */
        ConduitZone.subjects = [];
        /**
         * Expose an event stream of new values
         */
        ConduitZone.events = new Subject.Subject();
        ConduitZone.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ConduitZone.ctorParameters = function () { return []; };
        return ConduitZone;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitComponent = (function () {
        function ConduitComponent(_zone) {
            this._zone = _zone;
            // we want to ensure these functions get called even if a class overrides them
            invokeSuperFunction(this, 'ngOnInit');
            invokeSuperFunction(this, 'ngOnDestroy');
        }
        /** We need to register the conduits with the zone when the component is initialised */
        /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
        ConduitComponent.prototype.ngOnInit =
            function () {
                // register the conduit in the zone and ensure it gets the correct instance of the target
                this._zone.registerConduits(this);
            };
        /** We need to unregister the conduits when the component is destroyed */
        /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
        ConduitComponent.prototype.ngOnDestroy =
            function () {
                this._zone.unregisterConduits(this);
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.setConduitProperties =
            function (subject, properties) {
                this._zone.setConduitProperties(subject, properties);
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.createConduit =
            function (subject, properties) {
                this._zone.createConduit(subject, properties);
            };
        /** @nocollapse */
        ConduitComponent.ctorParameters = function () {
            return [
                { type: ConduitZone, decorators: [{ type: core.Optional },] },
            ];
        };
        return ConduitComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ ConduitZoneComponent = (function (_super) {
        __extends(ConduitZoneComponent, _super);
        function ConduitZoneComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        ConduitZoneComponent.prototype.ngOnInit =
            function () {
                this._zone.setZoneId(this.zoneId);
            };
        return ConduitZoneComponent;
    }(ConduitComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ defaultConduitProps = {
        acceptsInput: true,
        producesOutput: true,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Expose the property that conduits will be stored in
     */
    var /** @type {?} */ CONDUITS = '_conduits';
    /**
     * Create the conduit property decorator
     * @param {?} properties
     * @return {?}
     */
    function Conduit(properties) {
        return function (target, propertyKey) {
            if (typeof properties === 'function') {
                properties = properties.call(null);
            }
            // if the target does not already have a conduit list then create one
            if (!target.hasOwnProperty(CONDUITS)) {
                Object.defineProperty(target, CONDUITS, { value: [] });
            }
            // add the conduit to the list ensuring all required properties are provided
            target[CONDUITS].push(/** @type {?} */ (__assign({}, defaultConduitProps, properties, { target: target, propertyKey: propertyKey })));
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardService = (function () {
        function DashboardService() {
            var _this = this;
            this._rowHeight = 0;
            this.widgets$ = new BehaviorSubject.BehaviorSubject([]);
            this.options$ = new BehaviorSubject.BehaviorSubject(defaultOptions);
            this.dimensions$ = new BehaviorSubject.BehaviorSubject({});
            this.height$ = this.dimensions$.pipe(operators.delay(0), operators.map(function (dimensions) { return dimensions.height; }), operators.distinctUntilChanged());
            this.placeholder$ = new BehaviorSubject.BehaviorSubject({ visible: false, x: 0, y: 0, width: 0, height: 0 });
            this.layout$ = new Subject.Subject();
            this.stacked$ = new BehaviorSubject.BehaviorSubject(false);
            this.layout$.subscribe(this.setLayoutData.bind(this));
            this.stacked$.pipe(operators.filter(function (stacked) { return stacked === true; })).subscribe(this.updateWhenStacked.bind(this));
            this.widgets$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
            this.dimensions$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
        }
        Object.defineProperty(DashboardService.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.options$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "widgets", {
            get: /**
             * @return {?}
             */ function () {
                return this.widgets$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "stacked", {
            get: /**
             * @return {?}
             */ function () {
                return this.stacked$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "dimensions", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "columnWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions.width / this.options.columns;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add a widget to the dashboard
         * @param widget The widget component to add to the dashboard
         */
        /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
        DashboardService.prototype.addWidget =
            function (widget) {
                this.widgets$.next(__spread(this.widgets$.getValue(), [widget]));
            };
        /**
         * Remove a widget from the dashboard
         * @param widget The widget to remove
         */
        /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
        DashboardService.prototype.removeWidget =
            function (widget) {
                this.widgets$.next(this.widgets$.getValue().filter(function (_widget) { return _widget !== widget; }));
            };
        /**
         * Indicate that the dashboard element has been resized
         * @param width The width of the dashboard element in px
         * @param height The height of the dashboard element in px
         */
        /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
        DashboardService.prototype.setDimensions =
            function (width, height) {
                if (width === void 0) {
                    width = this.dimensions.width;
                }
                if (height === void 0) {
                    height = this.dimensions.height;
                }
                if (this.dimensions.width !== width || this.dimensions.height !== height) {
                    this.dimensions$.next({ width: width, height: height });
                }
            };
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         */
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
        DashboardService.prototype.getLayoutData =
            function () {
                return this.widgets.map(function (widget) {
                    return { id: widget.id, col: widget.getColumn(), row: widget.getRow(), colSpan: widget.getColumnSpan(), rowSpan: widget.getRowSpan() };
                });
            };
        /**
         * Position widgets programatically
         */
        /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
        DashboardService.prototype.setLayoutData =
            function (widgets) {
                var _this = this;
                // iterate through each widget data and find a match
                widgets.forEach(function (widget) {
                    // find the matching widget
                    var /** @type {?} */ target = _this.widgets.find(function (_widget) { return _widget.id === widget.id; });
                    if (target) {
                        target.setColumn(widget.col);
                        target.setRow(widget.row);
                        target.setColumnSpan(widget.colSpan);
                        target.setRowSpan(widget.rowSpan);
                    }
                });
            };
        /**
         * Update the positions and sizes of the widgets
         */
        /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
        DashboardService.prototype.renderDashboard =
            function () {
                var _this = this;
                // get the dimensions of the dashboard
                this._rowHeight = this.options.rowHeight || this.columnWidth;
                // ensure the column width is not below the min widths
                this.stacked$.next(this.columnWidth < this.options.minWidth);
                // ensure the row height is not below the min widths
                if (this._rowHeight < this.options.minWidth) {
                    this._rowHeight = this.options.minWidth;
                }
                this.setDashboardLayout();
                // iterate through each widget and set the size - except the one being resized
                this.widgets.filter(function (widget) { return !_this._actionWidget || widget !== _this._actionWidget.widget; })
                    .forEach(function (widget) { return widget.render(); });
            };
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         */
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
        DashboardService.prototype.setDashboardLayout =
            function () {
                var _this = this;
                // find any widgets that do not currently have a position set
                this.widgets.filter(function (widget) { return widget.getColumn() === undefined || widget.getRow() === undefined; })
                    .forEach(function (widget) { return _this.setWidgetPosition(widget); });
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.updateWhenStacked =
            function () {
                // iterate through each widget set it's stacked state and
                this.getWidgetsByOrder().forEach(function (widget, idx) {
                    widget.setColumn(0);
                    widget.setRow(idx);
                });
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getWidgetsByOrder =
            function () {
                return this.widgets.sort(function (w1, w2) {
                    var /** @type {?} */ w1Position = w1.getColumn() * w1.getRow();
                    var /** @type {?} */ w2Position = w2.getColumn() * w2.getRow();
                    if (w1Position < w2Position) {
                        return -1;
                    }
                    if (w1Position > w2Position) {
                        return 1;
                    }
                    return 0;
                });
            };
        /**
         * Find a position that a widget can fit in the dashboard
         * @param widget The widget to try and position
         */
        /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
        DashboardService.prototype.setWidgetPosition =
            function (widget) {
                // find a position for the widget
                var /** @type {?} */ position = 0;
                var /** @type {?} */ success = false;
                // repeat until a space is found
                while (!success) {
                    // get a position to try
                    var /** @type {?} */ column = position % this.options.columns;
                    var /** @type {?} */ row = Math.floor(position / this.options.columns);
                    // check the current position
                    if (this.getPositionAvailable(column, row, widget.getColumnSpan(), widget.getRowSpan())) {
                        success = true;
                        widget.setColumn(column);
                        widget.setRow(row);
                        return;
                    }
                    if (column === 0 && widget.colSpan > this.options.columns) {
                        throw new Error('Dashboard widgets have a colSpan greater than the max number of dashboard columns!');
                    }
                    position++;
                }
            };
        /**
         * Check if a position in the dashboard is vacant or not
         */
        /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
        DashboardService.prototype.getPositionAvailable =
            function (column, row, columnSpan, rowSpan, ignoreWidget) {
                // get a list of grid spaces that are populated
                var /** @type {?} */ spaces = this.getOccupiedSpaces();
                // check if the block would still be in bounds
                if (column + columnSpan > this.options.columns) {
                    return false;
                }
                var _loop_1 = function (x) {
                    var _loop_2 = function (y) {
                        if (spaces.find(function (block) { return block.column === x && block.row === y && block.widget !== ignoreWidget; })) {
                            return { value: false };
                        }
                    };
                    for (var /** @type {?} */ y = row; y < row + rowSpan; y++) {
                        var state_1 = _loop_2(y);
                        if (typeof state_1 === "object")
                            return state_1;
                    }
                };
                // check each required position
                for (var /** @type {?} */ x = column; x < column + columnSpan; x++) {
                    var state_2 = _loop_1(x);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
                return true;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getOccupiedSpaces =
            function () {
                var _this = this;
                // find all spaces that are currently occupied
                return this.widgets.filter(function (widget) { return widget.getColumn() !== undefined && widget.getRow() !== undefined; })
                    .reduce(function (value, widget) {
                    _this.forEachBlock(widget, function (column, row) { return value.push({ widget: widget, column: column, row: row }); });
                    return value;
                }, []);
            };
        /**
         * Begin resizing a widget
         * @param action The the widget to resize
         */
        /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
        DashboardService.prototype.onResizeStart =
            function (action) {
                // store the mouse event
                this._mouseEvent = action.event;
                this._actionWidget = action;
                // bring the widget to the font
                this.bringToFront(action.widget);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onResizeDrag =
            function (action) {
                var /** @type {?} */ mousePosX = this._mouseEvent.pageX - pageXOffset;
                var /** @type {?} */ mousePosY = this._mouseEvent.pageY - pageYOffset;
                // if there was no movement then do nothing
                if (action.event.x === mousePosX && action.event.y === mousePosY) {
                    return;
                }
                // update the stored mouse event
                this._mouseEvent = action.event;
                // get handle for direction
                var handle = action.handle;
                // get the bounds of the handle
                var /** @type {?} */ bounds = handle.getBoundingClientRect();
                // get the center of the handle
                var /** @type {?} */ centerX = bounds.left + (bounds.width / 2);
                var /** @type {?} */ centerY = bounds.top + (bounds.height / 2);
                // get the current mouse position
                var /** @type {?} */ mouseX = mousePosX - centerX;
                var /** @type {?} */ mouseY = mousePosY - centerY;
                // store the new proposed dimensions for the widget
                var /** @type {?} */ dimensions = {
                    x: action.widget.x,
                    y: action.widget.y,
                    width: action.widget.width,
                    height: action.widget.height
                };
                // update widget based on the handle being dragged
                switch (action.direction) {
                    case ActionDirection.Right:
                        dimensions.width += mouseX;
                        break;
                    case ActionDirection.Left:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.Bottom:
                        dimensions.height += mouseY;
                        break;
                    case ActionDirection.Top:
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    // Support resizing on multiple axis simultaneously
                    case ActionDirection.TopLeft:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.TopRight:
                        dimensions.width += mouseX;
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.BottomLeft:
                        dimensions.height += mouseY;
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.BottomRight:
                        dimensions.height += mouseY;
                        dimensions.width += mouseX;
                        break;
                }
                var /** @type {?} */ currentWidth = action.widget.x + action.widget.width;
                var /** @type {?} */ currentHeight = action.widget.y + action.widget.height;
                // ensure values are within the dashboard bounds
                if (dimensions.x < 0) {
                    dimensions.x = 0;
                    dimensions.width = currentWidth;
                }
                if (dimensions.y < 0) {
                    dimensions.y = 0;
                    dimensions.height = currentHeight;
                }
                if ((dimensions.x + dimensions.width) > this.dimensions.width) {
                    dimensions.width = this.dimensions.width - dimensions.x;
                }
                // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
                if (dimensions.width < this.options.minWidth) {
                    dimensions.x = action.widget.x;
                    dimensions.width = this.options.minWidth;
                }
                // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
                if (dimensions.height < this.options.minHeight) {
                    dimensions.y = action.widget.y;
                    dimensions.height = this.options.minHeight;
                }
                // update the widget actual values
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.updateWidgetPositions(action.widget);
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onResizeEnd =
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // commit resize changes
                this.commitWidgetChanges();
                // hide placeholder
                placeholder.visible = false;
                // update the placeholder
                this.placeholder$.next(placeholder);
                this._actionWidget = null;
                this._mouseEvent = null;
                // ensure any vacant upper spaces are filled where required
                this.shiftWidgetsUp();
                // update dashboard height
                this.setDashboardHeight();
                // emit information about the layout
                this.layout$.next(this.getLayoutData());
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDragStart =
            function (action) {
                this.onResizeStart(action);
                // store the starting placeholder position
                this.setWidgetOrigin();
                this.cacheWidgets();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onDragEnd =
            function () {
                this.onResizeEnd();
                this._widgetOrigin = {};
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDrag =
            function (action) {
                // if there was no movement then do nothing
                if (action.event.pageX === this._mouseEvent.pageX && action.event.pageY === this._mouseEvent.pageY) {
                    return;
                }
                // get the current mouse position
                var /** @type {?} */ mouseX = action.event.pageX - this._mouseEvent.pageX;
                var /** @type {?} */ mouseY = action.event.pageY - this._mouseEvent.pageY;
                // store the latest event
                this._mouseEvent = action.event;
                var /** @type {?} */ dimensions = {
                    x: action.widget.x + mouseX,
                    y: action.widget.y + mouseY,
                    width: action.widget.width,
                    height: action.widget.height
                };
                this.restoreWidgets(true);
                // update widget position
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.shiftWidgets();
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getRowHeight =
            function () {
                return this._rowHeight;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.cacheWidgets =
            function () {
                this._cache = this.widgets.map(function (widget) { return ({ id: widget.id, column: widget.getColumn(), row: widget.getRow() }); });
            };
        /**
         * @param {?=} ignoreActionWidget
         * @return {?}
         */
        DashboardService.prototype.restoreWidgets =
            function (ignoreActionWidget) {
                var _this = this;
                if (ignoreActionWidget === void 0) {
                    ignoreActionWidget = false;
                }
                this._cache.filter(function (widget) { return !ignoreActionWidget || widget.id !== _this._actionWidget.widget.id; }).forEach(function (widget) {
                    var /** @type {?} */ match = _this.widgets.find(function (wgt) { return wgt.id === widget.id; });
                    if (match) {
                        match.setColumn(widget.column);
                        match.setRow(widget.row);
                    }
                });
            };
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         */
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
        DashboardService.prototype.shiftWidgets =
            function () {
                var _this = this;
                var /** @type {?} */ widgetsToMove = [];
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var _loop_3 = function (row) {
                    var _loop_4 = function (column) {
                        // store reference to any widgets that need moved
                        this_1.getOccupiedSpaces()
                            .filter(function (space) { return space.column === column && space.row === row && space.widget !== _this._actionWidget.widget; })
                            .forEach(function (space) { return widgetsToMove.push(space.widget); });
                    };
                    for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                        _loop_4(column);
                    }
                };
                var this_1 = this;
                // check if there are any widgets under the placeholder
                for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                    _loop_3(row);
                }
                // remove any duplicates
                widgetsToMove = widgetsToMove.filter(function (widget, idx, array) { return array.indexOf(widget) === idx; });
                // if no widgets need moved then we can stop here
                if (widgetsToMove.length === 0) {
                    return;
                }
                // create a duplicate we can use to keep track of which have been moved
                var /** @type {?} */ unmovedWidgets = widgetsToMove.slice();
                // attempt to move any widgets to the previous widget position
                widgetsToMove.forEach(function (widget) {
                    // get a grid off all occupied spaces - taking into account the placeholder and ignoring widgets that need moved
                    var /** @type {?} */ grid = _this.getOccupiedSpaces().filter(function (space) { return !unmovedWidgets.find(function (wgt) { return wgt === space.widget; }); });
                    // iterate each free block
                    for (var /** @type {?} */ row = _this._widgetOrigin.row; row < _this._widgetOrigin.row + _this._widgetOrigin.rowSpan; row++) {
                        for (var /** @type {?} */ column = _this._widgetOrigin.column; column < _this._widgetOrigin.column + _this._widgetOrigin.columnSpan; column++) {
                            // determine if the block can fit in this space
                            var /** @type {?} */ requiredSpaces = _this.getRequiredSpacesFromPoint(widget, column, row);
                            // check if widget would fit in space
                            var /** @type {?} */ available = requiredSpaces.every(function (space) {
                                return !grid.find(function (gridSpace) { return gridSpace.column === space.column && gridSpace.row === space.row; }) && space.column < _this.getColumnCount();
                            });
                            if (available) {
                                widget.setColumn(column);
                                widget.setRow(row);
                                unmovedWidgets.splice(unmovedWidgets.findIndex(function (wgt) { return wgt === widget; }), 1);
                                return;
                            }
                        }
                    }
                    // if we get to here then we can't simply swap the positions - next try moving right
                    if (_this.canWidgetMoveRight(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Right);
                        return;
                    }
                    // next try moving left
                    if (_this.canWidgetMoveLeft(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Left);
                        return;
                    }
                    // determine the distance that the widget needs to be moved down
                    var /** @type {?} */ distance = (_this._actionWidget.widget.getRow() - widget.getRow()) + _this._actionWidget.widget.getRowSpan();
                    // as a last resort move the widget downwards
                    // as a last resort move the widget downwards
                    _this.moveWidgetDown(widget, distance);
                });
            };
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param shiftDirection - the position widgets were shifted
         */
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
        DashboardService.prototype.validatePlaceholderPosition =
            function (shiftDirection) {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check if the placeholder is over a widget
                if (this.getWidgetsAtPosition(placeholder.column, placeholder.row, true).length > 0) {
                    // move the placeholder the opposite direction
                    switch (shiftDirection) {
                        case ActionDirection.Left:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x + this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                        case ActionDirection.Right:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x - this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                    }
                    // validate this new position again
                    this.validatePlaceholderPosition(shiftDirection);
                }
            };
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveLeft =
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the action widget or occupies the first column
                if (widget === this._actionWidget.widget || widget.getColumn() === 0) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column - widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveLeft(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveLeft(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() - 1);
                }
                return moveable;
            };
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveRight =
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the dragging widget or the widget occupies the final column
                if (widget === this._actionWidget.widget || widget.getColumn() + widget.getColumnSpan() === this.options.columns) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column + widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveRight(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveRight(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() + 1);
                }
                return moveable;
            };
        /**
         * Store the initial position of the widget being dragged
         */
        /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
        DashboardService.prototype.setWidgetOrigin =
            function () {
                this._widgetOrigin = {
                    column: this._actionWidget.widget.getColumn(),
                    row: this._actionWidget.widget.getRow(),
                    columnSpan: this._actionWidget.widget.getColumnSpan(),
                    rowSpan: this._actionWidget.widget.getRowSpan()
                };
            };
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         */
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
        DashboardService.prototype.getRequiredSpacesFromPoint =
            function (widget, column, row) {
                var /** @type {?} */ spaces = [];
                for (var /** @type {?} */ y = row; y < row + widget.getRowSpan(); y++) {
                    for (var /** @type {?} */ x = column; x < column + widget.getColumnSpan(); x++) {
                        spaces.push({ column: x, row: y, widget: widget });
                    }
                }
                return spaces;
            };
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         */
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
        DashboardService.prototype.updateWidgetPositions =
            function (widget) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check all spaces the placeholder will occupy and move any widget currently in them down
                for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                    for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                        this.getWidgetsAtPosition(column, row, true)
                            .filter(function (wgt) { return wgt !== widget; })
                            .forEach(function (wgt) { return _this.moveWidgetDown(wgt); });
                    }
                }
                // update the height of the dashboard
                this.setDashboardHeight();
                // if we arent dragging the top handle then fill spaces
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Determine if a widget is occupying a specific row and column
         * @param column The columns to check if occupied
         * @param row The row to check if occupied
         * @param ignoreResizing Whether or not to ignore the widget currently being resized
         */
        /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
        DashboardService.prototype.getWidgetsAtPosition =
            function (column, row, ignoreResizing) {
                var _this = this;
                if (ignoreResizing === void 0) {
                    ignoreResizing = false;
                }
                return this.getOccupiedSpaces()
                    .filter(function (space) { return space.column === column && space.row === row; })
                    .filter(function (space) { return space.widget !== _this._actionWidget.widget || !ignoreResizing; })
                    .map(function (space) { return space.widget; });
            };
        /**
         * Update the placeholder visibility, position and size
         */
        /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.setPlaceholderBounds =
            function (visible, x, y, width, height) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var /** @type {?} */ rounding = this._actionWidget.direction === ActionDirection.Left ||
                    this._actionWidget.direction === ActionDirection.Top ? Rounding.RoundDownBelowHalf : Rounding.RoundUpOverHalf;
                placeholder.visible = visible;
                placeholder.column = this.getPlaceholderColumn(x, width);
                placeholder.row = this.getPlaceholderRow(y, height);
                placeholder.columnSpan = this.getPlaceholderColumnSpan(width);
                placeholder.rowSpan = this.getPlaceholderRowSpan(height);
                // calculate the maximum number of rows
                var /** @type {?} */ rowCount = this.widgets.filter(function (widget) { return widget !== _this._actionWidget.widget; })
                    .reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
                // constrain maximum placeholder row
                placeholder.row = Math.min(placeholder.row, rowCount);
                placeholder.x = (placeholder.column * this.getColumnWidth()) + this.options.padding;
                placeholder.y = (placeholder.row * this._rowHeight) + this.options.padding;
                placeholder.width = (placeholder.columnSpan * this.getColumnWidth()) - (this.options.padding * 2);
                placeholder.height = (placeholder.rowSpan * this._rowHeight) - (this.options.padding * 2);
                // set the values of the widget to match the values of the placeholder - however do not render the changes
                this._actionWidget.widget.setColumn(placeholder.column, false);
                this._actionWidget.widget.setRow(placeholder.row, false);
                this._actionWidget.widget.setColumnSpan(placeholder.columnSpan, false);
                this._actionWidget.widget.setRowSpan(placeholder.rowSpan, false);
                // update the placeholder
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the placeholder column position
         */
        /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumn =
            function (x, width) {
                var /** @type {?} */ column = this.getColumnFromPx(x, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ columnSpan = Math.floor(width / this.getColumnWidth());
                var /** @type {?} */ upperLimit = this.getColumnCount() - columnSpan;
                // if we arent dragging left then just return the column
                if (this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(Math.min(column, upperLimit), 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (x <= 0 || overflow === 0 || columnSpan === 0 || overflow > (this.getColumnWidth() / 2)) ?
                    Math.max(Math.min(column, upperLimit), 0) :
                    Math.max(Math.min(column + 1, upperLimit), 0);
            };
        /**
         * Get the column span of the placeholder
         */
        /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumnSpan =
            function (width) {
                var /** @type {?} */ columnSpan = this.getColumnFromPx(width);
                // if we arent dragging right or left then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Right &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.BottomRight &&
                    this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(columnSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (columnSpan > 0 && overflow > (this.getColumnWidth() / 2)) ? Math.max(columnSpan + 1, 1) : Math.max(columnSpan, 1);
            };
        /**
         * Get the row position of the placeholder
         */
        /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRow =
            function (y, height) {
                var /** @type {?} */ row = this.getRowFromPx(y, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ rowSpan = Math.ceil(height / this._rowHeight);
                // if we arent dragging up then just return the row
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    return Math.max(row, 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = height < this._rowHeight ? 0 : height % this._rowHeight;
                return (y <= 0 || rowSpan === 0 || overflow === 0 || overflow > (this._rowHeight / 2)) ? Math.max(row, 0) : Math.max(row + 1, 0);
            };
        /**
         * Get the row span of the placeholder
         */
        /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRowSpan =
            function (height) {
                var /** @type {?} */ rowSpan = this.getRowFromPx(height);
                // if we arent dragging up or down then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.Bottom &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomRight) {
                    return Math.max(rowSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = height % this._rowHeight;
                return (overflow > (this._rowHeight / 2)) ? Math.max(rowSpan + 1, 1) : Math.max(rowSpan, 1);
            };
        /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getColumnFromPx =
            function (x, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ column = Math.floor(x / Math.floor(this.getColumnWidth()));
                var /** @type {?} */ overflow = (x % Math.floor(this.getColumnWidth()));
                var /** @type {?} */ half = this.getColumnWidth() / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return column;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? column : column + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? column + 1 : column;
                    case Rounding.RoundUp:
                        return overflow > 0 ? column + 1 : column;
                }
            };
        /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getRowFromPx =
            function (y, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ row = Math.floor(y / Math.floor(this._rowHeight));
                var /** @type {?} */ overflow = (y % Math.floor(this._rowHeight));
                var /** @type {?} */ half = this._rowHeight / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return row;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? row : row + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? row + 1 : row;
                    case Rounding.RoundUp:
                        return overflow > 0 ? row + 1 : row;
                }
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.commitWidgetChanges =
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check that we have all the values we need
                if (placeholder.column === undefined || placeholder.row === undefined ||
                    placeholder.columnSpan === undefined || placeholder.rowSpan === undefined) {
                    return;
                }
                if (this._actionWidget) {
                    this._actionWidget.widget.setColumn(placeholder.column);
                    this._actionWidget.widget.setRow(placeholder.row);
                    this._actionWidget.widget.setColumnSpan(placeholder.columnSpan);
                    this._actionWidget.widget.setRowSpan(placeholder.rowSpan);
                }
                // reset all placeholder values
                placeholder.column = undefined;
                placeholder.row = undefined;
                placeholder.columnSpan = undefined;
                placeholder.rowSpan = undefined;
                // emit the new placeholder values
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the current column width
         */
        /**
         * Get the current column width
         * @return {?}
         */
        DashboardService.prototype.getColumnWidth =
            function () {
                return Math.floor(this.columnWidth);
            };
        /**
         * Calculate the number of rows populated with widgets
         */
        /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
        DashboardService.prototype.getRowCount =
            function () {
                return this.widgets.reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
            };
        /**
         * Set the height of the dashboard container element
         */
        /**
         * Set the height of the dashboard container element
         * @return {?}
         */
        DashboardService.prototype.setDashboardHeight =
            function () {
                // size the dashboard container to ensure all rows fit
                var /** @type {?} */ rowCount = this.getRowCount();
                // if we should show an empty row increment the row count by 1
                if (this.options.emptyRow) {
                    rowCount++;
                }
                this.setDimensions(undefined, rowCount * this._rowHeight);
            };
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param widget The widget that should be brought to the front
         */
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
        DashboardService.prototype.bringToFront =
            function (widget) {
                this.widgets.forEach(function (_widget) { return _widget === widget ? _widget.bringToFront() : _widget.sendToBack(); });
            };
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param widget The widget to move downwards
         */
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
        DashboardService.prototype.moveWidgetDown =
            function (widget, distance) {
                var _this = this;
                if (distance === void 0) {
                    distance = 1;
                }
                // move the widget down one position
                widget.setRow(widget.getRow() + distance);
                // check every space the widget occupies for collisions
                this.forEachBlock(widget, function (column, row) {
                    return _this.getWidgetsAtPosition(column, row, true)
                        .filter(function (wgt) { return wgt !== widget; })
                        .forEach(function (wgt) { return _this.moveWidgetDown(wgt, distance); });
                });
            };
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         */
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
        DashboardService.prototype.shiftWidgetsUp =
            function () {
                var _this = this;
                // check whether or not changes have been made - if so we need to repeat until stable
                var /** @type {?} */ stable = true;
                // iterate each widget and
                this.widgets.forEach(function (widget) {
                    // if widget is already on the top row then do nothing
                    if (widget.getRow() === 0) {
                        return;
                    }
                    // if we are currently dragging and this is the dragging widget then skip
                    if (_this._actionWidget && _this._actionWidget.widget === widget) {
                        return;
                    }
                    if (_this.getPositionAvailable(widget.getColumn(), widget.getRow() - 1, widget.getColumnSpan(), 1)) {
                        widget.setRow(widget.getRow() - 1);
                        stable = false;
                    }
                });
                // if changes occurred then we should repeat the process
                if (!stable) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Iterate over each space a widget occupied
         * @param widget The widget to determine spaces
         * @param callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         */
        /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
        DashboardService.prototype.forEachBlock =
            function (widget, callback) {
                for (var /** @type {?} */ row = widget.getRow(); row < widget.getRow() + widget.getRowSpan(); row++) {
                    for (var /** @type {?} */ column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                        callback.call(widget, column, row);
                    }
                }
            };
        /**
         * Returns the number of columns available
         */
        /**
         * Returns the number of columns available
         * @return {?}
         */
        DashboardService.prototype.getColumnCount =
            function () {
                return this.stacked ? 1 : this.options.columns;
            };
        DashboardService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DashboardService.ctorParameters = function () { return []; };
        return DashboardService;
    }());
    var /** @type {?} */ defaultOptions = { columns: 5, padding: 5, minWidth: 100, minHeight: 100, emptyRow: true };
    /** @enum {number} */
    var ActionDirection = {
        Top: 0,
        TopRight: 1,
        Right: 2,
        BottomRight: 3,
        Bottom: 4,
        BottomLeft: 5,
        Left: 6,
        TopLeft: 7,
        Move: 8,
    };
    ActionDirection[ActionDirection.Top] = "Top";
    ActionDirection[ActionDirection.TopRight] = "TopRight";
    ActionDirection[ActionDirection.Right] = "Right";
    ActionDirection[ActionDirection.BottomRight] = "BottomRight";
    ActionDirection[ActionDirection.Bottom] = "Bottom";
    ActionDirection[ActionDirection.BottomLeft] = "BottomLeft";
    ActionDirection[ActionDirection.Left] = "Left";
    ActionDirection[ActionDirection.TopLeft] = "TopLeft";
    ActionDirection[ActionDirection.Move] = "Move";
    /** @enum {number} */
    var Rounding = {
        RoundDown: 0,
        RoundDownBelowHalf: 1,
        RoundUp: 2,
        RoundUpOverHalf: 3,
    };
    Rounding[Rounding.RoundDown] = "RoundDown";
    Rounding[Rounding.RoundDownBelowHalf] = "RoundDownBelowHalf";
    Rounding[Rounding.RoundUp] = "RoundUp";
    Rounding[Rounding.RoundUpOverHalf] = "RoundUpOverHalf";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardComponent = (function () {
        function DashboardComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.layoutChange = new core.EventEmitter();
            dashboardService.layout$.subscribe(function (layout) { return _this.layoutChange.emit(layout); });
        }
        Object.defineProperty(DashboardComponent.prototype, "layout", {
            set: /**
             * @param {?} layout
             * @return {?}
             */ function (layout) {
                if (layout) {
                    this.dashboardService.layout$.next(layout);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardComponent.prototype, "options", {
            set: /**
             * @param {?} options
             * @return {?}
             */ function (options) {
                this.dashboardService.options$.next(__assign({}, defaultOptions, options));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set the initial dimensions
         */
        /**
         * Set the initial dimensions
         * @return {?}
         */
        DashboardComponent.prototype.ngAfterViewInit =
            function () {
                this.dashboardService.setDimensions(this.dashboardElement.nativeElement.offsetWidth, this.dashboardElement.nativeElement.offsetHeight);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DashboardComponent.prototype.onResize =
            function (event) {
                this.dashboardService.setDimensions(event.width, event.height);
            };
        DashboardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard',
                        template: "<div #dashboard class=\"dashboard-container\" [style.height.px]=\"dashboardService.height$ | async\">\n    <div (uxResize)=\"onResize($event)\" [throttle]=\"16\" class=\"dashboard\">\n        <ng-content></ng-content>\n    </div>\n    \n    <div class=\"position-indicator\" *ngIf=\"(dashboardService.placeholder$ | async).visible\" \n        [style.left.px]=\"(dashboardService.placeholder$ | async).x\" \n        [style.top.px]=\"(dashboardService.placeholder$ | async).y\" \n        [style.width.px]=\"(dashboardService.placeholder$ | async).width\"\n        [style.height.px]=\"(dashboardService.placeholder$ | async).height\"></div>\n</div>",
                        providers: [DashboardService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        DashboardComponent.ctorParameters = function () {
            return [
                { type: DashboardService, },
            ];
        };
        DashboardComponent.propDecorators = {
            "layout": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "layoutChange": [{ type: core.Output },],
            "dashboardElement": [{ type: core.ViewChild, args: ['dashboard',] },],
        };
        return DashboardComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardWidgetComponent = (function () {
        function DashboardWidgetComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.colSpan = 1;
            this.rowSpan = 1;
            this.resizable = false;
            this.x = 0;
            this.y = 0;
            this.width = 100;
            this.height = 100;
            this.padding = 0;
            this.zIndex = 0;
            this._column = { regular: undefined, stacked: undefined };
            this._row = { regular: undefined, stacked: undefined };
            this._columnSpan = { regular: 1, stacked: 1 };
            this._rowSpan = { regular: 1, stacked: 1 };
            this._subscription = dashboardService.options$.subscribe(function () { return _this.update(); });
        }
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnInit =
            function () {
                this._columnSpan.regular = this.colSpan;
                this._rowSpan.regular = this.rowSpan;
                if (!this.id) {
                    console.warn('Dashboard Widget is missing an ID.');
                    // set random id - keeps things working but prevents exporting of positions
                    this.id = Math.floor(Math.random() * 100000).toString();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngAfterViewInit =
            function () {
                // add the widget to the dashboard
                this.dashboardService.addWidget(this);
                // apply the current options
                this.update();
            };
        /**
         * If component is removed, then unregister it from the service
         */
        /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
                this.dashboardService.removeWidget(this);
            };
        /**
         * Apply the current dashboard options
         */
        /**
         * Apply the current dashboard options
         * @return {?}
         */
        DashboardWidgetComponent.prototype.update =
            function () {
                // get the current options at the time
                var _a = this.dashboardService.options, padding = _a.padding, columns = _a.columns;
                this.padding = padding;
                this._columnSpan.stacked = columns;
            };
        /**
         * Set the actual position and size values
         */
        /**
         * Set the actual position and size values
         * @return {?}
         */
        DashboardWidgetComponent.prototype.render =
            function () {
                this.x = this.getColumn() * this.dashboardService.getColumnWidth();
                this.y = this.getRow() * this.dashboardService.getRowHeight();
                this.width = this.getColumnSpan() * this.dashboardService.getColumnWidth();
                this.height = this.getRowSpan() * this.dashboardService.getRowHeight();
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumn =
            function () {
                return this.getStackableValue(this._column);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRow =
            function () {
                return this.getStackableValue(this._row);
            };
        /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumn =
            function (column, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._column, column);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRow =
            function (row, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._row, row);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumnSpan =
            function () {
                return this.getStackableValue(this._columnSpan);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRowSpan =
            function () {
                return this.getStackableValue(this._rowSpan);
            };
        /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumnSpan =
            function (columnSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._columnSpan, columnSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRowSpan =
            function (rowSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._rowSpan, rowSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.bringToFront =
            function () {
                this.zIndex = 1;
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.sendToBack =
            function () {
                this.zIndex = 0;
            };
        /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setBounds =
            function (x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragstart =
            function (handle, event, direction) {
                this.dashboardService.onResizeStart({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.drag =
            function (handle, event, direction) {
                this.dashboardService.onResizeDrag({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragend =
            function () {
                this.dashboardService.onResizeEnd();
            };
        /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setStackableValue =
            function (property, value) {
                if (this.dashboardService.stacked) {
                    property.stacked = value;
                }
                else {
                    property.regular = value;
                }
            };
        /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getStackableValue =
            function (property) {
                return this.dashboardService.stacked ? property.stacked : property.regular;
            };
        DashboardWidgetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard-widget',
                        template: "<div class=\"widget-content widget-col-span-{{ getColumnSpan() }} widget-row-span-{{ getRowSpan() }}\">\n    <ng-content></ng-content>\n</div>\n\n<div uxDrag #handleTop class=\"resizer-handle handle-top\" \n    (dragstart)=\"dragstart(handleTop, $event, 0)\"\n    (drag)=\"drag(handleTop, $event, 0)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag #handleTopRight class=\"resizer-handle handle-top-right\" \n    (dragstart)=\"dragstart(handleTopRight, $event, 1)\"\n    (drag)=\"drag(handleTopRight, $event, 1)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleRight class=\"resizer-handle handle-right\" \n    (dragstart)=\"dragstart(handleRight, $event, 2)\"\n    (drag)=\"drag(handleRight, $event, 2)\"\n    (dragend)=\"dragend()\"\n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleBottomRight class=\"resizer-handle handle-bottom-right\" \n    (dragstart)=\"dragstart(handleBottomRight, $event, 3)\"\n    (drag)=\"drag(handleBottomRight, $event, 3)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleBottom class=\"resizer-handle handle-bottom\" \n    (dragstart)=\"dragstart(handleBottom, $event, 4)\"\n    (drag)=\"drag(handleBottom, $event, 4)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag #handleBottomLeft class=\"resizer-handle handle-bottom-left\" \n    (dragstart)=\"dragstart(handleBottomLeft, $event, 5)\"\n    (drag)=\"drag(handleBottomLeft, $event, 5)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleLeft class=\"resizer-handle handle-left\" \n    (dragstart)=\"dragstart(handleLeft, $event, 6)\"\n    (drag)=\"drag(handleLeft, $event, 6)\"\n    (dragend)=\"dragend()\"\n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleTopLeft class=\"resizer-handle handle-top-left\" \n    (dragstart)=\"dragstart(handleTopLeft, $event, 7)\"\n    (drag)=\"drag(handleTopLeft, $event, 7)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>"
                    },] },
        ];
        /** @nocollapse */
        DashboardWidgetComponent.ctorParameters = function () {
            return [
                { type: DashboardService, },
            ];
        };
        DashboardWidgetComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "col": [{ type: core.Input },],
            "row": [{ type: core.Input },],
            "colSpan": [{ type: core.Input },],
            "rowSpan": [{ type: core.Input },],
            "resizable": [{ type: core.Input },],
            "x": [{ type: core.HostBinding, args: ['style.left.px',] },],
            "y": [{ type: core.HostBinding, args: ['style.top.px',] },],
            "width": [{ type: core.HostBinding, args: ['style.width.px',] },],
            "height": [{ type: core.HostBinding, args: ['style.height.px',] },],
            "padding": [{ type: core.HostBinding, args: ['style.padding.px',] },],
            "zIndex": [{ type: core.HostBinding, args: ['style.z-index',] },],
        };
        return DashboardWidgetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragDirective = (function () {
        function DragDirective(_elementRef, _ngZone, _renderer) {
            var _this = this;
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            this._renderer = _renderer;
            /**
             * Detemine if we should show a clone when dragging
             */
            this.clone = false;
            /**
             * Allow the dragging to be enabled/disabled
             */
            this.draggable = true;
            /**
             * Emit an event when dragging starts
             */
            this.dragstart = new core.EventEmitter();
            /**
             * Emit an event when the mouse moves while dragging
             */
            this.drag = new core.EventEmitter();
            /**
             * Emit an event when the dragging finishes
             */
            this.dragend = new core.EventEmitter();
            /**
             * Create an observable from the mouse down event
             */
            this._mousedown$ = fromEvent.fromEvent(this._elementRef.nativeElement, 'mousedown');
            /**
             * Create an observable from the mouse move event
             */
            this._mousemove$ = fromEvent.fromEvent(document, 'mousemove');
            /**
             * Create an observable from the mouse up event
             */
            this._mouseup$ = fromEvent.fromEvent(document, 'mouseup');
            /**
             * Use an observable to unsubscribe from all subscriptions
             */
            this._onDestroy = new Subject.Subject();
            this._mousedown$.pipe(operators.filter(function () { return _this.draggable; }), operators.takeUntil(this._onDestroy)).subscribe(this.dragStart.bind(this));
        }
        /** Emit events and create clone when drag starts */
        /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragStart =
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this.clone) {
                    // clone the node
                    this.cloneNode(event);
                }
                // apply a class to the element being dragged
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // emit the drag start event
                this._ngZone.run(function () { return _this.dragstart.emit(event); });
                this._mousemove$.pipe(operators.takeUntil(this._mouseup$), operators.takeUntil(this._onDestroy))
                    .subscribe(this.dragMove.bind(this), null, this.dragEnd.bind(this));
            };
        /** Emit event and update clone position when dragging moves */
        /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragMove =
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this._clone) {
                    this.updateNodePosition(event);
                }
                // emit the drag start event
                this._ngZone.run(function () { return _this.drag.emit(event); });
            };
        /** Emit event and destroy clone when dragging ends */
        /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
        DragDirective.prototype.dragEnd =
            function () {
                var _this = this;
                // if there was a clone, remove it
                if (this._clone) {
                    this._renderer.removeChild(document.body, this._clone);
                    this._clone = null;
                }
                // remove the dragging class
                this._renderer.removeClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                this._ngZone.run(function () { return _this.dragend.emit(); });
            };
        /** Create an exact clone of an element */
        /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.cloneNode =
            function (event) {
                // duplicate the node
                this._clone = this._elementRef.nativeElement.cloneNode(true);
                // store the position within the draggable element
                var _a = this._elementRef.nativeElement.getBoundingClientRect(), top = _a.top, left = _a.left;
                this._offset = { x: event.clientX - left, y: event.clientY - top };
                // inline all styles so it looks identical regardless of its position in the DOM
                this.inlineStyles(this._elementRef.nativeElement, this._clone);
                // ensure we can easily position the node an it is above all other elements
                this._renderer.setAttribute(this._clone, 'aria-hidden', 'true');
                this._renderer.setStyle(this._clone, 'position', 'absolute');
                this._renderer.setStyle(this._clone, 'z-index', '99999');
                // apply a class to allow custom styling
                this._renderer.addClass(this._clone, 'ux-drag-dragging-clone');
                // insert the cloned element
                this._renderer.appendChild(document.body, this._clone);
                // set the cloned element initial position
                this.updateNodePosition(event);
            };
        /** Position the clone relative to the mouse */
        /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.updateNodePosition =
            function (event) {
                this._renderer.setStyle(this._clone, 'left', (event.pageX - this._offset.x) + 'px');
                this._renderer.setStyle(this._clone, 'top', (event.pageY - this._offset.y) + 'px');
            };
        /** Inline all styles to ensure styling is consistent regardless of its position in the dom */
        /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        DragDirective.prototype.inlineStyles =
            function (source, target) {
                // get all the computed styles from the source element
                var /** @type {?} */ styles = getComputedStyle(source);
                // inline every specified style
                for (var /** @type {?} */ idx = 0; idx < styles.length; idx++) {
                    var /** @type {?} */ style = styles.item(idx);
                    if (style !== undefined) {
                        this._renderer.setStyle(target, styles[idx], styles[style]);
                    }
                }
                // ensure we dont capture any move events
                this._renderer.setStyle(target, 'pointer-events', 'none');
                // do the same for all the child elements
                for (var /** @type {?} */ idx = 0; idx < source.children.length; idx++) {
                    this.inlineStyles(source.children[idx], target.children[idx]);
                }
            };
        /** Unsubscribe from all subscriptions */
        /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
        DragDirective.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        DragDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDrag]'
                    },] },
        ];
        /** @nocollapse */
        DragDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.NgZone, },
                { type: core.Renderer2, },
            ];
        };
        DragDirective.propDecorators = {
            "clone": [{ type: core.Input },],
            "draggable": [{ type: core.Input },],
            "dragstart": [{ type: core.Output },],
            "drag": [{ type: core.Output },],
            "dragend": [{ type: core.Output },],
        };
        return DragDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardDragHandleDirective = (function (_super) {
        __extends(DashboardDragHandleDirective, _super);
        function DashboardDragHandleDirective(widget, dashboardService, elementRef, ngZone, renderer) {
            var _this = _super.call(this, elementRef, ngZone, renderer) || this;
            _this.dragstart.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDragStart({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.drag.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDrag({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.dragend.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function () { return dashboardService.onDragEnd(); });
            return _this;
        }
        DashboardDragHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDashboardWidgetDragHandle], [ux-dashboard-widget-drag-handle]'
                    },] },
        ];
        /** @nocollapse */
        DashboardDragHandleDirective.ctorParameters = function () {
            return [
                { type: DashboardWidgetComponent, },
                { type: DashboardService, },
                { type: core.ElementRef, },
                { type: core.NgZone, },
                { type: core.Renderer2, },
            ];
        };
        return DashboardDragHandleDirective;
    }(DragDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragModule = (function () {
        function DragModule() {
        }
        DragModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DragDirective],
                        declarations: [DragDirective]
                    },] },
        ];
        /** @nocollapse */
        DragModule.ctorParameters = function () { return []; };
        return DragModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS = [
        DashboardComponent,
        DashboardWidgetComponent,
        DashboardDragHandleDirective
    ];
    var DashboardModule = (function () {
        function DashboardModule() {
        }
        DashboardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            DragModule
                        ],
                        exports: DECLARATIONS,
                        declarations: DECLARATIONS,
                        providers: [DashboardService],
                    },] },
        ];
        /** @nocollapse */
        DashboardModule.ctorParameters = function () { return []; };
        return DashboardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SPIN_BUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SpinButtonComponent; }),
        multi: true
    };
    var SpinButtonComponent = (function () {
        function SpinButtonComponent() {
            this.type = 'text';
            this.placeholder = '';
            this.disabled = false;
            this.spinners = true;
            this.readOnly = true;
            this.scrolling = true;
            this.arrowkeys = true;
            this.valueChange = new core.EventEmitter();
            this.increment = new core.EventEmitter();
            this.decrement = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(SpinButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        SpinButtonComponent.prototype.scroll =
            function (event) {
                if (!this.scrolling) {
                    return;
                }
                if (event.deltaY > 0) {
                    this.triggerDecrement();
                }
                else {
                    this.triggerIncrement();
                }
                event.preventDefault();
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerIncrement =
            function () {
                if (!this.disabled) {
                    this.increment.emit();
                }
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerDecrement =
            function () {
                if (!this.disabled) {
                    this.decrement.emit();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SpinButtonComponent.prototype.writeValue =
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SpinButtonComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        SpinButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spin-button',
                        template: "<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"incrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerIncrement()\">\n\n  <span class=\"hpe-icon hpe-up\"></span>\n</button>\n\n<input [type]=\"type\"\n       role=\"spinbutton\"\n       [min]=\"min\"\n       [max]=\"max\"\n       [tabindex]=\"0\"\n       class=\"form-control\"\n       [placeholder]=\"placeholder\"\n       [readOnly]=\"readOnly\"\n       [disabled]=\"disabled\"\n       [attr.aria-label]=\"inputAriaLabel\"\n       [attr.aria-disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\"\n       [attr.aria-readonly]=\"readOnly\"\n       [ngModel]=\"value\"\n       (ngModelChange)=\"valueChange.emit($event)\"\n       (wheel)=\"scroll($event)\"\n       (keydown.arrowup)=\"arrowkeys ? triggerIncrement() : null; $event.preventDefault()\"\n       (keydown.arrowdown)=\"arrowkeys ? triggerDecrement() : null; $event.preventDefault()\">\n\n<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"decrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerDecrement()\">\n\n  <span class=\"hpe-icon hpe-down\"></span>\n</button>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [SPIN_BUTTON_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        SpinButtonComponent.ctorParameters = function () { return []; };
        SpinButtonComponent.propDecorators = {
            "value": [{ type: core.Input },],
            "type": [{ type: core.Input },],
            "min": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "spinners": [{ type: core.Input },],
            "readOnly": [{ type: core.Input },],
            "scrolling": [{ type: core.Input },],
            "arrowkeys": [{ type: core.Input },],
            "incrementAriaLabel": [{ type: core.Input },],
            "inputAriaLabel": [{ type: core.Input },],
            "decrementAriaLabel": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "increment": [{ type: core.Output },],
            "decrement": [{ type: core.Output },],
        };
        return SpinButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SpinButtonModule = (function () {
        function SpinButtonModule() {
        }
        SpinButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [SpinButtonComponent],
                        declarations: [SpinButtonComponent]
                    },] },
        ];
        /** @nocollapse */
        SpinButtonModule.ctorParameters = function () { return []; };
        return SpinButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeFormatPipe = (function () {
        function TimeFormatPipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        TimeFormatPipe.prototype.transform =
            function (value) {
                return value < 10 ? '0' + value : value;
            };
        TimeFormatPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'timeFormat'
                    },] },
        ];
        /** @nocollapse */
        TimeFormatPipe.ctorParameters = function () { return []; };
        return TimeFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TIME_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TimePickerComponent; }),
        multi: true
    };
    var TimePickerComponent = (function () {
        function TimePickerComponent() {
            var _this = this;
            this.arrowkeys = true;
            this.mousewheel = true;
            this.disabled = false;
            this.readOnly = false;
            this.showMeridian = false;
            this.showHours = true;
            this.showMinutes = true;
            this.showSeconds = false;
            this.showSpinners = true;
            this.hourStep = 1;
            this.minuteStep = 1;
            this.secondStep = 1;
            this.meridians = ['AM', 'PM'];
            this.valueChange = new core.EventEmitter();
            this.isValid = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this.value$ = new BehaviorSubject.BehaviorSubject(new Date());
            // create observables that are derived from the latest value
            this.hour$ = this.value$.pipe(operators.map(function (date) { return date.getHours(); }), operators.map(function (hour) { return _this.showMeridian ? _this.getMeridianTime(hour) : hour; }));
            this.minute$ = this.value$.pipe(operators.map(function (date) { return date.getMinutes(); }));
            this.second$ = this.value$.pipe(operators.map(function (date) { return date.getSeconds(); }));
            this.meridian$ = this.value$.pipe(operators.map(function (date) { return date.getHours() < 12 ? _this.meridians[0] : _this.meridians[1]; }));
            this.valid$ = this.value$.pipe(operators.map(function (date) { return _this.checkValidity(date); }));
            this._meridian = this.meridians[0];
            this._subscription = this.valid$.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.isValid.emit(valid); });
        }
        Object.defineProperty(TimePickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return new Date(this.value$.value);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.value$.next(new Date(value));
                this.valueChange.emit(this.value$.value);
                this.onChangeCallback(this.value$.value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TimePickerComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.writeValue =
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TimePickerComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.getMeridianTime =
            function (hour) {
                return hour > 12 ? hour - 12 : hour;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.setHour =
            function (hour) {
                var /** @type {?} */ date = this.value;
                date.setHours(hour ? hour : 0);
                this.value = date;
            };
        /**
         * @param {?} minute
         * @return {?}
         */
        TimePickerComponent.prototype.setMinute =
            function (minute) {
                var /** @type {?} */ date = this.value;
                date.setMinutes(minute ? minute : 0);
                this.value = date;
            };
        /**
         * @param {?} seconds
         * @return {?}
         */
        TimePickerComponent.prototype.setSeconds =
            function (seconds) {
                var /** @type {?} */ date = this.value;
                date.setSeconds(seconds ? seconds : 0);
                this.value = date;
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementHour =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() + this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementHour =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() - this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementMinute =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() + this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementMinute =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() - this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementSecond =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() + this.secondStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementSecond =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() - this.secondStep);
            };
        /**
         * @param {?} meridian
         * @return {?}
         */
        TimePickerComponent.prototype.selectMeridian =
            function (meridian) {
                this._meridian = meridian;
                // get the current time
                var /** @type {?} */ hour = this.value.getHours();
                // if we have selected AM
                if (meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        this.setHour(hour - 12);
                    }
                }
                // if we have selected PM
                if (meridian === this.meridians[1]) {
                    if (hour < 12) {
                        this.setHour(hour + 12);
                    }
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        TimePickerComponent.prototype.checkValidity =
            function (date) {
                var /** @type {?} */ valid = true;
                if (this.min && date.getTime() <= this.min.getTime()) {
                    valid = false;
                }
                if (this.max && date.getTime() >= this.max.getTime()) {
                    valid = false;
                }
                return valid;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.hourChange =
            function (value) {
                // convert the string to a number
                var /** @type {?} */ hour = parseInt(value);
                var /** @type {?} */ currentHour = this.value.getHours();
                // if the value hasn't changed, do nothing
                if (hour === currentHour) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(hour)) {
                    if (hour < 0) {
                        hour = 0;
                    }
                    if (hour > (this.showMeridian ? 12 : 23)) {
                        hour = this.showMeridian ? 12 : 23;
                    }
                }
                hour = isNaN(hour) ? currentHour : hour;
                // if the number is invalid then restore it to the previous value
                if (this._meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        hour -= 12;
                    }
                }
                // if we have selected PM
                if (this._meridian === this.meridians[1]) {
                    if (hour < 12) {
                        hour += 12;
                    }
                }
                this.setHour(hour);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.minuteChange =
            function (value) {
                // convert the string to a number
                var /** @type {?} */ minute = parseInt(value);
                var /** @type {?} */ currentMinute = this.value.getMinutes();
                // if the value hasn't changed, do nothing
                if (minute === currentMinute) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(minute)) {
                    if (minute < 0) {
                        minute = 59;
                    }
                    if (minute > 59) {
                        minute = 0;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setMinute(isNaN(minute) ? currentMinute : minute);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.secondChange =
            function (value) {
                // convert the string to a number
                var /** @type {?} */ second = parseInt(value);
                var /** @type {?} */ currentSecond = this.value.getSeconds();
                // if the value hasn't changed, do nothing
                if (second === currentSecond) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(second)) {
                    if (second < 0) {
                        second = 0;
                    }
                    if (second > 59) {
                        second = 59;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setSeconds(isNaN(second) ? currentSecond : second);
            };
        TimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-time-picker',
                        template: "<div class=\"time-picker\" aria-label=\"Time picker\">\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showHours\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"HH\"\n            [min]=\"0\"\n            [max]=\"showMeridian ? 12 : 23\"\n            [value]=\"hour$ | async | timeFormat\"\n            (valueChange)=\"hourChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"hour\"\n            incrementAriaLabel=\"Increment the hour\"\n            decrementAriaLabel=\"Decrement the hour\"\n            (increment)=\"incrementHour()\"\n            (decrement)=\"decrementHour()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showMinutes\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showMinutes\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"MM\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"minute$ | async | timeFormat\"\n            (valueChange)=\"minuteChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"minute\"\n            incrementAriaLabel=\"Increment the minute\"\n            decrementAriaLabel=\"Decrement the minute\"\n            (increment)=\"incrementMinute()\"\n            (decrement)=\"decrementMinute()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showSeconds\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showSeconds\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            type=\"number\"\n            placeholder=\"SS\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"second$ | async | timeFormat\"\n            (valueChange)=\"secondChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"seconds\"\n            incrementAriaLabel=\"Increment the second\"\n            decrementAriaLabel=\"Decrement the second\"\n            (increment)=\"incrementSecond()\"\n            (decrement)=\"decrementSecond()\">\n        </ux-spin-button>\n\n    </div>\n</div>\n\n<div class=\"time-picker-meridian\" *ngIf=\"showMeridian\">\n\n    <div class=\"btn-group\" role=\"radiogroup\">\n\n        <button class=\"btn button-toggle-accent\"\n                *ngFor=\"let meridian of meridians\"\n                role=\"radio\"\n                tabindex=\"0\"\n                [disabled]=\"disabled\"\n                (click)=\"selectMeridian(meridian)\"\n                [class.active]=\"meridian === (meridian$ | async)\"\n                [attr.aria-label]=\"meridian\"\n                [attr.aria-checked]=\"meridian === (meridian$ | async)\"\n                [attr.aria-disabled]=\"disabled\">\n                {{ meridian }}\n        </button>\n\n    </div>\n</div>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TIME_PICKER_VALUE_ACCESSOR],
                        host: {
                            'aria-label': 'Time Picker'
                        }
                    },] },
        ];
        /** @nocollapse */
        TimePickerComponent.ctorParameters = function () { return []; };
        TimePickerComponent.propDecorators = {
            "arrowkeys": [{ type: core.Input },],
            "mousewheel": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "readOnly": [{ type: core.Input },],
            "showMeridian": [{ type: core.Input },],
            "showHours": [{ type: core.Input },],
            "showMinutes": [{ type: core.Input },],
            "showSeconds": [{ type: core.Input },],
            "showSpinners": [{ type: core.Input },],
            "hourStep": [{ type: core.Input },],
            "minuteStep": [{ type: core.Input },],
            "secondStep": [{ type: core.Input },],
            "min": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "meridians": [{ type: core.Input },],
            "value": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "isValid": [{ type: core.Output },],
        };
        return TimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimePickerModule = (function () {
        function TimePickerModule() {
        }
        TimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            SpinButtonModule
                        ],
                        exports: [TimePickerComponent],
                        declarations: [TimePickerComponent, TimeFormatPipe],
                    },] },
        ];
        /** @nocollapse */
        TimePickerModule.ctorParameters = function () { return []; };
        return TimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Convert a single dimension array to a double dimension array
     * @template T
     * @param {?} items the single dimension array to convert
     * @param {?} columns the number of items each array should have
     * @return {?}
     */
    function gridify(items, columns) {
        // create a copy of array so not to effect the original
        items = items.slice(0);
        var /** @type {?} */ grid = [];
        while (items.length) {
            grid.push(items.splice(0, columns));
        }
        return grid;
    }
    /**
     * Create an array of numbers between two limits
     * @param {?} start the lower limit
     * @param {?} end the upper limit
     * @return {?}
     */
    function range(start, end) {
        var /** @type {?} */ list = [];
        for (var /** @type {?} */ idx = start; idx <= end; idx++) {
            list.push(idx);
        }
        return list;
    }
    /**
     * Create an array of dates between two points
     * @param {?} start the date to start the array
     * @param {?} end the date to end the array
     * @return {?}
     */
    function dateRange(start, end) {
        var /** @type {?} */ dates = [];
        // loop through all the days between the date range
        while (start <= end) {
            // add the date to the array
            dates.push(new Date(start));
            // move to the next day
            start.setDate(start.getDate() + 1);
        }
        return dates;
    }
    /**
     * Compare two dates to see if they are on the same day
     * @param {?} day1 the first date to compare
     * @param {?} day2 the second date to compare
     * @return {?}
     */
    function compareDays(day1, day2) {
        return day1.getDate() === day2.getDate() &&
            day1.getMonth() === day2.getMonth() &&
            day1.getFullYear() === day2.getFullYear();
    }
    /**
     * Date comparison for use primarily with distinctUntilChanged
     * @param {?} dateOne
     * @param {?} dateTwo
     * @return {?}
     */
    function dateComparator(dateOne, dateTwo) {
        return dateOne.getTime() === dateTwo.getTime();
    }
    /**
     * Timezone comparison for use primarily with distinctUntilChanged
     * @param {?} zoneOne
     * @param {?} zoneTwo
     * @return {?}
     */
    function timezoneComparator(zoneOne, zoneTwo) {
        return zoneOne.name === zoneTwo.name && zoneOne.offset === zoneTwo.offset;
    }
    /**
     * Export an array of all the available months
     */
    var /** @type {?} */ months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var /** @type {?} */ monthsShort = months.map(function (month) { return month.substring(0, 3); });
    /**
     * Export an array of all the available days of the week
     */
    var /** @type {?} */ weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    var /** @type {?} */ weekdaysShort = weekdays.map(function (weekday) { return weekday.substring(0, 3); });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerConfig = (function () {
        function DateTimePickerConfig() {
            this.showDate = true;
            this.showTime = true;
            this.showTimezone = true;
            this.showSeconds = false;
            this.showMeridian = true;
            this.showSpinners = true;
            this.weekdays = weekdaysShort;
            this.nowBtnText = 'Today';
            this.timezones = [
                { name: 'GMT-11', offset: 660 },
                { name: 'GMT-10', offset: 600 },
                { name: 'GMT-9', offset: 540 },
                { name: 'GMT-8', offset: 480 },
                { name: 'GMT-7', offset: 420 },
                { name: 'GMT-6', offset: 360 },
                { name: 'GMT-5', offset: 300 },
                { name: 'GMT-4', offset: 240 },
                { name: 'GMT-3', offset: 180 },
                { name: 'GMT-2', offset: 120 },
                { name: 'GMT-1', offset: 60 },
                { name: 'GMT', offset: 0 },
                { name: 'GMT+1', offset: -60 },
                { name: 'GMT+2', offset: -120 },
                { name: 'GMT+3', offset: -180 },
                { name: 'GMT+4', offset: -240 },
                { name: 'GMT+5', offset: -300 },
                { name: 'GMT+6', offset: -360 },
                { name: 'GMT+7', offset: -420 },
                { name: 'GMT+8', offset: -480 },
                { name: 'GMT+9', offset: -540 },
                { name: 'GMT+10', offset: -600 },
                { name: 'GMT+11', offset: -660 },
                { name: 'GMT+12', offset: -720 }
            ];
        }
        DateTimePickerConfig.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DateTimePickerConfig.ctorParameters = function () { return []; };
        return DateTimePickerConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerService = (function () {
        function DateTimePickerService(_config) {
            var _this = this;
            this._config = _config;
            this.mode$ = new BehaviorSubject.BehaviorSubject(DatePickerMode.Day);
            this.date$ = new BehaviorSubject.BehaviorSubject(new Date());
            this.timezone$ = new BehaviorSubject.BehaviorSubject(this.getCurrentTimezone());
            this.selected$ = new BehaviorSubject.BehaviorSubject(new Date());
            // the month and year to display in the viewport
            this.month$ = new BehaviorSubject.BehaviorSubject(new Date().getMonth());
            this.year$ = new BehaviorSubject.BehaviorSubject(new Date().getFullYear());
            this.showDate$ = new BehaviorSubject.BehaviorSubject(this._config.showDate);
            this.showTime$ = new BehaviorSubject.BehaviorSubject(this._config.showTime);
            this.showTimezone$ = new BehaviorSubject.BehaviorSubject(this._config.showTimezone);
            this.showSeconds$ = new BehaviorSubject.BehaviorSubject(this._config.showSeconds);
            this.showMeridian$ = new BehaviorSubject.BehaviorSubject(this._config.showMeridian);
            this.showSpinners$ = new BehaviorSubject.BehaviorSubject(this._config.showSpinners);
            this.weekdays$ = new BehaviorSubject.BehaviorSubject(this._config.weekdays);
            this.nowBtnText$ = new BehaviorSubject.BehaviorSubject(this._config.nowBtnText);
            this.timezones$ = new BehaviorSubject.BehaviorSubject(this._config.timezones);
            this.header$ = new BehaviorSubject.BehaviorSubject(null);
            this.headerEvent$ = new Subject.Subject();
            this.modeDirection = ModeDirection.None;
            // when the active date changes set the currently selected date
            this._subscription = this.selected$.pipe(operators.distinctUntilChanged(dateComparator)).subscribe(function (date) {
                // the month and year displayed in the viewport should reflect the newly selected items
                // the month and year displayed in the viewport should reflect the newly selected items
                _this.setViewportMonth(date.getMonth());
                _this.setViewportYear(date.getFullYear());
                // emit the new date to the component host
                // emit the new date to the component host
                _this.date$.next(date);
            });
        }
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMonth =
            function (month) {
                if (month < 0) {
                    this.month$.next(11);
                    this.year$.next(this.year$.value - 1);
                }
                else if (month > 11) {
                    this.month$.next(0);
                    this.year$.next(this.year$.value + 1);
                }
                else {
                    this.month$.next(month);
                }
            };
        /**
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportYear =
            function (year) {
                this.year$.next(year);
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setDate =
            function (day, month, year) {
                var /** @type {?} */ date = new Date(this.selected$.value);
                date.setDate(day);
                date.setMonth(month);
                date.setFullYear(year);
                this.selected$.next(date);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.setDateToNow =
            function () {
                this.selected$.next(new Date());
            };
        /**
         * @param {?} mode
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMode =
            function (mode) {
                this.mode$.next(mode);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToChildMode =
            function () {
                this.modeDirection = ModeDirection.Descend;
                switch (this.mode$.value) {
                    case DatePickerMode.Year:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Day);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToParentMode =
            function () {
                this.modeDirection = ModeDirection.Ascend;
                switch (this.mode$.value) {
                    case DatePickerMode.Day:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Year);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToNext =
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Next);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToPrevious =
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Previous);
            };
        /**
         * @param {?} header
         * @return {?}
         */
        DateTimePickerService.prototype.setHeader =
            function (header) {
                this.header$.next(header);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.getCurrentTimezone =
            function () {
                var /** @type {?} */ offset = new Date().getTimezoneOffset();
                return this._config.timezones.find(function (timezone) { return timezone.offset === offset; });
            };
        /**
         * @param {?} timezone
         * @return {?}
         */
        DateTimePickerService.prototype.setTimezone =
            function (timezone) {
                this.timezone$.next(timezone);
            };
        DateTimePickerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DateTimePickerService.ctorParameters = function () {
            return [
                { type: DateTimePickerConfig, },
            ];
        };
        return DateTimePickerService;
    }());
    /** @enum {number} */
    var DatePickerMode = {
        Day: 0,
        Month: 1,
        Year: 2,
    };
    DatePickerMode[DatePickerMode.Day] = "Day";
    DatePickerMode[DatePickerMode.Month] = "Month";
    DatePickerMode[DatePickerMode.Year] = "Year";
    /** @enum {number} */
    var ModeDirection = {
        None: 0,
        Ascend: 1,
        Descend: 2,
    };
    ModeDirection[ModeDirection.None] = "None";
    ModeDirection[ModeDirection.Ascend] = "Ascend";
    ModeDirection[ModeDirection.Descend] = "Descend";
    /** @enum {number} */
    var DatePickerHeaderEvent = {
        Previous: 0,
        Next: 1,
    };
    DatePickerHeaderEvent[DatePickerHeaderEvent.Previous] = "Previous";
    DatePickerHeaderEvent[DatePickerHeaderEvent.Next] = "Next";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerComponent = (function () {
        function DateTimePickerComponent(datepicker) {
            var _this = this;
            this.datepicker = datepicker;
            this.dateChange = new core.EventEmitter();
            this.timezoneChange = new core.EventEmitter();
            // expose enum to view
            this.DatePickerMode = DatePickerMode;
            this._subscription = new Subscription.Subscription();
            var /** @type {?} */ valueChange = datepicker.selected$.pipe(operators.distinctUntilChanged(dateComparator))
                .subscribe(function (date) { return _this.dateChange.emit(date); });
            var /** @type {?} */ timezoneChange = datepicker.timezone$.pipe(operators.distinctUntilChanged(timezoneComparator))
                .subscribe(function (timezone) { return _this.timezoneChange.emit(timezone); });
        }
        Object.defineProperty(DateTimePickerComponent.prototype, "showDate", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showDate$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTime", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTime$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTimezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTimezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSeconds", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSeconds$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showMeridian", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showMeridian$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSpinners", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSpinners$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "weekdays", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.weekdays$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "nowBtnText", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.nowBtnText$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezones", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezones$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "date", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!dateComparator(value, this.datepicker.selected$.value)) {
                    this.datepicker.selected$.next(new Date(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateTimePickerComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Change the date to the current date and time
         */
        /**
         * Change the date to the current date and time
         * @return {?}
         */
        DateTimePickerComponent.prototype.setToNow =
            function () {
                // set the date to the current moment
                this.datepicker.setDateToNow();
            };
        DateTimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker',
                        template: "<div class=\"calendar-container\">\n\n  <ux-date-time-picker-header></ux-date-time-picker-header>\n\n  <ng-container *ngIf=\"datepicker.showDate$ | async\" [ngSwitch]=\"datepicker.mode$ | async\">\n\n      <!-- Display days in the current month -->\n      <ux-date-time-picker-day-view *ngSwitchCase=\"DatePickerMode.Day\"></ux-date-time-picker-day-view>\n\n      <!-- Display the months in the current year -->\n      <ux-date-time-picker-month-view *ngSwitchCase=\"DatePickerMode.Month\"></ux-date-time-picker-month-view>\n\n      <!-- Display a decade -->\n      <ux-date-time-picker-year-view *ngSwitchCase=\"DatePickerMode.Year\"></ux-date-time-picker-year-view>\n\n  </ng-container>\n\n  <!-- Display a Time Picker -->\n  <ux-date-time-picker-time-view *ngIf=\"datepicker.showTime$ | async\"></ux-date-time-picker-time-view>\n\n</div>\n\n<button class=\"now-button\" aria-label=\"Set date to now\" (click)=\"setToNow()\">{{ datepicker.nowBtnText$ | async }}</button>",
                        providers: [DateTimePickerService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        DateTimePickerComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        DateTimePickerComponent.propDecorators = {
            "showDate": [{ type: core.Input },],
            "showTime": [{ type: core.Input },],
            "showTimezone": [{ type: core.Input },],
            "showSeconds": [{ type: core.Input },],
            "showMeridian": [{ type: core.Input },],
            "showSpinners": [{ type: core.Input },],
            "weekdays": [{ type: core.Input },],
            "nowBtnText": [{ type: core.Input },],
            "timezones": [{ type: core.Input },],
            "dateChange": [{ type: core.Output },],
            "timezoneChange": [{ type: core.Output },],
            "date": [{ type: core.Input },],
            "timezone": [{ type: core.Input },],
        };
        return DateTimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewService = (function () {
        function DayViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = combineLatest.combineLatest(_datepicker.month$, _datepicker.year$)
                .subscribe(function (_a) {
                var _b = __read(_a, 2), month = _b[0], year = _b[1];
                return _this.createDayGrid(month, year);
            });
        }
        /**
         * @return {?}
         */
        DayViewService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.setFocus =
            function (day, month, year) {
                this.focused$.next({ day: day, month: month, year: year });
                // update the date picker to show the required month and year
                this._datepicker.setViewportMonth(month);
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.createDayGrid =
            function (month, year) {
                var _this = this;
                // update the header
                this._datepicker.setHeader(months[month] + ' ' + year);
                // find the lower and upper boundaries
                var /** @type {?} */ start = new Date(year, month, 1);
                var /** @type {?} */ end = new Date(year, month + 1, 0);
                // we always want to show from the sunday - this may include showing some dates from the previous month
                start.setDate(start.getDate() - start.getDay());
                // we also want to make sure that the range ends on a saturday
                end.setDate(end.getDate() + (6 - end.getDay()));
                // create an array of all the days to display
                var /** @type {?} */ dates = dateRange(start, end).map(function (date) {
                    return ({
                        day: date.getDate(),
                        month: date.getMonth(),
                        year: date.getFullYear(),
                        date: date,
                        isToday: _this.isToday(date),
                        isActive: _this.isActive(date),
                        isCurrentMonth: date.getMonth() === month
                    });
                });
                // turn the dates into a grid
                var /** @type {?} */ items = gridify(dates, 7);
                this.grid$.next(items);
                // if no item has yet been focused then focus the first day of the month
                if ((this._datepicker.modeDirection === ModeDirection.None || this._datepicker.modeDirection === ModeDirection.Descend) && this.focused$.value === null) {
                    // check if the selected item is visible
                    var /** @type {?} */ selectedDay = dates.find(function (day) { return day.isCurrentMonth && day.isActive; });
                    if (selectedDay) {
                        this.setFocus(selectedDay.day, selectedDay.month, selectedDay.year);
                    }
                    else {
                        // find the first day of the month
                        var /** @type {?} */ first = dates.find(function (date) { return date.day === 1; });
                        // focus the date
                        this.setFocus(first.day, first.month, first.year);
                    }
                }
            };
        /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
        DayViewService.prototype.isToday =
            function (date) {
                return compareDays(new Date(), date);
            };
        /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
        DayViewService.prototype.isActive =
            function (date) {
                return compareDays(this._datepicker.selected$.value, date);
            };
        DayViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DayViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return DayViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewComponent = (function () {
        function DayViewComponent(datePicker, dayService) {
            var _this = this;
            this.datePicker = datePicker;
            this.dayService = dayService;
            this._subscription = datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        DayViewComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Navigate to the previous page of dates
         */
        /**
         * Navigate to the previous page of dates
         * @return {?}
         */
        DayViewComponent.prototype.previous =
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value - 1);
            };
        /**
         * Navigate to the next page of dates
         */
        /**
         * Navigate to the next page of dates
         * @return {?}
         */
        DayViewComponent.prototype.next =
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value + 1);
            };
        /**
         * Select a particular date
         * @param date the date to select
         */
        /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
        DayViewComponent.prototype.select =
            function (date) {
                // update the current date object
                this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear());
                // focus the newly selected date
                this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        DayViewComponent.prototype.trackWeekByFn =
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.trackDayByFn =
            function (index, item) {
                return item.day + " " + item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
        DayViewComponent.prototype.focusDate =
            function (item, dayOffset) {
                // determine the date of the day
                var /** @type {?} */ target = new Date(item.date.setDate(item.date.getDate() + dayOffset));
                // identify which date should be focused
                this.dayService.setFocus(target.getDate(), target.getMonth(), target.getFullYear());
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.getTabbable =
            function (item) {
                var /** @type {?} */ focused = this.dayService.focused$.value;
                var /** @type {?} */ grid = this.dayService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused day is visible
                    var /** @type {?} */ isFocusedDayVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.day === focused.day && _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedDayVisible) {
                        return focused.day === item.day && focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable day then check if there is a selected day
                var /** @type {?} */ isSelectedDayVisible = !!grid.find(function (row) { return !!row.find(function (day) { return day.isActive; }); });
                if (isSelectedDayVisible) {
                    return item.isActive;
                }
                // otherwise make the first day tabbable
                return item.day === 1;
            };
        DayViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-day-view',
                        template: "<table class=\"calendar\">\n    <thead>\n        <tr>\n            <th *ngFor=\"let day of datePicker.weekdays$ | async\" class=\"weekday\" [attr.aria-label]=\"day\">{{ day }}</th>\n        </tr>\n    </thead>\n\n    <tbody role=\"grid\">\n        <tr role=\"row\" *ngFor=\"let row of dayService.grid$ | async; trackBy: trackWeekByFn\">\n\n            <td *ngFor=\"let item of row; trackBy: trackDayByFn\" class=\"date-cell\" role=\"gridcell\">\n\n                <button class=\"date-button\"\n                        [focusIf]=\"(dayService.focused$ | async)?.day === item.day && (dayService.focused$ | async)?.month === item.month && (dayService.focused$ | async)?.year === item.year\"\n                        [attr.aria-label]=\"item.date | date\"\n                        [attr.aria-selected]=\"item.isActive\"\n                        [attr.aria-hidden]=\"!item.isCurrentMonth\"\n                        [class.current]=\"item.isToday\"\n                        [class.active]=\"item.isActive\"\n                        [class.preview]=\"!item.isCurrentMonth\"\n                        [tabindex]=\"getTabbable(item) ? 0 : -1\"\n                        (click)=\"select(item.date); $event.stopPropagation()\"\n                        (keydown.ArrowLeft)=\"focusDate(item, -1); $event.preventDefault()\"\n                        (keydown.ArrowRight)=\"focusDate(item, 1); $event.preventDefault()\"\n                        (keydown.ArrowUp)=\"focusDate(item, -7); $event.preventDefault()\"\n                        (keydown.ArrowDown)=\"focusDate(item, 7); $event.preventDefault()\">\n\n                    {{ item.date.getDate() }}\n                </button>\n\n            </td>\n        </tr>\n    </tbody>\n</table>",
                        providers: [DayViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        DayViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
                { type: DayViewService, },
            ];
        };
        return DayViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HeaderComponent = (function () {
        function HeaderComponent(datepicker) {
            this.datepicker = datepicker;
            this.canAscend$ = this.datepicker.mode$.pipe(operators.map(function (mode) { return mode !== DatePickerMode.Year; }));
            this.mode$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Day';
                    case DatePickerMode.Month:
                        return 'Month';
                    case DatePickerMode.Year:
                        return 'Year';
                }
            }));
            this.headerAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Switch to show months in the year';
                    case DatePickerMode.Month:
                        return 'Switch to show years in the decade';
                    case DatePickerMode.Year:
                        return '';
                }
            }));
            this.previousAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Previous month';
                    case DatePickerMode.Month:
                        return 'Previous year';
                    case DatePickerMode.Year:
                        return 'Previous decade';
                }
            }));
            this.nextAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Next month';
                    case DatePickerMode.Month:
                        return 'Next year';
                    case DatePickerMode.Year:
                        return 'Next decade';
                }
            }));
        }
        /**
         * @return {?}
         */
        HeaderComponent.prototype.previous =
            function () {
                this.datepicker.goToPrevious();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.ascend =
            function () {
                this.datepicker.goToParentMode();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.next =
            function () {
                this.datepicker.goToNext();
            };
        HeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-header',
                        template: "<header class=\"header\">\n\n  <button class=\"header-navigation\"\n          (click)=\"previous(); $event.stopPropagation()\"\n          [attr.aria-label]=\"previousAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-previous\"></i>\n  </button>\n\n  <button class=\"header-title\"\n          [attr.aria-label]=\"headerAria$ | async\"\n          [class.active]=\"canAscend$ | async\"\n          (click)=\"ascend(); $event.stopPropagation()\"\n          [tabindex]=\"(canAscend$ | async) ? 0 : -1\">\n       {{ datepicker.header$ | async }}\n  </button>\n\n  <button class=\"header-navigation\"\n          (click)=\"next(); $event.stopPropagation()\"\n          [attr.aria-label]=\"nextAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-next\"></i>\n  </button>\n</header>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        HeaderComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return HeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewService = (function () {
        function MonthViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = _datepicker.year$.subscribe(function (year) { return _this.createMonthGrid(year); });
        }
        /**
         * @return {?}
         */
        MonthViewService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.setFocus =
            function (month, year) {
                this.focused$.next({ month: month, year: year });
                // update the viewport to ensure focused month is visible
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.createMonthGrid =
            function (year) {
                // update the header
                this._datepicker.setHeader(year.toString());
                // get the current year and month
                var /** @type {?} */ currentMonth = new Date().getMonth();
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // get the currently selected month
                var /** @type {?} */ activeMonth = this._datepicker.selected$.value.getMonth();
                var /** @type {?} */ activeYear = this._datepicker.selected$.value.getFullYear();
                // create a 4x3 grid of month numbers
                var /** @type {?} */ months$$1 = range(0, 11).map(function (month) {
                    return {
                        name: monthsShort[month],
                        month: month,
                        year: year,
                        isCurrentMonth: year === currentYear && month === currentMonth,
                        isActiveMonth: year === activeYear && month === activeMonth
                    };
                });
                // map these to the appropriate format
                var /** @type {?} */ items = gridify(months$$1, 4);
                // update the grid
                this.grid$.next(items);
                // if there is no focused month select the first one
                if (this._datepicker.modeDirection === ModeDirection.Descend && this.focused$.value === null) {
                    // check if the selected month is in view
                    var /** @type {?} */ selectedMonth = months$$1.find(function (month) { return month.isActiveMonth; });
                    this.setFocus(selectedMonth ? selectedMonth.month : 0, year);
                }
            };
        MonthViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MonthViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return MonthViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewComponent = (function () {
        function MonthViewComponent(_datePicker, monthService) {
            var _this = this;
            this._datePicker = _datePicker;
            this.monthService = monthService;
            this._subscription = _datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        MonthViewComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Go to the previous year
         */
        /**
         * Go to the previous year
         * @return {?}
         */
        MonthViewComponent.prototype.previous =
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value - 1);
            };
        /**
         * Go to the next year
         */
        /**
         * Go to the next year
         * @return {?}
         */
        MonthViewComponent.prototype.next =
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value + 1);
            };
        /**
         * Select a month in the calendar
         * @param month the index of the month to select
         */
        /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
        MonthViewComponent.prototype.select =
            function (month) {
                this._datePicker.setViewportMonth(month);
                // show the day picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
        MonthViewComponent.prototype.focusMonth =
            function (item, monthOffset) {
                var /** @type {?} */ targetMonth = item.month + monthOffset;
                var /** @type {?} */ targetYear = item.year;
                if (targetMonth < 0) {
                    targetMonth += 12;
                    targetYear -= 1;
                }
                if (targetMonth >= 12) {
                    targetMonth -= 12;
                    targetYear += 1;
                }
                this.monthService.setFocus(targetMonth, targetYear);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        MonthViewComponent.prototype.trackRowByFn =
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.trackMonthByFn =
            function (index, item) {
                return item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.getTabbable =
            function (item) {
                var /** @type {?} */ focused = this.monthService.focused$.value;
                var /** @type {?} */ grid = this.monthService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused month is visible
                    var /** @type {?} */ isFocusedMonthVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedMonthVisible) {
                        return focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable month then check if there is a selected month
                var /** @type {?} */ isSelectedMonthVisible = !!grid.find(function (row) { return !!row.find(function (month) { return month.isActiveMonth; }); });
                if (isSelectedMonthVisible) {
                    return item.isActiveMonth;
                }
                // otherwise make the first month tabbable
                return item.month === 0;
            };
        MonthViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-month-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" *ngFor=\"let row of monthService.grid$ | async; trackBy: trackRowByFn\" role=\"row\">\n\n    <button role=\"gridcell\"\n         class=\"calendar-item\"\n         *ngFor=\"let item of row; trackBy: trackMonthByFn\"\n         [focusIf]=\"(monthService.focused$ | async)?.month === item.month && (monthService.focused$ | async)?.year === item.year\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\"\n         [attr.aria-label]=\"item.name + ' ' + item.year\"\n         [attr.aria-selected]=\"item.isActiveMonth\"\n         [class.active]=\"item.isActiveMonth\"\n         [class.current]=\"item.isCurrentMonth\"\n         (click)=\"select(item.month); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusMonth(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusMonth(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusMonth(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusMonth(item, 4); $event.preventDefault()\">\n         {{ item.name }}\n    </button>\n  </div>\n</div>\n",
                        providers: [MonthViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MonthViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
                { type: MonthViewService, },
            ];
        };
        return MonthViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeViewComponent = (function () {
        function TimeViewComponent(datepicker) {
            this.datepicker = datepicker;
        }
        /**
         * @param {?} name
         * @return {?}
         */
        TimeViewComponent.prototype.selectTimezone =
            function (name) {
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                // find matching timezone
                var /** @type {?} */ timezone = timezones.find(function (_timezone) { return _timezone.name === name; });
                if (timezone) {
                    this.datepicker.setTimezone(timezone);
                }
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.incrementTimezone =
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone + 1] ? timezones[currentZone + 1] : timezones[currentZone]);
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.decrementTimezone =
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone - 1] ? timezones[currentZone - 1] : timezones[currentZone]);
            };
        TimeViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-time-view',
                        template: "<ux-time-picker *ngIf=\"datepicker.showTime$ | async\"\n    [value]=\"datepicker.selected$ | async\"\n    (valueChange)=\"datepicker.selected$.next($event)\"\n    [showSeconds]=\"datepicker.showSeconds$ | async\"\n    [showMeridian]=\"datepicker.showMeridian$ | async\"\n    [showSpinners]=\"datepicker.showSpinners$ | async\">\n</ux-time-picker>\n\n<ng-container *ngIf=\"datepicker.showTimezone$ | async\">\n\n    <div class=\"time-zone-picker\" *ngIf=\"datepicker.showSpinners$ | async\">\n\n        <ux-spin-button\n            class=\"time-zone-spinner\"\n            [value]=\"(datepicker.timezone$ | async).name\"\n            [readOnly]=\"true\"\n            (increment)=\"incrementTimezone()\"\n            (decrement)=\"decrementTimezone()\"\n            inputAriaLabel=\"Time Zone\"\n            incrementAriaLabel=\"Switch to the next time zone\"\n            decrementAriaLabel=\"Switch to the previous time zone\">\n        </ux-spin-button>\n    </div>\n\n    <div class=\"time-zone-picker\" *ngIf=\"!(datepicker.showSpinners$ | async)\">\n\n        <select class=\"form-control time-zone-select\"\n                tabindex=\"0\"\n                [ngModel]=\"(datepicker.timezone$ | async).name\"\n                (ngModelChange)=\"selectTimezone($event)\"\n                aria-label=\"Timezone\"\n                [attr.aria-valuenow]=\"(datepicker.timezone$ | async).name\">\n\n            <option *ngFor=\"let zone of datepicker.timezones$ | async\"\n                    [selected]=\"zone.name === (datepicker.timezone$ | async).name\"\n                    [value]=\"zone.name\">\n                {{ zone?.name }}\n            </option>\n\n        </select>\n    </div>\n\n</ng-container>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        TimeViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return TimeViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewService = (function () {
        function YearViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._year = new Date().getFullYear();
            this._subscription = new Subscription.Subscription();
            var /** @type {?} */ year = _datepicker.year$.subscribe(function (_year) { return _this.createYearGrid(_year); });
            var /** @type {?} */ event = _datepicker.headerEvent$
                .subscribe(function (_event) { return _event === DatePickerHeaderEvent.Next ? _this.goToNextDecade() : _this.goToPreviousDecade(); });
            this._subscription.add(year);
            this._subscription.add(event);
        }
        /**
         * @return {?}
         */
        YearViewService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.setFocus =
            function (year) {
                this.focused$.next(year);
                this.createYearGrid(year);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToPreviousDecade =
            function () {
                this.createYearGrid(this._year - 10);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToNextDecade =
            function () {
                this.createYearGrid(this._year + 10);
            };
        /**
         * @param {?=} year
         * @return {?}
         */
        YearViewService.prototype.createYearGrid =
            function (year) {
                var _this = this;
                if (year === void 0) {
                    year = this._year;
                }
                this._year = year;
                // get the years to display
                var /** @type {?} */ decade = this.getDecade(year);
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // produce items in the correct format
                var /** @type {?} */ items = decade.range.map(function (_year) {
                    return {
                        year: _year,
                        isCurrentYear: _year === currentYear,
                        isActiveYear: _year === _this._datepicker.year$.value
                    };
                });
                // update the header text
                this._datepicker.setHeader(decade.start + ' - ' + decade.end);
                // create the grid
                this.grid$.next(gridify(items, 4));
            };
        /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.getDecade =
            function (year) {
                // figure the start and end points
                var /** @type {?} */ start = (year - (year % 10));
                var /** @type {?} */ end = start + 9;
                // create an array containing all the numbers between the start and end points
                return { start: start, end: end, range: range(start, end) };
            };
        YearViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        YearViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return YearViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewComponent = (function () {
        function YearViewComponent(_datePicker, yearService) {
            this._datePicker = _datePicker;
            this.yearService = yearService;
        }
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewComponent.prototype.select =
            function (year) {
                this._datePicker.setViewportYear(year);
                // show the month picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
        YearViewComponent.prototype.focusYear =
            function (item, yearOffset) {
                this.yearService.setFocus(item.year + yearOffset);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        YearViewComponent.prototype.trackRowByFn =
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.trackYearByFn =
            function (index, item) {
                return item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.getTabbable =
            function (item) {
                var /** @type {?} */ focused = this.yearService.focused$.value;
                var /** @type {?} */ grid = this.yearService.grid$.value;
                // if there is a focused year check if this is it
                if (focused) {
                    // check if the focused year is visible
                    var /** @type {?} */ isFocusedYearVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.year === focused; }); });
                    if (isFocusedYearVisible) {
                        return focused === item.year;
                    }
                }
                // if there is no focusable year then check if there is a selected year
                var /** @type {?} */ isSelectedYearVisible = !!grid.find(function (row) { return !!row.find(function (year) { return year.isActiveYear; }); });
                if (isSelectedYearVisible) {
                    return item.isActiveYear;
                }
                // otherwise make the first month tabbable
                return grid[0][0].year === item.year;
            };
        YearViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-year-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" role=\"row\" *ngFor=\"let row of yearService.grid$ | async; trackBy: trackRowByFn\">\n\n    <button *ngFor=\"let item of row; trackBy: trackYearByFn\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         [focusIf]=\"(yearService.focused$ | async) === item.year\"\n         [attr.aria-label]=\"item.year\"\n         [attr.aria-selected]=\"item.isActiveYear\"\n         [class.current]=\"item.isCurrentYear\"\n         [class.active]=\"item.isActiveYear\"\n         (click)=\"select(item.year); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusYear(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusYear(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusYear(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusYear(item, 4); $event.preventDefault()\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\">\n         {{ item.year }}\n    </button>\n  </div>\n</div>\n",
                        providers: [YearViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        YearViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
                { type: YearViewService, },
            ];
        };
        return YearViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfDirective = (function () {
        function FocusIfDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.focusIfDelay = 0;
            this._timeout = null;
        }
        Object.defineProperty(FocusIfDirective.prototype, "focusIf", {
            set: /**
             * @param {?} focus
             * @return {?}
             */ function (focus) {
                var _this = this;
                // if a timeout is pending then cancel it
                if (!focus && this._timeout !== null) {
                    clearTimeout(this._timeout);
                    this._timeout = null;
                }
                if (focus && this._timeout === null) {
                    this._timeout = window.setTimeout(function () {
                        _this._elementRef.nativeElement.focus();
                        _this._timeout = null;
                    }, this.focusIfDelay);
                }
            },
            enumerable: true,
            configurable: true
        });
        FocusIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[focusIf]'
                    },] },
        ];
        /** @nocollapse */
        FocusIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        FocusIfDirective.propDecorators = {
            "focusIfDelay": [{ type: core.Input },],
            "focusIf": [{ type: core.Input },],
        };
        return FocusIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfModule = (function () {
        function FocusIfModule() {
        }
        FocusIfModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FocusIfDirective],
                        declarations: [FocusIfDirective]
                    },] },
        ];
        /** @nocollapse */
        FocusIfModule.ctorParameters = function () { return []; };
        return FocusIfModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerModule = (function () {
        function DateTimePickerModule() {
        }
        DateTimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            TimePickerModule,
                            SpinButtonModule,
                            FocusIfModule
                        ],
                        exports: [DateTimePickerComponent],
                        declarations: [DateTimePickerComponent, HeaderComponent, DayViewComponent, MonthViewComponent, YearViewComponent, TimeViewComponent],
                        providers: [
                            DateTimePickerConfig
                        ]
                    },] },
        ];
        /** @nocollapse */
        DateTimePickerModule.ctorParameters = function () { return []; };
        return DateTimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxComponent = (function () {
        function EboxComponent() {
        }
        EboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-ebox',
                        template: "<div class=\"ux-ebox-header\">\n    <ng-content select=\"ux-ebox-header\"></ng-content>\n</div>\n\n<div class=\"ux-ebox-content\">\n    <ng-content select=\"ux-ebox-content\"></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        EboxComponent.ctorParameters = function () { return []; };
        return EboxComponent;
    }());
    var EboxHeaderDirective = (function () {
        function EboxHeaderDirective() {
        }
        EboxHeaderDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-header'
                    },] },
        ];
        /** @nocollapse */
        EboxHeaderDirective.ctorParameters = function () { return []; };
        return EboxHeaderDirective;
    }());
    var EboxContentDirective = (function () {
        function EboxContentDirective() {
        }
        EboxContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-content'
                    },] },
        ];
        /** @nocollapse */
        EboxContentDirective.ctorParameters = function () { return []; };
        return EboxContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxModule = (function () {
        function EboxModule() {
        }
        EboxModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [EboxComponent, EboxContentDirective, EboxHeaderDirective],
                        declarations: [EboxComponent, EboxContentDirective, EboxHeaderDirective]
                    },] },
        ];
        /** @nocollapse */
        EboxModule.ctorParameters = function () { return []; };
        return EboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTooltipId = 0;
    var TooltipComponent = (function () {
        function TooltipComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Define a unique id for each tooltip
             */
            this.id = "ux-tooltip-" + ++uniqueTooltipId;
            /**
             * Define the tooltip role
             */
            this.role = 'tooltip';
            /**
             * Allow a custom class to be added to the tooltip to allow custom styling
             */
            this.customClass = '';
            /**
             * Indicates whether or not the content is a string or a TemplateRef
             */
            this.isTemplateRef = false;
            /**
             * Emit when the tooltip need to update it's position
             */
            this.reposition$ = new Subject.Subject();
        }
        /** Cleanup after the component is destroyed */
        /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
        TooltipComponent.prototype.ngOnDestroy =
            function () {
                this.reposition$.complete();
            };
        /** Inform the parent directive that it needs to recalulate the position */
        /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
        TooltipComponent.prototype.reposition =
            function () {
                this.reposition$.next();
            };
        /** This will update the content of the tooltip and trigger change detection */
        /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
        TooltipComponent.prototype.setContent =
            function (content) {
                this.content = content;
                this.isTemplateRef = content instanceof core.TemplateRef;
                this._changeDetectorRef.markForCheck();
            };
        /** This will update the tooltip placement and trigger change detection */
        /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
        TooltipComponent.prototype.setPlacement =
            function (placement) {
                if (!placement) {
                    return;
                }
                this.placement = placement;
                this._changeDetectorRef.markForCheck();
            };
        /** This will set a custom class on the tooltip and trigger change detection */
        /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
        TooltipComponent.prototype.setClass =
            function (customClass) {
                if (!customClass) {
                    return;
                }
                this.customClass = customClass;
                this._changeDetectorRef.markForCheck();
            };
        /** Updates the context used by the TemplateRef */
        /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
        TooltipComponent.prototype.setContext =
            function (context) {
                if (!context) {
                    return;
                }
                this.context = context;
                this._changeDetectorRef.markForCheck();
            };
        /** Specify the tooltip role attribute */
        /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
        TooltipComponent.prototype.setRole =
            function (role) {
                if (!role) {
                    return;
                }
                this.role = role;
                this._changeDetectorRef.markForCheck();
            };
        TooltipComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tooltip',
                        template: "<div class=\"tooltip in\" [id]=\"id\" [attr.role]=\"role\" [ngClass]=\"[placement, customClass]\">\n    <div class=\"tooltip-arrow\"></div>\n    <div class=\"tooltip-inner\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        TooltipComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef, },
            ];
        };
        return TooltipComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipService = (function () {
        function TooltipService() {
            this.shown$ = new Subject.Subject();
        }
        TooltipService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TooltipService.ctorParameters = function () { return []; };
        return TooltipService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipDirective = (function () {
        function TooltipDirective(_elementRef, _viewContainerRef, _overlay, _scrollDispatcher, _changeDetectorRef, _renderer, _tooltipService) {
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._overlay = _overlay;
            this._scrollDispatcher = _scrollDispatcher;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._tooltipService = _tooltipService;
            /**
             * All the user to add a custom class to the tooltip
             */
            this.customClass = '';
            /**
             * All the user to add a role to the tooltip - default is tooltip
             */
            this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            this.context = {};
            /**
             * Delay the showing of the tooltip by a number of miliseconds
             */
            this.delay = 0;
            /**
             * Programmatically show and hide the tooltip
             */
            this.isOpen = false;
            /**
             * Customize how the tooltip should be positioned relative to the element
             */
            this.placement = 'top';
            /**
             * Specify which events should show the tooltip
             */
            this.showTriggers = ['mouseenter', 'focus'];
            /**
             * Specify which events should hide the tooltip
             */
            this.hideTriggers = ['mouseleave', 'blur'];
            /**
             * Emits an event when the tooltip is shown
             */
            this.shown = new core.EventEmitter();
            /**
             * Emits a event when the tooltip is hidden
             */
            this.hidden = new core.EventEmitter();
            /**
             * Allow two way binding to track the visibility of the tooltip
             */
            this.isOpenChange = new core.EventEmitter();
            /**
             * Keep track of the tooltip visibility
             */
            this.isVisible = false;
            /**
             * This will emit when the directive is destroyed allowing us to unsubscribe all subscriptions automatically
             */
            this._onDestroy = new Subject.Subject();
            /**
             * Internally store the type of this component - usual for distinctions when extending this class
             */
            this._type = 'tooltip';
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        TooltipDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                // set up show and hide event triggers
                fromEvent.fromEvent(this._elementRef.nativeElement, 'click').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClick.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseEnter.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseleave').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseLeave.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'focus').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onFocus.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'blur').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onBlur.bind(this));
                // when any other tooltips open hide this one
                this._tooltipService.shown$.pipe(operators.filter(function () { return _this._type === 'tooltip'; }), operators.filter(function (tooltip$$1) { return tooltip$$1 !== _this._instance; }), operators.takeUntil(this._onDestroy)).subscribe(this.hide.bind(this));
                // if the tooltip should be initially visible then open it
                if (this.isOpen) {
                    this.show();
                }
            };
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        TooltipDirective.prototype.ngOnChanges =
            function (changes) {
                // we can ignore the first change as it's handled in ngOnInit
                if (changes["isOpen"] && !changes["isOpen"].firstChange && changes["isOpen"].currentValue !== this.isVisible) {
                    changes["isOpen"].currentValue ? this.show() : this.hide();
                }
                // destroy the overlay ref so a new correctly positioned instance will be created next time
                if (changes["placement"]) {
                    this.destroyOverlay();
                }
                if (this._instance && changes["placement"]) {
                    this._instance.setPlacement(changes["placement"].currentValue);
                }
                if (this._instance && changes["content"]) {
                    this._instance.setContent(changes["content"].currentValue);
                }
                if (this._instance && changes["customClass"]) {
                    this._instance.setClass(changes["customClass"].currentValue);
                }
                if (this._instance && changes["context"]) {
                    this._instance.setContext(changes["context"].currentValue);
                }
                if (this._instance && changes["role"]) {
                    this._instance.setContext(changes["role"].currentValue);
                }
            };
        /** Ensure we clean up after ourselves */
        /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
        TooltipDirective.prototype.ngOnDestroy =
            function () {
                // ensure we close the tooltip when the host is destroyed
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._instance = null;
                }
                // emit this event to automatically unsubscribe from all subscriptions
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Make the tooltip open */
        /**
         * Make the tooltip open
         * @return {?}
         */
        TooltipDirective.prototype.show =
            function () {
                var _this = this;
                // if the tooltip is disabled then do nothing
                if (this.disabled || this.isVisible || this._showTimeoutId || !this.content) {
                    return;
                }
                // delay the show by the delay amount
                this._showTimeoutId = window.setTimeout(function () {
                    // create the tooltip and get the overlay ref
                    var /** @type {?} */ overlayRef = _this.createOverlay();
                    // create the portal to create the tooltip component
                    // create the portal to create the tooltip component
                    _this._portal = _this.createPortal();
                    _this._instance = _this.createInstance(overlayRef);
                    // watch for any changes to the content
                    // watch for any changes to the content
                    _this._instance.reposition$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.reposition.bind(_this));
                    // store the visible state
                    // store the visible state
                    _this.isVisible = true;
                    // ensure the overlay has the correct initial position
                    // ensure the overlay has the correct initial position
                    _this.reposition();
                    // emit the show events
                    // emit the show events
                    _this.shown.emit();
                    _this.isOpenChange.next(true);
                    // clear the interval id
                    // clear the interval id
                    _this._showTimeoutId = null;
                    // emit the show event to close any other tooltips
                    // emit the show event to close any other tooltips
                    _this._tooltipService.shown$.next(_this._instance);
                    // ensure change detection is run
                    // ensure change detection is run
                    _this._changeDetectorRef.detectChanges();
                }, this.delay);
            };
        /** If a tooltip exists and is visible, hide it */
        /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
        TooltipDirective.prototype.hide =
            function () {
                // if we are waiting to show a tooltip then cancel the pending timeout
                if (this._showTimeoutId) {
                    clearTimeout(this._showTimeoutId);
                    this._showTimeoutId = null;
                    return;
                }
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                this.setAriaDescribedBy(null);
                this._instance = null;
                // store the visible state
                this.isVisible = false;
                // emit the hide events
                this.hidden.emit();
                this.isOpenChange.next(false);
                // ensure change detection is run
                this._changeDetectorRef.detectChanges();
            };
        /** Toggle the visibility of the tooltip */
        /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
        TooltipDirective.prototype.toggle =
            function () {
                this.isVisible ? this.hide() : this.show();
            };
        /** Recalculate the position of the popover */
        /**
         * Recalculate the position of the popover
         * @return {?}
         */
        TooltipDirective.prototype.reposition =
            function () {
                if (this.isVisible && this._overlayRef) {
                    this._overlayRef.updatePosition();
                }
            };
        /** Create an instance from the overlay ref - allows overriding and additional logic here */
        /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
        TooltipDirective.prototype.createInstance =
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                return instance;
            };
        /** Create the component portal - allows overriding to allow other portals eg. popovers */
        /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
        TooltipDirective.prototype.createPortal =
            function () {
                return this._portal || new portal.ComponentPortal(TooltipComponent, this._viewContainerRef);
            };
        /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
        TooltipDirective.prototype.createOverlay =
            function () {
                // if the tooltip has already been created then just return the existing instance
                if (this._overlayRef) {
                    return this._overlayRef;
                }
                // configure the tooltip
                var /** @type {?} */ strategy = this._overlay.position()
                    .connectedTo(this._elementRef, this.getOrigin(), this.getOverlayPosition());
                // correctly handle scrolling
                var /** @type {?} */ scrollableAncestors = this._scrollDispatcher
                    .getAncestorScrollContainers(this._elementRef);
                strategy.withScrollableContainers(scrollableAncestors);
                this._overlayRef = this._overlay.create({
                    positionStrategy: strategy,
                    panelClass: 'ux-overlay-pane',
                    scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                    hasBackdrop: false
                });
                return this._overlayRef;
            };
        /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
        TooltipDirective.prototype.destroyOverlay =
            function () {
                // destroy the existing overlay
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
                this.isVisible = false;
            };
        /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOrigin =
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top' || this.placement == 'bottom') {
                    return { originX: 'center', originY: this.placement };
                }
                else if (this.placement == 'left') {
                    return { originX: 'start', originY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { originX: 'end', originY: 'center' };
                }
            };
        /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOverlayPosition =
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top') {
                    return { overlayX: 'center', overlayY: 'bottom' };
                }
                else if (this.placement == 'bottom') {
                    return { overlayX: 'center', overlayY: 'top' };
                }
                else if (this.placement == 'left') {
                    return { overlayX: 'end', overlayY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { overlayX: 'start', overlayY: 'center' };
                }
            };
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         **/
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
        TooltipDirective.prototype.includes =
            function (array, value) {
                return Array.isArray(array) && !!array.find(function (item) { return item === value; });
            };
        /** Handle the click event - show or hide accordingly */
        /**
         * Handle the click event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onClick =
            function (event) {
                // if its not visible and click is a show trigger open it
                if (!this.isVisible && this.includes(this.showTriggers, 'click')) {
                    return this.show();
                }
                // if its visible and click is a hide trigger close it
                if (this.isVisible && this.includes(this.hideTriggers, 'click')) {
                    return this.hide();
                }
            };
        /** Handle the mouse enter event - show or hide accordingly */
        /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseEnter =
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'mouseenter')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the mouse leave event - show or hide accordingly */
        /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseLeave =
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'mouseleave')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /** Handle the focus event - show or hide accordingly */
        /**
         * Handle the focus event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onFocus =
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'focus')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the blur event - show or hide accordingly */
        /**
         * Handle the blur event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onBlur =
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'blur')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /**
         * Determine if the trigger element is focused
         * @return {?}
         */
        TooltipDirective.prototype.isFocused =
            function () {
                return document.activeElement === this._elementRef.nativeElement;
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        TooltipDirective.prototype.setAriaDescribedBy =
            function (id) {
                if (id === null) {
                    this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
                }
                else {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', id);
                }
            };
        TooltipDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTooltip]',
                        exportAs: 'ux-tooltip'
                    },] },
        ];
        /** @nocollapse */
        TooltipDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.ViewContainerRef, },
                { type: overlay.Overlay, },
                { type: overlay.ScrollDispatcher, },
                { type: core.ChangeDetectorRef, },
                { type: core.Renderer2, },
                { type: TooltipService, },
            ];
        };
        TooltipDirective.propDecorators = {
            "content": [{ type: core.Input, args: ['uxTooltip',] },],
            "disabled": [{ type: core.Input, args: ['tooltipDisabled',] },],
            "customClass": [{ type: core.Input, args: ['tooltipClass',] },],
            "role": [{ type: core.Input, args: ['tooltipRole',] },],
            "context": [{ type: core.Input, args: ['tooltipContext',] },],
            "delay": [{ type: core.Input, args: ['tooltipDelay',] },],
            "isOpen": [{ type: core.Input },],
            "placement": [{ type: core.Input },],
            "showTriggers": [{ type: core.Input },],
            "hideTriggers": [{ type: core.Input },],
            "shown": [{ type: core.Output },],
            "hidden": [{ type: core.Output },],
            "isOpenChange": [{ type: core.Output },],
        };
        return TooltipDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipModule = (function () {
        function TooltipModule() {
        }
        TooltipModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule
                        ],
                        exports: [TooltipDirective],
                        declarations: [TooltipComponent, TooltipDirective],
                        providers: [TooltipService],
                        entryComponents: [TooltipComponent]
                    },] },
        ];
        /** @nocollapse */
        TooltipModule.ctorParameters = function () { return []; };
        return TooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadOptionEvent = (function () {
        function TypeaheadOptionEvent(option) {
            this.option = option;
        }
        return TypeaheadOptionEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadKeyService = (function () {
        function TypeaheadKeyService() {
        }
        /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
        TypeaheadKeyService.prototype.handleKey =
            function (event, typeahead) {
                if (typeahead) {
                    switch (event.key) {
                        case 'ArrowUp':
                        case 'Up':
                            if (!typeahead.open) {
                                typeahead.open = true;
                            }
                            else {
                                typeahead.moveHighlight(-1);
                            }
                            event.preventDefault();
                            break;
                        case 'ArrowDown':
                        case 'Down':
                            if (!typeahead.open) {
                                typeahead.open = true;
                            }
                            else {
                                typeahead.moveHighlight(1);
                            }
                            event.preventDefault();
                            break;
                        case 'Escape':
                        case 'Esc':
                            typeahead.open = false;
                            break;
                        case 'Enter':
                            if (typeahead.selectOnEnter) {
                                typeahead.selectHighlighted();
                            }
                    }
                }
            };
        TypeaheadKeyService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TypeaheadKeyService.ctorParameters = function () { return []; };
        return TypeaheadKeyService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadService = (function () {
        function TypeaheadService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlightedElement$ = new BehaviorSubject.BehaviorSubject(null);
        }
        TypeaheadService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TypeaheadService.ctorParameters = function () { return []; };
        return TypeaheadService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId = 0;
    var TypeaheadComponent = (function () {
        function TypeaheadComponent(typeaheadElement, _service) {
            var _this = this;
            this.typeaheadElement = typeaheadElement;
            this._service = _service;
            this.id = "ux-typeahead-" + ++uniqueId;
            this.openChange = new core.EventEmitter();
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiselectable = false;
            this.openOnFilterChange = true;
            this.pageSize = 20;
            this.selectFirst = true;
            this.selectOnEnter = false;
            this.loading = false;
            this.optionSelected = new core.EventEmitter();
            this.highlightedChange = new core.EventEmitter();
            this.highlightedElementChange = new core.EventEmitter();
            this.visibleOptions$ = new BehaviorSubject.BehaviorSubject([]);
            this.clicking = false;
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
            this.highlightedKey = null;
            this._onDestroy = new Subject.Subject();
            this.optionApi = {
                getKey: this.getKey.bind(this),
                getDisplay: this.getDisplay.bind(this),
                getDisplayHtml: this.getDisplayHtml.bind(this)
            };
            this.loadOptionsCallback = function (pageNum, pageSize, filter) {
                if (typeof _this.options === 'function') {
                    // Invoke the callback which may return an array or a promise.
                    var /** @type {?} */ arrayOrPromise = _this.options(pageNum, pageSize, filter);
                    // Map the results to an array of TypeaheadVisibleOption.
                    return Promise.resolve(arrayOrPromise).then(function (newOptions) {
                        if (!Array.isArray(newOptions)) {
                            return newOptions;
                        }
                        return newOptions.map(function (option) {
                            return {
                                value: option,
                                key: _this.getKey(option)
                            };
                        });
                    });
                }
                return null;
            };
            this._service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.openChange.emit(next);
                if (next) {
                    _this.initOptions();
                }
            });
            this.highlighted$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.highlightedKey = next ? next.key : null;
                _this.highlightedChange.emit(next ? next.value : null);
            });
            combineLatest.combineLatest(this._service.open$, this._service.highlightedElement$, this.visibleOptions$)
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (_a) {
                var _b = __read(_a, 3), open = _b[0], highlightedElement = _b[1], visibleOptions = _b[2];
                _this.highlightedElementChange.emit(open && visibleOptions.length > 0 ? highlightedElement : null);
            });
        }
        Object.defineProperty(TypeaheadComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._service.open$.getValue();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "highlighted", {
            get: /**
             * @return {?}
             */ function () {
                var /** @type {?} */ value = this.highlighted$.getValue();
                return value ? value.value : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnChanges =
            function (changes) {
                // Open the dropdown if the filter value updates
                if (changes["filter"]) {
                    if (this.openOnFilterChange && changes["filter"].currentValue && changes["filter"].currentValue.length > 0) {
                        this.open = true;
                    }
                }
                // Re-filter visibleOptions
                this.updateOptions();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mousedownHandler =
            function () {
                this.clicking = true;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mouseupHandler =
            function () {
                this.clicking = false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TypeaheadComponent.prototype.optionMousedownHandler =
            function (event) {
                // Workaround to prevent focus changing when an option is clicked
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.optionClickHandler =
            function (event, option) {
                this.select(option);
            };
        /**
         * Returns the unique key value of the given option.
         */
        /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getKey =
            function (option) {
                if (typeof this.key === 'function') {
                    return this.key(option);
                }
                if (typeof this.key === 'string' && option && option.hasOwnProperty(this.key)) {
                    return option[(this.key)];
                }
                return this.getDisplay(option);
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplay =
            function (option) {
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param option
         */
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplayHtml =
            function (option) {
                var /** @type {?} */ displayText = this.getDisplay(option).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                var /** @type {?} */ displayHtml = displayText;
                if (this.filter) {
                    var /** @type {?} */ length_1 = this.filter.length;
                    var /** @type {?} */ matchIndex = displayText.toLowerCase().indexOf(this.filter.toLowerCase());
                    if (matchIndex >= 0) {
                        var /** @type {?} */ highlight = "<span class=\"ux-filter-match\">" + displayText.substr(matchIndex, length_1) + "</span>";
                        displayHtml = displayText.substr(0, matchIndex) + highlight + displayText.substr(matchIndex + length_1);
                    }
                }
                return displayHtml;
            };
        /**
         * Returns true if the infinite scroll component should load
         */
        /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
        TypeaheadComponent.prototype.isInfiniteScroll =
            function () {
                return typeof this.options === 'function';
            };
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         */
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.select =
            function (option) {
                if (!this.isDisabled(option)) {
                    this.optionSelected.emit(new TypeaheadOptionEvent(option.value));
                    this.highlighted$.next(null);
                    this.open = false;
                }
            };
        /**
         * Returns true if the given option is part of the disabledOptions array.
         */
        /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.isDisabled =
            function (option) {
                var _this = this;
                if (this.disabledOptions) {
                    var /** @type {?} */ result = this.disabledOptions.find(function (selectedOption) {
                        return _this.getKey(selectedOption) === option.key;
                    });
                    return result !== undefined;
                }
                return false;
            };
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         */
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.highlight =
            function (option) {
                if (!this.isDisabled(option)) {
                    this.highlighted$.next(option);
                }
            };
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TypeaheadComponent.prototype.moveHighlight =
            function (d) {
                var /** @type {?} */ visibleOptions = this.visibleOptions$.getValue();
                var /** @type {?} */ highlightIndex = this.indexOfVisibleOption(this.highlighted);
                var /** @type {?} */ newIndex = highlightIndex;
                var /** @type {?} */ disabled = true;
                var /** @type {?} */ inBounds = true;
                do {
                    newIndex = newIndex + d;
                    inBounds = (newIndex >= 0 && newIndex < visibleOptions.length);
                    disabled = inBounds && this.isDisabled(visibleOptions[newIndex]);
                } while (inBounds && disabled);
                if (!disabled && inBounds) {
                    this.highlighted$.next(visibleOptions[newIndex]);
                }
                return this.highlighted;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.selectHighlighted =
            function () {
                if (this.highlighted) {
                    this.select({ value: this.highlighted, key: this.getKey(this.highlighted) });
                }
            };
        /**
         * Set up the options before the dropdown is displayed.
         */
        /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
        TypeaheadComponent.prototype.initOptions =
            function () {
                // Clear previous highlight
                this.highlighted$.next(null);
                if (this.selectFirst) {
                    // This will highlight the first non-disabled option.
                    this.moveHighlight(1);
                }
            };
        /**
         * Update the visibleOptions array with the current filter.
         */
        /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
        TypeaheadComponent.prototype.updateOptions =
            function () {
                var _this = this;
                if (typeof this.options === 'object') {
                    var /** @type {?} */ normalisedInput_1 = (this.filter || '').toLowerCase();
                    var /** @type {?} */ visibleOptions = this.options
                        .filter(function (option) {
                        return _this.getDisplay(option).toLowerCase().indexOf(normalisedInput_1) >= 0;
                    })
                        .map(function (value) {
                        return {
                            value: value,
                            key: _this.getKey(value)
                        };
                    });
                    this.visibleOptions$.next(visibleOptions);
                }
                this.initOptions();
            };
        /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.indexOfVisibleOption =
            function (option) {
                if (option) {
                    var /** @type {?} */ optionKey_1 = this.getKey(option);
                    return this.visibleOptions$.getValue().findIndex(function (el) {
                        return el.key === optionKey_1;
                    });
                }
                return -1;
            };
        TypeaheadComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-typeahead',
                        template: "<div class=\"ux-typeahead-options\"\n    [uxInfiniteScroll]=\"loadOptionsCallback\"\n    [collection]=\"visibleOptions$ | async\"\n    (collectionChange)=\"visibleOptions$.next($event)\"\n    [enabled]=\"isInfiniteScroll()\"\n    [filter]=\"filter\"\n    [loadOnScroll]=\"true\"\n    [pageSize]=\"pageSize\"\n    [scrollElement]=\"typeaheadElement\"\n    (loading)=\"loading = true\"\n    (loaded)=\"loading = false\">\n\n    <ol *ngIf=\"(visibleOptions$ | async).length > 0\">\n        <li *ngFor=\"let option of (visibleOptions$ | async); let i = index\"\n            [attr.id]=\"id + '-option-' + i\"\n            [class.disabled]=\"isDisabled(option)\"\n            [class.highlighted]=\"highlightedKey === option.key\"\n            [attr.aria-selected]=\"multiselectable ? isDisabled(option) : null\"\n            [uxTypeaheadHighlight]=\"highlightedKey === option.key\"\n            [uxScrollIntoViewIf]=\"highlightedKey === option.key\"\n            [scrollParent]=\"typeaheadElement.nativeElement\"\n            (mousedown)=\"optionMousedownHandler($event)\"\n            (click)=\"optionClickHandler($event, option)\"\n            (mouseover)=\"highlight(option)\">\n\n            <ng-container [ngTemplateOutlet]=\"optionTemplate || defaultOptionTemplate\"\n                [ngTemplateOutletContext]=\"{option: option.value, api: optionApi}\">\n            </ng-container>\n\n        </li>\n    </ol>\n\n    <div *uxInfiniteScrollLoading>\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n    <div *ngIf=\"isInfiniteScroll() === false && (visibleOptions$ | async).length === 0 && loading\">\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n</div>\n<div *ngIf=\"(visibleOptions$ | async).length === 0 && !loading\">\n    <ng-container [ngTemplateOutlet]=\"noOptionsTemplate || defaultNoOptionsTemplate\">\n    </ng-container>\n</div>\n\n<ng-template #defaultLoadingTemplate>\n    <div class=\"ux-typeahead-loading\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n        <div>Loading...</div>\n    </div>\n</ng-template>\n\n<ng-template #defaultOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span class=\"ux-typeahead-option\" [innerHtml]=\"api.getDisplayHtml(option)\"></span>\n</ng-template>\n\n<ng-template #defaultNoOptionsTemplate>\n    <span class=\"ux-typeahead-no-options\">No results</span>\n</ng-template>",
                        providers: [TypeaheadService],
                        host: {
                            'role': 'listbox',
                            '[class.open]': 'open',
                            '[class.drop-up]': 'dropDirection === "up"',
                            '[style.maxHeight]': 'maxHeight'
                        }
                    },] },
        ];
        /** @nocollapse */
        TypeaheadComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: TypeaheadService, },
            ];
        };
        TypeaheadComponent.propDecorators = {
            "id": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] },],
            "options": [{ type: core.Input },],
            "filter": [{ type: core.Input },],
            "open": [{ type: core.Input },],
            "openChange": [{ type: core.Output },],
            "display": [{ type: core.Input },],
            "key": [{ type: core.Input },],
            "disabledOptions": [{ type: core.Input },],
            "dropDirection": [{ type: core.Input },],
            "maxHeight": [{ type: core.Input },],
            "multiselectable": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-multiselectable',] },],
            "openOnFilterChange": [{ type: core.Input },],
            "pageSize": [{ type: core.Input },],
            "selectFirst": [{ type: core.Input },],
            "selectOnEnter": [{ type: core.Input },],
            "loading": [{ type: core.Input },],
            "loadingTemplate": [{ type: core.Input },],
            "optionTemplate": [{ type: core.Input },],
            "noOptionsTemplate": [{ type: core.Input },],
            "optionSelected": [{ type: core.Output },],
            "highlightedChange": [{ type: core.Output },],
            "highlightedElementChange": [{ type: core.Output },],
            "mousedownHandler": [{ type: core.HostListener, args: ['mousedown',] },],
            "mouseupHandler": [{ type: core.HostListener, args: ['mouseup',] },],
        };
        return TypeaheadComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadButtonDirective = (function () {
        function InfiniteScrollLoadButtonDirective(_element, _template, _viewContainer, _renderer) {
            this._element = _element;
            this._template = _template;
            this._viewContainer = _viewContainer;
            this._renderer = _renderer;
            this._visible = false;
            this._load = new Subject.Subject();
            this.load = (this._load.asObservable());
        }
        Object.defineProperty(InfiniteScrollLoadButtonDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._template);
                        // Template content follows the elementRef, which is a comment.
                        var /** @type {?} */ clickTarget = this.getNextElementSibling(this._template.elementRef.nativeElement);
                        this._renderer.listen(clickTarget, 'click', this.onClick.bind(this));
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.onClick =
            function (event) {
                this._load.next(event);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.getNextElementSibling =
            function (element) {
                var /** @type {?} */ next = element;
                while (next = next.nextSibling) {
                    if (next.nodeType === 1) {
                        return next;
                    }
                }
                return null;
            };
        InfiniteScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoadButton]'
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollLoadButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.TemplateRef, },
                { type: core.ViewContainerRef, },
                { type: core.Renderer2, },
            ];
        };
        InfiniteScrollLoadButtonDirective.propDecorators = {
            "visible": [{ type: core.Input, args: ['uxInfiniteScrollLoadButton',] },],
            "load": [{ type: core.Output },],
        };
        return InfiniteScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadingDirective = (function () {
        function InfiniteScrollLoadingDirective(_templateRef, _viewContainer) {
            this._templateRef = _templateRef;
            this._viewContainer = _viewContainer;
            this._visible = false;
        }
        Object.defineProperty(InfiniteScrollLoadingDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._templateRef);
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        InfiniteScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoading]'
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollLoadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef, },
                { type: core.ViewContainerRef, },
            ];
        };
        InfiniteScrollLoadingDirective.propDecorators = {
            "visible": [{ type: core.Input, args: ['uxInfiniteScrollLoading',] },],
        };
        return InfiniteScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollDirective = (function () {
        function InfiniteScrollDirective(_element) {
            this._element = _element;
            this._collection = [];
            this.enabled = true;
            this.loadOnInit = true;
            this.loadOnScroll = true;
            this.pageSize = 20;
            this.collectionChange = new core.EventEmitter();
            this.loadingEvent = new core.EventEmitter();
            this.loadedEvent = new core.EventEmitter();
            this.loadErrorEvent = new core.EventEmitter();
            this._nextPageNum = 0;
            this._updateRequests = new Subject.Subject();
            this._isLoading = new BehaviorSubject.BehaviorSubject(false);
            this._isExhausted = new BehaviorSubject.BehaviorSubject(false);
            this._loadButtonEnabled = new BehaviorSubject.BehaviorSubject(false);
            this._subscriptions = [];
            this._loadButtonSubscriptions = [];
            this._onDestroy = new Subject.Subject();
            this._canLoadManually = this._isLoading.pipe(operators.combineLatest(this._isExhausted, this._loadButtonEnabled, function (isLoading, isExhausted, loadButtonEnabled) {
                return !isLoading && !isExhausted && loadButtonEnabled;
            }));
        }
        Object.defineProperty(InfiniteScrollDirective.prototype, "collection", {
            get: /**
             * @return {?}
             */ function () {
                return this._collection;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.collectionChange.emit(value);
                this._collection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollDirective.prototype, "scrollElement", {
            set: /**
             * @param {?} element
             * @return {?}
             */ function (element) {
                this._scrollElement = element instanceof core.ElementRef ? element : new core.ElementRef(element);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnInit =
            function () {
                if (!this._scrollElement) {
                    this._scrollElement = this._element;
                }
                this._loadButtonEnabled.next(!this.loadOnScroll);
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // There are two kinds of update requests: check and load.
                // Check requests are throttled and will only cause an update if more data is required
                // to fill the scrolling view, and it isn't already loading some.
                // Load requests are not throttled and always request a page of data.
                this._updateRequests.pipe(operators.filter(function (request) { return request.check; }), operators.auditTime(200), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                this._updateRequests.pipe(operators.filter(function (request) { return !request.check; }), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                if (this.enabled) {
                    // Subscribe to scroll events and DOM changes.
                    this.attachEventHandlers();
                }
                // Connect the Load More button visible state.
                this._canLoadManually.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (canLoad) {
                    _this._loadButtonQuery.forEach(function (loadButton) {
                        loadButton.visible = canLoad;
                    });
                });
                // Connect the loading indicator visible state.
                this._isLoading.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isLoading) {
                    _this._loadingIndicatorQuery.forEach(function (loading) {
                        loading.visible = isLoading;
                    });
                });
                // Link the Load More button click event to trigger an update.
                this.attachLoadButtonEvents();
                this._loadButtonQuery.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.attachLoadButtonEvents();
                });
                // Initial update.
                if (this.loadOnInit) {
                    this.loadNextPage();
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnChanges =
            function (changes) {
                var /** @type {?} */ check = true;
                if (changes["enabled"] && changes["enabled"].currentValue !== changes["enabled"].previousValue) {
                    if (changes["enabled"].currentValue) {
                        this.attachEventHandlers();
                        this.reset();
                        check = false;
                    }
                    else {
                        this.detachEventHandlers();
                    }
                }
                if (this.enabled) {
                    if (changes["filter"] && changes["filter"].currentValue !== changes["filter"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    if (changes["loadOnScroll"]) {
                        this._loadButtonEnabled.next(!changes["loadOnScroll"].currentValue);
                    }
                    if (changes["pageSize"] && changes["pageSize"].currentValue !== changes["pageSize"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    this._updateRequests.next({
                        check: check,
                        pageNumber: this._nextPageNum,
                        pageSize: this.pageSize,
                        filter: this.filter
                    });
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnDestroy =
            function () {
                this.detachEventHandlers();
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Request an additional page of data.
         */
        /**
         * Request an additional page of data.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.loadNextPage =
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         */
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.check =
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: true,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Clear the collection. Future requests will load from page 0.
         */
        /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reset =
            function () {
                if (!this.enabled) {
                    return;
                }
                // Reset the page counter.
                this._nextPageNum = 0;
                this._pages = [];
                // Clear the collection (without changing the reference).
                if (this.collection) {
                    this.collection.length = 0;
                }
                // Reset the exhausted flag, allowing the Load More button to appear.
                this._isExhausted.next(false);
                // Cancel any pending requests
                if (this._subscriptions) {
                    this._subscriptions.forEach(function (request) { return request.unsubscribe(); });
                }
            };
        /**
         * Reload the data without clearing the view.
         */
        /**
         * Reload the data without clearing the view.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reload =
            function () {
                var _this = this;
                this._pages.forEach(function (page, i) { return _this.reloadPage(i); });
            };
        /**
         * Reload the data in a specific page without clearing the view.
         * @param pageNum Page number
         */
        /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reloadPage =
            function (pageNum) {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: pageNum,
                    pageSize: this.pageSize,
                    filter: this.filter,
                    reload: true
                });
            };
        /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachEventHandlers =
            function () {
                // if the scrollElement is documentElement we must watch for a scroll event on the document
                var /** @type {?} */ target = this._scrollElement.nativeElement instanceof HTMLHtmlElement ? document : this._scrollElement.nativeElement;
                // Subscribe to the scroll event on the target element.
                this._scrollEventSub = fromEvent.fromEvent(target, 'scroll').subscribe(this.check.bind(this));
                // Subscribe to child DOM changes. The main effect of this is to check whether even more data is
                // required after the initial load.
                this._domObserver = new MutationObserver(this.check.bind(this));
                this._domObserver.observe(this._scrollElement.nativeElement, {
                    childList: true,
                    subtree: true
                });
            };
        /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.detachEventHandlers =
            function () {
                if (this._scrollEventSub) {
                    this._scrollEventSub.unsubscribe();
                    this._scrollEventSub = null;
                }
                if (this._domObserver) {
                    this._domObserver.disconnect();
                    this._domObserver = null;
                }
            };
        /**
         * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
         * for any in the query.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachLoadButtonEvents =
            function () {
                var _this = this;
                this._loadButtonSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._loadButtonSubscriptions = this._loadButtonQuery.map(function (loadButton) { return loadButton.load.subscribe(_this.loadNextPage.bind(_this)); });
            };
        /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.doRequest =
            function (request) {
                var _this = this;
                // Load a new page if the scroll position is beyond the threshhold and if the client code did not
                // cancel.
                if (this.needsData(request) && this.beginLoading(request)) {
                    // Invoke the callback load function, which returns a promose or plain data.
                    var /** @type {?} */ loadResult = this.load(request.pageNumber, request.pageSize, request.filter);
                    var /** @type {?} */ observable = Array.isArray(loadResult) ? of.of(loadResult) : from.from(loadResult);
                    var /** @type {?} */ subscription_1 = observable.pipe(operators.first()).subscribe(function (items) {
                        // Make sure that the parameters have not changed since the load started;
                        // otherwise discard the results.
                        if (request.filter === _this.filter && request.pageSize === _this.pageSize) {
                            if (items && items.length) {
                                _this.setPageItems(request.pageNumber, items);
                            }
                            // Emit the loaded event
                            // Emit the loaded event
                            _this.endLoading(request, items);
                        }
                    }, function (reason) {
                        // Emit the loadError event
                        // Emit the loadError event
                        _this.endLoadingWithError(request, reason);
                    }, function () {
                        // remove this request from the list
                        // remove this request from the list
                        _this._subscriptions = _this._subscriptions.filter(function (s) { return s !== subscription_1; });
                    });
                    // add the subscription to the list of requests
                    this._subscriptions.push(subscription_1);
                }
            };
        /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.needsData =
            function (request) {
                if (!this.enabled) {
                    return false;
                }
                // Always load for a load request
                if (!request.check) {
                    return true;
                }
                // Ignore a check request when the end of data has been detected, or if data is currently loading.
                if (this._isExhausted.getValue() || this._isLoading.getValue()) {
                    return false;
                }
                // Load if the remaining scroll area is <= the element height.
                if (this._scrollElement && this.loadOnScroll) {
                    var /** @type {?} */ element = (this._scrollElement.nativeElement);
                    var /** @type {?} */ remainingScroll = element.scrollHeight -
                        (element.scrollTop + element.clientHeight);
                    return remainingScroll <= element.clientHeight;
                }
                return false;
            };
        /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.beginLoading =
            function (request) {
                var /** @type {?} */ event = new InfiniteScrollLoadingEvent(request.pageNumber, request.pageSize, request.filter);
                this.loadingEvent.emit(event);
                this._isLoading.next(!event.defaultPrevented());
                return !event.defaultPrevented();
            };
        /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
        InfiniteScrollDirective.prototype.setPageItems =
            function (pageNum, items) {
                this._pages[pageNum] = items;
                this.collection = this._pages.reduce(function (previous, current) { return previous.concat(current); }, []);
            };
        /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoading =
            function (request, data) {
                this._isLoading.next(false);
                var /** @type {?} */ isExhausted = !!(data && data.length < this.pageSize);
                this._isExhausted.next(isExhausted);
                this.loadedEvent.emit(new InfiniteScrollLoadedEvent(request.pageNumber, request.pageSize, request.filter, data, isExhausted));
                if (!request.reload) {
                    this._nextPageNum += 1;
                }
            };
        /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoadingWithError =
            function (request, error) {
                this._isLoading.next(false);
                this.loadErrorEvent.emit(new InfiniteScrollLoadErrorEvent(request.pageNumber, request.pageSize, request.filter, error));
            };
        InfiniteScrollDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScroll]',
                        exportAs: 'uxInfiniteScroll'
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        InfiniteScrollDirective.propDecorators = {
            "load": [{ type: core.Input, args: ['uxInfiniteScroll',] },],
            "_collection": [{ type: core.Input, args: ['collection',] },],
            "scrollElement": [{ type: core.Input },],
            "enabled": [{ type: core.Input },],
            "filter": [{ type: core.Input },],
            "loadOnInit": [{ type: core.Input },],
            "loadOnScroll": [{ type: core.Input },],
            "pageSize": [{ type: core.Input },],
            "collectionChange": [{ type: core.Output },],
            "loadingEvent": [{ type: core.Output, args: ['loading',] },],
            "loadedEvent": [{ type: core.Output, args: ['loaded',] },],
            "loadErrorEvent": [{ type: core.Output, args: ['loadError',] },],
            "_loadButtonQuery": [{ type: core.ContentChildren, args: [InfiniteScrollLoadButtonDirective,] },],
            "_loadingIndicatorQuery": [{ type: core.ContentChildren, args: [InfiniteScrollLoadingDirective,] },],
        };
        return InfiniteScrollDirective;
    }());
    /**
     * Event raised before the `loading` function is called.
     */
    var /**
     * Event raised before the `loading` function is called.
     */ InfiniteScrollLoadingEvent = (function () {
        function InfiniteScrollLoadingEvent(pageNumber, pageSize, filter) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this._defaultPrevented = false;
        }
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         */
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.preventDefault =
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.defaultPrevented =
            function () {
                return this._defaultPrevented;
            };
        return InfiniteScrollLoadingEvent;
    }());
    /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */
    var /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */ InfiniteScrollLoadedEvent = (function () {
        function InfiniteScrollLoadedEvent(pageNumber, pageSize, filter, data, exhausted) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.data = data;
            this.exhausted = exhausted;
        }
        return InfiniteScrollLoadedEvent;
    }());
    /**
     * Event raised if the loading function returns a rejected promise.
     */
    var /**
     * Event raised if the loading function returns a rejected promise.
     */ InfiniteScrollLoadErrorEvent = (function () {
        function InfiniteScrollLoadErrorEvent(pageNumber, pageSize, filter, error) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.error = error;
        }
        return InfiniteScrollLoadErrorEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollModule = (function () {
        function InfiniteScrollModule() {
        }
        InfiniteScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        declarations: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollModule.ctorParameters = function () { return []; };
        return InfiniteScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewService = (function () {
        function ScrollIntoViewService() {
        }
        /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
        ScrollIntoViewService.prototype.scrollIntoView =
            function (elem, scrollParent) {
                var /** @type {?} */ offsetTop = (elem.getBoundingClientRect().top + scrollParent.scrollTop) - scrollParent.getBoundingClientRect().top;
                if (offsetTop < scrollParent.scrollTop) {
                    scrollParent.scrollTop = offsetTop;
                }
                else {
                    var /** @type {?} */ offsetBottom = offsetTop + elem.offsetHeight;
                    if (offsetBottom > (scrollParent.scrollTop + scrollParent.clientHeight)) {
                        scrollParent.scrollTop = offsetBottom - scrollParent.clientHeight;
                    }
                }
            };
        ScrollIntoViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ScrollIntoViewService.ctorParameters = function () { return []; };
        return ScrollIntoViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewIfDirective = (function () {
        function ScrollIntoViewIfDirective(_element, _scrollIntoViewService) {
            this._element = _element;
            this._scrollIntoViewService = _scrollIntoViewService;
            this.condition = false;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewIfDirective.prototype.ngOnChanges =
            function () {
                var _this = this;
                if (this.condition) {
                    setTimeout(function () { return _this._scrollIntoViewService.scrollIntoView(_this._element.nativeElement, _this.scrollParent); });
                }
            };
        ScrollIntoViewIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoViewIf]',
                        providers: [ScrollIntoViewService]
                    },] },
        ];
        /** @nocollapse */
        ScrollIntoViewIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ScrollIntoViewService, },
            ];
        };
        ScrollIntoViewIfDirective.propDecorators = {
            "condition": [{ type: core.Input, args: ['uxScrollIntoViewIf',] },],
            "scrollParent": [{ type: core.Input },],
        };
        return ScrollIntoViewIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewDirective = (function () {
        function ScrollIntoViewDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow a condition around whether or not this should scroll into view
             */
            this.uxScrollIntoView = true;
            /**
             * Allow user to provide the browser supported options
             */
            this.scrollIntoViewOptions = true;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewDirective.prototype.ngAfterViewInit =
            function () {
                if (this.uxScrollIntoView) {
                    this._elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
                }
            };
        ScrollIntoViewDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoView]'
                    },] },
        ];
        /** @nocollapse */
        ScrollIntoViewDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ScrollIntoViewDirective.propDecorators = {
            "uxScrollIntoView": [{ type: core.Input },],
            "scrollIntoViewOptions": [{ type: core.Input },],
        };
        return ScrollIntoViewDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollModule = (function () {
        function ScrollModule() {
        }
        ScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ScrollIntoViewIfDirective, ScrollIntoViewDirective],
                        declarations: [ScrollIntoViewIfDirective, ScrollIntoViewDirective]
                    },] },
        ];
        /** @nocollapse */
        ScrollModule.ctorParameters = function () { return []; };
        return ScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadHighlightDirective = (function () {
        function TypeaheadHighlightDirective(_service, _elementRef) {
            this._service = _service;
            this._elementRef = _elementRef;
        }
        Object.defineProperty(TypeaheadHighlightDirective.prototype, "highlight", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._service.highlightedElement$.next(this._elementRef.nativeElement);
                }
            },
            enumerable: true,
            configurable: true
        });
        TypeaheadHighlightDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTypeaheadHighlight]'
                    },] },
        ];
        /** @nocollapse */
        TypeaheadHighlightDirective.ctorParameters = function () {
            return [
                { type: TypeaheadService, },
                { type: core.ElementRef, },
            ];
        };
        TypeaheadHighlightDirective.propDecorators = {
            "highlight": [{ type: core.Input, args: ['uxTypeaheadHighlight',] },],
        };
        return TypeaheadHighlightDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadModule = (function () {
        function TypeaheadModule() {
        }
        TypeaheadModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            InfiniteScrollModule,
                            ScrollModule
                        ],
                        exports: [TypeaheadComponent],
                        declarations: [TypeaheadComponent, TypeaheadHighlightDirective],
                        providers: [TypeaheadKeyService],
                    },] },
        ];
        /** @nocollapse */
        TypeaheadModule.ctorParameters = function () { return []; };
        return TypeaheadModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableHandleDirective = (function () {
        function ReorderableHandleDirective() {
        }
        ReorderableHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableHandle]'
                    },] },
        ];
        /** @nocollapse */
        ReorderableHandleDirective.ctorParameters = function () { return []; };
        return ReorderableHandleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModelDirective = (function () {
        // this can be used to identify which instance of the directive relates to which element
        function ReorderableModelDirective(elementRef) {
            this.elementRef = elementRef;
        }
        ReorderableModelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableModel]'
                    },] },
        ];
        /** @nocollapse */
        ReorderableModelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ReorderableModelDirective.propDecorators = {
            "uxReorderableModel": [{ type: core.Input },],
        };
        return ReorderableModelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    // WORKAROUND: Angular Cli 6 has removed the globals patch, dragular requires this to we can patch it here
    ((window)).global = ((window)).global || {};
    var /** @type {?} */ dragula = dragulaNamespace__default || dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableService = (function () {
        function ReorderableService() {
            this._groups = {};
            this._uniqueGroupId = 0;
        }
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         */
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
        ReorderableService.prototype.getUniqueGroupName =
            function () {
                return '_uxReorderable_' + this._uniqueGroupId++;
            };
        /**
         * Adds the container to the named group.
         */
        /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.register =
            function (groupName, container) {
                if (!this._groups[groupName]) {
                    this._groups[groupName] = new ReorderableGroup();
                }
                this._groups[groupName].register(container);
                return this._groups[groupName];
            };
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         */
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.unregister =
            function (groupName, container) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.unregister(container);
                    if (group.isEmpty()) {
                        group.destroy();
                        delete this._groups[groupName];
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
        ReorderableService.prototype.initialize =
            function (groupName) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.initialize();
                }
                return group;
            };
        /**
         * Returns the group object for the given name.
         */
        /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
        ReorderableService.prototype.getGroup =
            function (group) {
                return this._groups[group];
            };
        ReorderableService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ReorderableService.ctorParameters = function () { return []; };
        return ReorderableService;
    }());
    /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */
    var /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */ ReorderableGroup = (function () {
        function ReorderableGroup() {
            this.drag = new core.EventEmitter();
            this.dragEnd = new core.EventEmitter();
            this.drop = new core.EventEmitter();
            this.cancel = new core.EventEmitter();
            this.cloned = new core.EventEmitter();
            this._containers = [];
            this._config = {
                moves: this.canMove.bind(this)
            };
        }
        /**
         * Returns true if there are no containers registered with the group.
         */
        /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
        ReorderableGroup.prototype.isEmpty =
            function () {
                return this._containers.length === 0;
            };
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         */
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
        ReorderableGroup.prototype.getModelForElement =
            function (element) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        var /** @type {?} */ model = container.getModelFromElement(element);
                        if (model) {
                            return model;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return null;
                var e_1, _c;
            };
        /**
         * Adds the container to the group.
         */
        /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.register =
            function (container) {
                this._containers.push(container);
                if (this._instance) {
                    this._instance.containers = this._containers.map(function (c) { return c.element; });
                }
                if (!this._config.mirrorContainer) {
                    this._config.mirrorContainer = container.element;
                }
            };
        /**
         * Removes the container from the group.
         */
        /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.unregister =
            function (container) {
                var /** @type {?} */ index = this._containers.indexOf(container);
                if (index >= 0) {
                    this._containers.splice(index, 1);
                    if (this._instance) {
                        this._instance.containers = this._containers.map(function (c) { return c.element; });
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
        ReorderableGroup.prototype.initialize =
            function () {
                var _this = this;
                if (this._instance) {
                    return;
                }
                this._instance = dragula(this._containers.map(function (c) { return c.element; }), this._config);
                this._instance.on('drag', function (element, source) {
                    _this.drag.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        source: source
                    });
                });
                this._instance.on('dragend', function (element) {
                    _this.dragEnd.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('drop', function (element, target, source, sibling) {
                    _this.drop.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        target: target,
                        source: source,
                        sibling: sibling
                    });
                });
                this._instance.on('cancel', function (element) {
                    _this.cancel.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('cloned', function (clone, element, type) {
                    _this.cloned.emit({
                        clone: clone,
                        element: element,
                        type: type
                    });
                });
            };
        /**
         * Destroys the dragula instance.
         */
        /**
         * Destroys the dragula instance.
         * @return {?}
         */
        ReorderableGroup.prototype.destroy =
            function () {
                if (this._instance) {
                    this._instance.destroy();
                    this._instance = null;
                }
            };
        /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
        ReorderableGroup.prototype.canMove =
            function (element, containerElement, handle) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        if (container.element.isSameNode(containerElement)) {
                            return container.canMove(element, containerElement, handle);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                var e_2, _c;
            };
        return ReorderableGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableDirective = (function () {
        function ReorderableDirective(_elementRef, _renderer, _service) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._service = _service;
            this.reorderingDisabled = false;
            this.reorderableModelChange = new core.EventEmitter();
            this.reorderStart = new core.EventEmitter();
            this.reorderCancel = new core.EventEmitter();
            this.reorderEnd = new core.EventEmitter();
            this.dragging = false;
            this._subscriptions = new Subscription.Subscription();
        }
        /**
         * Initialise dragula and bind to all the required events
         */
        /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                // If no group name then generate a unique one for this instance only
                if (!this.reorderableGroup) {
                    this.reorderableGroup = this._service.getUniqueGroupName();
                }
                this._container = {
                    element: this._elementRef.nativeElement,
                    getModelFromElement: this.getModelFromElement.bind(this),
                    canMove: this.canMove.bind(this)
                };
                // Register for drag events on this element
                var /** @type {?} */ group = this._service.register(this.reorderableGroup, this._container);
                this._subscriptions.add(group.drag.subscribe(this.onDrag.bind(this)));
                this._subscriptions.add(group.dragEnd.subscribe(this.onDragEnd.bind(this)));
                this._subscriptions.add(group.drop.subscribe(this.onDrop.bind(this)));
                this._subscriptions.add(group.cancel.subscribe(function (event) { return _this.reorderCancel.emit({ element: event.element, model: event.model }); }));
                this._subscriptions.add(group.cloned.subscribe(this.onClone.bind(this)));
            };
        /**
         * @return {?}
         */
        ReorderableDirective.prototype.ngAfterViewInit =
            function () {
                this._service.initialize(this.reorderableGroup);
            };
        /**
         * We need to destroy the dragula instance on component destroy
         */
        /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnDestroy =
            function () {
                this._service.unregister(this.reorderableGroup, this._container);
                this._subscriptions.unsubscribe();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrag =
            function (event) {
                this.dragging = true;
                this.reorderStart.emit({ element: event.element, model: event.model });
            };
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         */
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrop =
            function (event) {
                // if there is no provided module we can skip this
                if (!this.reorderableModel) {
                    return;
                }
                var /** @type {?} */ changed = false;
                if (event.source.isSameNode(this._elementRef.nativeElement)) {
                    // remove this model from the list of models
                    var /** @type {?} */ index = this.reorderableModel.indexOf(event.model);
                    if (index >= 0) {
                        this.reorderableModel.splice(index, 1);
                        changed = true;
                    }
                }
                if (event.target.isSameNode(this._elementRef.nativeElement)) {
                    // get the position of sibling element
                    var /** @type {?} */ index = event.sibling && !event.sibling.classList.contains('gu-mirror') ?
                        this.reorderableModel.indexOf(this.getModelFromElement(event.sibling)) :
                        this.reorderableModel.length;
                    // insert the model at its new location
                    this.reorderableModel.splice(index, 0, event.model);
                    changed = true;
                }
                // Emit event if any changes were made
                if (changed) {
                    this.reorderableModelChange.emit(this.reorderableModel);
                }
            };
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         */
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
        ReorderableDirective.prototype.getModelFromElement =
            function (element) {
                var /** @type {?} */ model = this.models.find(function (_model) { return _model.elementRef.nativeElement === element; });
                if (!model) {
                    return null;
                }
                return model.uxReorderableModel;
            };
        /**
         * When we finish dragging remove the utillity class from the element being moved
         */
        /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDragEnd =
            function (event) {
                this.dragging = false;
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this._renderer.removeClass(event.element, 'ux-reorderable-moving');
                    this.reorderEnd.emit({
                        element: event.element,
                        model: event.model
                    });
                }
            };
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         */
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onClone =
            function (event) {
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this.setTableCellWidths(event.element, event.clone);
                    this.captureCanvases(event.element, event.clone);
                    this._renderer.addClass(event.element, 'ux-reorderable-moving');
                }
            };
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         */
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
        ReorderableDirective.prototype.canMove =
            function (element, container, handle) {
                if (this.reorderingDisabled) {
                    return false;
                }
                return this.handles.length === 0 ? true : !!this.handles.find(function (_handle) { return _handle.nativeElement === handle; });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.setTableCellWidths =
            function (source, target) {
                // if it is not a table row then skip this
                if (source.tagName !== 'TR') {
                    return;
                }
                // find any immediate td children and fix their width
                var /** @type {?} */ sourceCells = (Array.from(source.children));
                var /** @type {?} */ targetCells = (Array.from(target.children));
                // fix the width of these cells
                sourceCells.forEach(function (cell, idx) { return targetCells[idx].style.minWidth = getComputedStyle(cell).getPropertyValue('width'); });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.captureCanvases =
            function (source, target) {
                // find all child canvas elements
                var /** @type {?} */ sourceCanvases = Array.from(source.querySelectorAll('canvas'));
                var /** @type {?} */ targetCanvases = Array.from(target.querySelectorAll('canvas'));
                // replicate the canvas content
                targetCanvases.map(function (canvas) { return canvas.getContext('2d'); })
                    .forEach(function (context, idx) { return context.drawImage(sourceCanvases[idx], 0, 0); });
            };
        ReorderableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderable]'
                    },] },
        ];
        /** @nocollapse */
        ReorderableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
                { type: ReorderableService, },
            ];
        };
        ReorderableDirective.propDecorators = {
            "reorderableModel": [{ type: core.Input },],
            "reorderableGroup": [{ type: core.Input },],
            "reorderingDisabled": [{ type: core.Input },],
            "reorderableModelChange": [{ type: core.Output },],
            "reorderStart": [{ type: core.Output },],
            "reorderCancel": [{ type: core.Output },],
            "reorderEnd": [{ type: core.Output },],
            "handles": [{ type: core.ContentChildren, args: [ReorderableHandleDirective, { read: core.ElementRef, descendants: true },] },],
            "models": [{ type: core.ContentChildren, args: [ReorderableModelDirective,] },],
            "dragging": [{ type: core.HostBinding, args: ['class.ux-reorderable-container-moving',] },],
        };
        return ReorderableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModule = (function () {
        function ReorderableModule() {
        }
        ReorderableModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        exports: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        providers: [
                            ReorderableService
                        ]
                    },] },
        ];
        /** @nocollapse */
        ReorderableModule.ctorParameters = function () { return []; };
        return ReorderableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetSelect = (function () {
        function FacetSelect(facet) {
            this.facet = facet;
        }
        return FacetSelect;
    }());
    var FacetDeselect = (function () {
        function FacetDeselect(facet) {
            this.facet = facet;
        }
        return FacetDeselect;
    }());
    var FacetDeselectAll = (function () {
        function FacetDeselectAll() {
        }
        return FacetDeselectAll;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetContainerComponent = (function () {
        function FacetContainerComponent(_announcer) {
            this._announcer = _announcer;
            this.header = 'Selected:';
            this.clearTooltip = 'Clear All';
            this.emptyText = 'No Items';
            this.facets = [];
            this.facetsReorderable = false;
            this.facetsChange = new core.EventEmitter();
            this.events = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.ngOnDestroy =
            function () {
                this.events.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.selectFacet =
            function (facet) {
                // push the facet on to the list
                this.facets.push(facet);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetSelect(facet));
            };
        /**
         * @param {?} facet
         * @param {?=} tag
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectFacet =
            function (facet, tag) {
                // find the index of the item in the selected array
                var /** @type {?} */ idx = this.facets.findIndex(function (selectedFacet) { return facet === selectedFacet; });
                // if match there was no match then finish
                if (idx === -1) {
                    return;
                }
                // remove the last item
                this.facets.splice(idx, 1);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselect(facet));
                // announce the facet removal
                this._announcer.announce("Option " + facet.title + " deselected.", 'assertive');
                // focus another tag if there is one
                if (tag) {
                    var /** @type {?} */ sibling = tag.previousElementSibling || tag.nextElementSibling;
                    // if there is a sibling then focus it
                    if (sibling) {
                        ((sibling)).focus();
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectAllFacets =
            function () {
                // empty the selected array
                this.facets = [];
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselectAll());
                // announce the facet removal
                this._announcer.announce("All options deselected.", 'assertive');
            };
        /**
         * @param {?} _index
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.trackBy =
            function (_index, facet) {
                return facet.id || facet.title;
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftRight =
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, 1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved down.");
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftLeft =
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, -1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved up.");
            };
        /**
         * @param {?} facet
         * @param {?} distance
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftFacet =
            function (facet, distance) {
                var /** @type {?} */ index = this.facets.indexOf(facet);
                var /** @type {?} */ target = index + distance;
                // Ensure the move is valid
                if (target < 0 || target === this.facets.length) {
                    return;
                }
                // Perform the move
                this.facets.splice(index, 1);
                this.facets.splice(target, 0, facet);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetContainerComponent.prototype.triggerEvent =
            function (event) {
                this.events.next(event);
            };
        FacetContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-container',
                        template: "<!-- Display Any Selected Facets -->\n<div class=\"facets-selected-container\">\n\n    <!-- Display Title an Clear Button -->\n    <div class=\"facets-selected-header-container\">\n\n        <!-- Show The Selected Text -->\n        <span class=\"facets-selected-header-label\">{{ header }}</span>\n\n        <!-- Add a Clear Button -->\n        <button class=\"btn btn-link btn-icon button-secondary\"\n            tabindex=\"0\"\n            [attr.aria-label]=\"clearTooltip\"\n            [uxTooltip]=\"clearTooltip\"\n            placement=\"left\"\n            (click)=\"deselectAllFacets()\"\n            *ngIf=\"facets.length > 0\">\n\n            <svg class=\"facets-selected-clear-graphic\" focusable=\"false\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n                <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n                <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n                <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n                <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n                <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n            </svg>\n        </button>\n\n    </div>\n\n    <!-- Display Tags For Selected Items -->\n    <div class=\"facets-selected-list\"\n        uxReorderable\n        role=\"list\"\n        [reorderingDisabled]=\"!facetsReorderable\"\n        [(reorderableModel)]=\"facets\"\n        (reorderableModelChange)=\"facetsChange.emit(facets)\">\n\n        <!-- Show Selected Tags -->\n        <div #tag\n            class=\"facet-selected-tag\"\n            role=\"listitem\"\n            tabindex=\"0\"\n            uxReorderableHandle\n            *ngFor=\"let facet of facets; trackBy: trackBy\"\n            [attr.aria-label]=\"facet.title\"\n            [uxReorderableModel]=\"facet\"\n            (mousedown)=\"tag.focus()\"\n            (keydown.ArrowRight)=\"shiftRight(facet, tag)\"\n            (keydown.ArrowLeft)=\"shiftLeft(facet, tag)\">\n\n            <!-- Display Label -->\n            <span class=\"facet-selected-tag-label\">{{ facet.title }}</span>\n\n            <!-- Display Remove Icon -->\n            <button class=\"facet-selected-remove-btn\"\n                i18n-aria-label\n                aria-label=\"Deselect Facet\"\n                (click)=\"deselectFacet(facet, tag)\">\n\n                <i class=\"hpe-icon hpe-close\"></i>\n            </button>\n        </div>\n\n    </div>\n\n    <!-- Show Message Here if No Facets Selected -->\n    <p class=\"facets-selected-none-label\" *ngIf=\"emptyText && facets.length === 0\">{{ emptyText }}</p>\n\n</div>\n\n<!-- Any Facet Elements Should be Added Here By User -->\n<div class=\"facets-region\">\n    <ng-content></ng-content>\n</div>"
                    },] },
        ];
        /** @nocollapse */
        FacetContainerComponent.ctorParameters = function () {
            return [
                { type: a11y.LiveAnnouncer, },
            ];
        };
        FacetContainerComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "clearTooltip": [{ type: core.Input },],
            "emptyText": [{ type: core.Input },],
            "facets": [{ type: core.Input },],
            "facetsReorderable": [{ type: core.Input },],
            "facetsChange": [{ type: core.Output },],
            "events": [{ type: core.Output },],
        };
        return FacetContainerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetBaseComponent = (function () {
        function FacetBaseComponent(facetContainer, _elementRef) {
            var _this = this;
            this.facetContainer = facetContainer;
            this._elementRef = _elementRef;
            this.selected = [];
            this.selectedChange = new core.EventEmitter();
            this.events = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
            if (facetContainer) {
                // subscribe to any deselect events from the facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselect; }), operators.filter(function (event) { return !!_this.selected.find(function (facet) { return facet === event.facet; }); }), operators.takeUntil(this._onDestroy)).subscribe(function (event) { return _this.deselectFacet(event.facet); });
                // subscribe to any deselect all events from facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselectAll; }), operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.deselectAll(); });
            }
        }
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                // check if there should be any facets initially selected
                if (this.facetContainer) {
                    this.selected.forEach(function (facet) { return _this.facetContainer.selectFacet(facet); });
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.selectFacet =
            function (facet) {
                // if the facet is disabled it should not be selected
                if (facet.disabled) {
                    return;
                }
                // add the facet to the list of selected facets
                this.selected.push(facet);
                // send the new value to the event emitter
                this.selectedChange.emit(this.selected);
                // fire the event to the observable
                this.triggerEvent(new FacetSelect(facet));
                // tell the facet container about the selected facet
                if (this.facetContainer) {
                    this.facetContainer.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectFacet =
            function (facet) {
                // find facet to remove
                var /** @type {?} */ index = this.selected.findIndex(function (selectedFacet) { return selectedFacet === facet; });
                // only continue if facet is found
                if (index !== -1) {
                    // remove the facet from the selected list
                    this.selected.splice(index, 1);
                    // emit the changes to selected event emitter
                    this.selectedChange.emit(this.selected);
                    // fire the event to the observable
                    this.triggerEvent(new FacetDeselect(facet));
                    // deselect the facet in the facet container
                    if (this.facetContainer) {
                        this.facetContainer.deselectFacet(facet);
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectAll =
            function () {
                // remove all selected facets
                this.selected = [];
                // fire the event to the observable
                this.triggerEvent(new FacetDeselectAll());
                // emit the changes to the selected event emitter
                this.selectedChange.emit(this.selected);
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.toggleFacetSelection =
            function (facet) {
                // if the facet is selected then deselect - otherwise select it
                if (this.isFacetSelected(facet)) {
                    this.deselectFacet(facet);
                }
                else {
                    this.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.isFacetSelected =
            function (facet) {
                // determine if a facet is currently selected
                return !!this.selected.find(function (selectedFacet) { return selectedFacet === facet; });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetBaseComponent.prototype.triggerEvent =
            function (event) {
                this.events.next(event);
            };
        FacetBaseComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-base',
                        template: '',
                    },] },
        ];
        /** @nocollapse */
        FacetBaseComponent.ctorParameters = function () {
            return [
                { type: FacetContainerComponent, decorators: [{ type: core.Host },] },
                { type: core.ElementRef, },
            ];
        };
        FacetBaseComponent.propDecorators = {
            "selected": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
            "events": [{ type: core.Output },],
        };
        return FacetBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetHeaderComponent = (function () {
        function FacetHeaderComponent() {
            this.canExpand = true;
            this.expanded = true;
            this.expandedChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FacetHeaderComponent.prototype.toggleExpand =
            function () {
                // if not expandable then do nothing
                if (this.canExpand) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        FacetHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-header',
                        template: "<span class=\"facet-header-title\">{{ header }}</span>\n<span class=\"hpe-icon\" [class.hpe-down]=\"expanded\" [class.hpe-previous]=\"!expanded\" *ngIf=\"canExpand\"></span>",
                        host: {
                            'role': 'button',
                            'tabindex': '0',
                            '(click)': 'toggleExpand()',
                            '(keyup.enter)': 'toggleExpand()',
                            '[attr.aria-expanded]': 'expanded',
                            '[attr.aria-label]': 'header + \' Facet: Activate to \' + (expanded ? \'collapse\' : \'expand\')'
                        }
                    },] },
        ];
        /** @nocollapse */
        FacetHeaderComponent.ctorParameters = function () { return []; };
        FacetHeaderComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "canExpand": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
            "expandedChange": [{ type: core.Output },],
        };
        return FacetHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetCheckListItemComponent = (function () {
        function FacetCheckListItemComponent() {
            this.facet = null;
            this.selected = false;
            this.tabbable = false;
            this.selectedChange = new core.EventEmitter();
            this.itemFocus = new core.EventEmitter();
            this.itemBlur = new core.EventEmitter();
        }
        Object.defineProperty(FacetCheckListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.getLabel =
            function () {
                return this.facet ? this.facet.title : '';
            };
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.focus =
            function () {
                this.option.nativeElement.focus();
            };
        FacetCheckListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-check-list-item',
                        template: "<div #option\n    class=\"facet-check-list-item\"\n    [class.facet-active]=\"selected\"\n    [attr.aria-checked]=\"selected\"\n    role=\"option\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (blur)=\"itemBlur.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    [class.disabled]=\"facet?.disabled\">\n\n    <!-- Show check icon to indicate the state -->\n    <span class=\"facet-check-list-item-check\" aria-hidden=\"true\">\n        <span class=\"hpe-icon hpe-active\"></span>\n    </span>\n\n    <!-- Display the title -->\n    <span class=\"facet-check-list-item-title\">\n        {{ facet?.title }}\n    </span>\n\n    <!-- Display the count if specified -->\n    <span class=\"facet-check-list-item-count\"\n        *ngIf=\"facet?.count !== undefined\"\n        attr.aria-label=\"{{ facet?.count }}\"\n        i18n-aria-label>\n        ({{ facet?.count }})\n    </span>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        FacetCheckListItemComponent.ctorParameters = function () { return []; };
        FacetCheckListItemComponent.propDecorators = {
            "facet": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "tabbable": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
            "itemFocus": [{ type: core.Output },],
            "itemBlur": [{ type: core.Output },],
            "option": [{ type: core.ViewChild, args: ['option',] },],
        };
        return FacetCheckListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetCheckListComponent = (function (_super) {
        __extends(FacetCheckListComponent, _super);
        function FacetCheckListComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.facets = [];
            _this.scrollbar = true;
            _this.expanded = true;
            _this.isFocused = false;
            _this.activeIndex = 0;
            return _this;
        }
        /**
         * @return {?}
         */
        FacetCheckListComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                this._focusKeyManager = new a11y.FocusKeyManager(this.options)
                    .withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetCheckListComponent.prototype.onFocus =
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetCheckListComponent.prototype.onKeydown =
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetCheckListComponent.prototype.toggleFacet =
            function (index, facet) {
                this.toggleFacetSelection(facet);
                this._focusKeyManager.setActiveItem(index);
            };
        FacetCheckListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-check-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<!-- Create a container which will show when section is expanded -->\n<div class=\"facet-check-list-container\"\n    tabindex=\"-1\"\n    role=\"listbox\"\n    [class.facet-check-list-scrollbar]=\"scrollbar\"\n    [class.facet-check-list-scrollbar-focused]=\"isFocused\"\n    *ngIf=\"expanded\">\n\n    <!-- Iterate through each possible facet -->\n    <ux-facet-check-list-item *ngFor=\"let facet of facets; let index = index\"\n        [facet]=\"facet\"\n        [tabbable]=\"activeIndex === index\"\n        [selected]=\"isFacetSelected(facet)\"\n        (selectedChange)=\"toggleFacet(index, facet)\"\n        (keydown)=\"onKeydown($event)\"\n        (itemFocus)=\"isFocused = true; onFocus(index)\"\n        (itemBlur)=\"isFocused = false\">\n    </ux-facet-check-list-item>\n\n</div>"
                    },] },
        ];
        /** @nocollapse */
        FacetCheckListComponent.ctorParameters = function () { return []; };
        FacetCheckListComponent.propDecorators = {
            "facets": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "scrollbar": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
            "options": [{ type: core.ViewChildren, args: [FacetCheckListItemComponent,] },],
        };
        return FacetCheckListComponent;
    }(FacetBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetTypeaheadListItemComponent = (function () {
        function FacetTypeaheadListItemComponent() {
            this.selected = false;
            this.simplified = false;
            this.tabbable = false;
            this.itemFocus = new core.EventEmitter();
            this.selectedChange = new core.EventEmitter();
        }
        Object.defineProperty(FacetTypeaheadListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.getLabel =
            function () {
                return this.facet ? this.facet.title : null;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.focus =
            function () {
                this.option.nativeElement.focus();
            };
        FacetTypeaheadListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-typeahead-list-item',
                        template: "<div #option\n    role=\"option\"\n    class=\"facet-typeahead-list-selected-option\"\n    [attr.aria-checked]=\"selected\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\">\n\n    <ux-checkbox [clickable]=\"false\" [value]=\"selected\" [simplified]=\"simplified\" [tabindex]=\"-1\" [disabled]=\"disabled\">\n        <span class=\"facet-typeahead-list-selected-option-title\">{{ facet?.title }}</span>\n        <span class=\"facet-typeahead-list-selected-option-count\">({{ facet?.count }})</span>\n    </ux-checkbox>\n\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        FacetTypeaheadListItemComponent.ctorParameters = function () { return []; };
        FacetTypeaheadListItemComponent.propDecorators = {
            "facet": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "simplified": [{ type: core.Input },],
            "tabbable": [{ type: core.Input },],
            "itemFocus": [{ type: core.Output },],
            "selectedChange": [{ type: core.Output },],
            "option": [{ type: core.ViewChild, args: ['option',] },],
        };
        return FacetTypeaheadListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$1 = 1;
    var FacetTypeaheadListComponent = (function (_super) {
        __extends(FacetTypeaheadListComponent, _super);
        function FacetTypeaheadListComponent(typeaheadKeyService, facetContainer, elementRef, _announcer) {
            var _this = _super.call(this, facetContainer, elementRef) || this;
            _this.typeaheadKeyService = typeaheadKeyService;
            _this._announcer = _announcer;
            _this.expanded = true;
            _this.suggestions = [];
            _this.simplified = true;
            _this.query$ = new BehaviorSubject.BehaviorSubject('');
            _this.loading = false;
            _this.activeIndex = 0;
            _this.typeaheadId = "ux-facet-typeahead-" + uniqueId$1++;
            _this.typeaheadOpen = false;
            _this.typeaheadOptions = [];
            _this._config = { placeholder: '', maxResults: 50, minCharacters: 1 };
            return _this;
        }
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "typeaheadConfig", {
            get: /**
             * @return {?}
             */ function () {
                return this._config;
            },
            set: /**
             * @param {?} config
             * @return {?}
             */ function (config) {
                this._config = __assign({ placeholder: '', maxResults: 50, minCharacters: 1 }, config);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                // set up search query subscription
                this.query$.pipe(operators.takeUntil(this._onDestroy), operators.tap(function () {
                    _this.loading = true;
                    _this.typeaheadOptions = [];
                }), operators.mergeMap(function () {
                    return _this.getFacetObservable().pipe(operators.map(function (facets) {
                        return facets.filter(function (facet) { return !facet.disabled && !_this.selected.find(function (selectedFacet) { return selectedFacet === facet; }); })
                            .slice(0, _this._config.maxResults);
                    }));
                })).subscribe(function (facets) {
                    _this.loading = false;
                    _this.typeaheadOptions = facets;
                });
                this._focusKeyManager = new a11y.FocusKeyManager(this.options).withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onKeydown =
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onFocus =
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.toggleFacet =
            function (index, facet) {
                this.toggleFacetSelection(facet);
                this._focusKeyManager.setActiveItem(index);
            };
        /** Only show typeahead if we have enough characters */
        /**
         * Only show typeahead if we have enough characters
         * @param {?=} query
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.updateTypeahead =
            function (query) {
                if (query === void 0) {
                    query = '';
                }
                this.typeaheadOpen = query.length >= this._config.minCharacters;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.getFacetObservable =
            function () {
                return this.facets instanceof Observable.Observable ? this.facets : of.of(this.facets);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.select =
            function (event) {
                // check to make sure that the item is not currently selected
                if (this.selected.find(function (facet) { return facet === event.option; })) {
                    return;
                }
                // select the facet
                this.selectFacet(event.option);
                // clear the typeahead
                this.query$.next('');
                // announce the selected facet
                this._announcer.announce((((event.option))).title + " selected.");
            };
        FacetTypeaheadListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-typeahead-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<div class=\"facet-typeahead-list-container\" role=\"listbox\" *ngIf=\"expanded\">\n\n    <div class=\"facet-typeahead-list-selected-container\" tabindex=\"-1\" *ngIf=\"suggestions?.length > 0\">\n\n        <ux-facet-typeahead-list-item\n            *ngFor=\"let facet of suggestions; let index = index\"\n            [facet]=\"facet\"\n            [tabbable]=\"activeIndex === index\"\n            [selected]=\"isFacetSelected(facet)\"\n            (selectedChange)=\"toggleFacet(index, facet)\"\n            (keydown)=\"onKeydown($event)\"\n            (itemFocus)=\"onFocus(index)\">\n        </ux-facet-typeahead-list-item>\n\n    </div>\n\n    <div class=\"facet-typeahead-list-control\">\n\n        <!-- Create Typeahead Control -->\n        <input type=\"text\"\n            class=\"form-control\"\n            [placeholder]=\"typeaheadConfig?.placeholder\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            aria-autocomplete=\"list\"\n            aria-multiline=\"false\"\n            [attr.aria-controls]=\"typeaheadId\"\n            [ngModel]=\"query$ | async\"\n            (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n            (keydown)=\"typeaheadKeyService.handleKey($event, typeahead)\"\n            (blur)=\"typeaheadOpen = false\">\n\n        <ux-typeahead #typeahead\n            [id]=\"typeaheadId\"\n            [(open)]=\"typeaheadOpen\"\n            [loading]=\"loading\"\n            display=\"title\"\n            [options]=\"typeaheadOptions\"\n            [optionTemplate]=\"facetOptionTemplate\"\n            [selectOnEnter]=\"true\"\n            (optionSelected)=\"select($event)\"\n            (highlightedElementChange)=\"highlightedElement = $event\">\n        </ux-typeahead>\n\n    </div>\n\n</div>\n\n<ng-template #facetOptionTemplate let-option=\"option\" let-api=\"api\">\n    <p class=\"facet-typeahead-list-option\" [attr.aria-label]=\"option.title\">\n        <span [innerHTML]=\"option.title | facetTypeaheadHighlight: (query$ | async)\"></span>\n        <span class=\"facet-typeahead-list-option-count\"\n            *ngIf=\"option.count\">\n            ({{ option.count }})\n        </span>\n    </p>\n</ng-template>"
                    },] },
        ];
        /** @nocollapse */
        FacetTypeaheadListComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService, },
                { type: FacetContainerComponent, },
                { type: core.ElementRef, },
                { type: a11y.LiveAnnouncer, },
            ];
        };
        FacetTypeaheadListComponent.propDecorators = {
            "facets": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
            "suggestions": [{ type: core.Input },],
            "simplified": [{ type: core.Input },],
            "typeaheadConfig": [{ type: core.Input },],
            "options": [{ type: core.ViewChildren, args: [FacetTypeaheadListItemComponent,] },],
        };
        return FacetTypeaheadListComponent;
    }(FacetBaseComponent));
    var FacetTypeaheadHighlight = (function () {
        function FacetTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FacetTypeaheadHighlight.prototype.transform =
            function (value, searchQuery) {
                var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"facet-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FacetTypeaheadHighlight.decorators = [
            { type: core.Pipe, args: [{
                        name: 'facetTypeaheadHighlight'
                    },] },
        ];
        /** @nocollapse */
        FacetTypeaheadHighlight.ctorParameters = function () { return []; };
        return FacetTypeaheadHighlight;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$1 = [
        FacetContainerComponent,
        FacetHeaderComponent,
        FacetBaseComponent,
        FacetCheckListComponent,
        FacetCheckListItemComponent,
        FacetTypeaheadListComponent,
        FacetTypeaheadListItemComponent,
        FacetTypeaheadHighlight
    ];
    var FacetsModule = (function () {
        function FacetsModule() {
        }
        FacetsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            common.CommonModule,
                            forms.FormsModule,
                            CheckboxModule,
                            TooltipModule,
                            ReorderableModule,
                            TypeaheadModule
                        ],
                        exports: DECLARATIONS$1,
                        declarations: DECLARATIONS$1
                    },] },
        ];
        /** @nocollapse */
        FacetsModule.ctorParameters = function () { return []; };
        return FacetsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Facet = (function () {
        function Facet(title, data, count, disabled, id) {
            if (data === void 0) {
                data = {};
            }
            if (disabled === void 0) {
                disabled = false;
            }
            this.title = title;
            this.data = data;
            this.count = count;
            this.disabled = disabled;
            this.id = id;
        }
        return Facet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationService = (function () {
        function MenuNavigationService() {
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
        }
        MenuNavigationService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MenuNavigationService.ctorParameters = function () { return []; };
        return MenuNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationItemDirective = (function () {
        function MenuNavigationItemDirective(service, _elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.activated = new core.EventEmitter();
            this._subscription = service.active$.subscribe(function (next) {
                if (next === _this) {
                    _this.setActive();
                }
            });
        }
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.setActive =
            function () {
                this._elementRef.nativeElement.focus();
                this.activated.emit();
            };
        MenuNavigationItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationItem]'
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationItemDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService, },
                { type: core.ElementRef, },
            ];
        };
        MenuNavigationItemDirective.propDecorators = {
            "activated": [{ type: core.Output },],
        };
        return MenuNavigationItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationDirective = (function () {
        function MenuNavigationDirective(_service, _elementRef, document) {
            this._service = _service;
            this._elementRef = _elementRef;
            this.toggleButtonPosition = 'top';
            this.navigatedOut = new core.EventEmitter();
            this._subscription = new Subscription.Subscription();
            this._document = document;
        }
        Object.defineProperty(MenuNavigationDirective.prototype, "activeIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemsOrdered.indexOf(this._service.active$.value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnInit =
            function () {
                if (this.toggleButton) {
                    this._subscription.add(this.toggleButton.keyEnter.subscribe(this.focusFirst.bind(this)));
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                this._subscription.add(this.items.changes.subscribe(function () {
                    _this._itemsOrdered = _this.items.toArray();
                }));
                this._itemsOrdered = this.items.toArray();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.focusFirst =
            function () {
                this.moveFirst();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.keydownHandler =
            function (event) {
                // Only handle events when focus in within the list of menu items
                if (!this._elementRef.nativeElement.contains(this._document.activeElement)) {
                    return;
                }
                var /** @type {?} */ handled = false;
                switch (event.key) {
                    case 'ArrowUp':
                    case 'Up':
                        this.movePrevious(event);
                        handled = true;
                        break;
                    case 'ArrowDown':
                    case 'Down':
                        this.moveNext(event);
                        handled = true;
                        break;
                    case 'ArrowLeft':
                    case 'Left':
                        if (this.toggleButtonPosition === 'left') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case 'ArrowRight':
                    case 'Right':
                        if (this.toggleButtonPosition === 'right') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case 'Home':
                        this.moveFirst();
                        handled = true;
                        break;
                    case 'End':
                        this.moveLast();
                        handled = true;
                        break;
                    case 'Escape':
                        this.navigatedOut.emit(event);
                        handled = true;
                        break;
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveNext =
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex + 1;
                if (nextIndex < this._itemsOrdered.length) {
                    // Activate the next menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'bottom') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.movePrevious =
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex - 1;
                if (nextIndex >= 0) {
                    // Activate the previous menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'top') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveFirst =
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[0]);
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveLast =
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[this._itemsOrdered.length - 1]);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveToToggleButton =
            function (event) {
                if (this.toggleButton) {
                    this.toggleButton.focus();
                    this.toggleButton.menuOpen = false;
                }
                this.navigatedOut.emit(event);
            };
        MenuNavigationDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigation]',
                        exportAs: 'uxMenuNavigation',
                        providers: [MenuNavigationService]
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService, },
                { type: core.ElementRef, },
                { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
            ];
        };
        MenuNavigationDirective.propDecorators = {
            "toggleButton": [{ type: core.Input },],
            "toggleButtonPosition": [{ type: core.Input },],
            "navigatedOut": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [MenuNavigationItemDirective, { descendants: true },] },],
            "keydownHandler": [{ type: core.HostListener, args: ['document:keydown', ['$event'],] },],
        };
        return MenuNavigationDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationToggleDirective = (function () {
        function MenuNavigationToggleDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.menuPosition = 'bottom';
            this.menuOpenChange = new core.EventEmitter();
            this.keyEnter = new core.EventEmitter();
        }
        Object.defineProperty(MenuNavigationToggleDirective.prototype, "menuOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._menuOpen = value;
                this.menuOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.focus =
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.keydownHandler =
            function (event) {
                var _this = this;
                if (this.isKeyMatch(event.key)) {
                    // Open the menu
                    this.menuOpen = true;
                    // Allow the menu to init, then send the event to give it focus
                    setTimeout(function () {
                        _this.keyEnter.emit();
                    });
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} key
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.isKeyMatch =
            function (key) {
                switch (key) {
                    case 'Enter':
                    case ' ':
                        return true;
                    case 'ArrowUp':
                    case 'Up':
                        return this.menuPosition === 'top';
                    case 'ArrowDown':
                    case 'Down':
                        return this.menuPosition === 'bottom';
                    case 'ArrowLeft':
                    case 'Left':
                        return this.menuPosition === 'left';
                    case 'ArrowRight':
                    case 'Right':
                        return this.menuPosition === 'right';
                }
                return false;
            };
        MenuNavigationToggleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationToggle]',
                        exportAs: 'uxMenuNavigationToggle'
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationToggleDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        MenuNavigationToggleDirective.propDecorators = {
            "menuOpen": [{ type: core.Input },],
            "menuPosition": [{ type: core.Input },],
            "menuOpenChange": [{ type: core.Output },],
            "keydownHandler": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
        };
        return MenuNavigationToggleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS = [
        MenuNavigationDirective,
        MenuNavigationItemDirective,
        MenuNavigationToggleDirective
    ];
    var MenuNavigationModule = (function () {
        function MenuNavigationModule() {
        }
        MenuNavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: EXPORTS,
                        declarations: EXPORTS,
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationModule.ctorParameters = function () { return []; };
        return MenuNavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterContainerComponent = (function () {
        function FilterContainerComponent() {
            this.filters = [];
            this.filtersChange = new core.EventEmitter();
            this.events = new core.EventEmitter();
        }
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterContainerComponent.prototype.addFilter =
            function (filter) {
                this.filters.push(filter);
                this.events.next(new FilterAddEvent(filter));
                this.filtersChange.emit(this.filters);
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterContainerComponent.prototype.removeFilter =
            function (filter) {
                var /** @type {?} */ idx = this.filters.findIndex(function (filters) { return filters === filter; });
                if (idx !== -1) {
                    this.filters.splice(idx, 1);
                    this.events.next(new FilterRemoveEvent(filter));
                    this.filtersChange.emit(this.filters);
                }
            };
        /**
         * @return {?}
         */
        FilterContainerComponent.prototype.removeAll =
            function () {
                this.events.next(new FilterRemoveAllEvent());
            };
        FilterContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-container',
                        template: "<ng-content></ng-content>\n\n<!-- Add a Clear Button -->\n<button class=\"btn btn-link btn-icon btn-secondary m-l-xs\"\n    tabindex=\"0\"\n    aria-label=\"Clear all filters\"\n    i18n-aria-label\n    *ngIf=\"filters.length > 0\"\n    [uxTooltip]=\"clearTooltip || 'Clear All'\"\n    (click)=\"removeAll()\">\n\n    <svg class=\"filter-selected-clear-graphic\" width=\"100%\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n        <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n        <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n        <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n        <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n        <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n    </svg>\n\n</button>"
                    },] },
        ];
        /** @nocollapse */
        FilterContainerComponent.ctorParameters = function () { return []; };
        FilterContainerComponent.propDecorators = {
            "filters": [{ type: core.Input },],
            "clearTooltip": [{ type: core.Input },],
            "filtersChange": [{ type: core.Output },],
            "events": [{ type: core.Output },],
        };
        return FilterContainerComponent;
    }());
    var FilterAddEvent = (function () {
        function FilterAddEvent(filter) {
            this.filter = filter;
        }
        return FilterAddEvent;
    }());
    var FilterRemoveEvent = (function () {
        function FilterRemoveEvent(filter) {
            this.filter = filter;
        }
        return FilterRemoveEvent;
    }());
    var FilterRemoveAllEvent = (function () {
        function FilterRemoveAllEvent() {
        }
        return FilterRemoveAllEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterBaseComponent = (function () {
        function FilterBaseComponent(filtersContainer, _announcer) {
            this.filtersContainer = filtersContainer;
            this._announcer = _announcer;
            this._subscription = filtersContainer.events.pipe(operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; })).subscribe(this.removeFilter.bind(this));
        }
        /**
         * @return {?}
         */
        FilterBaseComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.addFilter =
            function (_filter) {
                if (!_filter.initial) {
                    this.filtersContainer.addFilter(_filter);
                    this._announcer.announce("Filter " + _filter.name + " selected.");
                }
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.removeFilter =
            function (_filter) {
                if (!_filter) {
                    return;
                }
                this.filtersContainer.removeFilter(_filter);
                this._announcer.announce("Filter " + _filter.name + " deselected.");
            };
        FilterBaseComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-filter-base'
                    },] },
        ];
        /** @nocollapse */
        FilterBaseComponent.ctorParameters = function () {
            return [
                { type: FilterContainerComponent, decorators: [{ type: core.Host },] },
                { type: a11y.LiveAnnouncer, },
            ];
        };
        FilterBaseComponent.propDecorators = {
            "filters": [{ type: core.Input },],
        };
        return FilterBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterDropdownComponent = (function (_super) {
        __extends(FilterDropdownComponent, _super);
        function FilterDropdownComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.removeFilter =
            function () {
                _super.prototype.removeFilter.call(this, this.selected);
                this.selected = this.initial;
            };
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.ngOnInit =
            function () {
                this.selected = this.initial;
            };
        /**
         * @param {?} filter
         * @param {?} event
         * @return {?}
         */
        FilterDropdownComponent.prototype.selectFilter =
            function (filter, event) {
                this.removeFilter();
                this.selected = filter;
                this.addFilter(this.selected);
                event.stopPropagation();
                event.preventDefault();
            };
        FilterDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dropdown',
                        template: "<div class=\"btn-group\" dropdown [autoClose]=\"true\" #dropdown=\"bs-dropdown\">\n\n    <button\n        type=\"button\"\n        tabindex=\"0\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdown.isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdown.isOpen\"\n        class=\"filter-dropdown btn dropdown-toggle\"\n        [class.active]=\"selected !== initial\">\n        {{ selected?.title }}\n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n\n    <ul *dropdownMenu\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\"\n        class=\"dropdown-menu\" role=\"menu\">\n\n        <li class=\"dropdown-list-item\"\n            *ngFor=\"let filter of filters\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"listitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem\n                [attr.aria-selected]=\"filter === selected\"\n                (click)=\"selectFilter(filter, $event); dropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.enter)=\"selectFilter(filter, $event); dropdown.hide(); menuNavigationToggle.focus()\">\n\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n            </a>\n        </li>\n    </ul>\n</div>",
                    },] },
        ];
        /** @nocollapse */
        FilterDropdownComponent.ctorParameters = function () { return []; };
        FilterDropdownComponent.propDecorators = {
            "initial": [{ type: core.Input },],
        };
        return FilterDropdownComponent;
    }(FilterBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$2 = 1;
    var FilterDynamicComponent = (function (_super) {
        __extends(FilterDynamicComponent, _super);
        function FilterDynamicComponent(typeaheadKeyService, container, announcer) {
            var _this = _super.call(this, container, announcer) || this;
            _this.typeaheadKeyService = typeaheadKeyService;
            _this.defaultOptions = {
                placeholder: '',
                minCharacters: 3,
                maxResults: Infinity
            };
            _this.typeaheadId = "ux-filter-dynamic-typeahead-" + uniqueId$2++;
            _this.query$ = new BehaviorSubject.BehaviorSubject('');
            _this.showTypeahead = true;
            _this.typeaheadItems = [];
            _this.typeaheadOpen = false;
            _this._config = __assign({}, _this.defaultOptions);
            return _this;
        }
        Object.defineProperty(FilterDynamicComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this._config;
            },
            set: /**
             * @param {?} options
             * @return {?}
             */ function (options) {
                this._config = __assign({}, this.defaultOptions, options);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.getItems =
            function () {
                var _this = this;
                var /** @type {?} */ query = this.query$.value.toLowerCase();
                return this.filters.filter(function (item) { return item !== _this.initial && item.name.toLowerCase().indexOf(query) !== -1; })
                    .map(function (item) { return item.name; })
                    .slice(0, this._config.maxResults);
            };
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.ngOnInit =
            function () {
                this.selected = this.initial;
                this.typeaheadItems = this.getItems();
                if (this.options && this.options.maxIndividualItems && this.options.maxIndividualItems + 1 >= this.filters.length) {
                    this.showTypeahead = false;
                }
            };
        /**
         * @param {?} typeaheadOption
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectOption =
            function (typeaheadOption) {
                this.removeFilter();
                var /** @type {?} */ idx = this.filters.findIndex(function (filter) { return filter.name === typeaheadOption.value; });
                this.selected = this.filters[idx];
                this.addFilter(this.selected);
                this.query$.next('');
                this.dropdown.hide();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FilterDynamicComponent.prototype.clickOff =
            function (event) {
                var /** @type {?} */ target = (event.target);
                var /** @type {?} */ hideDropdown = true;
                while (target && target.nodeName !== 'BODY') {
                    if (target.classList.contains('ux-dynamic-filter')) {
                        hideDropdown = false;
                        break;
                    }
                    else {
                        target = target.parentElement;
                    }
                }
                if (hideDropdown) {
                    this.query$.next('');
                    this.dropdown.hide();
                }
            };
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.removeFilter =
            function () {
                if (this.selected !== this.initial) {
                    _super.prototype.removeFilter.call(this, this.selected);
                    this.selected = this.initial;
                }
                this.query$.next('');
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectFilter =
            function (filter) {
                this.removeFilter();
                this.selected = filter;
                this.addFilter(this.selected);
            };
        /**
         * @param {?} query
         * @return {?}
         */
        FilterDynamicComponent.prototype.updateTypeahead =
            function (query) {
                this.typeaheadOpen = query.length >= this._config.minCharacters;
                this.typeaheadItems = this.getItems();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FilterDynamicComponent.prototype.select =
            function (event) {
                // find the filter with the matching name
                var /** @type {?} */ filter = this.filters.find(function (_filter) { return _filter.name === event.option; });
                if (filter) {
                    this.selectFilter(filter);
                }
            };
        FilterDynamicComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dynamic',
                        template: "<div class=\"btn-group ux-dynamic-filter\"\n    dropdown\n    [autoClose]=\"true\"\n    #dynamicDropdown=\"bs-dropdown\">\n\n    <button\n        type=\"button\"\n        tabindex=\"0\"\n        dropdownToggle\n        aria-haspopup=\"true\"\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dynamicDropdown.isOpen\"\n        [attr.aria-expanded]=\"dynamicDropdown.isOpen\"\n        [class.active]=\"selected !== initial\"\n        class=\"filter-dropdown btn dropdown-toggle\">\n        {{ selected?.title }}\n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li class=\"dropdown-list-item\"\n            *ngIf=\"showTypeahead\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"menuitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem\n                [attr.aria-selected]=\"initial === selected\"\n                (click)=\"removeFilter(); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.enter)=\"removeFilter(); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\">\n\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"initial === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ initial.name }}</span>\n            </a>\n        </li>\n\n        <li class=\"dropdown-list-item\"\n            *ngIf=\"selected !== initial && showTypeahead\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"menuitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem>\n                <i class=\"hpe-icon hpe-checkmark\"></i>\n                <span class=\"filter-dropdown-title\">{{ selected.name }}</span>\n            </a>\n        </li>\n\n        <hr>\n\n        <li *ngIf=\"showTypeahead\" class=\"typeahead-box\" role=\"none\">\n\n                <input type=\"text\"\n                    class=\"form-control\"\n                    [placeholder]=\"options?.placeholder || defaultOptions.placeholder\"\n                    [attr.aria-activedescendant]=\"highlightedElement?.id\"\n                    [attr.aria-controls]=\"typeaheadId\"\n                    aria-autocomplete=\"list\"\n                    aria-multiline=\"false\"\n                    [ngModel]=\"query$ | async\"\n                    (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n                    (keydown)=\"typeaheadKeyService.handleKey($event, typeahead); $event.stopPropagation();\"\n                    (keydown.enter)=\"$event.preventDefault()\"\n                    (blur)=\"typeaheadOpen = false\"\n                    (click)=\"$event.stopPropagation()\">\n\n                <ux-typeahead #typeahead\n                    [id]=\"typeaheadId\"\n                    [(open)]=\"typeaheadOpen\"\n                    display=\"title\"\n                    [selectOnEnter]=\"true\"\n                    [options]=\"typeaheadItems\"\n                    [optionTemplate]=\"filterOptionTemplate\"\n                    (optionSelected)=\"select($event); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                    (highlightedElementChange)=\"highlightedElement = $event\">\n                </ux-typeahead>\n        </li>\n\n        <ng-container *ngIf=\"!showTypeahead\">\n\n            <li class=\"dropdown-list-item\"\n                *ngFor=\"let filter of filters\"\n                role=\"none\">\n\n                <a class=\"dropdown-item\"\n                    role=\"menuitem\"\n                    tabindex=\"-1\"\n                    uxMenuNavigationItem\n                    [attr.aria-selected]=\"filter === selected\"\n                    (click)=\"selectFilter(filter); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                    (keydown.enter)=\"selectFilter(filter); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\">\n\n                    <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                    <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n                </a>\n            </li>\n\n        </ng-container>\n\n    </ul>\n</div>\n\n<ng-template #filterOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span [attr.aria-label]=\"option\" [innerHTML]=\"option | filterTypeaheadHighlight: (query$ | async)\"></span>\n</ng-template>",
                        host: {
                            '(document:click)': 'clickOff($event)',
                        }
                    },] },
        ];
        /** @nocollapse */
        FilterDynamicComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService, },
                { type: FilterContainerComponent, },
                { type: a11y.LiveAnnouncer, },
            ];
        };
        FilterDynamicComponent.propDecorators = {
            "filters": [{ type: core.Input },],
            "initial": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "dropdown": [{ type: core.ViewChild, args: [dropdown.BsDropdownDirective,] },],
        };
        return FilterDynamicComponent;
    }(FilterBaseComponent));
    var FilterTypeaheadHighlight = (function () {
        function FilterTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FilterTypeaheadHighlight.prototype.transform =
            function (value, searchQuery) {
                var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"filter-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FilterTypeaheadHighlight.decorators = [
            { type: core.Pipe, args: [{
                        name: 'filterTypeaheadHighlight'
                    },] },
        ];
        /** @nocollapse */
        FilterTypeaheadHighlight.ctorParameters = function () { return []; };
        return FilterTypeaheadHighlight;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$2 = [
        FilterBaseComponent,
        FilterContainerComponent,
        FilterDropdownComponent,
        FilterDynamicComponent,
        FilterTypeaheadHighlight
    ];
    var FilterModule = (function () {
        function FilterModule() {
        }
        FilterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            dropdown.BsDropdownModule.forRoot(),
                            TooltipModule,
                            forms.FormsModule,
                            MenuNavigationModule,
                            common.CommonModule,
                            TypeaheadModule,
                            a11y.A11yModule
                        ],
                        exports: DECLARATIONS$2,
                        declarations: DECLARATIONS$2
                    },] },
        ];
        /** @nocollapse */
        FilterModule.ctorParameters = function () { return []; };
        return FilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardComponent = (function () {
        function FlippableCardComponent() {
            this.direction = 'horizontal';
            this.trigger = 'hover';
            this.width = 280;
            this.height = 200;
            this.flipped = false;
            this.flippedChange = new core.EventEmitter();
        }
        /**
         * @param {?} state
         * @return {?}
         */
        FlippableCardComponent.prototype.setFlipped =
            function (state) {
                this.flipped = state;
                this.flippedChange.emit(this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.toggleFlipped =
            function () {
                this.setFlipped(!this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.clickTrigger =
            function () {
                // add or remove the class depending on whether or not the card has been flipped
                if (this.trigger === 'click') {
                    this.toggleFlipped();
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverEnter =
            function () {
                // if the trigger is hover then begin to flip
                if (this.trigger === 'hover') {
                    this.setFlipped(true);
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverExit =
            function () {
                if (this.trigger === 'hover') {
                    this.setFlipped(false);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        // IE uses different naming
        FlippableCardComponent.prototype.onKeyDown =
            // IE uses different naming
            function (event) {
                if (this.trigger !== 'manual') {
                    this.toggleFlipped();
                    event.preventDefault();
                }
            };
        FlippableCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-flippable-card',
                        template: "<div class=\"ux-flipper\"\n     [class.ux-flip-card]=\"flipped\"\n     [style.width.px]=\"width\"\n     [style.height.px]=\"height\">\n\n    <div class=\"ux-flippable-card-front\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"flipped\">\n\n        <ng-content select=\"ux-flippable-card-front\"></ng-content>\n    </div>\n\n    <div class=\"ux-flippable-card-back\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"!flipped\">\n\n        <ng-content select=\"ux-flippable-card-back\"></ng-content>\n    </div>\n</div>",
                        host: {
                            'tabindex': '0',
                            '[class.horizontal]': 'direction === "horizontal"',
                            '[class.vertical]': 'direction === "vertical"'
                        },
                        exportAs: 'ux-flippable-card'
                    },] },
        ];
        /** @nocollapse */
        FlippableCardComponent.ctorParameters = function () { return []; };
        FlippableCardComponent.propDecorators = {
            "direction": [{ type: core.Input },],
            "trigger": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "height": [{ type: core.Input },],
            "flipped": [{ type: core.Input },],
            "flippedChange": [{ type: core.Output },],
            "clickTrigger": [{ type: core.HostListener, args: ['click',] },],
            "hoverEnter": [{ type: core.HostListener, args: ['mouseenter',] },],
            "hoverExit": [{ type: core.HostListener, args: ['mouseleave',] },],
            "onKeyDown": [{ type: core.HostListener, args: ['keydown.enter', ['$event'],] }, { type: core.HostListener, args: ['keydown.space', ['$event'],] }, { type: core.HostListener, args: ['keydown.spacebar', ['$event'],] },],
        };
        return FlippableCardComponent;
    }());
    var FlippableCardFrontDirective = (function () {
        function FlippableCardFrontDirective() {
        }
        FlippableCardFrontDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-front'
                    },] },
        ];
        /** @nocollapse */
        FlippableCardFrontDirective.ctorParameters = function () { return []; };
        return FlippableCardFrontDirective;
    }());
    var FlippableCardBackDirective = (function () {
        function FlippableCardBackDirective() {
        }
        FlippableCardBackDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-back'
                    },] },
        ];
        /** @nocollapse */
        FlippableCardBackDirective.ctorParameters = function () { return []; };
        return FlippableCardBackDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardModule = (function () {
        function FlippableCardModule() {
        }
        FlippableCardModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective],
                        declarations: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective]
                    },] },
        ];
        /** @nocollapse */
        FlippableCardModule.ctorParameters = function () { return []; };
        return FlippableCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsService = (function () {
        function FloatingActionButtonsService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.open =
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.toggle =
            function () {
                this.open$.next(!this.open$.getValue());
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.close =
            function () {
                this.open$.next(false);
            };
        FloatingActionButtonsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        FloatingActionButtonsService.ctorParameters = function () { return []; };
        return FloatingActionButtonsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsComponent = (function () {
        function FloatingActionButtonsComponent(fab, _elementRef) {
            var _this = this;
            this.fab = fab;
            this._elementRef = _elementRef;
            this.direction = 'top';
            this.openChange = new core.EventEmitter();
            this._subscription = new Subscription.Subscription();
            this._subscription.add(this.fab.open$.subscribe(function (value) { return _this.openChange.emit(value); }));
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                this._subscription.add(this.fab.open$.pipe(operators.filter(function (open) { return open === false; }))
                    .subscribe(function () { return _this.tooltips.forEach(function (tooltip$$1) { return tooltip$$1.hide(); }); }));
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} target
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.close =
            function (target) {
                if (!this._elementRef.nativeElement.contains(target)) {
                    this.fab.close();
                }
            };
        FloatingActionButtonsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-buttons',
                        template: "<ng-content select=\"[fab-primary]\"></ng-content>\n\n<div class=\"floating-action-button-list\" [@fabAnimation]=\"fab.open$ | async\" [ngClass]=\"direction\" *ngIf=\"fab.open$ | async\">\n    <ng-content></ng-content>\n</div>",
                        providers: [FloatingActionButtonsService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        animations: [
                            animations.trigger('fabAnimation', [
                                animations.transition('void => true', [
                                    animations.query('ux-floating-action-button', animations.style({ opacity: 0 })),
                                    animations.query('ux-floating-action-button', animations.stagger(50, animations.animate(250, animations.style({ opacity: 1 }))))
                                ]),
                                animations.transition('true => void', [
                                    animations.query('ux-floating-action-button', animations.stagger(-50, animations.animate(250, animations.style({ opacity: 0 }))))
                                ])
                            ])
                        ]
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonsComponent.ctorParameters = function () {
            return [
                { type: FloatingActionButtonsService, },
                { type: core.ElementRef, },
            ];
        };
        FloatingActionButtonsComponent.propDecorators = {
            "direction": [{ type: core.Input },],
            "tooltips": [{ type: core.ContentChildren, args: [tooltip.TooltipDirective,] },],
            "openChange": [{ type: core.Output },],
            "close": [{ type: core.HostListener, args: ['document:click', ['$event.target'],] },],
        };
        return FloatingActionButtonsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonComponent = (function () {
        function FloatingActionButtonComponent(primary, fab) {
            this.fab = fab;
            this.tabindex = 1;
            this.primary = false;
            this.primary = primary !== null;
        }
        FloatingActionButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-button',
                        template: "<button class=\"btn floating-action-button\" \n        [class.button-primary]=\"primary\" \n        [class.button-secondary]=\"!primary\" \n        (click)=\"primary ? fab.toggle() : fab.close()\">\n\n    <span class=\"hpe-icon floating-action-button-icon\" *ngIf=\"icon\" [ngClass]=\"icon\"></span>\n    <ng-content *ngIf=\"!icon\"></ng-content>\n\n</button>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonComponent.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Attribute, args: ['fab-primary',] },] },
                { type: FloatingActionButtonsService, },
            ];
        };
        FloatingActionButtonComponent.propDecorators = {
            "icon": [{ type: core.Input },],
            "tabindex": [{ type: core.HostBinding },],
        };
        return FloatingActionButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsModule = (function () {
        function FloatingActionButtonsModule() {
        }
        FloatingActionButtonsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ],
                        declarations: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonsModule.ctorParameters = function () { return []; };
        return FloatingActionButtonsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarService = (function () {
        function HierarchyBarService() {
            this.nodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._nodes = [];
        }
        /**
         * Store the root node of the hierarchy tree
         */
        /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
        HierarchyBarService.prototype.setRootNode =
            function (root) {
                // store the root node
                this._root = root;
                // create a flat structure of nodes
                this._nodes = this.getNodeList(root);
                // flatten the array - based on the selected node
                this.nodes$.next(this.getSelectedChildren(root));
            };
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         */
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.selectNode =
            function (node) {
                // deselect all nodes
                this.deselectAll();
                // ensure the current node is selected and its parents
                this.select(node);
                // emit a new node list to trigger change detection
                this.nodes$.next(this.getSelectedChildren(this._root));
            };
        /**
         * Handles getting children with support for both arrays and observables
         */
        /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getChildren =
            function (node) {
                var _this = this;
                if (Array.isArray(node.children)) {
                    return of.of({ loading: false, children: node.children });
                }
                var /** @type {?} */ children$ = node.children;
                // if it is an observable then handle loading
                return Observable.Observable.create(function (observer) {
                    // emit initial value
                    observer.next({ loading: true, children: [] });
                    // now wait until the children observable completes
                    children$.pipe(operators.first()).subscribe(function (children) {
                        // replace the observable with an array for future loading
                        node.children = children;
                        // rebuild the node tree
                        // rebuild the node tree
                        _this.setRootNode(_this._root);
                        // emit the latest value
                        observer.next({ loading: false, children: children });
                        // close the observable stream
                        observer.complete();
                    });
                });
            };
        /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.select =
            function (node) {
                node.selected = true;
                if (node.parent) {
                    this.select(node.parent);
                }
            };
        /**
         * Deselects all nodes
         * @return {?}
         */
        HierarchyBarService.prototype.deselectAll =
            function () {
                this._nodes.forEach(function (node) { return node.selected = false; });
            };
        /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getNodeList =
            function (node) {
                var _this = this;
                // if there are no children then return only itself
                if (!node.children || node.children instanceof Observable.Observable || node.children.length === 0) {
                    return [node];
                }
                // store the parent property
                node.children.forEach(function (child) { return child.parent = node; });
                // get all descendants of this node
                var /** @type {?} */ descendants = node.children.reduce(function (nodes, current) { return __spread(nodes, _this.getNodeList(current)); }, []);
                return __spread([node], descendants);
            };
        /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getSelectedChildren =
            function (node) {
                if (node.children instanceof Observable.Observable) {
                    return [node];
                }
                // get the children - and account for when there is none
                var /** @type {?} */ children = node.children || [];
                // check if any child is selected
                var /** @type {?} */ child = children.find(function (_child) { return _child.selected; });
                // return the remaining chain of selected items
                return child ? __spread([node], this.getSelectedChildren(child)) : [node];
            };
        HierarchyBarService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        HierarchyBarService.ctorParameters = function () { return []; };
        return HierarchyBarService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarComponent = (function () {
        function HierarchyBarComponent(hierarchyBar) {
            var _this = this;
            this.hierarchyBar = hierarchyBar;
            this.selectedChange = new core.EventEmitter();
            this.overflow$ = new BehaviorSubject.BehaviorSubject(false);
            this.overflowNodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._subscription = new Subscription.Subscription();
            // subscribe to changes in the selected node
            var /** @type {?} */ selected = hierarchyBar.nodes$.subscribe(function (nodes) { return _this.selectedChange.emit(nodes.length === 0 ? null : nodes[nodes.length - 1]); });
            var /** @type {?} */ changed = hierarchyBar.nodes$.pipe(operators.debounceTime(0)).subscribe(function () { return _this.scrollIntoView(); });
            // store subscriptions
            this._subscription.add(selected);
            this._subscription.add(changed);
        }
        Object.defineProperty(HierarchyBarComponent.prototype, "root", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.setRootNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "selected", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.selectNode(node);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        HierarchyBarComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         */
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
        HierarchyBarComponent.prototype.scrollIntoView =
            function () {
                var _this = this;
                if (!this.nodelist) {
                    return;
                }
                // get the native element
                var nativeElement = this.nodelist.nativeElement;
                // emit whether or not there is overflow
                this.overflow$.next(nativeElement.scrollWidth > nativeElement.offsetWidth);
                // if the hierarchy bar contents do not overflow then do nothing
                if (nativeElement.scrollWidth > nativeElement.offsetWidth) {
                    // determine the amount of overflow
                    var /** @type {?} */ overflowAmount_1 = nativeElement.scrollWidth - nativeElement.offsetWidth;
                    // determine which nodes are not fully visible
                    this.overflowNodes$.next(this.nodes.filter(function (node) { return node.nativeElement.offsetLeft < overflowAmount_1; })
                        .map(function (node, index) { return _this.hierarchyBar.nodes$.value[index]; }));
                    // move the scroll position to always show the last itme
                    this.nodelist.nativeElement.scrollLeft = overflowAmount_1;
                }
            };
        HierarchyBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-hierarchy-bar',
                        template: "<!-- Allow content to be placed on the left of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarLeftAddon]\"></ng-content>\n</aside>\n\n<main #nodelist class=\"hierarchy-bar-nodes\" (uxResize)=\"scrollIntoView()\">\n\n    <div *ngIf=\"overflow$ | async\"\n         #popover=\"ux-popover\"\n         class=\"hierarchy-bar-overflow-indicator\"\n         [style.left.px]=\"nodelist.scrollLeft\"\n         [uxPopover]=\"overflow\"\n         [popoverContext]=\"{ popover: popover }\"\n         placement=\"bottom\"\n         popoverClass=\"hierarchy-bar-popover\">\n        . . .\n    </div>\n\n    <div #nodeElement class=\"hierarchy-bar-node\"\n         *ngFor=\"let node of hierarchyBar.nodes$ | async\">\n\n        <button class=\"hierarchy-bar-node-content\"\n                [attr.aria-label]=\"node.title\"\n                (click)=\"hierarchyBar.selectNode(node)\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n        </button>\n\n        <!-- Show a dropdown arrow if there are children -->\n        <button *ngIf=\"node.children\"\n              #popover=\"ux-popover\"\n              aria-label=\"Show children\"\n              role=\"button\"\n              class=\"hierarchy-bar-node-arrow hpe-icon hpe-next\"\n              [uxPopover]=\"content\"\n              [popoverContext]=\"{ node: node, popover: popover }\"\n              placement=\"bottom\"\n              popoverClass=\"hierarchy-bar-popover\"\n              tabindex=\"0\">\n        </button>\n\n    </div>\n\n</main>\n\n<!-- Allow content to be placed on the right of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarRightAddon]\"></ng-content>\n</aside>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n\n    <!-- Loading Indicator -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li class=\"hierarchy-bar-node-list-item\">\n            <ng-container [ngTemplateOutlet]=\"loadingIndicator || defaultLoadingIndicator\"></ng-container>\n        </li>\n    </ul>\n\n    <!-- List of children -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"!(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li *ngFor=\"let child of (hierarchyBar.getChildren(node) | async).children; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            [focusIf]=\"first\"\n            tabindex=\"0\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Template for the overflow popover list -->\n<ng-template #overflow let-popover=\"popover\">\n\n    <ul class=\"hierarchy-bar-node-list\">\n\n        <li *ngFor=\"let child of overflowNodes$ | async; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            tabindex=\"0\"\n            [focusIf]=\"first\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Loading Indicator Template -->\n<ng-template #defaultLoadingIndicator>\n    <div class=\"hierarchy-bar-node-icon\" alt=\"Hierarchy Bar Loading Indicator\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n    </div>\n\n    <!-- Show the name of the current node -->\n    <span class=\"hierarchy-bar-node-title\">Loading...</span>\n</ng-template>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        viewProviders: [HierarchyBarService]
                    },] },
        ];
        /** @nocollapse */
        HierarchyBarComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService, },
            ];
        };
        HierarchyBarComponent.propDecorators = {
            "root": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "loadingIndicator": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
            "nodelist": [{ type: core.ViewChild, args: ['nodelist',] },],
            "nodes": [{ type: core.ViewChildren, args: ['nodeElement',] },],
        };
        return HierarchyBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideDirective = (function () {
        function ClickOutsideDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.uxClickOutside = new core.EventEmitter();
        }
        /**
         * @param {?} event
         * @return {?}
         */
        ClickOutsideDirective.prototype.click =
            function (event) {
                if (this._elementRef.nativeElement !== event.target && !this._elementRef.nativeElement.contains(event.target)) {
                    this.uxClickOutside.emit(event);
                }
            };
        ClickOutsideDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxClickOutside]'
                    },] },
        ];
        /** @nocollapse */
        ClickOutsideDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ClickOutsideDirective.propDecorators = {
            "uxClickOutside": [{ type: core.Output },],
            "click": [{ type: core.HostListener, args: ['document:click', ['$event'],] },],
        };
        return ClickOutsideDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideModule = (function () {
        function ClickOutsideModule() {
        }
        ClickOutsideModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ClickOutsideDirective],
                        declarations: [ClickOutsideDirective]
                    },] },
        ];
        /** @nocollapse */
        ClickOutsideModule.ctorParameters = function () { return []; };
        return ClickOutsideModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniquePopoverId = 0;
    var PopoverComponent = (function (_super) {
        __extends(PopoverComponent, _super);
        function PopoverComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Define a unique id for each popover
             */
            _this.id = "ux-popover-" + ++uniquePopoverId;
            /**
             * This will emit an event any time the user clicks outside the popover
             */
            _this.clickOutside$ = new Subject.Subject();
            return _this;
        }
        /** This will update the title of the popover and trigger change detection */
        /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
        PopoverComponent.prototype.setTitle =
            function (title) {
                this.title = title;
                this._changeDetectorRef.markForCheck();
            };
        PopoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-popover',
                        template: "<div class=\"popover show\" [ngClass]=\"[placement, customClass]\" [id]=\"id\" [attr.role]=\"role\" (uxClickOutside)=\"clickOutside$.next($event)\">\n    <div class=\"arrow\"></div>\n    <h3 class=\"popover-title\" *ngIf=\"title\">{{ title }}</h3>\n    <div class=\"popover-content\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        PopoverComponent.ctorParameters = function () { return []; };
        return PopoverComponent;
    }(TooltipComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverDirective = (function (_super) {
        __extends(PopoverDirective, _super);
        function PopoverDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * All the user to add a custom class to the popover
             */
            _this.customClass = '';
            /**
             * All the user to add a role to the popover - default is tooltip
             */
            _this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            _this.context = {};
            /**
             * Delay the showing of the popover by a number of miliseconds
             */
            _this.delay = 0;
            /**
             * Specify which events should show the popover
             */
            _this.showTriggers = ['click'];
            /**
             * Specify which events should hide the popover
             */
            _this.hideTriggers = ['click', 'clickoutside', 'escape'];
            /**
             * Keep track of the tooltip visibility and update aria-expanded attribute
             */
            _this.isVisible = false;
            /**
             * Internally store the type of this component - usual for distinctions when extending the tooltip class
             */
            _this._type = 'popover';
            return _this;
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        PopoverDirective.prototype.ngOnInit =
            function () {
                // set up the event triggers
                fromEvent.fromEvent(document, 'keydown').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onKeyDown.bind(this));
                // check if there is an aria-described by attribute
                this._ariaDescribedBy = this._elementRef.nativeElement.hasAttribute('aria-describedby');
                // set up the default event triggers
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        PopoverDirective.prototype.ngOnChanges =
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (this._instance && changes["title"]) {
                    this._instance.setTitle(changes["title"].currentValue);
                }
            };
        /**
         * @param {?} overlayRef
         * @return {?}
         */
        PopoverDirective.prototype.createInstance =
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setTitle(this.title);
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                // subscribe to the outside click event
                instance.clickOutside$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClickOutside.bind(this));
                return instance;
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.createPortal =
            function () {
                return this._portal || new portal.ComponentPortal(PopoverComponent, this._viewContainerRef);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        PopoverDirective.prototype.onKeyDown =
            function (event) {
                // if visible and the escape key is pressed and it is one of the hide triggers
                if (this.isVisible && event.keyCode === keycodes.ESCAPE && this.includes(this.hideTriggers, 'escape')) {
                    this.hide();
                }
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.onClickOutside =
            function () {
                // if visible and it is one of the hide triggers
                if (this.isVisible && this.includes(this.hideTriggers, 'clickoutside')) {
                    this.hide();
                }
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        PopoverDirective.prototype.setAriaDescribedBy =
            function (id) {
                // we only want to set the aria-describedby attr when the content is a string and there was no user defined attribute already
                if (this._ariaDescribedBy === false && typeof this.content === 'string') {
                    _super.prototype.setAriaDescribedBy.call(this, id);
                }
            };
        PopoverDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPopover]',
                        exportAs: 'ux-popover'
                    },] },
        ];
        /** @nocollapse */
        PopoverDirective.ctorParameters = function () { return []; };
        PopoverDirective.propDecorators = {
            "content": [{ type: core.Input, args: ['uxPopover',] },],
            "title": [{ type: core.Input, args: ['popoverTitle',] },],
            "disabled": [{ type: core.Input, args: ['popoverDisabled',] },],
            "customClass": [{ type: core.Input, args: ['popoverClass',] },],
            "role": [{ type: core.Input, args: ['popoverRole',] },],
            "context": [{ type: core.Input, args: ['popoverContext',] },],
            "delay": [{ type: core.Input, args: ['popoverDelay',] },],
            "showTriggers": [{ type: core.Input },],
            "hideTriggers": [{ type: core.Input },],
            "isVisible": [{ type: core.HostBinding, args: ['attr.aria-expanded',] },],
        };
        return PopoverDirective;
    }(TooltipDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverModule = (function () {
        function PopoverModule() {
        }
        PopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule,
                            ClickOutsideModule,
                            TooltipModule
                        ],
                        exports: [PopoverDirective],
                        declarations: [PopoverComponent, PopoverDirective],
                        entryComponents: [PopoverComponent]
                    },] },
        ];
        /** @nocollapse */
        PopoverModule.ctorParameters = function () { return []; };
        return PopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarModule = (function () {
        function HierarchyBarModule() {
        }
        HierarchyBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            FocusIfModule,
                            PopoverModule
                        ],
                        exports: [HierarchyBarComponent],
                        declarations: [HierarchyBarComponent],
                    },] },
        ];
        /** @nocollapse */
        HierarchyBarModule.ctorParameters = function () { return []; };
        return HierarchyBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelService = (function () {
        function SidePanelService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        SidePanelService.prototype.open =
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        SidePanelService.prototype.close =
            function () {
                this.open$.next(false);
            };
        SidePanelService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SidePanelService.ctorParameters = function () { return []; };
        return SidePanelService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelComponent = (function () {
        function SidePanelComponent(service, _elementRef) {
            this.service = service;
            this._elementRef = _elementRef;
            this.inline = false;
            this.attachTo = 'window';
            this.width = '50%';
            this.top = '0';
            this.modal = false;
            this.animate = false;
            this.closeOnExternalClick = false;
            this.openChange = new core.EventEmitter();
        }
        Object.defineProperty(SidePanelComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this.service.open$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return 'static';
                }
                if (this.attachTo === 'container') {
                    return 'absolute';
                }
                return 'fixed';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.width === 'number') {
                    return this.width === 0 ? '0' : this.width + 'px';
                }
                return this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssTop", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.top === 'number') {
                    return this.top === 0 ? '0' : this.top + 'px';
                }
                return this.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "componentWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return this.open ? this.cssWidth : '0';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "hostWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline ? '100%' : this.cssWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this.service.open$.subscribe(function (next) {
                    _this.openChange.emit(next);
                });
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.openPanel =
            function () {
                this.service.open();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.closePanel =
            function () {
                this.service.close();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SidePanelComponent.prototype.clickHandler =
            function (event) {
                if (!this.open || !this.closeOnExternalClick) {
                    return;
                }
                var /** @type {?} */ target = (event.target);
                if (!this._elementRef.nativeElement.contains(target) ||
                    (target && target.classList.contains('modal-backdrop'))) {
                    this.closePanel();
                }
            };
        SidePanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-side-panel',
                        exportAs: 'ux-side-panel',
                        template: "<div *ngIf=\"modal && open\" class=\"modal-backdrop\"\n    [style.position]=\"position\"\n    [style.top]=\"cssTop\"></div>\n\n<div class=\"ux-side-panel-host\"\n    [class.modal-panel]=\"modal\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\">\n    <ng-content></ng-content>\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel'
                        }
                    },] },
        ];
        /** @nocollapse */
        SidePanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService, },
                { type: core.ElementRef, },
            ];
        };
        SidePanelComponent.propDecorators = {
            "open": [{ type: core.Input }, { type: core.HostBinding, args: ['class.open',] },],
            "inline": [{ type: core.Input }, { type: core.HostBinding, args: ['class.inline',] },],
            "attachTo": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "top": [{ type: core.Input },],
            "modal": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-modal',] },],
            "animate": [{ type: core.Input }, { type: core.HostBinding, args: ['class.animate',] },],
            "closeOnExternalClick": [{ type: core.Input },],
            "openChange": [{ type: core.Output },],
            "componentWidth": [{ type: core.HostBinding, args: ['style.width',] },],
            "closePanel": [{ type: core.HostListener, args: ['document:keyup.escape',] },],
            "clickHandler": [{ type: core.HostListener, args: ['document:click', ['$event'],] },],
        };
        return SidePanelComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ItemDisplayPanelContentDirective = (function () {
        function ItemDisplayPanelContentDirective() {
        }
        ItemDisplayPanelContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelContent]'
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelContentDirective.ctorParameters = function () { return []; };
        return ItemDisplayPanelContentDirective;
    }());
    var ItemDisplayPanelFooterDirective = (function () {
        function ItemDisplayPanelFooterDirective() {
        }
        ItemDisplayPanelFooterDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelFooter]'
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelFooterDirective.ctorParameters = function () { return []; };
        return ItemDisplayPanelFooterDirective;
    }());
    var ItemDisplayPanelComponent = (function (_super) {
        __extends(ItemDisplayPanelComponent, _super);
        function ItemDisplayPanelComponent(service, elementRef) {
            var _this = _super.call(this, service, elementRef) || this;
            _this.boxShadow = true;
            _this.closeVisible = true;
            _this.shadow = false;
            _this.visibleChange = new core.EventEmitter();
            _this.animate = false;
            _this.closeOnExternalClick = true;
            return _this;
        }
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "preventClose", {
            get: /**
             * @return {?}
             */ function () {
                return !this.closeOnExternalClick;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.closeOnExternalClick = !value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "title", {
            get: /**
             * @return {?}
             */ function () {
                return this.header;
            },
            set: /**
             * @deprecated
             * Title used for adding tooltips and shouldn't be used as an input
             * instead header will be used. This is here to support backward compatibility only
             * this property should not be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.header = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this.open;
            },
            set: /**
             * @param {?} visible
             * @return {?}
             */ function (visible) {
                this.open = visible;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this._itemDisplayPanelSubscription = this.service.open$.subscribe(function (next) {
                    _this.visibleChange.emit(next);
                });
            };
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.ngOnDestroy =
            function () {
                this._itemDisplayPanelSubscription.unsubscribe();
            };
        ItemDisplayPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-item-display-panel',
                        template: "<div class=\"ux-side-panel-host ux-item-display-panel\"\n    [class.box-shadow]=\"boxShadow\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\">\n\n    <div class=\"ux-side-panel-header\" [class.item-display-panel-shadow]=\"shadow\">\n        <h3>{{ header }}</h3>\n        <button *ngIf=\"closeVisible\" type=\"button\" class=\"btn btn-lg btn-link btn-icon button-secondary\" (click)=\"visible = false\">\n            <i class=\"hpe-icon hpe-close\"></i>\n        </button>\n    </div>\n\n    <div class=\"ux-side-panel-content\">\n        <ng-content select=\"[uxItemDisplayPanelContent]\"></ng-content>\n    </div>\n\n    <div class=\"ux-side-panel-footer\" *ngIf=\"footer\">\n        <ng-content select=\"[uxItemDisplayPanelFooter]\"></ng-content>\n    </div>\n\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel ux-item-display-panel'
                        }
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService, },
                { type: core.ElementRef, },
            ];
        };
        ItemDisplayPanelComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "boxShadow": [{ type: core.Input },],
            "closeVisible": [{ type: core.Input },],
            "preventClose": [{ type: core.Input },],
            "shadow": [{ type: core.Input },],
            "footer": [{ type: core.ContentChild, args: [ItemDisplayPanelFooterDirective,] },],
            "visibleChange": [{ type: core.Output },],
            "title": [{ type: core.Input },],
            "visible": [{ type: core.Input },],
        };
        return ItemDisplayPanelComponent;
    }(SidePanelComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$3 = [
        ItemDisplayPanelComponent,
        ItemDisplayPanelContentDirective,
        ItemDisplayPanelFooterDirective
    ];
    var ItemDisplayPanelModule = (function () {
        function ItemDisplayPanelModule() {
        }
        ItemDisplayPanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$3,
                        declarations: DECLARATIONS$3
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelModule.ctorParameters = function () { return []; };
        return ItemDisplayPanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardStepComponent = (function () {
        function WizardStepComponent() {
            this.valid = true;
            this.visitedChange = new core.EventEmitter();
            this._active = false;
            this._visited = false;
        }
        Object.defineProperty(WizardStepComponent.prototype, "visited", {
            get: /**
             * @return {?}
             */ function () {
                return this._visited;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._visited = value;
                this.visitedChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // store the active state of the step
                this._active = value;
                // if the value is true then the step should also be marked as visited
                if (value === true) {
                    this.visited = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        WizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                    },] },
        ];
        /** @nocollapse */
        WizardStepComponent.ctorParameters = function () { return []; };
        WizardStepComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "valid": [{ type: core.Input },],
            "visitedChange": [{ type: core.Input },],
            "visited": [{ type: core.Input },],
        };
        return WizardStepComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardComponent = (function () {
        function WizardComponent() {
            this._step = 0;
            this.steps = new core.QueryList();
            this.orientation = 'horizontal';
            this.nextText = 'Next';
            this.previousText = 'Previous';
            this.cancelText = 'Cancel';
            this.finishText = 'Finish';
            this.nextTooltip = 'Go to the next step';
            this.previousTooltip = 'Go to the previous step';
            this.cancelTooltip = 'Cancel the wizard';
            this.finishTooltip = 'Finish the wizard';
            this.nextDisabled = false;
            this.previousDisabled = false;
            this.cancelDisabled = false;
            this.finishDisabled = false;
            this.nextVisible = true;
            this.previousVisible = true;
            this.cancelVisible = true;
            this.finishVisible = true;
            this.cancelAlwaysVisible = false;
            this.finishAlwaysVisible = false;
            this.onNext = new core.EventEmitter();
            this.onPrevious = new core.EventEmitter();
            this.onCancel = new core.EventEmitter();
            this.onFinishing = new core.EventEmitter();
            this.onFinish = new core.EventEmitter();
            this.stepChanging = new core.EventEmitter();
            this.stepChange = new core.EventEmitter();
            this.invalidIndicator = false;
        }
        Object.defineProperty(WizardComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // only accept numbers as valid options
                if (typeof value === 'number') {
                    // store the active step
                    this._step = value;
                    // update which steps should be active
                    this.update();
                    // emit the change event
                    this.stepChange.next(this.step);
                    // reset the invalid state
                    this.invalidIndicator = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WizardComponent.prototype.ngAfterViewInit =
            function () {
                // initially set the correct visibility of the steps
                setTimeout(this.update.bind(this));
            };
        /**
         * Navigate to the next step
         */
        /**
         * Navigate to the next step
         * @return {?}
         */
        WizardComponent.prototype.next =
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step + 1));
                // check if current step is invalid
                if (!this.getCurrentStep().valid) {
                    this.invalidIndicator = true;
                    return;
                }
                // check if we are currently on the last step
                if ((this.step + 1) < this.steps.length) {
                    this.step++;
                    // emit the current step
                    this.onNext.next(this.step);
                }
            };
        /**
         * Navigate to the previous step
         */
        /**
         * Navigate to the previous step
         * @return {?}
         */
        WizardComponent.prototype.previous =
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step - 1));
                // check if we are currently on the last step
                if (this.step > 0) {
                    this.step--;
                    // emit the current step
                    this.onPrevious.next(this.step);
                }
            };
        /**
         * Perform actions when the finish button is clicked
         */
        /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
        WizardComponent.prototype.finish =
            function () {
                var _this = this;
                // fires when the finish button is clicked always
                this.onFinishing.next();
                /**
                         * This is required because we need to ensure change detection has run
                         * to determine whether or not we have the latest value for the 'valid' input
                         * on the current step. Unfortunately we can't use ChangeDetectorRef as we are looking to run
                         * on content children, and we cant use ApplicationRef.tick() as this does not work in a hybrid app, eg. our docs
                         */
                return new Promise(function (resolve) {
                    setTimeout(function () {
                        // only fires when the finish button is clicked and the step is valid
                        if (_this.getCurrentStep().valid) {
                            _this.onFinish.next();
                        }
                        resolve();
                    });
                });
            };
        /**
         * Perform actions when the cancel button is clicked
         */
        /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
        WizardComponent.prototype.cancel =
            function () {
                this.onCancel.next();
            };
        /**
         * Update the active state of each step
         */
        /**
         * Update the active state of each step
         * @return {?}
         */
        WizardComponent.prototype.update =
            function () {
                var _this = this;
                // update which steps should be active
                this.steps.forEach(function (step, idx) { return step.active = idx === _this.step; });
            };
        /**
         * Jump to a specific step only if the step has previously been visited
         */
        /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
        WizardComponent.prototype.gotoStep =
            function (step) {
                if (step.visited) {
                    var /** @type {?} */ stepIndex = this.steps.toArray().findIndex(function (stp) { return stp === step; });
                    this.stepChanging.next(new StepChangingEvent(this.step, stepIndex));
                    this.step = stepIndex;
                }
            };
        /**
         * Determine if the current step is the last step
         */
        /**
         * Determine if the current step is the last step
         * @return {?}
         */
        WizardComponent.prototype.isLastStep =
            function () {
                return this.step === (this.steps.length - 1);
            };
        /**
         * Reset the wizard - goes to first step and resets visited state
         */
        /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
        WizardComponent.prototype.reset =
            function () {
                // mark all steps as not visited
                this.steps.forEach(function (step) { return step.visited = false; });
                // go to the first step
                this.step = 0;
            };
        /**
         * Get the step at the current index
         */
        /**
         * Get the step at the current index
         * @return {?}
         */
        WizardComponent.prototype.getCurrentStep =
            function () {
                return this.getStepAtIndex(this.step);
            };
        /**
         * Return a step at a specific index
         */
        /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
        WizardComponent.prototype.getStepAtIndex =
            function (index) {
                return this.steps.toArray()[index];
            };
        WizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard',
                        template: "<div class=\"wizard-body\">\n\n    <div class=\"wizard-steps\">\n\n        <div class=\"wizard-step\" [class.active]=\"stp.active\" [class.visited]=\"stp.visited\" [class.invalid]=\"stp.active && !stp.valid && invalidIndicator\" (click)=\"gotoStep(stp)\" *ngFor=\"let stp of steps\">\n            {{ stp.header }}\n        </div>\n\n    </div>\n\n    <div class=\"wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n</div>\n\n<div class=\"wizard-footer\">\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" [disabled]=\"previousDisabled || step === 0\"\n        (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" [disabled]=\"nextDisabled\"\n        (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n        [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n        [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n</div>",
                        host: {
                            '[class]': 'orientation'
                        }
                    },] },
        ];
        /** @nocollapse */
        WizardComponent.ctorParameters = function () { return []; };
        WizardComponent.propDecorators = {
            "steps": [{ type: core.ContentChildren, args: [WizardStepComponent,] },],
            "orientation": [{ type: core.Input },],
            "nextText": [{ type: core.Input },],
            "previousText": [{ type: core.Input },],
            "cancelText": [{ type: core.Input },],
            "finishText": [{ type: core.Input },],
            "nextTooltip": [{ type: core.Input },],
            "previousTooltip": [{ type: core.Input },],
            "cancelTooltip": [{ type: core.Input },],
            "finishTooltip": [{ type: core.Input },],
            "nextDisabled": [{ type: core.Input },],
            "previousDisabled": [{ type: core.Input },],
            "cancelDisabled": [{ type: core.Input },],
            "finishDisabled": [{ type: core.Input },],
            "nextVisible": [{ type: core.Input },],
            "previousVisible": [{ type: core.Input },],
            "cancelVisible": [{ type: core.Input },],
            "finishVisible": [{ type: core.Input },],
            "cancelAlwaysVisible": [{ type: core.Input },],
            "finishAlwaysVisible": [{ type: core.Input },],
            "onNext": [{ type: core.Output },],
            "onPrevious": [{ type: core.Output },],
            "onCancel": [{ type: core.Output },],
            "onFinishing": [{ type: core.Output },],
            "onFinish": [{ type: core.Output },],
            "stepChanging": [{ type: core.Output },],
            "stepChange": [{ type: core.Output },],
            "step": [{ type: core.Input },],
        };
        return WizardComponent;
    }());
    var StepChangingEvent = (function () {
        function StepChangingEvent(from$$1, to) {
            this.from = from$$1;
            this.to = to;
        }
        return StepChangingEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$4 = [
        WizardComponent,
        WizardStepComponent
    ];
    var WizardModule = (function () {
        function WizardModule() {
        }
        WizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TooltipModule
                        ],
                        exports: DECLARATIONS$4,
                        declarations: DECLARATIONS$4
                    },] },
        ];
        /** @nocollapse */
        WizardModule.ctorParameters = function () { return []; };
        return WizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This service is required to provide a form of communication
     * between the marquee wizard steps and the containing marquee wizard.
     * We cannot inject the Host due to the steps being content children
     * rather than view children.
     */
    var MarqueeWizardService = (function () {
        function MarqueeWizardService() {
            this.valid$ = new Subject.Subject();
        }
        MarqueeWizardService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MarqueeWizardService.ctorParameters = function () { return []; };
        return MarqueeWizardService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardStepComponent = (function (_super) {
        __extends(MarqueeWizardStepComponent, _super);
        function MarqueeWizardStepComponent(_marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this._marqueeWizardService = _marqueeWizardService;
            _this.completed = false;
            _this.completedChange = new core.EventEmitter();
            _this._valid = true;
            return _this;
        }
        Object.defineProperty(MarqueeWizardStepComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                if (this._marqueeWizardService) {
                    this._marqueeWizardService.valid$.next({ step: this, valid: valid });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Update the completed state and emit the latest value
         * @param completed whether or not the step is completed
         */
        /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
        MarqueeWizardStepComponent.prototype.setCompleted =
            function (completed) {
                this.completed = completed;
                this.completedChange.emit(completed);
            };
        MarqueeWizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardStepComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService, },
            ];
        };
        MarqueeWizardStepComponent.propDecorators = {
            "icon": [{ type: core.Input },],
            "completed": [{ type: core.Input },],
            "completedChange": [{ type: core.Output },],
        };
        return MarqueeWizardStepComponent;
    }(WizardStepComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardComponent = (function (_super) {
        __extends(MarqueeWizardComponent, _super);
        function MarqueeWizardComponent(marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this.steps = new core.QueryList();
            marqueeWizardService.valid$.pipe(operators.filter(function (event) { return !event.valid; })).subscribe(_this.validChange.bind(_this));
            return _this;
        }
        Object.defineProperty(MarqueeWizardComponent.prototype, "isTemplate", {
            get: /**
             * @return {?}
             */ function () {
                return this.description && this.description instanceof core.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         */
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
        MarqueeWizardComponent.prototype.next =
            function () {
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                if (step.valid) {
                    _super.prototype.next.call(this);
                    // mark this step as completed
                    step.setCompleted(true);
                }
            };
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         */
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
        MarqueeWizardComponent.prototype.finish =
            function () {
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                // call the original finish function
                return _super.prototype.finish.call(this).then(function () {
                    // if the step is valid indicate that it is now complete
                    if (step.valid) {
                        step.setCompleted(true);
                    }
                });
            };
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         */
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
        MarqueeWizardComponent.prototype.validChange =
            function (state) {
                var /** @type {?} */ steps = this.steps.toArray();
                var /** @type {?} */ current = steps.findIndex(function (step) { return step === state.step; });
                var /** @type {?} */ affected = steps.slice(current);
                affected.forEach(function (step) {
                    // the step should no longer be completed
                    step.completed = false;
                    // if the step is not the current step then also mark it as unvisited
                    if (step !== state.step) {
                        step.visited = false;
                    }
                });
            };
        MarqueeWizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard',
                        template: "<div class=\"marquee-wizard-side-panel\">\n\n    <div class=\"marquee-wizard-description-container\" *ngIf=\"description\">\n        <!-- If a template was provided display it -->\n        <ng-container *ngIf=\"isTemplate\" [ngTemplateOutlet]=\"description\"></ng-container>\n\n        <!-- Otherwise wimply display the string -->\n        <ng-container *ngIf=\"!isTemplate\">\n            <p>{{ description }}</p>\n        </ng-container>\n    </div>\n\n    <ul class=\"marquee-wizard-steps\">\n\n        <li class=\"marquee-wizard-step\" *ngFor=\"let step of steps\" (click)=\"gotoStep(step)\" [class.active]=\"step.active\" [class.visited]=\"step.visited\" [class.invalid]=\"!step.valid\">\n            <i class=\"marquee-wizard-step-icon\" [ngClass]=\"step.icon\"></i>\n            <span class=\"marquee-wizard-step-title\">{{ step.header }}</span>\n            <span class=\"marquee-wizard-step-status hpe-icon hpe-checkmark\" *ngIf=\"step.completed\"></span>\n        </li>\n\n    </ul>\n</div>\n\n<div class=\"marquee-wizard-content-panel\">\n    <div class=\"marquee-wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n    <div class=\"modal-footer\">\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" container=\"body\"\n            [disabled]=\"previousDisabled || step === 0\" (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" container=\"body\"\n            [disabled]=\"nextDisabled\" (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n            container=\"body\" [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n            container=\"body\" [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n    </div>\n</div>",
                        providers: [MarqueeWizardService]
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService, },
            ];
        };
        MarqueeWizardComponent.propDecorators = {
            "description": [{ type: core.Input },],
            "steps": [{ type: core.ContentChildren, args: [MarqueeWizardStepComponent,] },],
        };
        return MarqueeWizardComponent;
    }(WizardComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardModule = (function () {
        function MarqueeWizardModule() {
        }
        MarqueeWizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            WizardModule,
                            TooltipModule
                        ],
                        exports: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ],
                        declarations: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardModule.ctorParameters = function () { return []; };
        return MarqueeWizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioService = (function () {
        function AudioService(_http) {
            this._http = _http;
        }
        /**
         * @param {?} mediaElement
         * @return {?}
         */
        AudioService.prototype.getAudioFileMetadata =
            function (mediaElement) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this._http.request(mediaElement.src, { responseType: http.ResponseContentType.Blob }).subscribe(function (response) {
                        var /** @type {?} */ filename = mediaElement.src.substring(mediaElement.src.lastIndexOf('/') + 1);
                        var /** @type {?} */ extension = mediaElement.src.substring(mediaElement.src.lastIndexOf('.') + 1).toLowerCase();
                        var /** @type {?} */ blob = response.blob();
                        var /** @type {?} */ description;
                        switch (extension) {
                            case 'mp3':
                                description = 'MPEG audio layer 3 file';
                                break;
                            case 'wma':
                                description = 'Windows media audio file';
                                break;
                            case 'wav':
                                description = 'WAVE audio file';
                                break;
                            case 'ogg':
                                description = 'Ogg Vorbis file';
                                break;
                            case 'aac':
                                description = 'Advanced audio coding file';
                                break;
                            case 'midi':
                                description = 'Musical instrument digital interface file';
                                break;
                            default:
                                description = 'Audio file';
                                break;
                        }
                        observer.next({
                            filename: filename,
                            extension: extension,
                            description: description,
                            size: blob.size
                        });
                    });
                });
            };
        /**
         * @param {?} url
         * @return {?}
         */
        AudioService.prototype.getWaveformFromUrl =
            function (url) {
                var _this = this;
                // if audio context is not support return a stream of empty data
                if (!((window)).AudioContext) {
                    return of.of([new Float32Array(0)]);
                }
                this._audioContext = new AudioContext();
                this.createVolumeNode();
                this.createAnalyserNode();
                return Observable.Observable.create(function (observer) {
                    // load the media from the URL provided
                    // load the media from the URL provided
                    _this._http.request(url, { responseType: http.ResponseContentType.ArrayBuffer }).subscribe(function (response) {
                        _this.getAudioBuffer(response.arrayBuffer()).subscribe(function (audioBuffer) {
                            // create the buffer source
                            // create the buffer source
                            _this.createBufferSource(audioBuffer);
                            var /** @type {?} */ dataPoints = [];
                            var /** @type {?} */ channels = _this._audioBuffer.numberOfChannels;
                            // extract the data from each channel
                            for (var /** @type {?} */ channelIdx = 0; channelIdx < channels; channelIdx++) {
                                dataPoints[channelIdx] = _this._audioBuffer.getChannelData(channelIdx);
                            }
                            observer.next(dataPoints);
                            observer.complete();
                            // cleanup after ourselves
                            dataPoints = null;
                        }, function (error) { return observer.error(error); });
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
        AudioService.prototype.getWaveformPoints =
            function (channels, skip) {
                if (channels === void 0) {
                    channels = [];
                }
                if (skip === void 0) {
                    skip = 1000;
                }
                var /** @type {?} */ waveform = [];
                var /** @type {?} */ duration = channels.length > 0 ? channels[0].length : 0;
                var _loop_1 = function (idx) {
                    // get all the channel data for a specific point
                    var /** @type {?} */ points = channels.map(function (channel) { return channel[idx]; });
                    // find the minimum point and maximum points at each position across all channels
                    waveform.push({
                        min: points.reduce(function (previous, current) { return current < previous ? current : previous; }),
                        max: points.reduce(function (previous, current) { return current > previous ? current : previous; })
                    });
                };
                // convert each channel data to a series of waveform points
                for (var /** @type {?} */ idx = 0; idx < duration; idx += skip) {
                    _loop_1(idx);
                }
                return waveform;
            };
        /**
         * @param {?} arrayBuffer
         * @return {?}
         */
        AudioService.prototype.getAudioBuffer =
            function (arrayBuffer) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this.getOfflineAudioContext().decodeAudioData(arrayBuffer, function (audioBuffer) {
                        observer.next(audioBuffer);
                        observer.complete();
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @return {?}
         */
        AudioService.prototype.getOfflineAudioContext =
            function () {
                return new OfflineAudioContext(1, 2, this._audioContext.sampleRate || 44100);
            };
        /**
         * @param {?} audioBuffer
         * @return {?}
         */
        AudioService.prototype.createBufferSource =
            function (audioBuffer) {
                this.disconnectSource();
                this._audioBuffer = audioBuffer;
                this._audioBufferSource = this._audioContext.createBufferSource();
                this._audioBufferSource.buffer = this._audioBuffer;
                this._audioBufferSource.connect(this._analyserNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createVolumeNode =
            function () {
                this._gainNode = this._audioContext.createGain();
                this._gainNode.connect(this._audioContext.destination);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createAnalyserNode =
            function () {
                this._analyserNode = this._audioContext.createAnalyser();
                this._analyserNode.connect(this._gainNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.disconnectSource =
            function () {
                if (this._audioBufferSource) {
                    this._audioBufferSource.disconnect();
                }
            };
        AudioService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        AudioService.ctorParameters = function () {
            return [
                { type: http.Http, },
            ];
        };
        return AudioService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioServiceModule = (function () {
        function AudioServiceModule() {
        }
        AudioServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [http.HttpModule],
                        providers: [AudioService]
                    },] },
        ];
        /** @nocollapse */
        AudioServiceModule.ctorParameters = function () { return []; };
        return AudioServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionService = (function () {
        function FrameExtractionService() {
        }
        /**
         * @param {?} source
         * @return {?}
         */
        FrameExtractionService.prototype.createVideoPlayer =
            function (source) {
                var /** @type {?} */ videoPlayer = document.createElement('video');
                videoPlayer.preload = 'auto';
                videoPlayer.src = source;
                return videoPlayer;
            };
        /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        FrameExtractionService.prototype.createCanvas =
            function (width, height) {
                var /** @type {?} */ canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            };
        /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.goToFrame =
            function (videoPlayer, time) {
                videoPlayer.currentTime = time;
                return fromEvent.fromEvent(videoPlayer, time === 0 ? 'loadeddata' : 'seeked');
            };
        /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
        FrameExtractionService.prototype.getThumbnail =
            function (videoPlayer, canvas, time, width, height) {
                var _this = this;
                if (width === void 0) {
                    width = 160;
                }
                if (height === void 0) {
                    height = 90;
                }
                return Observable.Observable.create(function (observer) {
                    // go to specified frame
                    var /** @type {?} */ subscription = _this.goToFrame(videoPlayer, time).subscribe(function (event) {
                        // create image from current frame
                        canvas.getContext('2d').drawImage(videoPlayer, 0, 0, width, height);
                        observer.next({ image: canvas.toDataURL(), width: width, height: height, time: time });
                        observer.complete();
                        subscription.unsubscribe();
                    });
                });
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnail =
            function (source, width, height, time) {
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                var /** @type {?} */ frameSubscription = this.getThumbnail(videoPlayer, canvas, time, width, height);
                // ensure we release memory after we are finished
                frameSubscription.subscribe(null, null, function () {
                    videoPlayer = null;
                    canvas = null;
                });
                return frameSubscription;
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnails =
            function (source, width, height, start, end, skip) {
                var _this = this;
                if (skip === void 0) {
                    skip = 5;
                }
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                return Observable.Observable.create(function (observer) {
                    fromEvent.fromEvent(videoPlayer, 'loadedmetadata').subscribe(function () {
                        // calculate the frames required
                        var /** @type {?} */ frames = [];
                        for (var /** @type {?} */ idx = start; idx < end; idx += skip) {
                            frames.push(_this.getThumbnail(videoPlayer, canvas, idx, width, height));
                        }
                        concat.concat.apply(void 0, __spread(frames)).subscribe(function (frame) { return observer.next(frame); }, null, function () {
                            videoPlayer = null;
                            canvas = null;
                            observer.complete();
                        });
                    });
                });
            };
        FrameExtractionService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        FrameExtractionService.ctorParameters = function () { return []; };
        return FrameExtractionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionModule = (function () {
        function FrameExtractionModule() {
        }
        FrameExtractionModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [FrameExtractionService],
                    },] },
        ];
        /** @nocollapse */
        FrameExtractionModule.ctorParameters = function () { return []; };
        return FrameExtractionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerService = (function () {
        function MediaPlayerService(_frameExtractionService) {
            var _this = this;
            this._frameExtractionService = _frameExtractionService;
            this.type = 'video';
            this.loaded = false;
            /*
                    Create observables for media player events
                */
            this.playing = new BehaviorSubject.BehaviorSubject(false);
            this.initEvent = new BehaviorSubject.BehaviorSubject(false);
            this.abortEvent = new Subject.Subject();
            this.canPlayEvent = new BehaviorSubject.BehaviorSubject(false);
            this.canPlayThroughEvent = new BehaviorSubject.BehaviorSubject(false);
            this.durationChangeEvent = new Subject.Subject();
            this.endedEvent = new Subject.Subject();
            this.errorEvent = new Subject.Subject();
            this.loadedDataEvent = new Subject.Subject();
            this.loadedMetadataEvent = new Subject.Subject();
            this.loadStartEvent = new Subject.Subject();
            this.pauseEvent = new Subject.Subject();
            this.playEvent = new Subject.Subject();
            this.playingEvent = new Subject.Subject();
            this.rateChangeEvent = new Subject.Subject();
            this.seekedEvent = new Subject.Subject();
            this.seekingEvent = new Subject.Subject();
            this.stalledEvent = new Subject.Subject();
            this.suspendEvent = new Subject.Subject();
            this.timeUpdateEvent = new Subject.Subject();
            this.volumeChangeEvent = new Subject.Subject();
            this.waitingEvent = new Subject.Subject();
            this.mediaClickEvent = new Subject.Subject();
            this.fullscreenEvent = new BehaviorSubject.BehaviorSubject(false);
            this.quietModeEvent = new BehaviorSubject.BehaviorSubject(false);
            this.progressEvent = Observable.Observable.create(function (observer) {
                // repeat until the whole video has fully loaded
                var /** @type {?} */ interval = setInterval(function () {
                    var /** @type {?} */ buffered = (_this._mediaPlayer.buffered);
                    observer.next(buffered);
                    if (buffered.length === 1 && buffered.start(0) === 0 && buffered.end(0) === _this.duration) {
                        observer.complete();
                        clearInterval(interval);
                    }
                }, 1000);
            });
            this._fullscreen = false;
        }
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayer", {
            /*
                Create all the getters and setters the can be used by media player extensions
            */
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this._quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // quiet mode cannot be enabled on audio player
                if (this.type === 'audio') {
                    value = false;
                }
                this._quietMode = value;
                this.quietModeEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetWidth : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetHeight : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "audioTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.audioTracks : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "autoplay", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.autoplay : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.autoplay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "buffered", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.buffered : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "crossOrigin", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.crossOrigin : null;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.crossOrigin = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentSrc", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentSrc : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentTime", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentTime : 0;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.currentTime = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultMuted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultMuted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultMuted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultPlaybackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultPlaybackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultPlaybackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "duration", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.duration : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "ended", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.ended : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "loop", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.loop : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "muted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.muted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.muted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "networkState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer.networkState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "paused", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.paused : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "playbackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.playbackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.playbackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "played", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.played : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "preload", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.preload : 'auto';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.preload = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "readyState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.readyState : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seekable", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seekable : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seeking", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seeking : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "src", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.src : '';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.src = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "textTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.textTracks : new TextTrackList();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "videoTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.videoTracks : new VideoTrackList();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.volume : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.volume = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "fullscreen", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._fullscreen : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._fullscreen = value;
                this.fullscreenEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
        MediaPlayerService.prototype.setMediaPlayer =
            function (hostElement, mediaPlayer) {
                this._hostElement = hostElement;
                this._mediaPlayer = mediaPlayer;
                this.initEvent.next(true);
            };
        /**
         * Toggle playing state
         */
        /**
         * Toggle playing state
         * @return {?}
         */
        MediaPlayerService.prototype.togglePlay =
            function () {
                // prevent any action is not loaded
                if (this.loaded === false) {
                    return;
                }
                if (this.paused) {
                    this.play();
                }
                else {
                    this.pause();
                }
            };
        /**
         * Starts playing the audio/video
         */
        /**
         * Starts playing the audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.play =
            function () {
                this._mediaPlayer.play();
            };
        /**
         * Pauses the currently playing audio/video
         */
        /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.pause =
            function () {
                this._mediaPlayer.pause();
            };
        /**
         * Re-loads the audio/video element
         */
        /**
         * Re-loads the audio/video element
         * @return {?}
         */
        MediaPlayerService.prototype.load =
            function () {
                this._mediaPlayer.load();
            };
        /**
         * Checks if the browser can play the specified audio/video type
         */
        /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
        MediaPlayerService.prototype.canPlayType =
            function (type) {
                return this._mediaPlayer.canPlayType(type);
            };
        /**
         * Adds a new text track to the audio/video
         */
        /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
        MediaPlayerService.prototype.addTextTrack =
            function (kind, label, language) {
                return this._mediaPlayer.addTextTrack(kind, label, language);
            };
        /**
         * Attempt to display media in fullscreen mode
         */
        /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
        MediaPlayerService.prototype.requestFullscreen =
            function () {
                if (this._hostElement.requestFullscreen) {
                    this._hostElement.requestFullscreen();
                }
                else if (this._hostElement.webkitRequestFullscreen) {
                    this._hostElement.webkitRequestFullscreen();
                }
                else if (((this._hostElement)).msRequestFullscreen) {
                    ((this._hostElement)).msRequestFullscreen();
                }
                else if (((this._hostElement)).mozRequestFullScreen) {
                    ((this._hostElement)).mozRequestFullScreen();
                }
            };
        /**
         * Exit full screen mode
         */
        /**
         * Exit full screen mode
         * @return {?}
         */
        MediaPlayerService.prototype.exitFullscreen =
            function () {
                if (((this._hostElement)).exitFullscreen) {
                    document.exitFullscreen();
                }
                else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                else if (((document)).msExitFullscreen) {
                    ((document)).msExitFullscreen();
                }
                else if (((document)).mozCancelFullScreen) {
                    ((document)).mozCancelFullScreen();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerService.prototype.fullscreenChange =
            function (event) {
                this.fullscreen = ((document)).fullscreen || document.webkitIsFullScreen || ((document)).mozFullScreen || ((document)).msFullscreenElement !== null && ((document)).msFullscreenElement !== undefined;
                this.fullscreenEvent.next(this.fullscreen);
            };
        /**
         * Toggle Fullscreen State
         */
        /**
         * Toggle Fullscreen State
         * @return {?}
         */
        MediaPlayerService.prototype.toggleFullscreen =
            function () {
                if (this.fullscreen) {
                    this.exitFullscreen();
                }
                else {
                    this.requestFullscreen();
                }
            };
        /**
         * Extract the frames from the video
         */
        /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
        MediaPlayerService.prototype.getFrames =
            function (width, height, skip) {
                if (this.type === 'video') {
                    return this._frameExtractionService.getFrameThumbnails(this.source, width, height, 0, this.duration, 10);
                }
                return from.from([]);
            };
        MediaPlayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MediaPlayerService.ctorParameters = function () {
            return [
                { type: FrameExtractionService, },
            ];
        };
        return MediaPlayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerComponent = (function () {
        function MediaPlayerComponent(mediaPlayerService, _audioService, _elementRef) {
            var _this = this;
            this.mediaPlayerService = mediaPlayerService;
            this._audioService = _audioService;
            this._elementRef = _elementRef;
            this.hovering = false;
            this._onDestroy = new Subject.Subject();
            // show controls when hovering and in quiet mode
            fromEvent.fromEvent(this._elementRef.nativeElement, 'mousemove').pipe(operators.switchMap(function (event) {
                _this.hovering = true;
                return of.of(event);
            }), operators.debounceTime(2000), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.hovering = false; });
        }
        Object.defineProperty(MediaPlayerComponent.prototype, "source", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.source;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.type;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.type = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.quietMode = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                this.mediaPlayerService.setMediaPlayer(this._elementRef.nativeElement, this._playerRef.nativeElement);
                this.audioMetadata = this._audioService.getAudioFileMetadata(this._playerRef.nativeElement);
                this.mediaPlayerService.playingEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(true); });
                this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(false); });
                this.mediaPlayerService.mediaClickEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.togglePlay(); });
                this.mediaPlayerService.loadedMetadataEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.loaded = true; });
            };
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        MediaPlayerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player',
                        template: "<div class=\"video-player-container\" *ngIf=\"type === 'video'\">\n\n    <video class=\"video-player\"\n        #player\n        [src]=\"source\"\n        (abort)=\"mediaPlayerService.abortEvent.next()\"\n        (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n        (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n        (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n        (ended)=\"mediaPlayerService.endedEvent.next()\"\n        (error)=\"mediaPlayerService.errorEvent.next($event)\"\n        (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n        (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n        (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n        (pause)=\"mediaPlayerService.pauseEvent.next()\"\n        (play)=\"mediaPlayerService.playEvent.next()\"\n        (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n        (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n        (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n        (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n        (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n        (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n        (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n        (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n        (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n        (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n    </video>\n\n    <div class=\"video-overlay\" [class.playing]=\"mediaPlayerService.playing | async\">\n        <svg class=\"play-graphic\" x=\"0px\" y=\"0px\" viewBox=\"0 0 64 64\">\n            <circle class=\"play-circle\" cx=\"32.2\" cy=\"31.8\" r=\"31.8\" />\n            <polygon class=\"play-triangle\" points=\"23,14.1 23,50.8 48.3,32.5\" />\n        </svg>\n    </div>\n\n</div>\n\n\n<div class=\"audio-player\" *ngIf=\"type === 'audio'\">\n\n    <svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n        <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n            <g transform=\"translate(-98.000000, -458.000000)\">\n                <g transform=\"translate(98.000000, 458.000000)\">\n                    <path d=\"M4.5,0.5 L18.0435308,0.5 L23.5,6.22251502 L23.5,23.5 L4.5,23.5 L4.5,0.5 Z\" fill=\"#CCEAE2\"></path>\n                    <path d=\"M4.5,8 L4.5,0.5 L18,0.5 L23.5,6 L23.5,23.5 L18,23.5\" stroke=\"#60798D\" fill=\"#CCEAE2\"></path>\n                    <path d=\"M4,13.5 L0.5,13.5 L0.5,18.5 L4,18.5 L9.5,22.5 L9.5,9.5 L4,13.5 Z\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                    <path d=\"M11.5,12.5137939 C13.7576225,12.5137939 14.5,14.3709236 14.5,16 C14.5,17.6849236 13.7089152,19.5420532 11.5,19.5420532\"\n                        stroke=\"#60798D\"></path>\n                    <path d=\"M11.5,9 C15.8037643,9.04168701 18.5,11.6604805 18.5,16 C18.5,20.3395195 15.8804302,23.0079956 11.5,23\" stroke=\"#60798D\"></path>\n                    <path d=\"M17.5219116,0.761413574 L17.5219116,6 L23,6\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                </g>\n            </g>\n        </g>\n    </svg>\n\n    <p class=\"audio-file-name\">{{ (audioMetadata | async)?.filename }}</p>\n    <p class=\"audio-file-format\">{{ (audioMetadata | async)?.description }}</p>\n    <p class=\"audio-file-size\">{{ (audioMetadata | async)?.size | fileSize }}</p>\n\n    <audio #player\n        [src]=\"source\"\n        (abort)=\"mediaPlayerService.abortEvent.next()\"\n        (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n        (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n        (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n        (ended)=\"mediaPlayerService.endedEvent.next()\"\n        (error)=\"mediaPlayerService.errorEvent.next($event)\"\n        (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n        (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n        (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n        (pause)=\"mediaPlayerService.pauseEvent.next()\"\n        (play)=\"mediaPlayerService.playEvent.next()\"\n        (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n        (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n        (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n        (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n        (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n        (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n        (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n        (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n        (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n        (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n    </audio>\n</div>\n\n<div class=\"control-bar\">\n    <ux-media-player-timeline></ux-media-player-timeline>\n    <ux-media-player-controls></ux-media-player-controls>\n</div>",
                        providers: [MediaPlayerService],
                        host: {
                            'tabindex': '0',
                            '(keydown.Space)': 'mediaPlayerService.togglePlay()',
                            '[class.standard]': '!mediaPlayerService.fullscreen',
                            '[class.fullscreen]': 'mediaPlayerService.fullscreen',
                            '[class.quiet]': 'quietMode && type === "video" || mediaPlayerService.fullscreen',
                            '[class.hover]': 'hovering',
                            '[class.video]': 'type === "video"',
                            '[class.audio]': 'type === "audio"',
                            '(mouseenter)': 'hovering = true',
                            '(mouseleave)': 'hovering = false',
                            '(document:webkitfullscreenchange)': 'mediaPlayerService.fullscreenChange($event)',
                            '(document:mozfullscreenchange)': 'mediaPlayerService.fullscreenChange($event)',
                            '(document:MSFullscreenChange)': 'mediaPlayerService.fullscreenChange($event)'
                        }
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerComponent.ctorParameters = function () {
            return [
                { type: MediaPlayerService, },
                { type: AudioService, },
                { type: core.ElementRef, },
            ];
        };
        MediaPlayerComponent.propDecorators = {
            "_playerRef": [{ type: core.ViewChild, args: ['player',] },],
            "source": [{ type: core.Input },],
            "type": [{ type: core.Input },],
            "quietMode": [{ type: core.Input },],
        };
        return MediaPlayerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerBaseExtensionDirective = (function () {
        function MediaPlayerBaseExtensionDirective(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
        }
        MediaPlayerBaseExtensionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mediaPlayerBaseExtension]'
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerBaseExtensionDirective.ctorParameters = function () {
            return [
                { type: MediaPlayerService, },
            ];
        };
        return MediaPlayerBaseExtensionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerTimelineExtensionComponent = (function (_super) {
        __extends(MediaPlayerTimelineExtensionComponent, _super);
        function MediaPlayerTimelineExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.current = 0;
            _this.position = 0;
            _this.duration = 0;
            _this.buffered = [];
            _this.mouseDown = false;
            _this.quietMode = false;
            _this.fullscreen = false;
            _this.scrub = { visible: false, position: 0, time: 0 };
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                // watch for changes to the current time
                this.mediaPlayerService.durationChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (duration) { return _this.duration = duration; });
                this.mediaPlayerService.quietModeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (quietMode) { return _this.quietMode = quietMode; });
                this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) {
                    _this.fullscreen = fullscreen;
                    _this.scrub.position = 0;
                });
                this.mediaPlayerService.timeUpdateEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (current) {
                    _this.current = current;
                    _this.position = (_this.current / _this.duration) * 100;
                });
                this.mediaPlayerService.progressEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (buffered) {
                    _this.buffered = [];
                    for (var /** @type {?} */ idx = 0; idx < buffered.length; idx++) {
                        _this.buffered.push({ start: (buffered.start(idx) / _this.duration) * 100, end: (buffered.end(idx) / _this.duration) * 100 });
                    }
                });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                var /** @type {?} */ mousedown$ = fromEvent.fromEvent(this.thumb.nativeElement, 'mousedown');
                var /** @type {?} */ mousemove$ = fromEvent.fromEvent(document, 'mousemove');
                var /** @type {?} */ mouseup$ = fromEvent.fromEvent(document, 'mouseup');
                mousedown$.pipe(operators.switchMap(function () { return mousemove$.pipe(operators.takeUntil(mouseup$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.scrub.visible = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.updateScrub =
            function (event) {
                var /** @type {?} */ target = (event.target);
                if (target.classList.contains('media-progress-bar-thumb')) {
                    return;
                }
                var /** @type {?} */ timeline = (this.timelineRef.nativeElement);
                var /** @type {?} */ bounds = timeline.getBoundingClientRect();
                this.scrub.position = event.offsetX;
                this.scrub.time = (event.offsetX / bounds.width) * this.mediaPlayerService.duration;
                if (this.mouseDown) {
                    this.mediaPlayerService.pause();
                    this.mediaPlayerService.currentTime = this.scrub.time;
                }
            };
        MediaPlayerTimelineExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-timeline',
                        template: "<p class=\"current-time\">{{ current | duration }}</p>\n\n<div #timeline class=\"timeline-bar\" (mouseenter)=\"scrub.visible = true; pop.show()\" (mouseleave)=\"scrub.visible = false; pop.hide()\"\n    (mousemove)=\"updateScrub($event)\" (mouseup)=\"updateScrub($event)\" (mousedown)=\"mouseDown = true; $event.preventDefault()\">\n\n    <div class=\"buffered-bar\" *ngFor=\"let buffer of buffered\" [style.left.%]=\"buffer.start\" [style.width.%]=\"buffer.end - buffer.start\"></div>\n\n    <div class=\"media-progress-bar\" [style.width.%]=\"position\">\n        <div #progressThumb class=\"media-progress-bar-thumb\" (mouseenter)=\"scrub.visible = false; pop.hide(); $event.stopPropagation()\"\n            (mouseleave)=\"scrub.visible = true; pop.show(); $event.stopPropagation()\"></div>\n    </div>\n\n    <div class=\"scrub-handle\"\n         [class.scrub-handle-hidden]=\"!scrub.visible\"\n         [style.left.px]=\"scrub.position\"\n         [uxTooltip]=\"popTemplate\"\n         placement=\"top\"\n         [showTriggers]=\"[]\"\n         [hideTriggers]=\"[]\"\n         #pop=\"ux-tooltip\"\n         [tooltipDelay]=\"100\"\n         [tooltipDisabled]=\"duration === 0\"></div>\n</div>\n\n<p class=\"duration-time\">{{ duration | duration }}</p>\n\n<ng-template #popTemplate>\n    <span>{{ scrub.time | duration }}</span>\n</ng-template>",
                        host: {
                            '(document:mouseup)': 'mouseDown = false',
                            '[class.quiet]': 'quietMode || fullscreen'
                        }
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerTimelineExtensionComponent.ctorParameters = function () { return []; };
        MediaPlayerTimelineExtensionComponent.propDecorators = {
            "thumb": [{ type: core.ViewChild, args: ['progressThumb',] },],
            "timelineRef": [{ type: core.ViewChild, args: ['timeline',] },],
        };
        return MediaPlayerTimelineExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerControlsExtensionComponent = (function (_super) {
        __extends(MediaPlayerControlsExtensionComponent, _super);
        function MediaPlayerControlsExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.fullscreen = false;
            _this.volumeActive = false;
            _this.volumeDragging = false;
            _this._volume = 50;
            _this._previousVolume = 50;
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        Object.defineProperty(MediaPlayerControlsExtensionComponent.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._volume;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === 0 && this._volume !== 0) {
                    this._previousVolume = this._volume;
                }
                this._volume = Math.min(Math.max(value, 0), 100);
                this.mediaPlayerService.volume = this._volume / 100;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this.mediaPlayerService.playEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.playing = true; });
                this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.playing = false; });
                this.mediaPlayerService.quietModeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (quietMode) { return _this.quietMode = quietMode; });
                this.mediaPlayerService.volumeChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (volume) { return _this.volume = volume * 100; });
                this.mediaPlayerService.initEvent.pipe(operators.debounceTime(1), operators.filter(function (init) { return init === true; }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volume = _this.mediaPlayerService.volume * 100; });
                this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) { return _this.fullscreen = fullscreen; });
                var /** @type {?} */ mouseenter$ = fromEvent.fromEvent(this.volumeIcon.nativeElement, 'mouseenter');
                var /** @type {?} */ mouseenterContainer$ = fromEvent.fromEvent(this.volumeContainer.nativeElement, 'mouseenter');
                var /** @type {?} */ mouseleaveContainer$ = fromEvent.fromEvent(this.volumeContainer.nativeElement, 'mouseleave');
                mouseenter$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = true; });
                mouseleaveContainer$.pipe(operators.switchMap(function () { return timer.timer(1500).pipe(operators.takeUntil(mouseenterContainer$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.toggleMute =
            function () {
                if (this.volume === 0) {
                    this.volume = this._previousVolume;
                }
                else {
                    this.volume = 0;
                }
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.togglePlay =
            function () {
                if (this.playing) {
                    this.mediaPlayerService.pause();
                }
                else {
                    this.mediaPlayerService.play();
                }
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.setFullscreen =
            function () {
                this.mediaPlayerService.toggleFullscreen();
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToStart =
            function () {
                this.mediaPlayerService.currentTime = 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToEnd =
            function () {
                this.mediaPlayerService.currentTime = this.mediaPlayerService.duration;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.dragStart =
            function (event) {
                event.preventDefault();
                this.volumeDragging = true;
                var /** @type {?} */ thumb = (event.target);
                thumb.focus();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.dragMove =
            function (event) {
                if (!this.volumeDragging) {
                    return;
                }
                event.preventDefault();
                var /** @type {?} */ slider = (this.volumeSlider.nativeElement);
                var /** @type {?} */ bounds = slider.getBoundingClientRect();
                var /** @type {?} */ x = Math.min(bounds.width, Math.max(0, event.pageX - bounds.left));
                // convert to a percentage
                this.volume = (x / bounds.width) * 100;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.dragEnd =
            function () {
                this.volumeDragging = false;
            };
        MediaPlayerControlsExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-controls',
                        template: "<div class=\"volume-container\">\n\n    <div class=\"volume-slider-container\" #volumeContainer [class.active]=\"volumeActive\">\n        <div class=\"volume-slider-icon\" #volumeIcon>\n            <span class=\"hpe-icon\" [class.hpe-volume-mute]=\"volume === 0\" [class.hpe-volume-low]=\"volume > 0 && volume <= 70\" [class.hpe-volume]=\"volume > 70\" [uxTooltip]=\"muteTooltip\" (click)=\"toggleMute()\"></span>\n        </div>\n        \n        <div class=\"volume-slider-node\">\n            <div class=\"volume-slider\" #volumeSlider>\n                <div class=\"volume-track-lower\" [style.width.%]=\"volume\"></div>\n                <div class=\"volume-slider-thumb\" (mousedown)=\"dragStart($event)\" [style.left.%]=\"volume\" tabindex=\"0\" (keydown.ArrowRight)=\"volume = volume + 10\" (keydown.ArrowLeft)=\"volume = volume - 10\"></div>\n            </div>\n        </div>\n    </div>\n</div>\n\n<div class=\"spacer\"></div>\n\n<svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" class=\"control-button\" (click)=\"goToStart()\">\n    <rect x=\"0\" y=\"0\" width=\"7.5\" height=\"64\" />\n    <polygon points=\"51.5,64 51.5,0 7.4,32 \" />\n</svg>\n\n<svg viewBox=\"0 0 45 64\" width=\"20\" height=\"29\" class=\"control-button\" *ngIf=\"!playing\" (click)=\"togglePlay()\">\n    <polygon points=\"0.4,0 0.4,64 44.6,32\" />\n</svg>\n\n<svg viewBox=\"0 0 43 56.9\" class=\"control-button\" width=\"20\" height=\"29\" *ngIf=\"playing\" (click)=\"togglePlay()\">\n    <rect y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n    <rect x=\"27.3\" y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n</svg>\n\n<svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" class=\"control-button\" (click)=\"goToEnd()\">\n    <rect x=\"44.1\" y=\"0\" width=\"7.5\" height=\"64\" />\n    <polygon points=\"0,64 0,0 44.1,32 \" />\n</svg>\n\n<div class=\"spacer\"></div>\n\n<span class=\"hpe-icon\" *ngIf=\"mediaPlayerService.type !== 'audio'\" [class.hpe-expand]=\"!mediaPlayerService.fullscreen\" [class.hpe-contract]=\"mediaPlayerService.fullscreen\"\n    (click)=\"setFullscreen()\"></span>\n\n<ng-template #muteTooltip>{{ volume === 0 ? 'Unmute' : 'Mute' }}</ng-template>",
                        host: {
                            '[class.quiet]': 'quietMode || fullscreen'
                        }
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerControlsExtensionComponent.ctorParameters = function () { return []; };
        MediaPlayerControlsExtensionComponent.propDecorators = {
            "volumeIcon": [{ type: core.ViewChild, args: ['volumeIcon',] },],
            "volumeSlider": [{ type: core.ViewChild, args: ['volumeSlider',] },],
            "volumeContainer": [{ type: core.ViewChild, args: ['volumeContainer',] },],
            "dragMove": [{ type: core.HostListener, args: ['document:mousemove', ['$event'],] },],
            "dragEnd": [{ type: core.HostListener, args: ['document:mouseup',] },],
        };
        return MediaPlayerControlsExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipe = (function () {
        function DurationPipe() {
        }
        /**
         * @param {?} seconds
         * @return {?}
         */
        DurationPipe.prototype.transform =
            function (seconds) {
                var /** @type {?} */ minutes = Math.floor(seconds / 60);
                var /** @type {?} */ hours = Math.floor(minutes / 60);
                var /** @type {?} */ days = Math.floor(hours / 24);
                hours = hours - (days * 24);
                minutes = minutes - (days * 24 * 60) - (hours * 60);
                seconds = Math.floor(seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60));
                if (hours > 0) {
                    return this.pad(hours) + ":" + this.pad(minutes) + ":" + this.pad(seconds);
                }
                else {
                    return this.pad(minutes) + ":" + this.pad(seconds);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        DurationPipe.prototype.pad =
            function (value) {
                if (value < 10) {
                    return "0" + value;
                }
                return value.toString();
            };
        DurationPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'duration'
                    },] },
        ];
        /** @nocollapse */
        DurationPipe.ctorParameters = function () { return []; };
        return DurationPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipeModule = (function () {
        function DurationPipeModule() {
        }
        DurationPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DurationPipe],
                        declarations: [DurationPipe]
                    },] },
        ];
        /** @nocollapse */
        DurationPipeModule.ctorParameters = function () { return []; };
        return DurationPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipe = (function () {
        function FileSizePipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        FileSizePipe.prototype.transform =
            function (value) {
                // allow for async values
                if (!value) {
                    return value;
                }
                var /** @type {?} */ units = ['B', 'KB', 'MB', 'GB', 'TB'];
                // calculate the which unit bracket the values should be a part of
                var /** @type {?} */ idx = Math.floor(Math.log(value) / Math.log(1024));
                var /** @type {?} */ formattedValue = value / Math.pow(1024, idx);
                return formattedValue.toFixed(2) + " " + units[idx];
            };
        FileSizePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'fileSize'
                    },] },
        ];
        /** @nocollapse */
        FileSizePipe.ctorParameters = function () { return []; };
        return FileSizePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipeModule = (function () {
        function FileSizePipeModule() {
        }
        FileSizePipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FileSizePipe],
                        declarations: [FileSizePipe]
                    },] },
        ];
        /** @nocollapse */
        FileSizePipeModule.ctorParameters = function () { return []; };
        return FileSizePipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$5 = [
        MediaPlayerComponent,
        MediaPlayerTimelineExtensionComponent,
        MediaPlayerBaseExtensionDirective,
        MediaPlayerControlsExtensionComponent
    ];
    var MediaPlayerModule = (function () {
        function MediaPlayerModule() {
        }
        MediaPlayerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            FrameExtractionModule,
                            TooltipModule,
                            AudioServiceModule,
                            DurationPipeModule,
                            FileSizePipeModule
                        ],
                        exports: DECLARATIONS$5,
                        declarations: DECLARATIONS$5,
                        providers: [MediaPlayerService]
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerModule.ctorParameters = function () { return []; };
        return MediaPlayerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationComponent = (function () {
        function NavigationComponent() {
        }
        NavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-navigation',
                        template: "<nav class=\"tree\" role=\"navigation\">\n    <ol class=\"nav\">\n        <ng-content></ng-content>\n    </ol>\n</nav>\n"
                    },] },
        ];
        /** @nocollapse */
        NavigationComponent.ctorParameters = function () { return []; };
        return NavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationItemComponent = (function () {
        function NavigationItemComponent(_elementRef, _renderer, _parent, _router, _activatedRoute) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._parent = _parent;
            this._router = _router;
            this._activatedRoute = _activatedRoute;
            this.expanded = false;
            this.level = 1;
            this.indentWithoutArrow = true;
            this.level = _parent ? _parent.level + 1 : 1;
            this._navigationEnd = _router.events.pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }))
                .subscribe(function () { return _this.expanded = _this.hasActiveLink(_this.link); });
        }
        Object.defineProperty(NavigationItemComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                if (this.link) {
                    return this._router.isActive(this.link, true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationItemComponent.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                var _this = this;
                return this._children.filter(function (item) { return item !== _this; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterViewInit =
            function () {
                // Add classes to parent for styling
                var /** @type {?} */ parentListElement = this._elementRef.nativeElement.parentElement;
                if (parentListElement) {
                    var /** @type {?} */ levelClass = this.getLevelClass();
                    if (levelClass.length > 0) {
                        this._renderer.addClass(parentListElement, 'nav');
                        this._renderer.addClass(parentListElement, levelClass);
                    }
                }
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // Set 'indentWithoutArrow'
                this.setIndentWithoutArrow();
                // Update 'indentWithoutArrow' in response to changes to children
                this._childrenChanges = this._children.changes.subscribe(function () { return _this.setIndentWithoutArrow(); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngOnDestroy =
            function () {
                this._navigationEnd.unsubscribe();
                this._childrenChanges.unsubscribe();
            };
        /**
         * @param {?} link
         * @return {?}
         */
        NavigationItemComponent.prototype.hasActiveLink =
            function (link) {
                var /** @type {?} */ tree = this._router.createUrlTree([link], {
                    relativeTo: this._activatedRoute,
                    queryParams: this._activatedRoute.snapshot.queryParams,
                    fragment: this._activatedRoute.snapshot.fragment
                });
                if (link && this._router.isActive(tree, true)) {
                    return true;
                }
                // If this component has children, check if any of them, or their descendants, are active.
                return this.children.some(function (item) { return item.hasActiveLink(item.link); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.getLevelClass =
            function () {
                switch (this.level) {
                    case 2:
                        return 'nav-second-level';
                    case 3:
                        return 'nav-third-level';
                    case 4:
                        return 'nav-fourth-level';
                    case 5:
                        return 'nav-fifth-level';
                }
                return '';
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.setIndentWithoutArrow =
            function () {
                if (this.children.length > 0) {
                    // If this element has children it will be indented and will have an arrow
                    this.indentWithoutArrow = false;
                }
                else if (this._parent) {
                    // If this element has a parent, indent it if any of its siblings have children
                    this.indentWithoutArrow = !this._parent.children.every(function (item) { return item.children.length === 0; });
                }
                else {
                    // Top-level elements should be indented
                    this.indentWithoutArrow = true;
                }
            };
        NavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: '[ux-navigation-item]',
                        template: "<a *ngIf=\"link\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\" [routerLink]=\"link\">\n    <span>{{header}}</span>\n</a>\n<a *ngIf=\"!link\" (click)=\"expanded = !expanded\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\">\n    <span>{{header}}</span>\n</a>\n<ng-content></ng-content>\n",
                    },] },
        ];
        /** @nocollapse */
        NavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
                { type: NavigationItemComponent, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
                { type: router.Router, },
                { type: router.ActivatedRoute, },
            ];
        };
        NavigationItemComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "icon": [{ type: core.Input },],
            "link": [{ type: core.Input },],
            "expanded": [{ type: core.Input }, { type: core.HostBinding, args: ['class.selected',] },],
            "active": [{ type: core.HostBinding, args: ['class.active',] },],
            "_children": [{ type: core.ContentChildren, args: [NavigationItemComponent, { descendants: true },] },],
        };
        return NavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationModule = (function () {
        function NavigationModule() {
        }
        NavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [
                            NavigationComponent,
                            NavigationItemComponent
                        ],
                        declarations: [
                            NavigationComponent,
                            NavigationItemComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        NavigationModule.ctorParameters = function () { return []; };
        return NavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorService = (function () {
        function ColorService() {
            this._colorSet = colorSets.keppel;
            if (this._colorSet.colorClassSet) {
                this.setColors();
            }
            else {
                for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                    this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                }
            }
        }
        /**
         * @return {?}
         */
        ColorService.prototype.setColors =
            function () {
                this._html = '';
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._html += '<div class="' + this._colorSet.colorClassSet[key] + '-color"></div>';
                }
                this._element = document.createElement('div');
                this._element.className = 'color-chart';
                this._element.innerHTML = this._html;
                document.body.appendChild(this._element);
                this._colors = {};
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._colors[key] = this.getColorValue(this._colorSet.colorClassSet[key]);
                }
                this._element.parentNode.removeChild(this._element);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValueByHex =
            function (color) {
                var /** @type {?} */ hex = color.replace('#', '');
                var /** @type {?} */ r = parseInt(hex.substring(0, 2), 16).toString();
                var /** @type {?} */ g = parseInt(hex.substring(2, 4), 16).toString();
                var /** @type {?} */ b = parseInt(hex.substring(4, 6), 16).toString();
                return new ThemeColor(r, g, b, '1');
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValue =
            function (color) {
                var /** @type {?} */ target = this._element.querySelector('.' + this._colorSet.colorClassSet[color] + '-color');
                if (!target) {
                    throw new Error('Invalid color');
                }
                var /** @type {?} */ colorValue = window.getComputedStyle(target).backgroundColor;
                var /** @type {?} */ rgba = colorValue.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
                return new ThemeColor(rgba[1], rgba[2], rgba[3], rgba[4]);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColor =
            function (color) {
                var /** @type {?} */ themeColor = this._colors[this.resolveColorName(color)];
                if (!themeColor) {
                    throw new Error('Color not found: ' + color);
                }
                return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
            };
        /**
         * @return {?}
         */
        ColorService.prototype.getColorSet =
            function () {
                return this._colorSet;
            };
        /**
         * @param {?} colorSet
         * @return {?}
         */
        ColorService.prototype.setColorSet =
            function (colorSet) {
                this._colorSet = colorSet;
                this._colors = {};
                if (this._colorSet.colorClassSet) {
                    this.setColors();
                }
                else {
                    for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                        this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                    }
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ColorService.prototype.resolve =
            function (value) {
                if (!value) {
                    return;
                }
                var /** @type {?} */ colorName = this.resolveColorName(value);
                for (var /** @type {?} */ color in this._colors) {
                    if (colorName === color.toLowerCase()) {
                        return this.getColor(colorName).toRgba();
                    }
                }
                return value;
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        ColorService.prototype.resolveColorName =
            function (value) {
                if (value === void 0) {
                    value = '';
                }
                return value.replace(/\s+/g, '-').toLowerCase();
            };
        ColorService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ColorService.ctorParameters = function () { return []; };
        return ColorService;
    }());
    var ThemeColor = (function () {
        function ThemeColor(r, g, b, a) {
            this._r = r;
            this._g = g;
            this._b = b;
            this._a = a === undefined ? '1' : a;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ThemeColor.parse =
            function (value) {
                var /** @type {?} */ r, /** @type {?} */ g, /** @type {?} */ b, /** @type {?} */ a = '1';
                var /** @type {?} */ rgbaPattern = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
                var /** @type {?} */ shortHexPattern = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                var /** @type {?} */ longHexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/;
                var /** @type {?} */ rgbaMatch = value.match(rgbaPattern);
                var /** @type {?} */ shortHexMatch = value.match(shortHexPattern);
                var /** @type {?} */ longHexMatch = value.match(longHexPattern);
                if (rgbaMatch) {
                    r = rgbaMatch[1];
                    g = rgbaMatch[2];
                    b = rgbaMatch[3];
                    a = rgbaMatch[4] ? rgbaMatch[4] : '1';
                }
                else if (longHexMatch) {
                    r = parseInt(longHexMatch[1], 16).toString();
                    g = parseInt(longHexMatch[2], 16).toString();
                    b = parseInt(longHexMatch[3], 16).toString();
                }
                else if (shortHexMatch) {
                    r = parseInt(shortHexMatch[1] + shortHexMatch[1], 16).toString();
                    g = parseInt(shortHexMatch[2] + shortHexMatch[2], 16).toString();
                    b = parseInt(shortHexMatch[3] + shortHexMatch[3], 16).toString();
                }
                else {
                    throw new Error("Cannot parse color - " + value + " is not a valid color.");
                }
                return new ThemeColor(r, g, b, a);
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toHex =
            function () {
                var /** @type {?} */ red = parseInt(this._r).toString(16);
                var /** @type {?} */ green = parseInt(this._g).toString(16);
                var /** @type {?} */ blue = parseInt(this._b).toString(16);
                if (red.length < 2) {
                    red = '0' + red;
                }
                if (green.length < 2) {
                    green = '0' + green;
                }
                if (blue.length < 2) {
                    blue = '0' + blue;
                }
                return '#' + red + green + blue;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgb =
            function () {
                return 'rgb(' + this._r + ', ' + this._g + ', ' + this._b + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgba =
            function () {
                return 'rgba(' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getRed =
            function () {
                return this._r;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getGreen =
            function () {
                return this._g;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getBlue =
            function () {
                return this._b;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getAlpha =
            function () {
                return this._a;
            };
        /**
         * @param {?} red
         * @return {?}
         */
        ThemeColor.prototype.setRed =
            function (red) {
                this._r = red;
                return this;
            };
        /**
         * @param {?} green
         * @return {?}
         */
        ThemeColor.prototype.setGreen =
            function (green) {
                this._g = green;
                return this;
            };
        /**
         * @param {?} blue
         * @return {?}
         */
        ThemeColor.prototype.setBlue =
            function (blue) {
                this._b = blue;
                return this;
            };
        /**
         * @param {?} alpha
         * @return {?}
         */
        ThemeColor.prototype.setAlpha =
            function (alpha) {
                this._a = alpha.toString();
                return this;
            };
        return ThemeColor;
    }());
    var /** @type {?} */ colorSets = {
        keppel: {
            colorClassSet: {
                'primary': 'primary',
                'accent': 'accent',
                'secondary': 'secondary',
                'alternate1': 'alternate1',
                'alternate2': 'alternate2',
                'alternate3': 'alternate3',
                'vibrant1': 'vibrant1',
                'vibrant2': 'vibrant2',
                'grey1': 'grey1',
                'grey2': 'grey2',
                'grey3': 'grey3',
                'grey4': 'grey4',
                'grey5': 'grey5',
                'grey6': 'grey6',
                'grey7': 'grey7',
                'grey8': 'grey8',
                'chart1': 'chart1',
                'chart2': 'chart2',
                'chart3': 'chart3',
                'chart4': 'chart4',
                'chart5': 'chart5',
                'chart6': 'chart6',
                'ok': 'ok',
                'warning': 'warning',
                'critical': 'critical',
                'partition1': 'partition1',
                'partition9': 'partition9',
                'partition10': 'partition10',
                'partition11': 'partition11',
                'partition12': 'partition12',
                'partition13': 'partition13',
                'partition14': 'partition14',
                'social-chart-node': 'social-chart-node',
                'social-chart-edge': 'social-chart-edge'
            }
        },
        microFocus: {
            'colorValueSet': {
                'cerulean': '#1668c1',
                'aqua': '#29ceff',
                'aquamarine': '#2fd6c3',
                'fuchsia': '#c6179d',
                'indigo': '#7425ad',
                'dark-blue': '#231ca5',
                'white': '#ffffff',
                'slightly-gray': '#f5f7f8',
                'bright-gray': '#f1f2f3',
                'gray': '#dcdedf',
                'silver': '#bdbec0',
                'dim-gray': '#656668',
                'dark-gray': '#323435',
                'black': '#000000',
                'crimson-negative': '#e5004c',
                'apricot': '#f48b34',
                'yellow': '#fcdb1f',
                'green-positive': '#1aac60',
                'ultramarine': '#3939c6',
                'skyblue': '#00abf3',
                'pale-aqua': '#43e4ff',
                'pale-green': '#1ffbba',
                'lime': '#75da4d',
                'orange': '#ffce00',
                'magenta': '#eb23c2',
                'pale-purple': '#ba47e2',
                'dark-ultramarine': '#271782',
                'steelblue': '#014272',
                'arctic-blue': '#0b8eac',
                'emerald': '#00a989',
                'olive': '#5bba36',
                'goldenrod': '#ffb000',
                'purple': '#9b1e83',
                'pale-eggplant': '#5216ac',
                'red': '#ff454f',
                'pale-amber': '#ffb24d',
                'pale-lemon': '#fde159',
                'pale-emerald': '#33c180',
                'plum': '#b21646',
                'copper': '#e57828',
                'amber': '#ffc002',
                'leaf-green': '#118c4f',
                'forest-green': '#00645a',
                'primary': '#0073e7',
                'accent': '#7425ad',
                'secondary': '#ffffff',
                'alternate1': '#29ceff',
                'alternate2': '#2fd6c3',
                'alternate3': '#c6179d',
                'vibrant1': '#43e4ff',
                'vibrant2': '#ffce00',
                'grey1': '#000000',
                'grey2': '#323435',
                'grey3': '#656668',
                'grey4': '#bdbec0',
                'grey5': '#dcdedf',
                'grey6': '#f1f2f3',
                'grey7': '#f5f7f8',
                'grey8': '#ffffff',
                'chart1': '#3939c6',
                'chart2': '#00abf3',
                'chart3': '#75da4d',
                'chart4': '#ffce00',
                'chart5': '#eb23c2',
                'chart6': '#ba47e2',
                'ok': '#1aac60',
                'warning': '#f48b34',
                'critical': 'e5004c',
                'partition1': '#7425ad',
                'partition9': '#5216ac',
                'partition10': '#5bba36',
                'partition11': '#014272',
                'partition12': '#ffb000',
                'partition13': '#bdbec0',
                'partition14': '#271782',
                'social-chart-node': '#ff00ff',
                'social-chart-edge': '#ff00ff'
            }
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorServiceModule = (function () {
        function ColorServiceModule() {
        }
        ColorServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [ColorService],
                    },] },
        ];
        /** @nocollapse */
        ColorServiceModule.ctorParameters = function () { return []; };
        return ColorServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationService = (function () {
        function NotificationService(_colorService) {
            this._colorService = _colorService;
            // provide default options
            this.options = {
                duration: 4,
                height: 100,
                spacing: 10,
                backgroundColor: this._colorService.getColor('accent').toHex(),
                iconColor: this._colorService.getColor('accent').toHex()
            };
            this.direction = 'above';
            this.notifications$ = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} templateRef
         * @param {?=} options
         * @param {?=} data
         * @return {?}
         */
        NotificationService.prototype.show =
            function (templateRef, options, data) {
                var _this = this;
                if (options === void 0) {
                    options = this.options;
                }
                if (data === void 0) {
                    data = {};
                }
                options = __assign({}, this.options, options);
                var /** @type {?} */ notificationRef = {
                    templateRef: templateRef,
                    duration: options.duration,
                    date: new Date(),
                    visible: true,
                    height: options.height,
                    spacing: options.spacing,
                    backgroundColor: options.backgroundColor,
                    iconColor: options.iconColor,
                    data: data
                };
                var /** @type {?} */ notifications = this.notifications$.getValue();
                if (this.direction === 'above') {
                    notifications.unshift(notificationRef);
                }
                else {
                    notifications.push(notificationRef);
                }
                this.notifications$.next(notifications);
                // remove notification after delay
                if (options.duration !== 0) {
                    setTimeout(function () { return _this.dismiss(notificationRef); }, options.duration * 1000);
                }
                return notificationRef;
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.getHistory =
            function () {
                return this.notifications$.getValue();
            };
        /**
         * @param {?} notificationRef
         * @return {?}
         */
        NotificationService.prototype.dismiss =
            function (notificationRef) {
                notificationRef.visible = false;
                this.notifications$.next(this.notifications$.getValue());
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.dismissAll =
            function () {
                this.notifications$.getValue().forEach(function (notificationRef) { return notificationRef.visible = false; });
                this.notifications$.next(this.notifications$.getValue());
            };
        NotificationService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        NotificationService.ctorParameters = function () {
            return [
                { type: ColorService, },
            ];
        };
        return NotificationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationListComponent = (function () {
        function NotificationListComponent(_notificationService) {
            this._notificationService = _notificationService;
            this.position = 'top-right';
            this.notifications$ = this._notificationService.notifications$.pipe(map.map(function (notificationRefs) { return notificationRefs.filter(function (notificationRef) { return notificationRef.visible; }); }));
        }
        Object.defineProperty(NotificationListComponent.prototype, "direction", {
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this._notificationService.direction = direction;
            },
            enumerable: true,
            configurable: true
        });
        NotificationListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-notification-list',
                        template: "<div class=\"notification\" *ngFor=\"let notificationRef of notifications$ | async; let idx = index\"\n    [style.top.px]=\"(notificationRef.height + notificationRef.spacing) * idx\"\n    [style.height.px]=\"notificationRef.height\"\n    [style.background-color]=\"notificationRef.backgroundColor\"\n    [@notificationState]>\n    <ng-container *ngTemplateOutlet=\"notificationRef.templateRef; context: { $implicit: notificationRef, data: notificationRef.data }\"></ng-container>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('notificationState', [
                                animations.state('in', animations.style({ transform: 'translateY(0)', opacity: 0.9 })),
                                animations.transition(':enter', [
                                    animations.style({ transform: 'translateY(-50px)', opacity: 0 }),
                                    animations.animate(500)
                                ]),
                                animations.transition(':leave', [
                                    animations.animate(500, animations.style({ transform: 'translateY(50px)', opacity: 0 }))
                                ])
                            ])
                        ]
                    },] },
        ];
        /** @nocollapse */
        NotificationListComponent.ctorParameters = function () {
            return [
                { type: NotificationService, },
            ];
        };
        NotificationListComponent.propDecorators = {
            "direction": [{ type: core.Input },],
            "position": [{ type: core.Input }, { type: core.HostBinding, args: ['class',] },],
        };
        return NotificationListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationModule = (function () {
        function NotificationModule() {
        }
        NotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule
                        ],
                        exports: [
                            NotificationListComponent
                        ],
                        declarations: [
                            NotificationListComponent
                        ],
                        providers: [
                            NotificationService
                        ]
                    },] },
        ];
        /** @nocollapse */
        NotificationModule.ctorParameters = function () { return []; };
        return NotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ NUMBER_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return NumberPickerComponent; }),
        multi: true
    };
    var NumberPickerComponent = (function () {
        function NumberPickerComponent() {
            this._min = -Infinity;
            this._max = Infinity;
            this._step = 1;
            this._disabled = false;
            this._value = 0;
            this._propagateChange = function (_) { };
            this.valid = true;
            this.valueChange = new core.EventEmitter();
        }
        Object.defineProperty(NumberPickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.valueChange.emit(value);
                this._propagateChange(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "min", {
            get: /**
             * @return {?}
             */ function () {
                return this._min;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._min = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "max", {
            get: /**
             * @return {?}
             */ function () {
                return this._max;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._max = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._step = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = typeof value === 'string' && (value === '' || value === 'true' || value === 'disabled') || value === true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.increment =
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.max(Math.min(this.value + this.step, this.max), this.min);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.decrement =
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.min(Math.max(this.value - this.step, this.min), this.max);
                }
            };
        /**
         * @return {?}
         */
        NumberPickerComponent.prototype.isValid =
            function () {
                if (this.value < this.min || this.value > this.max) {
                    return false;
                }
                return this.valid;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.onScroll =
            function (event) {
                var /** @type {?} */ scrollValue = event.deltaY || event.wheelDelta;
                if (scrollValue < 0) {
                    this.increment(event);
                }
                else {
                    this.decrement(event);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NumberPickerComponent.prototype.writeValue =
            function (value) {
                if (value !== undefined) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnChange =
            function (fn) {
                this._propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnTouched =
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NumberPickerComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        NumberPickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-number-picker',
                        template: "<input type=\"number\"\n       role=\"spinbutton\"\n       class=\"form-control number-picker-input\"\n       [(ngModel)]=\"value\"\n       [min]=\"min\"\n       [max]=\"max\"\n       (keydown.ArrowDown)=\"decrement($event)\"\n       (keydown.ArrowUp)=\"increment($event)\"\n       (wheel)=\"onScroll($event)\"\n       step=\"any\"\n       [disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\">\n\n<div class=\"number-picker-controls\">\n\n    <div class=\"number-picker-control-up\"\n         (click)=\"increment($event)\"\n         [class.disabled]=\"disabled || value >= max\">\n\n        <span class=\"hpe-icon hpe-up\"></span>\n    </div>\n\n    <div class=\"number-picker-control-down\"\n         (click)=\"decrement($event)\"\n         [class.disabled]=\"disabled || value <= min\">\n\n        <span class=\"hpe-icon hpe-down\"></span>\n    </div>\n\n</div>",
                        providers: [NUMBER_PICKER_VALUE_ACCESSOR],
                        host: {
                            '[class.has-error]': '!isValid()'
                        }
                    },] },
        ];
        /** @nocollapse */
        NumberPickerComponent.ctorParameters = function () { return []; };
        NumberPickerComponent.propDecorators = {
            "valid": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input, args: ['value',] },],
            "min": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "step": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
        };
        return NumberPickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NumberPickerModule = (function () {
        function NumberPickerModule() {
        }
        NumberPickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [NumberPickerComponent],
                        declarations: [NumberPickerComponent]
                    },] },
        ];
        /** @nocollapse */
        NumberPickerModule.ctorParameters = function () { return []; };
        return NumberPickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderCustomMenuDirective = (function () {
        function PageHeaderCustomMenuDirective() {
        }
        PageHeaderCustomMenuDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderCustomMenu]'
                    },] },
        ];
        /** @nocollapse */
        PageHeaderCustomMenuDirective.ctorParameters = function () { return []; };
        return PageHeaderCustomMenuDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderService = (function () {
        function PageHeaderService() {
            var _this = this;
            this.items$ = new BehaviorSubject.BehaviorSubject([]);
            this.selected$ = new BehaviorSubject.BehaviorSubject(null);
            this.selectedRoot$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondary$ = new BehaviorSubject.BehaviorSubject(false);
            this.activeIconMenu$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondaryNavigationAutoselect = false;
            this._subscription = this.selected$.pipe(operators.map(function (selected) { return _this.getRoot(selected); })).subscribe(function (root) { return _this.selectedRoot$.next(root); });
        }
        /**
         * @return {?}
         */
        PageHeaderService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.select =
            function (item) {
                if (this.secondaryNavigationAutoselect && item && item.children && item.children.length > 0) {
                    // Select the first child in secondaryNavigationAutoselect mode
                    this.selected$.next(item.children[0]);
                }
                else {
                    // if we are in secondary navigation mode and we click a parent - dont deselect the child
                    if (this.secondary$.getValue() === true && this.isParentOf(this.selected$.getValue(), item)) {
                        return;
                    }
                    // Otherwise select the given item
                    this.selected$.next(item);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.deselect =
            function (item) {
                var _this = this;
                // deselect the current item
                item.selected = false;
                // iterate any children and deselect them
                if (item.children) {
                    item.children.forEach(function (_item) { return _this.deselect(_item); });
                }
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.deselectAll =
            function () {
                var _this = this;
                this.items$.getValue().forEach(function (item) { return _this.deselect(item); });
            };
        /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
        PageHeaderService.prototype.updateItem =
            function (item, selected) {
                // Item is selected if it is the selected item, or one of the selected item's ancestors.
                item.selected = (item === selected) || this.isParentOf(selected, item);
                if (item === selected) {
                    // call the select function if present
                    if (item.select) {
                        item.select.call(item, item);
                    }
                }
            };
        /**
         * @param {?=} items
         * @return {?}
         */
        PageHeaderService.prototype.setItems =
            function (items) {
                var _this = this;
                if (items === void 0) {
                    items = [];
                }
                // identify all parent elements
                items.forEach(function (item) { return _this.setParent(item); });
                this.items$.next(items);
                // Set up the initally selected item
                var /** @type {?} */ initialSelectedItem = items.find(function (item) { return item.selected === true; });
                this.select(initialSelectedItem);
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        PageHeaderService.prototype.setSecondaryNavigation =
            function (enabled) {
                this.secondary$.next(enabled);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.getRoot =
            function (item) {
                return item && item.parent ? this.getRoot(item.parent) : item;
            };
        /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
        PageHeaderService.prototype.setParent =
            function (item, parent) {
                var _this = this;
                // set the parent field
                item.parent = parent;
                // call this function recursively on all children
                if (item.children) {
                    item.children.forEach(function (child) { return _this.setParent(child, item); });
                }
            };
        /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
        PageHeaderService.prototype.isParentOf =
            function (node, parent) {
                // if there are no parents return false
                if (!node || !node.parent) {
                    return false;
                }
                // if the parent is the match we are looking for return true
                if (node.parent === parent) {
                    return true;
                }
                // if there are potentially grandparents then check them too
                return this.isParentOf(node.parent, parent);
            };
        PageHeaderService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PageHeaderService.ctorParameters = function () { return []; };
        return PageHeaderService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderIconMenuComponent = (function () {
        function PageHeaderIconMenuComponent(_service) {
            var _this = this;
            this._service = _service;
            this._subscription = _service.activeIconMenu$.subscribe(function (next) {
                // Close all but the most recently opened menu
                if (next !== _this.menu) {
                    _this._isOpen = false;
                }
            });
        }
        Object.defineProperty(PageHeaderIconMenuComponent.prototype, "isOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._isOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._isOpen = value;
                if (value) {
                    this._service.activeIconMenu$.next(this.menu);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.select =
            function (item) {
                if (item.select) {
                    item.select.call(item, item);
                }
            };
        /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.keydownHandler =
            function (item, event) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        this.isOpen = false;
                        this.menuNavigationToggle.focus();
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderIconMenuComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-icon-menu',
                        template: "<div class=\"page-header-icon-menu\"\n    dropdown\n    placement=\"bottom right\"\n    [(isOpen)]=\"isOpen\">\n\n    <a role=\"button\"\n        class=\"page-header-icon-menu-button\"\n        [attr.aria-label]=\"menu.label\"\n        aria-haspopup=\"true\"\n        tabindex=\"0\"\n        (click)=\"select(menu)\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <i class=\"hpe-icon\" [ngClass]=\"menu.icon\"></i>\n        <span class=\"label label-primary\" *ngIf=\"menu?.badge\" aria-hidden=\"true\">{{ menu.badge }}</span>\n\n    </a>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li *ngFor=\"let dropdown of menu?.dropdown\"\n            role=\"none\"\n            [class.dropdown-header]=\"dropdown.header\"\n            [class.dropdown-divider]=\"dropdown.divider\">\n\n            <span class=\"font-bold\" *ngIf=\"dropdown.header\">{{ dropdown.title }}</span>\n\n            <a *ngIf=\"!dropdown.header\"\n                role=\"menuitem\"\n                class=\"dropdown-item\"\n                tabindex=\"-1\"\n                (click)=\"select(dropdown)\"\n                (keydown)=\"keydownHandler(dropdown, $event)\"\n                uxMenuNavigationItem>\n\n\n                <span class=\"dropdown-item-title\">\n                    <i class=\"hpe-icon hpe-fw\" [ngClass]=\"dropdown.icon\"></i>\n                    {{ dropdown.title }}\n                </span>\n                <span *ngIf=\"dropdown.subtitle\" class=\"dropdown-item-subtitle\">{{ dropdown.subtitle }}</span>\n\n            </a>\n        </li>\n\n    </ul>\n</div>"
                    },] },
        ];
        /** @nocollapse */
        PageHeaderIconMenuComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService, },
            ];
        };
        PageHeaderIconMenuComponent.propDecorators = {
            "menu": [{ type: core.Input },],
            "menuNavigationToggle": [{ type: core.ViewChild, args: ['menuNavigationToggle',] },],
        };
        return PageHeaderIconMenuComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationDropdownItemComponent = (function () {
        function PageHeaderNavigationDropdownItemComponent(_pageHeaderService) {
            var _this = this;
            this._pageHeaderService = _pageHeaderService;
            this.dropdownOpen = false;
            this._hover$ = new Subject.Subject();
            // subscribe to stream with a debounce (a small debounce is all that is required)
            this._subscription = this._hover$.pipe(operators.debounceTime(1)).subscribe(function (visible) { return _this.dropdownOpen = visible; });
            // Close submenus when selected item changes
            this._subscription.add(_pageHeaderService.selected$.subscribe(function () {
                _this.dropdownOpen = false;
            }));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.select =
            function (item) {
                // clicking on an item with children then return
                if (item.children) {
                    return;
                }
                // emit the selected item in an event
                this._pageHeaderService.select(item);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.focus =
            function () {
                this.button.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverStart =
            function () {
                this._hover$.next(true);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverLeave =
            function () {
                this._hover$.next(false);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.close =
            function () {
                this.dropdownOpen = false;
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.keydownHandler =
            function (event, item) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderNavigationDropdownItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-dropdown-item',
                        exportAs: 'ux-page-header-horizontal-navigation-dropdown-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0\"\n    dropdown\n    #subMenu=\"bs-dropdown\"\n    [isOpen]=\"dropdownOpen\"\n    container=\"body\"\n    placement=\"right\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdownOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        #button\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdownOpen\"\n        menuPosition=\"right\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n        <span class=\"dropdown-item-icon hpe-icon hpe-next\"></span>\n\n    </a>\n\n    <ul *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-submenu\"\n        (mouseenter)=\"hoverStart()\"\n        (mouseleave)=\"hoverLeave()\"\n        uxMenuNavigation\n        #menuNavigation=\"uxMenuNavigation\"\n        [toggleButton]=\"menuNavigationToggle\"\n        toggleButtonPosition=\"left\">\n\n        <li *ngFor=\"let subItem of item.children\" role=\"none\">\n\n            <a role=\"menuitem\"\n                class=\"dropdown-item\"\n                [class.selected]=\"subItem.selected\"\n                [attr.aria-selected]=\"subItem.selected\"\n                tabindex=\"-1\"\n                (click)=\"select(subItem)\"\n                (keydown)=\"keydownHandler($event, subItem)\"\n                uxMenuNavigationItem>\n\n                <span class=\"dropdown-item-title\">{{ subItem.title }}</span>\n\n            </a>\n\n        </li>\n    </ul>\n\n</div>\n\n<div *ngIf=\"!item.children || item.children.length === 0\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        #button\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        (click)=\"select(item)\"\n        (keydown)=\"keydownHandler($event, item)\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n\n    </a>\n\n</div>"
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationDropdownItemComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationDropdownItemComponent.propDecorators = {
            "item": [{ type: core.Input },],
            "button": [{ type: core.ViewChild, args: ['button',] },],
        };
        return PageHeaderNavigationDropdownItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationItemComponent = (function () {
        function PageHeaderNavigationItemComponent(elementRef, _pageHeaderService) {
            this.elementRef = elementRef;
            this._pageHeaderService = _pageHeaderService;
            this.secondary$ = this._pageHeaderService.secondary$;
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this._pageHeaderService.selected$.subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                    if (next && _this.isOpen) {
                        _this.isOpen = false;
                        // If menu was closed, keep focus on the toggle button
                        // If menu was closed, keep focus on the toggle button
                        _this.button.focus();
                    }
                });
                if (this.menu) {
                    this._subscription.add(this.menu.onHidden.subscribe(function () { return _this.dropdowns.forEach(function (dropdown$$1) { return dropdown$$1.close(); }); }));
                }
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.select =
            function () {
                // if the item has children then do nothing at this stage
                if (this.item.children && this._pageHeaderService.secondary$.getValue() === false) {
                    return;
                }
                // otherwise select the current item
                this._pageHeaderService.select(this.item);
            };
        PageHeaderNavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0 && !(secondary$ | async)\"\n    dropdown\n    #menu=\"bs-dropdown\"\n    [(isOpen)]=\"isOpen\"\n    container=\"body\"\n    placement=\"bottom left\">\n\n    <button role=\"menuitem\"\n        class=\"horizontal-navigation-button\"\n        [class.selected]=\"item.selected\"\n        [class.open]=\"isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"isOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #button=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n        <span class=\"navigation-item-label\">{{ item?.title }}</span>\n        <span class=\"hpe-icon hpe-down\"></span>\n\n    </button>\n\n    <div *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-menu\"\n        uxMenuNavigation\n        [toggleButton]=\"button\"\n        toggleButtonPosition=\"top\">\n\n        <div *ngFor=\"let item of item?.children\" uxMenuNavigationItem (activated)=\"dropdownItem.focus()\">\n            <ux-page-header-horizontal-navigation-dropdown-item\n                #dropdownItem=\"ux-page-header-horizontal-navigation-dropdown-item\"\n                [item]=\"item\">\n            </ux-page-header-horizontal-navigation-dropdown-item>\n        </div>\n\n    </div>\n\n</div>\n\n<button *ngIf=\"!item.children || item.children.length === 0 || (secondary$ | async)\"\n    role=\"menuitem\"\n    class=\"horizontal-navigation-button\"\n    [class.selected]=\"item.selected\"\n    [attr.aria-selected]=\"item.selected\"\n    (click)=\"select()\">\n\n    <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n    <span class=\"navigation-item-label\">{{ item?.title }}</span>\n\n</button>"
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationItemComponent.propDecorators = {
            "button": [{ type: core.ViewChild, args: ['button',] },],
            "menu": [{ type: core.ViewChild, args: ['menu',] },],
            "dropdowns": [{ type: core.ViewChildren, args: [PageHeaderNavigationDropdownItemComponent,] },],
            "item": [{ type: core.Input },],
        };
        return PageHeaderNavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationSecondaryItemDirective = (function () {
        function PageHeaderNavigationSecondaryItemDirective(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(operators.delay(0), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                });
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        PageHeaderNavigationSecondaryItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderNavigationSecondaryItem]'
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationSecondaryItemDirective.ctorParameters = function () {
            return [
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationSecondaryItemDirective.propDecorators = {
            "item": [{ type: core.Input, args: ['uxPageHeaderNavigationSecondaryItem',] },],
        };
        return PageHeaderNavigationSecondaryItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationComponent = (function () {
        function PageHeaderNavigationComponent(elementRef, resizeService, _pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this.items$ = this._pageHeaderService.items$;
            this.indicatorVisible = false;
            this.indicatorX = 0;
            this.indicatorWidth = 0;
            this._subscription = new Subscription.Subscription();
            this._subscription.add(resizeService.addResizeListener(elementRef.nativeElement).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.selected$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.secondary$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngAfterViewInit =
            function () {
                this.updateSelectedIndicator();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.updateSelectedIndicator =
            function () {
                var _this = this;
                setTimeout(function () {
                    // find the selected item
                    var /** @type {?} */ selected = _this.menuItems.find(function (item) { return item.item.selected; });
                    // determine whether or not to show the indicator
                    // determine whether or not to show the indicator
                    _this.indicatorVisible = !!selected;
                    // set the width of the indicator to match the width of the navigation item
                    if (selected) {
                        var /** @type {?} */ styles = getComputedStyle(selected.elementRef.nativeElement);
                        _this.indicatorX = selected.elementRef.nativeElement.offsetLeft;
                        _this.indicatorWidth = parseInt(styles.getPropertyValue('width'));
                    }
                });
            };
        PageHeaderNavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation',
                        template: "<ux-page-header-horizontal-navigation-item\n    *ngFor=\"let item of items$ | async\"\n    [item]=\"item\">\n</ux-page-header-horizontal-navigation-item>\n\n<div class=\"selected-indicator\"\n    [style.opacity]=\"indicatorVisible ? 1 : 0\"\n    [style.margin-left.px]=\"indicatorX\"\n    [style.width.px]=\"indicatorWidth\">\n</div>",
                        host: {
                            'role': 'menubar'
                        }
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationComponent.propDecorators = {
            "menuItems": [{ type: core.ViewChildren, args: [PageHeaderNavigationItemComponent,] },],
        };
        return PageHeaderNavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderComponent = (function () {
        function PageHeaderComponent(_colorService, _pageHeaderService) {
            this._colorService = _colorService;
            this._pageHeaderService = _pageHeaderService;
            this.alignment = 'center';
            this.condensed = false;
            this.backVisible = true;
            this.secondaryNavigationAlignment = 'center';
            this.backClick = new core.EventEmitter();
            this.selected$ = this._pageHeaderService.selected$;
            this.selectedRoot$ = this._pageHeaderService.selectedRoot$;
            this._crumbs = [];
        }
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigationAutoselect", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondaryNavigationAutoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._pageHeaderService.secondaryNavigationAutoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "items", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._pageHeaderService.setItems(items);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigation", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondary$.getValue();
            },
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._pageHeaderService.setSecondaryNavigation(enabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "crumbs", {
            get: /**
             * @return {?}
             */ function () {
                return this.condensed ? __spread(this._crumbs, [{ title: this.header }]) : this._crumbs;
            },
            set: /**
             * @param {?} crumbs
             * @return {?}
             */ function (crumbs) {
                this._crumbs = crumbs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyBackground", {
            get: /**
             * @return {?}
             */ function () {
                return this._familyBackground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._familyBackground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyForeground", {
            get: /**
             * @return {?}
             */ function () {
                return this._familyForeground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._familyForeground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.goBack =
            function () {
                this.backClick.emit();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderComponent.prototype.select =
            function (item) {
                this._pageHeaderService.select(item);
            };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header',
                        exportAs: 'ux-page-header',
                        template: "<div class=\"ux-page-header\" [class.page-header-condensed]=\"condensed\" role=\"banner\">\n\n    <!-- Display Upper Section when not condensed -->\n    <div class=\"page-header-actions\" *ngIf=\"!condensed\">\n\n        <div class=\"page-header-logo-container\" role=\"presentation\" [hidden]=\"!logo\">\n            <img [attr.src]=\"logo\" class=\"page-header-logo\">\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n    </div>\n\n    <!-- Display Lower Section When Not Condensed -->\n    <div class=\"page-header-details\" *ngIf=\"!condensed\">\n\n        <div class=\"page-header-state-container\" role=\"navigation\">\n\n            <button *ngIf=\"backVisible === true\" class=\"page-header-back-button\" (click)=\"goBack()\" aria-label=\"Go Back\">\n                <span class=\"hpe-icon hpe-previous text-primary\"></span>\n            </button>\n\n            <div class=\"page-header-title-container\">\n\n                <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n\n                <h1 class=\"page-header-title\" [style.backgroundColor]=\"familyBackground\" [style.color]=\"familyForeground\">{{ header }}</h1>\n            </div>\n\n        </div>\n\n    </div>\n\n    <!-- Display This Section Optimized for Condensed Mode -->\n    <div class=\"page-header-condensed-content\" *ngIf=\"condensed\">\n\n        <div class=\"page-header-breadcrumbs\" role=\"navigation\">\n            <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n\n    </div>\n\n</div>\n\n<div class=\"page-header-secondary\" [ngClass]=\"secondaryNavigationAlignment\" role=\"navigation\" *ngIf=\"secondaryNavigation && (selectedRoot$ | async)\">\n    <ul class=\"nav nav-tabs\" role=\"tablist\" aria-label=\"Secondary Navigation\" *ngIf=\"(selectedRoot$ | async)?.children; let children\">\n        <li *ngFor=\"let child of children\"\n            [class.active]=\"child.selected\"\n            role=\"none\"\n            [uxPageHeaderNavigationSecondaryItem]=\"child\">\n\n            <a role=\"tab\"\n                [attr.aria-selected]=\"child.selected\"\n                tabindex=\"0\"\n                (click)=\"select(child)\"\n                (keydown.enter)=\"select(child)\">{{ child.title }}</a>\n\n        </li>\n    </ul>\n</div>",
                        providers: [PageHeaderService]
                    },] },
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: ColorService, },
                { type: PageHeaderService, },
            ];
        };
        PageHeaderComponent.propDecorators = {
            "logo": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "alignment": [{ type: core.Input },],
            "condensed": [{ type: core.Input },],
            "iconMenus": [{ type: core.Input },],
            "backVisible": [{ type: core.Input },],
            "secondaryNavigationAlignment": [{ type: core.Input },],
            "secondaryNavigationAutoselect": [{ type: core.Input },],
            "items": [{ type: core.Input },],
            "secondaryNavigation": [{ type: core.Input },],
            "crumbs": [{ type: core.Input },],
            "familyBackground": [{ type: core.Input },],
            "familyForeground": [{ type: core.Input },],
            "backClick": [{ type: core.Output },],
            "customMenus": [{ type: core.ContentChildren, args: [PageHeaderCustomMenuDirective, { read: core.TemplateRef },] },],
        };
        return PageHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderModule = (function () {
        function PageHeaderModule() {
        }
        PageHeaderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            BreadcrumbsModule,
                            ColorServiceModule,
                            ResizeModule,
                            MenuNavigationModule,
                            dropdown.BsDropdownModule.forRoot()
                        ],
                        exports: [
                            PageHeaderComponent,
                            PageHeaderCustomMenuDirective
                        ],
                        declarations: [
                            PageHeaderComponent,
                            PageHeaderIconMenuComponent,
                            PageHeaderCustomMenuDirective,
                            PageHeaderNavigationComponent,
                            PageHeaderNavigationItemComponent,
                            PageHeaderNavigationDropdownItemComponent,
                            PageHeaderNavigationSecondaryItemDirective
                        ]
                    },] },
        ];
        /** @nocollapse */
        PageHeaderModule.ctorParameters = function () { return []; };
        return PageHeaderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarComponent = (function () {
        function ProgressBarComponent() {
            this.value = 0;
            this.max = 100;
            this.indeterminate = false;
        }
        ProgressBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-progress-bar',
                        template: "<div *ngIf=\"!indeterminate\" class=\"progressbar-track\" [style.width.%]=\"(value / max) * 100\" [style.backgroundColor]=\"barColor\">\n    <ng-content></ng-content>\n</div>\n<div *ngIf=\"indeterminate\" class=\"progressbar-track indeterminate\" [style.backgroundColor]=\"barColor\">\n    <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        ProgressBarComponent.ctorParameters = function () { return []; };
        ProgressBarComponent.propDecorators = {
            "value": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "indeterminate": [{ type: core.Input },],
            "trackColor": [{ type: core.Input },],
            "barColor": [{ type: core.Input },],
        };
        return ProgressBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarModule = (function () {
        function ProgressBarModule() {
        }
        ProgressBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [ProgressBarComponent],
                        declarations: [ProgressBarComponent]
                    },] },
        ];
        /** @nocollapse */
        ProgressBarModule.ctorParameters = function () { return []; };
        return ProgressBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ RADIOBUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueRadioId = 0;
    var RadioButtonComponent = (function () {
        function RadioButtonComponent() {
            this._radioButtonId = "ux-radio-button-" + ++uniqueRadioId;
            this.id = this._radioButtonId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.simplified = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.ariaDescribedby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(RadioButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._radioButtonId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.toggle =
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                // toggle the checked state
                this.value = this.option;
                // call callback
                this.onChangeCallback(this.value);
            };
        // Functions required to update ng-model
        /**
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue =
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        RadioButtonComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        RadioButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-radio-button',
                        template: "<label [attr.for]=\"inputId\" class=\"ux-radio-button\"\n       [class.ux-radio-button-checked]=\"value === option\"\n       [class.ux-radio-button-simplified]=\"simplified\"\n       [class.ux-radio-button-disabled]=\"disabled\"\n       [class.ux-radio-button-focused]=\"focused\">\n\n    <div class=\"ux-radio-button-container\">\n        <input class=\"ux-radio-button-input\"\n            type=\"radio\"\n            [id]=\"inputId\"\n            [checked]=\"value === option\"\n            [disabled]=\"disabled\"\n            [tabindex]=\"tabindex || value === option ? 0 : -1\"\n            [attr.name]=\"name\"\n            [required]=\"required\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [attr.aria-checked]=\"value === option\"\n            (focus)=\"focused = true\"\n            (blur)=\"focused = false\"\n            (change)=\"toggle()\"\n            (click)=\"$event.stopPropagation()\">\n    </div>\n\n    <span class=\"ux-radio-button-label\">\n        <ng-content></ng-content>\n    </span>\n\n</label>",
                        providers: [RADIOBUTTON_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonComponent.ctorParameters = function () { return []; };
        RadioButtonComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "name": [{ type: core.Input },],
            "required": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "clickable": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "simplified": [{ type: core.Input },],
            "option": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
            "ariaLabelledby": [{ type: core.Input, args: ['aria-labelledby',] },],
            "ariaDescribedby": [{ type: core.Input, args: ['aria-describedby',] },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input },],
        };
        return RadioButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RadioButtonModule = (function () {
        function RadioButtonModule() {
        }
        RadioButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [RadioButtonComponent],
                        declarations: [RadioButtonComponent]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonModule.ctorParameters = function () { return []; };
        return RadioButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderService = (function () {
        function SearchBuilderService() {
            this.query = {};
            this.queryChange = new Subject.Subject();
            this.validationChange = new BehaviorSubject.BehaviorSubject(true);
            this._componentId = 0;
            this._components = [];
            this._validation = {};
        }
        /**
         * Add a component to the internal list of components
         */
        /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponent =
            function (component) {
                // ensure there are no components with a matching name
                if (this._components.find(function (cmp) { return cmp.name === component.name; })) {
                    throw new Error("Search builder components must have a unique name. The name " + component.name + " has already been used.");
                }
                // if unique then add the component to the list
                this._components.push(component);
            };
        /**
         * Bulk registration of components
         * (Just a helper method)
         */
        /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponents =
            function (components) {
                var _this = this;
                components.forEach(function (component) { return _this.registerComponent(component); });
            };
        /**
         * Get a registered component class
         */
        /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
        SearchBuilderService.prototype.getComponent =
            function (name) {
                // find the component
                var /** @type {?} */ component = this._components.find(function (cmp) { return cmp.name === name; });
                // if there is no match throw an exception
                if (!component) {
                    throw new Error("No search build component with the name " + name + " exists");
                }
                // ensure config is defined - at least to an empty object
                component.config = component.config || {};
                return component;
            };
        /**
         * Update the internal search query state
         * note that the query will be immutable
         */
        /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
        SearchBuilderService.prototype.setQuery =
            function (query) {
                this.query = Object.assign({}, query);
            };
        /**
         * Return the current query state
         */
        /**
         * Return the current query state
         * @return {?}
         */
        SearchBuilderService.prototype.getQuery =
            function () {
                return this.query;
            };
        /**
         * Trigger the observable to indicate the query has been updated
         */
        /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
        SearchBuilderService.prototype.queryHasChanged =
            function () {
                this.queryChange.next(this.query);
            };
        /**
         * Store the validation state of the query
         */
        /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
        SearchBuilderService.prototype.setValid =
            function (id, valid) {
                var _this = this;
                // store the state for this specific component
                this._validation[id] = valid;
                // evaluate the entire validation state
                this.validationChange.next(!Object.keys(this._validation).some(function (key) { return !_this._validation[key]; }));
            };
        /**
         * Generate a unique id for each component
         */
        /**
         * Generate a unique id for each component
         * @return {?}
         */
        SearchBuilderService.prototype.generateComponentId =
            function () {
                return this._componentId++;
            };
        SearchBuilderService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SearchBuilderService.ctorParameters = function () { return []; };
        return SearchBuilderService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupService = (function () {
        function SearchBuilderGroupService(_searchBuilderService) {
            this._searchBuilderService = _searchBuilderService;
        }
        /**
         * Initialise the group by defining an id
         */
        /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
        SearchBuilderGroupService.prototype.init =
            function (id) {
                var _this = this;
                // store the name of the group
                this._id = id;
                // create the entry in the query object if it doesn't exist
                if (!this._searchBuilderService.query[this._id]) {
                    // create the section
                    this._searchBuilderService.query[this._id] = [];
                    // emit the changes after the initial setup
                    setTimeout(function () { return _this._searchBuilderService.queryHasChanged(); });
                }
            };
        /**
         * Remove a field from the search builder query
         */
        /**
         * Remove a field from the search builder query
         * @param {?} field
         * @return {?}
         */
        SearchBuilderGroupService.prototype.remove =
            function (field) {
                // get the query for this group
                var /** @type {?} */ query = this.getQuery();
                // remove the field from the array
                query.splice(query.indexOf(field), 1);
            };
        /**
         * Get the query for this specific search group
         */
        /**
         * Get the query for this specific search group
         * @return {?}
         */
        SearchBuilderGroupService.prototype.getQuery =
            function () {
                return this._searchBuilderService.query[this._id] ? this._searchBuilderService.query[this._id] : [];
            };
        SearchBuilderGroupService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SearchBuilderGroupService.ctorParameters = function () {
            return [
                { type: SearchBuilderService, },
            ];
        };
        return SearchBuilderGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupComponent = (function () {
        function SearchBuilderGroupComponent(searchBuilderGroupService, _searchBuilderService) {
            this.searchBuilderGroupService = searchBuilderGroupService;
            this._searchBuilderService = _searchBuilderService;
            this.operator = 'and';
            this.addText = 'Add a field';
            this.showPlaceholder = false;
            this.add = new core.EventEmitter();
            this.remove = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnInit =
            function () {
                // ensure we have a name otherwise throw an error
                if (!this.id) {
                    throw new Error('Search builder group must have a name attribute.');
                }
                // otherwise register the group
                this.searchBuilderGroupService.init(this.id);
            };
        /**
         * @param {?} field
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.removeField =
            function (field) {
                this.searchBuilderGroupService.remove(field);
                this.remove.emit(field);
            };
        SearchBuilderGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder-group',
                        template: "<h4 class=\"search-group-title\">{{ header }}</h4>\n\n<main class=\"search-group-content\">\n\n  <section class=\"search-group-operator search-group-operator-{{ operator }}\" [class.hidden-operator]=\"searchBuilderGroupService.getQuery().length < 2\">{{ operator }}</section>\n\n  <section class=\"search-group-items\">\n\n    <div class=\"search-group-item-container\" *ngFor=\"let field of searchBuilderGroupService.getQuery()\">\n\n      <div class=\"search-group-item\">\n        <ng-container *uxSearchBuilderOutlet=\"field.type; context: field\"></ng-container>\n      </div>\n\n      <div class=\"search-group-item-remove\" (click)=\"removeField(field)\">\n        <span class=\"hpe-icon hpe-close\"></span>\n      </div>\n    </div>\n\n    <!-- Placeholder Item -->\n    <ng-container *ngIf=\"showPlaceholder\">\n\n      <!-- The Default Placeholder -->\n      <div class=\"search-group-item-container placeholder-item\" *ngIf=\"!placeholder\">\n        \n        <div class=\"search-group-item\">\n          <label class=\"form-label\">New field</label>\n          <div class=\"form-control\"></div>\n        </div>\n  \n      </div>\n\n      <!-- Allow a custom placeholder -->\n    <ng-container *ngTemplateOutlet=\"placeholder\"></ng-container>\n\n    </ng-container>\n\n  </section>\n\n  <section class=\"search-builder-group-add-field\" (click)=\"add.emit($event)\">\n\n    <button type=\"button\" class=\"btn btn-icon btn-circular button-accent\" aria-label=\"Add Field\">\n      <span class=\"hpe-icon hpe-add\" aria-hidden=\"true\"></span>\n    </button>\n\n    <span class=\"search-builder-group-add-field-label\">{{ addText }}</span>\n\n  </section>\n\n</main>\n\n<hr class=\"search-builder-group-divider\">\n",
                        providers: [SearchBuilderGroupService]
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderGroupComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderGroupService, },
                { type: SearchBuilderService, },
            ];
        };
        SearchBuilderGroupComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "operator": [{ type: core.Input },],
            "addText": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "showPlaceholder": [{ type: core.Input },],
            "add": [{ type: core.Output },],
            "remove": [{ type: core.Output },],
        };
        return SearchBuilderGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderOutletDirective = (function () {
        function SearchBuilderOutletDirective(_viewContainerRef, _componentFactoryResolver, _searchBuilderService) {
            this._viewContainerRef = _viewContainerRef;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._searchBuilderService = _searchBuilderService;
        }
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnInit =
            function () {
                // get the class from the type
                var /** @type {?} */ componentDefinition = this._searchBuilderService.getComponent(this.uxSearchBuilderOutlet);
                // create the component factory
                var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentDefinition.component);
                // create the component instance
                this._componentRef = this._viewContainerRef.createComponent(componentFactory);
                // combine the predefined config with any dynmaic config
                var /** @type {?} */ config = Object.assign({}, componentDefinition.config, this.uxSearchBuilderOutletContext.config || {});
                // set the context and config property on the component instance
                this._componentRef.instance.context = this.uxSearchBuilderOutletContext;
                this._componentRef.instance.config = config;
            };
        SearchBuilderOutletDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSearchBuilderOutlet]'
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderOutletDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef, },
                { type: core.ComponentFactoryResolver, },
                { type: SearchBuilderService, },
            ];
        };
        SearchBuilderOutletDirective.propDecorators = {
            "uxSearchBuilderOutlet": [{ type: core.Input },],
            "uxSearchBuilderOutletContext": [{ type: core.Input },],
        };
        return SearchBuilderOutletDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BaseSearchComponent = (function () {
        function BaseSearchComponent(_searchBuilderService, _searchBuilderGroupService) {
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderGroupService = _searchBuilderGroupService;
            this._id = this._searchBuilderService.generateComponentId();
            this._valid = true;
        }
        Object.defineProperty(BaseSearchComponent.prototype, "value", {
            /**
             * Get the current value of the component
             */
            get: /**
             * Get the current value of the component
             * @return {?}
             */ function () {
                return this.context.value;
            },
            /**
             * Set the current value of the component
             */
            set: /**
             * Set the current value of the component
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.context.value = value;
                this._searchBuilderService.queryHasChanged();
                // if value has been set perform validation
                this.validate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                this._searchBuilderService.setValid(this._id, valid);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Make sure we clean up after ourselves
         */
        /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
        BaseSearchComponent.prototype.ngOnDestroy =
            function () {
                this.valid = true;
            };
        /**
         * Perform any required validation on the value
         */
        /**
         * Perform any required validation on the value
         * @return {?}
         */
        BaseSearchComponent.prototype.validate =
            function () {
                // if a custom validation function has been provided then use it
                this.valid = this.config.validation ? this.config.validation(this, this.value) : true;
            };
        BaseSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-base-search',
                        template: ''
                    },] },
        ];
        /** @nocollapse */
        BaseSearchComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService, },
                { type: SearchBuilderGroupService, },
            ];
        };
        return BaseSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchTextComponent = (function (_super) {
        __extends(SearchTextComponent, _super);
        function SearchTextComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'text';
            return _this;
        }
        Object.defineProperty(SearchTextComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchTextComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter text';
            },
            enumerable: true,
            configurable: true
        });
        SearchTextComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-text',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n<input [placeholder]=\"placeholder\" [(ngModel)]=\"value\" class=\"form-control\">"
                    },] },
        ];
        /** @nocollapse */
        SearchTextComponent.ctorParameters = function () { return []; };
        return SearchTextComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateComponent = (function (_super) {
        __extends(SearchDateComponent, _super);
        function SearchDateComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date';
            return _this;
        }
        Object.defineProperty(SearchDateComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter date';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SearchDateComponent.prototype.ngOnInit =
            function () {
                // by default set to the current date if not specified
                if (!this.value) {
                    this.value = new Date();
                }
            };
        SearchDateComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"input-group date m-nil\">\n    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"popover.show()\">\n        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n    </span>\n    <input type=\"text\" #popover=\"ux-popover\" [ngModel]=\"value | date:'dd MMMM yyyy'\" [uxPopover]=\"popoverTemplate\"\n        placement=\"bottom\" popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"placeholder\">\n</div>\n\n<ng-template #popoverTemplate>\n    <ux-date-time-picker [(date)]=\"value\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    },] },
        ];
        /** @nocollapse */
        SearchDateComponent.ctorParameters = function () { return []; };
        return SearchDateComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateRangeComponent = (function (_super) {
        __extends(SearchDateRangeComponent, _super);
        function SearchDateRangeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date-range';
            return _this;
        }
        Object.defineProperty(SearchDateRangeComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "from", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.from) {
                    this.from = new Date();
                }
                // ensure that the from value is a date object
                if (this.value.from instanceof Date === false) {
                    this.value.from = new Date(this.value.from);
                }
                return this.value.from;
            },
            set: /**
             * @param {?} fromValue
             * @return {?}
             */ function (fromValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the from value is a date
                if (fromValue instanceof Date === false) {
                    fromValue = new Date(fromValue);
                }
                // set the latest value
                value.from = fromValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "to", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.to) {
                    this.to = new Date();
                }
                // ensure that the to value is a date object
                if (this.value.to instanceof Date === false) {
                    this.value.to = new Date(this.value.to);
                }
                return this.value.to;
            },
            set: /**
             * @param {?} toValue
             * @return {?}
             */ function (toValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the to value is a date
                if (toValue instanceof Date === false) {
                    toValue = new Date(toValue);
                }
                // set the latest value
                value.to = toValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromLabel || 'From';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toLabel || 'To';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Override the default validation
         */
        /**
         * Override the default validation
         * @return {?}
         */
        SearchDateRangeComponent.prototype.validate =
            function () {
                // check if there is a config validation function
                if (this.config.validation) {
                    return _super.prototype.validate.call(this);
                }
                // create copies of the dates so we can modify time value (to ignore it)
                var /** @type {?} */ from$$1 = new Date(this.value.from);
                var /** @type {?} */ to = new Date(this.value.to);
                // set the time to the same so we dont compare it
                from$$1.setHours(0, 0, 0, 0);
                to.setHours(0, 0, 0, 0);
                // valid if the from date is less than or equal to the to date
                this.valid = from$$1 <= to;
            };
        SearchDateRangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date-range',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"row\">\n    <div class=\"col-sm-12\">\n        <div class=\"form-inline\" [class.has-error]=\"!valid\">\n\n            <div class=\"form-group p-r-md\">\n                <label class=\"form-label m-r-xs\">{{ fromLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon p-r-xs\" tabindex=\"1\" (click)=\"fromPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #fromPopover=\"ux-popover\" [ngModel]=\"from | date:'dd MMMM yyyy'\" [uxPopover]=\"fromPopoverTemplate\" placement=\"bottom\"\n                        popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"fromPlaceholder\">\n                </div>\n            </div>\n\n            <div class=\"form-group p-r-xs\">\n                <label class=\"form-label m-r-xs\">{{ toLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"toPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #toPopover=\"ux-popover\" [ngModel]=\"to | date:'dd MMMM yyyy'\" [uxPopover]=\"toPopoverTemplate\" placement=\"bottom\"\n                        popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"toPlaceholder\">\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n\n<ng-template #fromPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"from\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>\n\n<ng-template #toPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"to\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    },] },
        ];
        /** @nocollapse */
        SearchDateRangeComponent.ctorParameters = function () { return []; };
        return SearchDateRangeComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchSelectComponent = (function (_super) {
        __extends(SearchSelectComponent, _super);
        function SearchSelectComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'select';
            return _this;
        }
        Object.defineProperty(SearchSelectComponent.prototype, "label", {
            /**
             * Provide defaults for undefined properties
             */
            get: /**
             * Provide defaults for undefined properties
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.options || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "multiple", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.multiple || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Select item';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "dropDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.dropDirection || 'down';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "allowNull", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.allowNull || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.disabled || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "maxHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.maxHeight || '250px';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "pageSize", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.pageSize || 20;
            },
            enumerable: true,
            configurable: true
        });
        SearchSelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-select',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<ux-select [(value)]=\"value\" \n           [options]=\"options\" \n           [multiple]=\"multiple\" \n           [placeholder]=\"placeholder\" \n           [dropDirection]=\"dropDirection\"\n           [pageSize]=\"pageSize\"\n           [allowNull]=\"allowNull\"\n           [disabled]=\"disabled\"\n           [maxHeight]=\"maxHeight\"\n           [key]=\"config.key\"\n           [display]=\"config.display\"\n           [loadingTemplate]=\"config.loadingTemplate\"\n           [optionTemplate]=\"config.optionTemplate\"\n           [noOptionsTemplate]=\"config.noOptionsTemplate\">\n</ux-select>"
                    },] },
        ];
        /** @nocollapse */
        SearchSelectComponent.ctorParameters = function () { return []; };
        return SearchSelectComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderComponent = (function () {
        /**
         * Register the default search builder components
         */
        function SearchBuilderComponent(_searchBuilderService) {
            var _this = this;
            this._searchBuilderService = _searchBuilderService;
            this.queryChange = new core.EventEmitter();
            this.valid = new core.EventEmitter(true);
            // watch for any query changes
            this._querySubscription = _searchBuilderService.queryChange.subscribe(function (query) { return _this.queryChange.emit(query); });
            // watch for any changes to the validation
            this._validSubscription = _searchBuilderService.validationChange.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.valid.emit(valid); });
        }
        Object.defineProperty(SearchBuilderComponent.prototype, "components", {
            set: /**
             * @param {?} components
             * @return {?}
             */ function (components) {
                this._searchBuilderService.registerComponents(components);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBuilderComponent.prototype, "query", {
            get: /**
             * @return {?}
             */ function () {
                return this._searchBuilderService.getQuery();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._searchBuilderService.setQuery(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Remove any subscriptions and cleanup
         */
        /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
        SearchBuilderComponent.prototype.ngOnDestroy =
            function () {
                this._querySubscription.unsubscribe();
                this._validSubscription.unsubscribe();
            };
        SearchBuilderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder',
                        template: "<ng-content></ng-content>",
                        providers: [SearchBuilderService]
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService, },
            ];
        };
        SearchBuilderComponent.propDecorators = {
            "components": [{ type: core.Input },],
            "query": [{ type: core.Input },],
            "queryChange": [{ type: core.Output },],
            "valid": [{ type: core.Output },],
        };
        return SearchBuilderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$3 = 0;
    var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SelectComponent; }),
        multi: true
    };
    var SelectComponent = (function () {
        function SelectComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-select-" + ++uniqueId$3;
            this.allowNull = false;
            this.disabled = false;
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiple = false;
            this.pageSize = 20;
            this.valueChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.dropdownOpenChange = new core.EventEmitter();
            this.propagateChange = function (_) { };
            this._input$ = new BehaviorSubject.BehaviorSubject('');
            this._dropdownOpen = false;
            this._subscription = new Subscription.Subscription();
        }
        Object.defineProperty(SelectComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.valueChange.emit(value);
                this.propagateChange(value);
                // if we are not allow multiple selection update the input value (supporting ngModel)
                if (!this.multiple && value !== null) {
                    this.input = this.getDisplay(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input$.next(value);
                this.inputChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "dropdownOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._dropdownOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._dropdownOpen = value;
                this.dropdownOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                // Changes to the input field
                var /** @type {?} */ onInput = this._input$.pipe(operators.filter(function (value) { return _this.allowNull; }), operators.filter(function (value) { return !_this.multiple && value !== _this.getDisplay(_this.value); })).subscribe(function (value) { return _this.value = null; });
                // Set up filter from input
                this.filter$ = this._input$.pipe(operators.map(function (input) { return !_this.multiple && input === _this.getDisplay(_this.value) ? '' : input; }), operators.debounceTime(200));
                // Open the dropdown when filter is nonempty.
                var /** @type {?} */ onFilter = this.filter$.pipe(operators.filter(function (value) { return value && value.length > 0; })).subscribe(function () { return _this.dropdownOpen = true; });
                // store the subscriptions
                this._subscription.add(onInput);
                this._subscription.add(onFilter);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SelectComponent.prototype.ngOnChanges =
            function (changes) {
                if (changes["multiple"] && !changes["multiple"].firstChange && changes["multiple"].currentValue !== changes["multiple"].previousValue) {
                    this.input = '';
                }
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SelectComponent.prototype.writeValue =
            function (obj) {
                if (obj !== undefined && obj !== this._value) {
                    this.value = obj;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnChange =
            function (fn) {
                this.propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnTouched =
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SelectComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputClickHandler =
            function (event) {
                this.selectInputText();
                this.dropdownOpen = true;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputBlurHandler =
            function (event) {
                var _this = this;
                // If a click on the typeahead is in progress, just refocus the input.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.singleTypeahead && this.singleTypeahead.clicking) {
                    this.singleInput.nativeElement.focus();
                    return;
                }
                // Close dropdown and reset text input if focus is lost
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.dropdownOpen = false;
                        if (!_this.multiple) {
                            _this.input = _this.getDisplay(_this.value);
                        }
                    }
                }, 200);
            };
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         */
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputKeyHandler =
            function (event) {
                // Standard keys for typeahead (up/down/esc)
                this._typeaheadKeyService.handleKey(event, this.singleTypeahead);
                switch (event.key) {
                    case 'Enter':
                        if (this._dropdownOpen) {
                            // Set the highlighted option as the value and close
                            this.value = this.singleTypeahead.highlighted;
                            this.dropdownOpen = false;
                        }
                        // Update the input field. If dropdown isn't open then reset it to the previous value.
                        this.input = this.getDisplay(this.value);
                        event.preventDefault();
                        break;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.singleOptionSelected =
            function (event) {
                if (event.option) {
                    this.value = event.option;
                    this.dropdownOpen = false;
                }
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        SelectComponent.prototype.getDisplay =
            function (option) {
                if (option === null || option === undefined) {
                    return '';
                }
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.selectInputText =
            function () {
                this.singleInput.nativeElement.select();
            };
        SelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select',
                        template: "<ux-tag-input *ngIf=\"multiple\"\n    [id]=\"id + '-input'\"\n    [(tags)]=\"value\"\n    [(input)]=\"input\"\n    [addOnPaste]=\"false\"\n    [disabled]=\"disabled\"\n    [display]=\"display\"\n    [freeInput]=\"false\"\n    [placeholder]=\"placeholder\"\n    [showTypeaheadOnClick]=\"true\">\n\n    <ux-typeahead #multipleTypeahead\n        [id]=\"id + '-typeahead'\"\n        [options]=\"options\"\n        [filter]=\"filter$ | async\"\n        [(open)]=\"dropdownOpen\"\n        [display]=\"display\"\n        [key]=\"key\"\n        [disabledOptions]=\"value\"\n        [dropDirection]=\"dropDirection\"\n        [maxHeight]=\"maxHeight\"\n        [multiselectable]=\"true\"\n        [pageSize]=\"pageSize\"\n        [selectFirst]=\"true\"\n        [loadingTemplate]=\"loadingTemplate\"\n        [optionTemplate]=\"optionTemplate\"\n        [noOptionsTemplate]=\"noOptionsTemplate\">\n    </ux-typeahead>\n\n</ux-tag-input>\n\n<div *ngIf=\"!multiple\"\n    class=\"inner-addon right-addon\"\n    [class.disabled]=\"disabled\"\n    role=\"combobox\"\n    [attr.aria-expanded]=\"dropdownOpen\"\n    aria-haspopup=\"listbox\">\n\n    <i class=\"hpe-icon\"\n        [class.hpe-down]=\"dropDirection === 'down'\"\n        [class.hpe-up]=\"dropDirection === 'up'\"></i>\n\n    <input #singleInput type=\"text\" [attr.id]=\"id + '-input'\" class=\"form-control\"\n        [attr.aria-activedescendant]=\"highlightedElement?.id\"\n        aria-autocomplete=\"list\"\n        [attr.aria-controls]=\"singleTypeahead.id\"\n        aria-multiline=\"false\"\n        [(ngModel)]=\"input\"\n        [placeholder]=\"placeholder\"\n        [disabled]=\"disabled\"\n        (click)=\"inputClickHandler($event)\"\n        (blur)=\"inputBlurHandler($event)\"\n        (keydown)=\"inputKeyHandler($event)\">\n\n    <ux-typeahead #singleTypeahead\n        [id]=\"id + '-typeahead'\"\n        [options]=\"options\"\n        [filter]=\"filter$ | async\"\n        [(open)]=\"dropdownOpen\"\n        [display]=\"display\"\n        [key]=\"key\"\n        [dropDirection]=\"dropDirection\"\n        [maxHeight]=\"maxHeight\"\n        [multiselectable]=\"false\"\n        [openOnFilterChange]=\"false\"\n        [pageSize]=\"pageSize\"\n        [selectFirst]=\"true\"\n        [loadingTemplate]=\"loadingTemplate\"\n        [optionTemplate]=\"optionTemplate\"\n        [noOptionsTemplate]=\"noOptionsTemplate\"\n        (optionSelected)=\"singleOptionSelected($event)\"\n        (highlightedElementChange)=\"highlightedElement = $event\">\n    </ux-typeahead>\n\n</div>\n",
                        providers: [SELECT_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        SelectComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
                { type: TypeaheadKeyService, },
            ];
        };
        SelectComponent.propDecorators = {
            "id": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] },],
            "value": [{ type: core.Input },],
            "input": [{ type: core.Input },],
            "dropdownOpen": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "display": [{ type: core.Input },],
            "key": [{ type: core.Input },],
            "allowNull": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "dropDirection": [{ type: core.Input },],
            "maxHeight": [{ type: core.Input },],
            "multiple": [{ type: core.Input },],
            "pageSize": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "loadingTemplate": [{ type: core.Input },],
            "noOptionsTemplate": [{ type: core.Input },],
            "optionTemplate": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "inputChange": [{ type: core.Output },],
            "dropdownOpenChange": [{ type: core.Output },],
            "singleInput": [{ type: core.ViewChild, args: ['singleInput',] },],
            "multipleTypeahead": [{ type: core.ViewChild, args: ['multipleTypeahead',] },],
            "singleTypeahead": [{ type: core.ViewChild, args: ['singleTypeahead',] },],
        };
        return SelectComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputEvent = (function () {
        function TagInputEvent(tag) {
            this.tag = tag;
            this._defaultPrevented = false;
        }
        /**
         * @return {?}
         */
        TagInputEvent.prototype.preventDefault =
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        TagInputEvent.prototype.defaultPrevented =
            function () {
                return this._defaultPrevented;
            };
        return TagInputEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$4 = 0;
    var /** @type {?} */ TAGINPUT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var /** @type {?} */ TAGINPUT_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var TagInputComponent = (function () {
        function TagInputComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-tag-input-" + ++uniqueId$4;
            this.tagsChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.addOnPaste = true;
            this.disabled = false;
            this.enforceTagLimits = false;
            this.freeInput = true;
            this.maxTags = Number.MAX_VALUE;
            this.minTags = 0;
            this.placeholder = '';
            this.showTypeaheadOnClick = false;
            this.tagDelimiters = '';
            this.tagClass = function () { return undefined; };
            this.validationErrors = {};
            this.tagAdding = new core.EventEmitter();
            this.tagAdded = new core.EventEmitter();
            this.tagInvalidated = new core.EventEmitter();
            this.tagRemoving = new core.EventEmitter();
            this.tagRemoved = new core.EventEmitter();
            this.tagClick = new core.EventEmitter();
            this.selectedIndex = -1;
            this.tagApi = {
                getTagDisplay: this.getTagDisplay.bind(this),
                removeTagAt: this.removeTagAt.bind(this),
                canRemoveTagAt: this.canRemoveTagAt.bind(this)
            };
            this.valid = true;
            this.inputValid = true;
            this._input = '';
            this._tags = [];
            this._onChangeHandler = function () { };
            this._onTouchedHandler = function () { };
        }
        Object.defineProperty(TagInputComponent.prototype, "tags", {
            get: /**
             * @return {?}
             */ function () {
                if (!this._tags) {
                    this._tags = [];
                }
                return this._tags;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._tags = value;
                this._onChangeHandler(this._tags);
                this.tagsChange.emit(this._tags);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TagInputComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input = value;
                this.inputChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnInit =
            function () {
                if (!this.tagTemplate) {
                    this.tagTemplate = this._defaultTagTemplate;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // Watch for optional child typeahead control
                this.connectTypeahead(this.typeaheadQuery.first);
                this.typeaheadQuery.changes.subscribe(function (query) {
                    _this.connectTypeahead(query.first);
                });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        TagInputComponent.prototype.ngOnChanges =
            function (changes) {
                if (changes["disabled"]) {
                    if (changes["disabled"].currentValue) {
                        // Clear selection and close dropdown
                        this.selectedIndex = -1;
                        if (this.typeahead) {
                            this.typeahead.open = false;
                        }
                    }
                }
                // Update validation status
                this.validate();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TagInputComponent.prototype.writeValue =
            function (value) {
                if (value) {
                    this.tags = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnChange =
            function (fn) {
                this._onChangeHandler = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnTouched =
            function (fn) {
                this._onTouchedHandler = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TagInputComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnDestroy =
            function () {
                if (this._typeaheadSubscription) {
                    this._typeaheadSubscription.unsubscribe();
                }
            };
        /**
         * Validate the value of the control (tags property).
         */
        /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
        TagInputComponent.prototype.validate =
            function () {
                this.valid = true;
                var /** @type {?} */ tagRangeError = null;
                if (this.tags && (this.tags.length < this.minTags || this.tags.length > this.maxTags)) {
                    tagRangeError = {
                        given: this.tags.length,
                        min: this.minTags,
                        max: this.maxTags
                    };
                    this.valid = false;
                }
                this.validationErrors['tagRangeError'] = tagRangeError;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.keyHandler =
            function (event) {
                if (this.disabled) {
                    return;
                }
                // Get the input field cursor location
                var /** @type {?} */ inputCursorPos = this.tagInput.nativeElement.selectionStart;
                // Determine if the input field has any text selected
                var /** @type {?} */ hasSelection = this.tagInput.nativeElement.selectionStart !== this.tagInput.nativeElement.selectionEnd;
                // Determine if a tag has focus
                var /** @type {?} */ tagSelected = this.isValidTagIndex(this.selectedIndex);
                var /** @type {?} */ inputLength = this.input ? this.input.length : 0;
                // Check whether the arrow keys can move the selection. Otherwise the input field takes the event.
                var /** @type {?} */ canNavigateLeft = tagSelected || (inputCursorPos <= 0 && !hasSelection);
                var /** @type {?} */ canNavigateRight = tagSelected || (inputCursorPos >= inputLength && !hasSelection);
                // Forward key events to the typeahead component.
                this._typeaheadKeyService.handleKey(event, this.typeahead);
                switch (event.key) {
                    case 'Enter':
                        // Check if a typeahead option is highlighted
                        if (this.typeahead && this.typeahead.open && this.typeahead.highlighted) {
                            // Add the typeahead option as a tag, clear the input, and close the dropdown
                            this.commitTypeahead(this.typeahead.highlighted);
                            this.typeahead.open = false;
                        }
                        else {
                            // Validate and add the input text as a tag, if possible
                            this.commitInput();
                        }
                        event.preventDefault();
                        break;
                    case 'Backspace':
                        if (canNavigateLeft) {
                            this.backspace();
                            event.stopPropagation();
                            event.preventDefault();
                        }
                        break;
                    case 'Delete':
                    case 'Del':
                        if (tagSelected) {
                            this.removeTagAt(this.selectedIndex);
                        }
                        break;
                    case 'ArrowLeft':
                    case 'Left':
                        if (canNavigateLeft) {
                            this.moveSelection(-1);
                            event.preventDefault();
                        }
                        break;
                    case 'ArrowRight':
                    case 'Right':
                        if (canNavigateRight) {
                            this.moveSelection(1);
                            event.preventDefault();
                        }
                        break;
                }
                // Check for keys in the tagDelimiters
                if (this.tagDelimiters && this.tagDelimiters.indexOf(this.getKeyChar(event)) >= 0) {
                    // Commit previous text
                    this.commitInput();
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.focusOutHandler =
            function (event) {
                var _this = this;
                // If a click on the typeahead is in progress, don't do anything.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.typeahead && this.typeahead.clicking) {
                    return;
                }
                // Close the dropdown on blur
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.selectedIndex = -1;
                        if (_this.typeahead) {
                            _this.typeahead.open = false;
                        }
                    }
                }, 200);
            };
        /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.tagClickHandler =
            function (event, tag, index) {
                if (this.disabled) {
                    return;
                }
                // Send tagClick event
                var /** @type {?} */ tagClickEvent = new TagInputEvent(tag);
                this.tagClick.emit(tagClickEvent);
                // Prevent focus if preventDefault() was called
                if (tagClickEvent.defaultPrevented()) {
                    event.preventDefault();
                    return;
                }
                // Select the tag (for IE that doesn't propagate focus)
                this.selectTagAt(index);
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputClickHandler =
            function () {
                if (this.disabled) {
                    return;
                }
                if (this.typeahead && this.showTypeaheadOnClick) {
                    this.typeahead.open = true;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputFocusHandler =
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectInput();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.inputPasteHandler =
            function (event) {
                if (this.disabled) {
                    return;
                }
                if (this.addOnPaste) {
                    // Get text from the clipboard
                    var /** @type {?} */ input = null;
                    if (event.clipboardData) {
                        input = event.clipboardData.getData('text/plain');
                    }
                    else if (((window)).clipboardData) {
                        // Internet Explorer only
                        input = ((window)).clipboardData.getData('Text');
                    }
                    // Commit the clipboard text directly
                    if (this.commit(input)) {
                        this.selectInput();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.typeaheadOptionSelectedHandler =
            function (event) {
                if (this.disabled) {
                    return;
                }
                // When the typeahead sends the optionSelected event, commit the object directly
                this.commitTypeahead(event.option);
            };
        /**
         * Commit the current input value and clear the input field if successful.
         */
        /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
        TagInputComponent.prototype.commitInput =
            function () {
                if (this.commit(this.input)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given tag object and clear the input if successful.
         */
        /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.commitTypeahead =
            function (tag) {
                if (this.addTag(tag)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         */
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.commit =
            function (input) {
                if (input && this.freeInput) {
                    // Split the tags by the tagDelimiters if configured
                    var /** @type {?} */ newTags = this.splitTagInput(input);
                    // Check tag validation for all of the individual values
                    var /** @type {?} */ allValid = true;
                    try {
                        for (var newTags_1 = __values(newTags), newTags_1_1 = newTags_1.next(); !newTags_1_1.done; newTags_1_1 = newTags_1.next()) {
                            var newTag = newTags_1_1.value;
                            var /** @type {?} */ valid = this.validateTag(newTag);
                            if (!valid) {
                                allValid = false;
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (newTags_1_1 && !newTags_1_1.done && (_a = newTags_1.return))
                                _a.call(newTags_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    // Add the tags if all are valid
                    if (allValid) {
                        try {
                            for (var newTags_2 = __values(newTags), newTags_2_1 = newTags_2.next(); !newTags_2_1.done; newTags_2_1 = newTags_2.next()) {
                                var newTag = newTags_2_1.value;
                                this.addTag(this.createTag(newTag));
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (newTags_2_1 && !newTags_2_1.done && (_b = newTags_2.return))
                                    _b.call(newTags_2);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                        return true;
                    }
                }
                return false;
                var e_1, _a, e_2, _b;
            };
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         */
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
        TagInputComponent.prototype.backspace =
            function () {
                if (this.disabled) {
                    return;
                }
                if (!this.isValidTagIndex(this.selectedIndex)) {
                    this.selectTagAt(this.tags.length - 1);
                }
                else {
                    this.removeTagAt(this.selectedIndex);
                }
            };
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param d Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} d Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TagInputComponent.prototype.moveSelection =
            function (d) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidSelectIndex(this.selectedIndex)) {
                    this.selectedIndex += d;
                    // Do wrapping of selection when out of bounds
                    if (this.selectedIndex < 0) {
                        this.selectedIndex = this.tags.length;
                    }
                    else if (this.selectedIndex > this.tags.length) {
                        this.selectedIndex = 0;
                    }
                }
            };
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         */
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.getTagDisplay =
            function (tag) {
                if (typeof this.display === 'function') {
                    return this.display(tag);
                }
                if (typeof this.display === 'string') {
                    return tag[(this.display)];
                }
                return tag;
            };
        /**
         * Returns true if the given index is selected (tag index or input field).
         */
        /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isSelected =
            function (index) {
                return index === this.selectedIndex;
            };
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         */
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.selectTagAt =
            function (tagIndex) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidTagIndex(tagIndex)) {
                    this.selectedIndex = tagIndex;
                }
            };
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         */
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
        TagInputComponent.prototype.selectInput =
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectedIndex = this.tags.length;
            };
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         */
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.removeTagAt =
            function (tagIndex) {
                if (this.disabled || !this.canRemoveTagAt(tagIndex)) {
                    return;
                }
                // Check that the tagIndex is in range
                if (this.isValidTagIndex(tagIndex)) {
                    var /** @type {?} */ tag = this.tags[tagIndex];
                    var /** @type {?} */ tagRemovingEvent = new TagInputEvent(tag);
                    this.tagRemoving.emit(tagRemovingEvent);
                    if (!tagRemovingEvent.defaultPrevented()) {
                        // Select input first to avoid issues with dropping focus
                        this.selectInput();
                        // Remove the tag
                        this.tags.splice(tagIndex, 1);
                        // Set focus again since indices have changed
                        this.selectInput();
                        this.tagRemoved.emit(new TagInputEvent(tag));
                        this.validate();
                    }
                }
            };
        /**
         * Returns true if the tag at the given index can be removed.
         */
        /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.canRemoveTagAt =
            function (tagIndex) {
                return this.tags.length > this.minTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if the input field should be available.
         */
        /**
         * Returns true if the input field should be available.
         * @return {?}
         */
        TagInputComponent.prototype.isInputVisible =
            function () {
                return this.tags.length < this.maxTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if any part of the control has focus.
         */
        /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
        TagInputComponent.prototype.hasFocus =
            function () {
                return this.isValidSelectIndex(this.selectedIndex);
            };
        /**
         * @param {?} typeahead
         * @return {?}
         */
        TagInputComponent.prototype.connectTypeahead =
            function (typeahead) {
                var _this = this;
                if (this._typeaheadSubscription) {
                    this._typeaheadSubscription.unsubscribe();
                    this._typeaheadSubscription = null;
                }
                this.typeahead = typeahead;
                if (this.typeahead) {
                    // Set up event handler for selected options
                    this._typeaheadSubscription = this.typeahead.optionSelected.subscribe(this.typeaheadOptionSelectedHandler.bind(this));
                    // Set up event handler for the highlighted element
                    // Added a delay to move it out of the current change detection cycle
                    this._typeaheadSubscription.add(this.typeahead.highlightedElementChange.pipe(delay.delay(0)).subscribe(function (element) {
                        _this.highlightedElement = element;
                    }));
                }
            };
        /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.validateTag =
            function (tagValue) {
                var /** @type {?} */ inputPattern = null;
                this.inputValid = true;
                if (this.tagPattern && !this.tagPattern.test(tagValue)) {
                    inputPattern = {
                        given: tagValue,
                        pattern: this.tagPattern
                    };
                    this.inputValid = false;
                }
                this.validationErrors['inputPattern'] = inputPattern;
                return this.inputValid;
            };
        /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.createTag =
            function (tagValue) {
                var /** @type {?} */ tag = null;
                if (this.createTagHandler && typeof this.createTagHandler === 'function') {
                    tag = this.createTagHandler(tagValue);
                }
                else if (typeof this.display === 'string') {
                    tag = {};
                    tag[(this.display)] = tagValue;
                }
                else {
                    tag = tagValue;
                }
                return tag;
            };
        /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.addTag =
            function (tag) {
                if (tag) {
                    // Verify that the new tag can be displayed
                    var /** @type {?} */ displayValue = this.getTagDisplay(tag);
                    if (displayValue && typeof displayValue === 'string' && displayValue.length > 0) {
                        var /** @type {?} */ tagAddingEvent = new TagInputEvent(tag);
                        this.tagAdding.emit(tagAddingEvent);
                        if (!tagAddingEvent.defaultPrevented()) {
                            this.tags = this.tags || [];
                            this.tags.push(tag);
                            this.tagAdded.emit(new TagInputEvent(tag));
                            this.validate();
                            return true;
                        }
                    }
                }
                return false;
            };
        /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.isValidTagIndex =
            function (tagIndex) {
                return tagIndex >= 0 && tagIndex < this.tags.length;
            };
        /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isValidSelectIndex =
            function (index) {
                return index >= 0 && index <= this.tags.length;
            };
        /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.getKeyChar =
            function (event) {
                switch (event.key) {
                    case 'Spacebar':
                        return ' ';
                }
                return event.key;
            };
        /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.splitTagInput =
            function (input) {
                var /** @type {?} */ tagValues = [input];
                if (this.tagDelimiters && typeof this.tagDelimiters === 'string') {
                    var /** @type {?} */ escapedDelimiters = this.tagDelimiters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    var /** @type {?} */ delimiterRegex = new RegExp("[" + escapedDelimiters + "]", 'g');
                    tagValues = input.split(delimiterRegex).filter(function (s) { return s.length > 0; });
                }
                return tagValues;
            };
        TagInputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tag-input',
                        template: "<ol [attr.role]=\"typeahead ? 'combobox' : 'none'\" [attr.aria-haspopup]=\"typeahead ? 'listbox' : null\">\n    <li *ngFor=\"let tag of tags; let i = index\" class=\"ux-tag\"\n        [class.disabled]=\"disabled\"\n        [ngClass]=\"tagClass(tag, i, isSelected(i))\"\n        [attr.tabindex]=\"disabled ? null : 0\"\n        [focusIf]=\"isSelected(i)\"\n        (click)=\"tagClickHandler($event, tag, i)\"\n        (focus)=\"selectTagAt(i)\">\n\n        <ng-container [ngTemplateOutlet]=\"tagTemplate\"\n            [ngTemplateOutletContext]=\"{tag: tag, index: i, disabled: disabled, api: tagApi}\">\n        </ng-container>\n\n    </li>\n    <li *ngIf=\"isInputVisible()\" class=\"ux-tag-input\" role=\"none\">\n        <input #tagInput type=\"text\" [attr.id]=\"id\" class=\"ux-tag-input\"\n            [(ngModel)]=\"input\"\n            [class.invalid]=\"!inputValid\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            [attr.aria-autocomplete]=\"typeahead ? 'list' : 'none'\"\n            [attr.aria-controls]=\"typeahead?.id\"\n            aria-multiline=\"false\"\n            [placeholder]=\"disabled ? '' : (placeholder || '')\"\n            [disabled]=\"disabled\"\n            [focusIf]=\"isSelected(tags.length)\"\n            (click)=\"inputClickHandler()\"\n            (focus)=\"inputFocusHandler()\"\n            (paste)=\"inputPasteHandler($event)\">\n    </li>\n</ol>\n\n<ng-content #typeahead></ng-content>\n\n<ng-template #defaultTagTemplate let-tag=\"tag\" let-index=\"index\" let-disabled=\"disabled\" let-api=\"api\">\n    <span class=\"ux-tag-text\">{{api.getTagDisplay(tag)}}</span>\n    <button *ngIf=\"api.canRemoveTagAt(index)\"\n        type=\"button\"\n        class=\"ux-tag-remove\"\n        aria-label=\"Remove Item\"\n        [disabled]=\"disabled\"\n        (click)=\"api.removeTagAt(index); $event.stopPropagation();\">\n        <span class=\"hpe-icon hpe-close\"></span>\n    </button>\n</ng-template>",
                        providers: [TAGINPUT_VALUE_ACCESSOR, TAGINPUT_VALIDATOR],
                        host: {
                            '[class.disabled]': 'disabled',
                            '[class.focus]': 'hasFocus()',
                            '[class.invalid]': '!valid || !inputValid'
                        }
                    },] },
        ];
        /** @nocollapse */
        TagInputComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
                { type: TypeaheadKeyService, },
            ];
        };
        TagInputComponent.propDecorators = {
            "id": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] },],
            "tags": [{ type: core.Input, args: ['tags',] },],
            "tagsChange": [{ type: core.Output },],
            "input": [{ type: core.Input, args: ['input',] },],
            "inputChange": [{ type: core.Output },],
            "display": [{ type: core.Input },],
            "addOnPaste": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "enforceTagLimits": [{ type: core.Input },],
            "freeInput": [{ type: core.Input },],
            "maxTags": [{ type: core.Input },],
            "minTags": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "showTypeaheadOnClick": [{ type: core.Input },],
            "tagDelimiters": [{ type: core.Input },],
            "tagPattern": [{ type: core.Input },],
            "tagTemplate": [{ type: core.Input },],
            "tagClass": [{ type: core.Input },],
            "validationErrors": [{ type: core.Input },],
            "createTagHandler": [{ type: core.Input, args: ['createTag',] },],
            "tagAdding": [{ type: core.Output },],
            "tagAdded": [{ type: core.Output },],
            "tagInvalidated": [{ type: core.Output },],
            "tagRemoving": [{ type: core.Output },],
            "tagRemoved": [{ type: core.Output },],
            "tagClick": [{ type: core.Output },],
            "typeaheadQuery": [{ type: core.ContentChildren, args: [TypeaheadComponent,] },],
            "tagInput": [{ type: core.ViewChild, args: ['tagInput',] },],
            "_defaultTagTemplate": [{ type: core.ViewChild, args: ['defaultTagTemplate',] },],
            "keyHandler": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
            "focusOutHandler": [{ type: core.HostListener, args: ['focusout', ['$event'],] },],
        };
        return TagInputComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputModule = (function () {
        function TagInputModule() {
        }
        TagInputModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            FocusIfModule,
                            TypeaheadModule
                        ],
                        exports: [TagInputComponent],
                        declarations: [TagInputComponent],
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        TagInputModule.ctorParameters = function () { return []; };
        return TagInputModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectModule = (function () {
        function SelectModule() {
        }
        SelectModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            InfiniteScrollModule,
                            TagInputModule,
                            TypeaheadModule
                        ],
                        exports: [SelectComponent],
                        declarations: [SelectComponent]
                    },] },
        ];
        /** @nocollapse */
        SelectModule.ctorParameters = function () { return []; };
        return SelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderModule = (function () {
        function SearchBuilderModule() {
        }
        SearchBuilderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            DateTimePickerModule,
                            PopoverModule,
                            SelectModule
                        ],
                        exports: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            BaseSearchComponent
                        ],
                        declarations: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchBuilderOutletDirective,
                            SearchSelectComponent,
                            BaseSearchComponent
                        ],
                        entryComponents: [
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchSelectComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderModule.ctorParameters = function () { return []; };
        return SearchBuilderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelCloseDirective = (function () {
        function SidePanelCloseDirective(_service) {
            this._service = _service;
        }
        /**
         * @return {?}
         */
        SidePanelCloseDirective.prototype.clickHandler =
            function () {
                this._service.close();
            };
        SidePanelCloseDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSidePanelClose]'
                    },] },
        ];
        /** @nocollapse */
        SidePanelCloseDirective.ctorParameters = function () {
            return [
                { type: SidePanelService, },
            ];
        };
        SidePanelCloseDirective.propDecorators = {
            "clickHandler": [{ type: core.HostListener, args: ['click',] },],
        };
        return SidePanelCloseDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS$1 = [
        SidePanelComponent,
        SidePanelCloseDirective
    ];
    var SidePanelModule = (function () {
        function SidePanelModule() {
        }
        SidePanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: EXPORTS$1,
                        declarations: EXPORTS$1
                    },] },
        ];
        /** @nocollapse */
        SidePanelModule.ctorParameters = function () { return []; };
        return SidePanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderComponent = (function () {
        function SliderComponent(colorService, _changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.value = 0;
            this.valueChange = new core.EventEmitter();
            // expose enums to Angular view
            this.sliderType = SliderType;
            this.sliderStyle = SliderStyle;
            this.sliderSize = SliderSize;
            this.sliderSnap = SliderSnap;
            this.sliderThumb = SliderThumb;
            this.sliderTickType = SliderTickType;
            this.sliderThumbEvent = SliderThumbEvent;
            this.sliderCalloutTrigger = SliderCalloutTrigger;
            this.tracks = {
                lower: {
                    size: 0,
                    color: ''
                },
                middle: {
                    size: 0,
                    color: ''
                },
                upper: {
                    size: 0,
                    color: ''
                }
            };
            this.tooltips = {
                lower: {
                    visible: false,
                    position: 0,
                    label: ''
                },
                upper: {
                    visible: false,
                    position: 0,
                    label: ''
                }
            };
            this.thumbs = {
                lower: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 100,
                    value: /** @type {?} */ (null)
                },
                upper: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 101,
                    value: /** @type {?} */ (null)
                }
            };
            // store all the ticks to display
            this.ticks = [];
            // setup default options
            this.defaultOptions = {
                type: SliderType.Value,
                handles: {
                    style: SliderStyle.Button,
                    callout: {
                        trigger: SliderCalloutTrigger.None,
                        background: colorService.getColor('grey2').toHex(),
                        color: '#fff',
                        formatter: function (value) { return value; }
                    },
                    keyboard: {
                        major: 5,
                        minor: 1
                    },
                    aria: {
                        thumb: 'Slider value',
                        lowerThumb: 'Slider lower value',
                        upperThumb: 'Slider upper value'
                    }
                },
                track: {
                    height: SliderSize.Wide,
                    min: 0,
                    max: 100,
                    ticks: {
                        snap: SliderSnap.None,
                        major: {
                            show: true,
                            steps: 10,
                            labels: true,
                            formatter: function (value) { return value; }
                        },
                        minor: {
                            show: true,
                            steps: 5,
                            labels: false,
                            formatter: function (value) { return value; }
                        }
                    },
                    colors: {
                        lower: colorService.getColor('grey6').toHex(),
                        range: colorService.getColor('accent').setAlpha(0.75).toRgba(),
                        higher: colorService.getColor('grey6').toHex()
                    }
                }
            };
        }
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnInit =
            function () {
                this.updateOptions();
                this.updateValues();
                this.setThumbState(SliderThumb.Lower, false, false);
                this.setThumbState(SliderThumb.Upper, false, false);
                // emit the initial value
                this.valueChange.next(this.clone(this.value));
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngDoCheck =
            function () {
                if (this.detectValueChange(this.value, this._value)) {
                    this.updateValues();
                    this._value = this.clone(this.value);
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                // persistent tooltips will need positioned correctly at this stage
                setTimeout(function () {
                    _this.updateTooltipPosition(SliderThumb.Lower);
                    _this.updateTooltipPosition(SliderThumb.Upper);
                    // mark as dirty
                    // mark as dirty
                    _this._changeDetectorRef.markForCheck();
                });
            };
        /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToNearestTick =
            function (thumb, snapTarget, forwards) {
                // get the value for the thumb
                var value = this.getThumbState(thumb).value;
                // get the closest ticks - remove any tick if we are currently on it
                var /** @type {?} */ closest = this.getTickDistances(value, thumb, snapTarget)
                    .filter(function (tick) { return tick.value !== value; })
                    .find(function (tick) { return forwards ? tick.value > value : tick.value < value; });
                // If we have no ticks then move by a predefined amount
                if (closest) {
                    return this.setThumbValue(thumb, this.validateValue(thumb, closest.value));
                }
                var /** @type {?} */ step = snapTarget === SliderSnap.Major ? this.options.handles.keyboard.major : this.options.handles.keyboard.minor;
                this.setThumbValue(thumb, this.validateValue(thumb, value + (forwards ? step : -step)));
            };
        /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToEnd =
            function (thumb, forwards) {
                this.setThumbValue(thumb, this.validateValue(thumb, forwards ? this.options.track.max : this.options.track.min));
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbValue =
            function (thumb) {
                return this.getThumbState(thumb).value;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getFormattedValue =
            function (thumb) {
                return this.options.handles.callout.formatter(this.getThumbState(thumb).value);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbState =
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.thumbs.lower : this.thumbs.upper;
            };
        /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
        SliderComponent.prototype.setThumbState =
            function (thumb, hover, drag) {
                if (thumb === SliderThumb.Lower) {
                    this.thumbs.lower.hover = hover;
                    this.thumbs.lower.drag = drag;
                }
                else {
                    this.thumbs.upper.hover = hover;
                    this.thumbs.upper.drag = drag;
                }
                // update the visibility of the tooltips
                this.updateTooltips(thumb);
            };
        /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.thumbEvent =
            function (thumb, event) {
                // get the current thumb state
                var /** @type {?} */ state = this.getThumbState(thumb);
                // update based upon event
                switch (event) {
                    case SliderThumbEvent.DragStart:
                        state.drag = true;
                        break;
                    case SliderThumbEvent.DragEnd:
                        state.drag = false;
                        break;
                    case SliderThumbEvent.MouseOver:
                        state.hover = true;
                        break;
                    case SliderThumbEvent.MouseLeave:
                        state.hover = false;
                        break;
                    case SliderThumbEvent.None:
                        state.drag = false;
                        state.hover = false;
                        break;
                }
                // update the thumb state
                this.setThumbState(thumb, state.hover, state.drag);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getAriaValueText =
            function (thumb) {
                // get the current thumb value
                var /** @type {?} */ value = this.getThumbValue(thumb);
                // get all the ticks
                var /** @type {?} */ tick = this.ticks.find(function (_tick) { return _tick.value === value; });
                if (tick && tick.label) {
                    return tick.label;
                }
                // otherwise simply display the formatted value
                return this.getFormattedValue(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltips =
            function (thumb) {
                var /** @type {?} */ visible = false;
                var /** @type {?} */ state = this.getThumbState(thumb);
                switch (this.options.handles.callout.trigger) {
                    case SliderCalloutTrigger.Persistent:
                        visible = true;
                        break;
                    case SliderCalloutTrigger.Drag:
                        visible = state.drag;
                        break;
                    case SliderCalloutTrigger.Hover:
                        visible = state.hover || state.drag;
                        break;
                    case SliderCalloutTrigger.Dynamic:
                        visible = true;
                        break;
                }
                // update the state for the corresponding thumb
                this.getTooltip(thumb).visible = visible;
                // update the tooltip text
                this.updateTooltipText(thumb);
                // update the tooltip positions
                this.updateTooltipPosition(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipText =
            function (thumb) {
                // get the thumb value
                var /** @type {?} */ state = this.getThumbState(thumb);
                var /** @type {?} */ tooltip$$1 = this.getTooltip(thumb);
                // store the formatted label
                tooltip$$1.label = this.getFormattedValue(thumb).toString();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltipElement =
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.lowerTooltip : this.upperTooltip;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltip =
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.tooltips.lower : this.tooltips.upper;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipPosition =
            function (thumb) {
                var /** @type {?} */ tooltip$$1 = this.getTooltip(thumb);
                // if tooltip is not visible then stop here
                if (tooltip$$1.visible === false) {
                    return;
                }
                var /** @type {?} */ tooltipElement = this.getTooltipElement(thumb);
                // get the element widths
                var /** @type {?} */ thumbWidth;
                if (this.options.handles.style === SliderStyle.Button) {
                    thumbWidth = this.options.track.height === SliderSize.Narrow ? 16 : 24;
                }
                else {
                    thumbWidth = 2;
                }
                var /** @type {?} */ tooltipWidth = tooltipElement.nativeElement.offsetWidth;
                // calculate the tooltips new position
                var /** @type {?} */ tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);
                // update tooltip position
                tooltip$$1.position = -tooltipPosition;
                if (this.options.type === SliderType.Range && this.options.handles.callout.trigger === SliderCalloutTrigger.Dynamic) {
                    this.preventTooltipOverlap(tooltip$$1);
                }
            };
        /**
         * @param {?} tooltip
         * @return {?}
         */
        SliderComponent.prototype.preventTooltipOverlap =
            function (tooltip$$1) {
                var /** @type {?} */ trackWidth = this.track.nativeElement.offsetWidth;
                var /** @type {?} */ lower = (trackWidth / 100) * this.thumbs.lower.position;
                var /** @type {?} */ upper = (trackWidth / 100) * this.thumbs.upper.position;
                var /** @type {?} */ lowerWidth = this.lowerTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ upperWidth = this.upperTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ diff = (lower + lowerWidth) - (upper - upperWidth);
                // if the tooltips are closer than 16px then adjust so the dont move any close
                if (diff > 0) {
                    if (tooltip$$1 === this.tooltips.lower && this.thumbs.lower.drag === false) {
                        tooltip$$1.position -= (diff / 2);
                    }
                    else if (tooltip$$1 === this.tooltips.upper && this.thumbs.upper.drag === false) {
                        tooltip$$1.position += (diff / 2);
                    }
                }
            };
        /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
        SliderComponent.prototype.clamp =
            function (value, min, max) {
                return Math.min(Math.max(value, min), max);
            };
        /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateThumbPosition =
            function (event, thumb) {
                // get event position - either mouse or touch
                var /** @type {?} */ eventPosition = event instanceof MouseEvent ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;
                // if event position is null do nothing
                if (eventPosition === null) {
                    return;
                }
                // get mouse position
                var /** @type {?} */ mouseX = window.pageXOffset + eventPosition;
                // get track size and position
                var /** @type {?} */ trackBounds = this.track.nativeElement.getBoundingClientRect();
                // restrict the value within the range size
                var /** @type {?} */ position = this.clamp(mouseX - trackBounds.left, 0, trackBounds.width);
                // get fraction representation of location within the track
                var /** @type {?} */ fraction = (position / trackBounds.width);
                // convert to value within the range
                var /** @type {?} */ value = ((this.options.track.max - this.options.track.min) * fraction) + this.options.track.min;
                // ensure value is valid
                value = this.validateValue(thumb, value);
                // snap to a tick if required
                value = this.snapToTick(value, thumb);
                // update the value accordingly
                this.setThumbValue(thumb, value);
                this.updateOrder(thumb);
                this.updateValues();
                // update tooltip text & position
                this.updateTooltipText(thumb);
                // update the position of all visible tooltips
                this.updateTooltipPosition(SliderThumb.Lower);
                this.updateTooltipPosition(SliderThumb.Upper);
                // mark as dirty for change detection
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateOrder =
            function (thumb) {
                var /** @type {?} */ lower = thumb === SliderThumb.Lower ? 101 : 100;
                var /** @type {?} */ upper = thumb === SliderThumb.Lower ? 100 : 101;
                // The most recently used thumb should be above
                this.thumbs.lower.order = lower;
                this.thumbs.upper.order = upper;
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
        SliderComponent.prototype.getTickDistances =
            function (value, thumb, snapTarget) {
                // if snap target is none then return original value
                if (snapTarget === SliderSnap.None) {
                    return [];
                }
                // get filtered ticks
                var /** @type {?} */ ticks;
                switch (snapTarget) {
                    case SliderSnap.Minor:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Minor; });
                        break;
                    case SliderSnap.Major:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Major; });
                        break;
                    default:
                        ticks = this.ticks.slice(0);
                }
                // get the track limit
                var /** @type {?} */ lowerLimit = this.options.track.min;
                var /** @type {?} */ upperLimit = this.options.track.max;
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Lower) {
                    upperLimit = this.thumbs.upper.value;
                }
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Upper) {
                    lowerLimit = this.thumbs.lower.value;
                }
                // Find the closest tick to the current position
                var /** @type {?} */ range = ticks.filter(function (tick) { return tick.value >= lowerLimit && tick.value <= upperLimit; });
                // If there are no close ticks in the valid range then dont snap
                if (range.length === 0) {
                    return [];
                }
                return range.sort(function (tickOne, tickTwo) {
                    var /** @type {?} */ tickOneDelta = Math.max(tickOne.value, value) - Math.min(tickOne.value, value);
                    var /** @type {?} */ tickTwoDelta = Math.max(tickTwo.value, value) - Math.min(tickTwo.value, value);
                    return tickOneDelta - tickTwoDelta;
                });
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.snapToTick =
            function (value, thumb) {
                var /** @type {?} */ tickDistances = this.getTickDistances(value, thumb, this.options.track.ticks.snap);
                // if there are no ticks return the current value
                if (tickDistances.length === 0) {
                    return value;
                }
                // get the closest tick
                return tickDistances[0].value;
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.validateValue =
            function (thumb, value) {
                // if slider is not a range value is always valid providing it is within the chart min and max values
                if (this.options.type === SliderType.Value) {
                    return Math.max(Math.min(value, this.options.track.max), this.options.track.min);
                }
                // check if value is with chart ranges
                if (value > this.options.track.max) {
                    return thumb === SliderThumb.Lower ? Math.min(this.options.track.max, this.thumbs.upper.value) : this.options.track.max;
                }
                if (value < this.options.track.min) {
                    return thumb === SliderThumb.Upper ? Math.max(this.options.track.min, this.thumbs.lower.value) : this.options.track.min;
                }
                // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
                if (thumb === SliderThumb.Lower) {
                    if (this.thumbs.upper.value === null) {
                        return value;
                    }
                    return value <= this.thumbs.upper.value ? value : this.thumbs.upper.value;
                }
                if (thumb === SliderThumb.Upper) {
                    if (this.thumbs.lower.value === null) {
                        return value;
                    }
                    return value >= this.thumbs.lower.value ? value : this.thumbs.lower.value;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateOptions =
            function () {
                // add in the default options that user hasn't specified
                this.options = this.deepMerge(this.options || {}, this.defaultOptions);
                this.updateTrackColors();
                this.updateTicks();
                this.updateValues();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateValues =
            function () {
                if (this.value === undefined || this.value === null) {
                    this.value = 0;
                }
                var /** @type {?} */ lowerValue = typeof this.value === 'number' ? this.value : this.value.low;
                var /** @type {?} */ upperValue = typeof this.value === 'number' ? this.value : this.value.high;
                // validate values
                lowerValue = this.validateValue(SliderThumb.Lower, Number(lowerValue.toFixed(4)));
                upperValue = this.validateValue(SliderThumb.Upper, Number(upperValue.toFixed(4)));
                // calculate the positions as percentages
                var /** @type {?} */ lowerPosition = (((lowerValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                var /** @type {?} */ upperPosition = (((upperValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                // update thumb positions
                this.thumbs.lower.position = lowerPosition;
                this.thumbs.upper.position = upperPosition;
                // calculate the track sizes
                this.tracks.lower.size = lowerPosition;
                this.tracks.middle.size = upperPosition - lowerPosition;
                this.tracks.upper.size = this.options.type === SliderType.Value ? 100 - lowerPosition : 100 - upperPosition;
                // update the value input
                this.setValue(lowerValue, upperValue);
            };
        /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
        SliderComponent.prototype.setValue =
            function (low, high) {
                this.thumbs.lower.value = low;
                this.thumbs.upper.value = high;
                var /** @type {?} */ previousValue = this.clone(this._value);
                this.value = this.options.type === SliderType.Value ? low : { low: low, high: high };
                // call the event emitter if changes occured
                if (this.detectValueChange(this.value, previousValue)) {
                    this.valueChange.emit(this.clone(this.value));
                    this.updateTooltipText(SliderThumb.Lower);
                    this.updateTooltipText(SliderThumb.Upper);
                }
                else {
                    this.valueChange.emit(this.clone(this.value));
                }
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.setThumbValue =
            function (thumb, value) {
                // update the thumb value
                this.getThumbState(thumb).value = value;
                // forward these changes to the value
                this.setValue(this.thumbs.lower.value, this.thumbs.upper.value);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTicks =
            function () {
                // get tick options
                var /** @type {?} */ majorOptions = this.options.track.ticks.major;
                var /** @type {?} */ minorOptions = this.options.track.ticks.minor;
                // check if we should show ticks
                if (majorOptions.show === false && minorOptions.show === false) {
                    this.ticks = [];
                }
                // create ticks for both major and minor - only get the ones to be shown
                var /** @type {?} */ majorTicks = this.getTicks(majorOptions, SliderTickType.Major).filter(function (tick) { return tick.showTicks; });
                var /** @type {?} */ minorTicks = this.getTicks(minorOptions, SliderTickType.Minor).filter(function (tick) { return tick.showTicks; });
                // remove any minor ticks that are on a major interval
                this.ticks = this.unionTicks(majorTicks, minorTicks);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTrackColors =
            function () {
                // get colors for each part of the track
                var _a = this.options.track.colors, lower = _a.lower, range = _a.range, higher = _a.higher;
                // update the controller value
                this.tracks.lower.color = typeof lower === 'string' ? lower : "linear-gradient(to right, " + lower.join(', ') + ")";
                this.tracks.middle.color = typeof range === 'string' ? range : "linear-gradient(to right, " + range.join(', ') + ")";
                this.tracks.upper.color = typeof higher === 'string' ? higher : "linear-gradient(to right, " + higher.join(', ') + ")";
            };
        /**
         * @param {?} steps
         * @return {?}
         */
        SliderComponent.prototype.getSteps =
            function (steps) {
                // if they are already an array just return it
                if (steps instanceof Array) {
                    return steps;
                }
                var /** @type {?} */ output = [];
                // otherwise calculate the steps
                for (var /** @type {?} */ idx = this.options.track.min; idx <= this.options.track.max; idx += steps) {
                    output.push(idx);
                }
                return output;
            };
        /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
        SliderComponent.prototype.getTicks =
            function (options, type) {
                // create an array to store the ticks and step points
                var /** @type {?} */ steps = this.getSteps(options.steps);
                // get some chart options
                var /** @type {?} */ min = this.options.track.min;
                var /** @type {?} */ max = this.options.track.max;
                // convert each step to a slider tick and remove invalid ticks
                return steps.map(function (step) {
                    return {
                        showTicks: options.show,
                        showLabels: options.labels,
                        type: type,
                        position: ((step - min) / (max - min)) * 100,
                        value: step,
                        label: options.formatter(step)
                    };
                }).filter(function (tick) { return tick.position >= 0 && tick.position <= 100; });
            };
        /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
        SliderComponent.prototype.unionTicks =
            function (majorTicks, minorTicks) {
                // get all ticks combined removing any minor ticks with the same value as major ticks
                return majorTicks.concat(minorTicks)
                    .filter(function (tick, index, array) { return tick.type === SliderTickType.Major || !array.find(function (tk) { return tk.type === SliderTickType.Major && tk.position === tick.position; }); })
                    .sort(function (t1, t2) { return t1.value - t2.value; });
            };
        /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
        SliderComponent.prototype.deepMerge =
            function (destination, source) {
                // loop though all of the properties in the source object
                for (var /** @type {?} */ prop in source) {
                    // check if the destination object has the property
                    if (!destination.hasOwnProperty(prop)) {
                        // copy the property across
                        destination[prop] = source[prop];
                        continue;
                    }
                    // if the property exists and is not an object then skip
                    if (typeof destination[prop] !== 'object') {
                        continue;
                    }
                    // check if property is an array
                    if (destination[prop] instanceof Array) {
                        continue;
                    }
                    // if it is an object then perform a recursive check
                    destination[prop] = this.deepMerge(destination[prop], source[prop]);
                }
                return destination;
            };
        /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
        SliderComponent.prototype.detectValueChange =
            function (value1, value2) {
                // compare two slider values
                if (this.isSliderValue(value1) && this.isSliderValue(value2)) {
                    // references to the objects in the correct types
                    var /** @type {?} */ obj1 = (value1);
                    var /** @type {?} */ obj2 = (value2);
                    return obj1.low !== obj2.low || obj1.high !== obj2.high;
                }
                // if not a slider value - should be number of nullable type - compare normally
                return value1 !== value2;
            };
        /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
        SliderComponent.prototype.isSliderValue =
            function (value) {
                // check if is an object
                if (typeof value !== 'object') {
                    return false;
                }
                // next check if it contains the necessary properties
                return 'low' in value && 'high' in value;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.clone =
            function (value) {
                // if it is not an object simply return the value
                if (typeof value !== 'object') {
                    return value;
                }
                // create a new object from the existing one
                var /** @type {?} */ instance = __assign({}, value);
                // delete remove the value from the old object
                value = undefined;
                // return the new instance of the object
                return instance;
            };
        SliderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-slider',
                        template: "<div class=\"track\" #track [class.narrow]=\"options.track.height === sliderSize.Narrow\" [class.wide]=\"options.track.height === sliderSize.Wide\" [class.range]=\"options.type === sliderType.Range\">\n\n    <!-- Section Beneath Lower Thumb -->\n    <div class=\"track-section track-lower\" [style.flex-grow]=\"tracks.lower.size\" [style.background]=\"tracks.lower.color\"></div>\n\n    <!-- Lower Thumb Button / Line -->\n    <div class=\"thumb lower\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #lowerthumb\n        [attr.aria-label]=\"options.type === sliderType.Range ? options.handles.aria.lowerThumb : options.handles.aria.thumb\"\n        [attr.aria-valuemin]=\"options?.track?.min\"\n        [attr.aria-valuemax]=\"options.type === sliderType.Range ? getThumbValue(sliderThumb.Upper) : options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Lower)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Lower)\"\n        [style.left.%]=\"thumbs.lower.position\"\n        [class.active]=\"thumbs.lower.drag\"\n        [style.z-index]=\"thumbs.lower.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (dragstart)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragStart); lowerthumb.focus()\"\n        (drag)=\"updateThumbPosition($event, sliderThumb.Lower)\"\n        (dragend)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Lower, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Lower, true); $event.preventDefault()\">\n\n        <!-- Lower Thumb Callout -->\n        <div class=\"tooltip top tooltip-lower\" #lowerTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.lower.drag === false\"\n            [style.opacity]=\"tooltips.lower.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.lower.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.lower.label }}\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Section of Track Between Lower and Upper Thumbs -->\n    <div class=\"track-section track-range\" *ngIf=\"options.type === sliderType.Range\" [style.flex-grow]=\"tracks.middle.size\" [style.background]=\"tracks.middle.color\">\n    </div>\n\n    <!-- Upper Thumb Button / Line -->\n    <div class=\"thumb upper\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #upperthumb\n        [attr.aria-label]=\"options.handles.aria.upperThumb\"\n        [attr.aria-valuemin]=\"getThumbValue(sliderThumb.Lower) || options?.track?.min\"\n        [attr.aria-valuemax]=\"options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Upper)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Upper)\"\n        [hidden]=\"options.type !== sliderType.Range\"\n        [class.active]=\"thumbs.upper.drag\"\n        [style.left.%]=\"thumbs.upper.position\"\n        [style.z-index]=\"thumbs.upper.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (dragstart)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragStart); upperthumb.focus()\"\n        (drag)=\"updateThumbPosition($event, sliderThumb.Upper)\"\n        (dragend)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Upper, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Upper, true); $event.preventDefault()\">\n\n        <!-- Upper Thumb Callout -->\n        <div class=\"tooltip top tooltip-upper\" #upperTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.upper.drag === false\"\n            [style.opacity]=\"tooltips.upper.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.upper.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                *ngIf=\"options.type === sliderType.Range\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.upper.label }}\n            </div>\n        </div>\n    </div>\n\n    <!-- Section of Track Abover Upper Thumb -->\n    <div class=\"track-section track-higher\" [style.flex-grow]=\"tracks.upper.size\" [style.background]=\"tracks.upper.color\"></div>\n\n</div>\n\n<!-- Chart Ticks and Tick Labels -->\n<div class=\"tick-container\"\n    role=\"presentation\"\n    *ngIf=\"(options.track.ticks.major.show || options.track.ticks.minor.show) && options.handles.callout.trigger !== sliderCalloutTrigger.Dynamic\"\n    [class.show-labels]=\"options.track.ticks.major.labels || options.track.ticks.minor.labels\">\n\n    <div class=\"tick\"\n        *ngFor=\"let tick of ticks\"\n        [class.major]=\"tick.type === sliderTickType.Major\"\n        [class.minor]=\"tick.type === sliderTickType.Minor\"\n        [style.left.%]=\"tick.position\"\n        [hidden]=\"!tick.showTicks\">\n\n        <div class=\"tick-indicator\"></div>\n        <div class=\"tick-label\" aria-hidden=\"true\" [hidden]=\"!tick.showLabels\">{{ tick.label }}</div>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        SliderComponent.ctorParameters = function () {
            return [
                { type: ColorService, },
                { type: core.ChangeDetectorRef, },
            ];
        };
        SliderComponent.propDecorators = {
            "value": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "lowerTooltip": [{ type: core.ViewChild, args: ['lowerTooltip',] },],
            "upperTooltip": [{ type: core.ViewChild, args: ['upperTooltip',] },],
            "track": [{ type: core.ViewChild, args: ['track',] },],
        };
        return SliderComponent;
    }());
    /** @enum {number} */
    var SliderType = {
        Value: 0,
        Range: 1,
    };
    SliderType[SliderType.Value] = "Value";
    SliderType[SliderType.Range] = "Range";
    /** @enum {number} */
    var SliderStyle = {
        Button: 0,
        Line: 1,
    };
    SliderStyle[SliderStyle.Button] = "Button";
    SliderStyle[SliderStyle.Line] = "Line";
    /** @enum {number} */
    var SliderSize = {
        Narrow: 0,
        Wide: 1,
    };
    SliderSize[SliderSize.Narrow] = "Narrow";
    SliderSize[SliderSize.Wide] = "Wide";
    /** @enum {number} */
    var SliderCalloutTrigger = {
        None: 0,
        Hover: 1,
        Drag: 2,
        Persistent: 3,
        Dynamic: 4,
    };
    SliderCalloutTrigger[SliderCalloutTrigger.None] = "None";
    SliderCalloutTrigger[SliderCalloutTrigger.Hover] = "Hover";
    SliderCalloutTrigger[SliderCalloutTrigger.Drag] = "Drag";
    SliderCalloutTrigger[SliderCalloutTrigger.Persistent] = "Persistent";
    SliderCalloutTrigger[SliderCalloutTrigger.Dynamic] = "Dynamic";
    /** @enum {number} */
    var SliderSnap = {
        None: 0,
        Minor: 1,
        Major: 2,
        All: 3,
    };
    SliderSnap[SliderSnap.None] = "None";
    SliderSnap[SliderSnap.Minor] = "Minor";
    SliderSnap[SliderSnap.Major] = "Major";
    SliderSnap[SliderSnap.All] = "All";
    /** @enum {number} */
    var SliderTickType = {
        Minor: 0,
        Major: 1,
    };
    SliderTickType[SliderTickType.Minor] = "Minor";
    SliderTickType[SliderTickType.Major] = "Major";
    /** @enum {number} */
    var SliderThumbEvent = {
        None: 0,
        MouseOver: 1,
        MouseLeave: 2,
        DragStart: 3,
        DragEnd: 4,
    };
    SliderThumbEvent[SliderThumbEvent.None] = "None";
    SliderThumbEvent[SliderThumbEvent.MouseOver] = "MouseOver";
    SliderThumbEvent[SliderThumbEvent.MouseLeave] = "MouseLeave";
    SliderThumbEvent[SliderThumbEvent.DragStart] = "DragStart";
    SliderThumbEvent[SliderThumbEvent.DragEnd] = "DragEnd";
    /** @enum {number} */
    var SliderThumb = {
        Lower: 0,
        Upper: 1,
    };
    SliderThumb[SliderThumb.Lower] = "Lower";
    SliderThumb[SliderThumb.Upper] = "Upper";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderModule = (function () {
        function SliderModule() {
        }
        SliderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            DragModule
                        ],
                        exports: [SliderComponent],
                        declarations: [SliderComponent]
                    },] },
        ];
        /** @nocollapse */
        SliderModule.ctorParameters = function () { return []; };
        return SliderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkComponent = (function () {
        function SparkComponent(_colorService) {
            this._colorService = _colorService;
            this.values = [];
            this.barHeight = 10;
            this._theme = 'primary';
            this._barColor = [];
        }
        Object.defineProperty(SparkComponent.prototype, "theme", {
            get: /**
             * @return {?}
             */ function () {
                return this._theme;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._theme = this._colorService.resolveColorName(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "trackColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._trackColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._trackColor = this._colorService.resolve(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "barColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._barColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (Array.isArray(value)) {
                    this._barColor = value.map(function (color) { return _this._colorService.resolve(color); });
                }
                else {
                    this._barColor = [this._colorService.resolve(value)];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.values;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // ensure 'value' is an array at this point
                var /** @type {?} */ values = Array.isArray(value) ? value : [value];
                // get the total value of all lines
                var /** @type {?} */ total = Math.max(values.reduce(function (previous, current) { return previous + current; }, 0), 100);
                // figure out the percentages for each spark line
                this.values = values.map(function (val) { return (val / total) * 100; });
            },
            enumerable: true,
            configurable: true
        });
        SparkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spark',
                        template: "<!-- Inline Spark Chart -->\n<div *ngIf=\"inlineLabel\" class=\"ux-spark-inline-label-container\">\n\n    <div class=\"ux-spark-inline-label-left\" [innerHtml]=\"inlineLabel\"></div>\n\n    <div class=\"ux-spark-line\">\n\n        <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n            <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n            <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n        </div>\n\n        <div class=\"ux-spark ux-inline ux-spark-theme-{{theme}}\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\" [uxTooltip]=\"tooltip\">\n            <div class=\"ux-spark-bar\" *ngFor=\"let line of values; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n        </div>\n\n        <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n            <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n            <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n        </div>\n\n    </div>\n</div>\n\n<!-- End Inline Spark Chart -->\n\n\n<!-- Non Inline Spark Chart -->\n<div *ngIf=\"!inlineLabel\">\n\n    <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n        <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n        <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n    </div>\n\n    <div class=\"ux-spark ux-spark-theme-{{theme}}\" [class.ux-spark-multi-value]=\"values.length > 1\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\"\n        [uxTooltip]=\"tooltip\">\n        <div class=\"ux-spark-bar\" *ngFor=\"let line of value; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n    </div>\n\n    <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n        <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n        <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n    </div>\n</div>\n\n<!-- End Non Inline Spark Chart -->",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        SparkComponent.ctorParameters = function () {
            return [
                { type: ColorService, },
            ];
        };
        SparkComponent.propDecorators = {
            "barHeight": [{ type: core.Input },],
            "inlineLabel": [{ type: core.Input },],
            "topLeftLabel": [{ type: core.Input },],
            "topRightLabel": [{ type: core.Input },],
            "bottomLeftLabel": [{ type: core.Input },],
            "bottomRightLabel": [{ type: core.Input },],
            "tooltip": [{ type: core.Input },],
            "theme": [{ type: core.Input },],
            "trackColor": [{ type: core.Input },],
            "barColor": [{ type: core.Input },],
            "value": [{ type: core.Input },],
        };
        return SparkComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkModule = (function () {
        function SparkModule() {
        }
        SparkModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            TooltipModule
                        ],
                        exports: [SparkComponent],
                        declarations: [SparkComponent]
                    },] },
        ];
        /** @nocollapse */
        SparkModule.ctorParameters = function () { return []; };
        return SparkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetService = (function () {
        function TabsetService() {
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.focused$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
        }
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.add =
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
                // check if this is the only tab. If so select this by default
                if (!this.active$.value) {
                    this.select(tab);
                }
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.remove =
            function (tab) {
                // remove the tab
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.select =
            function (tab) {
                if (!tab.disabled) {
                    this.active$.next(tab);
                    this.highlighted$.next(tab);
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        TabsetService.prototype.selectAtIndex =
            function (index) {
                // if there are no tabs then do nothing
                if (this.tabs$.value.length === 0) {
                    return;
                }
                // check if the index is within the bounds
                if (index < 0) {
                    return this.selectAtIndex(this.tabs$.value.length - 1);
                }
                else if (index >= this.tabs$.value.length) {
                    return this.selectAtIndex(0);
                }
                var /** @type {?} */ target = this.tabs$.value[index];
                if (target) {
                    this.select(target);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectNextTab =
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs after the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(index + 1);
                try {
                    // check if any of the tabs are not disabled
                    for (var tabs_1 = __values(tabs), tabs_1_1 = tabs_1.next(); !tabs_1_1.done; tabs_1_1 = tabs_1.next()) {
                        var tab = tabs_1_1.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (tabs_1_1 && !tabs_1_1.done && (_a = tabs_1.return))
                            _a.call(tabs_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // if we reach here then no tab could be selected - select the first tab
                this.selectFirstTab();
                var e_1, _a;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectPreviousTab =
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs before the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(0, index);
                try {
                    // check if any of the tabs are not disabled
                    for (var _a = __values(tabs.reverse()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var tab = _b.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                // if we reach here then no previous tab could be selected - select the last tab
                this.selectLastTab();
                var e_2, _c;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectFirstTab =
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex(tabIndex);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectLastTab =
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.slice().reverse().findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex((this.tabs$.value.length - 1) - tabIndex);
                }
            };
        TabsetService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TabsetService.ctorParameters = function () { return []; };
        return TabsetService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabFocusDirective = (function () {
        function TabFocusDirective(_tabset, _elementRef) {
            this._tabset = _tabset;
            this._elementRef = _elementRef;
        }
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this._tabset.highlighted$.pipe(operators.filter(function () { return _this._tabset.focused$.value === true; }), operators.filter(function () { return _this._tabset.highlighted$.value === _this.uxTabFocus; })).subscribe(function () { return _this._elementRef.nativeElement.focus(); });
            };
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        TabFocusDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabFocus]'
                    },] },
        ];
        /** @nocollapse */
        TabFocusDirective.ctorParameters = function () {
            return [
                { type: TabsetService, },
                { type: core.ElementRef, },
            ];
        };
        TabFocusDirective.propDecorators = {
            "uxTabFocus": [{ type: core.Input },],
        };
        return TabFocusDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTabId = 0;
    var TabComponent = (function () {
        function TabComponent(_tabset) {
            var _this = this;
            this._tabset = _tabset;
            this.id = "ux-tab-" + ++uniqueTabId;
            this.disabled = false;
            this.select = new core.EventEmitter();
            this.deselect = new core.EventEmitter();
            this.active$ = this._tabset.active$.pipe(operators.map(function (active) { return active === _this; }));
            _tabset.add(this);
            this._subscription = this.active$.subscribe(function (active) { return active ? _this.select.emit() : _this.deselect.emit(); });
        }
        Object.defineProperty(TabComponent.prototype, "active", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._tabset.select(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabComponent.prototype.ngOnDestroy =
            function () {
                this._tabset.remove(this);
                this._subscription.unsubscribe();
            };
        TabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tab',
                        template: "<div role=\"tabpanel\"\n     class=\"tab-pane\"\n     [class.active]=\"active$ | async\"\n     [id]=\"id + '-panel'\"\n     [attr.aria-labelledby]=\"id\"\n     [attr.aria-hidden]=\"!(active$ | async)\">\n  <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        TabComponent.ctorParameters = function () {
            return [
                { type: TabsetService, },
            ];
        };
        TabComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "heading": [{ type: core.Input },],
            "customClass": [{ type: core.Input },],
            "select": [{ type: core.Output },],
            "deselect": [{ type: core.Output },],
            "active": [{ type: core.Input },],
        };
        return TabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabHeadingDirective = (function () {
        function TabHeadingDirective(templateRef, tab) {
            tab.headingRef = templateRef;
        }
        TabHeadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabHeading]'
                    },] },
        ];
        /** @nocollapse */
        TabHeadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef, },
                { type: TabComponent, },
            ];
        };
        return TabHeadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetComponent = (function () {
        function TabsetComponent(tabset) {
            this.tabset = tabset;
            this.minimal = true;
            this.stacked = 'none';
        }
        /**
         * Allow manual tab selected
         */
        /**
         * Allow manual tab selected
         * @param {?} tab
         * @return {?}
         */
        TabsetComponent.prototype.select =
            function (tab) {
                this.tabset.select(tab);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectPreviousTab =
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowLeft = event.key === 'ArrowLeft' || event.keyCode === 37;
                var /** @type {?} */ arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
                // only perform action if the arrow key matches the orientation
                if (arrowLeft && this.stacked !== 'none' || arrowUp && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectPreviousTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectNextTab =
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowRight = event.key === 'ArrowRight' || event.keyCode === 39;
                var /** @type {?} */ arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
                // only perform action if the arrow key matches the orientation
                if (arrowRight && this.stacked !== 'none' || arrowDown && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectNextTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        TabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tabset',
                        template: "<!-- Nav tabs -->\n<ul role=\"tablist\"\n    class=\"nav nav-tabs\"\n    [class.minimal-tab]=\"minimal\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-orientation]=\"stacked === 'none' ? 'horizontal' : 'vertical'\">\n\n\t<li role=\"presentation\" \n        class=\"nav-item\"\n        *ngFor=\"let tab of tabset.tabs$ | async; let index = index\"\n        [class.active]=\"tab.active$ | async\"\n        [class.disabled]=\"tab.disabled\"\n        [ngClass]=\"tab.customClass\">\n\n        <a class=\"nav-link\"\n            [id]=\"tab.id\"\n            role=\"tab\"\n            [uxTabFocus]=\"tab\"\n            [tabindex]=\"(tab.active$ | async) ? 0 : -1\"\n            [class.highlighted]=\"(tabset.focused$ | async) && (tabset.highlighted$ | async) === tab\"            \n            (mousedown)=\"tabset.select(tab)\"\n            (focus)=\"tabset.focused$.next(true)\"\n            (blur)=\"tabset.focused$.next(false)\"\n            (mousedown)=\"tabset.focused$.next(true)\"\n            (keydown.ArrowUp)=\"selectPreviousTab($event)\"\n            (keydown.ArrowLeft)=\"selectPreviousTab($event)\"\n            (keydown.ArrowRight)=\"selectNextTab($event)\"\n            (keydown.ArrowDown)=\"selectNextTab($event)\"\n            (keydown.Home)=\"tabset.selectFirstTab(); $event.preventDefault()\"\n            (keydown.End)=\"tabset.selectLastTab(); $event.preventDefault()\"\n            [attr.aria-controls]=\"tab.id\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            [attr.aria-disabled]=\"tab.disabled\">\n\n            <span *ngIf=\"!tab.headingRef\">{{ tab.heading }}</span>\n\n            <ng-container *ngIf=\"tab.headingRef\" [ngTemplateOutlet]=\"tab.headingRef\"></ng-container>\n        </a>\n\n\t</li>\n\n</ul>\n\n<!-- Tab panes -->\n<div class=\"tab-content\">\n\t<ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TabsetService],
                        host: {
                            '[class.tabs-left]': 'stacked === "left"',
                            '[class.tabs-right]': 'stacked === "right"',
                        }
                    },] },
        ];
        /** @nocollapse */
        TabsetComponent.ctorParameters = function () {
            return [
                { type: TabsetService, },
            ];
        };
        TabsetComponent.propDecorators = {
            "minimal": [{ type: core.Input },],
            "stacked": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
        };
        return TabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetModule = (function () {
        function TabsetModule() {
        }
        TabsetModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [TabsetComponent, TabComponent, TabHeadingDirective],
                        declarations: [TabsetComponent, TabComponent, TabHeadingDirective, TabFocusDirective],
                    },] },
        ];
        /** @nocollapse */
        TabsetModule.ctorParameters = function () { return []; };
        return TabsetModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineComponent = (function () {
        function TimelineComponent() {
        }
        TimelineComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline',
                        template: "<div class=\"timeline\">\n    <ng-content></ng-content>\n</div>\n"
                    },] },
        ];
        /** @nocollapse */
        TimelineComponent.ctorParameters = function () { return []; };
        return TimelineComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineEventComponent = (function () {
        function TimelineEventComponent() {
        }
        TimelineEventComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline-event',
                        template: "<div class=\"timeline-badge\" [ngClass]=\"badgeColor\">\n    <span>{{badgeTitle}}</span>\n</div>\n<div class=\"timeline-panel\">\n    <ng-content></ng-content>\n</div>\n"
                    },] },
        ];
        /** @nocollapse */
        TimelineEventComponent.ctorParameters = function () { return []; };
        TimelineEventComponent.propDecorators = {
            "badgeColor": [{ type: core.Input },],
            "badgeTitle": [{ type: core.Input },],
        };
        return TimelineEventComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineModule = (function () {
        function TimelineModule() {
        }
        TimelineModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            TimelineComponent,
                            TimelineEventComponent
                        ],
                        declarations: [
                            TimelineComponent,
                            TimelineEventComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        TimelineModule.ctorParameters = function () { return []; };
        return TimelineModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TOGGLESWITCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ToggleSwitchComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueToggleSwitchId = 0;
    var ToggleSwitchComponent = (function () {
        function ToggleSwitchComponent() {
            this._toggleSwitchId = "ux-toggleswitch-" + ++uniqueToggleSwitchId;
            this.id = this._toggleSwitchId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(ToggleSwitchComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // Update value output
                this.valueChange.emit(value);
                // Notify ngModel
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToggleSwitchComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._toggleSwitchId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToggleSwitchComponent.prototype.toggle =
            function () {
                if (!this.disabled && this.clickable) {
                    this.value = !this.value;
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ToggleSwitchComponent.prototype.writeValue =
            function (value) {
                this.value = !!value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        ToggleSwitchComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        ToggleSwitchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toggleswitch',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-toggleswitch\"\n       [class.ux-toggleswitch-checked]=\"value\"\n       [class.ux-toggleswitch-disabled]=\"disabled\"\n       [class.ux-toggleswitch-focused]=\"focused\">\n\n    <input class=\"ux-toggleswitch-input\"\n           type=\"checkbox\"\n           role=\"switch\"\n           [id]=\"inputId\"\n           [checked]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"value\"\n           (focus)=\"focused = true\"\n           (blur)=\"focused = false\"\n           (change)=\"toggle()\"\n           (click)=\"$event.stopPropagation()\">\n\n    <div class=\"ux-toggleswitch-container\">\n        <div class=\"ux-toggleswitch-bg\"></div>\n        <div class=\"ux-toggleswitch-nub\"></div>\n    </div>\n\n    <span class=\"ux-toggleswitch-label\">\n        <ng-content></ng-content>\n    </span>\n</label>",
                        providers: [TOGGLESWITCH_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        ToggleSwitchComponent.ctorParameters = function () { return []; };
        ToggleSwitchComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "name": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "clickable": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
            "ariaLabelledby": [{ type: core.Input, args: ['aria-labelledby',] },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input },],
        };
        return ToggleSwitchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToggleSwitchModule = (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [ToggleSwitchComponent],
                        declarations: [ToggleSwitchComponent]
                    },] },
        ];
        /** @nocollapse */
        ToggleSwitchModule.ctorParameters = function () { return []; };
        return ToggleSwitchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchButtonDirective = (function () {
        function ToolbarSearchButtonDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.clicked = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchButtonDirective.prototype, "width", {
            get: /**
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.offsetWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchButtonDirective.prototype.clickHandler =
            function () {
                this.clicked.emit();
            };
        ToolbarSearchButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchButton]'
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ToolbarSearchButtonDirective.propDecorators = {
            "clicked": [{ type: core.Output },],
            "clickHandler": [{ type: core.HostListener, args: ['click',] },],
        };
        return ToolbarSearchButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ KEYS = {
        ENTER: 13,
        ESCAPE: 27
    };
    var ToolbarSearchFieldDirective = (function () {
        function ToolbarSearchFieldDirective(_elementRef, _ngModel) {
            this._elementRef = _elementRef;
            this._ngModel = _ngModel;
            this.cancel = new core.EventEmitter();
            this.submit = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchFieldDirective.prototype, "text", {
            get: /**
             * @return {?}
             */ function () {
                // Use ngModel if specified on the host; otherwise read the DOM
                if (this._ngModel) {
                    return this._ngModel.value;
                }
                return this._elementRef.nativeElement.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.focus =
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.focus();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.blur =
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.blur();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.clear =
            function () {
                // Use ngModel if specified on the host; otherwise use the DOM
                if (this._ngModel) {
                    this._ngModel.reset();
                }
                else {
                    this._elementRef.nativeElement.value = '';
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.keydownHandler =
            function (event) {
                var _this = this;
                setTimeout(function () {
                    if (event.keyCode === KEYS.ENTER) {
                        _this.submit.emit(_this.text);
                    }
                    else if (event.keyCode === KEYS.ESCAPE) {
                        _this._elementRef.nativeElement.blur();
                        _this.cancel.emit();
                    }
                });
            };
        ToolbarSearchFieldDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchField]'
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchFieldDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: forms.NgModel, decorators: [{ type: core.Optional },] },
            ];
        };
        ToolbarSearchFieldDirective.propDecorators = {
            "cancel": [{ type: core.Output },],
            "submit": [{ type: core.Output },],
            "keydownHandler": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
        };
        return ToolbarSearchFieldDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchComponent = (function () {
        function ToolbarSearchComponent(_elementRef, _colorService, _document) {
            this._elementRef = _elementRef;
            this._colorService = _colorService;
            this._document = _document;
            this.direction = 'right';
            this.inverse = false;
            this.expandedChange = new core.EventEmitter();
            this.search = new core.EventEmitter();
            this._expanded = false;
            this.position = 'relative';
            this.backgroundColor = 'transparent';
        }
        Object.defineProperty(ToolbarSearchComponent.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._expanded = value;
                this.expandedChange.emit(value);
                if (value) {
                    // Set focus on the input when expanded
                    this.field.focus();
                }
                else {
                    // Clear text when contracted
                    this.field.clear();
                    // Remove focus (works around an IE issue where the caret remains visible)
                    this.field.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "background", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.backgroundColor = this._colorService.resolve(value) || 'transparent';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "expandedAnimation", {
            get: /**
             * @return {?}
             */ function () {
                return {
                    value: this.expanded ? 'expanded' : 'collapsed',
                    params: {
                        initialWidth: this.button.width + 'px'
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // Subscribe to the submit event on the input field, triggering the search event
                this.field.submit.subscribe(function (text) { return _this.search.emit(text); });
                // Subscribe to cancel events coming from the input field
                this.field.cancel.subscribe(function () { return _this.expanded = false; });
                // Subscribe to the button click event
                this.button.clicked.subscribe(function () {
                    if (_this.expanded && _this.field.text) {
                        _this.search.emit(_this.field.text);
                    }
                    else {
                        _this.expanded = !_this.expanded;
                    }
                });
                // Create placeholder element to avoid changing layout when switching to position: absolute
                this.createPlaceholder();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationStart =
            function (event) {
                if (event.toState === 'expanded') {
                    this.position = 'absolute';
                    this.enablePlaceholder(true);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationDone =
            function (event) {
                if (event.toState === 'collapsed') {
                    this.position = 'relative';
                    this.enablePlaceholder(false);
                }
            };
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.createPlaceholder =
            function () {
                // Get width and height of the component
                var /** @type {?} */ styles = getComputedStyle(this._elementRef.nativeElement);
                // Create invisible div with the same dimensions
                this._placeholder = this._document.createElement('div');
                this._placeholder.style.display = 'none';
                this._placeholder.style.width = this.button.width + 'px';
                this._placeholder.style.height = styles.height;
                this._placeholder.style.visibility = 'hidden';
                // Add as a sibling
                this._elementRef.nativeElement.parentNode.insertBefore(this._placeholder, this._elementRef.nativeElement);
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        ToolbarSearchComponent.prototype.enablePlaceholder =
            function (enabled) {
                this._placeholder.style.display = (enabled ? 'inline-block' : 'none');
            };
        ToolbarSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toolbar-search',
                        template: "<ng-content></ng-content>",
                        animations: [
                            animations.trigger('expanded', [
                                animations.state('collapsed', animations.style({
                                    width: '{{initialWidth}}'
                                }), {
                                    params: { initialWidth: '30px' }
                                }),
                                animations.state('expanded', animations.style({
                                    width: '100%'
                                })),
                                animations.transition('collapsed <=> expanded', [animations.animate('0.3s ease-out')])
                            ])
                        ]
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ColorService, },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
            ];
        };
        ToolbarSearchComponent.propDecorators = {
            "expanded": [{ type: core.HostBinding, args: ['class.expanded',] }, { type: core.Input },],
            "direction": [{ type: core.Input }, { type: core.HostBinding, args: ['class',] },],
            "inverse": [{ type: core.Input }, { type: core.HostBinding, args: ['class.inverse',] },],
            "background": [{ type: core.Input },],
            "expandedChange": [{ type: core.Output },],
            "search": [{ type: core.Output },],
            "expandedAnimation": [{ type: core.HostBinding, args: ['@expanded',] },],
            "position": [{ type: core.HostBinding, args: ['style.position',] },],
            "backgroundColor": [{ type: core.HostBinding, args: ['style.background-color',] },],
            "field": [{ type: core.ContentChild, args: [ToolbarSearchFieldDirective,] },],
            "button": [{ type: core.ContentChild, args: [ToolbarSearchButtonDirective,] },],
            "animationStart": [{ type: core.HostListener, args: ['@expanded.start', ['$event'],] },],
            "animationDone": [{ type: core.HostListener, args: ['@expanded.done', ['$event'],] },],
        };
        return ToolbarSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$6 = [
        ToolbarSearchComponent,
        ToolbarSearchFieldDirective,
        ToolbarSearchButtonDirective
    ];
    var ToolbarSearchModule = (function () {
        function ToolbarSearchModule() {
        }
        ToolbarSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$6,
                        declarations: DECLARATIONS$6,
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchModule.ctorParameters = function () { return []; };
        return ToolbarSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadingDirective = (function () {
        function VirtualScrollLoadingDirective() {
        }
        VirtualScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoading]'
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollLoadingDirective.ctorParameters = function () { return []; };
        return VirtualScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadButtonDirective = (function () {
        function VirtualScrollLoadButtonDirective() {
        }
        VirtualScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoadButton]'
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollLoadButtonDirective.ctorParameters = function () { return []; };
        return VirtualScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollCellDirective = (function () {
        function VirtualScrollCellDirective() {
        }
        VirtualScrollCellDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollCell]'
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollCellDirective.ctorParameters = function () { return []; };
        return VirtualScrollCellDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollComponent = (function () {
        function VirtualScrollComponent(_elementRef, resizeService) {
            var _this = this;
            this._elementRef = _elementRef;
            this.collection = Observable.Observable.create();
            this.loadOnScroll = true;
            this.loading = new core.EventEmitter();
            this.cells = new BehaviorSubject.BehaviorSubject([]);
            this.scrollTop = 0;
            this.isLoading = false;
            this.pageNumber = 0;
            this.data = [];
            this.loadingComplete = false;
            // watch for any future changes to size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) { return _this._height = event.height; });
        }
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnInit =
            function () {
                if (!this.cellHeight) {
                    throw new Error('Virtual Scroll Component requires "cellHeight" property to be defined.');
                }
                // subscribe to the collection
                this.setupObservable();
                // load the first page of data
                this.loadNextPage();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngAfterContentInit =
            function () {
                // re-render cells now that we can display any loading indicator or loading button
                this.renderCells();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnChanges =
            function (changes) {
                if (changes["collection"] && changes["collection"].currentValue !== changes["collection"].previousValue && !changes["collection"].isFirstChange()) {
                    this.setupObservable();
                    this.reset();
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.setupObservable =
            function () {
                var _this = this;
                // if there is a current subscription, unsubscribe
                if (this._subscription && this._subscription.unsubscribe) {
                    this._subscription.unsubscribe();
                }
                this._subscription = this.collection.subscribe(function (collection) {
                    (_a = _this.data).push.apply(_a, __spread(collection));
                    _this.renderCells();
                    _this.isLoading = false;
                    var _a;
                }, null, function () {
                    _this.loadingComplete = true;
                });
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.renderCells =
            function () {
                this.cells.next(this.getVisibleCells());
                if (this.loadOnScroll && !this.isLoading && !this.loadingComplete) {
                    var /** @type {?} */ remainingScroll = this._elementRef.nativeElement.scrollHeight - (this._elementRef.nativeElement.scrollTop + this._elementRef.nativeElement.clientHeight);
                    // if the current cells take up less than the height of the component then load the next page
                    if (remainingScroll <= this._elementRef.nativeElement.clientHeight) {
                        this.loadNextPage();
                    }
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getVisibleCells =
            function () {
                // store the initial element height
                if (!this._height) {
                    this._height = this._elementRef.nativeElement.offsetHeight;
                }
                // perform some calculations
                var /** @type {?} */ scrollTop = this._elementRef.nativeElement.scrollTop;
                var /** @type {?} */ startCell = Math.floor(scrollTop / this.cellHeight);
                var /** @type {?} */ endCell = Math.ceil(this._height / this.cellHeight) + 1;
                // update the scroll position
                this.scrollTop = scrollTop - (scrollTop % this.cellHeight);
                // return a sublist of items visible on the screen
                return this.data.slice(startCell, startCell + endCell);
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getTotalHeight =
            function () {
                return this.cellHeight * this.data.length;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.loadNextPage =
            function () {
                this.isLoading = true;
                this.loading.next(this.pageNumber);
                this.pageNumber++;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.reset =
            function () {
                // reset all values
                this.scrollTop = 0;
                this.data = [];
                this._height = undefined;
                this.pageNumber = 0;
                this.loadingComplete = false;
                // set scroll position
                this._elementRef.nativeElement.scrollTop = 0;
                // clear the current cells
                this.renderCells();
                // reload first page
                this.loadNextPage();
            };
        VirtualScrollComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-virtual-scroll',
                        template: "<div class=\"virtual-scroll-content-height\" [style.height.px]=\"getTotalHeight()\"></div>\n<div class=\"virtual-scroll-content\" [style.transform]=\"'translateY(' + scrollTop + 'px)'\">\n\n    <!-- Virtually Render Cells -->\n    <ng-container *ngFor=\"let cell of cells | async\">\n        <ng-container *ngTemplateOutlet=\"cellTemplate; context: { cell: cell }\"></ng-container>\n    </ng-container>\n\n    <!-- Loading Indicator -->\n    <ng-container *ngIf=\"loadingIndicatorTemplate && isLoading\" [ngTemplateOutlet]=\"loadingIndicatorTemplate\"></ng-container>\n\n    <!-- Loading Button -->\n    <div class=\"virtual-scroll-load-button\" *ngIf=\"loadButtonTemplate && !loadOnScroll && !loadingComplete && !isLoading\" (click)=\"loadNextPage()\">\n        <ng-container *ngTemplateOutlet=\"loadButtonTemplate\"></ng-container>\n    </div>\n    \n</div>"
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
            ];
        };
        VirtualScrollComponent.propDecorators = {
            "collection": [{ type: core.Input },],
            "cellHeight": [{ type: core.Input },],
            "loadOnScroll": [{ type: core.Input },],
            "loading": [{ type: core.Output },],
            "cellTemplate": [{ type: core.ContentChild, args: [VirtualScrollCellDirective, { read: core.TemplateRef },] },],
            "loadingIndicatorTemplate": [{ type: core.ContentChild, args: [VirtualScrollLoadingDirective, { read: core.TemplateRef },] },],
            "loadButtonTemplate": [{ type: core.ContentChild, args: [VirtualScrollLoadButtonDirective, { read: core.TemplateRef },] },],
            "renderCells": [{ type: core.HostListener, args: ['scroll',] },],
        };
        return VirtualScrollComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$7 = [
        VirtualScrollComponent,
        VirtualScrollLoadingDirective,
        VirtualScrollLoadButtonDirective,
        VirtualScrollCellDirective
    ];
    var VirtualScrollModule = (function () {
        function VirtualScrollModule() {
        }
        VirtualScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        exports: DECLARATIONS$7,
                        declarations: DECLARATIONS$7
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollModule.ctorParameters = function () { return []; };
        return VirtualScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowDirective = (function () {
        function AutoGrowDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            // ensure this is a textarea or else throw error
            if (_elementRef.nativeElement.tagName.toLowerCase() !== 'textarea') {
                throw new Error('uxAutoGrow directive can only be used on <textarea> elements.');
            }
        }
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.ngAfterViewInit =
            function () {
                this.update();
            };
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.update =
            function () {
                // perform sizing
                this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'hidden');
                this._renderer.setStyle(this._elementRef.nativeElement, 'height', 'auto');
                // get the new total height and element height
                var scrollHeight = this._elementRef.nativeElement.scrollHeight;
                var maxHeight = getComputedStyle(this._elementRef.nativeElement).maxHeight;
                // determine what the maximum allowed height is
                var /** @type {?} */ maximum = !isNaN(parseFloat(maxHeight)) ? parseFloat(maxHeight) : Infinity;
                // if there is a max height specifed we want to show the scrollbars
                if (maximum < scrollHeight) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'auto');
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', maximum + 'px');
                }
                else {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', scrollHeight + 'px');
                }
            };
        AutoGrowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxAutoGrow]'
                    },] },
        ];
        /** @nocollapse */
        AutoGrowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
            ];
        };
        AutoGrowDirective.propDecorators = {
            "update": [{ type: core.HostListener, args: ['input',] },],
        };
        return AutoGrowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowModule = (function () {
        function AutoGrowModule() {
        }
        AutoGrowModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [AutoGrowDirective],
                        declarations: [AutoGrowDirective]
                    },] },
        ];
        /** @nocollapse */
        AutoGrowModule.ctorParameters = function () { return []; };
        return AutoGrowModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableDirective = (function () {
        function FixedHeaderTableDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.tablePaging = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.ngOnInit =
            function () {
                // add class to the table
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-fixed-header-table');
                // locate the important elements
                this._tableHead = this._elementRef.nativeElement.querySelector('thead');
                this._tableBody = this._elementRef.nativeElement.querySelector('tbody');
                // bind to scroll events on the table body
                this._renderer.listen(this._tableBody, 'scroll', this.onScroll.bind(this));
                // resize the table header to account for scrollbar
                this.setLayout();
                // trigger the loading of the first page
                this.tablePaging.emit();
            };
        /**
         * Get the table element
         * Primarily used by column width directive
         */
        /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.getTable =
            function () {
                return this._elementRef.nativeElement;
            };
        /**
         * Handle scroll events
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.onScroll =
            function () {
                // determine if we are scrolled to the bottom and if so load the next page
                if (this._tableBody.scrollTop === (this._tableBody.scrollHeight - this._tableBody.offsetHeight)) {
                    this.tablePaging.emit();
                }
            };
        /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.setLayout =
            function () {
                // calculate the size of the scrollbar
                var /** @type {?} */ scrollbar = this._tableBody.offsetWidth - this._tableBody.clientWidth;
                // add padding to the header to account for this
                this._renderer.setStyle(this._tableHead, 'padding-right', scrollbar + 'px');
                // set the desired height of the table body
                this._renderer.setStyle(this._tableBody, 'height', typeof this.tableHeight === 'number' ? this.tableHeight + "px" : this.tableHeight);
            };
        FixedHeaderTableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFixedHeaderTable]'
                    },] },
        ];
        /** @nocollapse */
        FixedHeaderTableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
            ];
        };
        FixedHeaderTableDirective.propDecorators = {
            "tableHeight": [{ type: core.Input },],
            "tablePaging": [{ type: core.Output },],
        };
        return FixedHeaderTableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableModule = (function () {
        function FixedHeaderTableModule() {
        }
        FixedHeaderTableModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FixedHeaderTableDirective],
                        declarations: [FixedHeaderTableDirective]
                    },] },
        ];
        /** @nocollapse */
        FixedHeaderTableModule.ctorParameters = function () { return []; };
        return FixedHeaderTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelDirective = (function () {
        function FloatLabelDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.mode = 'focus';
            this.raised = false;
            this._focused = false;
            this._eventHandles = [];
        }
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnInit =
            function () {
                this._eventHandles.push(this._renderer.listen(this.input, 'focus', this.inputFocus.bind(this)), this._renderer.listen(this.input, 'blur', this.inputBlur.bind(this)), this._renderer.listen(this.input, 'input', this.inputChange.bind(this)));
                // Check initial input value
                this.raised = this.hasText();
                // Ensure that the `for` attribute is set
                if (!this._elementRef.nativeElement.getAttribute('for') && this.input.getAttribute('id')) {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'for', this.input.getAttribute('id'));
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnChanges =
            function () {
                if (!(this.mode === 'focus' && this._focused)) {
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnDestroy =
            function () {
                // Unsubscribe event handles
                this._eventHandles.forEach(function (eventHandle) { return eventHandle(); });
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.hasText =
            function () {
                if (this.value === undefined) {
                    return !!this.input.value;
                }
                return !!this.value;
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputFocus =
            function () {
                if (this.mode === 'focus') {
                    this._focused = true;
                    this.raised = true;
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputBlur =
            function () {
                if (this.mode === 'focus') {
                    this._focused = false;
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputChange =
            function () {
                if (this.mode === 'input') {
                    this.raised = this.hasText();
                }
            };
        FloatLabelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFloatLabel]',
                        host: {
                            'class': 'ux-float-label'
                        }
                    },] },
        ];
        /** @nocollapse */
        FloatLabelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
            ];
        };
        FloatLabelDirective.propDecorators = {
            "input": [{ type: core.Input, args: ['uxFloatLabel',] },],
            "value": [{ type: core.Input },],
            "mode": [{ type: core.Input },],
            "raised": [{ type: core.HostBinding, args: ['class.ux-float-label-raised',] },],
        };
        return FloatLabelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelModule = (function () {
        function FloatLabelModule() {
        }
        FloatLabelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [FloatLabelDirective],
                        declarations: [FloatLabelDirective],
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        FloatLabelModule.ctorParameters = function () { return []; };
        return FloatLabelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterService = (function () {
        function HelpCenterService() {
            this.items = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.registerItem =
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // add the new item to the list
                items.push(item);
                // update the observable
                this.items.next(items);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.unregisterItem =
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // remove the item being unregistered
                items = items.filter(function (itm) { return itm !== item; });
                // update the observable
                this.items.next(items);
            };
        HelpCenterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        HelpCenterService.ctorParameters = function () { return []; };
        return HelpCenterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterItemDirective = (function () {
        function HelpCenterItemDirective(_helpCenterService) {
            this._helpCenterService = _helpCenterService;
        }
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnInit =
            function () {
                // register the item in the service
                this._helpCenterService.registerItem(this.uxHelpCenterItem);
            };
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnDestroy =
            function () {
                // remove this item when it is destroyed
                this._helpCenterService.unregisterItem(this.uxHelpCenterItem);
            };
        HelpCenterItemDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[uxHelpCenterItem]' },] },
        ];
        /** @nocollapse */
        HelpCenterItemDirective.ctorParameters = function () {
            return [
                { type: HelpCenterService, },
            ];
        };
        HelpCenterItemDirective.propDecorators = {
            "uxHelpCenterItem": [{ type: core.Input },],
        };
        return HelpCenterItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterModule = (function () {
        function HelpCenterModule() {
        }
        HelpCenterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [HelpCenterItemDirective],
                        declarations: [HelpCenterItemDirective],
                        providers: [HelpCenterService],
                    },] },
        ];
        /** @nocollapse */
        HelpCenterModule.ctorParameters = function () { return []; };
        return HelpCenterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionService = (function () {
        function HoverActionService() {
            this.active = new BehaviorSubject.BehaviorSubject(false);
            this._focused = false;
            this._hovered = false;
            this._actions = [];
        }
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.register =
            function (action) {
                this._actions.push(action);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.unregister =
            function (action) {
                this._actions = this._actions.filter(function (actn) { return actn !== action; });
            };
        /**
         * @param {?} container
         * @return {?}
         */
        HoverActionService.prototype.setContainer =
            function (container) {
                this._container = container;
            };
        /**
         * @param {?} focus
         * @return {?}
         */
        HoverActionService.prototype.setFocusState =
            function (focus) {
                this._focused = focus;
                this.updateVisibility();
            };
        /**
         * @param {?} hover
         * @return {?}
         */
        HoverActionService.prototype.setHoverState =
            function (hover) {
                this._hovered = hover;
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.next =
            function () {
                // if container has focus then focus the first hover action
                if (this.containerHasFocus()) {
                    this.focusActionAtIndex(0);
                    return this.updateVisibility();
                }
                // if a hover action has focus then focus the next action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() + 1;
                    this.focusActionAtIndex(index);
                    this.updateVisibility();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.previous =
            function () {
                // if a hover action has focus then focus the previous action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() - 1;
                    if (index >= 0) {
                        this.focusActionAtIndex(index);
                    }
                    else {
                        this._container.focus();
                    }
                }
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.updateVisibility =
            function () {
                this.active.next(this._focused || this._hovered || this.actionHasFocus());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        HoverActionService.prototype.focusActionAtIndex =
            function (index) {
                if (index >= 0 && index < this._actions.length) {
                    this._actions[index].focus();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedActionIndex =
            function () {
                var _this = this;
                return this._actions.findIndex(function (action) { return action === _this.getFocusedAction(); });
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.containerHasFocus =
            function () {
                return this._focused;
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.actionHasFocus =
            function () {
                return !!this.getFocusedAction();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedAction =
            function () {
                return this._actions.find(function (action) { return action.focused; });
            };
        HoverActionService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        HoverActionService.ctorParameters = function () { return []; };
        return HoverActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionContainerDirective = (function () {
        function HoverActionContainerDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            // register the container element with the service
            this._hoverActionService.setContainer(this);
            // apply a class based on the active state of the container and it's actions
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.ngOnDestroy =
            function () {
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.focus =
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onFocus =
            function () {
                this._hoverActionService.setFocusState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onBlur =
            function () {
                this._hoverActionService.setFocusState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onHover =
            function () {
                this._hoverActionService.setHoverState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onLeave =
            function () {
                this._hoverActionService.setHoverState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.next =
            function () {
                this._hoverActionService.next();
            };
        HoverActionContainerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverActionContainer]',
                        providers: [HoverActionService],
                        host: {
                            '[class.hover-action-container-active]': 'active',
                            '[tabindex]': 'tabindex'
                        }
                    },] },
        ];
        /** @nocollapse */
        HoverActionContainerDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: HoverActionService, },
            ];
        };
        HoverActionContainerDirective.propDecorators = {
            "tabindex": [{ type: core.Input },],
            "focus": [{ type: core.HostListener, args: ['click',] },],
            "onFocus": [{ type: core.HostListener, args: ['focus',] },],
            "onBlur": [{ type: core.HostListener, args: ['blur',] },],
            "onHover": [{ type: core.HostListener, args: ['mouseenter',] },],
            "onLeave": [{ type: core.HostListener, args: ['mouseleave',] },],
            "next": [{ type: core.HostListener, args: ['keydown.arrowright',] },],
        };
        return HoverActionContainerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionDirective = (function () {
        function HoverActionDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 1;
            this.active = false;
            this.focused = false;
            // register the action
            this._hoverActionService.register(this);
            // watch for changes to the activeness of the container
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.ngOnDestroy =
            function () {
                this._hoverActionService.unregister(this);
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.focus =
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onFocus =
            function () {
                this.focused = true;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onBlur =
            function () {
                this.focused = false;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.previous =
            function (event) {
                event.stopPropagation();
                this._hoverActionService.previous();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.next =
            function (event) {
                event.stopPropagation();
                this._hoverActionService.next();
            };
        HoverActionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverAction]',
                        host: {
                            '[class.hover-action-active]': 'active',
                            '[class.hover-action-focused]': 'focused',
                            '[tabindex]': 'tabindex'
                        }
                    },] },
        ];
        /** @nocollapse */
        HoverActionDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: HoverActionService, },
            ];
        };
        HoverActionDirective.propDecorators = {
            "tabindex": [{ type: core.Input },],
            "onFocus": [{ type: core.HostListener, args: ['focus',] },],
            "onBlur": [{ type: core.HostListener, args: ['blur',] },],
            "previous": [{ type: core.HostListener, args: ['keydown.arrowleft', ['$event'],] },],
            "next": [{ type: core.HostListener, args: ['keydown.arrowright', ['$event'],] },],
        };
        return HoverActionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$8 = [
        HoverActionDirective,
        HoverActionContainerDirective
    ];
    var HoverActionModule = (function () {
        function HoverActionModule() {
        }
        HoverActionModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: DECLARATIONS$8,
                        declarations: DECLARATIONS$8
                    },] },
        ];
        /** @nocollapse */
        HoverActionModule.ctorParameters = function () { return []; };
        return HoverActionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherItemDirective = (function () {
        function LayoutSwitcherItemDirective(_templateRef, _viewContainerRef) {
            this._templateRef = _templateRef;
            this._viewContainerRef = _viewContainerRef;
        }
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getLayout =
            function () {
                return this._templateRef;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getConfig =
            function () {
                return this._config;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.activate =
            function () {
                this._embeddedView = this._viewContainerRef.createEmbeddedView(this._templateRef);
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.deactivate =
            function () {
                var /** @type {?} */ index = this._viewContainerRef.indexOf(this._embeddedView);
                this._viewContainerRef.remove(index);
                this._embeddedView = null;
            };
        LayoutSwitcherItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcherItem]'
                    },] },
        ];
        /** @nocollapse */
        LayoutSwitcherItemDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef, },
                { type: core.ViewContainerRef, },
            ];
        };
        LayoutSwitcherItemDirective.propDecorators = {
            "_config": [{ type: core.Input, args: ['uxLayoutSwitcherItem',] },],
        };
        return LayoutSwitcherItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherDirective = (function () {
        function LayoutSwitcherDirective(_elementRef, resizeService, _viewContainerRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            // watch for changes to the container size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) {
                _this._width = event.width;
                // render the appropriate layout
                // render the appropriate layout
                _this.updateActiveLayout();
            });
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngOnChanges =
            function (changes) {
                // if the active group has changed then render the appropriate layout
                if (changes["group"].currentValue !== changes["group"].previousValue) {
                    this.updateActiveLayout();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.getActiveLayout =
            function () {
                var _this = this;
                // if there are currently no layouts then do nothing
                if (!this._layouts) {
                    return null;
                }
                // otherwise find layouts that match the active group and that meet the constraints
                return this._layouts.filter(function (layout) { return _this.group === layout.getConfig().group; }).find(function (layout) {
                    var /** @type {?} */ minWidth = layout.getConfig().minWidth || 0;
                    var /** @type {?} */ maxWidth = layout.getConfig().maxWidth || Infinity;
                    return _this._width >= minWidth && _this._width < maxWidth;
                });
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.updateActiveLayout =
            function () {
                // get the layout that should be shown
                var /** @type {?} */ layout = this.getActiveLayout();
                // check if we are currently showing the layout
                if (this._activeLayout === layout) {
                    return;
                }
                // remove the current layout
                if (this._activeLayout) {
                    this._activeLayout.deactivate();
                }
                // store the new active layout
                this._activeLayout = layout;
                // if there is an active layout then activate
                if (this._activeLayout) {
                    this._activeLayout.activate();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngAfterContentInit =
            function () {
                // store the initial current element width
                this._width = this._elementRef.nativeElement.offsetWidth;
                // render the appropriate layout - need a delay as Angular doesn't like changes like this in these lifecycle hooks
                requestAnimationFrame(this.updateActiveLayout.bind(this));
            };
        LayoutSwitcherDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcher]'
                    },] },
        ];
        /** @nocollapse */
        LayoutSwitcherDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
                { type: core.ViewContainerRef, },
            ];
        };
        LayoutSwitcherDirective.propDecorators = {
            "group": [{ type: core.Input },],
            "_layouts": [{ type: core.ContentChildren, args: [LayoutSwitcherItemDirective,] },],
        };
        return LayoutSwitcherDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$9 = [
        LayoutSwitcherDirective,
        LayoutSwitcherItemDirective
    ];
    var LayoutSwitcherModule = (function () {
        function LayoutSwitcherModule() {
        }
        LayoutSwitcherModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            ResizeModule
                        ],
                        exports: DECLARATIONS$9,
                        declarations: DECLARATIONS$9,
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        LayoutSwitcherModule.ctorParameters = function () { return []; };
        return LayoutSwitcherModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OverflowDirective = (function () {
        function OverflowDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow overflow to be within a range before emitting
             */
            this.tolerance = 0;
            /**
             * Emit when there is a change to the overflow state - horizontal or vertical
             */
            this.uxOverflowObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the horizontal axis
             */
            this.uxOverflowHorizontalObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the vertical axis
             */
            this.uxOverflowVerticalObserver = new core.EventEmitter();
            /**
             * Store the overflow state on both axis
             */
            this._state = { horizontalOverflow: false, verticalOverflow: false };
            /**
             * Unsubscribe from all the observables
             */
            this._onDestroy = new Subject.Subject();
        }
        /** Set up the trigger if specified */
        /**
         * Set up the trigger if specified
         * @return {?}
         */
        OverflowDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                if (this.trigger) {
                    this.trigger.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.checkForOverflow(); });
                }
            };
        /** Perform an intial check for overflow */
        /**
         * Perform an intial check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                requestAnimationFrame(function () { return _this.checkForOverflow(); });
            };
        /** Unsubscribe from the trigger */
        /**
         * Unsubscribe from the trigger
         * @return {?}
         */
        OverflowDirective.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Programmatically trigger check for overflow */
        /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.checkForOverflow =
            function () {
                var _a = this._elementRef.nativeElement, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scrollWidth = _a.scrollWidth, scrollHeight = _a.scrollHeight;
                var /** @type {?} */ horizontalOverflow = (scrollWidth - offsetWidth) > this.tolerance;
                var /** @type {?} */ verticalOverflow = (scrollHeight - offsetHeight) > this.tolerance;
                if (horizontalOverflow !== this._state.horizontalOverflow) {
                    this.uxOverflowHorizontalObserver.emit(horizontalOverflow);
                }
                if (verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowVerticalObserver.emit(verticalOverflow);
                }
                if (horizontalOverflow !== this._state.horizontalOverflow || verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowObserver.emit((horizontalOverflow || verticalOverflow));
                }
                // store the state
                this._state = { horizontalOverflow: horizontalOverflow, verticalOverflow: verticalOverflow };
            };
        OverflowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxOverflowObserver], [uxOverflowHorizontalObserver], [uxOverflowVerticalObserver]',
                        exportAs: 'ux-overflow-observer'
                    },] },
        ];
        /** @nocollapse */
        OverflowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        OverflowDirective.propDecorators = {
            "trigger": [{ type: core.Input },],
            "tolerance": [{ type: core.Input },],
            "uxOverflowObserver": [{ type: core.Output },],
            "uxOverflowHorizontalObserver": [{ type: core.Output },],
            "uxOverflowVerticalObserver": [{ type: core.Output },],
        };
        return OverflowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ObserversModule = (function () {
        function ObserversModule() {
        }
        ObserversModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [OverflowDirective],
                        declarations: [OverflowDirective]
                    },] },
        ];
        /** @nocollapse */
        ObserversModule.ctorParameters = function () { return []; };
        return ObserversModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var KeyCode = {
        UpArrow: 38,
        DownArrow: 40,
        Spacebar: 32,
    };
    KeyCode[KeyCode.UpArrow] = "UpArrow";
    KeyCode[KeyCode.DownArrow] = "DownArrow";
    KeyCode[KeyCode.Spacebar] = "Spacebar";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionStrategy = (function () {
        function SelectionStrategy(selectionService) {
            this.selectionService = selectionService;
        }
        /**
         * @param {?} selectionService
         * @return {?}
         */
        SelectionStrategy.prototype.setSelectionService =
            function (selectionService) {
                this.selectionService = selectionService;
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.mousedown =
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.click =
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.keydown =
            function (event, data) { };
        /**
         * Select the item - default behavior
         */
        /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.select =
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).select.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Toggle the item's selected state - default behavior
         */
        /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.toggle =
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).toggle.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Deselect the item - default behavior
         */
        /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.deselect =
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).deselect.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Select all items - default behavior
         */
        /**
         * Select all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.selectAll =
            function () {
                this.select.apply(this, __spread(this.selectionService.dataset));
            };
        /**
         * Deselect all items - default behavior
         */
        /**
         * Deselect all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.deselectAll =
            function () {
                this.deselect.apply(this, __spread(this.selectionService.dataset));
            };
        /**
         * @return {?}
         */
        SelectionStrategy.prototype.destroy =
            function () { };
        return SelectionStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowSelectionStrategy = (function (_super) {
        __extends(RowSelectionStrategy, _super);
        function RowSelectionStrategy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._selection = { start: null, end: null };
            return _this;
        }
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         */
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
        RowSelectionStrategy.prototype.mousedown =
            function (event) {
                event.preventDefault();
            };
        /**
         * When a row is clicked we want to handle selection
         */
        /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.click =
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if the shift key is pressed we want to perform a multiple selection
                if (shiftKey) {
                    return this.multipleSelect(data);
                }
                // if the control key is pressed we want to perform an additive toggle selection
                if (ctrlKey) {
                    return this.toggle(data);
                }
                // perform a single selection where all other rows are deselected
                this.singleSelect(data);
            };
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         */
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.keydown =
            function (event, data) {
                switch (event.keyCode) {
                    case KeyCode.UpArrow:
                    case KeyCode.DownArrow:
                        event.preventDefault();
                        this.navigate(event, data);
                        break;
                    case KeyCode.Spacebar:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data, true);
                        break;
                }
            };
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         */
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @param {?=} activate
         * @return {?}
         */
        RowSelectionStrategy.prototype.toggle =
            function (data, activate) {
                if (activate === void 0) {
                    activate = false;
                }
                _super.prototype.toggle.call(this, data);
                // store or clear the selection
                this.selectionService.isSelected(data) ? this.setSelectionStart(data) : this.clearSelection();
                // if we want to keep the item activated then activate
                if (activate) {
                    this.selectionService.activate(data);
                }
            };
        /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.singleSelect =
            function (data) {
                // deselect all other rows if neither modifier key is pressed
                this.deselectAll();
                // select the current row
                this.select(data);
                // store the current item as the selection start
                this.setSelectionStart(data);
            };
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         */
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.multipleSelect =
            function (data) {
                // if no selection currently exists then perform initial selection
                if (!this._selection.start) {
                    // select the row
                    this.select(data);
                    // store the starting point
                    return this.setSelectionStart(data);
                }
                // if a multiple selection already took place - clear the previous selection
                if (this._selection.start && this._selection.end) {
                    this.deselect.apply(this, __spread(this.getSelectedItems()));
                }
                // set the new selection end point
                this.setSelectionEnd(data);
                // select all the items in the range
                this.select.apply(this, __spread(this.getSelectedItems()));
            };
        /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionStart =
            function (data) {
                this._selection.start = data;
                this._selection.end = null;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionEnd =
            function (data) {
                this._selection.end = data;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Clear both start and end selection points
         */
        /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
        RowSelectionStrategy.prototype.clearSelection =
            function (deactivate) {
                if (deactivate === void 0) {
                    deactivate = true;
                }
                // reset the selected item
                this._selection = { start: null, end: null };
                // remove the current active item
                if (deactivate) {
                    this.selectionService.deactivate();
                }
            };
        /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
        RowSelectionStrategy.prototype.getSelectedItems =
            function () {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                var /** @type {?} */ startIdx = dataset.indexOf(this._selection.start);
                var /** @type {?} */ endIdx = dataset.indexOf(this._selection.end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.navigate =
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                // activate the sibling - if the up arrow is pressed then navigate to the previous sibling
                var /** @type {?} */ sibling = this.selectionService.activateSibling(event.keyCode === KeyCode.UpArrow);
                // if the shift key is pressed then we also want to toggle the state if the item
                if (shiftKey && sibling) {
                    // if there is no current selection start then select the current row
                    if (!this._selection.start) {
                        this.multipleSelect(data);
                    }
                    this.multipleSelect(sibling);
                }
            };
        return RowSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowAltSelectionStrategy = (function (_super) {
        __extends(RowAltSelectionStrategy, _super);
        function RowAltSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.keydown =
            function (event, data) {
                switch (event.keyCode) {
                    case KeyCode.UpArrow:
                    case KeyCode.DownArrow:
                        event.preventDefault();
                        this.handleCursorKey(event, data);
                        break;
                    case KeyCode.Spacebar:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data);
                        break;
                }
            };
        /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.handleCursorKey =
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                if (ctrlKey) {
                    this.selectionService.activateSibling(event.keyCode === KeyCode.UpArrow);
                }
                else {
                    var /** @type {?} */ sibling = this.selectionService.getSibling(event.keyCode === KeyCode.UpArrow);
                    this.multipleSelect(sibling ? sibling : data);
                }
            };
        return RowAltSelectionStrategy;
    }(RowSelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SimpleSelectionStrategy = (function (_super) {
        __extends(SimpleSelectionStrategy, _super);
        function SimpleSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * When the item is clicked simply toggle the current selected state
         */
        /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.click =
            function (event, data) {
                this.toggle(data);
            };
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         */
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.keydown =
            function (event, data) {
                switch (event.keyCode) {
                    case KeyCode.UpArrow:
                        event.preventDefault();
                        return this.selectionService.activateSibling(true);
                    case KeyCode.DownArrow:
                        event.preventDefault();
                        return this.selectionService.activateSibling(false);
                    case KeyCode.Spacebar:
                        event.preventDefault();
                        return this.toggle(data);
                }
            };
        /**
         * Override the standard toggle function to always activate the item
         */
        /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.toggle =
            function (data) {
                _super.prototype.toggle.call(this, data);
                this.selectionService.activate(data);
            };
        return SimpleSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionService = (function () {
        function SelectionService() {
            this._selection = new Set();
            this.dataset = [];
            this.enabled = true;
            this.clickEnabled = true;
            this.keyboardEnabled = true;
            this.strategy = new SimpleSelectionStrategy(this);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.focusTarget$ = new BehaviorSubject.BehaviorSubject(null);
            this.selection$ = new BehaviorSubject.BehaviorSubject([]);
            this._strategyToDestroy = this.strategy;
        }
        /**
         * @return {?}
         */
        SelectionService.prototype.ngOnDestroy =
            function () {
                if (this._strategyToDestroy) {
                    this._strategyToDestroy.destroy();
                }
            };
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         */
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.select =
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // add each selection to the set
                selections.forEach(function (selection) { return _this._selection.add(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Remove an item from the list of selected items
         */
        /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.deselect =
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // remove each item from the set
                selections.forEach(function (selection) { return _this._selection.delete(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Toggle the selected state of any specified items
         */
        /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.toggle =
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                selections.forEach(function (selection) { return _this.isSelected(selection) ? _this.deselect(selection) : _this.select(selection); });
            };
        /**
         * Determine whether or not a specific item is currently selected
         */
        /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.isSelected =
            function (data) {
                return this._selection.has(data);
            };
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         */
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.selected$ =
            function (data) {
                var _this = this;
                return this.selection$.pipe(operators.map(function () { return _this.isSelected(data); }), operators.distinctUntilChanged());
            };
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         */
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
        SelectionService.prototype.setMode =
            function (mode) {
                if (this._strategyToDestroy) {
                    // Destroy previous strategy if it was created internally
                    this._strategyToDestroy.destroy();
                    this._strategyToDestroy = null;
                }
                if (mode instanceof SelectionStrategy) {
                    // Custom strategy - pass in the service instance
                    this.strategy = mode;
                    this.strategy.setSelectionService(this);
                }
                else {
                    switch (mode.toLowerCase().trim()) {
                        case 'simple':
                            this.strategy = this._strategyToDestroy = new SimpleSelectionStrategy(this);
                            break;
                        case 'row':
                            this.strategy = this._strategyToDestroy = new RowSelectionStrategy(this);
                            break;
                        case 'row-alt':
                            this.strategy = this._strategyToDestroy = new RowAltSelectionStrategy(this);
                            break;
                        default:
                            throw new Error("The selection mode '" + mode + "' does not exist. Valid modes are 'simple', 'row', or 'row-alt'.");
                    }
                }
            };
        /**
         * Set the current active item
         */
        /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.activate =
            function (data) {
                this.active$.next(data);
            };
        /**
         * Deactive all items
         */
        /**
         * Deactive all items
         * @return {?}
         */
        SelectionService.prototype.deactivate =
            function () {
                this.active$.next(null);
            };
        /**
         * Return the next or previous sibling of the current active item.
         * @param previous If true, the previous sibling will be returned.
         */
        /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
        SelectionService.prototype.getSibling =
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                // get the currently active item
                var /** @type {?} */ current = this.active$.getValue();
                // check if there is a current active item
                if (!current) {
                    return;
                }
                // get the index of the current item
                var /** @type {?} */ idx = this.dataset.indexOf(current);
                var /** @type {?} */ target = this.dataset[previous ? idx - 1 : idx + 1];
                return target;
            };
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         */
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
        SelectionService.prototype.activateSibling =
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                var /** @type {?} */ target = this.getSibling(previous);
                // check if the target exists
                if (target) {
                    this.activate(target);
                }
                return target;
            };
        /**
         * @param {?} disabled
         * @return {?}
         */
        SelectionService.prototype.setDisabled =
            function (disabled) {
                // store the current disabled state
                this.enabled = !disabled;
                // clear any stateful data
                this.active$.next(null);
                this._selection.clear();
                // emit the selection change information
                this.selectionHasMutated();
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.selectionHasMutated =
            function () {
                this.selection$.next(Array.from(this._selection));
            };
        SelectionService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SelectionService.ctorParameters = function () { return []; };
        return SelectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionItemDirective = (function () {
        function SelectionItemDirective(_selectionService, _elementRef) {
            this._selectionService = _selectionService;
            this._elementRef = _elementRef;
            this.tabindex = null;
            this.selectedChange = new core.EventEmitter();
            this.active = false;
            this._selected = false;
            this._managedTabIndex = -1;
            this._subscriptions = new Subscription.Subscription();
        }
        Object.defineProperty(SelectionItemDirective.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            set: /**
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                selected ? this.select() : this.deselect();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "attrTabIndex", {
            get: /**
             * @return {?}
             */ function () {
                return (this.tabindex !== null) ? this.tabindex : this._managedTabIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                // if there is no associated data then throw an error
                if (!this.uxSelectionItem) {
                    throw new Error('The uxSelectionItem directive must have data associated with it.');
                }
                // subscribe to selection changes on this item
                this._subscriptions.add(this._selectionService.selected$(this.uxSelectionItem).subscribe(function (selected) {
                    // store the selected state
                    // store the selected state
                    _this._selected = selected;
                    // emit the selected state
                    // emit the selected state
                    _this.selectedChange.emit(selected);
                }));
                // subscribe to changes to the active state
                this._subscriptions.add(this._selectionService.active$.pipe(operators.map(function (active) { return active === _this.uxSelectionItem; })).subscribe(function (active) {
                    // store the focus state
                    // store the focus state
                    _this.active = active;
                    // if it is active then focus the element
                    if (active === true) {
                        _this._selectionService.focusTarget$.next(_this.uxSelectionItem);
                        _this._elementRef.nativeElement.focus();
                    }
                }));
                // Subscribe to changes to the focus target
                // This is mostly the same as active$, except that it has an initial value of the first item in the collection.
                this._subscriptions.add(this._selectionService.focusTarget$.subscribe(function (focusTarget) {
                    _this._managedTabIndex = (focusTarget === _this.uxSelectionItem) ? 0 : -1;
                }));
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnDestroy =
            function () {
                this._subscriptions.unsubscribe();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.click =
            function (event) {
                if (this._selectionService.enabled && this._selectionService.clickEnabled) {
                    this._selectionService.strategy.click(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.mousedown =
            function (event) {
                if (this._selectionService.enabled && this._selectionService.clickEnabled) {
                    this._selectionService.strategy.mousedown(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.keydown =
            function (event) {
                if (this._selectionService.enabled && this._selectionService.keyboardEnabled) {
                    this._selectionService.strategy.keydown(event, this.uxSelectionItem);
                }
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.focus =
            function () {
                // If tabbed to from outside the component, activate.
                if (this._selectionService.active$.getValue() !== this.uxSelectionItem) {
                    this._selectionService.activate(this.uxSelectionItem);
                }
            };
        /**
         * Select this item using the current strategy
         */
        /**
         * Select this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.select =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.select(this.uxSelectionItem);
                }
            };
        /**
         * Deselect this item using the current strategy
         */
        /**
         * Deselect this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.deselect =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.deselect(this.uxSelectionItem);
                }
            };
        SelectionItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelectionItem]',
                        exportAs: 'ux-selection-item'
                    },] },
        ];
        /** @nocollapse */
        SelectionItemDirective.ctorParameters = function () {
            return [
                { type: SelectionService, },
                { type: core.ElementRef, },
            ];
        };
        SelectionItemDirective.propDecorators = {
            "uxSelectionItem": [{ type: core.Input },],
            "selected": [{ type: core.Input }, { type: core.HostBinding, args: ['class.ux-selection-selected',] },],
            "tabindex": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
            "active": [{ type: core.HostBinding, args: ['class.ux-selection-focused',] },],
            "attrTabIndex": [{ type: core.HostBinding, args: ['attr.tabindex',] },],
            "click": [{ type: core.HostListener, args: ['click', ['$event'],] },],
            "mousedown": [{ type: core.HostListener, args: ['mousedown', ['$event'],] },],
            "keydown": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
            "focus": [{ type: core.HostListener, args: ['focus',] },],
        };
        return SelectionItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionDirective = (function () {
        function SelectionDirective(_selectionService, _cdRef) {
            var _this = this;
            this._selectionService = _selectionService;
            this._cdRef = _cdRef;
            this.tabindex = null;
            this.uxSelectionChange = new core.EventEmitter();
            this._subscriptions = new Subscription.Subscription();
            this._subscriptions.add(_selectionService.selection$.subscribe(function (items) { return _this.uxSelectionChange.emit(items); }));
        }
        Object.defineProperty(SelectionDirective.prototype, "uxSelection", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                (_a = this._selectionService).select.apply(_a, __spread(items));
                var _a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "disabled", {
            set: /**
             * @param {?} disabled
             * @return {?}
             */ function (disabled) {
                this._selectionService.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "mode", {
            set: /**
             * @param {?} mode
             * @return {?}
             */ function (mode) {
                this._selectionService.setMode(mode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "clickSelection", {
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._selectionService.clickEnabled = enabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "keyboardSelection", {
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._selectionService.keyboardEnabled = enabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // provide the initial list of selection items
                this.update();
                // if the list changes then inform the service
                this._subscriptions.add(this.items.changes.subscribe(function () { return _this.update(); }));
                // The above could trigger a change in the computed tabindex for selection items
                this._cdRef.detectChanges();
            };
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngOnDestroy =
            function () {
                this._subscriptions.unsubscribe();
            };
        /**
         * Update the dataset to reflect the latest selection items
         */
        /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
        SelectionDirective.prototype.update =
            function () {
                this._selectionService.dataset = this.items.map(function (item) { return item.uxSelectionItem; });
                // Make sure that a tab target has been defined so that the component can be tabbed to.
                if (this._selectionService.focusTarget$.getValue() === null && this._selectionService.dataset.length > 0) {
                    this._selectionService.focusTarget$.next(this._selectionService.dataset[0]);
                }
            };
        /**
         * Select all the items in the list
         */
        /**
         * Select all the items in the list
         * @return {?}
         */
        SelectionDirective.prototype.selectAll =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.selectAll();
                }
            };
        /**
         * Deselect all currently selected items
         */
        /**
         * Deselect all currently selected items
         * @return {?}
         */
        SelectionDirective.prototype.deselectAll =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.deselectAll();
                }
            };
        SelectionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelection]',
                        exportAs: 'ux-selection',
                        providers: [SelectionService]
                    },] },
        ];
        /** @nocollapse */
        SelectionDirective.ctorParameters = function () {
            return [
                { type: SelectionService, },
                { type: core.ChangeDetectorRef, },
            ];
        };
        SelectionDirective.propDecorators = {
            "uxSelection": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "mode": [{ type: core.Input },],
            "clickSelection": [{ type: core.Input },],
            "keyboardSelection": [{ type: core.Input },],
            "tabindex": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.tabindex',] },],
            "uxSelectionChange": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [SelectionItemDirective,] },],
        };
        return SelectionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionModule = (function () {
        function SelectionModule() {
        }
        SelectionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [SelectionDirective, SelectionItemDirective],
                        exports: [SelectionDirective, SelectionItemDirective]
                    },] },
        ];
        /** @nocollapse */
        SelectionModule.ctorParameters = function () { return []; };
        return SelectionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ContactsNg1Component = (function (_super) {
        __extends(ContactsNg1Component, _super);
        function ContactsNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'contactGroup', elementRef, injector) || this;
            _this.overflowClick = new core.EventEmitter();
            return _this;
        }
        ContactsNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'contact-group'
                    },] },
        ];
        /** @nocollapse */
        ContactsNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        ContactsNg1Component.propDecorators = {
            "contacts": [{ type: core.Input },],
            "organization": [{ type: core.Input },],
            "size": [{ type: core.Input },],
            "colors": [{ type: core.Input },],
            "maxContacts": [{ type: core.Input },],
            "overflowClick": [{ type: core.Output },],
        };
        return ContactsNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ExpandInputNg1Component = (function (_super) {
        __extends(ExpandInputNg1Component, _super);
        function ExpandInputNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'expandInput', elementRef, injector) || this;
            _this.focus = new core.EventEmitter();
            return _this;
        }
        ExpandInputNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'expand-input'
                    },] },
        ];
        /** @nocollapse */
        ExpandInputNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        ExpandInputNg1Component.propDecorators = {
            "elname": [{ type: core.Input },],
            "placeHolder": [{ type: core.Input },],
            "className": [{ type: core.Input },],
            "clearTextIcon": [{ type: core.Input },],
            "closeSearch": [{ type: core.Input },],
            "expandAlways": [{ type: core.Input },],
            "onEnter": [{ type: core.Input },],
            "focus": [{ type: core.Output },],
        };
        return ExpandInputNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonNg1Component = (function (_super) {
        __extends(FloatingActionButtonNg1Component, _super);
        function FloatingActionButtonNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'floatingActionButton', elementRef, injector) || this;
            _this.items = [];
            return _this;
        }
        FloatingActionButtonNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'floating-action-button'
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        FloatingActionButtonNg1Component.propDecorators = {
            "items": [{ type: core.Input },],
            "primary": [{ type: core.Input },],
            "direction": [{ type: core.Input },],
            "fabTooltip": [{ type: core.Input },],
            "fabTooltipPlacement": [{ type: core.Input },],
        };
        return FloatingActionButtonNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlotNg1Component = (function (_super) {
        __extends(FlotNg1Component, _super);
        function FlotNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxFlotNg1', elementRef, injector) || this;
            _this.onPlotClick = new core.EventEmitter();
            _this.onPlotHover = new core.EventEmitter();
            return _this;
        }
        FlotNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'flot'
                    },] },
        ];
        /** @nocollapse */
        FlotNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        FlotNg1Component.propDecorators = {
            "dataset": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "callback": [{ type: core.Input },],
            "donutLabels": [{ type: core.Input },],
            "onPlotClick": [{ type: core.Output },],
            "onPlotHover": [{ type: core.Output },],
        };
        return FlotNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GridNg1Component = (function (_super) {
        __extends(GridNg1Component, _super);
        function GridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'grid', elementRef, injector) || this;
            _this.source = [];
            _this.columns = [];
            return _this;
        }
        GridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'grid'
                    },] },
        ];
        /** @nocollapse */
        GridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        GridNg1Component.propDecorators = {
            "source": [{ type: core.Input },],
            "columns": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "events": [{ type: core.Input },],
            "plugins": [{ type: core.Input },],
        };
        return GridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarNg1Component = (function (_super) {
        __extends(HierarchyBarNg1Component, _super);
        function HierarchyBarNg1Component(elementRef, injector) {
            return _super.call(this, 'hierarchyBar', elementRef, injector) || this;
        }
        HierarchyBarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'hierarchy-bar'
                    },] },
        ];
        /** @nocollapse */
        HierarchyBarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        HierarchyBarNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "selectNode": [{ type: core.Input },],
            "containerClass": [{ type: core.Input },],
        };
        return HierarchyBarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardNg1Component = (function (_super) {
        __extends(MarqueeWizardNg1Component, _super);
        function MarqueeWizardNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'marqueeWizard', elementRef, injector) || this;
            _this.wizardStepsChange = new core.EventEmitter();
            return _this;
        }
        MarqueeWizardNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'marquee-wizard'
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        MarqueeWizardNg1Component.propDecorators = {
            "wizardIcon": [{ type: core.Input },],
            "wizardSteps": [{ type: core.Input },],
            "buttonOptions": [{ type: core.Input },],
            "onChanging": [{ type: core.Input },],
            "onFinished": [{ type: core.Input },],
            "onFinishing": [{ type: core.Input },],
            "onCanceled": [{ type: core.Input },],
            "isVisited": [{ type: core.Input },],
            "sideInfo": [{ type: core.Input },],
            "wizardStepsChange": [{ type: core.Output },],
        };
        return MarqueeWizardNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NestedDonutNg1Component = (function (_super) {
        __extends(NestedDonutNg1Component, _super);
        function NestedDonutNg1Component(elementRef, injector) {
            return _super.call(this, 'uxNestedDonutNg1', elementRef, injector) || this;
        }
        NestedDonutNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'nested-donut'
                    },] },
        ];
        /** @nocollapse */
        NestedDonutNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        NestedDonutNg1Component.propDecorators = {
            "dataset": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return NestedDonutNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OrganizationChartNg1Component = (function (_super) {
        __extends(OrganizationChartNg1Component, _super);
        function OrganizationChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxOrganizationChartNg1', elementRef, injector) || this;
            _this.dataChange = new core.EventEmitter();
            _this.optionsChange = new core.EventEmitter();
            return _this;
        }
        OrganizationChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'organization-chart'
                    },] },
        ];
        /** @nocollapse */
        OrganizationChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        OrganizationChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "dataChange": [{ type: core.Output },],
            "optionsChange": [{ type: core.Output },],
        };
        return OrganizationChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PartitionMapNg1Component = (function (_super) {
        __extends(PartitionMapNg1Component, _super);
        function PartitionMapNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPartitionMapNg1', elementRef, injector) || this;
        }
        PartitionMapNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'partition-map'
                    },] },
        ];
        /** @nocollapse */
        PartitionMapNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PartitionMapNg1Component.propDecorators = {
            "chartData": [{ type: core.Input },],
            "chartOptions": [{ type: core.Input },],
            "chartLoading": [{ type: core.Input },],
        };
        return PartitionMapNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityBarChartNg1Component = (function (_super) {
        __extends(PeityBarChartNg1Component, _super);
        function PeityBarChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityBarChartNg1', elementRef, injector) || this;
        }
        PeityBarChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'bar-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityBarChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityBarChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return PeityBarChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityLineChartNg1Component = (function (_super) {
        __extends(PeityLineChartNg1Component, _super);
        function PeityLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityLineChartNg1', elementRef, injector) || this;
        }
        PeityLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'line-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityLineChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return PeityLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityPieChartNg1Component = (function (_super) {
        __extends(PeityPieChartNg1Component, _super);
        function PeityPieChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityPieChartNg1', elementRef, injector) || this;
        }
        PeityPieChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'pie-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityPieChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityPieChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return PeityPieChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityUpdatingLineChartNg1Component = (function (_super) {
        __extends(PeityUpdatingLineChartNg1Component, _super);
        function PeityUpdatingLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityUpdatingLineChartNg1', elementRef, injector) || this;
        }
        PeityUpdatingLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'updating-line-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityUpdatingLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityUpdatingLineChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "method": [{ type: core.Input },],
            "updateinterval": [{ type: core.Input },],
        };
        return PeityUpdatingLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SankeyNg1Component = (function (_super) {
        __extends(SankeyNg1Component, _super);
        function SankeyNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSankeyNg1', elementRef, injector) || this;
        }
        SankeyNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sankey'
                    },] },
        ];
        /** @nocollapse */
        SankeyNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SankeyNg1Component.propDecorators = {
            "chartSize": [{ type: core.Input },],
            "chartData": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "click": [{ type: core.Input },],
        };
        return SankeyNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchToolbarNg1Component = (function (_super) {
        __extends(SearchToolbarNg1Component, _super);
        function SearchToolbarNg1Component(elementRef, injector) {
            return _super.call(this, 'searchToolbar', elementRef, injector) || this;
        }
        SearchToolbarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'search-toolbar'
                    },] },
        ];
        /** @nocollapse */
        SearchToolbarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SearchToolbarNg1Component.propDecorators = {
            "searchTypeahead": [{ type: core.Input },],
            "placeHolder": [{ type: core.Input },],
            "closeSearch": [{ type: core.Input },],
            "onSearch": [{ type: core.Input },],
            "onFocus": [{ type: core.Input },],
        };
        return SearchToolbarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectTableNg1Component = (function (_super) {
        __extends(SelectTableNg1Component, _super);
        function SelectTableNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'selectTable', elementRef, injector) || this;
            _this.selectedChange = new core.EventEmitter();
            return _this;
        }
        SelectTableNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'select-table'
                    },] },
        ];
        /** @nocollapse */
        SelectTableNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SelectTableNg1Component.propDecorators = {
            "values": [{ type: core.Input },],
            "multipleSelect": [{ type: core.Input },],
            "selectKey": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "searchText": [{ type: core.Input },],
            "tableHeight": [{ type: core.Input },],
            "selectHiddenItems": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
        };
        return SelectTableNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SLIDER_CHART_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SliderChartNg1Component; }),
        multi: true
    };
    var SliderChartNg1Component = (function (_super) {
        __extends(SliderChartNg1Component, _super);
        function SliderChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'sliderChart', elementRef, injector) || this;
            _this.ngModelChange = new core.EventEmitter();
            return _this;
        }
        /**
         * @param {?} obj
         * @return {?}
         */
        SliderChartNg1Component.prototype.writeValue =
            function (obj) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnChange =
            function (fn) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnTouched =
            function (fn) { };
        SliderChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'slider-chart',
                        providers: [SLIDER_CHART_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        SliderChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SliderChartNg1Component.propDecorators = {
            "sliderOptions": [{ type: core.Input },],
            "ngModel": [{ type: core.Input },],
            "chartOptions": [{ type: core.Input },],
            "chartData": [{ type: core.Input },],
            "ngModelChange": [{ type: core.Output },],
        };
        return SliderChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SocialChartNg1Component = (function (_super) {
        __extends(SocialChartNg1Component, _super);
        function SocialChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSocialChartNg1', elementRef, injector) || this;
        }
        SocialChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'social-chart'
                    },] },
        ];
        /** @nocollapse */
        SocialChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SocialChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "height": [{ type: core.Input },],
            "api": [{ type: core.Input },],
            "communities": [{ type: core.Input },],
            "detailStyle": [{ type: core.Input },],
            "popoverStyle": [{ type: core.Input },],
            "nodeDetail": [{ type: core.Input },],
            "edgeDetail": [{ type: core.Input },],
            "nodePopover": [{ type: core.Input },],
            "edgePopover": [{ type: core.Input },],
            "forceAtlasDuration": [{ type: core.Input },],
            "nodeSizeAttribute": [{ type: core.Input },],
            "startMaximized": [{ type: core.Input },],
            "startMaximised": [{ type: core.Input },],
            "showMaximizeControl": [{ type: core.Input },],
            "showMaximiseControl": [{ type: core.Input },],
            "socialChartContainer": [{ type: core.Input },],
            "fullscreenButtonPosition": [{ type: core.Input },],
            "localStrings": [{ type: core.Input },],
            "chartTitle": [{ type: core.Input },],
            "titleDisplayTime": [{ type: core.Input },],
            "edgeWeightInfluence": [{ type: core.Input },],
            "minLabels": [{ type: core.Input },],
        };
        return SocialChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SortDirectionToggleNg1Component = (function (_super) {
        __extends(SortDirectionToggleNg1Component, _super);
        function SortDirectionToggleNg1Component(elementRef, injector) {
            return _super.call(this, 'sortDirectionToggle', elementRef, injector) || this;
        }
        SortDirectionToggleNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sort-direction-toggle'
                    },] },
        ];
        /** @nocollapse */
        SortDirectionToggleNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SortDirectionToggleNg1Component.propDecorators = {
            "label": [{ type: core.Input },],
            "sorters": [{ type: core.Input },],
            "descend": [{ type: core.Input },],
        };
        return SortDirectionToggleNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridNg1Component = (function (_super) {
        __extends(TreeGridNg1Component, _super);
        function TreeGridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'treegrid', elementRef, injector) || this;
            _this.optionsChange = new core.EventEmitter();
            _this.selectedChange = new core.EventEmitter();
            _this.currentRowChange = new core.EventEmitter();
            _this.treeDataChange = new core.EventEmitter();
            return _this;
        }
        TreeGridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'treegrid'
                    },] },
        ];
        /** @nocollapse */
        TreeGridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        TreeGridNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "columns": [{ type: core.Input },],
            "treeData": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "currentRow": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "optionsChange": [{ type: core.Output },],
            "selectedChange": [{ type: core.Output },],
            "currentRowChange": [{ type: core.Output },],
            "treeDataChange": [{ type: core.Output },],
        };
        return TreeGridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ThumbnailNg1Component = (function (_super) {
        __extends(ThumbnailNg1Component, _super);
        function ThumbnailNg1Component(elementRef, injector) {
            return _super.call(this, 'thumbnail', elementRef, injector) || this;
        }
        ThumbnailNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'thumbnail'
                    },] },
        ];
        /** @nocollapse */
        ThumbnailNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        ThumbnailNg1Component.propDecorators = {
            "url": [{ type: core.Input },],
            "show": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "height": [{ type: core.Input },],
        };
        return ThumbnailNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationMenuService = (function () {
        function NavigationMenuService(_navigationMenuService) {
            this._navigationMenuService = _navigationMenuService;
        }
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.show =
            function () {
                this._navigationMenuService.show();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.hide =
            function () {
                this._navigationMenuService.hide();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.visible =
            function () {
                return this._navigationMenuService.visible();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.collapseAtWidth =
            function () {
                return this._navigationMenuService.collapseAtWidth();
            };
        /**
         * @param {?} width
         * @return {?}
         */
        NavigationMenuService.prototype.setCollapseAtWidth =
            function (width) {
                this._navigationMenuService.setCollapseAtWidth(width);
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.setDefaultCollapseAtWidth =
            function () {
                this._navigationMenuService.setDefaultCollapseAtWidth();
            };
        NavigationMenuService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        NavigationMenuService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$navigationMenu',] },] },
            ];
        };
        return NavigationMenuService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function navigationMenuServiceFactory(injector) {
        return injector.get('$navigationMenu');
    }
    var /** @type {?} */ navigationMenuServiceProvider = {
        provide: '$navigationMenu',
        useFactory: navigationMenuServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PdfService = (function () {
        function PdfService(_pdfService) {
            this._pdfService = _pdfService;
        }
        /**
         * @param {?} columns
         * @param {?} rows
         * @param {?=} options
         * @return {?}
         */
        PdfService.prototype.createTable =
            function (columns, rows, options) {
                if (options === void 0) {
                    options = {};
                }
                return this._pdfService.createTable(columns, rows, options);
            };
        PdfService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PdfService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$pdf',] },] },
            ];
        };
        return PdfService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function pdfServiceFactory(injector) {
        return injector.get('$pdf');
    }
    var /** @type {?} */ pdfServiceProvider = {
        provide: '$pdf',
        useFactory: pdfServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeAgoService = (function () {
        function TimeAgoService(_timeAgoService) {
            this._timeAgoService = _timeAgoService;
        }
        /**
         * @param {?} strings
         * @return {?}
         */
        TimeAgoService.prototype.setStrings =
            function (strings) {
                this._timeAgoService.setStrings(strings);
            };
        /**
         * @param {?} past
         * @param {?} present
         * @return {?}
         */
        TimeAgoService.prototype.timeSince =
            function (past, present) {
                return this._timeAgoService.timeSince(past, present);
            };
        /**
         * @param {?} moment
         * @return {?}
         */
        TimeAgoService.prototype.timeSinceNow =
            function (moment) {
                return this._timeAgoService.timeSinceNow(moment);
            };
        TimeAgoService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TimeAgoService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['timeAgoService',] },] },
            ];
        };
        return TimeAgoService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function timeAgoServiceFactory(injector) {
        return injector.get('timeAgoService');
    }
    var /** @type {?} */ timeAgoServiceProvider = {
        provide: 'timeAgoService',
        useFactory: timeAgoServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ declarations = [
        ContactsNg1Component,
        ExpandInputNg1Component,
        FloatingActionButtonNg1Component,
        FlotNg1Component,
        GridNg1Component,
        HierarchyBarNg1Component,
        MarqueeWizardNg1Component,
        NestedDonutNg1Component,
        OrganizationChartNg1Component,
        PartitionMapNg1Component,
        PeityBarChartNg1Component,
        PeityLineChartNg1Component,
        PeityPieChartNg1Component,
        PeityUpdatingLineChartNg1Component,
        SankeyNg1Component,
        SearchToolbarNg1Component,
        SelectTableNg1Component,
        SliderChartNg1Component,
        SocialChartNg1Component,
        SortDirectionToggleNg1Component,
        TreeGridNg1Component,
        ThumbnailNg1Component,
    ];
    var HybridModule = (function () {
        function HybridModule() {
        }
        HybridModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: declarations,
                        declarations: declarations,
                        providers: [
                            navigationMenuServiceProvider,
                            pdfServiceProvider,
                            timeAgoServiceProvider,
                            TimeAgoService,
                            PdfService,
                            NavigationMenuService,
                        ],
                    },] },
        ];
        /** @nocollapse */
        HybridModule.ctorParameters = function () { return []; };
        return HybridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterPipe = (function () {
        function StringFilterPipe() {
        }
        /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
        StringFilterPipe.prototype.transform =
            function (items, value) {
                if (!items) {
                    return [];
                }
                return items.filter(function (it) { return it.toLowerCase().indexOf(value.toLowerCase()) >= 0; });
            };
        StringFilterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'stringFilter'
                    },] },
            { type: core.Injectable },
        ];
        /** @nocollapse */
        StringFilterPipe.ctorParameters = function () { return []; };
        return StringFilterPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterModule = (function () {
        function StringFilterModule() {
        }
        StringFilterModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [StringFilterPipe],
                        declarations: [StringFilterPipe]
                    },] },
        ];
        /** @nocollapse */
        StringFilterModule.ctorParameters = function () { return []; };
        return StringFilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CookieAdapter = (function () {
        function CookieAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.getItem =
            function (key) {
                if (document.cookie) {
                    // get all the cookies for this site
                    var /** @type {?} */ cookies = document.cookie.split(';');
                    // process the cookies into a from we can easily manage
                    var /** @type {?} */ match = cookies
                        .map(function (cookie) { return ({ key: cookie.split('=')[0].trim(), value: cookie.split('=')[1].trim() }); })
                        .find(function (cookie) { return cookie.key === key; });
                    return match ? match.value : null;
                }
                return null;
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        CookieAdapter.prototype.setItem =
            function (key, value) {
                document.cookie = key + "=" + value + "; path=/";
            };
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.removeItem =
            function (key) {
                document.cookie.split(';').forEach(function (cookie) {
                    var /** @type {?} */ eqPos = cookie.indexOf('=');
                    var /** @type {?} */ name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie;
                    if (name === key) {
                        document.cookie = cookie.trim().replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                    }
                });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.clear =
            function () {
                var _this = this;
                // call remove item on each cookie
                document.cookie.split(';').map(function (cookie) { return cookie.split('=')[0].trim(); })
                    .forEach(function (cookie) { return _this.removeItem(cookie); });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.getSupported =
            function () {
                // cookies are supported in all browsers
                return this;
            };
        return CookieAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LocalStorageAdapter = (function () {
        function LocalStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.getItem =
            function (key) {
                return localStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        LocalStorageAdapter.prototype.setItem =
            function (key, value) {
                localStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.removeItem =
            function (key) {
                localStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.clear =
            function () {
                localStorage.clear();
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.getSupported =
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!localStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    localStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    localStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return LocalStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SessionStorageAdapter = (function () {
        function SessionStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.getItem =
            function (key) {
                return sessionStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        SessionStorageAdapter.prototype.setItem =
            function (key, value) {
                sessionStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.removeItem =
            function (key) {
                sessionStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.clear =
            function () {
                sessionStorage.clear();
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.getSupported =
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!sessionStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    sessionStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    sessionStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return SessionStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataService = (function () {
        function PersistentDataService() {
        }
        /**
         * Save the item in some form of persistent storage
         */
        /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.setItem =
            function (key, value, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).setItem(key, value);
            };
        /**
         * Get a stored value from persistent storage
         */
        /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.getItem =
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                return this.getAdapter(type).getItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.removeItem =
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).removeItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.clear =
            function (type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).clear();
            };
        /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
        PersistentDataService.prototype.getAdapter =
            function (type) {
                switch (type) {
                    case PersistentDataStorageType.Cookie:
                        return new CookieAdapter();
                    case PersistentDataStorageType.LocalStorage:
                        var /** @type {?} */ localStorageAdapter = new LocalStorageAdapter();
                        return localStorageAdapter.getSupported();
                    case PersistentDataStorageType.SessionStorage:
                        var /** @type {?} */ sessionStorageAdapter = new SessionStorageAdapter();
                        return sessionStorageAdapter.getSupported();
                }
            };
        PersistentDataService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PersistentDataService.ctorParameters = function () { return []; };
        return PersistentDataService;
    }());
    /** @enum {number} */
    var PersistentDataStorageType = {
        LocalStorage: 0,
        Cookie: 1,
        SessionStorage: 2,
    };
    PersistentDataStorageType[PersistentDataStorageType.LocalStorage] = "LocalStorage";
    PersistentDataStorageType[PersistentDataStorageType.Cookie] = "Cookie";
    PersistentDataStorageType[PersistentDataStorageType.SessionStorage] = "SessionStorage";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataModule = (function () {
        function PersistentDataModule() {
        }
        PersistentDataModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [PersistentDataService],
                    },] },
        ];
        /** @nocollapse */
        PersistentDataModule.ctorParameters = function () { return []; };
        return PersistentDataModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ StorageAdapter = (function () {
        function StorageAdapter() {
        }
        return StorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.BreadcrumbsComponent = BreadcrumbsComponent;
    exports.BreadcrumbsModule = BreadcrumbsModule;
    exports.CardTabsModule = CardTabsModule;
    exports.CardTabsService = CardTabsService;
    exports.CardTabsetComponent = CardTabsetComponent;
    exports.CardTabComponent = CardTabComponent;
    exports.CardTabContentDirective = CardTabContentDirective;
    exports.CheckboxModule = CheckboxModule;
    exports.CHECKBOX_VALUE_ACCESSOR = CHECKBOX_VALUE_ACCESSOR;
    exports.CheckboxComponent = CheckboxComponent;
    exports.ColumnSortingModule = ColumnSortingModule;
    exports.ColumnSortingComponent = ColumnSortingComponent;
    exports.ColumnSortingDirective = ColumnSortingDirective;
    exports.ColumnSortingState = ColumnSortingState;
    exports.ConduitSubject = ConduitSubject;
    exports.ConduitZoneComponent = ConduitZoneComponent;
    exports.ConduitZone = ConduitZone;
    exports.ConduitComponent = ConduitComponent;
    exports.CONDUITS = CONDUITS;
    exports.Conduit = Conduit;
    exports.defaultConduitProps = defaultConduitProps;
    exports.DashboardModule = DashboardModule;
    exports.DashboardComponent = DashboardComponent;
    exports.DashboardService = DashboardService;
    exports.defaultOptions = defaultOptions;
    exports.ActionDirection = ActionDirection;
    exports.Rounding = Rounding;
    exports.DashboardDragHandleDirective = DashboardDragHandleDirective;
    exports.DashboardWidgetComponent = DashboardWidgetComponent;
    exports.DateTimePickerModule = DateTimePickerModule;
    exports.DateTimePickerComponent = DateTimePickerComponent;
    exports.DateTimePickerService = DateTimePickerService;
    exports.DatePickerMode = DatePickerMode;
    exports.ModeDirection = ModeDirection;
    exports.DatePickerHeaderEvent = DatePickerHeaderEvent;
    exports.DateTimePickerConfig = DateTimePickerConfig;
    exports.EboxModule = EboxModule;
    exports.EboxComponent = EboxComponent;
    exports.EboxHeaderDirective = EboxHeaderDirective;
    exports.EboxContentDirective = EboxContentDirective;
    exports.FacetsModule = FacetsModule;
    exports.FacetContainerComponent = FacetContainerComponent;
    exports.FacetSelect = FacetSelect;
    exports.FacetDeselect = FacetDeselect;
    exports.FacetDeselectAll = FacetDeselectAll;
    exports.FacetHeaderComponent = FacetHeaderComponent;
    exports.FacetBaseComponent = FacetBaseComponent;
    exports.FacetCheckListComponent = FacetCheckListComponent;
    exports.FacetTypeaheadListComponent = FacetTypeaheadListComponent;
    exports.FacetTypeaheadHighlight = FacetTypeaheadHighlight;
    exports.Facet = Facet;
    exports.FilterModule = FilterModule;
    exports.FilterContainerComponent = FilterContainerComponent;
    exports.FilterAddEvent = FilterAddEvent;
    exports.FilterRemoveEvent = FilterRemoveEvent;
    exports.FilterRemoveAllEvent = FilterRemoveAllEvent;
    exports.FilterBaseComponent = FilterBaseComponent;
    exports.FilterDropdownComponent = FilterDropdownComponent;
    exports.FilterDynamicComponent = FilterDynamicComponent;
    exports.FilterTypeaheadHighlight = FilterTypeaheadHighlight;
    exports.FlippableCardModule = FlippableCardModule;
    exports.FlippableCardComponent = FlippableCardComponent;
    exports.FlippableCardFrontDirective = FlippableCardFrontDirective;
    exports.FlippableCardBackDirective = FlippableCardBackDirective;
    exports.FloatingActionButtonsModule = FloatingActionButtonsModule;
    exports.FloatingActionButtonsComponent = FloatingActionButtonsComponent;
    exports.FloatingActionButtonComponent = FloatingActionButtonComponent;
    exports.HierarchyBarModule = HierarchyBarModule;
    exports.HierarchyBarService = HierarchyBarService;
    exports.HierarchyBarComponent = HierarchyBarComponent;
    exports.ItemDisplayPanelModule = ItemDisplayPanelModule;
    exports.ItemDisplayPanelContentDirective = ItemDisplayPanelContentDirective;
    exports.ItemDisplayPanelFooterDirective = ItemDisplayPanelFooterDirective;
    exports.ItemDisplayPanelComponent = ItemDisplayPanelComponent;
    exports.MarqueeWizardStepComponent = MarqueeWizardStepComponent;
    exports.MarqueeWizardComponent = MarqueeWizardComponent;
    exports.MarqueeWizardModule = MarqueeWizardModule;
    exports.MediaPlayerModule = MediaPlayerModule;
    exports.MediaPlayerComponent = MediaPlayerComponent;
    exports.MediaPlayerBaseExtensionDirective = MediaPlayerBaseExtensionDirective;
    exports.MediaPlayerControlsExtensionComponent = MediaPlayerControlsExtensionComponent;
    exports.MediaPlayerTimelineExtensionComponent = MediaPlayerTimelineExtensionComponent;
    exports.NavigationModule = NavigationModule;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationItemComponent = NavigationItemComponent;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NumberPickerModule = NumberPickerModule;
    exports.NUMBER_PICKER_VALUE_ACCESSOR = NUMBER_PICKER_VALUE_ACCESSOR;
    exports.NumberPickerComponent = NumberPickerComponent;
    exports.PageHeaderModule = PageHeaderModule;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageHeaderNavigationComponent = PageHeaderNavigationComponent;
    exports.PageHeaderIconMenuComponent = PageHeaderIconMenuComponent;
    exports.PageHeaderCustomMenuDirective = PageHeaderCustomMenuDirective;
    exports.PopoverModule = PopoverModule;
    exports.PopoverComponent = PopoverComponent;
    exports.PopoverDirective = PopoverDirective;
    exports.ProgressBarModule = ProgressBarModule;
    exports.ProgressBarComponent = ProgressBarComponent;
    exports.RadioButtonModule = RadioButtonModule;
    exports.RADIOBUTTON_VALUE_ACCESSOR = RADIOBUTTON_VALUE_ACCESSOR;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.SearchBuilderGroupComponent = SearchBuilderGroupComponent;
    exports.SearchBuilderGroupService = SearchBuilderGroupService;
    exports.SearchBuilderOutletDirective = SearchBuilderOutletDirective;
    exports.BaseSearchComponent = BaseSearchComponent;
    exports.SearchTextComponent = SearchTextComponent;
    exports.SearchDateComponent = SearchDateComponent;
    exports.SearchDateRangeComponent = SearchDateRangeComponent;
    exports.SearchSelectComponent = SearchSelectComponent;
    exports.SearchBuilderComponent = SearchBuilderComponent;
    exports.SearchBuilderService = SearchBuilderService;
    exports.SearchBuilderModule = SearchBuilderModule;
    exports.SELECT_VALUE_ACCESSOR = SELECT_VALUE_ACCESSOR;
    exports.SelectComponent = SelectComponent;
    exports.SelectModule = SelectModule;
    exports.SidePanelComponent = SidePanelComponent;
    exports.SidePanelCloseDirective = SidePanelCloseDirective;
    exports.SidePanelModule = SidePanelModule;
    exports.SliderModule = SliderModule;
    exports.SliderComponent = SliderComponent;
    exports.SliderType = SliderType;
    exports.SliderStyle = SliderStyle;
    exports.SliderSize = SliderSize;
    exports.SliderCalloutTrigger = SliderCalloutTrigger;
    exports.SliderSnap = SliderSnap;
    exports.SliderTickType = SliderTickType;
    exports.SliderThumbEvent = SliderThumbEvent;
    exports.SliderThumb = SliderThumb;
    exports.SparkModule = SparkModule;
    exports.SparkComponent = SparkComponent;
    exports.SpinButtonModule = SpinButtonModule;
    exports.SPIN_BUTTON_VALUE_ACCESSOR = SPIN_BUTTON_VALUE_ACCESSOR;
    exports.SpinButtonComponent = SpinButtonComponent;
    exports.TabsetModule = TabsetModule;
    exports.TabsetComponent = TabsetComponent;
    exports.TabsetService = TabsetService;
    exports.TabComponent = TabComponent;
    exports.TabHeadingDirective = TabHeadingDirective;
    exports.TabFocusDirective = TabFocusDirective;
    exports.TagInputEvent = TagInputEvent;
    exports.TagInputComponent = TagInputComponent;
    exports.TagInputModule = TagInputModule;
    exports.TimePickerModule = TimePickerModule;
    exports.TIME_PICKER_VALUE_ACCESSOR = TIME_PICKER_VALUE_ACCESSOR;
    exports.TimePickerComponent = TimePickerComponent;
    exports.TimeFormatPipe = TimeFormatPipe;
    exports.TimelineModule = TimelineModule;
    exports.TimelineComponent = TimelineComponent;
    exports.TimelineEventComponent = TimelineEventComponent;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.ToolbarSearchModule = ToolbarSearchModule;
    exports.ToolbarSearchComponent = ToolbarSearchComponent;
    exports.ToolbarSearchFieldDirective = ToolbarSearchFieldDirective;
    exports.ToolbarSearchButtonDirective = ToolbarSearchButtonDirective;
    exports.TooltipModule = TooltipModule;
    exports.TooltipComponent = TooltipComponent;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipService = TooltipService;
    exports.TypeaheadOptionEvent = TypeaheadOptionEvent;
    exports.TypeaheadKeyService = TypeaheadKeyService;
    exports.TypeaheadComponent = TypeaheadComponent;
    exports.TypeaheadModule = TypeaheadModule;
    exports.VirtualScrollModule = VirtualScrollModule;
    exports.VirtualScrollComponent = VirtualScrollComponent;
    exports.VirtualScrollLoadingDirective = VirtualScrollLoadingDirective;
    exports.VirtualScrollLoadButtonDirective = VirtualScrollLoadButtonDirective;
    exports.VirtualScrollCellDirective = VirtualScrollCellDirective;
    exports.WizardModule = WizardModule;
    exports.WizardComponent = WizardComponent;
    exports.StepChangingEvent = StepChangingEvent;
    exports.WizardStepComponent = WizardStepComponent;
    exports.AutoGrowModule = AutoGrowModule;
    exports.AutoGrowDirective = AutoGrowDirective;
    exports.ClickOutsideModule = ClickOutsideModule;
    exports.ClickOutsideDirective = ClickOutsideDirective;
    exports.DragModule = DragModule;
    exports.DragDirective = DragDirective;
    exports.FixedHeaderTableModule = FixedHeaderTableModule;
    exports.FixedHeaderTableDirective = FixedHeaderTableDirective;
    exports.FloatLabelDirective = FloatLabelDirective;
    exports.FloatLabelModule = FloatLabelModule;
    exports.FocusIfDirective = FocusIfDirective;
    exports.FocusIfModule = FocusIfModule;
    exports.HelpCenterModule = HelpCenterModule;
    exports.HelpCenterService = HelpCenterService;
    exports.HelpCenterItemDirective = HelpCenterItemDirective;
    exports.HoverActionModule = HoverActionModule;
    exports.HoverActionContainerDirective = HoverActionContainerDirective;
    exports.HoverActionDirective = HoverActionDirective;
    exports.InfiniteScrollDirective = InfiniteScrollDirective;
    exports.InfiniteScrollLoadingEvent = InfiniteScrollLoadingEvent;
    exports.InfiniteScrollLoadedEvent = InfiniteScrollLoadedEvent;
    exports.InfiniteScrollLoadErrorEvent = InfiniteScrollLoadErrorEvent;
    exports.InfiniteScrollLoadButtonDirective = InfiniteScrollLoadButtonDirective;
    exports.InfiniteScrollLoadingDirective = InfiniteScrollLoadingDirective;
    exports.InfiniteScrollModule = InfiniteScrollModule;
    exports.LayoutSwitcherModule = LayoutSwitcherModule;
    exports.LayoutSwitcherDirective = LayoutSwitcherDirective;
    exports.LayoutSwitcherItemDirective = LayoutSwitcherItemDirective;
    exports.MenuNavigationItemDirective = MenuNavigationItemDirective;
    exports.MenuNavigationDirective = MenuNavigationDirective;
    exports.MenuNavigationModule = MenuNavigationModule;
    exports.ObserversModule = ObserversModule;
    exports.OverflowDirective = OverflowDirective;
    exports.ReorderableModule = ReorderableModule;
    exports.ReorderableDirective = ReorderableDirective;
    exports.ReorderableHandleDirective = ReorderableHandleDirective;
    exports.ReorderableModelDirective = ReorderableModelDirective;
    exports.ReorderableService = ReorderableService;
    exports.ReorderableGroup = ReorderableGroup;
    exports.ResizeService = ResizeService;
    exports.ResizeDirective = ResizeDirective;
    exports.ResizeModule = ResizeModule;
    exports.ScrollIntoViewIfModule = ScrollModule;
    exports.ScrollIntoViewIfDirective = ScrollIntoViewIfDirective;
    exports.ScrollIntoViewDirective = ScrollIntoViewDirective;
    exports.ScrollIntoViewService = ScrollIntoViewService;
    exports.ScrollModule = ScrollModule;
    exports.SelectionItemDirective = SelectionItemDirective;
    exports.SelectionDirective = SelectionDirective;
    exports.SelectionModule = SelectionModule;
    exports.SelectionService = SelectionService;
    exports.SelectionStrategy = SelectionStrategy;
    exports.ContactsNg1Component = ContactsNg1Component;
    exports.ExpandInputNg1Component = ExpandInputNg1Component;
    exports.FloatingActionButtonNg1Component = FloatingActionButtonNg1Component;
    exports.FlotNg1Component = FlotNg1Component;
    exports.GridNg1Component = GridNg1Component;
    exports.HierarchyBarNg1Component = HierarchyBarNg1Component;
    exports.MarqueeWizardNg1Component = MarqueeWizardNg1Component;
    exports.NestedDonutNg1Component = NestedDonutNg1Component;
    exports.OrganizationChartNg1Component = OrganizationChartNg1Component;
    exports.PartitionMapNg1Component = PartitionMapNg1Component;
    exports.PeityBarChartNg1Component = PeityBarChartNg1Component;
    exports.PeityLineChartNg1Component = PeityLineChartNg1Component;
    exports.PeityPieChartNg1Component = PeityPieChartNg1Component;
    exports.PeityUpdatingLineChartNg1Component = PeityUpdatingLineChartNg1Component;
    exports.SankeyNg1Component = SankeyNg1Component;
    exports.SearchToolbarNg1Component = SearchToolbarNg1Component;
    exports.SelectTableNg1Component = SelectTableNg1Component;
    exports.SLIDER_CHART_VALUE_ACCESSOR = SLIDER_CHART_VALUE_ACCESSOR;
    exports.SliderChartNg1Component = SliderChartNg1Component;
    exports.SocialChartNg1Component = SocialChartNg1Component;
    exports.SortDirectionToggleNg1Component = SortDirectionToggleNg1Component;
    exports.TreeGridNg1Component = TreeGridNg1Component;
    exports.ThumbnailNg1Component = ThumbnailNg1Component;
    exports.NavigationMenuService = NavigationMenuService;
    exports.navigationMenuServiceFactory = navigationMenuServiceFactory;
    exports.navigationMenuServiceProvider = navigationMenuServiceProvider;
    exports.PdfService = PdfService;
    exports.pdfServiceFactory = pdfServiceFactory;
    exports.pdfServiceProvider = pdfServiceProvider;
    exports.TimeAgoService = TimeAgoService;
    exports.timeAgoServiceFactory = timeAgoServiceFactory;
    exports.timeAgoServiceProvider = timeAgoServiceProvider;
    exports.HybridModule = HybridModule;
    exports.DurationPipeModule = DurationPipeModule;
    exports.DurationPipe = DurationPipe;
    exports.FileSizePipeModule = FileSizePipeModule;
    exports.FileSizePipe = FileSizePipe;
    exports.StringFilterPipe = StringFilterPipe;
    exports.StringFilterModule = StringFilterModule;
    exports.AudioServiceModule = AudioServiceModule;
    exports.AudioService = AudioService;
    exports.ColorServiceModule = ColorServiceModule;
    exports.ColorService = ColorService;
    exports.ThemeColor = ThemeColor;
    exports.colorSets = colorSets;
    exports.FrameExtractionModule = FrameExtractionModule;
    exports.FrameExtractionService = FrameExtractionService;
    exports.PersistentDataModule = PersistentDataModule;
    exports.PersistentDataService = PersistentDataService;
    exports.PersistentDataStorageType = PersistentDataStorageType;
    exports.StorageAdapter = StorageAdapter;
    exports.CookieAdapter = CookieAdapter;
    exports.LocalStorageAdapter = LocalStorageAdapter;
    exports.SessionStorageAdapter = SessionStorageAdapter;
    exports.d = DayViewComponent;
    exports.e = DayViewService;
    exports.c = HeaderComponent;
    exports.f = MonthViewComponent;
    exports.g = MonthViewService;
    exports.j = TimeViewComponent;
    exports.h = YearViewComponent;
    exports.i = YearViewService;
    exports.m = FacetCheckListItemComponent;
    exports.n = FacetTypeaheadListItemComponent;
    exports.q = FloatingActionButtonsService;
    exports.s = MarqueeWizardService;
    exports.t = MediaPlayerService;
    exports.w = PageHeaderNavigationDropdownItemComponent;
    exports.v = PageHeaderNavigationItemComponent;
    exports.x = PageHeaderNavigationSecondaryItemDirective;
    exports.u = PageHeaderService;
    exports.r = SidePanelService;
    exports.l = TypeaheadHighlightDirective;
    exports.k = TypeaheadService;
    exports.y = HoverActionService;
    exports.p = MenuNavigationToggleDirective;
    exports.o = MenuNavigationService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXgtYXNwZWN0cy11eC1hc3BlY3RzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlc2l6ZS9yZXNpemUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlc2l6ZS9yZXNpemUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jYXJkLXRhYnMvY2FyZC10YWIvY2FyZC10YWItY29udGVudC5kaXJlY3RpdmUudHMiLG51bGwsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYnMuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jYXJkLXRhYnMvY2FyZC10YWJzZXQvY2FyZC10YWJzZXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY2FyZC10YWJzL2NhcmQtdGFicy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQtc3ViamVjdC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC11dGlscy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC16b25lLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LXpvbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC5kZWNvcmF0b3IudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9kcmFnL2RyYWcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2RyYWctaGFuZGxlL2RyYWctaGFuZGxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2RyYWcvZHJhZy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RpbWUtcGlja2VyL3RpbWUtZm9ybWF0LnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIudXRpbHMudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIuY29uZmlnLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXktdmlldy9kYXktdmlldy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXktdmlldy9kYXktdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2hlYWRlci9oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9tb250aC12aWV3L21vbnRoLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvbW9udGgtdmlldy9tb250aC12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvdGltZS12aWV3L3RpbWUtdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL3llYXItdmlldy95ZWFyLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIveWVhci12aWV3L3llYXItdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mb2N1cy1pZi9mb2N1cy1pZi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mb2N1cy1pZi9mb2N1cy1pZi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZWJveC9lYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Vib3gvZWJveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLWtleS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2Nyb2xsL3Njcm9sbC1pbnRvLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LWlmLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC1oaWdobGlnaHQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS1oYW5kbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvcmVvcmRlcmFibGUtbW9kZWwuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvZHJhZ3VsYS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtZXZlbnRzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2Jhc2UvZmFjZXQtaGVhZGVyL2ZhY2V0LWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtY2hlY2stbGlzdC9jaGVjay1saXN0LWl0ZW0vZmFjZXQtY2hlY2stbGlzdC1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZhY2V0cy9mYWNldC1jaGVjay1saXN0L2ZhY2V0LWNoZWNrLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LXR5cGVhaGVhZC1saXN0L3R5cGVhaGVhZC1saXN0LWl0ZW0vZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtdHlwZWFoZWFkLWxpc3QvZmFjZXQtdHlwZWFoZWFkLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0cy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvbW9kZWxzL2ZhY2V0LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1kcm9wZG93bi9maWx0ZXItZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXItZHluYW1pYy9maWx0ZXItZHluYW1pYy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbGlwcGFibGUtY2FyZC9mbGlwcGFibGUtY2FyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbGlwcGFibGUtY2FyZC9mbGlwcGFibGUtY2FyZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9oaWVyYXJjaHktYmFyL2hpZXJhcmNoeS1iYXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlL2NsaWNrLW91dHNpZGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvY2xpY2stb3V0c2lkZS9jbGljay1vdXRzaWRlLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wb3BvdmVyL3BvcG92ZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcG9wb3Zlci9wb3BvdmVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zaWRlLXBhbmVsL3NpZGUtcGFuZWwuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9pdGVtLWRpc3BsYXktcGFuZWwvaXRlbS1kaXNwbGF5LXBhbmVsLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2l0ZW0tZGlzcGxheS1wYW5lbC9pdGVtLWRpc3BsYXktcGFuZWwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvd2l6YXJkL3dpemFyZC1zdGVwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3dpemFyZC93aXphcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvd2l6YXJkL3dpemFyZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWFycXVlZS13aXphcmQvbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvYXVkaW8vYXVkaW8uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9hdWRpby9hdWRpby5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvZnJhbWUtZXh0cmFjdGlvbi9mcmFtZS1leHRyYWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvZnJhbWUtZXh0cmFjdGlvbi9mcmFtZS1leHRyYWN0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21lZGlhLXBsYXllci9tZWRpYS1wbGF5ZXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21lZGlhLXBsYXllci9tZWRpYS1wbGF5ZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL2V4dGVuc2lvbnMvYmFzZS1leHRlbnNpb24uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL2V4dGVuc2lvbnMvdGltZWxpbmUvdGltZWxpbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL2V4dGVuc2lvbnMvY29udHJvbHMvY29udHJvbHMuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL2R1cmF0aW9uL2R1cmF0aW9uLnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZHVyYXRpb24vZHVyYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL2ZpbGUtc2l6ZS9maWxlLXNpemUucGlwZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9maWxlLXNpemUvZmlsZS1zaXplLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21lZGlhLXBsYXllci9tZWRpYS1wbGF5ZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25hdmlnYXRpb24vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL2NvbG9yL2NvbG9yLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvY29sb3IvY29sb3IubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbnVtYmVyLXBpY2tlci9udW1iZXItcGlja2VyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL251bWJlci1waWNrZXIvbnVtYmVyLXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9jdXN0b20tbWVudS9jdXN0b20tbWVudS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvaWNvbi1tZW51L2ljb24tbWVudS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9uYXZpZ2F0aW9uL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS9uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWl0ZW0vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL25hdmlnYXRpb24vbmF2aWdhdGlvbi1zZWNvbmRhcnktaXRlbS9uYXZpZ2F0aW9uLXNlY29uZGFyeS1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Byb2dyZXNzLWJhci9wcm9ncmVzcy1iYXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcmFkaW9idXR0b24vcmFkaW9idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcmFkaW9idXR0b24vcmFkaW9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLWdyb3VwL3NlYXJjaC1idWlsZGVyLWdyb3VwLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci1vdXRsZXQvc2VhcmNoLWJ1aWxkZXItb3V0bGV0LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL2Jhc2Utc2VhcmNoLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL3RleHQvdGV4dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9kYXRlL2RhdGUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWNvbXBvbmVudHMvZGF0ZS1yYW5nZS9kYXRlLXJhbmdlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWctaW5wdXQvdGFnLWlucHV0LWV2ZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFnLWlucHV0L3RhZy1pbnB1dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWctaW5wdXQvdGFnLWlucHV0Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLWNsb3NlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zbGlkZXIvc2xpZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc3Bhcmsvc3BhcmsuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc3Bhcmsvc3BhcmsubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYnNldC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWItZm9jdXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWItaGVhZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJzZXQvdGFic2V0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWJzZXQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUtZXZlbnQvdGltZWxpbmUtZXZlbnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9nZ2xlc3dpdGNoL3RvZ2dsZXN3aXRjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b2dnbGVzd2l0Y2gvdG9nZ2xlc3dpdGNoLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLWJ1dHRvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC1maWVsZC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvZGlyZWN0aXZlcy92aXJ0dWFsLXNjcm9sbC1sb2FkLWJ1dHRvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvdmlydHVhbC1zY3JvbGwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvdmlydHVhbC1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYXV0by1ncm93L2F1dG8tZ3Jvdy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9hdXRvLWdyb3cvYXV0by1ncm93Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2ZpeGVkLWhlYWRlci10YWJsZS9maXhlZC1oZWFkZXItdGFibGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvZml4ZWQtaGVhZGVyLXRhYmxlL2ZpeGVkLWhlYWRlci10YWJsZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mbG9hdC1sYWJlbC9mbG9hdC1sYWJlbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mbG9hdC1sYWJlbC9mbG9hdC1sYWJlbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvaGVscC1jZW50ZXIvaGVscC1jZW50ZXItaXRlbS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLWNvbnRhaW5lci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2xheW91dC1zd2l0Y2hlci9sYXlvdXQtc3dpdGNoZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9vYnNlcnZlcnMvb3ZlcmZsb3cvb3ZlcmZsb3ctb2JzZXJ2ZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvb2JzZXJ2ZXJzL29ic2VydmVycy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9yb3ctc2VsZWN0aW9uLnN0cmF0ZWd5LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3N0cmF0ZWdpZXMvcm93LWFsdC1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9zaW1wbGUtc2VsZWN0aW9uLnN0cmF0ZWd5LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zZWxlY3Rpb24uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvY29udGFjdHMvY29udGFjdHMuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2V4cGFuZC1pbnB1dC9leHBhbmQtaW5wdXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvZmxvdC9mbG90LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9ncmlkL2dyaWQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvbWFycXVlZS13aXphcmQvbWFycXVlZS13aXphcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL25lc3RlZC1kb251dC9uZXN0ZWQtZG9udXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL29yZ2FuaXphdGlvbi1jaGFydC9vcmdhbml6YXRpb24tY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BhcnRpdGlvbi1tYXAvcGFydGl0aW9uLW1hcC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktYmFyLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1saW5lLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1waWUtY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LXVwZGF0aW5nLWxpbmUtY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NhbmtleS1jaGFydC9zYW5rZXkuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NlYXJjaC10b29sYmFyL3NlYXJjaC10b29sYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zZWxlY3QtdGFibGUvc2VsZWN0LXRhYmxlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zbGlkZXItY2hhcnQvc2xpZGVyLWNoYXJ0LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zb2NpYWwtY2hhcnQvc29jaWFsLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zb3J0LWRpcmVjdGlvbi10b2dnbGUvc29ydC1kaXJlY3Rpb24tdG9nZ2xlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy90cmVlLWdyaWQvdHJlZS1ncmlkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy90aHVtYm5haWwvdGh1bWJuYWlsLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvc2VydmljZXMvbmF2aWdhdGlvbi1tZW51L25hdmlnYXRpb24tbWVudS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9zZXJ2aWNlcy9wZGYvcGRmLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL3NlcnZpY2VzL3RpbWUtYWdvL3RpbWUtYWdvLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2h5YnJpZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvc3RyaW5nLWZpbHRlci9zdHJpbmctZmlsdGVyLnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvc3RyaW5nLWZpbHRlci9zdHJpbmctZmlsdGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvYWRhcHRlcnMvY29va2llLWFkYXB0ZXIudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL2FkYXB0ZXJzL2xvY2FsLXN0b3JhZ2UtYWRhcHRlci50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvYWRhcHRlcnMvc2Vzc2lvbi1zdG9yYWdlLWFkYXB0ZXIudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL3BlcnNpc3RlbnQtZGF0YS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9wZXJzaXN0ZW50LWRhdGEubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9hZGFwdGVycy9zdG9yYWdlLWFkYXB0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWJyZWFkY3J1bWJzJyxcbiAgICB0ZW1wbGF0ZTogYDxuYXYgYXJpYS1sYWJlbD1cIkJyZWFkY3J1bWJcIj5cbiAgICA8b2wgY2xhc3M9XCJicmVhZGNydW1iXCI+XG4gICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgY3J1bWIgb2YgY3J1bWJzXCI+XG5cbiAgICAgICAgICAgIDwhLS0gSWYgdGhlcmUgaXMgYSByb3V0ZXIgbGluayB0aGVuIHVzZSBhIHRhZyAtLT5cbiAgICAgICAgICAgIDxhICpuZ0lmPVwiY3J1bWIucm91dGVyTGluayB8fCBjcnVtYi5vbkNsaWNrXCJcbiAgICAgICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgIFtyb3V0ZXJMaW5rXT1cImNydW1iLnJvdXRlckxpbmtcIlxuICAgICAgICAgICAgICAgIFtmcmFnbWVudF09XCJjcnVtYi5mcmFnbWVudFwiXG4gICAgICAgICAgICAgICAgW3F1ZXJ5UGFyYW1zXT1cImNydW1iLnF1ZXJ5UGFyYW1zXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2xpY2tDcnVtYigkZXZlbnQsIGNydW1iKVwiPlxuICAgICAgICAgICAgICAgIHt7IGNydW1iLnRpdGxlIH19XG4gICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDwhLS0gSWYgdGhlcmUgaXMgbm90IHJvdXRlciBsaW5rIHRoZW4gZGlzcGxheSB0ZXh0IGluIGEgc3BhbiAtLT5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiIWNydW1iLnJvdXRlckxpbmsgJiYgIWNydW1iLm9uQ2xpY2tcIj57eyBjcnVtYi50aXRsZSB9fTwvc3Bhbj5cbiAgICAgICAgPC9saT5cbiAgICA8L29sPlxuPC9uYXY+YFxufSlcblxuZXhwb3J0IGNsYXNzIEJyZWFkY3J1bWJzQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGNydW1iczogQnJlYWRjcnVtYltdO1xuXG4gICAgY2xpY2tDcnVtYihldmVudDogTW91c2VFdmVudCwgY3J1bWI6IEJyZWFkY3J1bWIpIHtcbiAgICAgICAgaWYgKGNydW1iLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIGNydW1iLm9uQ2xpY2suY2FsbChudWxsLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJlYWRjcnVtYiB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICByb3V0ZXJMaW5rPzogc3RyaW5nO1xuICAgIGZyYWdtZW50Pzogc3RyaW5nO1xuICAgIHF1ZXJ5UGFyYW1zPzogYW55O1xuICAgIG9uQ2xpY2s/OiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQ7XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQnJlYWRjcnVtYnNDb21wb25lbnQgfSBmcm9tICcuL2JyZWFkY3J1bWJzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSwgXG4gICAgICAgIFJvdXRlck1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW0JyZWFkY3J1bWJzQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtCcmVhZGNydW1ic0NvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYnNNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUsIE9uRGVzdHJveSwgUmVuZGVyZXIyLCBSZW5kZXJlckZhY3RvcnkyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUmVzaXplU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MiwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlckZhY3RvcnkuY3JlYXRlUmVuZGVyZXIobnVsbCwgbnVsbCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGFkZFJlc2l6ZUxpc3RlbmVyKG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQmVoYXZpb3JTdWJqZWN0PFJlc2l6ZURpbWVuc2lvbnM+IHtcblxuICAgICAgICAvLyBjcmVhdGUgYSBiZWhhdmlvciBzdWJqZWN0IHN1YmplY3RcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UmVzaXplRGltZW5zaW9ucz4oeyB3aWR0aDogbmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBuYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCB9KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHN0eWxlIG9mIHRoZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IGRpc3BsYXlNb2RlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobmF0aXZlRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgaWZyYW1lIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaWZyYW1lOiBIVE1MSUZyYW1lRWxlbWVudCA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXG4gICAgICAgIC8vIHN0eWxlIHRoZSBpZnJhbWUgdG8gYmUgaW52aXNpYmxlIGJ1dCBmaWxsIGNvbnRhaW5pbmcgZWxlbWVudFxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3RvcCcsICcwJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3JpZ2h0JywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnYm90dG9tJywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnbGVmdCcsICcwJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3otaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnb3BhY2l0eScsICcwJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ2JvcmRlcicsICdub25lJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ21hcmdpbicsICcwJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBpZnJhbWUgaWdub3JlcyBhbnkgdGFiYmluZ1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoaWZyYW1lLCAndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGlmcmFtZSwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMgbmVlZCBjaGFuZ2VkIHRvIHJlbGF0aXZlIGZvciB0aGlzIG1ldGhvZCB0byB3b3JrXG4gICAgICAgIGlmIChkaXNwbGF5TW9kZSAhPT0gJ3JlbGF0aXZlJyAmJiBkaXNwbGF5TW9kZSAhPT0gJ2Fic29sdXRlJyAmJiBkaXNwbGF5TW9kZSAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUobmF0aXZlRWxlbWVudCwgJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIGlmcmFtZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYXBwZW5kQ2hpbGQobmF0aXZlRWxlbWVudCwgaWZyYW1lKTtcblxuICAgICAgICB0aGlzLndhaXRVbnRpbFJlYWR5KGlmcmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWZyYW1lRG9jID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudCB8fCBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudCBhcyBEb2N1bWVudDtcblxuICAgICAgICAgICAgY29uc3QgYXR0YWNoTGlzdGVuZXIgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyB3YXRjaCBmb3IgYW55IGZ1dHVyZSByZXNpemVzIC0gcnVuIGluc2lkZSBuZ3pvbmUgYXMgYW4gaWZyYW1lIGV2ZW50IGxpc3RlbmVyIGlzIG5vdCBwYXRjaGVkXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChmcm9tRXZlbnQoaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnKS5zdWJzY3JpYmUoKGV2ZW50OiBSZXNpemVEaW1lbnNpb25zKSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHN1YmplY3QubmV4dCh7IHdpZHRoOiBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoLCBoZWlnaHQ6IG5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IH0pKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGlmcmFtZURvYy5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBpZnJhbWUgdG8gbG9hZFxuICAgICAgICAgICAgICAgIGlmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4gYXR0YWNoTGlzdGVuZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB3YWl0VW50aWxSZWFkeShpZnJhbWU6IEhUTUxJRnJhbWVFbGVtZW50LCBjYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCB8fCBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy53YWl0VW50aWxSZWFkeShpZnJhbWUsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzaXplRGltZW5zaW9ucyB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE5nWm9uZSwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgUmVzaXplRGltZW5zaW9ucywgUmVzaXplU2VydmljZSB9IGZyb20gJy4vcmVzaXplLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFJlc2l6ZV0nLFxuICAgIHByb3ZpZGVyczogW1Jlc2l6ZVNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFJlc2l6ZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHRocm90dGxlOiBudW1iZXIgPSAwO1xuICAgIEBPdXRwdXQoKSB1eFJlc2l6ZTogRXZlbnRFbWl0dGVyPFJlc2l6ZURpbWVuc2lvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcjxSZXNpemVEaW1lbnNpb25zPigpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlLCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fcmVzaXplU2VydmljZS5hZGRSZXNpemVMaXN0ZW5lcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgICAgICAucGlwZShkZWJvdW5jZVRpbWUodGhpcy50aHJvdHRsZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChldmVudDogUmVzaXplRGltZW5zaW9ucykgPT4gdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLnV4UmVzaXplLmVtaXQoZXZlbnQpKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBSZXNpemVEaXJlY3RpdmUgfSBmcm9tICcuL3Jlc2l6ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4vcmVzaXplLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtSZXNpemVEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW1Jlc2l6ZURpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbUmVzaXplU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgUmVzaXplTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eENhcmRUYWJDb250ZW50XSdcbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmUgeyB9XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDYXJkVGFiQ29tcG9uZW50IH0gZnJvbSAnLi9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ2FyZFRhYnNTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICB0YWIkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDYXJkVGFiQ29tcG9uZW50PihudWxsKTtcbiAgdGFicyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PENhcmRUYWJDb21wb25lbnRbXT4oW10pO1xuICBwb3NpdGlvbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4oJ3RvcCcpO1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgLy8gd2hlbiBhIHRhYiBpcyBhZGRlZCBvciByZW1vdmVkIGVuc3VyZSB3ZSBhbHdheXMgc2VsZWN0IG9uZSBpZiBhbnkgYXJlIGF2YWlsYWJsZVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMudGFicyQucGlwZShcbiAgICAgIGZpbHRlcih0YWJzID0+ICF0aGlzLnRhYiQudmFsdWUgfHwgIXRhYnMuZmluZCh0YWIgPT4gdGFiID09PSB0aGlzLnRhYiQudmFsdWUpKSxcbiAgICApLnN1YnNjcmliZSh0YWJzID0+IHRoaXMudGFiJC5uZXh0KHRhYnMubGVuZ3RoID4gMCA/IHRhYnNbMF0gOiBudWxsKSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0YWIgdG8gdGhlIGxpc3Qgb2YgdGFic1xuICAgKi9cbiAgYWRkVGFiKHRhYjogQ2FyZFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgIHRoaXMudGFicyQubmV4dChbLi4udGhpcy50YWJzJC52YWx1ZSwgdGFiXSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFiIGZyb20gdGhlIGxpc3RcbiAgICovXG4gIHJlbW92ZVRhYih0YWI6IENhcmRUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICB0aGlzLnRhYnMkLm5leHQodGhpcy50YWJzJC52YWx1ZS5maWx0ZXIoX3RhYiA9PiBfdGFiICE9PSB0YWIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgdGhlIHRhYlxuICAgKi9cbiAgc2VsZWN0KHRhYjogQ2FyZFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgIHRoaXMudGFiJC5uZXh0KHRhYik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGFiIGNvbnRlbnRcbiAgICovXG4gIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnBvc2l0aW9uJC5uZXh0KHBvc2l0aW9uKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENhcmRUYWJzU2VydmljZSB9IGZyb20gJy4uL2NhcmQtdGFicy5zZXJ2aWNlJztcbmltcG9ydCB7IENhcmRUYWJDb250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi9jYXJkLXRhYi1jb250ZW50LmRpcmVjdGl2ZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LWNhcmQtdGFiJyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudCAqbmdJZj1cImFjdGl2ZSQgfCBhc3luY1wiPjwvbmctY29udGVudD5gLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDYXJkVGFiQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBhY3RpdmUkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5fdGFiU2VydmljZS50YWIkLnBpcGUobWFwKHRhYiA9PiB0YWIgPT09IHRoaXMpKTtcbiAgQENvbnRlbnRDaGlsZChDYXJkVGFiQ29udGVudERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBjb250ZW50OiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYlNlcnZpY2U6IENhcmRUYWJzU2VydmljZSkge1xuICAgIHRoaXMuX3RhYlNlcnZpY2UuYWRkVGFiKHRoaXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fdGFiU2VydmljZS5yZW1vdmVUYWIodGhpcyk7XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplRGltZW5zaW9ucyB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplJztcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuLi9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ2FyZFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi4vY2FyZC10YWJzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1jYXJkLXRhYnNldCcsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImNhcmQtdGFiLWNvbnRlbnRcIiByb2xlPVwidGFicGFuZWxcIiAqbmdJZj1cIih0YWJTZXJ2aWNlLnRhYiQgfCBhc3luYylcIj5cclxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuPC9kaXY+XHJcblxyXG48ZGl2IGNsYXNzPVwiY2FyZC10YWJzXCIgI3RhYnM+XHJcblxyXG4gICAgPGJ1dHRvbiBjbGFzcz1cImNhcmQtdGFicy1wYWdpbmctYnRuIGNhcmQtdGFicy1wYWdpbmctYnRuLXByZXZpb3VzXCIgYXJpYS1sYWJlbD1cIlByZXZpb3VzIFRhYnNcIiAoY2xpY2spPVwicHJldmlvdXMoKVwiICpuZ0lmPVwib2Zmc2V0IDwgYm91bmRzLmxvd2VyXCI+XHJcbiAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtcHJldmlvdXNcIj48L2k+XHJcbiAgICA8L2J1dHRvbj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC10YWJzLWxpc3RcIiByb2xlPVwidGFibGlzdFwiICN0YWJsaXN0ICh1eFJlc2l6ZSk9XCJyZXNpemUoJGV2ZW50KVwiIFtzdHlsZS50cmFuc2Zvcm1dPVwiJ3RyYW5zbGF0ZVgoJyArIG9mZnNldCArICdweCknXCI+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLXRhYlwiXHJcbiAgICAgICAgICAgIHJvbGU9XCJ0YWJcIlxyXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIiAjY2FyZFxyXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYlNlcnZpY2UudGFicyQgfCBhc3luY1wiXHJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInRhYlNlcnZpY2UucG9zaXRpb24kIHwgYXN5bmNcIlxyXG4gICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cInRhYi5hY3RpdmUkIHwgYXN5bmNcIlxyXG4gICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cInRhYi5hY3RpdmUkIHwgYXN5bmNcIlxyXG4gICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0KHRhYiwgY2FyZClcIlxyXG4gICAgICAgICAgICAoZm9jdXMpPVwidGFicy5zY3JvbGxMZWZ0ID0gMFwiXHJcbiAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cInNlbGVjdCh0YWIsIGNhcmQpXCI+XHJcblxyXG4gICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYi5jb250ZW50XCI+PC9uZy1jb250YWluZXI+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPGJ1dHRvbiBjbGFzcz1cImNhcmQtdGFicy1wYWdpbmctYnRuIGNhcmQtdGFicy1wYWdpbmctYnRuLW5leHRcIiBhcmlhLWxhYmVsPVwiTmV4dCBUYWJzXCIgKGNsaWNrKT1cIm5leHQoKVwiICpuZ0lmPVwib2Zmc2V0ID4gYm91bmRzLnVwcGVyXCI+XHJcbiAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtbmV4dFwiPjwvaT5cclxuICAgIDwvYnV0dG9uPlxyXG48L2Rpdj5gLFxuICBwcm92aWRlcnM6IFtDYXJkVGFic1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIENhcmRUYWJzZXRDb21wb25lbnQge1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICBASW5wdXQoKSBzZXQgcG9zaXRpb24oZGlyZWN0aW9uOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRhYlNlcnZpY2Uuc2V0UG9zaXRpb24oZGlyZWN0aW9uKTtcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnRhYlNlcnZpY2UucG9zaXRpb24kLmdldFZhbHVlKCk7XG4gIH1cblxuICBAVmlld0NoaWxkKCd0YWJsaXN0JykgdGFibGlzdDogRWxlbWVudFJlZjtcblxuICBvZmZzZXQ6IG51bWJlciA9IDA7XG4gIGJvdW5kczogQ2FyZFRhYnNCb3VuZHMgPSB7IGxvd2VyOiAwLCB1cHBlcjogMCB9O1xuXG4gIHByaXZhdGUgX3dpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgX2lubmVyV2lkdGg6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFiU2VydmljZTogQ2FyZFRhYnNTZXJ2aWNlKSB7fVxuXG4gIHNlbGVjdCh0YWI6IENhcmRUYWJDb21wb25lbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgLy8gc2VsZWN0IHRoZSB0YWJcbiAgICB0aGlzLnRhYlNlcnZpY2Uuc2VsZWN0KHRhYik7XG5cbiAgICAvLyBlbnN1cmUgdGhlIHRhYiBpcyBtb3ZlZCBpbnRvIHZpZXcgaWYgcmVxdWlyZWRcbiAgICB0aGlzLm1vdmVJbnRvVmlldyhlbGVtZW50KTtcbiAgfVxuXG4gIHJlc2l6ZShkaW1lbnNpb25zOiBSZXNpemVEaW1lbnNpb25zKTogdm9pZCB7XG4gICAgdGhpcy5fd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgIHRoaXMuX2lubmVyV2lkdGggPSB0aGlzLnRhYmxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aDtcblxuICAgIHRoaXMuYm91bmRzLmxvd2VyID0gMDtcbiAgICB0aGlzLmJvdW5kcy51cHBlciA9IC0odGhpcy5faW5uZXJXaWR0aCAtIHRoaXMuX3dpZHRoKTtcbiAgfVxuXG4gIHByZXZpb3VzKCk6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0ICs9IHRoaXMuX3dpZHRoO1xuXG4gICAgLy8gZW5zdXJlIGl0IHJlbWFpbnMgd2l0aGluIHRoZSBhbGxvd2VkIGJvdW5kc1xuICAgIHRoaXMub2Zmc2V0ID0gTWF0aC5taW4odGhpcy5vZmZzZXQsIHRoaXMuYm91bmRzLmxvd2VyKTtcbiAgfVxuXG4gIG5leHQoKTogdm9pZCB7XG4gICAgdGhpcy5vZmZzZXQgLT0gdGhpcy5fd2lkdGg7XG5cbiAgICAvLyBlbnN1cmUgaXQgcmVtYWlucyB3aXRoaW4gdGhlIGFsbG93ZWQgYm91bmRzXG4gICAgdGhpcy5vZmZzZXQgPSBNYXRoLm1heCh0aGlzLm9mZnNldCwgdGhpcy5ib3VuZHMudXBwZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBtb3ZlSW50b1ZpZXcoZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcblxuICAgIC8vIGlmIHdlIGRvbnQgaGF2ZSB0aGUgZGltZW5zaW9ucyB3ZSBjYW50IGNoZWNrXG4gICAgaWYgKCF0aGlzLl93aWR0aCB8fCAhdGhpcy5faW5uZXJXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgY3VycmVudCBlbGVtZW50IGJvdW5kc1xuICAgIGNvbnN0IHsgb2Zmc2V0TGVmdCwgb2Zmc2V0V2lkdGggfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgeyBtYXJnaW5MZWZ0LCBtYXJnaW5SaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdmlzaWJsZSBhcmVhXG4gICAgY29uc3Qgdmlld3BvcnRTdGFydCA9IE1hdGguYWJzKHRoaXMub2Zmc2V0KTtcbiAgICBjb25zdCB2aWV3cG9ydEVuZCA9IHZpZXdwb3J0U3RhcnQgKyB0aGlzLl93aWR0aDtcbiAgICBjb25zdCBjYXJkV2lkdGggPSBwYXJzZUZsb2F0KG1hcmdpbkxlZnQpICsgb2Zmc2V0V2lkdGggKyBwYXJzZUZsb2F0KG1hcmdpblJpZ2h0KTtcblxuICAgIC8vIGlmIHdlIG5lZWQgdG8gbW92ZSB0byB0aGUgbGVmdCAtIGZpZ3VyZSBvdXQgaG93IG11Y2hcbiAgICBpZiAob2Zmc2V0TGVmdCA8IHZpZXdwb3J0U3RhcnQpIHtcbiAgICAgIHRoaXMub2Zmc2V0IC09IChvZmZzZXRMZWZ0IC0gcGFyc2VGbG9hdChtYXJnaW5MZWZ0KSkgLSB2aWV3cG9ydFN0YXJ0O1xuICAgIH1cbiAgICBcbiAgICAvLyBpZiB3ZSBuZWVkIHRvIG1vdmUgdG8gdGhlIHJpZ2h0IC0gZmlndXJlIG91dCBob3cgbXVjaFxuICAgIGlmICgob2Zmc2V0TGVmdCArIGNhcmRXaWR0aCkgPiB2aWV3cG9ydEVuZCkge1xuICAgICAgdGhpcy5vZmZzZXQgLT0gKG9mZnNldExlZnQgKyBjYXJkV2lkdGgpIC0gdmlld3BvcnRFbmQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FyZFRhYnNCb3VuZHMge1xuICBsb3dlcjogbnVtYmVyO1xuICB1cHBlcjogbnVtYmVyO1xufVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xyXG5pbXBvcnQgeyBDYXJkVGFiQ29udGVudERpcmVjdGl2ZSB9IGZyb20gJy4vY2FyZC10YWIvY2FyZC10YWItY29udGVudC5kaXJlY3RpdmUnO1xyXG5pbXBvcnQgeyBDYXJkVGFiQ29tcG9uZW50IH0gZnJvbSAnLi9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBDYXJkVGFic2V0Q29tcG9uZW50IH0gZnJvbSAnLi9jYXJkLXRhYnNldC9jYXJkLXRhYnNldC5jb21wb25lbnQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBpbXBvcnRzOiBbXHJcbiAgICBDb21tb25Nb2R1bGUsXHJcbiAgICBSZXNpemVNb2R1bGVcclxuICBdLFxyXG4gIGRlY2xhcmF0aW9uczogW0NhcmRUYWJzZXRDb21wb25lbnQsIENhcmRUYWJDb21wb25lbnQsIENhcmRUYWJDb250ZW50RGlyZWN0aXZlXSxcclxuICBleHBvcnRzOiBbQ2FyZFRhYnNldENvbXBvbmVudCwgQ2FyZFRhYkNvbXBvbmVudCwgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmVdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDYXJkVGFic01vZHVsZSB7IH1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IENIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5sZXQgdW5pcXVlQ2hlY2tib3hJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtY2hlY2tib3gnLFxuICAgIHRlbXBsYXRlOiBgPGxhYmVsIFthdHRyLmZvcl09XCJpbnB1dElkXCJcbiAgICAgICBjbGFzcz1cInV4LWNoZWNrYm94XCJcbiAgICAgICBbY2xhc3MudXgtY2hlY2tib3gtY2hlY2tlZF09XCJ2YWx1ZSA9PT0gdHJ1ZVwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LWluZGV0ZXJtaW5hdGVdPVwiaW5kZXRlcm1pbmF0ZVwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LXNpbXBsaWZpZWRdPVwic2ltcGxpZmllZFwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbY2xhc3MudXgtY2hlY2tib3gtZm9jdXNlZF09XCJmb2N1c2VkXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtY2hlY2tib3gtY29udGFpbmVyXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgY2xhc3M9XCJ1eC1jaGVja2JveC1pbnB1dFwiXG4gICAgICAgICAgICAgICBbaWRdPVwiaW5wdXRJZFwiXG4gICAgICAgICAgICAgICBbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgW2F0dHIudmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiaW5kZXhcIlxuICAgICAgICAgICAgICAgW2luZGV0ZXJtaW5hdGVdPVwiaW5kZXRlcm1pbmF0ZVwiXG4gICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG4gICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiYXJpYUxhYmVsbGVkYnlcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1jaGVja2VkXT1cImFyaWFDaGVja2VkXCJcbiAgICAgICAgICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgICAgICAgICAoYmx1cik9XCJmb2N1c2VkID0gZmFsc2VcIlxuICAgICAgICAgICAgICAgKGNoYW5nZSk9XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSgpXCI+XG4gICAgPC9kaXY+XG5cbiAgICA8c3BhbiBjbGFzcz1cInV4LWNoZWNrYm94LWxhYmVsXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L3NwYW4+XG48L2xhYmVsPlxuYCxcbiAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBwcml2YXRlIF9jaGVja2JveElkOiBzdHJpbmcgPSBgdXgtY2hlY2tib3gtJHsrK3VuaXF1ZUNoZWNrYm94SWR9YDtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl9jaGVja2JveElkO1xuICAgIEBJbnB1dCgpIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgY2xpY2thYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzaW1wbGlmaWVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaW5kZXRlcm1pbmF0ZVZhbHVlOiBhbnkgPSAtMTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nID0gbnVsbDtcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgaXQgaXMgaW4gdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGVcbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gdGhpcy5fdmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gdGhpcy5pbmRldGVybWluYXRlID8gJ21peGVkJyA6IHRoaXMuX3ZhbHVlO1xuXG4gICAgICAgIC8vIGludm9rZSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRJZCgpOiBzdHJpbmcgeyBcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fY2hlY2tib3hJZH0taW5wdXRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnkgPSBmYWxzZTtcblxuICAgIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhcmlhQ2hlY2tlZDogYm9vbGVhbiB8IHN0cmluZztcbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLnZhbHVlID0gIXRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25zIHJlcXVpcmVkIHRvIHVwZGF0ZSBuZ01vZGVsXG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2hlY2tib3hDb21wb25lbnQgfSBmcm9tICcuL2NoZWNrYm94LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlXSxcbiAgICBleHBvcnRzOiBbQ2hlY2tib3hDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0NoZWNrYm94Q29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja2JveE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4Q29sdW1uU29ydGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIENvbHVtblNvcnRpbmdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgc2luZ2xlU29ydDogYm9vbGVhbjtcbiAgICBldmVudHMgPSBuZXcgU3ViamVjdDxDb2x1bW5Tb3J0aW5nT3JkZXJbXT4oKTtcbiAgICBvcmRlcjogQ29sdW1uU29ydGluZ09yZGVyW10gPSBbXTtcblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50cy5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHRvZ2dsZUNvbHVtbihzb3J0aW5nOiBDb2x1bW5Tb3J0aW5nT3JkZXIpOiBDb2x1bW5Tb3J0aW5nT3JkZXJbXSB7XG5cbiAgICAgICAgLy8gYXBwbHkgc29ydGluZyBiYXNlZCBvbiB0aGUgc2luZ2xlIG9yIG11bHRpcGxlIHNvcnRcbiAgICAgICAgdGhpcy5vcmRlciA9IHRoaXMuc2luZ2xlU29ydCA/IHRoaXMudG9nZ2xlU2luZ2xlQ29sdW1uKHNvcnRpbmcpIDogdGhpcy50b2dnbGVNdWx0aXBsZUNvbHVtbihzb3J0aW5nKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBsYXRlc3Qgb3JkZXJcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dCh0aGlzLm9yZGVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5vcmRlcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZVNpbmdsZUNvbHVtbihzb3J0aW5nOiBDb2x1bW5Tb3J0aW5nT3JkZXIpOiBDb2x1bW5Tb3J0aW5nT3JkZXJbXSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nLnN0YXRlID09PSBDb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0ID8gW10gOiBbeyBrZXk6IHNvcnRpbmcua2V5LCBzdGF0ZTogc29ydGluZy5zdGF0ZSB9XTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZU11bHRpcGxlQ29sdW1uKHNvcnRpbmc6IENvbHVtblNvcnRpbmdPcmRlcik6IENvbHVtblNvcnRpbmdPcmRlcltdIHtcbiAgICAgICAgLy8gcmVvcmRlciBjb2x1bW5zIGhlcmVcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5vcmRlci5maW5kSW5kZXgoY29sdW1uID0+IGNvbHVtbi5rZXkgPT09IHNvcnRpbmcua2V5KTtcblxuICAgICAgICAvLyBpZiB3YXNudCBwcmV2aW91c2x5IHNlbGVjdGVkIGFkZCB0byBsaXN0XG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMub3JkZXIsIHsga2V5OiBzb3J0aW5nLmtleSwgc3RhdGU6IHNvcnRpbmcuc3RhdGUgfV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhcmUgc29ydGluZyBpdCBjaGFuZ2UgdGhlIHNvcnRpbmcgb3JkZXJcbiAgICAgICAgaWYgKHNvcnRpbmcuc3RhdGUgPT09IENvbHVtblNvcnRpbmdTdGF0ZS5Bc2NlbmRpbmcgfHwgc29ydGluZy5zdGF0ZSA9PT0gQ29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpcy5vcmRlci5maWx0ZXIoX2NvbHVtbiA9PiBfY29sdW1uLmtleSAhPT0gc29ydGluZy5rZXkpLCB7IGtleTogc29ydGluZy5rZXksIHN0YXRlOiBzb3J0aW5nLnN0YXRlIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICByZXR1cm4gdGhpcy5vcmRlci5maWx0ZXIoX2NvbHVtbiA9PiBfY29sdW1uLmtleSAhPT0gc29ydGluZy5rZXkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5Tb3J0aW5nT3JkZXIge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHN0YXRlOiBDb2x1bW5Tb3J0aW5nU3RhdGU7XG59XG5cbmV4cG9ydCBlbnVtIENvbHVtblNvcnRpbmdTdGF0ZSB7XG4gICAgQXNjZW5kaW5nID0gJ2FzY2VuZGluZycsXG4gICAgRGVzY2VuZGluZyA9ICdkZXNjZW5kaW5nJyxcbiAgICBOb1NvcnQgPSAnbm9uZSdcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IENvbHVtblNvcnRpbmdEaXJlY3RpdmUsIENvbHVtblNvcnRpbmdPcmRlciwgQ29sdW1uU29ydGluZ1N0YXRlIH0gZnJvbSAnLi9jb2x1bW4tc29ydGluZy5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWNvbHVtbi1zb3J0aW5nJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1jb2x1bW4tc29ydGluZ1wiPlxuXG4gICAgPGkgY2xhc3M9XCJ1eC1jb2x1bW4tc29ydGluZy1pY29uIGhwZS1pY29uXCJcbiAgICAgICBbY2xhc3MuaHBlLWFzY2VuZF09XCJzdGF0ZSA9PT0gY29sdW1uU29ydGluZ1N0YXRlLkFzY2VuZGluZ1wiXG4gICAgICAgW2NsYXNzLmhwZS1kZXNjZW5kXT1cInN0YXRlID09PSBjb2x1bW5Tb3J0aW5nU3RhdGUuRGVzY2VuZGluZ1wiXG4gICAgICAgW2NsYXNzLmNvbHVtbi1zb3J0aW5nLWljb24taGlkZGVuXT1cInN0YXRlID09PSBjb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0XCI+XG4gICAgPC9pPlxuXG4gICAgPHAgY2xhc3M9XCJ1eC1jb2x1bW4tc29ydGluZy1udW1iZXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj57eyBvcmRlciB9fTwvcD5cbjwvZGl2PmAsXG4gICAgZXhwb3J0QXM6ICd1eC1jb2x1bW4tc29ydGluZydcbn0pXG5leHBvcnQgY2xhc3MgQ29sdW1uU29ydGluZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBzdGF0ZTogQ29sdW1uU29ydGluZ1N0YXRlO1xuICAgIEBJbnB1dCgpIGtleTogc3RyaW5nO1xuICAgIEBPdXRwdXQoKSBzdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Q29sdW1uU29ydGluZ1N0YXRlPigpO1xuXG4gICAgb3JkZXI6IG51bWJlcjtcbiAgICBjb2x1bW5Tb3J0aW5nU3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGU7XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfY29sdW1uU29ydGVyOiBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2NvbHVtblNvcnRlci5ldmVudHMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHNvcnRpbmcgdGhpcyBjb2x1bW4gdGhlbiBmaW5kIHRoZSBtYXRjaGluZyBkYXRhXG4gICAgICAgICAgICBjb25zdCBjb2x1bW5JZHggPSBldmVudC5maW5kSW5kZXgoX2NvbHVtbiA9PiBfY29sdW1uLmtleSA9PT0gdGhpcy5rZXkpO1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHNvcnRpbmcgdGhpcyBjb2x1bW4gdGhlbiBtYXJrIGl0IGFzIE5vU29ydFxuICAgICAgICAgICAgaWYgKGNvbHVtbklkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlLk5vU29ydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSBzdG9yZSB0aGUgbnVtYmVyIGlmIHdlIGhhdmUgMiBvciBtb3JlIGNvbHVtbnMgYmVpbmcgc29ydGVkXG4gICAgICAgICAgICB0aGlzLm9yZGVyID0gZXZlbnQubGVuZ3RoIDwgMiB8fCBjb2x1bW5JZHggPT09IC0xID8gbnVsbCA6IGNvbHVtbklkeCArIDE7XG5cbiAgICAgICAgICAgIC8vIEVtaXQgdGhlIGxhdGVzdCBjaGFuZ2VcbiAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UuZW1pdCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIGNoYW5nZVN0YXRlKCk6IENvbHVtblNvcnRpbmdPcmRlcltdIHtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcblxuICAgICAgICAgICAgY2FzZSBDb2x1bW5Tb3J0aW5nU3RhdGUuQXNjZW5kaW5nOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGUuRGVzY2VuZGluZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb2x1bW5Tb3J0aW5nU3RhdGUuRGVzY2VuZGluZzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlLk5vU29ydDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlLkFzY2VuZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluZm9ybSBwYXJlbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtblNvcnRlci50b2dnbGVDb2x1bW4oeyBrZXk6IHRoaXMua2V5LCBzdGF0ZTogdGhpcy5zdGF0ZSB9KTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sdW1uU29ydGluZ0NvbXBvbmVudCB9IGZyb20gJy4vY29sdW1uLXNvcnRpbmcuY29tcG9uZW50JztcblxuaW1wb3J0IHsgQ29sdW1uU29ydGluZ0RpcmVjdGl2ZSB9IGZyb20gJy4vY29sdW1uLXNvcnRpbmcuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbQ29sdW1uU29ydGluZ0NvbXBvbmVudCwgQ29sdW1uU29ydGluZ0RpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbQ29sdW1uU29ydGluZ0NvbXBvbmVudCwgQ29sdW1uU29ydGluZ0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgQ29sdW1uU29ydGluZ01vZHVsZSB7IH0iLCJpbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IENvbmR1aXRab25lIH0gZnJvbSAnLi9jb25kdWl0LXpvbmUuc2VydmljZSc7XG5pbXBvcnQgeyBDb25kdWl0RXZlbnQgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1ldmVudCc7XG5pbXBvcnQgeyBDb25kdWl0TWV0YWRhdGEgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1tZXRhZGF0YSc7XG5cbmV4cG9ydCBjbGFzcyBDb25kdWl0U3ViamVjdCB7XG5cbiAgICBwcml2YXRlIF9zdWJqZWN0OiBTdWJqZWN0PGFueT47XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEsIHByaXZhdGUgX3pvbmU6IENvbmR1aXRab25lLCBwdWJsaWMgem9uZUlkOiBzdHJpbmcpIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgdGFyZ2V0IHN1YmplY3Qgb2JqZWN0XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBjb25kdWl0LnN1YmplY3Q7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBjb25kdWl0cyB0aGF0IGhhdmUgc3VwcGxpZWQgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIHRoZSBzb3VyY2Ugc3ViamVjdFxuICAgICAgICB0aGlzLl9zdWJqZWN0LnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoY29uZHVpdC5jaGFuZ2VEZXRlY3Rpb24pLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5vbk91dHB1dC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIHpvbmUgZXZlbnRzIGFuZCByb290IHpvbmUgZXZlbnRzXG4gICAgICAgIF96b25lLmdldEV2ZW50cygpLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50LmNvbmR1aXQuaWQgPT09IGNvbmR1aXQuaWQpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25JbnB1dC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2sgYWxsIGFsbG93IGlucHV0cyB0byBzZWUgaWYgdGhlcmUgaXMgYSB2YWx1ZSB3ZSBzaG91bGQgaW5pdGlhbGx5IHNldCB0aGUgY29uZHVpdCB0byAqL1xuICAgIGdldEluaXRpYWxWYWx1ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB3ZSBkbyBub3QgYWNjZXB0IGlucHV0cyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gYWxsIHN1YmplY3RzIHRoYXQgYXJlIDEpIE5vdCBpdHNlbGYgMikgSW4gYSB6b25lIHRoYXQgaXMgbGlzdGVkIGluIGFjY2VwdHNJbnB1dCAzKSBIYXZlIGEgY3VycmVudFZhbHVlIHNldFxuICAgICAgICBjb25zdCBzdWJqZWN0cyA9IHRoaXMuX3pvbmUuZ2V0U3ViamVjdHMoKS5maWx0ZXIoc3ViamVjdCA9PiB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgaXRzZWxmIG9yIGlmIGl0IGhhcyBub3QgdmFsdWUgdG8gZ2l2ZSB1cyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmIChzdWJqZWN0ID09PSB0aGlzIHx8IHN1YmplY3QuY29uZHVpdC5pZCAhPT0gdGhpcy5jb25kdWl0LmlkIHx8ICFzdWJqZWN0LmNvbmR1aXQuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhY2NlcHRzSW5wdXQgaXMgdHJ1ZSB0aGVuIHdlIHJldHVybiBldmVyeSB0aW1lXG4gICAgICAgICAgICBpZiAodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0LmluZGV4T2Yoc3ViamVjdC56b25lSWQpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hdGNoZXMgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmIChzdWJqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBzb3J0IGJ5IHRoZSBsYXN0IG1vZGlmaWVkIGZpZWxkXG4gICAgICAgIHN1YmplY3RzLnNvcnQoKHN1YmplY3RPbmUsIHN1YmplY3RUd28pID0+IHN1YmplY3RPbmUuY29uZHVpdC5sYXN0TW9kaWZpZWQuZ2V0VGltZSgpIDwgc3ViamVjdFR3by5jb25kdWl0Lmxhc3RNb2RpZmllZC5nZXRUaW1lKCkgPyAxIDogLTEpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgbW9zdCByZWNlbnQgdmFsdWVcbiAgICAgICAgdGhpcy5fc3ViamVjdC5uZXh0KHN1YmplY3RzWzBdLmNvbmR1aXQuY3VycmVudFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogVGhpcyB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIGEgY29uZHVpdHMgdmFsdWUgaGFzIGNoYW5nZWQgKi9cbiAgICBvbklucHV0KGV2ZW50OiBDb25kdWl0RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgd2UgZG9udCBhY2NlcHQgaW5wdXQgb3Igd2UgZW1pdHRlZCB0aGlzIHZhbHVlIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCA9PT0gZmFsc2UgfHwgZXZlbnQuY29uZHVpdCA9PT0gdGhpcy5jb25kdWl0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgY29uZHVpdCBwcm9kdWNlcyBvdXRwdXQgLSBpZiBub3Qgd2Ugb25seSBkbyBzb21ldGhpbmcgaWYgd2UgYXJlIGluIHRoZSBzYW1lIHpvbmVcbiAgICAgICAgaWYgKGV2ZW50LmNvbmR1aXQucHJvZHVjZXNPdXRwdXQgPT09IGZhbHNlICYmIGV2ZW50LnpvbmVJZCAhPT0gdGhpcy56b25lSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG9ubHkgYWNjZXB0IGlucHV0cyBmcm9tIHNwZWNpZmljIHpvbmVzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZXZlbnQgY2FtZSBmcm9tIGFuIGFjY2VwdGFibGUgem9uZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0LmZpbmQoem9uZSA9PiB6b25lID09PSBldmVudC56b25lSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcmVxdWlyZWQgdHJhbnNmb3JtIHRoZSB2YWx1ZVxuICAgICAgICBjb25zdCBvdXRwdXRWYWx1ZSA9IHRoaXMuY29uZHVpdC5tYXAgPyB0aGlzLmNvbmR1aXQubWFwKGV2ZW50LnZhbHVlKSA6IGV2ZW50LnZhbHVlO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3ViamVjdFxuICAgICAgICB0aGlzLl9zdWJqZWN0Lm5leHQob3V0cHV0VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKiBUaGlzIHdpbGwgYmUgZmlyZWQgd2hlbiB0aGlzIGNvbmR1aXQgZW1pdHMgYSBuZXcgdmFsdWUgKi9cbiAgICBvbk91dHB1dCh2YWx1ZTogYW55KTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGFuZCB3aGVuIGl0IHdhcyBtb2RpZmllZCAtIGNhbiBiZSB1c2VkIGZvciBhbnkgbmV3IGNvbmR1aXRzIHRvIGxvb2t1cCBhIHZhbHVlXG4gICAgICAgIHRoaXMuY29uZHVpdC5jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25kdWl0Lmxhc3RNb2RpZmllZCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBzaG91bGQgcHJvZHVjZSBvdXRwdXRcbiAgICAgICAgaWYgKHRoaXMuY29uZHVpdC5wcm9kdWNlc091dHB1dCkge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5lbWl0KHsgY29uZHVpdDogdGhpcy5jb25kdWl0LCB6b25lSWQ6IHRoaXMuem9uZUlkLCB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBVbnN1YnNjcmliZSBvbmNlIHRoaXMgc3ViamVjdCBpcyBkZXN0cm95ZWQgKi9cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG59XG4iLCIvKiogVGhpcyB1dGlsaXR5IGlzIHRvIGVuc3VyZSBhIGFsbCBmdW5jdGlvbnMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgYXJlIGNhbGxlZCBpbiBhbGwgc3VwZXIgY2xhc3NlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVN1cGVyRnVuY3Rpb24odGFyZ2V0OiBvYmplY3QsIGZ1bmN0aW9uTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gZ2V0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGZ1bmN0aW9uXG4gICAgY29uc3QgZnVuY3Rpb25MaXN0OiBGdW5jdGlvbltdID0gW107XG5cbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBwcm90b3R5cGUgd2UgYXJlIGNoZWNraW5nXG4gICAgbGV0IHByb3RvdHlwZTogYW55ID0gdGFyZ2V0O1xuXG4gICAgLy8gbG9vayB0aHJvdWdoIGV2ZXJ5IGJhc2UgY2xhc3MgYW5kIGNoZWNrIGl0XG4gICAgZG8ge1xuICAgICAgICBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5KGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTGlzdC5wdXNoKHByb3RvdHlwZVtmdW5jdGlvbk5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvdHlwZSA9IHByb3RvdHlwZS5fX3Byb3RvX187XG4gICAgfSB3aGlsZSAocHJvdG90eXBlLl9fcHJvdG9fXyk7XG5cbiAgICAvLyBhdWdtZW50IHRoZSB0b3AgbGV2ZWwgZnVuY3Rpb24gdG8gY2FsbCBhbGwgdGhlIGZ1bmN0aW9uc1xuICAgIHRhcmdldFtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIGZ1bmN0aW9uTGlzdC5mb3JFYWNoKGZ1bmMgPT4gZnVuYy5jYWxsKHRhcmdldCwgLi4uYXJncykpO1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQ29uZHVpdFN1YmplY3QgfSBmcm9tICcuL2NvbmR1aXQtc3ViamVjdCc7XG5pbXBvcnQgeyBDb25kdWl0RXZlbnQgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1ldmVudCc7XG5pbXBvcnQgeyBDb25kdWl0TWV0YWRhdGEgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1tZXRhZGF0YSc7XG5pbXBvcnQgeyBDb25kdWl0UHJvcGVydGllcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LXByb3BlcnRpZXMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29uZHVpdFpvbmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIENyZWF0ZSBhIGdsb2JhbCBzdWJqZWN0IHN0b3JlICovXG4gICAgc3RhdGljIHN1YmplY3RzOiBDb25kdWl0U3ViamVjdFtdID0gW107XG5cbiAgICAvKiogRXhwb3NlIGFuIGV2ZW50IHN0cmVhbSBvZiBuZXcgdmFsdWVzICovXG4gICAgc3RhdGljIGV2ZW50cyA9IG5ldyBTdWJqZWN0PENvbmR1aXRFdmVudD4oKTtcblxuICAgIC8qKiBTdG9yZSB0aGUgem9uZSBuYW1lICovXG4gICAgcHJpdmF0ZSBfem9uZUlkOiBzdHJpbmc7XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCBhbGwgY29uZHVpdCBzdWJqZWN0cyB0aGF0IGFyZSBwYXJ0IG9mIHRoaXMgem9uZVxuICAgICAgICBDb25kdWl0Wm9uZS5zdWJqZWN0cy5maWx0ZXIoX3N1YmplY3QgPT4gX3N1YmplY3Quem9uZUlkID09PSB0aGlzLl96b25lSWQpXG4gICAgICAgICAgICAuZm9yRWFjaChfc3ViamVjdCA9PiB0aGlzLnVucmVnaXN0ZXJDb25kdWl0KF9zdWJqZWN0LmNvbmR1aXQpKTtcbiAgICB9XG5cbiAgICAvKiogU3RvcmUgcmVmZXJlbmNlIHRvIHRoZSByZXBvc2l0b3J5IGFuZCBiZWdpbiB3YXRjaGluZyBmb3IgYW5kIGVtaXR0aW5nIGNoYW5nZXMgKi9cbiAgICByZWdpc3RlckNvbmR1aXQoY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhKTogdm9pZCB7XG4gICAgICAgIENvbmR1aXRab25lLnN1YmplY3RzLnB1c2gobmV3IENvbmR1aXRTdWJqZWN0KGNvbmR1aXQsIHRoaXMsIHRoaXMuX3pvbmVJZCkpO1xuICAgIH1cblxuICAgIC8qKiBEZXN0cm95IGEgY29uZHVpdCAqL1xuICAgIHVucmVnaXN0ZXJDb25kdWl0KGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSk6IHZvaWQge1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5nZXRDb25kdWl0U3ViamVjdChjb25kdWl0LnN1YmplY3QpO1xuXG4gICAgICAgIGlmIChzdWJqZWN0KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHN1YmplY3QgZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjb25kdWl0IHN1YmplY3RzXG4gICAgICAgICAgICBDb25kdWl0Wm9uZS5zdWJqZWN0cyA9IENvbmR1aXRab25lLnN1YmplY3RzLmZpbHRlcihfc3ViamVjdCA9PiBfc3ViamVjdCAhPT0gc3ViamVjdCk7XG5cbiAgICAgICAgICAgIC8vIHBlcmZvcm0gYWxsIHVuc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgc3ViamVjdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUHJvdmlkZSB0aGUgem9uZSB3aXRoIGFuIElEICovXG4gICAgc2V0Wm9uZUlkKHpvbmVJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmVJZCA9IHpvbmVJZDtcbiAgICB9XG5cbiAgICAvKiogRW1pdCBhIHZhbHVlIHRvIGFsbCB6b25lcyBmb3IgY2hlY2tpbmcgKi9cbiAgICBlbWl0KGV2ZW50OiBDb25kdWl0RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgQ29uZHVpdFpvbmUuZXZlbnRzLm5leHQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKiBSZXRyaWV2ZSBhIGNvbmR1aXQgc3Vic2plY3Qgb2JqZWN0IGZyb20gdGhlIHJ4anMgc3ViamVjdCAqL1xuICAgIGdldENvbmR1aXRTdWJqZWN0KHN1YmplY3Q6IFN1YmplY3Q8YW55Pik6IENvbmR1aXRTdWJqZWN0IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBDb25kdWl0Wm9uZS5zdWJqZWN0cy5maW5kKF9zdWJqZWN0ID0+IF9zdWJqZWN0LmNvbmR1aXQuc3ViamVjdCA9PT0gc3ViamVjdCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCBhbGwgc3ViamVjdHMgZnJvbSBhbGwgem9uZXMgKi9cbiAgICBnZXRTdWJqZWN0cygpOiBDb25kdWl0U3ViamVjdFtdIHtcbiAgICAgICAgcmV0dXJuIENvbmR1aXRab25lLnN1YmplY3RzO1xuICAgIH1cblxuICAgIC8qKiBBbHRlciB0aGUgcHJvcGVydGllcyBvZiBhIGNvbmR1aXQgZHluYW1pY2FsbHkgKi9cbiAgICBzZXRDb25kdWl0UHJvcGVydGllcyhzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IFBhcnRpYWw8Q29uZHVpdFByb3BlcnRpZXM+KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgY29uZHVpdCB3aXRoIHRoZSBtYXRjaGluZyBzdWJqZWN0XG4gICAgICAgIGNvbnN0IGNvbmR1aXRTdWJqZWN0ID0gdGhpcy5nZXRTdWJqZWN0cygpLmZpbmQoX2NvbmR1aXQgPT4gX2NvbmR1aXQuY29uZHVpdC5zdWJqZWN0ID09PSBzdWJqZWN0KTtcblxuICAgICAgICAvLyBpZiBhIG1hdGNoIHdhcyBmb3VuZCB1cGRhdGUgdGhlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKGNvbmR1aXRTdWJqZWN0KSB7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBlYWNoIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25kdWl0U3ViamVjdC5jb25kdWl0W3Byb3BdID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbmR1aXQgYXQgcnVudGltZSAqL1xuICAgIGNyZWF0ZUNvbmR1aXQoc3ViamVjdDogU3ViamVjdDxhbnk+LCBwcm9wZXJ0aWVzOiBDb25kdWl0UHJvcGVydGllcyk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBjb25kdWl0IHdpdGggdGhlIHpvbmVcbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbmR1aXQoeyAuLi5wcm9wZXJ0aWVzLCBzdWJqZWN0IH0pO1xuICAgIH1cblxuICAgIC8qKiBSZWdpc3RlciBhbGwgY29uZHVpdHMgaW4gYSBjb21wb25lbnQgKi9cbiAgICByZWdpc3RlckNvbmR1aXRzKGNvbXBvbmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudC5fY29uZHVpdHMpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuX2NvbmR1aXRzLmZvckVhY2goKGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSkgPT4gdGhpcy5yZWdpc3RlckNvbmR1aXQoeyAuLi5jb25kdWl0LCBzdWJqZWN0OiBjb21wb25lbnRbY29uZHVpdC5wcm9wZXJ0eUtleV0gfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJlZ2lzdGVyIGFsbCBjb25kdWl0cyBpbiBhIGNvbXBvbmVudCAqL1xuICAgIHVucmVnaXN0ZXJDb25kdWl0cyhjb21wb25lbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnQuX2NvbmR1aXRzKSkge1xuICAgICAgICAgICAgY29tcG9uZW50Ll9jb25kdWl0cy5mb3JFYWNoKChjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEpID0+IHRoaXMudW5yZWdpc3RlckNvbmR1aXQoY29uZHVpdCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiB0aGUgZ2xvYmFsIGV2ZW50IHN0cmVhbSAqL1xuICAgIGdldEV2ZW50cygpOiBTdWJqZWN0PENvbmR1aXRFdmVudD4ge1xuICAgICAgICByZXR1cm4gQ29uZHVpdFpvbmUuZXZlbnRzO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE9uRGVzdHJveSwgT25Jbml0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBpbnZva2VTdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi9jb25kdWl0LXV0aWxzJztcbmltcG9ydCB7IENvbmR1aXRab25lIH0gZnJvbSAnLi9jb25kdWl0LXpvbmUuc2VydmljZSc7XG5pbXBvcnQgeyBDb25kdWl0UHJvcGVydGllcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LXByb3BlcnRpZXMnO1xuXG5leHBvcnQgY2xhc3MgQ29uZHVpdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByb3RlY3RlZCBfem9uZTogQ29uZHVpdFpvbmUpIHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBlbnN1cmUgdGhlc2UgZnVuY3Rpb25zIGdldCBjYWxsZWQgZXZlbiBpZiBhIGNsYXNzIG92ZXJyaWRlcyB0aGVtXG4gICAgICAgIGludm9rZVN1cGVyRnVuY3Rpb24odGhpcywgJ25nT25Jbml0Jyk7XG4gICAgICAgIGludm9rZVN1cGVyRnVuY3Rpb24odGhpcywgJ25nT25EZXN0cm95Jyk7XG4gICAgfVxuXG4gICAgLyoqIFdlIG5lZWQgdG8gcmVnaXN0ZXIgdGhlIGNvbmR1aXRzIHdpdGggdGhlIHpvbmUgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxpc2VkICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBjb25kdWl0IGluIHRoZSB6b25lIGFuZCBlbnN1cmUgaXQgZ2V0cyB0aGUgY29ycmVjdCBpbnN0YW5jZSBvZiB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMuX3pvbmUucmVnaXN0ZXJDb25kdWl0cyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKiogV2UgbmVlZCB0byB1bnJlZ2lzdGVyIHRoZSBjb25kdWl0cyB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUudW5yZWdpc3RlckNvbmR1aXRzKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKiBBbHRlciB0aGUgcHJvcGVydGllcyBvZiBhIGNvbmR1aXQgZHluYW1pY2FsbHkgKi9cbiAgICBzZXRDb25kdWl0UHJvcGVydGllcyhzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IFBhcnRpYWw8Q29uZHVpdFByb3BlcnRpZXM+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUuc2V0Q29uZHVpdFByb3BlcnRpZXMoc3ViamVjdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29uZHVpdCBhdCBydW50aW1lICovXG4gICAgY3JlYXRlQ29uZHVpdChzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IENvbmR1aXRQcm9wZXJ0aWVzKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUuY3JlYXRlQ29uZHVpdChzdWJqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29uZHVpdENvbXBvbmVudCB9IGZyb20gJy4vY29uZHVpdC5jb21wb25lbnQnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29uZHVpdFpvbmVDb21wb25lbnQgZXh0ZW5kcyBDb25kdWl0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBhYnN0cmFjdCB6b25lSWQ6IHN0cmluZztcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl96b25lLnNldFpvbmVJZCh0aGlzLnpvbmVJZCk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBDb25kdWl0UHJvcGVydGllcyB7XG4gICAgaWQ6IG51bWJlciB8IHN0cmluZztcbiAgICBhY2NlcHRzSW5wdXQ/OiBib29sZWFuIHwgc3RyaW5nW107XG4gICAgcHJvZHVjZXNPdXRwdXQ/OiBib29sZWFuO1xuICAgIGNoYW5nZURldGVjdGlvbj86ICh4OiBhbnksIHk6IGFueSkgPT4gYm9vbGVhbjtcbiAgICBtYXA/OiBhbnk7XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29uZHVpdFByb3BzOiBQYXJ0aWFsPENvbmR1aXRQcm9wZXJ0aWVzPiA9IHtcbiAgICBhY2NlcHRzSW5wdXQ6IHRydWUsXG4gICAgcHJvZHVjZXNPdXRwdXQ6IHRydWUsXG59O1xuIiwiaW1wb3J0IHsgQ29uZHVpdE1ldGFkYXRhIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtbWV0YWRhdGEnO1xuaW1wb3J0IHsgQ29uZHVpdFByb3BlcnRpZXMsIGRlZmF1bHRDb25kdWl0UHJvcHMgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1wcm9wZXJ0aWVzJztcblxuLyoqIEV4cG9zZSB0aGUgcHJvcGVydHkgdGhhdCBjb25kdWl0cyB3aWxsIGJlIHN0b3JlZCBpbiAqL1xuZXhwb3J0IGNvbnN0IENPTkRVSVRTID0gJ19jb25kdWl0cyc7XG5cbi8qKiBDcmVhdGUgdGhlIGNvbmR1aXQgcHJvcGVydHkgZGVjb3JhdG9yICovXG5leHBvcnQgZnVuY3Rpb24gQ29uZHVpdChwcm9wZXJ0aWVzOiBDb25kdWl0UHJvcGVydGllcyB8IEZ1bmN0aW9uKTogUHJvcGVydHlEZWNvcmF0b3Ige1xuICAgIHJldHVybiAodGFyZ2V0OiBPYmplY3QsIHByb3BlcnR5S2V5OiBzdHJpbmcpID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmNhbGwobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGRvZXMgbm90IGFscmVhZHkgaGF2ZSBhIGNvbmR1aXQgbGlzdCB0aGVuIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoQ09ORFVJVFMpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBDT05EVUlUUywgeyB2YWx1ZTogW10gfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIGNvbmR1aXQgdG8gdGhlIGxpc3QgZW5zdXJpbmcgYWxsIHJlcXVpcmVkIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkXG4gICAgICAgIHRhcmdldFtDT05EVUlUU10ucHVzaCh7IC4uLmRlZmF1bHRDb25kdWl0UHJvcHMsIC4uLnByb3BlcnRpZXMsIHRhcmdldCwgcHJvcGVydHlLZXkgfSBhcyBDb25kdWl0TWV0YWRhdGEpO1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRlbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IERhc2hib2FyZE9wdGlvbnMgfSBmcm9tICcuL2Rhc2hib2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50IH0gZnJvbSAnLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkU2VydmljZSB7XG5cbiAgICBwcml2YXRlIF93aWRnZXRPcmlnaW46IHsgY29sdW1uPzogbnVtYmVyLCByb3c/OiBudW1iZXIsIGNvbHVtblNwYW4/OiBudW1iZXIsIHJvd1NwYW4/OiBudW1iZXIgfTtcbiAgICBwcml2YXRlIF9hY3Rpb25XaWRnZXQ6IERhc2hib2FyZEFjdGlvbjtcbiAgICBwcml2YXRlIF9yb3dIZWlnaHQ6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBfY2FjaGU6IERhc2hib2FyZENhY2hlW107XG4gICAgcHJpdmF0ZSBfbW91c2VFdmVudDogTW91c2VFdmVudDtcblxuICAgIHdpZGdldHMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXT4oW10pO1xuICAgIG9wdGlvbnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXNoYm9hcmRPcHRpb25zPihkZWZhdWx0T3B0aW9ucyk7XG4gICAgZGltZW5zaW9ucyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZERpbWVuc2lvbnM+KHt9KTtcbiAgICBoZWlnaHQkOiBPYnNlcnZhYmxlPG51bWJlcj4gPSB0aGlzLmRpbWVuc2lvbnMkLnBpcGUoZGVsYXkoMCksIG1hcCgoZGltZW5zaW9uczogRGFzaGJvYXJkRGltZW5zaW9ucykgPT4gZGltZW5zaW9ucy5oZWlnaHQpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICBwbGFjZWhvbGRlciQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZFBsYWNlaG9sZGVyPih7IHZpc2libGU6IGZhbHNlLCB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgIGxheW91dCQgPSBuZXcgU3ViamVjdDxEYXNoYm9hcmRMYXlvdXREYXRhW10+KCk7XG4gICAgc3RhY2tlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCB3aWRnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCBzdGFja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja2VkJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCBkaW1lbnNpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCBjb2x1bW5XaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9ucy53aWR0aCAvIHRoaXMub3B0aW9ucy5jb2x1bW5zO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxheW91dCQuc3Vic2NyaWJlKHRoaXMuc2V0TGF5b3V0RGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGFja2VkJC5waXBlKGZpbHRlcihzdGFja2VkID0+IHN0YWNrZWQgPT09IHRydWUpKS5zdWJzY3JpYmUodGhpcy51cGRhdGVXaGVuU3RhY2tlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzJC5waXBlKGRlbGF5KDApKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZW5kZXJEYXNoYm9hcmQoKSk7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyQucGlwZShkZWxheSgwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVuZGVyRGFzaGJvYXJkKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHdpZGdldCB0byB0aGUgZGFzaGJvYXJkXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IGNvbXBvbmVudCB0byBhZGQgdG8gdGhlIGRhc2hib2FyZFxuICAgICAqL1xuICAgIGFkZFdpZGdldCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLndpZGdldHMkLm5leHQoWy4uLnRoaXMud2lkZ2V0cyQuZ2V0VmFsdWUoKSwgd2lkZ2V0XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgd2lkZ2V0IGZyb20gdGhlIGRhc2hib2FyZFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmVXaWRnZXQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy53aWRnZXRzJC5uZXh0KHRoaXMud2lkZ2V0cyQuZ2V0VmFsdWUoKS5maWx0ZXIoX3dpZGdldCA9PiBfd2lkZ2V0ICE9PSB3aWRnZXQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB0aGF0IHRoZSBkYXNoYm9hcmQgZWxlbWVudCBoYXMgYmVlbiByZXNpemVkXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgZGFzaGJvYXJkIGVsZW1lbnQgaW4gcHhcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGRhc2hib2FyZCBlbGVtZW50IGluIHB4XG4gICAgICovXG4gICAgc2V0RGltZW5zaW9ucyh3aWR0aDogbnVtYmVyID0gdGhpcy5kaW1lbnNpb25zLndpZHRoLCBoZWlnaHQ6IG51bWJlciA9IHRoaXMuZGltZW5zaW9ucy5oZWlnaHQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGltZW5zaW9ucy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5kaW1lbnNpb25zLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMkLm5leHQoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHJlcXVpcmVkIGxheW91dCBkYXRhLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZXhwb3J0aW5nL3NhdmluZyBhIGxheW91dFxuICAgICAqL1xuICAgIGdldExheW91dERhdGEoKTogRGFzaGJvYXJkTGF5b3V0RGF0YVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5tYXAod2lkZ2V0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGlkOiB3aWRnZXQuaWQsIGNvbDogd2lkZ2V0LmdldENvbHVtbigpLCByb3c6IHdpZGdldC5nZXRSb3coKSwgY29sU3Bhbjogd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgcm93U3Bhbjogd2lkZ2V0LmdldFJvd1NwYW4oKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB3aWRnZXRzIHByb2dyYW1hdGljYWxseVxuICAgICAqL1xuICAgIHNldExheW91dERhdGEod2lkZ2V0czogRGFzaGJvYXJkTGF5b3V0RGF0YVtdKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggd2lkZ2V0IGRhdGEgYW5kIGZpbmQgYSBtYXRjaFxuICAgICAgICB3aWRnZXRzLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbWF0Y2hpbmcgd2lkZ2V0XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLndpZGdldHMuZmluZChfd2lkZ2V0ID0+IF93aWRnZXQuaWQgPT09IHdpZGdldC5pZCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0Q29sdW1uKHdpZGdldC5jb2wpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRSb3cod2lkZ2V0LnJvdyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldENvbHVtblNwYW4od2lkZ2V0LmNvbFNwYW4pO1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRSb3dTcGFuKHdpZGdldC5yb3dTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwb3NpdGlvbnMgYW5kIHNpemVzIG9mIHRoZSB3aWRnZXRzXG4gICAgICovXG4gICAgcmVuZGVyRGFzaGJvYXJkKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuX3Jvd0hlaWdodCA9IHRoaXMub3B0aW9ucy5yb3dIZWlnaHQgfHwgdGhpcy5jb2x1bW5XaWR0aDtcblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGNvbHVtbiB3aWR0aCBpcyBub3QgYmVsb3cgdGhlIG1pbiB3aWR0aHNcbiAgICAgICAgdGhpcy5zdGFja2VkJC5uZXh0KHRoaXMuY29sdW1uV2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcm93IGhlaWdodCBpcyBub3QgYmVsb3cgdGhlIG1pbiB3aWR0aHNcbiAgICAgICAgaWYgKHRoaXMuX3Jvd0hlaWdodCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1pbldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRMYXlvdXQoKTtcblxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFjaCB3aWRnZXQgYW5kIHNldCB0aGUgc2l6ZSAtIGV4Y2VwdCB0aGUgb25lIGJlaW5nIHJlc2l6ZWRcbiAgICAgICAgdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gIXRoaXMuX2FjdGlvbldpZGdldCB8fCB3aWRnZXQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQpXG4gICAgICAgICAgICAuZm9yRWFjaCh3aWRnZXQgPT4gd2lkZ2V0LnJlbmRlcigpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hlcmUgd2lkZ2V0cyBzaG91bGQgYmUgcG9zaXRpb25lZCBiYXNlZCBvbiB0aGVpciBwb3NpdGlvbnMsIHdpZHRoIGFuZCB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyXG4gICAgICovXG4gICAgc2V0RGFzaGJvYXJkTGF5b3V0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgYW55IHdpZGdldHMgdGhhdCBkbyBub3QgY3VycmVudGx5IGhhdmUgYSBwb3NpdGlvbiBzZXRcbiAgICAgICAgdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gd2lkZ2V0LmdldENvbHVtbigpID09PSB1bmRlZmluZWQgfHwgd2lkZ2V0LmdldFJvdygpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAuZm9yRWFjaCh3aWRnZXQgPT4gdGhpcy5zZXRXaWRnZXRQb3NpdGlvbih3aWRnZXQpKTtcblxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVdoZW5TdGFja2VkKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHdpZGdldCBzZXQgaXQncyBzdGFja2VkIHN0YXRlIGFuZFxuICAgICAgICB0aGlzLmdldFdpZGdldHNCeU9yZGVyKCkuZm9yRWFjaCgod2lkZ2V0LCBpZHgpID0+IHtcbiAgICAgICAgICAgIHdpZGdldC5zZXRDb2x1bW4oMCk7XG4gICAgICAgICAgICB3aWRnZXQuc2V0Um93KGlkeCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZ2V0V2lkZ2V0c0J5T3JkZXIoKTogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLnNvcnQoKHcxLCB3MikgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB3MVBvc2l0aW9uID0gdzEuZ2V0Q29sdW1uKCkgKiB3MS5nZXRSb3coKTtcbiAgICAgICAgICAgIGNvbnN0IHcyUG9zaXRpb24gPSB3Mi5nZXRDb2x1bW4oKSAqIHcyLmdldFJvdygpO1xuXG4gICAgICAgICAgICBpZiAodzFQb3NpdGlvbiA8IHcyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3MVBvc2l0aW9uID4gdzJQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHBvc2l0aW9uIHRoYXQgYSB3aWRnZXQgY2FuIGZpdCBpbiB0aGUgZGFzaGJvYXJkXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRvIHRyeSBhbmQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzZXRXaWRnZXRQb3NpdGlvbih3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgYSBwb3NpdGlvbiBmb3IgdGhlIHdpZGdldFxuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHJlcGVhdCB1bnRpbCBhIHNwYWNlIGlzIGZvdW5kXG4gICAgICAgIHdoaWxlICghc3VjY2Vzcykge1xuXG4gICAgICAgICAgICAvLyBnZXQgYSBwb3NpdGlvbiB0byB0cnlcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBvc2l0aW9uICUgdGhpcy5vcHRpb25zLmNvbHVtbnM7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gdGhpcy5vcHRpb25zLmNvbHVtbnMpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UG9zaXRpb25BdmFpbGFibGUoY29sdW1uLCByb3csIHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIHdpZGdldC5nZXRSb3dTcGFuKCkpKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHdpZGdldC5zZXRSb3cocm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW4gPT09IDAgJiYgd2lkZ2V0LmNvbFNwYW4gPiB0aGlzLm9wdGlvbnMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGFzaGJvYXJkIHdpZGdldHMgaGF2ZSBhIGNvbFNwYW4gZ3JlYXRlciB0aGFuIHRoZSBtYXggbnVtYmVyIG9mIGRhc2hib2FyZCBjb2x1bW5zIScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBwb3NpdGlvbiBpbiB0aGUgZGFzaGJvYXJkIGlzIHZhY2FudCBvciBub3RcbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbkF2YWlsYWJsZShjb2x1bW46IG51bWJlciwgcm93OiBudW1iZXIsIGNvbHVtblNwYW46IG51bWJlciwgcm93U3BhbjogbnVtYmVyLCBpZ25vcmVXaWRnZXQ/OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBnZXQgYSBsaXN0IG9mIGdyaWQgc3BhY2VzIHRoYXQgYXJlIHBvcHVsYXRlZFxuICAgICAgICBjb25zdCBzcGFjZXMgPSB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGJsb2NrIHdvdWxkIHN0aWxsIGJlIGluIGJvdW5kc1xuICAgICAgICBpZiAoY29sdW1uICsgY29sdW1uU3BhbiA+IHRoaXMub3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBlYWNoIHJlcXVpcmVkIHBvc2l0aW9uXG4gICAgICAgIGZvciAobGV0IHggPSBjb2x1bW47IHggPCBjb2x1bW4gKyBjb2x1bW5TcGFuOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSByb3c7IHkgPCByb3cgKyByb3dTcGFuOyB5KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VzLmZpbmQoYmxvY2sgPT4gYmxvY2suY29sdW1uID09PSB4ICYmIGJsb2NrLnJvdyA9PT0geSAmJiBibG9jay53aWRnZXQgIT09IGlnbm9yZVdpZGdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldE9jY3VwaWVkU3BhY2VzKCk6IERhc2hib2FyZFNwYWNlW10ge1xuXG4gICAgICAgIC8vIGZpbmQgYWxsIHNwYWNlcyB0aGF0IGFyZSBjdXJyZW50bHkgb2NjdXBpZWRcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5maWx0ZXIod2lkZ2V0ID0+IHdpZGdldC5nZXRDb2x1bW4oKSAhPT0gdW5kZWZpbmVkICYmIHdpZGdldC5nZXRSb3coKSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgLnJlZHVjZSgodmFsdWUsIHdpZGdldCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoQmxvY2sod2lkZ2V0LCAoY29sdW1uLCByb3cpID0+IHZhbHVlLnB1c2goeyB3aWRnZXQ6IHdpZGdldCwgY29sdW1uOiBjb2x1bW4sIHJvdzogcm93IH0pKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZWdpbiByZXNpemluZyBhIHdpZGdldFxuICAgICAqIEBwYXJhbSBhY3Rpb24gVGhlIHRoZSB3aWRnZXQgdG8gcmVzaXplXG4gICAgICovXG4gICAgb25SZXNpemVTdGFydChhY3Rpb246IERhc2hib2FyZEFjdGlvbik6IHZvaWQge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBtb3VzZSBldmVudFxuICAgICAgICB0aGlzLl9tb3VzZUV2ZW50ID0gYWN0aW9uLmV2ZW50O1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQgPSBhY3Rpb247XG5cbiAgICAgICAgLy8gYnJpbmcgdGhlIHdpZGdldCB0byB0aGUgZm9udFxuICAgICAgICB0aGlzLmJyaW5nVG9Gcm9udChhY3Rpb24ud2lkZ2V0KTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZURyYWcoYWN0aW9uOiBEYXNoYm9hcmRBY3Rpb24pOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBtb3VzZVBvc1ggPSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VYIC0gcGFnZVhPZmZzZXQ7XG4gICAgICAgIGNvbnN0IG1vdXNlUG9zWSA9IHRoaXMuX21vdXNlRXZlbnQucGFnZVkgLSBwYWdlWU9mZnNldDtcblxuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgbm8gbW92ZW1lbnQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmIChhY3Rpb24uZXZlbnQueCA9PT0gbW91c2VQb3NYICYmIGFjdGlvbi5ldmVudC55ID09PSBtb3VzZVBvc1kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RvcmVkIG1vdXNlIGV2ZW50XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBhY3Rpb24uZXZlbnQ7XG5cbiAgICAgICAgLy8gZ2V0IGhhbmRsZSBmb3IgZGlyZWN0aW9uXG4gICAgICAgIGNvbnN0IHsgaGFuZGxlIH0gPSBhY3Rpb247XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGhhbmRsZVxuICAgICAgICBjb25zdCBib3VuZHMgPSBoYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjZW50ZXIgb2YgdGhlIGhhbmRsZVxuICAgICAgICBjb25zdCBjZW50ZXJYID0gYm91bmRzLmxlZnQgKyAoYm91bmRzLndpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBib3VuZHMudG9wICsgKGJvdW5kcy5oZWlnaHQgLyAyKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgICAgICAgY29uc3QgbW91c2VYID0gbW91c2VQb3NYIC0gY2VudGVyWDtcbiAgICAgICAgY29uc3QgbW91c2VZID0gbW91c2VQb3NZIC0gY2VudGVyWTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbmV3IHByb3Bvc2VkIGRpbWVuc2lvbnMgZm9yIHRoZSB3aWRnZXRcbiAgICAgICAgY29uc3QgZGltZW5zaW9uczogRGFzaGJvYXJkV2lkZ2V0RGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHg6IGFjdGlvbi53aWRnZXQueCxcbiAgICAgICAgICAgIHk6IGFjdGlvbi53aWRnZXQueSxcbiAgICAgICAgICAgIHdpZHRoOiBhY3Rpb24ud2lkZ2V0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBhY3Rpb24ud2lkZ2V0LmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHVwZGF0ZSB3aWRnZXQgYmFzZWQgb24gdGhlIGhhbmRsZSBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLmRpcmVjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggLT0gbW91c2VYO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5XaWR0aCAtIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlRvcDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0IC09IG1vdXNlWTtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy55IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0IHJlc2l6aW5nIG9uIG11bHRpcGxlIGF4aXMgc2ltdWx0YW5lb3VzbHlcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQ6XG5cbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggLT0gbW91c2VYO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5XaWR0aCAtIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy55ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAtPSBtb3VzZVk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy5oZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQ6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy55ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAtPSBtb3VzZVk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy5oZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tTGVmdDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy54ICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoIC09IG1vdXNlWDtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluV2lkdGggLSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tUmlnaHQ6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudFdpZHRoID0gYWN0aW9uLndpZGdldC54ICsgYWN0aW9uLndpZGdldC53aWR0aDtcbiAgICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IGFjdGlvbi53aWRnZXQueSArIGFjdGlvbi53aWRnZXQuaGVpZ2h0O1xuXG4gICAgICAgIC8vIGVuc3VyZSB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZGFzaGJvYXJkIGJvdW5kc1xuICAgICAgICBpZiAoZGltZW5zaW9ucy54IDwgMCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy54ID0gMDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggPSBjdXJyZW50V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGltZW5zaW9ucy55IDwgMCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy55ID0gMDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ID0gY3VycmVudEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZGltZW5zaW9ucy54ICsgZGltZW5zaW9ucy53aWR0aCkgPiB0aGlzLmRpbWVuc2lvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggPSB0aGlzLmRpbWVuc2lvbnMud2lkdGggLSBkaW1lbnNpb25zLng7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcHJvcG9zZWQgd2lkdGggaXMgc21hbGxlciB0aGFuIGFsbG93ZWQgdGhlbiByZXNldCB3aWR0aCB0byBtaW5pbXVtIGFuZCBpZ25vcmUgeCBjaGFuZ2VzXG4gICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnggPSBhY3Rpb24ud2lkZ2V0Lng7XG4gICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoID0gdGhpcy5vcHRpb25zLm1pbldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHByb3Bvc2VkIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gYWxsb3dlZCB0aGVuIHJlc2V0IGhlaWdodCB0byBtaW5pbXVtIGFuZCBpZ25vcmUgeSBjaGFuZ2VzXG4gICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMueSA9IGFjdGlvbi53aWRnZXQueTtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgd2lkZ2V0IGFjdHVhbCB2YWx1ZXNcbiAgICAgICAgYWN0aW9uLndpZGdldC5zZXRCb3VuZHMoZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyB1cGRhdGUgcGxhY2Vob2xkZXIgcG9zaXRpb24gYW5kIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHModHJ1ZSwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBzaG93IHRoZSB3aWRnZXQgcG9zaXRpb25zIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9ucyBhbmQgc2l6ZXMgd2VyZSB0byBwZXJzaXN0XG4gICAgICAgIHRoaXMudXBkYXRlV2lkZ2V0UG9zaXRpb25zKGFjdGlvbi53aWRnZXQpO1xuICAgIH1cblxuICAgIG9uUmVzaXplRW5kKCk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjb21taXQgcmVzaXplIGNoYW5nZXNcbiAgICAgICAgdGhpcy5jb21taXRXaWRnZXRDaGFuZ2VzKCk7XG5cbiAgICAgICAgLy8gaGlkZSBwbGFjZWhvbGRlclxuICAgICAgICBwbGFjZWhvbGRlci52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyJC5uZXh0KHBsYWNlaG9sZGVyKTtcblxuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3VzZUV2ZW50ID0gbnVsbDtcblxuICAgICAgICAvLyBlbnN1cmUgYW55IHZhY2FudCB1cHBlciBzcGFjZXMgYXJlIGZpbGxlZCB3aGVyZSByZXF1aXJlZFxuICAgICAgICB0aGlzLnNoaWZ0V2lkZ2V0c1VwKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGRhc2hib2FyZCBoZWlnaHRcbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRIZWlnaHQoKTtcblxuICAgICAgICAvLyBlbWl0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBsYXlvdXRcbiAgICAgICAgdGhpcy5sYXlvdXQkLm5leHQodGhpcy5nZXRMYXlvdXREYXRhKCkpO1xuICAgIH1cblxuICAgIG9uRHJhZ1N0YXJ0KGFjdGlvbjogRGFzaGJvYXJkQWN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25SZXNpemVTdGFydChhY3Rpb24pO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBzdGFydGluZyBwbGFjZWhvbGRlciBwb3NpdGlvblxuICAgICAgICB0aGlzLnNldFdpZGdldE9yaWdpbigpO1xuXG4gICAgICAgIHRoaXMuY2FjaGVXaWRnZXRzKCk7XG4gICAgfVxuXG4gICAgb25EcmFnRW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uUmVzaXplRW5kKCk7XG5cbiAgICAgICAgdGhpcy5fd2lkZ2V0T3JpZ2luID0ge307XG4gICAgfVxuXG4gICAgb25EcmFnKGFjdGlvbjogRGFzaGJvYXJkQWN0aW9uKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIG1vdmVtZW50IHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAoYWN0aW9uLmV2ZW50LnBhZ2VYID09PSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VYICYmIGFjdGlvbi5ldmVudC5wYWdlWSA9PT0gdGhpcy5fbW91c2VFdmVudC5wYWdlWSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IG1vdXNlWCA9IGFjdGlvbi5ldmVudC5wYWdlWCAtIHRoaXMuX21vdXNlRXZlbnQucGFnZVg7XG4gICAgICAgIGNvbnN0IG1vdXNlWSA9IGFjdGlvbi5ldmVudC5wYWdlWSAtIHRoaXMuX21vdXNlRXZlbnQucGFnZVk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGxhdGVzdCBldmVudFxuICAgICAgICB0aGlzLl9tb3VzZUV2ZW50ID0gYWN0aW9uLmV2ZW50O1xuXG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnM6IERhc2hib2FyZFdpZGdldERpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICB4OiBhY3Rpb24ud2lkZ2V0LnggKyBtb3VzZVgsXG4gICAgICAgICAgICB5OiBhY3Rpb24ud2lkZ2V0LnkgKyBtb3VzZVksXG4gICAgICAgICAgICB3aWR0aDogYWN0aW9uLndpZGdldC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYWN0aW9uLndpZGdldC5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc3RvcmVXaWRnZXRzKHRydWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB3aWRnZXQgcG9zaXRpb25cbiAgICAgICAgYWN0aW9uLndpZGdldC5zZXRCb3VuZHMoZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyB1cGRhdGUgcGxhY2Vob2xkZXIgcG9zaXRpb24gYW5kIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHModHJ1ZSwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBzaG93IHRoZSB3aWRnZXQgcG9zaXRpb25zIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9ucyBhbmQgc2l6ZXMgd2VyZSB0byBwZXJzaXN0XG4gICAgICAgIHRoaXMuc2hpZnRXaWRnZXRzKCk7XG5cbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRIZWlnaHQoKTtcbiAgICB9XG5cbiAgICBnZXRSb3dIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd0hlaWdodDtcbiAgICB9XG5cbiAgICBjYWNoZVdpZGdldHMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy53aWRnZXRzLm1hcCh3aWRnZXQgPT4gKHsgaWQ6IHdpZGdldC5pZCwgY29sdW1uOiB3aWRnZXQuZ2V0Q29sdW1uKCksIHJvdzogd2lkZ2V0LmdldFJvdygpIH0pKTtcbiAgICB9XG5cbiAgICByZXN0b3JlV2lkZ2V0cyhpZ25vcmVBY3Rpb25XaWRnZXQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9jYWNoZS5maWx0ZXIod2lkZ2V0ID0+ICFpZ25vcmVBY3Rpb25XaWRnZXQgfHwgd2lkZ2V0LmlkICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmlkKS5mb3JFYWNoKHdpZGdldCA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy53aWRnZXRzLmZpbmQod2d0ID0+IHdndC5pZCA9PT0gd2lkZ2V0LmlkKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2guc2V0Q29sdW1uKHdpZGdldC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIG1hdGNoLnNldFJvdyh3aWRnZXQucm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkcmFnZ2luZyBhbnkgd2lkZ2V0cyB0aGF0IG5lZWQgdG8gYmUgbW92ZWQgc2hvdWxkIGJlIG1vdmVkIHRvIGFuIGFwcHJvcHJpYXRlIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2hpZnRXaWRnZXRzKCk6IHZvaWQge1xuXG4gICAgICAgIGxldCB3aWRnZXRzVG9Nb3ZlOiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IHdpZGdldHMgdW5kZXIgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHBsYWNlaG9sZGVyLnJvdzsgcm93IDwgcGxhY2Vob2xkZXIucm93ICsgcGxhY2Vob2xkZXIucm93U3Bhbjsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiA9IHBsYWNlaG9sZGVyLmNvbHVtbjsgY29sdW1uIDwgcGxhY2Vob2xkZXIuY29sdW1uICsgcGxhY2Vob2xkZXIuY29sdW1uU3BhbjsgY29sdW1uKyspIHtcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHJlZmVyZW5jZSB0byBhbnkgd2lkZ2V0cyB0aGF0IG5lZWQgbW92ZWRcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKClcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihzcGFjZSA9PiBzcGFjZS5jb2x1bW4gPT09IGNvbHVtbiAmJiBzcGFjZS5yb3cgPT09IHJvdyAmJiBzcGFjZS53aWRnZXQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKHNwYWNlID0+IHdpZGdldHNUb01vdmUucHVzaChzcGFjZS53aWRnZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgZHVwbGljYXRlc1xuICAgICAgICB3aWRnZXRzVG9Nb3ZlID0gd2lkZ2V0c1RvTW92ZS5maWx0ZXIoKHdpZGdldCwgaWR4LCBhcnJheSkgPT4gYXJyYXkuaW5kZXhPZih3aWRnZXQpID09PSBpZHgpO1xuXG4gICAgICAgIC8vIGlmIG5vIHdpZGdldHMgbmVlZCBtb3ZlZCB0aGVuIHdlIGNhbiBzdG9wIGhlcmVcbiAgICAgICAgaWYgKHdpZGdldHNUb01vdmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYSBkdXBsaWNhdGUgd2UgY2FuIHVzZSB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGhhdmUgYmVlbiBtb3ZlZFxuICAgICAgICBjb25zdCB1bm1vdmVkV2lkZ2V0cyA9IHdpZGdldHNUb01vdmUuc2xpY2UoKTtcblxuICAgICAgICAvLyBhdHRlbXB0IHRvIG1vdmUgYW55IHdpZGdldHMgdG8gdGhlIHByZXZpb3VzIHdpZGdldCBwb3NpdGlvblxuICAgICAgICB3aWRnZXRzVG9Nb3ZlLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgLy8gZ2V0IGEgZ3JpZCBvZmYgYWxsIG9jY3VwaWVkIHNwYWNlcyAtIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHBsYWNlaG9sZGVyIGFuZCBpZ25vcmluZyB3aWRnZXRzIHRoYXQgbmVlZCBtb3ZlZFxuICAgICAgICAgICAgY29uc3QgZ3JpZCA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKS5maWx0ZXIoc3BhY2UgPT4gIXVubW92ZWRXaWRnZXRzLmZpbmQod2d0ID0+IHdndCA9PT0gc3BhY2Uud2lkZ2V0KSk7XG5cbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgZWFjaCBmcmVlIGJsb2NrXG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSB0aGlzLl93aWRnZXRPcmlnaW4ucm93OyByb3cgPCB0aGlzLl93aWRnZXRPcmlnaW4ucm93ICsgdGhpcy5fd2lkZ2V0T3JpZ2luLnJvd1NwYW47IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uID0gdGhpcy5fd2lkZ2V0T3JpZ2luLmNvbHVtbjsgY29sdW1uIDwgdGhpcy5fd2lkZ2V0T3JpZ2luLmNvbHVtbiArIHRoaXMuX3dpZGdldE9yaWdpbi5jb2x1bW5TcGFuOyBjb2x1bW4rKykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgYmxvY2sgY2FuIGZpdCBpbiB0aGlzIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXF1aXJlZFNwYWNlcyA9IHRoaXMuZ2V0UmVxdWlyZWRTcGFjZXNGcm9tUG9pbnQod2lkZ2V0LCBjb2x1bW4sIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2lkZ2V0IHdvdWxkIGZpdCBpbiBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBsZXQgYXZhaWxhYmxlID0gcmVxdWlyZWRTcGFjZXMuZXZlcnkoc3BhY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFncmlkLmZpbmQoZ3JpZFNwYWNlID0+IGdyaWRTcGFjZS5jb2x1bW4gPT09IHNwYWNlLmNvbHVtbiAmJiBncmlkU3BhY2Uucm93ID09PSBzcGFjZS5yb3cpICYmIHNwYWNlLmNvbHVtbiA8IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnNldFJvdyhyb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3ZlZFdpZGdldHMuc3BsaWNlKHVubW92ZWRXaWRnZXRzLmZpbmRJbmRleCh3Z3QgPT4gd2d0ID09PSB3aWRnZXQpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgZ2V0IHRvIGhlcmUgdGhlbiB3ZSBjYW4ndCBzaW1wbHkgc3dhcCB0aGUgcG9zaXRpb25zIC0gbmV4dCB0cnkgbW92aW5nIHJpZ2h0XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5XaWRnZXRNb3ZlUmlnaHQod2lkZ2V0LCB0cnVlKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHNoaWZ0IGNoZWNrIGlmIHBsYWNlaG9sZGVyIHBvc2l0aW9uIGlzIHN0aWxsIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24oQWN0aW9uRGlyZWN0aW9uLlJpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5leHQgdHJ5IG1vdmluZyBsZWZ0XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5XaWRnZXRNb3ZlTGVmdCh3aWRnZXQsIHRydWUpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2hpZnQgY2hlY2sgaWYgcGxhY2Vob2xkZXIgcG9zaXRpb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihBY3Rpb25EaXJlY3Rpb24uTGVmdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGRpc3RhbmNlIHRoYXQgdGhlIHdpZGdldCBuZWVkcyB0byBiZSBtb3ZlZCBkb3duXG4gICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSAodGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRSb3coKSAtIHdpZGdldC5nZXRSb3coKSkgKyB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvd1NwYW4oKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCBtb3ZlIHRoZSB3aWRnZXQgZG93bndhcmRzXG4gICAgICAgICAgICB0aGlzLm1vdmVXaWRnZXREb3duKHdpZGdldCwgZGlzdGFuY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZnRlciBzaGlmdHMgaGF2ZSB0YWtlbiBwbGFjZSB3ZSBzaG91bGQgdmVyaWZ5IHRoZSBwbGFjZSBob2xkZXIgcG9zaXRpb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgKiBAcGFyYW0gc2hpZnREaXJlY3Rpb24gLSB0aGUgcG9zaXRpb24gd2lkZ2V0cyB3ZXJlIHNoaWZ0ZWRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24oc2hpZnREaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbikge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcGxhY2Vob2xkZXIgaXMgb3ZlciBhIHdpZGdldFxuICAgICAgICBpZiAodGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihwbGFjZWhvbGRlci5jb2x1bW4sIHBsYWNlaG9sZGVyLnJvdywgdHJ1ZSkubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBwbGFjZWhvbGRlciB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgICAgICBzd2l0Y2ggKHNoaWZ0RGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyQm91bmRzKHBsYWNlaG9sZGVyLnZpc2libGUsIHBsYWNlaG9sZGVyLnggKyB0aGlzLmdldENvbHVtbldpZHRoKCksIHBsYWNlaG9sZGVyLnksIHBsYWNlaG9sZGVyLndpZHRoLCBwbGFjZWhvbGRlci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyQm91bmRzKHBsYWNlaG9sZGVyLnZpc2libGUsIHBsYWNlaG9sZGVyLnggLSB0aGlzLmdldENvbHVtbldpZHRoKCksIHBsYWNlaG9sZGVyLnksIHBsYWNlaG9sZGVyLndpZHRoLCBwbGFjZWhvbGRlci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFsaWRhdGUgdGhpcyBuZXcgcG9zaXRpb24gYWdhaW5cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQbGFjZWhvbGRlclBvc2l0aW9uKHNoaWZ0RGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIHdpZGdldCBjYW4gYmUgbW92ZWQgbGVmdCAtIG9yIGlmIGl0IGNhbiBtb3ZlIHRoZSB3aWRnZXRzIHRvIHRoZSByaWdodCB0byBtYWtlIHNwYWNlIGZvciB0aGUgd2lkZ2V0XG4gICAgICovXG4gICAgY2FuV2lkZ2V0TW92ZUxlZnQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIHBlcmZvcm1Nb3ZlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgd2lkZ2V0IGlzIHRoZSBhY3Rpb24gd2lkZ2V0IG9yIG9jY3VwaWVzIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAgICAgaWYgKHdpZGdldCA9PT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldCB8fCB3aWRnZXQuZ2V0Q29sdW1uKCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIHBvc2l0aW9ucyByZXF1aXJlZFxuICAgICAgICBjb25zdCB0YXJnZXRTcGFjZXMgPSB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKCkuZmlsdGVyKHNwYWNlID0+IHNwYWNlLndpZGdldCA9PT0gd2lkZ2V0KS5tYXAoc3BhY2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29sdW1uOiBzcGFjZS5jb2x1bW4gLSB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCByb3c6IHNwYWNlLnJvdywgd2lkZ2V0OiBzcGFjZS53aWRnZXQgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHdpZGdldCBpbiB0aGUgcmVxdWlyZWQgcG9zaXRpb25zIGFuZCBpZiBzbywgY2FuIHRoZXkgbW92ZSByaWdodD9cbiAgICAgICAgY29uc3QgbW92ZWFibGUgPSB0YXJnZXRTcGFjZXMuZXZlcnkoc3BhY2UgPT4gdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihzcGFjZS5jb2x1bW4sIHNwYWNlLnJvdykuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHNwYWNlLndpZGdldCkuZXZlcnkod2d0ID0+IHRoaXMuY2FuV2lkZ2V0TW92ZUxlZnQod2d0KSkpO1xuXG4gICAgICAgIGlmIChwZXJmb3JtTW92ZSAmJiBtb3ZlYWJsZSkge1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGFsbCB3aWRnZXRzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgdGFyZ2V0U3BhY2VzLmZvckVhY2goc3BhY2UgPT4gdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihzcGFjZS5jb2x1bW4sIHNwYWNlLnJvdykuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHNwYWNlLndpZGdldCkuZm9yRWFjaCh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlTGVmdCh3Z3QsIHRydWUpKSk7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgY3VycmVudCB3aWRnZXQgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKHdpZGdldC5nZXRDb2x1bW4oKSAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIHdpZGdldCBjYW4gYmUgbW92ZWQgcmlnaHQgLSBvciBpZiBpdCBjYW4gbW92ZSB0aGUgd2lkZ2V0cyB0byB0aGUgcmlnaHQgdG8gbWFrZSBzcGFjZSBmb3IgdGhlIHdpZGdldFxuICAgICAqL1xuICAgIGNhbldpZGdldE1vdmVSaWdodCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgcGVyZm9ybU1vdmU6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB3aWRnZXQgaXMgdGhlIGRyYWdnaW5nIHdpZGdldCBvciB0aGUgd2lkZ2V0IG9jY3VwaWVzIHRoZSBmaW5hbCBjb2x1bW5cbiAgICAgICAgaWYgKHdpZGdldCA9PT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldCB8fCB3aWRnZXQuZ2V0Q29sdW1uKCkgKyB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpID09PSB0aGlzLm9wdGlvbnMuY29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcG9zaXRpb25zIHJlcXVpcmVkXG4gICAgICAgIGNvbnN0IHRhcmdldFNwYWNlcyA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKS5maWx0ZXIoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0ID09PSB3aWRnZXQpLm1hcChzcGFjZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2x1bW46IHNwYWNlLmNvbHVtbiArIHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIHJvdzogc3BhY2Uucm93LCB3aWRnZXQ6IHNwYWNlLndpZGdldCB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgd2lkZ2V0IGluIHRoZSByZXF1aXJlZCBwb3NpdGlvbnMgYW5kIGlmIHNvLCBjYW4gdGhleSBtb3ZlIHJpZ2h0P1xuICAgICAgICBjb25zdCBtb3ZlYWJsZSA9IHRhcmdldFNwYWNlcy5ldmVyeShzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5ldmVyeSh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlUmlnaHQod2d0KSkpO1xuXG4gICAgICAgIGlmIChwZXJmb3JtTW92ZSAmJiBtb3ZlYWJsZSkge1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGFsbCB3aWRnZXRzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgdGFyZ2V0U3BhY2VzLmZvckVhY2goc3BhY2UgPT4gdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihzcGFjZS5jb2x1bW4sIHNwYWNlLnJvdykuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHNwYWNlLndpZGdldCkuZm9yRWFjaCh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlUmlnaHQod2d0LCB0cnVlKSkpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGN1cnJlbnQgd2lkZ2V0IHRvIHRoZSByaWdodFxuICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbih3aWRnZXQuZ2V0Q29sdW1uKCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlYWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSB0aGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgd2lkZ2V0IGJlaW5nIGRyYWdnZWRcbiAgICAgKi9cbiAgICBzZXRXaWRnZXRPcmlnaW4oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3dpZGdldE9yaWdpbiA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRDb2x1bW4oKSxcbiAgICAgICAgICAgIHJvdzogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRSb3coKSxcbiAgICAgICAgICAgIGNvbHVtblNwYW46IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Q29sdW1uU3BhbigpLFxuICAgICAgICAgICAgcm93U3BhbjogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRSb3dTcGFuKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYWxsIHRoZSByZXF1aXJlZCBwb3NpdGlvbnMgaXMgYSB3aWRnZXQgd2FzIHRvIGJlIHBvc2l0aW9uZWQgYXQgYSBwYXJ0aWN1bGFyIHBvaW50XG4gICAgICovXG4gICAgZ2V0UmVxdWlyZWRTcGFjZXNGcm9tUG9pbnQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlcik6IERhc2hib2FyZFNwYWNlW10ge1xuICAgICAgICBjb25zdCBzcGFjZXM6IERhc2hib2FyZFNwYWNlW10gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCB5ID0gcm93OyB5IDwgcm93ICsgd2lkZ2V0LmdldFJvd1NwYW4oKTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gY29sdW1uOyB4IDwgY29sdW1uICsgd2lkZ2V0LmdldENvbHVtblNwYW4oKTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgc3BhY2VzLnB1c2goeyBjb2x1bW46IHgsIHJvdzogeSwgd2lkZ2V0OiB3aWRnZXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHdpZGdldHMgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGFjZWhvbGRlciAtIHRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIGNvbmZpcm1lZFxuICAgICAqL1xuICAgIHVwZGF0ZVdpZGdldFBvc2l0aW9ucyh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCkge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayBhbGwgc3BhY2VzIHRoZSBwbGFjZWhvbGRlciB3aWxsIG9jY3VweSBhbmQgbW92ZSBhbnkgd2lkZ2V0IGN1cnJlbnRseSBpbiB0aGVtIGRvd25cbiAgICAgICAgZm9yIChsZXQgY29sdW1uID0gcGxhY2Vob2xkZXIuY29sdW1uOyBjb2x1bW4gPCBwbGFjZWhvbGRlci5jb2x1bW4gKyBwbGFjZWhvbGRlci5jb2x1bW5TcGFuOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gcGxhY2Vob2xkZXIucm93OyByb3cgPCBwbGFjZWhvbGRlci5yb3cgKyBwbGFjZWhvbGRlci5yb3dTcGFuOyByb3crKykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihjb2x1bW4sIHJvdywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSB3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKHdndCA9PiB0aGlzLm1vdmVXaWRnZXREb3duKHdndCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGRhc2hib2FyZFxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIHRoZSB0b3AgaGFuZGxlIHRoZW4gZmlsbCBzcGFjZXNcbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3AgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRXaWRnZXRzVXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIHdpZGdldCBpcyBvY2N1cHlpbmcgYSBzcGVjaWZpYyByb3cgYW5kIGNvbHVtblxuICAgICAqIEBwYXJhbSBjb2x1bW4gVGhlIGNvbHVtbnMgdG8gY2hlY2sgaWYgb2NjdXBpZWRcbiAgICAgKiBAcGFyYW0gcm93IFRoZSByb3cgdG8gY2hlY2sgaWYgb2NjdXBpZWRcbiAgICAgKiBAcGFyYW0gaWdub3JlUmVzaXppbmcgV2hldGhlciBvciBub3QgdG8gaWdub3JlIHRoZSB3aWRnZXQgY3VycmVudGx5IGJlaW5nIHJlc2l6ZWRcbiAgICAgKi9cbiAgICBnZXRXaWRnZXRzQXRQb3NpdGlvbihjb2x1bW46IG51bWJlciwgcm93OiBudW1iZXIsIGlnbm9yZVJlc2l6aW5nOiBib29sZWFuID0gZmFsc2UpOiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKClcbiAgICAgICAgICAgIC5maWx0ZXIoc3BhY2UgPT4gc3BhY2UuY29sdW1uID09PSBjb2x1bW4gJiYgc3BhY2Uucm93ID09PSByb3cpXG4gICAgICAgICAgICAuZmlsdGVyKHNwYWNlID0+IHNwYWNlLndpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldCB8fCAhaWdub3JlUmVzaXppbmcpXG4gICAgICAgICAgICAubWFwKHNwYWNlID0+IHNwYWNlLndpZGdldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwbGFjZWhvbGRlciB2aXNpYmlsaXR5LCBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAqL1xuICAgIHNldFBsYWNlaG9sZGVyQm91bmRzKHZpc2libGU6IGJvb2xlYW4sIHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICBjb25zdCByb3VuZGluZyA9IHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gPT09IEFjdGlvbkRpcmVjdGlvbi5MZWZ0IHx8XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uID09PSBBY3Rpb25EaXJlY3Rpb24uVG9wID8gUm91bmRpbmcuUm91bmREb3duQmVsb3dIYWxmIDogUm91bmRpbmcuUm91bmRVcE92ZXJIYWxmO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLnZpc2libGUgPSB2aXNpYmxlO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtbiA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJDb2x1bW4oeCwgd2lkdGgpO1xuICAgICAgICBwbGFjZWhvbGRlci5yb3cgPSB0aGlzLmdldFBsYWNlaG9sZGVyUm93KHksIGhlaWdodCk7XG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtblNwYW4gPSB0aGlzLmdldFBsYWNlaG9sZGVyQ29sdW1uU3Bhbih3aWR0aCk7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvd1NwYW4gPSB0aGlzLmdldFBsYWNlaG9sZGVyUm93U3BhbihoZWlnaHQpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93c1xuICAgICAgICBjb25zdCByb3dDb3VudCA9IHRoaXMud2lkZ2V0cy5maWx0ZXIod2lkZ2V0ID0+IHdpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXZpb3VzLCB3aWRnZXQpID0+IE1hdGgubWF4KHdpZGdldC5nZXRSb3coKSArIHdpZGdldC5nZXRSb3dTcGFuKCksIHByZXZpb3VzKSwgMCk7XG5cbiAgICAgICAgLy8gY29uc3RyYWluIG1heGltdW0gcGxhY2Vob2xkZXIgcm93XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvdyA9IE1hdGgubWluKHBsYWNlaG9sZGVyLnJvdywgcm93Q291bnQpO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLnggPSAocGxhY2Vob2xkZXIuY29sdW1uICogdGhpcy5nZXRDb2x1bW5XaWR0aCgpKSArIHRoaXMub3B0aW9ucy5wYWRkaW5nO1xuICAgICAgICBwbGFjZWhvbGRlci55ID0gKHBsYWNlaG9sZGVyLnJvdyAqIHRoaXMuX3Jvd0hlaWdodCkgKyB0aGlzLm9wdGlvbnMucGFkZGluZztcbiAgICAgICAgcGxhY2Vob2xkZXIud2lkdGggPSAocGxhY2Vob2xkZXIuY29sdW1uU3BhbiAqIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSkgLSAodGhpcy5vcHRpb25zLnBhZGRpbmcgKiAyKTtcbiAgICAgICAgcGxhY2Vob2xkZXIuaGVpZ2h0ID0gKHBsYWNlaG9sZGVyLnJvd1NwYW4gKiB0aGlzLl9yb3dIZWlnaHQpIC0gKHRoaXMub3B0aW9ucy5wYWRkaW5nICogMik7XG5cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZXMgb2YgdGhlIHdpZGdldCB0byBtYXRjaCB0aGUgdmFsdWVzIG9mIHRoZSBwbGFjZWhvbGRlciAtIGhvd2V2ZXIgZG8gbm90IHJlbmRlciB0aGUgY2hhbmdlc1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldENvbHVtbihwbGFjZWhvbGRlci5jb2x1bW4sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRSb3cocGxhY2Vob2xkZXIucm93LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Q29sdW1uU3BhbihwbGFjZWhvbGRlci5jb2x1bW5TcGFuLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Um93U3BhbihwbGFjZWhvbGRlci5yb3dTcGFuLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyJC5uZXh0KHBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBsYWNlaG9sZGVyIGNvbHVtbiBwb3NpdGlvblxuICAgICAqL1xuICAgIGdldFBsYWNlaG9sZGVyQ29sdW1uKHg6IG51bWJlciwgd2lkdGg6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5nZXRDb2x1bW5Gcm9tUHgoeCwgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiA9PT0gQWN0aW9uRGlyZWN0aW9uLk1vdmUgPyBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGYgOiBSb3VuZGluZy5Sb3VuZERvd24pO1xuICAgICAgICBjb25zdCBjb2x1bW5TcGFuID0gTWF0aC5mbG9vcih3aWR0aCAvIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSk7XG4gICAgICAgIGNvbnN0IHVwcGVyTGltaXQgPSB0aGlzLmdldENvbHVtbkNvdW50KCkgLSBjb2x1bW5TcGFuO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIGxlZnQgdGhlbiBqdXN0IHJldHVybiB0aGUgY29sdW1uXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oY29sdW1uLCB1cHBlckxpbWl0KSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYW55IG92ZXJmbG93XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gd2lkdGggJSB0aGlzLmdldENvbHVtbldpZHRoKCk7XG5cbiAgICAgICAgcmV0dXJuICh4IDw9IDAgfHwgb3ZlcmZsb3cgPT09IDAgfHwgY29sdW1uU3BhbiA9PT0gMCB8fCBvdmVyZmxvdyA+ICh0aGlzLmdldENvbHVtbldpZHRoKCkgLyAyKSkgP1xuICAgICAgICAgICAgTWF0aC5tYXgoTWF0aC5taW4oY29sdW1uLCB1cHBlckxpbWl0KSwgMCkgOlxuICAgICAgICAgICAgTWF0aC5tYXgoTWF0aC5taW4oY29sdW1uICsgMSwgdXBwZXJMaW1pdCksIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29sdW1uIHNwYW4gb2YgdGhlIHBsYWNlaG9sZGVyXG4gICAgICovXG4gICAgZ2V0UGxhY2Vob2xkZXJDb2x1bW5TcGFuKHdpZHRoOiBudW1iZXIpOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IGNvbHVtblNwYW4gPSB0aGlzLmdldENvbHVtbkZyb21QeCh3aWR0aCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgcmlnaHQgb3IgbGVmdCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBjb2x1bW4gc3BhblxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlJpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21SaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkxlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNvbHVtblNwYW4sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGNvbHVtbiBzcGFuIGFuZCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB3aWR0aCAlIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKTtcblxuICAgICAgICByZXR1cm4gKGNvbHVtblNwYW4gPiAwICYmIG92ZXJmbG93ID4gKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSAvIDIpKSA/IE1hdGgubWF4KGNvbHVtblNwYW4gKyAxLCAxKSA6IE1hdGgubWF4KGNvbHVtblNwYW4sIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IHBvc2l0aW9uIG9mIHRoZSBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGdldFBsYWNlaG9sZGVyUm93KHk6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93RnJvbVB4KHksIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gPT09IEFjdGlvbkRpcmVjdGlvbi5Nb3ZlID8gUm91bmRpbmcuUm91bmRVcE92ZXJIYWxmIDogUm91bmRpbmcuUm91bmREb3duKTtcbiAgICAgICAgY29uc3Qgcm93U3BhbiA9IE1hdGguY2VpbChoZWlnaHQgLyB0aGlzLl9yb3dIZWlnaHQpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIHVwIHRoZW4ganVzdCByZXR1cm4gdGhlIHJvd1xuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvdywgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYW55IG92ZXJmbG93XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGhlaWdodCA8IHRoaXMuX3Jvd0hlaWdodCA/IDAgOiBoZWlnaHQgJSB0aGlzLl9yb3dIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuICh5IDw9IDAgfHwgcm93U3BhbiA9PT0gMCB8fCBvdmVyZmxvdyA9PT0gMCB8fCBvdmVyZmxvdyA+ICh0aGlzLl9yb3dIZWlnaHQgLyAyKSkgPyBNYXRoLm1heChyb3csIDApIDogTWF0aC5tYXgocm93ICsgMSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb3cgc3BhbiBvZiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgKi9cbiAgICBnZXRQbGFjZWhvbGRlclJvd1NwYW4oaGVpZ2h0OiBudW1iZXIpOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IHJvd1NwYW4gPSB0aGlzLmdldFJvd0Zyb21QeChoZWlnaHQpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIHVwIG9yIGRvd24gdGhlbiBqdXN0IHJldHVybiB0aGUgY29sdW1uIHNwYW5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3AgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b20gJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChyb3dTcGFuLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBjb2x1bW4gc3BhbiBhbmQgYW55IG92ZXJmbG93XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gaGVpZ2h0ICUgdGhpcy5fcm93SGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiAob3ZlcmZsb3cgPiAodGhpcy5fcm93SGVpZ2h0IC8gMikpID8gTWF0aC5tYXgocm93U3BhbiArIDEsIDEpIDogTWF0aC5tYXgocm93U3BhbiwgMSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1uRnJvbVB4KHg6IG51bWJlciwgcm91bmRpbmc6IFJvdW5kaW5nID0gUm91bmRpbmcuUm91bmREb3duKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCBjb2x1bW4gPSBNYXRoLmZsb29yKHggLyBNYXRoLmZsb29yKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSkpO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9ICh4ICUgTWF0aC5mbG9vcih0aGlzLmdldENvbHVtbldpZHRoKCkpKTtcbiAgICAgICAgY29uc3QgaGFsZiA9IHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSAvIDI7XG5cbiAgICAgICAgc3dpdGNoIChyb3VuZGluZykge1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uO1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bkJlbG93SGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPCBoYWxmID8gY29sdW1uIDogY29sdW1uICsgMTtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93ID4gaGFsZiA/IGNvbHVtbiArIDEgOiBjb2x1bW47XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmRVcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiAwID8gY29sdW1uICsgMSA6IGNvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ2V0Um93RnJvbVB4KHk6IG51bWJlciwgcm91bmRpbmc6IFJvdW5kaW5nID0gUm91bmRpbmcuUm91bmREb3duKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKHkgLyBNYXRoLmZsb29yKHRoaXMuX3Jvd0hlaWdodCkpO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9ICh5ICUgTWF0aC5mbG9vcih0aGlzLl9yb3dIZWlnaHQpKTtcbiAgICAgICAgY29uc3QgaGFsZiA9IHRoaXMuX3Jvd0hlaWdodCAvIDI7XG5cbiAgICAgICAgc3dpdGNoIChyb3VuZGluZykge1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bkJlbG93SGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPCBoYWxmID8gcm93IDogcm93ICsgMTtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93ID4gaGFsZiA/IHJvdyArIDEgOiByb3c7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmRVcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiAwID8gcm93ICsgMSA6IHJvdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbW1pdFdpZGdldENoYW5nZXMoKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBhbGwgdGhlIHZhbHVlcyB3ZSBuZWVkXG4gICAgICAgIGlmIChwbGFjZWhvbGRlci5jb2x1bW4gPT09IHVuZGVmaW5lZCB8fCBwbGFjZWhvbGRlci5yb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uU3BhbiA9PT0gdW5kZWZpbmVkIHx8IHBsYWNlaG9sZGVyLnJvd1NwYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRDb2x1bW4ocGxhY2Vob2xkZXIuY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Um93KHBsYWNlaG9sZGVyLnJvdyk7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldENvbHVtblNwYW4ocGxhY2Vob2xkZXIuY29sdW1uU3Bhbik7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldFJvd1NwYW4ocGxhY2Vob2xkZXIucm93U3Bhbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCBhbGwgcGxhY2Vob2xkZXIgdmFsdWVzXG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGxhY2Vob2xkZXIucm93ID0gdW5kZWZpbmVkO1xuICAgICAgICBwbGFjZWhvbGRlci5jb2x1bW5TcGFuID0gdW5kZWZpbmVkO1xuICAgICAgICBwbGFjZWhvbGRlci5yb3dTcGFuID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIG5ldyBwbGFjZWhvbGRlciB2YWx1ZXNcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciQubmV4dChwbGFjZWhvbGRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbHVtbiB3aWR0aFxuICAgICAqL1xuICAgIGdldENvbHVtbldpZHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuY29sdW1uV2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgcG9wdWxhdGVkIHdpdGggd2lkZ2V0c1xuICAgICAqL1xuICAgIGdldFJvd0NvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMucmVkdWNlKChwcmV2aW91cywgd2lkZ2V0KSA9PiBNYXRoLm1heCh3aWRnZXQuZ2V0Um93KCkgKyB3aWRnZXQuZ2V0Um93U3BhbigpLCBwcmV2aW91cyksIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBkYXNoYm9hcmQgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBzZXREYXNoYm9hcmRIZWlnaHQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc2l6ZSB0aGUgZGFzaGJvYXJkIGNvbnRhaW5lciB0byBlbnN1cmUgYWxsIHJvd3MgZml0XG4gICAgICAgIGxldCByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICAvLyBpZiB3ZSBzaG91bGQgc2hvdyBhbiBlbXB0eSByb3cgaW5jcmVtZW50IHRoZSByb3cgY291bnQgYnkgMVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVtcHR5Um93KSB7XG4gICAgICAgICAgICByb3dDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHVuZGVmaW5lZCwgcm93Q291bnQgKiB0aGlzLl9yb3dIZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yZGVycyB0aGUgei1pbmRleCBvZiBhbGwgd2lkZ2V0cyB0byBtb3ZlIHRoZSBhY3RpdmUgb25lIHRvIHRoZSBmcm9udFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0aGF0IHNob3VsZCBiZSBicm91Z2h0IHRvIHRoZSBmcm9udFxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChfd2lkZ2V0ID0+IF93aWRnZXQgPT09IHdpZGdldCA/IF93aWRnZXQuYnJpbmdUb0Zyb250KCkgOiBfd2lkZ2V0LnNlbmRUb0JhY2soKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIHdpZGdldCBkb3duIC0gaWYgd2lkZ2V0cyBhcmUgaW4gdGhlIHBvc2l0aW9uIGJlbG93LCB0aGVuIG1vdmUgdGhlbSBkb3duIGZ1cnRoZXJcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gbW92ZSBkb3dud2FyZHNcbiAgICAgKi9cbiAgICBtb3ZlV2lkZ2V0RG93bih3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgZGlzdGFuY2U6IG51bWJlciA9IDEpOiB2b2lkIHtcblxuICAgICAgICAvLyBtb3ZlIHRoZSB3aWRnZXQgZG93biBvbmUgcG9zaXRpb25cbiAgICAgICAgd2lkZ2V0LnNldFJvdyh3aWRnZXQuZ2V0Um93KCkgKyBkaXN0YW5jZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgZXZlcnkgc3BhY2UgdGhlIHdpZGdldCBvY2N1cGllcyBmb3IgY29sbGlzaW9uc1xuICAgICAgICB0aGlzLmZvckVhY2hCbG9jayh3aWRnZXQsIChjb2x1bW4sIHJvdykgPT5cbiAgICAgICAgICAgIHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oY29sdW1uLCByb3csIHRydWUpXG4gICAgICAgICAgICAgICAgLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSB3aWRnZXQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2god2d0ID0+IHRoaXMubW92ZVdpZGdldERvd24od2d0LCBkaXN0YW5jZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaWRnZXRzIHNob3VsZCBub3QgYmUgYWxsb3dlZCB0byBoYXZlIGEgdmFjYW50IHNwYWNlIGFib3ZlIHRoZW0gLSBpZiB0aGVyZSBpcyBvbmUgdGhleSBzaG91bGQgbW92ZSB1cHdhcmRzIHRvIGZpbGwgaXRcbiAgICAgKi9cbiAgICBzaGlmdFdpZGdldHNVcCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIG9yIG5vdCBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIC0gaWYgc28gd2UgbmVlZCB0byByZXBlYXQgdW50aWwgc3RhYmxlXG4gICAgICAgIGxldCBzdGFibGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgZWFjaCB3aWRnZXQgYW5kXG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHdpZGdldCA9PiB7XG5cbiAgICAgICAgICAgIC8vIGlmIHdpZGdldCBpcyBhbHJlYWR5IG9uIHRoZSB0b3Agcm93IHRoZW4gZG8gbm90aGluZ1xuICAgICAgICAgICAgaWYgKHdpZGdldC5nZXRSb3coKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZyBhbmQgdGhpcyBpcyB0aGUgZHJhZ2dpbmcgd2lkZ2V0IHRoZW4gc2tpcFxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldCAmJiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0ID09PSB3aWRnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdldFBvc2l0aW9uQXZhaWxhYmxlKHdpZGdldC5nZXRDb2x1bW4oKSwgd2lkZ2V0LmdldFJvdygpIC0gMSwgd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgMSkpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Um93KHdpZGdldC5nZXRSb3coKSAtIDEpO1xuICAgICAgICAgICAgICAgIHN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBjaGFuZ2VzIG9jY3VycmVkIHRoZW4gd2Ugc2hvdWxkIHJlcGVhdCB0aGUgcHJvY2Vzc1xuICAgICAgICBpZiAoIXN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zaGlmdFdpZGdldHNVcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIGVhY2ggc3BhY2UgYSB3aWRnZXQgb2NjdXBpZWRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gZGV0ZXJtaW5lIHNwYWNlc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIHNwYWNlLCBzaG91bGQgZXhwZWN0IGEgY29sdW1uIGFuZCByb3cgYXJndW1lbnQgd2l0aHQgaGUgY29udGV4dCBiZWluZyB0aGUgd2lkZ2V0XG4gICAgICovXG4gICAgZm9yRWFjaEJsb2NrKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBjYWxsYmFjazogKGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBmb3IgKGxldCByb3cgPSB3aWRnZXQuZ2V0Um93KCk7IHJvdyA8IHdpZGdldC5nZXRSb3coKSArIHdpZGdldC5nZXRSb3dTcGFuKCk7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSB3aWRnZXQuZ2V0Q29sdW1uKCk7IGNvbHVtbiA8IHdpZGdldC5nZXRDb2x1bW4oKSArIHdpZGdldC5nZXRDb2x1bW5TcGFuKCk7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh3aWRnZXQsIGNvbHVtbiwgcm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrZWQgPyAxIDogdGhpcy5vcHRpb25zLmNvbHVtbnM7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdE9wdGlvbnM6IERhc2hib2FyZE9wdGlvbnMgPSB7IGNvbHVtbnM6IDUsIHBhZGRpbmc6IDUsIG1pbldpZHRoOiAxMDAsIG1pbkhlaWdodDogMTAwLCBlbXB0eVJvdzogdHJ1ZSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZERpbWVuc2lvbnMge1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGhlaWdodD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRXaWRnZXREaW1lbnNpb25zIHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkQWN0aW9uIHtcbiAgICB3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudDtcbiAgICBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbjtcbiAgICBldmVudDogTW91c2VFdmVudDtcbiAgICBoYW5kbGU/OiBIVE1MRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRTcGFjZSB7XG4gICAgd2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQ7XG4gICAgY29sdW1uOiBudW1iZXI7XG4gICAgcm93OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkUGxhY2Vob2xkZXIge1xuICAgIHZpc2libGU6IGJvb2xlYW47XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xuICAgIGNvbHVtbj86IG51bWJlcjtcbiAgICByb3c/OiBudW1iZXI7XG4gICAgY29sdW1uU3Bhbj86IG51bWJlcjtcbiAgICByb3dTcGFuPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZENhY2hlIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGNvbHVtbjogbnVtYmVyO1xuICAgIHJvdzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZExheW91dERhdGEge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgY29sOiBudW1iZXI7XG4gICAgcm93OiBudW1iZXI7XG4gICAgY29sU3BhbjogbnVtYmVyO1xuICAgIHJvd1NwYW46IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gQWN0aW9uRGlyZWN0aW9uIHtcbiAgICBUb3AgPSAwLFxuICAgIFRvcFJpZ2h0ID0gMSxcbiAgICBSaWdodCA9IDIsXG4gICAgQm90dG9tUmlnaHQgPSAzLFxuICAgIEJvdHRvbSA9IDQsXG4gICAgQm90dG9tTGVmdCA9IDUsXG4gICAgTGVmdCA9IDYsXG4gICAgVG9wTGVmdCA9IDcsXG4gICAgTW92ZSA9IDhcbn1cblxuZXhwb3J0IGVudW0gUm91bmRpbmcge1xuICAgIFJvdW5kRG93bixcbiAgICBSb3VuZERvd25CZWxvd0hhbGYsXG4gICAgUm91bmRVcCxcbiAgICBSb3VuZFVwT3ZlckhhbGZcbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplRGltZW5zaW9ucyB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5zZXJ2aWNlJztcbmltcG9ydCB7IERhc2hib2FyZExheW91dERhdGEsIERhc2hib2FyZFNlcnZpY2UsIGRlZmF1bHRPcHRpb25zIH0gZnJvbSAnLi9kYXNoYm9hcmQuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGFzaGJvYXJkJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgI2Rhc2hib2FyZCBjbGFzcz1cImRhc2hib2FyZC1jb250YWluZXJcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImRhc2hib2FyZFNlcnZpY2UuaGVpZ2h0JCB8IGFzeW5jXCI+XG4gICAgPGRpdiAodXhSZXNpemUpPVwib25SZXNpemUoJGV2ZW50KVwiIFt0aHJvdHRsZV09XCIxNlwiIGNsYXNzPVwiZGFzaGJvYXJkXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwicG9zaXRpb24taW5kaWNhdG9yXCIgKm5nSWY9XCIoZGFzaGJvYXJkU2VydmljZS5wbGFjZWhvbGRlciQgfCBhc3luYykudmlzaWJsZVwiIFxuICAgICAgICBbc3R5bGUubGVmdC5weF09XCIoZGFzaGJvYXJkU2VydmljZS5wbGFjZWhvbGRlciQgfCBhc3luYykueFwiIFxuICAgICAgICBbc3R5bGUudG9wLnB4XT1cIihkYXNoYm9hcmRTZXJ2aWNlLnBsYWNlaG9sZGVyJCB8IGFzeW5jKS55XCIgXG4gICAgICAgIFtzdHlsZS53aWR0aC5weF09XCIoZGFzaGJvYXJkU2VydmljZS5wbGFjZWhvbGRlciQgfCBhc3luYykud2lkdGhcIlxuICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT1cIihkYXNoYm9hcmRTZXJ2aWNlLnBsYWNlaG9sZGVyJCB8IGFzeW5jKS5oZWlnaHRcIj48L2Rpdj5cbjwvZGl2PmAsXG4gICAgcHJvdmlkZXJzOiBbRGFzaGJvYXJkU2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBASW5wdXQoKSBzZXQgbGF5b3V0KGxheW91dDogRGFzaGJvYXJkTGF5b3V0RGF0YVtdKSB7XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5sYXlvdXQkLm5leHQobGF5b3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBJbnB1dCgpIHNldCBvcHRpb25zKG9wdGlvbnM6IERhc2hib2FyZE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9wdGlvbnMkLm5leHQoeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgbGF5b3V0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXNoYm9hcmRMYXlvdXREYXRhW10+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdkYXNoYm9hcmQnKSBkYXNoYm9hcmRFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhc2hib2FyZFNlcnZpY2U6IERhc2hib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgZGFzaGJvYXJkU2VydmljZS5sYXlvdXQkLnN1YnNjcmliZShsYXlvdXQgPT4gdGhpcy5sYXlvdXRDaGFuZ2UuZW1pdChsYXlvdXQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGluaXRpYWwgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnNldERpbWVuc2lvbnModGhpcy5kYXNoYm9hcmRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgsIHRoaXMuZGFzaGJvYXJkRWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCk7XG4gICAgfVxuXG4gICAgb25SZXNpemUoZXZlbnQ6IFJlc2l6ZURpbWVuc2lvbnMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnNldERpbWVuc2lvbnMoZXZlbnQud2lkdGgsIGV2ZW50LmhlaWdodCk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZE9wdGlvbnMge1xuICAgIGNvbHVtbnM/OiBudW1iZXI7XG4gICAgcGFkZGluZz86IG51bWJlcjtcbiAgICBtaW5XaWR0aD86IG51bWJlcjtcbiAgICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gICAgcm93SGVpZ2h0PzogbnVtYmVyO1xuICAgIGVtcHR5Um93PzogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSwgSG9zdEJpbmRpbmcsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhc2hib2FyZFNlcnZpY2UsIEFjdGlvbkRpcmVjdGlvbiB9IGZyb20gJy4uL2Rhc2hib2FyZC5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXNoYm9hcmQtd2lkZ2V0JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3aWRnZXQtY29udGVudCB3aWRnZXQtY29sLXNwYW4te3sgZ2V0Q29sdW1uU3BhbigpIH19IHdpZGdldC1yb3ctc3Bhbi17eyBnZXRSb3dTcGFuKCkgfX1cIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cblxuPGRpdiB1eERyYWcgI2hhbmRsZVRvcCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS10b3BcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVUb3AsICRldmVudCwgMClcIlxuICAgIChkcmFnKT1cImRyYWcoaGFuZGxlVG9wLCAkZXZlbnQsIDApXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS50b3AucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVUb3BSaWdodCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS10b3AtcmlnaHRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVUb3BSaWdodCwgJGV2ZW50LCAxKVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVUb3BSaWdodCwgJGV2ZW50LCAxKVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUudG9wLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbc3R5bGUucmlnaHQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSAmJiAhKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlUmlnaHQgY2xhc3M9XCJyZXNpemVyLWhhbmRsZSBoYW5kbGUtcmlnaHRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVSaWdodCwgJGV2ZW50LCAyKVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVSaWdodCwgJGV2ZW50LCAyKVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUucmlnaHQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSB8fCAoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVCb3R0b21SaWdodCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS1ib3R0b20tcmlnaHRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVCb3R0b21SaWdodCwgJGV2ZW50LCAzKVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVCb3R0b21SaWdodCwgJGV2ZW50LCAzKVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUuYm90dG9tLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbc3R5bGUucmlnaHQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSAmJiAhKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlQm90dG9tIGNsYXNzPVwicmVzaXplci1oYW5kbGUgaGFuZGxlLWJvdHRvbVwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZUJvdHRvbSwgJGV2ZW50LCA0KVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVCb3R0b20sICRldmVudCwgNClcIlxuICAgIChkcmFnZW5kKT1cImRyYWdlbmQoKVwiXG4gICAgW3N0eWxlLmJvdHRvbS5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlXCI+XG48L2Rpdj5cblxuPGRpdiB1eERyYWcgI2hhbmRsZUJvdHRvbUxlZnQgY2xhc3M9XCJyZXNpemVyLWhhbmRsZSBoYW5kbGUtYm90dG9tLWxlZnRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVCb3R0b21MZWZ0LCAkZXZlbnQsIDUpXCJcbiAgICAoZHJhZyk9XCJkcmFnKGhhbmRsZUJvdHRvbUxlZnQsICRldmVudCwgNSlcIlxuICAgIChkcmFnZW5kKT1cImRyYWdlbmQoKVwiXG4gICAgW3N0eWxlLmJvdHRvbS5weF09XCJwYWRkaW5nXCIgXG4gICAgW3N0eWxlLmxlZnQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSAmJiAhKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlTGVmdCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS1sZWZ0XCIgXG4gICAgKGRyYWdzdGFydCk9XCJkcmFnc3RhcnQoaGFuZGxlTGVmdCwgJGV2ZW50LCA2KVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVMZWZ0LCAkZXZlbnQsIDYpXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS5sZWZ0LnB4XT1cInBhZGRpbmdcIiBcbiAgICBbaGlkZGVuXT1cIiFyZXNpemFibGUgfHwgKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlVG9wTGVmdCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS10b3AtbGVmdFwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZVRvcExlZnQsICRldmVudCwgNylcIlxuICAgIChkcmFnKT1cImRyYWcoaGFuZGxlVG9wTGVmdCwgJGV2ZW50LCA3KVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUudG9wLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbc3R5bGUubGVmdC5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlICYmICEoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNvbDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIHJvdzogbnVtYmVyO1xuICAgIEBJbnB1dCgpIGNvbFNwYW46IG51bWJlciA9IDE7XG4gICAgQElucHV0KCkgcm93U3BhbjogbnVtYmVyID0gMTtcbiAgICBASW5wdXQoKSByZXNpemFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBIb3N0QmluZGluZygnc3R5bGUubGVmdC5weCcpIHg6IG51bWJlciA9IDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS50b3AucHgnKSB5OiBudW1iZXIgPSAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUud2lkdGgucHgnKSB3aWR0aDogbnVtYmVyID0gMTAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuaGVpZ2h0LnB4JykgaGVpZ2h0OiBudW1iZXIgPSAxMDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5wYWRkaW5nLnB4JykgcGFkZGluZzogbnVtYmVyID0gMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnotaW5kZXgnKSB6SW5kZXg6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIF9jb2x1bW46IFN0YWNrYWJsZVZhbHVlID0geyByZWd1bGFyOiB1bmRlZmluZWQsIHN0YWNrZWQ6IHVuZGVmaW5lZCB9O1xuICAgIHByaXZhdGUgX3JvdzogU3RhY2thYmxlVmFsdWUgPSB7IHJlZ3VsYXI6IHVuZGVmaW5lZCwgc3RhY2tlZDogdW5kZWZpbmVkIH07XG4gICAgcHJpdmF0ZSBfY29sdW1uU3BhbjogU3RhY2thYmxlVmFsdWUgPSB7IHJlZ3VsYXI6IDEsIHN0YWNrZWQ6IDEgfTtcbiAgICBwcml2YXRlIF9yb3dTcGFuOiBTdGFja2FibGVWYWx1ZSA9IHsgcmVndWxhcjogMSwgc3RhY2tlZDogMSB9O1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhc2hib2FyZFNlcnZpY2U6IERhc2hib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gZGFzaGJvYXJkU2VydmljZS5vcHRpb25zJC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGUoKSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5fY29sdW1uU3Bhbi5yZWd1bGFyID0gdGhpcy5jb2xTcGFuO1xuICAgICAgICB0aGlzLl9yb3dTcGFuLnJlZ3VsYXIgPSB0aGlzLnJvd1NwYW47XG5cbiAgICAgICAgaWYgKCF0aGlzLmlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rhc2hib2FyZCBXaWRnZXQgaXMgbWlzc2luZyBhbiBJRC4nKTtcblxuICAgICAgICAgICAgLy8gc2V0IHJhbmRvbSBpZCAtIGtlZXBzIHRoaW5ncyB3b3JraW5nIGJ1dCBwcmV2ZW50cyBleHBvcnRpbmcgb2YgcG9zaXRpb25zXG4gICAgICAgICAgICB0aGlzLmlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICAvLyBhZGQgdGhlIHdpZGdldCB0byB0aGUgZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5hZGRXaWRnZXQodGhpcyk7XG5cbiAgICAgICAgLy8gYXBwbHkgdGhlIGN1cnJlbnQgb3B0aW9uc1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGNvbXBvbmVudCBpcyByZW1vdmVkLCB0aGVuIHVucmVnaXN0ZXIgaXQgZnJvbSB0aGUgc2VydmljZVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnJlbW92ZVdpZGdldCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgY3VycmVudCBkYXNoYm9hcmQgb3B0aW9uc1xuICAgICAqL1xuICAgIHVwZGF0ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgb3B0aW9ucyBhdCB0aGUgdGltZSBcbiAgICAgICAgY29uc3QgeyBwYWRkaW5nLCBjb2x1bW5zIH0gPSB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub3B0aW9ucztcblxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICB0aGlzLl9jb2x1bW5TcGFuLnN0YWNrZWQgPSBjb2x1bW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYWN0dWFsIHBvc2l0aW9uIGFuZCBzaXplIHZhbHVlc1xuICAgICAqL1xuICAgIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy54ID0gdGhpcy5nZXRDb2x1bW4oKSAqIHRoaXMuZGFzaGJvYXJkU2VydmljZS5nZXRDb2x1bW5XaWR0aCgpO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLmdldFJvdygpICogdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmdldFJvd0hlaWdodCgpO1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5nZXRDb2x1bW5TcGFuKCkgKiB0aGlzLmRhc2hib2FyZFNlcnZpY2UuZ2V0Q29sdW1uV2lkdGgoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmdldFJvd1NwYW4oKSAqIHRoaXMuZGFzaGJvYXJkU2VydmljZS5nZXRSb3dIZWlnaHQoKTtcbiAgICB9XG5cbiAgICBnZXRDb2x1bW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2thYmxlVmFsdWUodGhpcy5fY29sdW1uKTtcbiAgICB9XG5cbiAgICBnZXRSb3coKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93KTtcbiAgICB9XG5cbiAgICBzZXRDb2x1bW4oY29sdW1uOiBudW1iZXIsIHJlbmRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW4sIGNvbHVtbik7XG5cbiAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJvdyhyb3c6IG51bWJlciwgcmVuZGVyOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFN0YWNrYWJsZVZhbHVlKHRoaXMuX3Jvdywgcm93KTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1uU3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW5TcGFuKTtcbiAgICB9XG5cbiAgICBnZXRSb3dTcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrYWJsZVZhbHVlKHRoaXMuX3Jvd1NwYW4pO1xuICAgIH1cblxuICAgIHNldENvbHVtblNwYW4oY29sdW1uU3BhbjogbnVtYmVyLCByZW5kZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhY2thYmxlVmFsdWUodGhpcy5fY29sdW1uU3BhbiwgY29sdW1uU3Bhbik7XG5cbiAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJvd1NwYW4ocm93U3BhbjogbnVtYmVyLCByZW5kZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93U3Bhbiwgcm93U3Bhbik7XG5cbiAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJyaW5nVG9Gcm9udCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy56SW5kZXggPSAxO1xuICAgIH1cblxuICAgIHNlbmRUb0JhY2soKTogdm9pZCB7XG4gICAgICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBzZXRCb3VuZHMoeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgZHJhZ3N0YXJ0KGhhbmRsZTogSFRNTEVsZW1lbnQsIGV2ZW50OiBNb3VzZUV2ZW50LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub25SZXNpemVTdGFydCh7IHdpZGdldDogdGhpcywgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGV2ZW50OiBldmVudCwgaGFuZGxlOiBoYW5kbGUgfSk7XG4gICAgfVxuXG4gICAgZHJhZyhoYW5kbGU6IEhUTUxFbGVtZW50LCBldmVudDogTW91c2VFdmVudCwgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9uUmVzaXplRHJhZyh7IHdpZGdldDogdGhpcywgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGV2ZW50OiBldmVudCwgaGFuZGxlOiBoYW5kbGUgfSk7XG4gICAgfVxuXG4gICAgZHJhZ2VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9uUmVzaXplRW5kKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGF1dG9tYXRpYyBzZXR0aW5nIG9mIHN0YWNrYWJsZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBUaGUgY3VycmVudCBTdGFja2FibGVWYWx1ZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBpbiB0aGUgYXBwcm9wcmlhdGUgZmllbGRcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFN0YWNrYWJsZVZhbHVlKHByb3BlcnR5OiBTdGFja2FibGVWYWx1ZSwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCkge1xuICAgICAgICAgICAgcHJvcGVydHkuc3RhY2tlZCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydHkucmVndWxhciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZSBmcm9tIGEgc3RhY2thYmxlIHZhbHVlXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBTdGFja2FibGUgdmFsdWUgb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTdGFja2FibGVWYWx1ZShwcm9wZXJ0eTogU3RhY2thYmxlVmFsdWUpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnN0YWNrZWQgPyBwcm9wZXJ0eS5zdGFja2VkIDogcHJvcGVydHkucmVndWxhcjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2thYmxlVmFsdWUge1xuICAgIHJlZ3VsYXI6IG51bWJlcjtcbiAgICBzdGFja2VkOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhEcmFnXSdcbn0pXG5leHBvcnQgY2xhc3MgRHJhZ0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogRGV0ZW1pbmUgaWYgd2Ugc2hvdWxkIHNob3cgYSBjbG9uZSB3aGVuIGRyYWdnaW5nICovXG4gICAgQElucHV0KCkgY2xvbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBBbGxvdyB0aGUgZHJhZ2dpbmcgdG8gYmUgZW5hYmxlZC9kaXNhYmxlZCAqL1xuICAgIEBJbnB1dCgpIGRyYWdnYWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIGRyYWdnaW5nIHN0YXJ0cyAqL1xuICAgIEBPdXRwdXQoKSBkcmFnc3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyB3aGlsZSBkcmFnZ2luZyAqL1xuICAgIEBPdXRwdXQoKSBkcmFnID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqIEVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgZHJhZ2dpbmcgZmluaXNoZXMgKi9cbiAgICBAT3V0cHV0KCkgZHJhZ2VuZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBTdG9yZSB0aGUgZWxlbWVudCB3ZSBoYXZlIGNsb25lZCAqL1xuICAgIHByaXZhdGUgX2Nsb25lOiBFbGVtZW50O1xuXG4gICAgLyoqIFN0b3JlIHRoZSBtb3VzZSBvZmZzZXQgZm9yIHRoZSBjbG9uZWQgZWxlbWVudCBwb3NpdGlvbiAqL1xuICAgIHByaXZhdGUgX29mZnNldDogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9O1xuXG4gICAgLyoqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIGZyb20gdGhlIG1vdXNlIGRvd24gZXZlbnQgKi9cbiAgICBwcml2YXRlIF9tb3VzZWRvd24kID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicpO1xuXG4gICAgLyoqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIGZyb20gdGhlIG1vdXNlIG1vdmUgZXZlbnQgKi9cbiAgICBwcml2YXRlIF9tb3VzZW1vdmUkID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KGRvY3VtZW50LCAnbW91c2Vtb3ZlJyk7XG5cbiAgICAvKiogQ3JlYXRlIGFuIG9ic2VydmFibGUgZnJvbSB0aGUgbW91c2UgdXAgZXZlbnQgKi9cbiAgICBwcml2YXRlIF9tb3VzZXVwJCA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pihkb2N1bWVudCwgJ21vdXNldXAnKTtcblxuICAgIC8qKiBVc2UgYW4gb2JzZXJ2YWJsZSB0byB1bnN1YnNjcmliZSBmcm9tIGFsbCBzdWJzY3JpcHRpb25zICovXG4gICAgcHJvdGVjdGVkIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICAgICAgdGhpcy5fbW91c2Vkb3duJC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmRyYWdnYWJsZSksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5kcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgZXZlbnRzIGFuZCBjcmVhdGUgY2xvbmUgd2hlbiBkcmFnIHN0YXJ0cyAqL1xuICAgIGRyYWdTdGFydChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNsb25lKSB7XG4gICAgICAgICAgICAvLyBjbG9uZSB0aGUgbm9kZVxuICAgICAgICAgICAgdGhpcy5jbG9uZU5vZGUoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYSBjbGFzcyB0byB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWRyYWctZHJhZ2dpbmcnKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5kcmFnc3RhcnQuZW1pdChldmVudCkpO1xuXG4gICAgICAgIHRoaXMuX21vdXNlbW92ZSQucGlwZSh0YWtlVW50aWwodGhpcy5fbW91c2V1cCQpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5kcmFnTW92ZS5iaW5kKHRoaXMpLCBudWxsLCB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgZXZlbnQgYW5kIHVwZGF0ZSBjbG9uZSBwb3NpdGlvbiB3aGVuIGRyYWdnaW5nIG1vdmVzICovXG4gICAgZHJhZ01vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAodGhpcy5fY2xvbmUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZVBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLmRyYWcuZW1pdChldmVudCkpO1xuICAgIH1cblxuICAgIC8qKiBFbWl0IGV2ZW50IGFuZCBkZXN0cm95IGNsb25lIHdoZW4gZHJhZ2dpbmcgZW5kcyAqL1xuICAgIGRyYWdFbmQoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIGNsb25lLCByZW1vdmUgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Nsb25lKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDaGlsZChkb2N1bWVudC5ib2R5LCB0aGlzLl9jbG9uZSk7XG4gICAgICAgICAgICB0aGlzLl9jbG9uZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIGRyYWdnaW5nIGNsYXNzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWRyYWctZHJhZ2dpbmcnKTtcblxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuZHJhZ2VuZC5lbWl0KCkpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW4gZXhhY3QgY2xvbmUgb2YgYW4gZWxlbWVudCAqL1xuICAgIGNsb25lTm9kZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGR1cGxpY2F0ZSB0aGUgbm9kZVxuICAgICAgICB0aGlzLl9jbG9uZSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0geyB4OiBldmVudC5jbGllbnRYIC0gbGVmdCwgeTogZXZlbnQuY2xpZW50WSAtIHRvcCB9O1xuXG4gICAgICAgIC8vIGlubGluZSBhbGwgc3R5bGVzIHNvIGl0IGxvb2tzIGlkZW50aWNhbCByZWdhcmRsZXNzIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgRE9NXG4gICAgICAgIHRoaXMuaW5saW5lU3R5bGVzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fY2xvbmUpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBjYW4gZWFzaWx5IHBvc2l0aW9uIHRoZSBub2RlIGFuIGl0IGlzIGFib3ZlIGFsbCBvdGhlciBlbGVtZW50c1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fY2xvbmUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2Nsb25lLCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICd6LWluZGV4JywgJzk5OTk5Jyk7XG5cbiAgICAgICAgLy8gYXBwbHkgYSBjbGFzcyB0byBhbGxvdyBjdXN0b20gc3R5bGluZ1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9jbG9uZSwgJ3V4LWRyYWctZHJhZ2dpbmctY2xvbmUnKTtcblxuICAgICAgICAvLyBpbnNlcnQgdGhlIGNsb25lZCBlbGVtZW50XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmJvZHksIHRoaXMuX2Nsb25lKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGNsb25lZCBlbGVtZW50IGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVOb2RlUG9zaXRpb24oZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKiBQb3NpdGlvbiB0aGUgY2xvbmUgcmVsYXRpdmUgdG8gdGhlIG1vdXNlICovXG4gICAgdXBkYXRlTm9kZVBvc2l0aW9uKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2Nsb25lLCAnbGVmdCcsIChldmVudC5wYWdlWCAtIHRoaXMuX29mZnNldC54KSArICdweCcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9jbG9uZSwgJ3RvcCcsIChldmVudC5wYWdlWSAtIHRoaXMuX29mZnNldC55KSArICdweCcpO1xuICAgIH1cblxuICAgIC8qKiBJbmxpbmUgYWxsIHN0eWxlcyB0byBlbnN1cmUgc3R5bGluZyBpcyBjb25zaXN0ZW50IHJlZ2FyZGxlc3Mgb2YgaXRzIHBvc2l0aW9uIGluIHRoZSBkb20gKi9cbiAgICBpbmxpbmVTdHlsZXMoc291cmNlOiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gZ2V0IGFsbCB0aGUgY29tcHV0ZWQgc3R5bGVzIGZyb20gdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc291cmNlKTtcblxuICAgICAgICAvLyBpbmxpbmUgZXZlcnkgc3BlY2lmaWVkIHN0eWxlXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHN0eWxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlcy5pdGVtKGlkeCk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGFyZ2V0LCBzdHlsZXNbaWR4XSwgc3R5bGVzW3N0eWxlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgd2UgZG9udCBjYXB0dXJlIGFueSBtb3ZlIGV2ZW50c1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0YXJnZXQsICdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cbiAgICAgICAgLy8gZG8gdGhlIHNhbWUgZm9yIGFsbCB0aGUgY2hpbGQgZWxlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lU3R5bGVzKHNvdXJjZS5jaGlsZHJlbltpZHhdLCB0YXJnZXQuY2hpbGRyZW5baWR4XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVW5zdWJzY3JpYmUgZnJvbSBhbGwgc3Vic2NyaXB0aW9ucyAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBOZ1pvbmUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRHJhZ0RpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy9kcmFnLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBBY3Rpb25EaXJlY3Rpb24sIERhc2hib2FyZFNlcnZpY2UgfSBmcm9tICcuLi9kYXNoYm9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgfSBmcm9tICcuLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eERhc2hib2FyZFdpZGdldERyYWdIYW5kbGVdLCBbdXgtZGFzaGJvYXJkLXdpZGdldC1kcmFnLWhhbmRsZV0nXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZERyYWdIYW5kbGVEaXJlY3RpdmUgZXh0ZW5kcyBEcmFnRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBkYXNoYm9hcmRTZXJ2aWNlOiBEYXNoYm9hcmRTZXJ2aWNlLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBuZ1pvbmU6IE5nWm9uZSwgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgICAgICBzdXBlcihlbGVtZW50UmVmLCBuZ1pvbmUsIHJlbmRlcmVyKTtcblxuICAgICAgICB0aGlzLmRyYWdzdGFydC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IGRhc2hib2FyZFNlcnZpY2Uub25EcmFnU3RhcnQoeyB3aWRnZXQ6IHdpZGdldCwgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24uTW92ZSwgZXZlbnQ6IGV2ZW50IH0pKTtcblxuICAgICAgICB0aGlzLmRyYWcucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiBkYXNoYm9hcmRTZXJ2aWNlLm9uRHJhZyh7IHdpZGdldDogd2lkZ2V0LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbi5Nb3ZlLCBldmVudDogZXZlbnQgfSkpO1xuXG4gICAgICAgIHRoaXMuZHJhZ2VuZC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiBkYXNoYm9hcmRTZXJ2aWNlLm9uRHJhZ0VuZCgpKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHJhZ0RpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZy5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtEcmFnRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtEcmFnRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBEcmFnTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBEYXNoYm9hcmRDb21wb25lbnQgfSBmcm9tICcuL2Rhc2hib2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50IH0gZnJvbSAnLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkU2VydmljZSB9IGZyb20gJy4vZGFzaGJvYXJkLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGFzaGJvYXJkRHJhZ0hhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZy1oYW5kbGUvZHJhZy1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlM6IGFueVtdID0gW1xuICAgIERhc2hib2FyZENvbXBvbmVudCxcbiAgICBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsXG4gICAgRGFzaGJvYXJkRHJhZ0hhbmRsZURpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUmVzaXplTW9kdWxlLFxuICAgICAgICBEcmFnTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgcHJvdmlkZXJzOiBbRGFzaGJvYXJkU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0VuY2Fwc3VsYXRpb24sIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFNQSU5fQlVUVE9OX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU3BpbkJ1dHRvbkNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc3Bpbi1idXR0b24nLFxuICAgIHRlbXBsYXRlOiBgPGJ1dHRvbiBjbGFzcz1cInNwaW4tYnV0dG9uXCJcbiAgICAgICAgKm5nSWY9XCJzcGlubmVyc1wiXG4gICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImluY3JlbWVudEFyaWFMYWJlbFwiXG4gICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAoY2xpY2spPVwidHJpZ2dlckluY3JlbWVudCgpXCI+XG5cbiAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtdXBcIj48L3NwYW4+XG48L2J1dHRvbj5cblxuPGlucHV0IFt0eXBlXT1cInR5cGVcIlxuICAgICAgIHJvbGU9XCJzcGluYnV0dG9uXCJcbiAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgW21heF09XCJtYXhcIlxuICAgICAgIFt0YWJpbmRleF09XCIwXCJcbiAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICBbcmVhZE9ubHldPVwicmVhZE9ubHlcIlxuICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJpbnB1dEFyaWFMYWJlbFwiXG4gICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJtaW5cIlxuICAgICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwidmFsdWVcIlxuICAgICAgIFthdHRyLmFyaWEtdmFsdWVtYXhdPVwibWF4XCJcbiAgICAgICBbYXR0ci5hcmlhLXJlYWRvbmx5XT1cInJlYWRPbmx5XCJcbiAgICAgICBbbmdNb2RlbF09XCJ2YWx1ZVwiXG4gICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwidmFsdWVDaGFuZ2UuZW1pdCgkZXZlbnQpXCJcbiAgICAgICAod2hlZWwpPVwic2Nyb2xsKCRldmVudClcIlxuICAgICAgIChrZXlkb3duLmFycm93dXApPVwiYXJyb3drZXlzID8gdHJpZ2dlckluY3JlbWVudCgpIDogbnVsbDsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgIChrZXlkb3duLmFycm93ZG93bik9XCJhcnJvd2tleXMgPyB0cmlnZ2VyRGVjcmVtZW50KCkgOiBudWxsOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG48YnV0dG9uIGNsYXNzPVwic3Bpbi1idXR0b25cIlxuICAgICAgICAqbmdJZj1cInNwaW5uZXJzXCJcbiAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiZGVjcmVtZW50QXJpYUxhYmVsXCJcbiAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIChjbGljayk9XCJ0cmlnZ2VyRGVjcmVtZW50KClcIj5cblxuICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1kb3duXCI+PC9zcGFuPlxuPC9idXR0b24+YCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1NQSU5fQlVUVE9OX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBTcGluQnV0dG9uQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgQElucHV0KCkgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KCkgdHlwZTogc3RyaW5nID0gJ3RleHQnO1xuICAgIEBJbnB1dCgpIG1pbjogbnVtYmVyO1xuICAgIEBJbnB1dCgpIG1heDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIHBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnJztcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNwaW5uZXJzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSByZWFkT25seTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2Nyb2xsaW5nOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBhcnJvd2tleXM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KCkgaW5jcmVtZW50QXJpYUxhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaW5wdXRBcmlhTGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSBkZWNyZW1lbnRBcmlhTGFiZWw6IHN0cmluZztcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgQE91dHB1dCgpIGluY3JlbWVudCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgZGVjcmVtZW50ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnk7XG5cbiAgICBzY3JvbGwoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVsdGFZID4gMCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRGVjcmVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJJbmNyZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdHJpZ2dlckluY3JlbWVudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmlnZ2VyRGVjcmVtZW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50LmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTcGluQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9zcGluLWJ1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1NwaW5CdXR0b25Db21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NwaW5CdXR0b25Db21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFNwaW5CdXR0b25Nb2R1bGUgeyB9IiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gIG5hbWU6ICd0aW1lRm9ybWF0J1xufSlcbmV4cG9ydCBjbGFzcyBUaW1lRm9ybWF0UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gIHRyYW5zZm9ybSh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gdmFsdWUgPCAxMCA/ICcwJyArIHZhbHVlIDogdmFsdWU7XG4gIH1cblxufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgY29uc3QgVElNRV9QSUNLRVJfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUaW1lUGlja2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10aW1lLXBpY2tlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidGltZS1waWNrZXJcIiBhcmlhLWxhYmVsPVwiVGltZSBwaWNrZXJcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1jb2x1bW5cIiBbY2xhc3MuaGFzLWVycm9yXT1cIiEodmFsaWQkIHwgYXN5bmMpXCIgKm5nSWY9XCJzaG93SG91cnNcIj5cblxuICAgICAgICA8dXgtc3Bpbi1idXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgY2xhc3M9XCJ0aW1lLXNwaW5uZXJcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJISFwiXG4gICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgW21heF09XCJzaG93TWVyaWRpYW4gPyAxMiA6IDIzXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJob3VyJCB8IGFzeW5jIHwgdGltZUZvcm1hdFwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaG91ckNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIFtzcGlubmVyc109XCJzaG93U3Bpbm5lcnNcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkT25seV09XCJyZWFkT25seVwiXG4gICAgICAgICAgICBpbnB1dEFyaWFMYWJlbD1cImhvdXJcIlxuICAgICAgICAgICAgaW5jcmVtZW50QXJpYUxhYmVsPVwiSW5jcmVtZW50IHRoZSBob3VyXCJcbiAgICAgICAgICAgIGRlY3JlbWVudEFyaWFMYWJlbD1cIkRlY3JlbWVudCB0aGUgaG91clwiXG4gICAgICAgICAgICAoaW5jcmVtZW50KT1cImluY3JlbWVudEhvdXIoKVwiXG4gICAgICAgICAgICAoZGVjcmVtZW50KT1cImRlY3JlbWVudEhvdXIoKVwiPlxuICAgICAgICA8L3V4LXNwaW4tYnV0dG9uPlxuXG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidGltZS1waWNrZXItc2VwYXJhdG9yXCIgKm5nSWY9XCJzaG93TWludXRlc1wiPjo8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1jb2x1bW5cIiBbY2xhc3MuaGFzLWVycm9yXT1cIiEodmFsaWQkIHwgYXN5bmMpXCIgKm5nSWY9XCJzaG93TWludXRlc1wiPlxuXG4gICAgICAgIDx1eC1zcGluLWJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICBjbGFzcz1cInRpbWUtc3Bpbm5lclwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIk1NXCJcbiAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICBbbWF4XT1cIjU5XCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJtaW51dGUkIHwgYXN5bmMgfCB0aW1lRm9ybWF0XCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJtaW51dGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbc3Bpbm5lcnNdPVwic2hvd1NwaW5uZXJzXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbcmVhZE9ubHldPVwicmVhZE9ubHlcIlxuICAgICAgICAgICAgaW5wdXRBcmlhTGFiZWw9XCJtaW51dGVcIlxuICAgICAgICAgICAgaW5jcmVtZW50QXJpYUxhYmVsPVwiSW5jcmVtZW50IHRoZSBtaW51dGVcIlxuICAgICAgICAgICAgZGVjcmVtZW50QXJpYUxhYmVsPVwiRGVjcmVtZW50IHRoZSBtaW51dGVcIlxuICAgICAgICAgICAgKGluY3JlbWVudCk9XCJpbmNyZW1lbnRNaW51dGUoKVwiXG4gICAgICAgICAgICAoZGVjcmVtZW50KT1cImRlY3JlbWVudE1pbnV0ZSgpXCI+XG4gICAgICAgIDwvdXgtc3Bpbi1idXR0b24+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1zZXBhcmF0b3JcIiAqbmdJZj1cInNob3dTZWNvbmRzXCI+OjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtcGlja2VyLWNvbHVtblwiIFtjbGFzcy5oYXMtZXJyb3JdPVwiISh2YWxpZCQgfCBhc3luYylcIiAqbmdJZj1cInNob3dTZWNvbmRzXCI+XG5cbiAgICAgICAgPHV4LXNwaW4tYnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgIGNsYXNzPVwidGltZS1zcGlubmVyXCJcbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJTU1wiXG4gICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgW21heF09XCI1OVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwic2Vjb25kJCB8IGFzeW5jIHwgdGltZUZvcm1hdFwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwic2Vjb25kQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW3NwaW5uZXJzXT1cInNob3dTcGlubmVyc1wiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRPbmx5XT1cInJlYWRPbmx5XCJcbiAgICAgICAgICAgIGlucHV0QXJpYUxhYmVsPVwic2Vjb25kc1wiXG4gICAgICAgICAgICBpbmNyZW1lbnRBcmlhTGFiZWw9XCJJbmNyZW1lbnQgdGhlIHNlY29uZFwiXG4gICAgICAgICAgICBkZWNyZW1lbnRBcmlhTGFiZWw9XCJEZWNyZW1lbnQgdGhlIHNlY29uZFwiXG4gICAgICAgICAgICAoaW5jcmVtZW50KT1cImluY3JlbWVudFNlY29uZCgpXCJcbiAgICAgICAgICAgIChkZWNyZW1lbnQpPVwiZGVjcmVtZW50U2Vjb25kKClcIj5cbiAgICAgICAgPC91eC1zcGluLWJ1dHRvbj5cblxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1tZXJpZGlhblwiICpuZ0lmPVwic2hvd01lcmlkaWFuXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCIgcm9sZT1cInJhZGlvZ3JvdXBcIj5cblxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ1dHRvbi10b2dnbGUtYWNjZW50XCJcbiAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgbWVyaWRpYW4gb2YgbWVyaWRpYW5zXCJcbiAgICAgICAgICAgICAgICByb2xlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0TWVyaWRpYW4obWVyaWRpYW4pXCJcbiAgICAgICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cIm1lcmlkaWFuID09PSAobWVyaWRpYW4kIHwgYXN5bmMpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm1lcmlkaWFuXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWNoZWNrZWRdPVwibWVyaWRpYW4gPT09IChtZXJpZGlhbiQgfCBhc3luYylcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICAgICAgICAgICB7eyBtZXJpZGlhbiB9fVxuICAgICAgICA8L2J1dHRvbj5cblxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1RJTUVfUElDS0VSX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdhcmlhLWxhYmVsJzogJ1RpbWUgUGlja2VyJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVGltZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgYXJyb3drZXlzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBtb3VzZXdoZWVsOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHJlYWRPbmx5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBzaG93TWVyaWRpYW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzaG93SG91cnM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNob3dNaW51dGVzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzaG93U2Vjb25kczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNob3dTcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBASW5wdXQoKSBob3VyU3RlcDogbnVtYmVyID0gMTtcbiAgICBASW5wdXQoKSBtaW51dGVTdGVwOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIHNlY29uZFN0ZXA6IG51bWJlciA9IDE7XG5cbiAgICBASW5wdXQoKSBtaW46IERhdGU7XG4gICAgQElucHV0KCkgbWF4OiBEYXRlO1xuICAgIEBJbnB1dCgpIG1lcmlkaWFuczogc3RyaW5nW10gPSBbJ0FNJywgJ1BNJ107XG5cbiAgICBASW5wdXQoKSBzZXQgdmFsdWUodmFsdWU6IERhdGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSQubmV4dChuZXcgRGF0ZSh2YWx1ZSkpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSQudmFsdWUpO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLnZhbHVlJC52YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlJC52YWx1ZSk7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuICAgIEBPdXRwdXQoKSBpc1ZhbGlkID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IERhdGUpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB2YWx1ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuXG4gICAgLy8gY3JlYXRlIG9ic2VydmFibGVzIHRoYXQgYXJlIGRlcml2ZWQgZnJvbSB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgaG91ciQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMudmFsdWUkLnBpcGUobWFwKGRhdGUgPT4gZGF0ZS5nZXRIb3VycygpKSwgbWFwKGhvdXIgPT4gdGhpcy5zaG93TWVyaWRpYW4gPyB0aGlzLmdldE1lcmlkaWFuVGltZShob3VyKSA6IGhvdXIpKTtcbiAgICBtaW51dGUkOiBPYnNlcnZhYmxlPG51bWJlcj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IGRhdGUuZ2V0TWludXRlcygpKSk7XG4gICAgc2Vjb25kJDogT2JzZXJ2YWJsZTxudW1iZXI+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldFNlY29uZHMoKSkpO1xuICAgIG1lcmlkaWFuJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IHRoaXMubWVyaWRpYW5zWzBdIDogdGhpcy5tZXJpZGlhbnNbMV0pKTtcbiAgICB2YWxpZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IHRoaXMuY2hlY2tWYWxpZGl0eShkYXRlKSkpO1xuXG4gICAgcHJpdmF0ZSBfbWVyaWRpYW46IHN0cmluZyA9IHRoaXMubWVyaWRpYW5zWzBdO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMudmFsaWQkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHZhbGlkID0+IHRoaXMuaXNWYWxpZC5lbWl0KHZhbGlkKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IERhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IChfOiBEYXRlKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgZ2V0TWVyaWRpYW5UaW1lKGhvdXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBob3VyID4gMTIgPyBob3VyIC0gMTIgOiBob3VyO1xuICAgIH1cblxuICAgIHNldEhvdXIoaG91cjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBkYXRlLnNldEhvdXJzKGhvdXIgPyBob3VyIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgc2V0TWludXRlKG1pbnV0ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBkYXRlLnNldE1pbnV0ZXMobWludXRlID8gbWludXRlIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgc2V0U2Vjb25kcyhzZWNvbmRzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcyhzZWNvbmRzID8gc2Vjb25kcyA6IDApO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSBkYXRlO1xuICAgIH1cblxuICAgIGluY3JlbWVudEhvdXIoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0SG91cih0aGlzLnZhbHVlLmdldEhvdXJzKCkgKyB0aGlzLmhvdXJTdGVwKTtcbiAgICB9XG5cbiAgICBkZWNyZW1lbnRIb3VyKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEhvdXIodGhpcy52YWx1ZS5nZXRIb3VycygpIC0gdGhpcy5ob3VyU3RlcCk7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50TWludXRlKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE1pbnV0ZSh0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKSArIHRoaXMubWludXRlU3RlcCk7XG4gICAgfVxuXG4gICAgZGVjcmVtZW50TWludXRlKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE1pbnV0ZSh0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKSAtIHRoaXMubWludXRlU3RlcCk7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50U2Vjb25kKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFNlY29uZHModGhpcy52YWx1ZS5nZXRTZWNvbmRzKCkgKyB0aGlzLnNlY29uZFN0ZXApO1xuICAgIH1cblxuICAgIGRlY3JlbWVudFNlY29uZChhcnJvd2tleTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGFycm93a2V5ICYmICF0aGlzLmFycm93a2V5cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTZWNvbmRzKHRoaXMudmFsdWUuZ2V0U2Vjb25kcygpIC0gdGhpcy5zZWNvbmRTdGVwKTtcbiAgICB9XG5cbiAgICBzZWxlY3RNZXJpZGlhbihtZXJpZGlhbjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lcmlkaWFuID0gbWVyaWRpYW47XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgY29uc3QgaG91ciA9IHRoaXMudmFsdWUuZ2V0SG91cnMoKTtcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHNlbGVjdGVkIEFNXG4gICAgICAgIGlmIChtZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIb3VyKGhvdXIgLSAxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHNlbGVjdGVkIFBNXG4gICAgICAgIGlmIChtZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMV0pIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhvdXIoaG91ciArIDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrVmFsaWRpdHkoZGF0ZTogRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1pbiAmJiBkYXRlLmdldFRpbWUoKSA8PSB0aGlzLm1pbi5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXggJiYgZGF0ZS5nZXRUaW1lKCkgPj0gdGhpcy5tYXguZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cblxuICAgIGhvdXJDaGFuZ2UodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlclxuICAgICAgICBsZXQgaG91ciA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRIb3VyID0gdGhpcy52YWx1ZS5nZXRIb3VycygpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoaG91ciA9PT0gY3VycmVudEhvdXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgaG91cnMgaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc05hTihob3VyKSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob3VyID4gKHRoaXMuc2hvd01lcmlkaWFuID8gMTIgOiAyMykpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gdGhpcy5zaG93TWVyaWRpYW4gPyAxMiA6IDIzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaG91ciA9IGlzTmFOKGhvdXIpID8gY3VycmVudEhvdXIgOiBob3VyO1xuXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgaW52YWxpZCB0aGVuIHJlc3RvcmUgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLl9tZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciAtPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc2VsZWN0ZWQgUE1cbiAgICAgICAgaWYgKHRoaXMuX21lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1sxXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEhvdXIoaG91cik7XG4gICAgfVxuXG4gICAgbWludXRlQ2hhbmdlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXJcbiAgICAgICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRNaW51dGUgPSB0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKG1pbnV0ZSA9PT0gY3VycmVudE1pbnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBob3VycyBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzTmFOKG1pbnV0ZSkpIHtcbiAgICAgICAgICAgIGlmIChtaW51dGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWludXRlID0gNTk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW51dGUgPiA1OSkge1xuICAgICAgICAgICAgICAgIG1pbnV0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQgdGhlbiByZXN0b3JlIGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICB0aGlzLnNldE1pbnV0ZShpc05hTihtaW51dGUpID8gY3VycmVudE1pbnV0ZSA6IG1pbnV0ZSk7XG4gICAgfVxuXG4gICAgc2Vjb25kQ2hhbmdlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyXG4gICAgICAgIGxldCBzZWNvbmQgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgIGxldCBjdXJyZW50U2Vjb25kID0gdGhpcy52YWx1ZS5nZXRTZWNvbmRzKCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChzZWNvbmQgPT09IGN1cnJlbnRTZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgaG91cnMgaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc05hTihzZWNvbmQpKSB7XG4gICAgICAgICAgICBpZiAoc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgIHNlY29uZCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWNvbmQgPiA1OSkge1xuICAgICAgICAgICAgICAgIHNlY29uZCA9IDU5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIG51bWJlciBpcyBpbnZhbGlkIHRoZW4gcmVzdG9yZSBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRTZWNvbmRzKGlzTmFOKHNlY29uZCkgPyBjdXJyZW50U2Vjb25kIDogc2Vjb25kKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFNwaW5CdXR0b25Nb2R1bGUgfSBmcm9tICcuLi9zcGluLWJ1dHRvbi9pbmRleCc7XG5pbXBvcnQgeyBUaW1lRm9ybWF0UGlwZSB9IGZyb20gJy4vdGltZS1mb3JtYXQucGlwZSc7XG5pbXBvcnQgeyBUaW1lUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi90aW1lLXBpY2tlci5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgU3BpbkJ1dHRvbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1RpbWVQaWNrZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1RpbWVQaWNrZXJDb21wb25lbnQsIFRpbWVGb3JtYXRQaXBlXSxcbn0pXG5leHBvcnQgY2xhc3MgVGltZVBpY2tlck1vZHVsZSB7IH0iLCJpbXBvcnQgeyBEYXRlVGltZVBpY2tlclRpbWV6b25lIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSBkaW1lbnNpb24gYXJyYXkgdG8gYSBkb3VibGUgZGltZW5zaW9uIGFycmF5XG4gKiBAcGFyYW0gaXRlbXMgdGhlIHNpbmdsZSBkaW1lbnNpb24gYXJyYXkgdG8gY29udmVydFxuICogQHBhcmFtIGNvbHVtbnMgdGhlIG51bWJlciBvZiBpdGVtcyBlYWNoIGFycmF5IHNob3VsZCBoYXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmlkaWZ5PFQ+KGl0ZW1zOiBUW10sIGNvbHVtbnM6IG51bWJlcik6IFRbXVtdIHtcblxuICAgIC8vIGNyZWF0ZSBhIGNvcHkgb2YgYXJyYXkgc28gbm90IHRvIGVmZmVjdCB0aGUgb3JpZ2luYWxcbiAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDApO1xuXG4gICAgY29uc3QgZ3JpZDogVFtdW10gPSBbXTtcblxuICAgIHdoaWxlIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgZ3JpZC5wdXNoKGl0ZW1zLnNwbGljZSgwLCBjb2x1bW5zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyaWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIG51bWJlcnMgYmV0d2VlbiB0d28gbGltaXRzXG4gKiBAcGFyYW0gc3RhcnQgdGhlIGxvd2VyIGxpbWl0XG4gKiBAcGFyYW0gZW5kIHRoZSB1cHBlciBsaW1pdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbGlzdDogbnVtYmVyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGlkeCA9IHN0YXJ0OyBpZHggPD0gZW5kOyBpZHgrKykge1xuICAgICAgICBsaXN0LnB1c2goaWR4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgZGF0ZXMgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0gc3RhcnQgdGhlIGRhdGUgdG8gc3RhcnQgdGhlIGFycmF5XG4gKiBAcGFyYW0gZW5kIHRoZSBkYXRlIHRvIGVuZCB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVSYW5nZShzdGFydDogRGF0ZSwgZW5kOiBEYXRlKTogRGF0ZVtdIHtcblxuICAgIGxldCBkYXRlczogRGF0ZVtdID0gW107XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIHRoZSBkYXlzIGJldHdlZW4gdGhlIGRhdGUgcmFuZ2VcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBkYXRlIHRvIHRoZSBhcnJheVxuICAgICAgICBkYXRlcy5wdXNoKG5ldyBEYXRlKHN0YXJ0KSk7XG5cbiAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCBkYXlcbiAgICAgICAgc3RhcnQuc2V0RGF0ZShzdGFydC5nZXREYXRlKCkgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZXM7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gZGF0ZXMgdG8gc2VlIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIGRheVxuICogQHBhcmFtIGRheTEgdGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIGRheTIgdGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVEYXlzKGRheTE6IERhdGUsIGRheTI6IERhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZGF5MS5nZXREYXRlKCkgPT09IGRheTIuZ2V0RGF0ZSgpICYmXG4gICAgICAgIGRheTEuZ2V0TW9udGgoKSA9PT0gZGF5Mi5nZXRNb250aCgpICYmXG4gICAgICAgIGRheTEuZ2V0RnVsbFllYXIoKSA9PT0gZGF5Mi5nZXRGdWxsWWVhcigpO1xufVxuXG4vKipcbiAqIERhdGUgY29tcGFyaXNvbiBmb3IgdXNlIHByaW1hcmlseSB3aXRoIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlQ29tcGFyYXRvcihkYXRlT25lOiBEYXRlLCBkYXRlVHdvOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRhdGVPbmUuZ2V0VGltZSgpID09PSBkYXRlVHdvLmdldFRpbWUoKTtcbn1cblxuLyoqXG4gKiBUaW1lem9uZSBjb21wYXJpc29uIGZvciB1c2UgcHJpbWFyaWx5IHdpdGggZGlzdGluY3RVbnRpbENoYW5nZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWV6b25lQ29tcGFyYXRvcih6b25lT25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lLCB6b25lVHdvOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHpvbmVPbmUubmFtZSA9PT0gem9uZVR3by5uYW1lICYmIHpvbmVPbmUub2Zmc2V0ID09PSB6b25lVHdvLm9mZnNldDtcbn1cblxuLyoqXG4gKiBFeHBvcnQgYW4gYXJyYXkgb2YgYWxsIHRoZSBhdmFpbGFibGUgbW9udGhzXG4gKi9cbmV4cG9ydCBjb25zdCBtb250aHMgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IG1vbnRocy5tYXAobW9udGggPT4gbW9udGguc3Vic3RyaW5nKDAsIDMpKTtcblxuLyoqXG4gKiBFeHBvcnQgYW4gYXJyYXkgb2YgYWxsIHRoZSBhdmFpbGFibGUgZGF5cyBvZiB0aGUgd2Vla1xuICovXG5leHBvcnQgY29uc3Qgd2Vla2RheXMgPSBbJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknLCAnU3VuZGF5J107XG5leHBvcnQgY29uc3Qgd2Vla2RheXNTaG9ydCA9IHdlZWtkYXlzLm1hcCh3ZWVrZGF5ID0+IHdlZWtkYXkuc3Vic3RyaW5nKDAsIDMpKTsiLCIvKipcbiAqIEFkZCBhIGNvbmZpZyBzZXJ2aWNlIHRvIGFsbG93IGFuIGFwcGxpY2F0aW9uXG4gKiB0byBjdXN0b21pemUgdGhlIGRhdGUgdGltZSBwaWNrZXIgZGVmYXVsdCBzZXR0aW5nc1xuICogYWNyb3NzIHRoZSBlbnRpcmUgYXBwbGljYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB3ZWVrZGF5c1Nob3J0IH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyVGltZXpvbmUgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlckNvbmZpZyB7XG5cbiAgICBzaG93RGF0ZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1RpbWU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dUaW1lem9uZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1NlY29uZHM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG93TWVyaWRpYW46IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dTcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG4gICAgd2Vla2RheXM6IHN0cmluZ1tdID0gd2Vla2RheXNTaG9ydDtcbiAgICBub3dCdG5UZXh0OiBzdHJpbmcgPSAnVG9kYXknO1xuXG4gICAgdGltZXpvbmVzOiBEYXRlVGltZVBpY2tlclRpbWV6b25lW10gPSBbXG4gICAgICAgIHsgbmFtZTogJ0dNVC0xMScsIG9mZnNldDogNjYwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC0xMCcsIG9mZnNldDogNjAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC05Jywgb2Zmc2V0OiA1NDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTgnLCBvZmZzZXQ6IDQ4MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtNycsIG9mZnNldDogNDIwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC02Jywgb2Zmc2V0OiAzNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTUnLCBvZmZzZXQ6IDMwMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtNCcsIG9mZnNldDogMjQwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC0zJywgb2Zmc2V0OiAxODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTInLCBvZmZzZXQ6IDEyMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtMScsIG9mZnNldDogNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UJywgb2Zmc2V0OiAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVCsxJywgb2Zmc2V0OiAtNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzInLCBvZmZzZXQ6IC0xMjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzMnLCBvZmZzZXQ6IC0xODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzQnLCBvZmZzZXQ6IC0yNDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzUnLCBvZmZzZXQ6IC0zMDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzYnLCBvZmZzZXQ6IC0zNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzcnLCBvZmZzZXQ6IC00MjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzgnLCBvZmZzZXQ6IC00ODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzknLCBvZmZzZXQ6IC01NDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzEwJywgb2Zmc2V0OiAtNjAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVCsxMScsIG9mZnNldDogLTY2MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrMTInLCBvZmZzZXQ6IC03MjAgfVxuICAgIF07XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyQ29uZmlnIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLmNvbmZpZyc7XG5pbXBvcnQgeyBkYXRlQ29tcGFyYXRvciB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlclNlcnZpY2Uge1xuXG4gICAgbW9kZSQ6IEJlaGF2aW9yU3ViamVjdDxEYXRlUGlja2VyTW9kZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGVQaWNrZXJNb2RlPihEYXRlUGlja2VyTW9kZS5EYXkpO1xuICAgIGRhdGUkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuICAgIHRpbWV6b25lJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4odGhpcy5nZXRDdXJyZW50VGltZXpvbmUoKSk7XG4gICAgc2VsZWN0ZWQkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuXG4gICAgLy8gdGhlIG1vbnRoIGFuZCB5ZWFyIHRvIGRpc3BsYXkgaW4gdGhlIHZpZXdwb3J0XG4gICAgbW9udGgkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldE1vbnRoKCkpO1xuICAgIHllYXIkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpO1xuXG4gICAgc2hvd0RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd0RhdGUpO1xuICAgIHNob3dUaW1lJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dUaW1lKTtcbiAgICBzaG93VGltZXpvbmUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd1RpbWV6b25lKTtcbiAgICBzaG93U2Vjb25kcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZy5zaG93U2Vjb25kcyk7XG4gICAgc2hvd01lcmlkaWFuJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dNZXJpZGlhbik7XG4gICAgc2hvd1NwaW5uZXJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dTcGlubmVycyk7XG4gICAgd2Vla2RheXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmdbXT4odGhpcy5fY29uZmlnLndlZWtkYXlzKTtcbiAgICBub3dCdG5UZXh0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPih0aGlzLl9jb25maWcubm93QnRuVGV4dCk7XG4gICAgdGltZXpvbmVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdPih0aGlzLl9jb25maWcudGltZXpvbmVzKTtcblxuICAgIGhlYWRlciQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4obnVsbCk7XG4gICAgaGVhZGVyRXZlbnQkID0gbmV3IFN1YmplY3Q8RGF0ZVBpY2tlckhlYWRlckV2ZW50PigpO1xuICAgIG1vZGVEaXJlY3Rpb246IE1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLk5vbmU7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbmZpZzogRGF0ZVRpbWVQaWNrZXJDb25maWcpIHtcblxuICAgICAgICAvLyB3aGVuIHRoZSBhY3RpdmUgZGF0ZSBjaGFuZ2VzIHNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGVcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5zZWxlY3RlZCQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZChkYXRlQ29tcGFyYXRvcikpLnN1YnNjcmliZShkYXRlID0+IHtcblxuICAgICAgICAgICAgLy8gdGhlIG1vbnRoIGFuZCB5ZWFyIGRpc3BsYXllZCBpbiB0aGUgdmlld3BvcnQgc2hvdWxkIHJlZmxlY3QgdGhlIG5ld2x5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0TW9udGgoZGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnRZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIG5ldyBkYXRlIHRvIHRoZSBjb21wb25lbnQgaG9zdFxuICAgICAgICAgICAgdGhpcy5kYXRlJC5uZXh0KGRhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRNb250aChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChtb250aCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQoMTEpO1xuICAgICAgICAgICAgdGhpcy55ZWFyJC5uZXh0KHRoaXMueWVhciQudmFsdWUgLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb250aCA+IDExKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoJC5uZXh0KDApO1xuICAgICAgICAgICAgdGhpcy55ZWFyJC5uZXh0KHRoaXMueWVhciQudmFsdWUgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQobW9udGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRZZWFyKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnllYXIkLm5leHQoeWVhcik7XG4gICAgfVxuXG4gICAgc2V0RGF0ZShkYXk6IG51bWJlciwgbW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnNlbGVjdGVkJC52YWx1ZSk7XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKGRheSk7XG4gICAgICAgIGRhdGUuc2V0TW9udGgobW9udGgpO1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQoZGF0ZSk7XG4gICAgfVxuXG4gICAgc2V0RGF0ZVRvTm93KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KG5ldyBEYXRlKCkpO1xuICAgIH1cblxuICAgIHNldFZpZXdwb3J0TW9kZShtb2RlOiBEYXRlUGlja2VyTW9kZSk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGUkLm5leHQobW9kZSk7XG4gICAgfVxuXG4gICAgZ29Ub0NoaWxkTW9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb2RlRGlyZWN0aW9uID0gTW9kZURpcmVjdGlvbi5EZXNjZW5kO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlJC52YWx1ZSkge1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRNb2RlKERhdGVQaWNrZXJNb2RlLk1vbnRoKTtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuRGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9QYXJlbnRNb2RlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLkFzY2VuZDtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSQudmFsdWUpIHtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRNb2RlKERhdGVQaWNrZXJNb2RlLk1vbnRoKTtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuWWVhcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvTmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oZWFkZXJFdmVudCQubmV4dChEYXRlUGlja2VySGVhZGVyRXZlbnQuTmV4dCk7XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZpb3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYWRlckV2ZW50JC5uZXh0KERhdGVQaWNrZXJIZWFkZXJFdmVudC5QcmV2aW91cyk7XG4gICAgfVxuXG4gICAgc2V0SGVhZGVyKGhlYWRlcjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGVhZGVyJC5uZXh0KGhlYWRlcik7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFRpbWV6b25lKCk6IERhdGVUaW1lUGlja2VyVGltZXpvbmUge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcudGltZXpvbmVzLmZpbmQodGltZXpvbmUgPT4gdGltZXpvbmUub2Zmc2V0ID09PSBvZmZzZXQpO1xuICAgIH1cblxuICAgIHNldFRpbWV6b25lKHRpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKTogdm9pZCB7XG4gICAgICAgIHRoaXMudGltZXpvbmUkLm5leHQodGltZXpvbmUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gRGF0ZVBpY2tlck1vZGUge1xuICAgIERheSxcbiAgICBNb250aCxcbiAgICBZZWFyXG59XG5cbmV4cG9ydCBlbnVtIE1vZGVEaXJlY3Rpb24ge1xuICAgIE5vbmUsXG4gICAgQXNjZW5kLFxuICAgIERlc2NlbmRcbn1cblxuZXhwb3J0IGVudW0gRGF0ZVBpY2tlckhlYWRlckV2ZW50IHtcbiAgICBQcmV2aW91cyxcbiAgICBOZXh0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG9mZnNldDogbnVtYmVyO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERhdGVQaWNrZXJNb2RlLCBEYXRlVGltZVBpY2tlclNlcnZpY2UsIERhdGVUaW1lUGlja2VyVGltZXpvbmUgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBkYXRlQ29tcGFyYXRvciwgdGltZXpvbmVDb21wYXJhdG9yIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlcicsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImNhbGVuZGFyLWNvbnRhaW5lclwiPlxuXG4gIDx1eC1kYXRlLXRpbWUtcGlja2VyLWhlYWRlcj48L3V4LWRhdGUtdGltZS1waWNrZXItaGVhZGVyPlxuXG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dEYXRlJCB8IGFzeW5jXCIgW25nU3dpdGNoXT1cImRhdGVwaWNrZXIubW9kZSQgfCBhc3luY1wiPlxuXG4gICAgICA8IS0tIERpc3BsYXkgZGF5cyBpbiB0aGUgY3VycmVudCBtb250aCAtLT5cbiAgICAgIDx1eC1kYXRlLXRpbWUtcGlja2VyLWRheS12aWV3ICpuZ1N3aXRjaENhc2U9XCJEYXRlUGlja2VyTW9kZS5EYXlcIj48L3V4LWRhdGUtdGltZS1waWNrZXItZGF5LXZpZXc+XG5cbiAgICAgIDwhLS0gRGlzcGxheSB0aGUgbW9udGhzIGluIHRoZSBjdXJyZW50IHllYXIgLS0+XG4gICAgICA8dXgtZGF0ZS10aW1lLXBpY2tlci1tb250aC12aWV3ICpuZ1N3aXRjaENhc2U9XCJEYXRlUGlja2VyTW9kZS5Nb250aFwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlci1tb250aC12aWV3PlxuXG4gICAgICA8IS0tIERpc3BsYXkgYSBkZWNhZGUgLS0+XG4gICAgICA8dXgtZGF0ZS10aW1lLXBpY2tlci15ZWFyLXZpZXcgKm5nU3dpdGNoQ2FzZT1cIkRhdGVQaWNrZXJNb2RlLlllYXJcIj48L3V4LWRhdGUtdGltZS1waWNrZXIteWVhci12aWV3PlxuXG4gIDwvbmctY29udGFpbmVyPlxuXG4gIDwhLS0gRGlzcGxheSBhIFRpbWUgUGlja2VyIC0tPlxuICA8dXgtZGF0ZS10aW1lLXBpY2tlci10aW1lLXZpZXcgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dUaW1lJCB8IGFzeW5jXCI+PC91eC1kYXRlLXRpbWUtcGlja2VyLXRpbWUtdmlldz5cblxuPC9kaXY+XG5cbjxidXR0b24gY2xhc3M9XCJub3ctYnV0dG9uXCIgYXJpYS1sYWJlbD1cIlNldCBkYXRlIHRvIG5vd1wiIChjbGljayk9XCJzZXRUb05vdygpXCI+e3sgZGF0ZXBpY2tlci5ub3dCdG5UZXh0JCB8IGFzeW5jIH19PC9idXR0b24+YCxcbiAgcHJvdmlkZXJzOiBbRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgX3RpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lO1xuXG4gIEBJbnB1dCgpIHNldCBzaG93RGF0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93RGF0ZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2hvd1RpbWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1RpbWUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dUaW1lem9uZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93VGltZXpvbmUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dTZWNvbmRzKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnNob3dTZWNvbmRzJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93TWVyaWRpYW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd01lcmlkaWFuJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93U3Bpbm5lcnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1NwaW5uZXJzJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCB3ZWVrZGF5cyh2YWx1ZTogc3RyaW5nW10pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIud2Vla2RheXMkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IG5vd0J0blRleHQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5ub3dCdG5UZXh0JC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCB0aW1lem9uZXModmFsdWU6IERhdGVUaW1lUGlja2VyVGltZXpvbmVbXSkge1xuICAgIHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLm5leHQodmFsdWUpO1xuICB9XG5cblxuICBAT3V0cHV0KCkgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuICBAT3V0cHV0KCkgdGltZXpvbmVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRlVGltZVBpY2tlclRpbWV6b25lPiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4oKTtcblxuICBASW5wdXQoKVxuICBzZXQgZGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGlmICghZGF0ZUNvbXBhcmF0b3IodmFsdWUsIHRoaXMuZGF0ZXBpY2tlci5zZWxlY3RlZCQudmFsdWUpKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXIuc2VsZWN0ZWQkLm5leHQobmV3IERhdGUodmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgdGltZXpvbmUodmFsdWU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgLy8gZXhwb3NlIGVudW0gdG8gdmlld1xuICBEYXRlUGlja2VyTW9kZSA9IERhdGVQaWNrZXJNb2RlO1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgY29uc3QgdmFsdWVDaGFuZ2UgPSBkYXRlcGlja2VyLnNlbGVjdGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKGRhdGVDb21wYXJhdG9yKSlcbiAgICAgIC5zdWJzY3JpYmUoZGF0ZSA9PiB0aGlzLmRhdGVDaGFuZ2UuZW1pdChkYXRlKSk7XG5cbiAgICBjb25zdCB0aW1lem9uZUNoYW5nZSA9IGRhdGVwaWNrZXIudGltZXpvbmUkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQodGltZXpvbmVDb21wYXJhdG9yKSlcbiAgICAgIC5zdWJzY3JpYmUoKHRpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKSA9PiB0aGlzLnRpbWV6b25lQ2hhbmdlLmVtaXQodGltZXpvbmUpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZGF0ZSB0byB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lXG4gICAqL1xuICBzZXRUb05vdygpOiB2b2lkIHtcblxuICAgIC8vIHNldCB0aGUgZGF0ZSB0byB0aGUgY3VycmVudCBtb21lbnRcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2V0RGF0ZVRvTm93KCk7XG4gIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UsIE1vZGVEaXJlY3Rpb24gfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgY29tcGFyZURheXMsIGRhdGVSYW5nZSwgZ3JpZGlmeSwgbW9udGhzIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXlWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF5Vmlld0l0ZW1bXVtdPihbW11dKTtcbiAgICBmb2N1c2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Rm9jdXNlZERheUl0ZW0+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gY29tYmluZUxhdGVzdChfZGF0ZXBpY2tlci5tb250aCQsIF9kYXRlcGlja2VyLnllYXIkKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoW21vbnRoLCB5ZWFyXSkgPT4gdGhpcy5jcmVhdGVEYXlHcmlkKG1vbnRoLCB5ZWFyKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEZvY3VzKGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkJC5uZXh0KHsgZGF5OiBkYXksIG1vbnRoOiBtb250aCwgeWVhcjogeWVhciB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGRhdGUgcGlja2VyIHRvIHNob3cgdGhlIHJlcXVpcmVkIG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHllYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlRGF5R3JpZChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlclxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldEhlYWRlcihtb250aHNbbW9udGhdICsgJyAnICsgeWVhcik7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kYXJpZXNcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgMCk7XG5cbiAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gc2hvdyBmcm9tIHRoZSBzdW5kYXkgLSB0aGlzIG1heSBpbmNsdWRlIHNob3dpbmcgc29tZSBkYXRlcyBmcm9tIHRoZSBwcmV2aW91cyBtb250aFxuICAgICAgICBzdGFydC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSAtIHN0YXJ0LmdldERheSgpKTtcblxuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHJhbmdlIGVuZHMgb24gYSBzYXR1cmRheVxuICAgICAgICBlbmQuc2V0RGF0ZShlbmQuZ2V0RGF0ZSgpICsgKDYgLSBlbmQuZ2V0RGF5KCkpKTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgb2YgYWxsIHRoZSBkYXlzIHRvIGRpc3BsYXlcbiAgICAgICAgY29uc3QgZGF0ZXM6IERheVZpZXdJdGVtW10gPSBkYXRlUmFuZ2Uoc3RhcnQsIGVuZCkubWFwKGRhdGUgPT4gKHtcbiAgICAgICAgICAgIGRheTogZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIGlzVG9kYXk6IHRoaXMuaXNUb2RheShkYXRlKSxcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQWN0aXZlKGRhdGUpLFxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IGRhdGUuZ2V0TW9udGgoKSA9PT0gbW9udGhcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHR1cm4gdGhlIGRhdGVzIGludG8gYSBncmlkXG4gICAgICAgIGNvbnN0IGl0ZW1zOiBEYXlWaWV3SXRlbVtdW10gPSBncmlkaWZ5KGRhdGVzLCA3KTtcblxuICAgICAgICB0aGlzLmdyaWQkLm5leHQoaXRlbXMpO1xuXG4gICAgICAgIC8vIGlmIG5vIGl0ZW0gaGFzIHlldCBiZWVuIGZvY3VzZWQgdGhlbiBmb2N1cyB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICBpZiAoKHRoaXMuX2RhdGVwaWNrZXIubW9kZURpcmVjdGlvbiA9PT0gTW9kZURpcmVjdGlvbi5Ob25lIHx8IHRoaXMuX2RhdGVwaWNrZXIubW9kZURpcmVjdGlvbiA9PT0gTW9kZURpcmVjdGlvbi5EZXNjZW5kKSAmJiB0aGlzLmZvY3VzZWQkLnZhbHVlID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWxlY3RlZCBpdGVtIGlzIHZpc2libGVcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRGF5ID0gZGF0ZXMuZmluZChkYXkgPT4gZGF5LmlzQ3VycmVudE1vbnRoICYmIGRheS5pc0FjdGl2ZSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZERheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoc2VsZWN0ZWREYXkuZGF5LCBzZWxlY3RlZERheS5tb250aCwgc2VsZWN0ZWREYXkueWVhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0ZXMuZmluZChkYXRlID0+IGRhdGUuZGF5ID09PSAxKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBmb2N1cyB0aGUgZGF0ZVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoZmlyc3QuZGF5LCBmaXJzdC5tb250aCwgZmlyc3QueWVhcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBkYXRlIGlzIHRvZGF5XG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGNoZWNrXG4gICAqL1xuICAgIHByaXZhdGUgaXNUb2RheShkYXRlOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBjb21wYXJlRGF5cyhuZXcgRGF0ZSgpLCBkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgc3BlY2lmaWMgZGF0ZSBpcyB0aGUgc2VsZWN0ZWQgb25lXG4gICAgICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY2hlY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzQWN0aXZlKGRhdGU6IERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVEYXlzKHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLCBkYXRlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5Vmlld0l0ZW0ge1xuICAgIGRheTogbnVtYmVyO1xuICAgIG1vbnRoOiBudW1iZXI7XG4gICAgeWVhcjogbnVtYmVyO1xuICAgIGRhdGU6IERhdGU7XG4gICAgaXNUb2RheTogYm9vbGVhbjtcbiAgICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgICBpc0N1cnJlbnRNb250aDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb2N1c2VkRGF5SXRlbSB7XG4gICAgZGF5OiBudW1iZXI7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBEYXRlUGlja2VySGVhZGVyRXZlbnQsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBEYXlWaWV3SXRlbSwgRGF5Vmlld1NlcnZpY2UgfSBmcm9tICcuL2RheS12aWV3LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLWRheS12aWV3JyxcbiAgdGVtcGxhdGU6IGA8dGFibGUgY2xhc3M9XCJjYWxlbmRhclwiPlxuICAgIDx0aGVhZD5cbiAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRoICpuZ0Zvcj1cImxldCBkYXkgb2YgZGF0ZVBpY2tlci53ZWVrZGF5cyQgfCBhc3luY1wiIGNsYXNzPVwid2Vla2RheVwiIFthdHRyLmFyaWEtbGFiZWxdPVwiZGF5XCI+e3sgZGF5IH19PC90aD5cbiAgICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuXG4gICAgPHRib2R5IHJvbGU9XCJncmlkXCI+XG4gICAgICAgIDx0ciByb2xlPVwicm93XCIgKm5nRm9yPVwibGV0IHJvdyBvZiBkYXlTZXJ2aWNlLmdyaWQkIHwgYXN5bmM7IHRyYWNrQnk6IHRyYWNrV2Vla0J5Rm5cIj5cblxuICAgICAgICAgICAgPHRkICpuZ0Zvcj1cImxldCBpdGVtIG9mIHJvdzsgdHJhY2tCeTogdHJhY2tEYXlCeUZuXCIgY2xhc3M9XCJkYXRlLWNlbGxcIiByb2xlPVwiZ3JpZGNlbGxcIj5cblxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkYXRlLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZm9jdXNJZl09XCIoZGF5U2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8uZGF5ID09PSBpdGVtLmRheSAmJiAoZGF5U2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8ubW9udGggPT09IGl0ZW0ubW9udGggJiYgKGRheVNlcnZpY2UuZm9jdXNlZCQgfCBhc3luYyk/LnllYXIgPT09IGl0ZW0ueWVhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIml0ZW0uZGF0ZSB8IGRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLmlzQWN0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtaGlkZGVuXT1cIiFpdGVtLmlzQ3VycmVudE1vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5jdXJyZW50XT1cIml0ZW0uaXNUb2RheVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cIml0ZW0uaXNBY3RpdmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnByZXZpZXddPVwiIWl0ZW0uaXNDdXJyZW50TW9udGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3RhYmluZGV4XT1cImdldFRhYmJhYmxlKGl0ZW0pID8gMCA6IC0xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3QoaXRlbS5kYXRlKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXlkb3duLkFycm93TGVmdCk9XCJmb2N1c0RhdGUoaXRlbSwgLTEpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5BcnJvd1JpZ2h0KT1cImZvY3VzRGF0ZShpdGVtLCAxKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGtleWRvd24uQXJyb3dVcCk9XCJmb2N1c0RhdGUoaXRlbSwgLTcpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5BcnJvd0Rvd24pPVwiZm9jdXNEYXRlKGl0ZW0sIDcpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG4gICAgICAgICAgICAgICAgICAgIHt7IGl0ZW0uZGF0ZS5nZXREYXRlKCkgfX1cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC90cj5cbiAgICA8L3Rib2R5PlxuPC90YWJsZT5gLFxuICBwcm92aWRlcnM6IFtEYXlWaWV3U2VydmljZV0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIERheVZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRlUGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UsIHB1YmxpYyBkYXlTZXJ2aWNlOiBEYXlWaWV3U2VydmljZSkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IGRhdGVQaWNrZXIuaGVhZGVyRXZlbnQkXG4gICAgICAuc3Vic2NyaWJlKGV2ZW50ID0+IGV2ZW50ID09PSBEYXRlUGlja2VySGVhZGVyRXZlbnQuTmV4dCA/IHRoaXMubmV4dCgpIDogdGhpcy5wcmV2aW91cygpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBwYWdlIG9mIGRhdGVzXG4gICAqL1xuICBwcmV2aW91cygpOiB2b2lkIHtcbiAgICB0aGlzLmRhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aCh0aGlzLmRhdGVQaWNrZXIubW9udGgkLnZhbHVlIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIG5leHQgcGFnZSBvZiBkYXRlc1xuICAgKi9cbiAgbmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLmRhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aCh0aGlzLmRhdGVQaWNrZXIubW9udGgkLnZhbHVlICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgcGFydGljdWxhciBkYXRlXG4gICAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIHNlbGVjdFxuICAgKi9cbiAgc2VsZWN0KGRhdGU6IERhdGUpOiB2b2lkIHtcbiAgICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZGF0ZSBvYmplY3RcbiAgICB0aGlzLmRhdGVQaWNrZXIuc2V0RGF0ZShkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldEZ1bGxZZWFyKCkpO1xuXG4gICAgLy8gZm9jdXMgdGhlIG5ld2x5IHNlbGVjdGVkIGRhdGVcbiAgICB0aGlzLmRheVNlcnZpY2Uuc2V0Rm9jdXMoZGF0ZS5nZXREYXRlKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgfVxuXG4gIHRyYWNrV2Vla0J5Rm4oaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgdHJhY2tEYXlCeUZuKGluZGV4OiBudW1iZXIsIGl0ZW06IERheVZpZXdJdGVtKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7IGl0ZW0uZGF5IH0gJHsgaXRlbS5tb250aCB9ICR7IGl0ZW0ueWVhciB9YDtcbiAgfVxuXG4gIGZvY3VzRGF0ZShpdGVtOiBEYXlWaWV3SXRlbSwgZGF5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSB0aGUgZGF0ZSBvZiB0aGUgZGF5XG4gICAgY29uc3QgdGFyZ2V0ID0gbmV3IERhdGUoaXRlbS5kYXRlLnNldERhdGUoaXRlbS5kYXRlLmdldERhdGUoKSArIGRheU9mZnNldCkpO1xuXG4gICAgLy8gaWRlbnRpZnkgd2hpY2ggZGF0ZSBzaG91bGQgYmUgZm9jdXNlZFxuICAgIHRoaXMuZGF5U2VydmljZS5zZXRGb2N1cyh0YXJnZXQuZ2V0RGF0ZSgpLCB0YXJnZXQuZ2V0TW9udGgoKSwgdGFyZ2V0LmdldEZ1bGxZZWFyKCkpO1xuICB9XG5cbiAgZ2V0VGFiYmFibGUoaXRlbTogRGF5Vmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5kYXlTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLmRheVNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIGZvY3VzZWQgbW9udGggY2hlY2sgaWYgdGhpcyBpcyBpdFxuICAgIGlmIChmb2N1c2VkKSB7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBmb2N1c2VkIGRheSBpcyB2aXNpYmxlXG4gICAgICBjb25zdCBpc0ZvY3VzZWREYXlWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0uZGF5ID09PSBmb2N1c2VkLmRheSAmJiBfaXRlbS5tb250aCA9PT0gZm9jdXNlZC5tb250aCAmJiBfaXRlbS55ZWFyID09PSBmb2N1c2VkLnllYXIpKTtcblxuICAgICAgaWYgKGlzRm9jdXNlZERheVZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZvY3VzZWQuZGF5ID09PSBpdGVtLmRheSAmJiBmb2N1c2VkLm1vbnRoID09PSBpdGVtLm1vbnRoICYmIGZvY3VzZWQueWVhciA9PT0gaXRlbS55ZWFyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSBkYXkgdGhlbiBjaGVjayBpZiB0aGVyZSBpcyBhIHNlbGVjdGVkIGRheVxuICAgIGNvbnN0IGlzU2VsZWN0ZWREYXlWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoZGF5ID0+IGRheS5pc0FjdGl2ZSkpO1xuXG4gICAgaWYgKGlzU2VsZWN0ZWREYXlWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlzQWN0aXZlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBkYXkgdGFiYmFibGVcbiAgICByZXR1cm4gaXRlbS5kYXkgPT09IDE7XG4gIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGF0ZVBpY2tlck1vZGUsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiBgPGhlYWRlciBjbGFzcz1cImhlYWRlclwiPlxuXG4gIDxidXR0b24gY2xhc3M9XCJoZWFkZXItbmF2aWdhdGlvblwiXG4gICAgICAgICAgKGNsaWNrKT1cInByZXZpb3VzKCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJwcmV2aW91c0FyaWEkIHwgYXN5bmNcIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiPlxuXG4gICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtcHJldmlvdXNcIj48L2k+XG4gIDwvYnV0dG9uPlxuXG4gIDxidXR0b24gY2xhc3M9XCJoZWFkZXItdGl0bGVcIlxuICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaGVhZGVyQXJpYSQgfCBhc3luY1wiXG4gICAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJjYW5Bc2NlbmQkIHwgYXN5bmNcIlxuICAgICAgICAgIChjbGljayk9XCJhc2NlbmQoKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICBbdGFiaW5kZXhdPVwiKGNhbkFzY2VuZCQgfCBhc3luYykgPyAwIDogLTFcIj5cbiAgICAgICB7eyBkYXRlcGlja2VyLmhlYWRlciQgfCBhc3luYyB9fVxuICA8L2J1dHRvbj5cblxuICA8YnV0dG9uIGNsYXNzPVwiaGVhZGVyLW5hdmlnYXRpb25cIlxuICAgICAgICAgIChjbGljayk9XCJuZXh0KCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJuZXh0QXJpYSQgfCBhc3luY1wiXG4gICAgICAgICAgdGFiaW5kZXg9XCIwXCI+XG5cbiAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1uZXh0XCI+PC9pPlxuICA8L2J1dHRvbj5cbjwvaGVhZGVyPmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgSGVhZGVyQ29tcG9uZW50IHtcblxuICAgIGNhbkFzY2VuZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiBtb2RlICE9PSBEYXRlUGlja2VyTW9kZS5ZZWFyKSk7XG4gICAgXG4gICAgbW9kZSQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0RheSc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiAnTW9udGgnO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5ZZWFyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnWWVhcic7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBoZWFkZXJBcmlhJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5kYXRlcGlja2VyLm1vZGUkLnBpcGUobWFwKG1vZGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuRGF5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnU3dpdGNoIHRvIHNob3cgbW9udGhzIGluIHRoZSB5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTd2l0Y2ggdG8gc2hvdyB5ZWFycyBpbiB0aGUgZGVjYWRlJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBwcmV2aW91c0FyaWEkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdQcmV2aW91cyBtb250aCc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiAnUHJldmlvdXMgeWVhcic7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdQcmV2aW91cyBkZWNhZGUnO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgbmV4dEFyaWEkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZXh0IG1vbnRoJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZXh0IHllYXInO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5ZZWFyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnTmV4dCBkZWNhZGUnO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGVwaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSkgeyB9XG5cbiAgICBwcmV2aW91cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLmdvVG9QcmV2aW91cygpO1xuICAgIH1cblxuICAgIGFzY2VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLmdvVG9QYXJlbnRNb2RlKCk7XG4gICAgfVxuXG4gICAgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLmdvVG9OZXh0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBNb2RlRGlyZWN0aW9uIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IGdyaWRpZnksIG1vbnRoc1Nob3J0LCByYW5nZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIudXRpbHMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTW9udGhWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TW9udGhWaWV3SXRlbVtdW10+KFtbXV0pO1xuICAgIGZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxGb2N1c2VkTW9udGhJdGVtPihudWxsKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9kYXRlcGlja2VyLnllYXIkLnN1YnNjcmliZSh5ZWFyID0+IHRoaXMuY3JlYXRlTW9udGhHcmlkKHllYXIpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMobW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCQubmV4dCh7IG1vbnRoOiBtb250aCwgeWVhcjogeWVhciB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZpZXdwb3J0IHRvIGVuc3VyZSBmb2N1c2VkIG1vbnRoIGlzIHZpc2libGVcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRWaWV3cG9ydFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVNb250aEdyaWQoeWVhcjogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWFkZXJcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRIZWFkZXIoeWVhci50b1N0cmluZygpKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgeWVhciBhbmQgbW9udGhcbiAgICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBtb250aFxuICAgICAgICBjb25zdCBhY3RpdmVNb250aCA9IHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVllYXIgPSB0aGlzLl9kYXRlcGlja2VyLnNlbGVjdGVkJC52YWx1ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIDR4MyBncmlkIG9mIG1vbnRoIG51bWJlcnNcbiAgICAgICAgY29uc3QgbW9udGhzOiBNb250aFZpZXdJdGVtW10gPSByYW5nZSgwLCAxMSkubWFwKG1vbnRoID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbW9udGhzU2hvcnRbbW9udGhdLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgICAgICAgIGlzQ3VycmVudE1vbnRoOiB5ZWFyID09PSBjdXJyZW50WWVhciAmJiBtb250aCA9PT0gY3VycmVudE1vbnRoLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlTW9udGg6IHllYXIgPT09IGFjdGl2ZVllYXIgJiYgbW9udGggPT09IGFjdGl2ZU1vbnRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBtYXAgdGhlc2UgdG8gdGhlIGFwcHJvcHJpYXRlIGZvcm1hdFxuICAgICAgICBjb25zdCBpdGVtczogTW9udGhWaWV3SXRlbVtdW10gPSBncmlkaWZ5KG1vbnRocywgNCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBncmlkXG4gICAgICAgIHRoaXMuZ3JpZCQubmV4dChpdGVtcyk7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZm9jdXNlZCBtb250aCBzZWxlY3QgdGhlIGZpcnN0IG9uZVxuICAgICAgICBpZiAodGhpcy5fZGF0ZXBpY2tlci5tb2RlRGlyZWN0aW9uID09PSBNb2RlRGlyZWN0aW9uLkRlc2NlbmQgJiYgdGhpcy5mb2N1c2VkJC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgc2VsZWN0ZWQgbW9udGggaXMgaW4gdmlld1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRNb250aCA9IG1vbnRocy5maW5kKG1vbnRoID0+IG1vbnRoLmlzQWN0aXZlTW9udGgpO1xuXG4gICAgICAgICAgICB0aGlzLnNldEZvY3VzKHNlbGVjdGVkTW9udGggPyBzZWxlY3RlZE1vbnRoLm1vbnRoIDogMCwgeWVhcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9udGhWaWV3SXRlbSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG1vbnRoOiBudW1iZXI7XG4gICAgeWVhcjogbnVtYmVyO1xuICAgIGlzQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICAgIGlzQWN0aXZlTW9udGg6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9jdXNlZE1vbnRoSXRlbSB7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBEYXRlUGlja2VySGVhZGVyRXZlbnQsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBNb250aFZpZXdJdGVtLCBNb250aFZpZXdTZXJ2aWNlIH0gZnJvbSAnLi9tb250aC12aWV3LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWRhdGUtdGltZS1waWNrZXItbW9udGgtdmlldycsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXJcIiByb2xlPVwiZ3JpZFwiPlxuICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItcm93XCIgKm5nRm9yPVwibGV0IHJvdyBvZiBtb250aFNlcnZpY2UuZ3JpZCQgfCBhc3luYzsgdHJhY2tCeTogdHJhY2tSb3dCeUZuXCIgcm9sZT1cInJvd1wiPlxuXG4gICAgPGJ1dHRvbiByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgY2xhc3M9XCJjYWxlbmRhci1pdGVtXCJcbiAgICAgICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIHJvdzsgdHJhY2tCeTogdHJhY2tNb250aEJ5Rm5cIlxuICAgICAgICAgW2ZvY3VzSWZdPVwiKG1vbnRoU2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8ubW9udGggPT09IGl0ZW0ubW9udGggJiYgKG1vbnRoU2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8ueWVhciA9PT0gaXRlbS55ZWFyXCJcbiAgICAgICAgIFt0YWJpbmRleF09XCJnZXRUYWJiYWJsZShpdGVtKSA/IDAgOiAtMVwiXG4gICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIml0ZW0ubmFtZSArICcgJyArIGl0ZW0ueWVhclwiXG4gICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cIml0ZW0uaXNBY3RpdmVNb250aFwiXG4gICAgICAgICBbY2xhc3MuYWN0aXZlXT1cIml0ZW0uaXNBY3RpdmVNb250aFwiXG4gICAgICAgICBbY2xhc3MuY3VycmVudF09XCJpdGVtLmlzQ3VycmVudE1vbnRoXCJcbiAgICAgICAgIChjbGljayk9XCJzZWxlY3QoaXRlbS5tb250aCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAoa2V5ZG93bi5BcnJvd0xlZnQpPVwiZm9jdXNNb250aChpdGVtLCAtMSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwiZm9jdXNNb250aChpdGVtLCAxKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dVcCk9XCJmb2N1c01vbnRoKGl0ZW0sIC00KTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dEb3duKT1cImZvY3VzTW9udGgoaXRlbSwgNCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG4gICAgICAgICB7eyBpdGVtLm5hbWUgfX1cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgcHJvdmlkZXJzOiBbTW9udGhWaWV3U2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTW9udGhWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZVBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBwdWJsaWMgbW9udGhTZXJ2aWNlOiBNb250aFZpZXdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9kYXRlUGlja2VyLmhlYWRlckV2ZW50JFxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiBldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLm5leHQoKSA6IHRoaXMucHJldmlvdXMoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdvIHRvIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHRoaXMuX2RhdGVQaWNrZXIueWVhciQudmFsdWUgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHbyB0byB0aGUgbmV4dCB5ZWFyXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydFllYXIodGhpcy5fZGF0ZVBpY2tlci55ZWFyJC52YWx1ZSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIG1vbnRoIGluIHRoZSBjYWxlbmRhclxuICAgICAqIEBwYXJhbSBtb250aCB0aGUgaW5kZXggb2YgdGhlIG1vbnRoIHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgZGF5IHBpY2tlclxuICAgICAgICB0aGlzLl9kYXRlUGlja2VyLmdvVG9DaGlsZE1vZGUoKTtcbiAgICB9XG5cbiAgICBmb2N1c01vbnRoKGl0ZW06IE1vbnRoVmlld0l0ZW0sIG1vbnRoT2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRhcmdldE1vbnRoID0gaXRlbS5tb250aCArIG1vbnRoT2Zmc2V0O1xuICAgICAgICBsZXQgdGFyZ2V0WWVhciA9IGl0ZW0ueWVhcjtcblxuICAgICAgICBpZiAodGFyZ2V0TW9udGggPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRNb250aCArPSAxMjtcbiAgICAgICAgICAgIHRhcmdldFllYXIgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRNb250aCA+PSAxMikge1xuICAgICAgICAgICAgdGFyZ2V0TW9udGggLT0gMTI7XG4gICAgICAgICAgICB0YXJnZXRZZWFyICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vbnRoU2VydmljZS5zZXRGb2N1cyh0YXJnZXRNb250aCwgdGFyZ2V0WWVhcik7XG4gICAgfVxuXG4gICAgdHJhY2tSb3dCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgdHJhY2tNb250aEJ5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogTW9udGhWaWV3SXRlbSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtpdGVtLm1vbnRofSAke2l0ZW0ueWVhcn1gO1xuICAgIH1cblxuICAgIGdldFRhYmJhYmxlKGl0ZW06IE1vbnRoVmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMubW9udGhTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5tb250aFNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBmb2N1c2VkIG1vbnRoIGNoZWNrIGlmIHRoaXMgaXMgaXRcbiAgICAgICAgaWYgKGZvY3VzZWQpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZvY3VzZWQgbW9udGggaXMgdmlzaWJsZVxuICAgICAgICAgICAgY29uc3QgaXNGb2N1c2VkTW9udGhWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0ubW9udGggPT09IGZvY3VzZWQubW9udGggJiYgX2l0ZW0ueWVhciA9PT0gZm9jdXNlZC55ZWFyKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpc0ZvY3VzZWRNb250aFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXNlZC5tb250aCA9PT0gaXRlbS5tb250aCAmJiBmb2N1c2VkLnllYXIgPT09IGl0ZW0ueWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSBtb250aCB0aGVuIGNoZWNrIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgbW9udGhcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKG1vbnRoID0+IG1vbnRoLmlzQWN0aXZlTW9udGgpKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaXNBY3RpdmVNb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBtb250aCB0YWJiYWJsZVxuICAgICAgICByZXR1cm4gaXRlbS5tb250aCA9PT0gMDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLXRpbWUtdmlldycsXG4gICAgdGVtcGxhdGU6IGA8dXgtdGltZS1waWNrZXIgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dUaW1lJCB8IGFzeW5jXCJcbiAgICBbdmFsdWVdPVwiZGF0ZXBpY2tlci5zZWxlY3RlZCQgfCBhc3luY1wiXG4gICAgKHZhbHVlQ2hhbmdlKT1cImRhdGVwaWNrZXIuc2VsZWN0ZWQkLm5leHQoJGV2ZW50KVwiXG4gICAgW3Nob3dTZWNvbmRzXT1cImRhdGVwaWNrZXIuc2hvd1NlY29uZHMkIHwgYXN5bmNcIlxuICAgIFtzaG93TWVyaWRpYW5dPVwiZGF0ZXBpY2tlci5zaG93TWVyaWRpYW4kIHwgYXN5bmNcIlxuICAgIFtzaG93U3Bpbm5lcnNdPVwiZGF0ZXBpY2tlci5zaG93U3Bpbm5lcnMkIHwgYXN5bmNcIj5cbjwvdXgtdGltZS1waWNrZXI+XG5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dUaW1lem9uZSQgfCBhc3luY1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtem9uZS1waWNrZXJcIiAqbmdJZj1cImRhdGVwaWNrZXIuc2hvd1NwaW5uZXJzJCB8IGFzeW5jXCI+XG5cbiAgICAgICAgPHV4LXNwaW4tYnV0dG9uXG4gICAgICAgICAgICBjbGFzcz1cInRpbWUtem9uZS1zcGlubmVyXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCIoZGF0ZXBpY2tlci50aW1lem9uZSQgfCBhc3luYykubmFtZVwiXG4gICAgICAgICAgICBbcmVhZE9ubHldPVwidHJ1ZVwiXG4gICAgICAgICAgICAoaW5jcmVtZW50KT1cImluY3JlbWVudFRpbWV6b25lKClcIlxuICAgICAgICAgICAgKGRlY3JlbWVudCk9XCJkZWNyZW1lbnRUaW1lem9uZSgpXCJcbiAgICAgICAgICAgIGlucHV0QXJpYUxhYmVsPVwiVGltZSBab25lXCJcbiAgICAgICAgICAgIGluY3JlbWVudEFyaWFMYWJlbD1cIlN3aXRjaCB0byB0aGUgbmV4dCB0aW1lIHpvbmVcIlxuICAgICAgICAgICAgZGVjcmVtZW50QXJpYUxhYmVsPVwiU3dpdGNoIHRvIHRoZSBwcmV2aW91cyB0aW1lIHpvbmVcIj5cbiAgICAgICAgPC91eC1zcGluLWJ1dHRvbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXpvbmUtcGlja2VyXCIgKm5nSWY9XCIhKGRhdGVwaWNrZXIuc2hvd1NwaW5uZXJzJCB8IGFzeW5jKVwiPlxuXG4gICAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2wgdGltZS16b25lLXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICBbbmdNb2RlbF09XCIoZGF0ZXBpY2tlci50aW1lem9uZSQgfCBhc3luYykubmFtZVwiXG4gICAgICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwic2VsZWN0VGltZXpvbmUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlRpbWV6b25lXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cIihkYXRlcGlja2VyLnRpbWV6b25lJCB8IGFzeW5jKS5uYW1lXCI+XG5cbiAgICAgICAgICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IHpvbmUgb2YgZGF0ZXBpY2tlci50aW1lem9uZXMkIHwgYXN5bmNcIlxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRdPVwiem9uZS5uYW1lID09PSAoZGF0ZXBpY2tlci50aW1lem9uZSQgfCBhc3luYykubmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ6b25lLm5hbWVcIj5cbiAgICAgICAgICAgICAgICB7eyB6b25lPy5uYW1lIH19XG4gICAgICAgICAgICA8L29wdGlvbj5cblxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cblxuPC9uZy1jb250YWluZXI+XG5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFRpbWVWaWV3Q29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHsgfVxuXG4gICAgc2VsZWN0VGltZXpvbmUobmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lcyA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLnZhbHVlO1xuICAgICAgICBcbiAgICAgICAgLy8gZmluZCBtYXRjaGluZyB0aW1lem9uZVxuICAgICAgICBjb25zdCB0aW1lem9uZSA9IHRpbWV6b25lcy5maW5kKF90aW1lem9uZSA9PiBfdGltZXpvbmUubmFtZSA9PT0gbmFtZSk7XG5cbiAgICAgICAgaWYgKHRpbWV6b25lKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVwaWNrZXIuc2V0VGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5jcmVtZW50VGltZXpvbmUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lID0gdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lJC52YWx1ZTtcbiAgICAgICAgY29uc3QgdGltZXpvbmVzID0gdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lcyQudmFsdWU7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFpvbmUgPSB0aW1lem9uZXMuZmluZEluZGV4KHpvbmUgPT4gem9uZS5uYW1lID09PSB0aW1lem9uZS5uYW1lICYmIHpvbmUub2Zmc2V0ID09PSB0aW1lem9uZS5vZmZzZXQpO1xuXG4gICAgICAgIC8vIHRyeSB0byBnZXQgdGhlIHByZXZpb3VzIHpvbmVcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLnNldFRpbWV6b25lKHRpbWV6b25lc1tjdXJyZW50Wm9uZSArIDFdID8gdGltZXpvbmVzW2N1cnJlbnRab25lICsgMV0gOiB0aW1lem9uZXNbY3VycmVudFpvbmVdKTtcbiAgICB9XG5cbiAgICBkZWNyZW1lbnRUaW1lem9uZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLnZhbHVlO1xuICAgICAgICBjb25zdCB0aW1lem9uZXMgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmVzJC52YWx1ZTtcblxuICAgICAgICBjb25zdCBjdXJyZW50Wm9uZSA9IHRpbWV6b25lcy5maW5kSW5kZXgoem9uZSA9PiB6b25lLm5hbWUgPT09IHRpbWV6b25lLm5hbWUgJiYgem9uZS5vZmZzZXQgPT09IHRpbWV6b25lLm9mZnNldCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcHJldmlvdXMgem9uZVxuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuc2V0VGltZXpvbmUodGltZXpvbmVzW2N1cnJlbnRab25lIC0gMV0gPyB0aW1lem9uZXNbY3VycmVudFpvbmUgLSAxXSA6IHRpbWV6b25lc1tjdXJyZW50Wm9uZV0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IERhdGVQaWNrZXJIZWFkZXJFdmVudCwgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IGdyaWRpZnksIHJhbmdlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBZZWFyVmlld1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgZ3JpZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFllYXJWaWV3SXRlbVtdW10+KFtbXV0pO1xuICAgIGZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfeWVhcjogbnVtYmVyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgIGNvbnN0IHllYXIgPSBfZGF0ZXBpY2tlci55ZWFyJC5zdWJzY3JpYmUoX3llYXIgPT4gdGhpcy5jcmVhdGVZZWFyR3JpZChfeWVhcikpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2RhdGVwaWNrZXIuaGVhZGVyRXZlbnQkXG4gICAgICAgICAgICAuc3Vic2NyaWJlKF9ldmVudCA9PiBfZXZlbnQgPT09IERhdGVQaWNrZXJIZWFkZXJFdmVudC5OZXh0ID8gdGhpcy5nb1RvTmV4dERlY2FkZSgpIDogdGhpcy5nb1RvUHJldmlvdXNEZWNhZGUoKSk7XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh5ZWFyKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChldmVudCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEZvY3VzKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQkLm5leHQoeWVhcik7XG4gICAgICAgIHRoaXMuY3JlYXRlWWVhckdyaWQoeWVhcik7XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZpb3VzRGVjYWRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNyZWF0ZVllYXJHcmlkKHRoaXMuX3llYXIgLSAxMCk7XG4gICAgfVxuXG4gICAgZ29Ub05leHREZWNhZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3JlYXRlWWVhckdyaWQodGhpcy5feWVhciArIDEwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVllYXJHcmlkKHllYXI6IG51bWJlciA9IHRoaXMuX3llYXIpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLl95ZWFyID0geWVhcjtcblxuICAgICAgICAvLyBnZXQgdGhlIHllYXJzIHRvIGRpc3BsYXlcbiAgICAgICAgY29uc3QgZGVjYWRlID0gdGhpcy5nZXREZWNhZGUoeWVhcik7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgLy8gcHJvZHVjZSBpdGVtcyBpbiB0aGUgY29ycmVjdCBmb3JtYXRcbiAgICAgICAgY29uc3QgaXRlbXM6IFllYXJWaWV3SXRlbVtdID0gZGVjYWRlLnJhbmdlLm1hcChfeWVhciA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHllYXI6IF95ZWFyLFxuICAgICAgICAgICAgICAgIGlzQ3VycmVudFllYXI6IF95ZWFyID09PSBjdXJyZW50WWVhcixcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZVllYXI6IF95ZWFyID09PSB0aGlzLl9kYXRlcGlja2VyLnllYXIkLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlciB0ZXh0XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0SGVhZGVyKGRlY2FkZS5zdGFydCArICcgLSAnICsgZGVjYWRlLmVuZCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBncmlkXG4gICAgICAgIHRoaXMuZ3JpZCQubmV4dChncmlkaWZ5KGl0ZW1zLCA0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB5ZWFycyBpbiB0aGUgY3VycmVudCBkZWNhZGUgdG8gZGlzcGxheVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RGVjYWRlKHllYXI6IG51bWJlcik6IFllYXJSYW5nZSB7XG5cbiAgICAgICAgLy8gZmlndXJlIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgICAgICBjb25zdCBzdGFydCA9ICh5ZWFyIC0gKHllYXIgJSAxMCkpO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIDk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBudW1iZXJzIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHJhbmdlOiByYW5nZShzdGFydCwgZW5kKSB9O1xuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFllYXJSYW5nZSB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbiAgICByYW5nZTogbnVtYmVyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgWWVhclZpZXdJdGVtIHtcbiAgICB5ZWFyOiBudW1iZXI7XG4gICAgaXNDdXJyZW50WWVhcjogYm9vbGVhbjtcbiAgICBpc0FjdGl2ZVllYXI6IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IFllYXJWaWV3SXRlbSwgWWVhclZpZXdTZXJ2aWNlIH0gZnJvbSAnLi95ZWFyLXZpZXcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LWRhdGUtdGltZS1waWNrZXIteWVhci12aWV3JyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXJcIiByb2xlPVwiZ3JpZFwiPlxuICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItcm93XCIgcm9sZT1cInJvd1wiICpuZ0Zvcj1cImxldCByb3cgb2YgeWVhclNlcnZpY2UuZ3JpZCQgfCBhc3luYzsgdHJhY2tCeTogdHJhY2tSb3dCeUZuXCI+XG5cbiAgICA8YnV0dG9uICpuZ0Zvcj1cImxldCBpdGVtIG9mIHJvdzsgdHJhY2tCeTogdHJhY2tZZWFyQnlGblwiXG4gICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgY2xhc3M9XCJjYWxlbmRhci1pdGVtXCJcbiAgICAgICAgIFtmb2N1c0lmXT1cIih5ZWFyU2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKSA9PT0gaXRlbS55ZWFyXCJcbiAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaXRlbS55ZWFyXCJcbiAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiaXRlbS5pc0FjdGl2ZVllYXJcIlxuICAgICAgICAgW2NsYXNzLmN1cnJlbnRdPVwiaXRlbS5pc0N1cnJlbnRZZWFyXCJcbiAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwiaXRlbS5pc0FjdGl2ZVllYXJcIlxuICAgICAgICAgKGNsaWNrKT1cInNlbGVjdChpdGVtLnllYXIpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cImZvY3VzWWVhcihpdGVtLCAtMSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwiZm9jdXNZZWFyKGl0ZW0sIDEpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cImZvY3VzWWVhcihpdGVtLCAtNCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJmb2N1c1llYXIoaXRlbSwgNCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIFt0YWJpbmRleF09XCJnZXRUYWJiYWJsZShpdGVtKSA/IDAgOiAtMVwiPlxuICAgICAgICAge3sgaXRlbS55ZWFyIH19XG4gICAgPC9idXR0b24+XG4gIDwvZGl2PlxuPC9kaXY+XG5gLFxuICBwcm92aWRlcnM6IFtZZWFyVmlld1NlcnZpY2VdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBZZWFyVmlld0NvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZVBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBwdWJsaWMgeWVhclNlcnZpY2U6IFllYXJWaWV3U2VydmljZSkge31cblxuICBzZWxlY3QoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydFllYXIoeWVhcik7XG5cbiAgICAvLyBzaG93IHRoZSBtb250aCBwaWNrZXJcbiAgICB0aGlzLl9kYXRlUGlja2VyLmdvVG9DaGlsZE1vZGUoKTtcbiAgfVxuXG4gIGZvY3VzWWVhcihpdGVtOiBZZWFyVmlld0l0ZW0sIHllYXJPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMueWVhclNlcnZpY2Uuc2V0Rm9jdXMoaXRlbS55ZWFyICsgeWVhck9mZnNldCk7XG4gIH1cblxuICB0cmFja1Jvd0J5Rm4oaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgdHJhY2tZZWFyQnlGbihpbmRleDogbnVtYmVyLCBpdGVtOiBZZWFyVmlld0l0ZW0pOiBudW1iZXIge1xuICAgIHJldHVybiBpdGVtLnllYXI7XG4gIH1cblxuICBnZXRUYWJiYWJsZShpdGVtOiBZZWFyVmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICBjb25zdCBmb2N1c2VkID0gdGhpcy55ZWFyU2VydmljZS5mb2N1c2VkJC52YWx1ZTtcbiAgICBjb25zdCBncmlkID0gdGhpcy55ZWFyU2VydmljZS5ncmlkJC52YWx1ZTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGEgZm9jdXNlZCB5ZWFyIGNoZWNrIGlmIHRoaXMgaXMgaXRcbiAgICBpZiAoZm9jdXNlZCkge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmb2N1c2VkIHllYXIgaXMgdmlzaWJsZVxuICAgICAgICBjb25zdCBpc0ZvY3VzZWRZZWFyVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKF9pdGVtID0+IF9pdGVtLnllYXIgPT09IGZvY3VzZWQpKTtcblxuICAgICAgICBpZiAoaXNGb2N1c2VkWWVhclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmb2N1c2VkID09PSBpdGVtLnllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBmb2N1c2FibGUgeWVhciB0aGVuIGNoZWNrIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgeWVhclxuICAgIGNvbnN0IGlzU2VsZWN0ZWRZZWFyVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKHllYXIgPT4geWVhci5pc0FjdGl2ZVllYXIpKTtcblxuICAgIGlmIChpc1NlbGVjdGVkWWVhclZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaXNBY3RpdmVZZWFyO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBtb250aCB0YWJiYWJsZVxuICAgIHJldHVybiBncmlkWzBdWzBdLnllYXIgPT09IGl0ZW0ueWVhcjtcbn1cblxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tmb2N1c0lmXSdcbn0pXG5leHBvcnQgY2xhc3MgRm9jdXNJZkRpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoKSBmb2N1c0lmRGVsYXk6IG51bWJlciA9IDA7XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmb2N1c0lmKGZvY3VzOiBib29sZWFuKSB7XG5cbiAgICAgICAgLy8gaWYgYSB0aW1lb3V0IGlzIHBlbmRpbmcgdGhlbiBjYW5jZWwgaXRcbiAgICAgICAgaWYgKCFmb2N1cyAmJiB0aGlzLl90aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2N1cyAmJiB0aGlzLl90aW1lb3V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcy5mb2N1c0lmRGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdGltZW91dDogbnVtYmVyID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c0lmRGlyZWN0aXZlIH0gZnJvbSAnLi9mb2N1cy1pZi5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZvY3VzSWZEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZvY3VzSWZEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIEZvY3VzSWZNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3BpbkJ1dHRvbk1vZHVsZSB9IGZyb20gJy4uL3NwaW4tYnV0dG9uL2luZGV4JztcbmltcG9ydCB7IFRpbWVQaWNrZXJNb2R1bGUgfSBmcm9tICcuLi90aW1lLXBpY2tlci9pbmRleCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJDb25maWcgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuY29uZmlnJztcbmltcG9ydCB7IERheVZpZXdDb21wb25lbnQgfSBmcm9tICcuL2RheS12aWV3L2RheS12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2hlYWRlci9oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IE1vbnRoVmlld0NvbXBvbmVudCB9IGZyb20gJy4vbW9udGgtdmlldy9tb250aC12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaW1lVmlld0NvbXBvbmVudCB9IGZyb20gJy4vdGltZS12aWV3L3RpbWUtdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgWWVhclZpZXdDb21wb25lbnQgfSBmcm9tICcuL3llYXItdmlldy95ZWFyLXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFRpbWVQaWNrZXJNb2R1bGUsXG4gICAgICAgIFNwaW5CdXR0b25Nb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtEYXRlVGltZVBpY2tlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQsIEhlYWRlckNvbXBvbmVudCwgRGF5Vmlld0NvbXBvbmVudCwgTW9udGhWaWV3Q29tcG9uZW50LCBZZWFyVmlld0NvbXBvbmVudCwgVGltZVZpZXdDb21wb25lbnRdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBEYXRlVGltZVBpY2tlckNvbmZpZ1xuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVQaWNrZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1lYm94JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1lYm94LWhlYWRlclwiPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cInV4LWVib3gtaGVhZGVyXCI+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJ1eC1lYm94LWNvbnRlbnRcIj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJ1eC1lYm94LWNvbnRlbnRcIj48L25nLWNvbnRlbnQ+XG48L2Rpdj5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIEVib3hDb21wb25lbnQgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZWJveC1oZWFkZXInXG59KVxuZXhwb3J0IGNsYXNzIEVib3hIZWFkZXJEaXJlY3RpdmUgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZWJveC1jb250ZW50J1xufSlcbmV4cG9ydCBjbGFzcyBFYm94Q29udGVudERpcmVjdGl2ZSB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEVib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlIH0gZnJvbSAnLi9lYm94LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0Vib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtFYm94Q29tcG9uZW50LCBFYm94Q29udGVudERpcmVjdGl2ZSwgRWJveEhlYWRlckRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRWJveE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBUZW1wbGF0ZVJlZiwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbmNob3JQbGFjZW1lbnQgfSBmcm9tICcuL3Rvb2x0aXAuZGlyZWN0aXZlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5sZXQgdW5pcXVlVG9vbHRpcElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtdG9vbHRpcCcsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInRvb2x0aXAgaW5cIiBbaWRdPVwiaWRcIiBbYXR0ci5yb2xlXT1cInJvbGVcIiBbbmdDbGFzc109XCJbcGxhY2VtZW50LCBjdXN0b21DbGFzc11cIj5cbiAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCIgKGNka09ic2VydmVDb250ZW50KT1cInJlcG9zaXRpb24oKVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGVSZWZcIj57eyBjb250ZW50IH19PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpc1RlbXBsYXRlUmVmXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29udGVudFwiIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJjb250ZXh0XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG48L2Rpdj5gLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBUb29sdGlwQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogRGVmaW5lIGEgdW5pcXVlIGlkIGZvciBlYWNoIHRvb2x0aXAgKi9cbiAgaWQ6IHN0cmluZyA9IGB1eC10b29sdGlwLSR7Kyt1bmlxdWVUb29sdGlwSWR9YDtcblxuICAvKiogRGVmaW5lIHRoZSB0b29sdGlwIHJvbGUgKi9cbiAgcm9sZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gIC8qKiBUaGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCwgZWl0aGVyIGEgc3RyaW5nIG9yIGEgVGVtcGxhdGVSZWYgZm9yIGZ1cnRoZXIgY3VzdG9taXphdGlvbiAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKiBBbGxvdyB0aGUgdXNlciB0byBzdXBwbHkgYSBjb250ZXh0IGZvciB0aGUgdG9vbHRpcCBUZW1wbGF0ZVJlZiAqL1xuICBjb250ZXh0OiBhbnk7XG5cbiAgLyoqIFRoZSBwb3NpdGlvbiB0aGUgdG9vbHRpcCBzaG91bGQgZGlzcGxheSByZWxhdGl2ZSB0byB0aGUgYXNzb2NpYXRlZCBlbGVtZW50ICovXG4gIHBsYWNlbWVudDogQW5jaG9yUGxhY2VtZW50O1xuXG4gIC8qKiBBbGxvdyBhIGN1c3RvbSBjbGFzcyB0byBiZSBhZGRlZCB0byB0aGUgdG9vbHRpcCB0byBhbGxvdyBjdXN0b20gc3R5bGluZyAqL1xuICBjdXN0b21DbGFzczogc3RyaW5nID0gJyc7XG5cbiAgLyoqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgY29udGVudCBpcyBhIHN0cmluZyBvciBhIFRlbXBsYXRlUmVmICovXG4gIGlzVGVtcGxhdGVSZWY6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogRW1pdCB3aGVuIHRoZSB0b29sdGlwIG5lZWQgdG8gdXBkYXRlIGl0J3MgcG9zaXRpb24gKi9cbiAgcmVwb3NpdGlvbiQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gIC8qKiBDbGVhbnVwIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMucmVwb3NpdGlvbiQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBJbmZvcm0gdGhlIHBhcmVudCBkaXJlY3RpdmUgdGhhdCBpdCBuZWVkcyB0byByZWNhbHVsYXRlIHRoZSBwb3NpdGlvbiAqL1xuICByZXBvc2l0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMucmVwb3NpdGlvbiQubmV4dCgpO1xuICB9XG5cbiAgLyoqIFRoaXMgd2lsbCB1cGRhdGUgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMuaXNUZW1wbGF0ZVJlZiA9IGNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBUaGlzIHdpbGwgdXBkYXRlIHRoZSB0b29sdGlwIHBsYWNlbWVudCBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uICovXG4gIHNldFBsYWNlbWVudChwbGFjZW1lbnQ6IEFuY2hvclBsYWNlbWVudCkge1xuXG4gICAgaWYgKCFwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBUaGlzIHdpbGwgc2V0IGEgY3VzdG9tIGNsYXNzIG9uIHRoZSB0b29sdGlwIGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gKi9cbiAgc2V0Q2xhc3MoY3VzdG9tQ2xhc3M6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgaWYgKCFjdXN0b21DbGFzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VzdG9tQ2xhc3MgPSBjdXN0b21DbGFzcztcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIHRoZSBjb250ZXh0IHVzZWQgYnkgdGhlIFRlbXBsYXRlUmVmICovXG4gIHNldENvbnRleHQoY29udGV4dDogYW55KTogdm9pZCB7XG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFNwZWNpZnkgdGhlIHRvb2x0aXAgcm9sZSBhdHRyaWJ1dGUgKi9cbiAgc2V0Um9sZShyb2xlOiBzdHJpbmcpOiB2b2lkIHtcblxuICAgIGlmICghcm9sZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucm9sZSA9IHJvbGU7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi90b29sdGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRvb2x0aXBTZXJ2aWNlIHtcbiAgICBzaG93biQgPSBuZXcgU3ViamVjdDxUb29sdGlwQ29tcG9uZW50PigpO1xufSIsImltcG9ydCB7IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiwgT3ZlcmxheSwgT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbiwgT3ZlcmxheVJlZiwgU2Nyb2xsRGlzcGF0Y2hlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBSZW5kZXJlcjIsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi90b29sdGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUb29sdGlwU2VydmljZSB9IGZyb20gJy4vdG9vbHRpcC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhUb29sdGlwXScsXG4gICAgZXhwb3J0QXM6ICd1eC10b29sdGlwJ1xufSlcbmV4cG9ydCBjbGFzcyBUb29sdGlwRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogQ29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgb3IgYSBUZW1wbGF0ZVJlZiBmb3IgbW9yZSBkZXRhaWxlZCBjb250ZW50ICovXG4gICAgQElucHV0KCd1eFRvb2x0aXAnKSBjb250ZW50OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqIEFsbG93IHRoZSB0b29sdGlwIHRvIGJlIGNvbmRpdGlvbmFsbHkgZGlzYWJsZWQgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBEaXNhYmxlZCcpIGRpc2FibGVkOiBib29sZWFuO1xuXG4gICAgLyoqIEFsbCB0aGUgdXNlciB0byBhZGQgYSBjdXN0b20gY2xhc3MgdG8gdGhlIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBDbGFzcycpIGN1c3RvbUNsYXNzOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKiBBbGwgdGhlIHVzZXIgdG8gYWRkIGEgcm9sZSB0byB0aGUgdG9vbHRpcCAtIGRlZmF1bHQgaXMgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgndG9vbHRpcFJvbGUnKSByb2xlOiBzdHJpbmcgPSAndG9vbHRpcCc7XG5cbiAgICAvKiogUHJvdmlkZSB0aGUgVGVtcGxhdGVSZWYgYSBjb250ZXh0IG9iamVjdCAqL1xuICAgIEBJbnB1dCgndG9vbHRpcENvbnRleHQnKSBjb250ZXh0OiBhbnkgPSB7fTtcblxuICAgIC8qKiBEZWxheSB0aGUgc2hvd2luZyBvZiB0aGUgdG9vbHRpcCBieSBhIG51bWJlciBvZiBtaWxpc2Vjb25kcyAqL1xuICAgIEBJbnB1dCgndG9vbHRpcERlbGF5JykgZGVsYXk6IG51bWJlciA9IDA7XG5cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSBzaG93IGFuZCBoaWRlIHRoZSB0b29sdGlwICovXG4gICAgQElucHV0KCkgaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQ3VzdG9taXplIGhvdyB0aGUgdG9vbHRpcCBzaG91bGQgYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCAqL1xuICAgIEBJbnB1dCgpIHBsYWNlbWVudDogQW5jaG9yUGxhY2VtZW50ID0gJ3RvcCc7XG5cbiAgICAvKiogU3BlY2lmeSB3aGljaCBldmVudHMgc2hvdWxkIHNob3cgdGhlIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoKSBzaG93VHJpZ2dlcnM6IHN0cmluZ1tdID0gWydtb3VzZWVudGVyJywgJ2ZvY3VzJ107XG5cbiAgICAvKiogU3BlY2lmeSB3aGljaCBldmVudHMgc2hvdWxkIGhpZGUgdGhlIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoKSBoaWRlVHJpZ2dlcnM6IHN0cmluZ1tdID0gWydtb3VzZWxlYXZlJywgJ2JsdXInXTtcblxuICAgIC8qKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSB0b29sdGlwIGlzIHNob3duICovXG4gICAgQE91dHB1dCgpIHNob3duID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEVtaXRzIGEgZXZlbnQgd2hlbiB0aGUgdG9vbHRpcCBpcyBoaWRkZW4gKi9cbiAgICBAT3V0cHV0KCkgaGlkZGVuID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEFsbG93IHR3byB3YXkgYmluZGluZyB0byB0cmFjayB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdG9vbHRpcCAqL1xuICAgIEBPdXRwdXQoKSBpc09wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKiogS2VlcCB0cmFjayBvZiB0aGUgdG9vbHRpcCB2aXNpYmlsaXR5ICovXG4gICAgaXNWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIENESyBwb3J0YWwgY29udGFpbmluZyB0aGUgb3ZlcmxheSAqL1xuICAgIHByb3RlY3RlZCBfcG9ydGFsOiBDb21wb25lbnRQb3J0YWw8VG9vbHRpcENvbXBvbmVudD47XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIG92ZXJsYXkgdGhlIHRvb2x0aXAgd2lsbCBiZSBpbnNlcnRlZCBpbnRvICovXG4gICAgcHJvdGVjdGVkIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmO1xuXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiB0aGUgdG9vbHRpcCBjb21wb25lbnQgd2hlbiBjcmVhdGVkICovXG4gICAgcHJvdGVjdGVkIF9pbnN0YW5jZTogVG9vbHRpcENvbXBvbmVudDtcblxuICAgIC8qKiBUaGlzIHdpbGwgZW1pdCB3aGVuIHRoZSBkaXJlY3RpdmUgaXMgZGVzdHJveWVkIGFsbG93aW5nIHVzIHRvIHVuc3Vic2NyaWJlIGFsbCBzdWJzY3JpcHRpb25zIGF1dG9tYXRpY2FsbHkgKi9cbiAgICBwcm90ZWN0ZWQgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogU3RvcmUgdGhlIHRpbWVvdXQgaW50ZXJ2YWwgZm9yIGNhbmNlbGF0aW9uICovXG4gICAgcHJpdmF0ZSBfc2hvd1RpbWVvdXRJZDogbnVtYmVyO1xuXG4gICAgLyoqIEludGVybmFsbHkgc3RvcmUgdGhlIHR5cGUgb2YgdGhpcyBjb21wb25lbnQgLSB1c3VhbCBmb3IgZGlzdGluY3Rpb25zIHdoZW4gZXh0ZW5kaW5nIHRoaXMgY2xhc3MgKi9cbiAgICBwcm90ZWN0ZWQgX3R5cGU6IHN0cmluZyA9ICd0b29sdGlwJztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcm90ZWN0ZWQgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByb3RlY3RlZCBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJvdGVjdGVkIF9vdmVybGF5OiBPdmVybGF5LFxuICAgICAgICBwcm90ZWN0ZWQgX3Njcm9sbERpc3BhdGNoZXI6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgcHJpdmF0ZSBfdG9vbHRpcFNlcnZpY2U6IFRvb2x0aXBTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIC8qKiBTZXQgdXAgdGhlIHRyaWdnZXJzIGFuZCBiaW5kIHRvIHRoZSBzaG93L2hpZGUgZXZlbnRzIHRvIGtlZXAgdmlzaWJpbGl0eSBpbiBzeW5jICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc2V0IHVwIHNob3cgYW5kIGhpZGUgZXZlbnQgdHJpZ2dlcnNcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NsaWNrJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlZW50ZXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbk1vdXNlRW50ZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWxlYXZlJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25Nb3VzZUxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkZvY3VzLmJpbmQodGhpcykpO1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYmx1cicpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uQmx1ci5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyB3aGVuIGFueSBvdGhlciB0b29sdGlwcyBvcGVuIGhpZGUgdGhpcyBvbmVcbiAgICAgICAgdGhpcy5fdG9vbHRpcFNlcnZpY2Uuc2hvd24kLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fdHlwZSA9PT0gJ3Rvb2x0aXAnKSxcbiAgICAgICAgICAgIGZpbHRlcih0b29sdGlwID0+IHRvb2x0aXAgIT09IHRoaXMuX2luc3RhbmNlKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKHRoaXMuaGlkZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcCBzaG91bGQgYmUgaW5pdGlhbGx5IHZpc2libGUgdGhlbiBvcGVuIGl0XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIHNlbmQgaW5wdXQgY2hhbmdlcyB0byB0aGUgdG9vbHRpcCBjb21wb25lbnRcbiAgICAgKiBXZSBjYW4ndCB1c2Ugc2V0dGVycyBhcyB0aGV5IG1heSB0cmlnZ2VyIGJlZm9yZSB0b29sdGlwIGluaXRpYWxpc2VkIGFuZCBjYW4ndCByZXNlbmQgb25jZSBpbml0aWFsaXNlZFxuICAgICAqKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG5cbiAgICAgICAgLy8gd2UgY2FuIGlnbm9yZSB0aGUgZmlyc3QgY2hhbmdlIGFzIGl0J3MgaGFuZGxlZCBpbiBuZ09uSW5pdFxuICAgICAgICBpZiAoY2hhbmdlcy5pc09wZW4gJiYgIWNoYW5nZXMuaXNPcGVuLmZpcnN0Q2hhbmdlICYmIGNoYW5nZXMuaXNPcGVuLmN1cnJlbnRWYWx1ZSAhPT0gdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGNoYW5nZXMuaXNPcGVuLmN1cnJlbnRWYWx1ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IHRoZSBvdmVybGF5IHJlZiBzbyBhIG5ldyBjb3JyZWN0bHkgcG9zaXRpb25lZCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQgbmV4dCB0aW1lXG4gICAgICAgIGlmIChjaGFuZ2VzLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95T3ZlcmxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMucGxhY2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRQbGFjZW1lbnQoY2hhbmdlcy5wbGFjZW1lbnQuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldENvbnRlbnQoY2hhbmdlcy5jb250ZW50LmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5jdXN0b21DbGFzcykge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0Q2xhc3MoY2hhbmdlcy5jdXN0b21DbGFzcy5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0Q29udGV4dChjaGFuZ2VzLmNvbnRleHQuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLnJvbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldENvbnRleHQoY2hhbmdlcy5yb2xlLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRW5zdXJlIHdlIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlcyAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBjbG9zZSB0aGUgdG9vbHRpcCB3aGVuIHRoZSBob3N0IGlzIGRlc3Ryb3llZFxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbWl0IHRoaXMgZXZlbnQgdG8gYXV0b21hdGljYWxseSB1bnN1YnNjcmliZSBmcm9tIGFsbCBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKiBNYWtlIHRoZSB0b29sdGlwIG9wZW4gKi9cbiAgICBzaG93KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b29sdGlwIGlzIGRpc2FibGVkIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLmlzVmlzaWJsZSB8fCB0aGlzLl9zaG93VGltZW91dElkIHx8ICF0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlbGF5IHRoZSBzaG93IGJ5IHRoZSBkZWxheSBhbW91bnRcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSB0b29sdGlwIGFuZCBnZXQgdGhlIG92ZXJsYXkgcmVmXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5jcmVhdGVPdmVybGF5KCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcG9ydGFsIHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuX3BvcnRhbCA9IHRoaXMuY3JlYXRlUG9ydGFsKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHRoaXMuY3JlYXRlSW5zdGFuY2Uob3ZlcmxheVJlZik7XG5cbiAgICAgICAgICAgIC8vIHdhdGNoIGZvciBhbnkgY2hhbmdlcyB0byB0aGUgY29udGVudFxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UucmVwb3NpdGlvbiQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMucmVwb3NpdGlvbi5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHZpc2libGUgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBvdmVybGF5IGhhcyB0aGUgY29ycmVjdCBpbml0aWFsIHBvc2l0aW9uXG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb24oKTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgc2hvdyBldmVudHNcbiAgICAgICAgICAgIHRoaXMuc2hvd24uZW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5pc09wZW5DaGFuZ2UubmV4dCh0cnVlKTtcblxuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGludGVydmFsIGlkXG4gICAgICAgICAgICB0aGlzLl9zaG93VGltZW91dElkID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgc2hvdyBldmVudCB0byBjbG9zZSBhbnkgb3RoZXIgdG9vbHRpcHNcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTZXJ2aWNlLnNob3duJC5uZXh0KHRoaXMuX2luc3RhbmNlKTtcblxuICAgICAgICAgICAgLy8gZW5zdXJlIGNoYW5nZSBkZXRlY3Rpb24gaXMgcnVuXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0sIHRoaXMuZGVsYXkpO1xuXG4gICAgfVxuXG4gICAgLyoqIElmIGEgdG9vbHRpcCBleGlzdHMgYW5kIGlzIHZpc2libGUsIGhpZGUgaXQgKi9cbiAgICBoaWRlKCkge1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSB3YWl0aW5nIHRvIHNob3cgYSB0b29sdGlwIHRoZW4gY2FuY2VsIHRoZSBwZW5kaW5nIHRpbWVvdXRcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYgJiYgdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRBcmlhRGVzY3JpYmVkQnkobnVsbCk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgdmlzaWJsZSBzdGF0ZVxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGhpZGUgZXZlbnRzXG4gICAgICAgIHRoaXMuaGlkZGVuLmVtaXQoKTtcbiAgICAgICAgdGhpcy5pc09wZW5DaGFuZ2UubmV4dChmYWxzZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIGNoYW5nZSBkZXRlY3Rpb24gaXMgcnVuXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKiogVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB0b29sdGlwICovXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gICAgfVxuXG4gICAgLyoqIFJlY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciAqL1xuICAgIHJlcG9zaXRpb24oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGFuIGluc3RhbmNlIGZyb20gdGhlIG92ZXJsYXkgcmVmIC0gYWxsb3dzIG92ZXJyaWRpbmcgYW5kIGFkZGl0aW9uYWwgbG9naWMgaGVyZSAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVJbnN0YW5jZShvdmVybGF5UmVmOiBPdmVybGF5UmVmKTogVG9vbHRpcENvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gb3ZlcmxheVJlZi5hdHRhY2godGhpcy5fcG9ydGFsKS5pbnN0YW5jZSBhcyBUb29sdGlwQ29tcG9uZW50O1xuXG4gICAgICAgIC8vIHN1cHBseSB0aGUgdG9vbHRpcCB3aXRoIHRoZSBjb3JyZWN0IHByb3BlcnRpZXNcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpbnN0YW5jZS5zZXRQbGFjZW1lbnQodGhpcy5wbGFjZW1lbnQpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDbGFzcyh0aGlzLmN1c3RvbUNsYXNzKTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgICBpbnN0YW5jZS5zZXRSb2xlKHRoaXMucm9sZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLnNldEFyaWFEZXNjcmliZWRCeShpbnN0YW5jZS5pZCk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgdGhlIGNvbXBvbmVudCBwb3J0YWwgLSBhbGxvd3Mgb3ZlcnJpZGluZyB0byBhbGxvdyBvdGhlciBwb3J0YWxzIGVnLiBwb3BvdmVycyAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVQb3J0YWwoKTogQ29tcG9uZW50UG9ydGFsPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsIHx8IG5ldyBDb21wb25lbnRQb3J0YWwoVG9vbHRpcENvbXBvbmVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSB0aGUgb3ZlcmxheSBhbmQgc2V0IHVwIHRoZSBzY3JvbGwgaGFuZGxpbmcgYmVoYXZpb3IgKi9cbiAgICBwcml2YXRlIGNyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvb2x0aXAgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkIHRoZW4ganVzdCByZXR1cm4gdGhlIGV4aXN0aW5nIGluc3RhbmNlXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbmZpZ3VyZSB0aGUgdG9vbHRpcFxuICAgICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnRSZWYsIHRoaXMuZ2V0T3JpZ2luKCksIHRoaXMuZ2V0T3ZlcmxheVBvc2l0aW9uKCkpO1xuXG4gICAgICAgIC8vIGNvcnJlY3RseSBoYW5kbGUgc2Nyb2xsaW5nXG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvcnMgPSB0aGlzLl9zY3JvbGxEaXNwYXRjaGVyXG4gICAgICAgICAgICAuZ2V0QW5jZXN0b3JTY3JvbGxDb250YWluZXJzKHRoaXMuX2VsZW1lbnRSZWYpO1xuXG4gICAgICAgIHN0cmF0ZWd5LndpdGhTY3JvbGxhYmxlQ29udGFpbmVycyhzY3JvbGxhYmxlQW5jZXN0b3JzKTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoe1xuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneTogc3RyYXRlZ3ksXG4gICAgICAgICAgICBwYW5lbENsYXNzOiAndXgtb3ZlcmxheS1wYW5lJyxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbih7IHNjcm9sbFRocm90dGxlOiAwIH0pLFxuICAgICAgICAgICAgaGFzQmFja2Ryb3A6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgIH1cblxuICAgIC8qKiBSZWNyZWF0ZSB0aGUgb3ZlcmxheSByZWYgdXNpbmcgdGhlIHVwZGF0ZWQgb3JpZ2luIGFuZCBvdmVybGF5IHBvc2l0aW9ucyAqL1xuICAgIHByaXZhdGUgZGVzdHJveU92ZXJsYXkoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGVzdHJveSB0aGUgZXhpc3Rpbmcgb3ZlcmxheVxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZiAmJiB0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgb3JpZ2luIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgdG9vbHRpcCBwbGFjZW1lbnQgKi9cbiAgICBwcml2YXRlIGdldE9yaWdpbigpOiBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24ge1xuXG4gICAgICAgIC8vIGVuc3VyZSBwbGFjZW1lbnQgaXMgZGVmaW5lZFxuICAgICAgICB0aGlzLnBsYWNlbWVudCA9IHRoaXMucGxhY2VtZW50IHx8ICd0b3AnO1xuXG4gICAgICAgIGlmICh0aGlzLnBsYWNlbWVudCA9PSAndG9wJyB8fCB0aGlzLnBsYWNlbWVudCA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6IHRoaXMucGxhY2VtZW50IH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxhY2VtZW50ID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENhbGN1bGF0ZSB0aGUgb3ZlcmxheSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHRvb2x0aXAgcGxhY2VtZW50ICovXG4gICAgcHJpdmF0ZSBnZXRPdmVybGF5UG9zaXRpb24oKTogT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbiB7XG5cbiAgICAgICAgLy8gZW5zdXJlIHBsYWNlbWVudCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMucGxhY2VtZW50ID0gdGhpcy5wbGFjZW1lbnQgfHwgJ3RvcCc7XG5cbiAgICAgICAgaWYgKHRoaXMucGxhY2VtZW50ID09ICd0b3AnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAnYm90dG9tJyB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxhY2VtZW50ID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAndG9wJyB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxhY2VtZW50ID09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdlbmQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICdjZW50ZXInIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgdXRpbGl0eSBtZXRob2QgLSBiZWNhdXNlIElFIGRvZXNuJ3Qgc3VwcG9ydCBhcnJheS5pbmNsdWRlc1xuICAgICAqIEFuZCBpdCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgY29yZS1qcy9lczYgcG9seWZpbGxzIHdoaWNoIGFyZSB0aGVcbiAgICAgKiBvbmx5IG9uZXMgcmVxdWlyZWQgYnkgQW5ndWxhciBhbmQgZ3VhcmFudGVlZCB0byBiZSB0aGVyZVxuICAgICAqKi9cbiAgICBwcm90ZWN0ZWQgaW5jbHVkZXM8VD4oYXJyYXk6IEFycmF5PFQ+LCB2YWx1ZTogVCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnJheSkgJiYgISFhcnJheS5maW5kKGl0ZW0gPT4gaXRlbSA9PT0gdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIGNsaWNrIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBpdHMgbm90IHZpc2libGUgYW5kIGNsaWNrIGlzIGEgc2hvdyB0cmlnZ2VyIG9wZW4gaXRcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuc2hvd1RyaWdnZXJzLCAnY2xpY2snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXRzIHZpc2libGUgYW5kIGNsaWNrIGlzIGEgaGlkZSB0cmlnZ2VyIGNsb3NlIGl0XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnY2xpY2snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBtb3VzZSBlbnRlciBldmVudCAtIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseSAqL1xuICAgIHByb3RlY3RlZCBvbk1vdXNlRW50ZXIoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGFuIHNob3cgb25seSB0cmlnZ2VyIC0gaWYgYWxyZWFkeSBvcGVuIG9yIGl0IGlzbid0IGEgdHJpZ2dlciBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSB8fCAhdGhpcy5pbmNsdWRlcyh0aGlzLnNob3dUcmlnZ2VycywgJ21vdXNlZW50ZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIG9wZW4gdGhlIHRvb2x0aXBcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgbW91c2UgbGVhdmUgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25Nb3VzZUxlYXZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhbiBoaWRlIG9ubHkgdHJpZ2dlciAtIGlmIG5vdCBvcGVuIG9yIGl0IGlzbid0IGEgdHJpZ2dlciBkbyBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUgfHwgIXRoaXMuaW5jbHVkZXModGhpcy5oaWRlVHJpZ2dlcnMsICdtb3VzZWxlYXZlJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBjbG9zZSB0aGUgdG9vbHRpcFxuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBmb2N1cyBldmVudCAtIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseSAqL1xuICAgIHByb3RlY3RlZCBvbkZvY3VzKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYW4gc2hvdyBvbmx5IHRyaWdnZXIgLSBpZiBhbHJlYWR5IG9wZW4gb3IgaXQgaXNuJ3QgYSB0cmlnZ2VyIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmluY2x1ZGVzKHRoaXMuc2hvd1RyaWdnZXJzLCAnZm9jdXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIG9wZW4gdGhlIHRvb2x0aXBcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgYmx1ciBldmVudCAtIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseSAqL1xuICAgIHByb3RlY3RlZCBvbkJsdXIoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhbiBoaWRlIG9ubHkgdHJpZ2dlciAtIGlmIG5vdCBvcGVuIG9yIGl0IGlzbid0IGEgdHJpZ2dlciBkbyBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUgfHwgIXRoaXMuaW5jbHVkZXModGhpcy5oaWRlVHJpZ2dlcnMsICdibHVyJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBjbG9zZSB0aGUgdG9vbHRpcFxuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lIGlmIHRoZSB0cmlnZ2VyIGVsZW1lbnQgaXMgZm9jdXNlZCAqL1xuICAgIHByaXZhdGUgaXNGb2N1c2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKiBQcm9ncmFtbWF0aWNhbGx5IHVwZGF0ZSB0aGUgYXJpYS1kZXNjcmliZWRieSBwcm9wZXJ0eSAqL1xuICAgIHByb3RlY3RlZCBzZXRBcmlhRGVzY3JpYmVkQnkoaWQ6IHN0cmluZyB8IG51bGwpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYXJpYS1kZXNjcmliZWRieScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2FyaWEtZGVzY3JpYmVkYnknLCBpZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IHR5cGUgQW5jaG9yUGxhY2VtZW50ID0gJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCc7IiwiaW1wb3J0IHsgT3ZlcmxheU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVG9vbHRpcENvbXBvbmVudCB9IGZyb20gJy4vdG9vbHRpcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVG9vbHRpcERpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbHRpcC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgT2JzZXJ2ZXJzTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL29ic2VydmVycyc7XG5pbXBvcnQgeyBUb29sdGlwU2VydmljZSB9IGZyb20gJy4vdG9vbHRpcC5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIE9ic2VydmVyc01vZHVsZVxuICBdLFxuICBleHBvcnRzOiBbVG9vbHRpcERpcmVjdGl2ZV0sXG4gIGRlY2xhcmF0aW9uczogW1Rvb2x0aXBDb21wb25lbnQsIFRvb2x0aXBEaXJlY3RpdmVdLFxuICBwcm92aWRlcnM6IFtUb29sdGlwU2VydmljZV0sXG4gIGVudHJ5Q29tcG9uZW50czogW1Rvb2x0aXBDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFRvb2x0aXBNb2R1bGUgeyB9XG4iLCJleHBvcnQgY2xhc3MgVHlwZWFoZWFkT3B0aW9uRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb246IGFueSkge31cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQgfSBmcm9tICcuL3R5cGVhaGVhZC5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkS2V5U2VydmljZSB7XG5cbiAgICBoYW5kbGVLZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIHR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50KSB7XG4gICAgICAgIGlmICh0eXBlYWhlYWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVhaGVhZC5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQubW92ZUhpZ2hsaWdodCgtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlYWhlYWQub3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm1vdmVIaWdobGlnaHQoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFc2MnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVhaGVhZC5zZWxlY3RPbkVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQuc2VsZWN0SGlnaGxpZ2h0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkU2VydmljZSB7XHJcblxyXG4gICAgb3BlbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxIVE1MRWxlbWVudD4obnVsbCk7XHJcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcclxuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4vdHlwZWFoZWFkLWV2ZW50JztcclxuaW1wb3J0IHsgVHlwZWFoZWFkU2VydmljZSB9IGZyb20gJy4vdHlwZWFoZWFkLnNlcnZpY2UnO1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10eXBlYWhlYWQnLFxyXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidXgtdHlwZWFoZWFkLW9wdGlvbnNcIlxuICAgIFt1eEluZmluaXRlU2Nyb2xsXT1cImxvYWRPcHRpb25zQ2FsbGJhY2tcIlxuICAgIFtjb2xsZWN0aW9uXT1cInZpc2libGVPcHRpb25zJCB8IGFzeW5jXCJcbiAgICAoY29sbGVjdGlvbkNoYW5nZSk9XCJ2aXNpYmxlT3B0aW9ucyQubmV4dCgkZXZlbnQpXCJcbiAgICBbZW5hYmxlZF09XCJpc0luZmluaXRlU2Nyb2xsKClcIlxuICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICBbbG9hZE9uU2Nyb2xsXT1cInRydWVcIlxuICAgIFtwYWdlU2l6ZV09XCJwYWdlU2l6ZVwiXG4gICAgW3Njcm9sbEVsZW1lbnRdPVwidHlwZWFoZWFkRWxlbWVudFwiXG4gICAgKGxvYWRpbmcpPVwibG9hZGluZyA9IHRydWVcIlxuICAgIChsb2FkZWQpPVwibG9hZGluZyA9IGZhbHNlXCI+XG5cbiAgICA8b2wgKm5nSWY9XCIodmlzaWJsZU9wdGlvbnMkIHwgYXN5bmMpLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBvcHRpb24gb2YgKHZpc2libGVPcHRpb25zJCB8IGFzeW5jKTsgbGV0IGkgPSBpbmRleFwiXG4gICAgICAgICAgICBbYXR0ci5pZF09XCJpZCArICctb3B0aW9uLScgKyBpXCJcbiAgICAgICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJpc0Rpc2FibGVkKG9wdGlvbilcIlxuICAgICAgICAgICAgW2NsYXNzLmhpZ2hsaWdodGVkXT1cImhpZ2hsaWdodGVkS2V5ID09PSBvcHRpb24ua2V5XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwibXVsdGlzZWxlY3RhYmxlID8gaXNEaXNhYmxlZChvcHRpb24pIDogbnVsbFwiXG4gICAgICAgICAgICBbdXhUeXBlYWhlYWRIaWdobGlnaHRdPVwiaGlnaGxpZ2h0ZWRLZXkgPT09IG9wdGlvbi5rZXlcIlxuICAgICAgICAgICAgW3V4U2Nyb2xsSW50b1ZpZXdJZl09XCJoaWdobGlnaHRlZEtleSA9PT0gb3B0aW9uLmtleVwiXG4gICAgICAgICAgICBbc2Nyb2xsUGFyZW50XT1cInR5cGVhaGVhZEVsZW1lbnQubmF0aXZlRWxlbWVudFwiXG4gICAgICAgICAgICAobW91c2Vkb3duKT1cIm9wdGlvbk1vdXNlZG93bkhhbmRsZXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAoY2xpY2spPVwib3B0aW9uQ2xpY2tIYW5kbGVyKCRldmVudCwgb3B0aW9uKVwiXG4gICAgICAgICAgICAobW91c2VvdmVyKT1cImhpZ2hsaWdodChvcHRpb24pXCI+XG5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwib3B0aW9uVGVtcGxhdGUgfHwgZGVmYXVsdE9wdGlvblRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie29wdGlvbjogb3B0aW9uLnZhbHVlLCBhcGk6IG9wdGlvbkFwaX1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDwvbGk+XG4gICAgPC9vbD5cblxuICAgIDxkaXYgKnV4SW5maW5pdGVTY3JvbGxMb2FkaW5nPlxuICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxvYWRpbmdUZW1wbGF0ZSB8fCBkZWZhdWx0TG9hZGluZ1RlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2ICpuZ0lmPVwiaXNJbmZpbml0ZVNjcm9sbCgpID09PSBmYWxzZSAmJiAodmlzaWJsZU9wdGlvbnMkIHwgYXN5bmMpLmxlbmd0aCA9PT0gMCAmJiBsb2FkaW5nXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwibG9hZGluZ1RlbXBsYXRlIHx8IGRlZmF1bHRMb2FkaW5nVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG48ZGl2ICpuZ0lmPVwiKHZpc2libGVPcHRpb25zJCB8IGFzeW5jKS5sZW5ndGggPT09IDAgJiYgIWxvYWRpbmdcIj5cbiAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vT3B0aW9uc1RlbXBsYXRlIHx8IGRlZmF1bHROb09wdGlvbnNUZW1wbGF0ZVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdExvYWRpbmdUZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwidXgtdHlwZWFoZWFkLWxvYWRpbmdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNwaW5uZXIgc3Bpbm5lci1hY2NlbnQgc3Bpbm5lci1ib3VuY2UtbWlkZGxlXCI+PC9kaXY+XG4gICAgICAgIDxkaXY+TG9hZGluZy4uLjwvZGl2PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0T3B0aW9uVGVtcGxhdGUgbGV0LW9wdGlvbj1cIm9wdGlvblwiIGxldC1hcGk9XCJhcGlcIj5cbiAgICA8c3BhbiBjbGFzcz1cInV4LXR5cGVhaGVhZC1vcHRpb25cIiBbaW5uZXJIdG1sXT1cImFwaS5nZXREaXNwbGF5SHRtbChvcHRpb24pXCI+PC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0Tm9PcHRpb25zVGVtcGxhdGU+XG4gICAgPHNwYW4gY2xhc3M9XCJ1eC10eXBlYWhlYWQtbm8tb3B0aW9uc1wiPk5vIHJlc3VsdHM8L3NwYW4+XG48L25nLXRlbXBsYXRlPmAsXHJcbiAgICBwcm92aWRlcnM6IFtUeXBlYWhlYWRTZXJ2aWNlXSxcclxuICAgIGhvc3Q6IHtcclxuICAgICAgICAncm9sZSc6ICdsaXN0Ym94JyxcclxuICAgICAgICAnW2NsYXNzLm9wZW5dJzogJ29wZW4nLFxyXG4gICAgICAgICdbY2xhc3MuZHJvcC11cF0nOiAnZHJvcERpcmVjdGlvbiA9PT0gXCJ1cFwiJyxcclxuICAgICAgICAnW3N0eWxlLm1heEhlaWdodF0nOiAnbWF4SGVpZ2h0J1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xyXG5cclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGlkOiBzdHJpbmcgPSBgdXgtdHlwZWFoZWFkLSR7Kyt1bmlxdWVJZH1gO1xyXG5cclxuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueVtdIHwgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb247XHJcbiAgICBASW5wdXQoKSBmaWx0ZXI6IHN0cmluZztcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IG9wZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2Uub3BlbiQuZ2V0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fc2VydmljZS5vcGVuJC5uZXh0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBAT3V0cHV0KCkgb3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcclxuXHJcbiAgICBASW5wdXQoKSBkaXNwbGF5OiAob3B0aW9uOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGtleTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZE9wdGlvbnM6IGFueVtdO1xyXG4gICAgQElucHV0KCkgZHJvcERpcmVjdGlvbjogJ3VwJyB8ICdkb3duJyA9ICdkb3duJztcclxuICAgIEBJbnB1dCgpIG1heEhlaWdodDogc3RyaW5nID0gJzI1MHB4JztcclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW11bHRpc2VsZWN0YWJsZScpIG11bHRpc2VsZWN0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgb3Blbk9uRmlsdGVyQ2hhbmdlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIHBhZ2VTaXplOiBudW1iZXIgPSAyMDtcclxuICAgIEBJbnB1dCgpIHNlbGVjdEZpcnN0OiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIHNlbGVjdE9uRW50ZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIGxvYWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBASW5wdXQoKSBsb2FkaW5nVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBvcHRpb25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIG5vT3B0aW9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIEBPdXRwdXQoKSBvcHRpb25TZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VHlwZWFoZWFkT3B0aW9uRXZlbnQ+KCk7XHJcblxyXG4gICAgQE91dHB1dCgpIGhpZ2hsaWdodGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgaGlnaGxpZ2h0ZWRFbGVtZW50Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxIVE1MRWxlbWVudD4oKTtcclxuXHJcbiAgICBsb2FkT3B0aW9uc0NhbGxiYWNrOiBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcclxuICAgIHZpc2libGVPcHRpb25zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHlwZWFoZWFkVmlzaWJsZU9wdGlvbltdPihbXSk7XHJcbiAgICBjbGlja2luZyA9IGZhbHNlO1xyXG4gICAgaGlnaGxpZ2h0ZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUeXBlYWhlYWRWaXNpYmxlT3B0aW9uPihudWxsKTtcclxuICAgIGhpZ2hsaWdodGVkS2V5OiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIGdldCBoaWdobGlnaHRlZCgpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5oaWdobGlnaHRlZCQuZ2V0VmFsdWUoKTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS52YWx1ZSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBvcHRpb25BcGk6IFR5cGVhaGVhZE9wdGlvbkFwaSA9IHtcclxuICAgICAgICBnZXRLZXk6IHRoaXMuZ2V0S2V5LmJpbmQodGhpcyksXHJcbiAgICAgICAgZ2V0RGlzcGxheTogdGhpcy5nZXREaXNwbGF5LmJpbmQodGhpcyksXHJcbiAgICAgICAgZ2V0RGlzcGxheUh0bWw6IHRoaXMuZ2V0RGlzcGxheUh0bWwuYmluZCh0aGlzKVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwdWJsaWMgdHlwZWFoZWFkRWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICBwcml2YXRlIF9zZXJ2aWNlOiBUeXBlYWhlYWRTZXJ2aWNlXHJcbiAgICApIHtcclxuXHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9uc0NhbGxiYWNrID0gKHBhZ2VOdW06IG51bWJlciwgcGFnZVNpemU6IG51bWJlciwgZmlsdGVyOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIHdoaWNoIG1heSByZXR1cm4gYW4gYXJyYXkgb3IgYSBwcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlPclByb21pc2UgPSB0aGlzLm9wdGlvbnMocGFnZU51bSwgcGFnZVNpemUsIGZpbHRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFwIHRoZSByZXN1bHRzIHRvIGFuIGFycmF5IG9mIFR5cGVhaGVhZFZpc2libGVPcHRpb24uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFycmF5T3JQcm9taXNlKS50aGVuKG5ld09wdGlvbnMgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3T3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3T3B0aW9ucy5tYXAoKG9wdGlvbjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmdldEtleShvcHRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl9zZXJ2aWNlLm9wZW4kLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgobmV4dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5DaGFuZ2UuZW1pdChuZXh0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKChuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRLZXkgPSBuZXh0ID8gbmV4dC5rZXkgOiBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkQ2hhbmdlLmVtaXQobmV4dCA/IG5leHQudmFsdWUgOiBudWxsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29tYmluZUxhdGVzdCh0aGlzLl9zZXJ2aWNlLm9wZW4kLCB0aGlzLl9zZXJ2aWNlLmhpZ2hsaWdodGVkRWxlbWVudCQsIHRoaXMudmlzaWJsZU9wdGlvbnMkKVxyXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcclxuICAgICAgICAgICAgLnN1YnNjcmliZSgoW29wZW4sIGhpZ2hsaWdodGVkRWxlbWVudCwgdmlzaWJsZU9wdGlvbnNdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkRWxlbWVudENoYW5nZS5lbWl0KG9wZW4gJiYgdmlzaWJsZU9wdGlvbnMubGVuZ3RoID4gMCA/IGhpZ2hsaWdodGVkRWxlbWVudCA6IG51bGwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgLy8gT3BlbiB0aGUgZHJvcGRvd24gaWYgdGhlIGZpbHRlciB2YWx1ZSB1cGRhdGVzXHJcbiAgICAgICAgaWYgKGNoYW5nZXMuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5PbkZpbHRlckNoYW5nZSAmJiBjaGFuZ2VzLmZpbHRlci5jdXJyZW50VmFsdWUgJiYgY2hhbmdlcy5maWx0ZXIuY3VycmVudFZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlLWZpbHRlciB2aXNpYmxlT3B0aW9uc1xyXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJylcclxuICAgIG1vdXNlZG93bkhhbmRsZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jbGlja2luZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2V1cCcpXHJcbiAgICBtb3VzZXVwSGFuZGxlcigpIHtcclxuICAgICAgICB0aGlzLmNsaWNraW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9uTW91c2Vkb3duSGFuZGxlcihldmVudDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIC8vIFdvcmthcm91bmQgdG8gcHJldmVudCBmb2N1cyBjaGFuZ2luZyB3aGVuIGFuIG9wdGlvbiBpcyBjbGlja2VkXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25DbGlja0hhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQsIG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbikge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0KG9wdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUga2V5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldEtleShvcHRpb246IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleSA9PT0gJ3N0cmluZycgJiYgb3B0aW9uICYmIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSh0aGlzLmtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbls8c3RyaW5nPnRoaXMua2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheShvcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5KG9wdGlvbjogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5KG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnc3RyaW5nJyAmJiBvcHRpb24gJiYgb3B0aW9uLmhhc093blByb3BlcnR5KHRoaXMuZGlzcGxheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbls8c3RyaW5nPnRoaXMuZGlzcGxheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24gd2l0aCBIVE1MIG1hcmt1cCBhZGRlZCB0byBoaWdobGlnaHQgdGhlIHBhcnQgd2hpY2ggbWF0Y2hlcyB0aGUgY3VycmVudCBmaWx0ZXIgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldERpc3BsYXlIdG1sKG9wdGlvbjogYW55KSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxheVRleHQgPSB0aGlzLmdldERpc3BsYXkob3B0aW9uKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XHJcbiAgICAgICAgbGV0IGRpc3BsYXlIdG1sID0gZGlzcGxheVRleHQ7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZmlsdGVyLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IGRpc3BsYXlUZXh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlci50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IGA8c3BhbiBjbGFzcz1cInV4LWZpbHRlci1tYXRjaFwiPiR7ZGlzcGxheVRleHQuc3Vic3RyKG1hdGNoSW5kZXgsIGxlbmd0aCl9PC9zcGFuPmA7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5SHRtbCA9IGRpc3BsYXlUZXh0LnN1YnN0cigwLCBtYXRjaEluZGV4KSArIGhpZ2hsaWdodCArIGRpc3BsYXlUZXh0LnN1YnN0cihtYXRjaEluZGV4ICsgbGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzcGxheUh0bWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGluZmluaXRlIHNjcm9sbCBjb21wb25lbnQgc2hvdWxkIGxvYWRcclxuICAgICAqL1xyXG4gICAgaXNJbmZpbml0ZVNjcm9sbCgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIG9wdGlvbiwgZW1pdHRpbmcgdGhlIG9wdGlvblNlbGVjdGVkIGV2ZW50IGFuZCBjbG9zaW5nIHRoZSBkcm9wZG93bi5cclxuICAgICAqL1xyXG4gICAgc2VsZWN0KG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKG9wdGlvbikpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25TZWxlY3RlZC5lbWl0KG5ldyBUeXBlYWhlYWRPcHRpb25FdmVudChvcHRpb24udmFsdWUpKTtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dChudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvcHRpb24gaXMgcGFydCBvZiB0aGUgZGlzYWJsZWRPcHRpb25zIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBpc0Rpc2FibGVkKG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRpc2FibGVkT3B0aW9ucy5maW5kKChzZWxlY3RlZE9wdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KHNlbGVjdGVkT3B0aW9uKSA9PT0gb3B0aW9uLmtleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBnaXZlbiBvcHRpb24gYXMgdGhlIGN1cnJlbnQgaGlnaGxpZ2h0ZWQgb3B0aW9uLCBhdmFpbGFibGUgaW4gdGhlIGhpZ2hsaWdodGVkT3B0aW9uIHBhcmFtZXRlci5cclxuICAgICAqL1xyXG4gICAgaGlnaGxpZ2h0KG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKG9wdGlvbikpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dChvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluY3JlbWVudCBvciBkZWNyZW1lbnQgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbiBpbiB0aGUgbGlzdC4gRGlzYWJsZWQgb3B0aW9ucyBhcmUgc2tpcHBlZC5cclxuICAgICAqIEBwYXJhbSBkIFZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoZSBpbmRleCBvZiB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uLCBpLmUuIC0xIHRvIG1vdmUgYmFja3dhcmRzLCArMSB0byBtb3ZlIGZvcndhcmRzLlxyXG4gICAgICovXHJcbiAgICBtb3ZlSGlnaGxpZ2h0KGQ6IG51bWJlcik6IGFueSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU9wdGlvbnMgPSB0aGlzLnZpc2libGVPcHRpb25zJC5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodEluZGV4ID0gdGhpcy5pbmRleE9mVmlzaWJsZU9wdGlvbih0aGlzLmhpZ2hsaWdodGVkKTtcclxuICAgICAgICBsZXQgbmV3SW5kZXggPSBoaWdobGlnaHRJbmRleDtcclxuICAgICAgICBsZXQgZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCBpbkJvdW5kcyA9IHRydWU7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgZDtcclxuICAgICAgICAgICAgaW5Cb3VuZHMgPSAobmV3SW5kZXggPj0gMCAmJiBuZXdJbmRleCA8IHZpc2libGVPcHRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGRpc2FibGVkID0gaW5Cb3VuZHMgJiYgdGhpcy5pc0Rpc2FibGVkKHZpc2libGVPcHRpb25zW25ld0luZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpbkJvdW5kcyAmJiBkaXNhYmxlZCk7XHJcblxyXG4gICAgICAgIGlmICghZGlzYWJsZWQgJiYgaW5Cb3VuZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dCh2aXNpYmxlT3B0aW9uc1tuZXdJbmRleF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0SGlnaGxpZ2h0ZWQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoeyB2YWx1ZTogdGhpcy5oaWdobGlnaHRlZCwga2V5OiB0aGlzLmdldEtleSh0aGlzLmhpZ2hsaWdodGVkKX0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB1cCB0aGUgb3B0aW9ucyBiZWZvcmUgdGhlIGRyb3Bkb3duIGlzIGRpc3BsYXllZC5cclxuICAgICAqL1xyXG4gICAgaW5pdE9wdGlvbnMoKSB7XHJcbiAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgaGlnaGxpZ2h0XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dChudWxsKTtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RGaXJzdCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgaGlnaGxpZ2h0IHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLlxyXG4gICAgICAgICAgICB0aGlzLm1vdmVIaWdobGlnaHQoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSB2aXNpYmxlT3B0aW9ucyBhcnJheSB3aXRoIHRoZSBjdXJyZW50IGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlT3B0aW9ucygpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXNlZElucHV0ID0gKHRoaXMuZmlsdGVyIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlT3B0aW9ucyA9IHRoaXMub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheShvcHRpb24pLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihub3JtYWxpc2VkSW5wdXQpID49IDA7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm1hcCgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5nZXRLZXkodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2libGVPcHRpb25zJC5uZXh0KHZpc2libGVPcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdE9wdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIG9wdGlvbiBpbiB0aGUgdmlzaWJsZU9wdGlvbnMgYXJyYXkuIFJldHVybnMgLTEgaWYgdGhlIG9wdGlvbiBpcyBub3QgY3VycmVudGx5IHZpc2libGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaW5kZXhPZlZpc2libGVPcHRpb24ob3B0aW9uOiBhbnkpOiBudW1iZXIge1xyXG4gICAgICAgIGlmIChvcHRpb24pIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uS2V5ID0gdGhpcy5nZXRLZXkob3B0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZU9wdGlvbnMkLmdldFZhbHVlKCkuZmluZEluZGV4KChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmtleSA9PT0gb3B0aW9uS2V5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBBUEkgYXZhaWxhYmxlIHRvIG9wdGlvbiB0ZW1wbGF0ZXMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVhaGVhZE9wdGlvbkFwaSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUga2V5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldEtleShvcHRpb246IGFueSk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheShvcHRpb246IGFueSk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbiB3aXRoIEhUTUwgbWFya3VwIGFkZGVkIHRvIGhpZ2hsaWdodCB0aGUgcGFydCB3aGljaCBtYXRjaGVzIHRoZSBjdXJyZW50IGZpbHRlciB2YWx1ZS4gT3ZlcnJpZGUgdGhlIHV4LWZpbHRlci1tYXRjaCBjbGFzcyBpbiBDU1MgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGFwcGVhcmFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldERpc3BsYXlIdG1sKG9wdGlvbjogYW55KTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVhaGVhZFZpc2libGVPcHRpb24ge1xyXG4gICAgdmFsdWU6IGFueTtcclxuICAgIGtleTogc3RyaW5nO1xyXG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT3V0cHV0LCBSZW5kZXJlcjIsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbl0nXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoJ3V4SW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uJylcbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfVxuICAgIHNldCB2aXNpYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGVtcGxhdGUgY29udGVudCBmb2xsb3dzIHRoZSBlbGVtZW50UmVmLCB3aGljaCBpcyBhIGNvbW1lbnQuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpY2tUYXJnZXQgPSB0aGlzLmdldE5leHRFbGVtZW50U2libGluZyh0aGlzLl90ZW1wbGF0ZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmxpc3RlbihjbGlja1RhcmdldCwgJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIGxvYWQ6IE9ic2VydmFibGU8RXZlbnQ+O1xuXG4gICAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2xvYWQgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX3RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7XG5cbiAgICAgICAgdGhpcy5sb2FkID0gdGhpcy5fbG9hZC5hc09ic2VydmFibGUoKSBhcyBPYnNlcnZhYmxlPEV2ZW50PjtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbG9hZC5uZXh0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE5leHRFbGVtZW50U2libGluZyhlbGVtZW50OiBhbnkpOiBFbGVtZW50IHtcbiAgICAgICAgdmFyIG5leHQgPSBlbGVtZW50O1xuICAgICAgICB3aGlsZSAobmV4dCA9IG5leHQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJbmZpbml0ZVNjcm9sbExvYWRpbmddJ1xufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCd1eEluZmluaXRlU2Nyb2xsTG9hZGluZycpXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgICBzZXQgdmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlUmVmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmKSB7IH1cbn1cbiIsIlxuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IGF1ZGl0VGltZSwgY29tYmluZUxhdGVzdCwgZmlsdGVyIGFzIGZpbHRlck9wZXJhdG9yLCBmaXJzdCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1sb2FkLWJ1dHRvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEluZmluaXRlU2Nyb2xsXScsXG4gICAgZXhwb3J0QXM6ICd1eEluZmluaXRlU2Nyb2xsJ1xufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCd1eEluZmluaXRlU2Nyb2xsJykgbG9hZDogSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb247XG5cbiAgICBASW5wdXQoJ2NvbGxlY3Rpb24nKSBfY29sbGVjdGlvbjogYW55W10gPSBbXTtcbiAgICBnZXQgY29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247XG4gICAgfVxuICAgIHNldCBjb2xsZWN0aW9uKHZhbHVlOiBhbnlbXSkge1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSB2YWx1ZTtcbiAgICB9XG5cblxuICAgIEBJbnB1dCgpIHNldCBzY3JvbGxFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnRSZWYgfCBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnRSZWYgPyBlbGVtZW50IDogbmV3IEVsZW1lbnRSZWYoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgQElucHV0KCkgZW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZmlsdGVyOiBhbnk7XG4gICAgQElucHV0KCkgbG9hZE9uSW5pdDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgbG9hZE9uU2Nyb2xsOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBwYWdlU2l6ZTogbnVtYmVyID0gMjA7XG5cbiAgICBAT3V0cHV0KCkgY29sbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XG5cbiAgICBAT3V0cHV0KCdsb2FkaW5nJylcbiAgICBsb2FkaW5nRXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPEluZmluaXRlU2Nyb2xsTG9hZGluZ0V2ZW50PigpO1xuXG4gICAgQE91dHB1dCgnbG9hZGVkJylcbiAgICBsb2FkZWRFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8SW5maW5pdGVTY3JvbGxMb2FkZWRFdmVudD4oKTtcblxuICAgIEBPdXRwdXQoJ2xvYWRFcnJvcicpXG4gICAgbG9hZEVycm9yRXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPEluZmluaXRlU2Nyb2xsTG9hZEVycm9yRXZlbnQ+KCk7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSlcbiAgICBwcml2YXRlIF9sb2FkQnV0dG9uUXVlcnk6IFF1ZXJ5TGlzdDxJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmU+O1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmUpXG4gICAgcHJpdmF0ZSBfbG9hZGluZ0luZGljYXRvclF1ZXJ5OiBRdWVyeUxpc3Q8SW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlPjtcblxuICAgIHByaXZhdGUgX3BhZ2VzOiBhbnlbXVtdO1xuICAgIHByaXZhdGUgX25leHRQYWdlTnVtID0gMDtcbiAgICBwcml2YXRlIF9kb21PYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlcjtcbiAgICBwcml2YXRlIF9zY3JvbGxFdmVudFN1YjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX3VwZGF0ZVJlcXVlc3RzID0gbmV3IFN1YmplY3Q8SW5maW5pdGVTY3JvbGxSZXF1ZXN0PigpO1xuXG4gICAgcHJpdmF0ZSBfaXNMb2FkaW5nID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcHJpdmF0ZSBfaXNFeGhhdXN0ZWQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBwcml2YXRlIF9sb2FkQnV0dG9uRW5hYmxlZCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHByaXZhdGUgX2NhbkxvYWRNYW51YWxseTogT2JzZXJ2YWJsZTxib29sZWFuPjtcblxuICAgIHByaXZhdGUgX3Njcm9sbEVsZW1lbnQ6IEVsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgICBwcml2YXRlIF9sb2FkQnV0dG9uU3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9jYW5Mb2FkTWFudWFsbHkgPSB0aGlzLl9pc0xvYWRpbmcucGlwZShjb21iaW5lTGF0ZXN0KFxuICAgICAgICAgICAgdGhpcy5faXNFeGhhdXN0ZWQsXG4gICAgICAgICAgICB0aGlzLl9sb2FkQnV0dG9uRW5hYmxlZCxcbiAgICAgICAgICAgIChpc0xvYWRpbmcsIGlzRXhoYXVzdGVkLCBsb2FkQnV0dG9uRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNMb2FkaW5nICYmICFpc0V4aGF1c3RlZCAmJiBsb2FkQnV0dG9uRW5hYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb2FkQnV0dG9uRW5hYmxlZC5uZXh0KCF0aGlzLmxvYWRPblNjcm9sbCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuXG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28ga2luZHMgb2YgdXBkYXRlIHJlcXVlc3RzOiBjaGVjayBhbmQgbG9hZC5cbiAgICAgICAgLy8gQ2hlY2sgcmVxdWVzdHMgYXJlIHRocm90dGxlZCBhbmQgd2lsbCBvbmx5IGNhdXNlIGFuIHVwZGF0ZSBpZiBtb3JlIGRhdGEgaXMgcmVxdWlyZWRcbiAgICAgICAgLy8gdG8gZmlsbCB0aGUgc2Nyb2xsaW5nIHZpZXcsIGFuZCBpdCBpc24ndCBhbHJlYWR5IGxvYWRpbmcgc29tZS5cbiAgICAgICAgLy8gTG9hZCByZXF1ZXN0cyBhcmUgbm90IHRocm90dGxlZCBhbmQgYWx3YXlzIHJlcXVlc3QgYSBwYWdlIG9mIGRhdGEuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLnBpcGUoZmlsdGVyT3BlcmF0b3IocmVxdWVzdCA9PiByZXF1ZXN0LmNoZWNrKSwgYXVkaXRUaW1lKDIwMCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5kb1JlcXVlc3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLnBpcGUoZmlsdGVyT3BlcmF0b3IocmVxdWVzdCA9PiAhcmVxdWVzdC5jaGVjayksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5kb1JlcXVlc3QuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHNjcm9sbCBldmVudHMgYW5kIERPTSBjaGFuZ2VzLlxuICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25uZWN0IHRoZSBMb2FkIE1vcmUgYnV0dG9uIHZpc2libGUgc3RhdGUuXG4gICAgICAgIHRoaXMuX2NhbkxvYWRNYW51YWxseS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoY2FuTG9hZCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkQnV0dG9uUXVlcnkuZm9yRWFjaChsb2FkQnV0dG9uID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkQnV0dG9uLnZpc2libGUgPSBjYW5Mb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIHZpc2libGUgc3RhdGUuXG4gICAgICAgIHRoaXMuX2lzTG9hZGluZy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoaXNMb2FkaW5nID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdJbmRpY2F0b3JRdWVyeS5mb3JFYWNoKGxvYWRpbmcgPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcudmlzaWJsZSA9IGlzTG9hZGluZztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaW5rIHRoZSBMb2FkIE1vcmUgYnV0dG9uIGNsaWNrIGV2ZW50IHRvIHRyaWdnZXIgYW4gdXBkYXRlLlxuICAgICAgICB0aGlzLmF0dGFjaExvYWRCdXR0b25FdmVudHMoKTtcbiAgICAgICAgdGhpcy5fbG9hZEJ1dHRvblF1ZXJ5LmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoTG9hZEJ1dHRvbkV2ZW50cygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0aWFsIHVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMubG9hZE9uSW5pdCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGNoZWNrID0gdHJ1ZTtcblxuICAgICAgICBpZiAoY2hhbmdlcy5lbmFibGVkICYmIGNoYW5nZXMuZW5hYmxlZC5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMuZW5hYmxlZC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5lbmFibGVkLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmZpbHRlciAmJiBjaGFuZ2VzLmZpbHRlci5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMuZmlsdGVyLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZXMubG9hZE9uU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEJ1dHRvbkVuYWJsZWQubmV4dChcbiAgICAgICAgICAgICAgICAgICAgIWNoYW5nZXMubG9hZE9uU2Nyb2xsLmN1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLnBhZ2VTaXplICYmIGNoYW5nZXMucGFnZVNpemUuY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLnBhZ2VTaXplLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVxdWVzdHMubmV4dCh7XG4gICAgICAgICAgICAgICAgY2hlY2s6IGNoZWNrLFxuICAgICAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHRoaXMuX25leHRQYWdlTnVtLFxuICAgICAgICAgICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGFuIGFkZGl0aW9uYWwgcGFnZSBvZiBkYXRhLlxuICAgICAqL1xuICAgIGxvYWROZXh0UGFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgY2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5fbmV4dFBhZ2VOdW0sXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhIGNoZWNrIGZvciB3aGV0aGVyIGFuIGFkZGl0aW9uYWwgcGFnZSBvZiBkYXRhIGlzIHJlcXVpcmVkLiBUaGlzIGlzIHRocm90dGxlZC5cbiAgICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgY2hlY2s6IHRydWUsXG4gICAgICAgICAgICBwYWdlTnVtYmVyOiB0aGlzLl9uZXh0UGFnZU51bSxcbiAgICAgICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlclxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY29sbGVjdGlvbi4gRnV0dXJlIHJlcXVlc3RzIHdpbGwgbG9hZCBmcm9tIHBhZ2UgMC5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwYWdlIGNvdW50ZXIuXG4gICAgICAgIHRoaXMuX25leHRQYWdlTnVtID0gMDtcblxuICAgICAgICB0aGlzLl9wYWdlcyA9IFtdO1xuXG4gICAgICAgIC8vIENsZWFyIHRoZSBjb2xsZWN0aW9uICh3aXRob3V0IGNoYW5naW5nIHRoZSByZWZlcmVuY2UpLlxuICAgICAgICBpZiAodGhpcy5jb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBleGhhdXN0ZWQgZmxhZywgYWxsb3dpbmcgdGhlIExvYWQgTW9yZSBidXR0b24gdG8gYXBwZWFyLlxuICAgICAgICB0aGlzLl9pc0V4aGF1c3RlZC5uZXh0KGZhbHNlKTtcblxuICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaChyZXF1ZXN0ID0+IHJlcXVlc3QudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxvYWQgdGhlIGRhdGEgd2l0aG91dCBjbGVhcmluZyB0aGUgdmlldy5cbiAgICAgKi9cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VzLmZvckVhY2goKHBhZ2UsIGkpID0+IHRoaXMucmVsb2FkUGFnZShpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsb2FkIHRoZSBkYXRhIGluIGEgc3BlY2lmaWMgcGFnZSB3aXRob3V0IGNsZWFyaW5nIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSBwYWdlTnVtIFBhZ2UgbnVtYmVyXG4gICAgICovXG4gICAgcmVsb2FkUGFnZShwYWdlTnVtOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgY2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bSxcbiAgICAgICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgICAgICAgIHJlbG9hZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggc2Nyb2xsIGV2ZW50IGhhbmRsZXIgYW5kIERPTSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGF0dGFjaEV2ZW50SGFuZGxlcnMoKSB7XG5cbiAgICAgICAgLy8gaWYgdGhlIHNjcm9sbEVsZW1lbnQgaXMgZG9jdW1lbnRFbGVtZW50IHdlIG11c3Qgd2F0Y2ggZm9yIGEgc2Nyb2xsIGV2ZW50IG9uIHRoZSBkb2N1bWVudFxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9zY3JvbGxFbGVtZW50Lm5hdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSHRtbEVsZW1lbnQgPyBkb2N1bWVudCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQubmF0aXZlRWxlbWVudDtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHNjcm9sbCBldmVudCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgIHRoaXMuX3Njcm9sbEV2ZW50U3ViID0gZnJvbUV2ZW50KHRhcmdldCwgJ3Njcm9sbCcpLnN1YnNjcmliZSh0aGlzLmNoZWNrLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGlsZCBET00gY2hhbmdlcy4gVGhlIG1haW4gZWZmZWN0IG9mIHRoaXMgaXMgdG8gY2hlY2sgd2hldGhlciBldmVuIG1vcmUgZGF0YSBpc1xuICAgICAgICAvLyByZXF1aXJlZCBhZnRlciB0aGUgaW5pdGlhbCBsb2FkLlxuICAgICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuY2hlY2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RvbU9ic2VydmVyLm9ic2VydmUodGhpcy5fc2Nyb2xsRWxlbWVudC5uYXRpdmVFbGVtZW50LCB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGFjaCBzY3JvbGwgZXZlbnQgaGFuZGxlciBhbmQgRE9NIG9ic2VydmVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgZGV0YWNoRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEV2ZW50U3ViKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFdmVudFN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRTdWIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2RvbU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW55IGV4aXN0aW5nIGV2ZW50IHN1YnNjcmlwdGlvbnMgZm9yIHRoZSBsb2FkIGJ1dHRvbiBgbG9hZGAgZXZlbnQsIHRoZW4gYXR0YWNoIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBmb3IgYW55IGluIHRoZSBxdWVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGF0dGFjaExvYWRCdXR0b25FdmVudHMoKSB7XG4gICAgICAgIHRoaXMuX2xvYWRCdXR0b25TdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLl9sb2FkQnV0dG9uU3Vic2NyaXB0aW9ucyA9IHRoaXMuX2xvYWRCdXR0b25RdWVyeS5tYXAoXG4gICAgICAgICAgICBsb2FkQnV0dG9uID0+IGxvYWRCdXR0b24ubG9hZC5zdWJzY3JpYmUodGhpcy5sb2FkTmV4dFBhZ2UuYmluZCh0aGlzKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25kaXRpb25hbGx5IGxvYWRzIGEgcGFnZSBpbnRvIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIGRpcmVjdGl2ZSBzdGF0ZSBhbmQgcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHByaXZhdGUgZG9SZXF1ZXN0KHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCkge1xuXG4gICAgICAgIC8vIExvYWQgYSBuZXcgcGFnZSBpZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGJleW9uZCB0aGUgdGhyZXNoaG9sZCBhbmQgaWYgdGhlIGNsaWVudCBjb2RlIGRpZCBub3RcbiAgICAgICAgLy8gY2FuY2VsLlxuICAgICAgICBpZiAodGhpcy5uZWVkc0RhdGEocmVxdWVzdCkgJiYgdGhpcy5iZWdpbkxvYWRpbmcocmVxdWVzdCkpIHtcblxuICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBsb2FkIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIGEgcHJvbW9zZSBvciBwbGFpbiBkYXRhLlxuICAgICAgICAgICAgY29uc3QgbG9hZFJlc3VsdCA9IHRoaXMubG9hZChyZXF1ZXN0LnBhZ2VOdW1iZXIsIHJlcXVlc3QucGFnZVNpemUsIHJlcXVlc3QuZmlsdGVyKTtcblxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZSA9IEFycmF5LmlzQXJyYXkobG9hZFJlc3VsdCkgPyBvZihsb2FkUmVzdWx0KSA6IGZyb208YW55W10+KGxvYWRSZXN1bHQpO1xuXG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBhcmFtZXRlcnMgaGF2ZSBub3QgY2hhbmdlZCBzaW5jZSB0aGUgbG9hZCBzdGFydGVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgZGlzY2FyZCB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuZmlsdGVyID09PSB0aGlzLmZpbHRlciAmJiByZXF1ZXN0LnBhZ2VTaXplID09PSB0aGlzLnBhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYWdlSXRlbXMocmVxdWVzdC5wYWdlTnVtYmVyLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGxvYWRlZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRMb2FkaW5nKHJlcXVlc3QsIGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgbG9hZEVycm9yIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kTG9hZGluZ1dpdGhFcnJvcihyZXF1ZXN0LCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhpcyByZXF1ZXN0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZmlsdGVyKHMgPT4gcyAhPT0gc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHN1YnNjcmlwdGlvbiB0byB0aGUgbGlzdCBvZiByZXF1ZXN0c1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIGZ1bGZpbGxlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIG5lZWRzRGF0YShyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsd2F5cyBsb2FkIGZvciBhIGxvYWQgcmVxdWVzdFxuICAgICAgICBpZiAoIXJlcXVlc3QuY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWdub3JlIGEgY2hlY2sgcmVxdWVzdCB3aGVuIHRoZSBlbmQgb2YgZGF0YSBoYXMgYmVlbiBkZXRlY3RlZCwgb3IgaWYgZGF0YSBpcyBjdXJyZW50bHkgbG9hZGluZy5cbiAgICAgICAgaWYgKHRoaXMuX2lzRXhoYXVzdGVkLmdldFZhbHVlKCkgfHwgdGhpcy5faXNMb2FkaW5nLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvYWQgaWYgdGhlIHJlbWFpbmluZyBzY3JvbGwgYXJlYSBpcyA8PSB0aGUgZWxlbWVudCBoZWlnaHQuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxFbGVtZW50ICYmIHRoaXMubG9hZE9uU2Nyb2xsKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+dGhpcy5fc2Nyb2xsRWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID1cbiAgICAgICAgICAgICAgICBlbGVtZW50LnNjcm9sbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQuc2Nyb2xsVG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nU2Nyb2xsIDw9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3RhdGUgZm9yIHRoZSBiZWdpbm5pbmcgb2YgYSBsb2FkLiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBgbG9hZGluZ2AgZXZlbnQgd2FzIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGJlZ2luTG9hZGluZyhyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QpOiBib29sZWFuIHtcblxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBJbmZpbml0ZVNjcm9sbExvYWRpbmdFdmVudChcbiAgICAgICAgICAgIHJlcXVlc3QucGFnZU51bWJlcixcbiAgICAgICAgICAgIHJlcXVlc3QucGFnZVNpemUsXG4gICAgICAgICAgICByZXF1ZXN0LmZpbHRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLmxvYWRpbmdFdmVudC5lbWl0KGV2ZW50KTtcblxuICAgICAgICB0aGlzLl9pc0xvYWRpbmcubmV4dCghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCgpKTtcblxuICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBhZ2VJdGVtcyhwYWdlTnVtOiBudW1iZXIsIGl0ZW1zOiBhbnlbXSkge1xuICAgICAgICB0aGlzLl9wYWdlc1twYWdlTnVtXSA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSB0aGlzLl9wYWdlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBwcmV2aW91cy5jb25jYXQoY3VycmVudCksIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHN0YXRlIGZyb20gYSBzdWNjZXNzZnVsIGxvYWQuIFJhaXNlcyB0aGUgYGxvYWRlZGAgZXZlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBlbmRMb2FkaW5nKHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCwgZGF0YT86IGFueSkge1xuICAgICAgICB0aGlzLl9pc0xvYWRpbmcubmV4dChmYWxzZSk7XG5cbiAgICAgICAgY29uc3QgaXNFeGhhdXN0ZWQgPSAhIShkYXRhICYmIGRhdGEubGVuZ3RoIDwgdGhpcy5wYWdlU2l6ZSk7XG4gICAgICAgIHRoaXMuX2lzRXhoYXVzdGVkLm5leHQoaXNFeGhhdXN0ZWQpO1xuXG4gICAgICAgIHRoaXMubG9hZGVkRXZlbnQuZW1pdChcbiAgICAgICAgICAgIG5ldyBJbmZpbml0ZVNjcm9sbExvYWRlZEV2ZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFnZU51bWJlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZmlsdGVyLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgaXNFeGhhdXN0ZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlcXVlc3QucmVsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0UGFnZU51bSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzdGF0ZSBmcm9tIGEgZmFpbGVkIGxvYWQuIFJhaXNlcyB0aGUgYGxvYWRFcnJvcmAgZXZlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBlbmRMb2FkaW5nV2l0aEVycm9yKHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCwgZXJyb3I6IGFueSkge1xuICAgICAgICB0aGlzLl9pc0xvYWRpbmcubmV4dChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5sb2FkRXJyb3JFdmVudC5lbWl0KFxuICAgICAgICAgICAgbmV3IEluZmluaXRlU2Nyb2xsTG9hZEVycm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYWdlTnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFnZVNpemUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIGludGVybmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgbG9hZC9jaGVjayByZXF1ZXN0LlxuICovXG5jbGFzcyBJbmZpbml0ZVNjcm9sbFJlcXVlc3Qge1xuICAgIGNoZWNrOiBib29sZWFuO1xuICAgIHBhZ2VOdW1iZXI6IG51bWJlcjtcbiAgICBwYWdlU2l6ZTogbnVtYmVyO1xuICAgIGZpbHRlcjogYW55O1xuICAgIHJlbG9hZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uID0gKFxuICAgIHBhZ2VOdW06IG51bWJlcixcbiAgICBwYWdlU2l6ZTogbnVtYmVyLFxuICAgIGZpbHRlcjogYW55XG4pID0+IGFueSB8IFByb21pc2U8YW55PjtcblxuLyoqXG4gKiBFdmVudCByYWlzZWQgYmVmb3JlIHRoZSBgbG9hZGluZ2AgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICovXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkaW5nRXZlbnQge1xuICAgIHByaXZhdGUgX2RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSByZXF1ZXN0ZWQgcGFnZSwgc3RhcnRpbmcgZnJvbSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VOdW1iZXI6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmlsdGVyIGRldGFpbHMgYXMgcHJvdmlkZWQgdmlhIHRoZSBgZmlsdGVyYCBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGZpbHRlcjogYW55XG4gICAgKSB7IH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGUgYGxvYWRpbmdgIGV2ZW50IChsb2FkaW5nIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZCkuXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGRlZmF1bHRQcmV2ZW50ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFdmVudCByYWlzZWQgd2hlbiB0aGUgbG9hZGluZyBmdW5jdGlvbiByZXN1bHQgaGFzIGJlZW4gcmVzb2x2ZWQgYW5kIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkZWRFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHJlcXVlc3RlZCBwYWdlLCBzdGFydGluZyBmcm9tIDAuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZU51bWJlcjogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVtcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZVNpemU6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWx0ZXIgZGV0YWlscyBhcyBwcm92aWRlZCB2aWEgdGhlIGBmaWx0ZXJgIGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZmlsdGVyOiBhbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGZyb20gdGhlIGxvYWRpbmcgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZGF0YTogYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpZiB0aGUgZGF0YSBpcyBjb25zaWRlcmVkIGV4aGF1c3RlZCAobnVtYmVyIG9mIGl0ZW1zIHJldHVybmVkIGxlc3MgdGhhbiBgcGFnZVNpemVgKS5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBleGhhdXN0ZWQ6IGJvb2xlYW5cbiAgICApIHsgfVxufVxuXG4vKipcbiAqIEV2ZW50IHJhaXNlZCBpZiB0aGUgbG9hZGluZyBmdW5jdGlvbiByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZEVycm9yRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSByZXF1ZXN0ZWQgcGFnZSwgc3RhcnRpbmcgZnJvbSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VOdW1iZXI6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmlsdGVyIGRldGFpbHMgYXMgcHJvdmlkZWQgdmlhIHRoZSBgZmlsdGVyYCBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGZpbHRlcjogYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9iamVjdCBwcm92aWRlZCB3aGVuIHJlamVjdGluZyB0aGUgcHJvbWlzZS5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBlcnJvcjogYW55XG4gICAgKSB7IH1cbn1cbiIsImltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1sb2FkaW5nLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNjcm9sbEludG9WaWV3U2VydmljZSB7XG5cbiAgICBzY3JvbGxJbnRvVmlldyhlbGVtOiBIVE1MRWxlbWVudCwgc2Nyb2xsUGFyZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBjb25zdCBvZmZzZXRUb3AgPSAoZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSAtIHNjcm9sbFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgIGlmIChvZmZzZXRUb3AgPCBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gb2Zmc2V0VG9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0VG9wICsgZWxlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAob2Zmc2V0Qm90dG9tID4gKHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgKyBzY3JvbGxQYXJlbnQuY2xpZW50SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBvZmZzZXRCb3R0b20gLSBzY3JvbGxQYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2Nyb2xsSW50b1ZpZXdTZXJ2aWNlIH0gZnJvbSAnLi9zY3JvbGwtaW50by12aWV3LnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFNjcm9sbEludG9WaWV3SWZdJyxcbiAgICBwcm92aWRlcnM6IFtTY3JvbGxJbnRvVmlld1NlcnZpY2VdXG4gfSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxJbnRvVmlld0lmRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICAgIEBJbnB1dCgndXhTY3JvbGxJbnRvVmlld0lmJykgY29uZGl0aW9uID0gZmFsc2U7XG4gICAgQElucHV0KCkgc2Nyb2xsUGFyZW50OiBIVE1MRWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3Njcm9sbEludG9WaWV3U2VydmljZTogU2Nyb2xsSW50b1ZpZXdTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zY3JvbGxJbnRvVmlld1NlcnZpY2Uuc2Nyb2xsSW50b1ZpZXcodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCB0aGlzLnNjcm9sbFBhcmVudCkpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhTY3JvbGxJbnRvVmlld10nXG59KVxuZXhwb3J0IGNsYXNzIFNjcm9sbEludG9WaWV3RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvKiogQWxsb3cgYSBjb25kaXRpb24gYXJvdW5kIHdoZXRoZXIgb3Igbm90IHRoaXMgc2hvdWxkIHNjcm9sbCBpbnRvIHZpZXcgKi9cbiAgICBASW5wdXQoKSB1eFNjcm9sbEludG9WaWV3OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBBbGxvdyB1c2VyIHRvIHByb3ZpZGUgdGhlIGJyb3dzZXIgc3VwcG9ydGVkIG9wdGlvbnMgKi9cbiAgICBASW5wdXQoKSBzY3JvbGxJbnRvVmlld09wdGlvbnM6IFNjcm9sbEludG9WaWV3T3B0aW9ucyB8IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnV4U2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxJbnRvVmlldyh0aGlzLnNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNjcm9sbEludG9WaWV3SWZEaXJlY3RpdmUgfSBmcm9tICcuL3Njcm9sbC1pbnRvLXZpZXctaWYuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNjcm9sbEludG9WaWV3RGlyZWN0aXZlIH0gZnJvbSAnLi9zY3JvbGwtaW50by12aWV3LmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbU2Nyb2xsSW50b1ZpZXdJZkRpcmVjdGl2ZSwgU2Nyb2xsSW50b1ZpZXdEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW1Njcm9sbEludG9WaWV3SWZEaXJlY3RpdmUsIFNjcm9sbEludG9WaWV3RGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxNb2R1bGUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRTZXJ2aWNlIH0gZnJvbSAnLi90eXBlYWhlYWQuc2VydmljZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3V4VHlwZWFoZWFkSGlnaGxpZ2h0XSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZEhpZ2hsaWdodERpcmVjdGl2ZSB7XHJcblxyXG4gICAgQElucHV0KCd1eFR5cGVhaGVhZEhpZ2hsaWdodCcpXHJcbiAgICBzZXQgaGlnaGxpZ2h0KHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuaGlnaGxpZ2h0ZWRFbGVtZW50JC5uZXh0KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlcnZpY2U6IFR5cGVhaGVhZFNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvaW5maW5pdGUtc2Nyb2xsL2luZGV4JztcbmltcG9ydCB7IFNjcm9sbE1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvc2Nyb2xsL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZEhpZ2hsaWdodERpcmVjdGl2ZSB9IGZyb20gJy4vdHlwZWFoZWFkLWhpZ2hsaWdodC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVHlwZWFoZWFkS2V5U2VydmljZSB9IGZyb20gJy4vdHlwZWFoZWFkLWtleS5zZXJ2aWNlJztcbmltcG9ydCB7IFR5cGVhaGVhZENvbXBvbmVudCB9IGZyb20gJy4vdHlwZWFoZWFkLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTW9kdWxlLFxuICAgICAgICBTY3JvbGxNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtUeXBlYWhlYWRDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1R5cGVhaGVhZENvbXBvbmVudCwgVHlwZWFoZWFkSGlnaGxpZ2h0RGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtUeXBlYWhlYWRLZXlTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3V4UmVvcmRlcmFibGVIYW5kbGVdJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUgeyB9XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdbdXhSZW9yZGVyYWJsZU1vZGVsXSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUge1xyXG5cclxuICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgYSBtb2RlbCBmb3IgdGhlIGl0ZW0gLSBhbGxvd3MgdXNlIHdpdGggbmdGb3JcclxuICAgIEBJbnB1dCgpIHV4UmVvcmRlcmFibGVNb2RlbDogYW55O1xyXG5cclxuICAgIC8vIHRoaXMgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgd2hpY2ggaW5zdGFuY2Ugb2YgdGhlIGRpcmVjdGl2ZSByZWxhdGVzIHRvIHdoaWNoIGVsZW1lbnRcclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxufVxyXG4iLCIvLyBXT1JLQVJPVU5EOiBBbmd1bGFyIENsaSA2IGhhcyByZW1vdmVkIHRoZSBnbG9iYWxzIHBhdGNoLCBkcmFndWxhciByZXF1aXJlcyB0aGlzIHRvIHdlIGNhbiBwYXRjaCBpdCBoZXJlXG4oPGFueT53aW5kb3cpLmdsb2JhbCA9ICg8YW55PndpbmRvdykuZ2xvYmFsIHx8IHt9O1xuXG4vLyBXT1JLQVJPVU5EOiBuZy1wYWNrYWdyIGlzc3VlIC0gaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG5pbXBvcnQgKiBhcyBkcmFndWxhTmFtZXNwYWNlIGZyb20gJ2RyYWd1bGEnO1xuaW1wb3J0IHsgRHJha2UgfSBmcm9tICdkcmFndWxhJztcblxuZXhwb3J0IGNvbnN0IGRyYWd1bGE6IChjb250YWluZXJzPzogYW55LCBvcHRpb25zPzogYW55KSA9PiBEcmFrZSA9IChkcmFndWxhTmFtZXNwYWNlIGFzIGFueSkuZGVmYXVsdCB8fCBkcmFndWxhTmFtZXNwYWNlOyIsImltcG9ydCB7IEluamVjdGFibGUsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRHJha2UsIERyYWd1bGFPcHRpb25zIH0gZnJvbSAnZHJhZ3VsYSc7XG5pbXBvcnQgeyBkcmFndWxhIH0gZnJvbSAnLi9kcmFndWxhJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlU2VydmljZSB7XG5cbiAgICBwcml2YXRlIF9ncm91cHM6IHsgW2s6IHN0cmluZ106IFJlb3JkZXJhYmxlR3JvdXAgfSA9IHt9O1xuICAgIHByaXZhdGUgX3VuaXF1ZUdyb3VwSWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHVuaXF1ZSBzdHJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgYXMgYSBncm91cCBuYW1lIGlmIG9uZSB3YXMgbm90IGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgZ2V0VW5pcXVlR3JvdXBOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnX3V4UmVvcmRlcmFibGVfJyArIHRoaXMuX3VuaXF1ZUdyb3VwSWQrKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBjb250YWluZXIgdG8gdGhlIG5hbWVkIGdyb3VwLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGdyb3VwTmFtZTogc3RyaW5nLCBjb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyKTogUmVvcmRlcmFibGVHcm91cCB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV0gPSBuZXcgUmVvcmRlcmFibGVHcm91cCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV0ucmVnaXN0ZXIoY29udGFpbmVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29udGFpbmVyIGZyb20gdGhlIG5hbWVkIGdyb3VwLiBJZiBpdCB3YXMgdGhlIGxhc3QgY29udGFpbmVyIGluIHRoZSBncm91cCwgZGVzdHJveXMgdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoZ3JvdXBOYW1lOiBzdHJpbmcsIGNvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXIpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xuXG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAudW5yZWdpc3Rlcihjb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXAuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZHJhZ3VsYSBpbnN0YW5jZSB3aXRoIHRoZSBjdXJyZW50IGNvbmZpZyBhbmQgYXR0YWNoZXMgdGhlIGV2ZW50cywgaWYgbm90IGFscmVhZHkgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplKGdyb3VwTmFtZTogc3RyaW5nKTogUmVvcmRlcmFibGVHcm91cCB7XG5cbiAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcblxuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBncm91cCBvYmplY3QgZm9yIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIGdldEdyb3VwKGdyb3VwOiBzdHJpbmcpOiBSZW9yZGVyYWJsZUdyb3VwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3Vwc1tncm91cF07XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlQ29udGFpbmVyIHtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIGdldE1vZGVsRnJvbUVsZW1lbnQ6IChlbGVtZW50OiBFbGVtZW50KSA9PiBhbnk7XG4gICAgY2FuTW92ZTogKGVsZW1lbnQ6IEVsZW1lbnQsIGNvbnRhaW5lcjogRWxlbWVudCwgaGFuZGxlOiBFbGVtZW50KSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlRHJhZ0V2ZW50IHtcbiAgICBtb2RlbDogYW55O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgc291cmNlOiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlRHJhZ0VuZEV2ZW50IHtcbiAgICBtb2RlbDogYW55O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVEcm9wRXZlbnQge1xuICAgIG1vZGVsOiBhbnk7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICB0YXJnZXQ6IEVsZW1lbnQ7XG4gICAgc291cmNlOiBFbGVtZW50O1xuICAgIHNpYmxpbmc6IEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVDYW5jZWxFdmVudCB7XG4gICAgbW9kZWw6IGFueTtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlQ2xvbmVkRXZlbnQge1xuICAgIGNsb25lOiBFbGVtZW50O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgdHlwZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGRyYWctYW5kLWRyb3AgY29udGFpbmVycyAodXhSZW9yZGVyYWJsZSkgdGhhdCBpdGVtcyBjYW4gYmUgZHJhZ2dlZCBiZXR3ZWVuLlxuICovXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVHcm91cCB7XG5cbiAgICBkcmFnID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZURyYWdFdmVudD4oKTtcbiAgICBkcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZURyYWdFbmRFdmVudD4oKTtcbiAgICBkcm9wID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZURyb3BFdmVudD4oKTtcbiAgICBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJhYmxlQ2FuY2VsRXZlbnQ+KCk7XG4gICAgY2xvbmVkID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZUNsb25lZEV2ZW50PigpO1xuXG4gICAgcHJpdmF0ZSBfaW5zdGFuY2U6IERyYWtlO1xuICAgIHByaXZhdGUgX2NvbnRhaW5lcnM6IFJlb3JkZXJhYmxlQ29udGFpbmVyW10gPSBbXTtcblxuICAgIHByaXZhdGUgX2NvbmZpZzogRHJhZ3VsYU9wdGlvbnMgPSB7XG4gICAgICAgIG1vdmVzOiB0aGlzLmNhbk1vdmUuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIGNvbnRhaW5lcnMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVycy5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kZWwgb2JqZWN0ICh1eFJlb3JkZXJhYmxlTW9kZWwpIGZvciBhbiBlbGVtZW50cyBpbiBvbmUgb2YgdGhlIGNvbnRhaW5lcnMgaW4gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIGdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50OiBFbGVtZW50KTogYW55IHtcbiAgICAgICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5fY29udGFpbmVycykge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBjb250YWluZXIuZ2V0TW9kZWxGcm9tRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGNvbnRhaW5lciB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9jb250YWluZXJzLnB1c2goY29udGFpbmVyKTtcblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmNvbnRhaW5lcnMgPSB0aGlzLl9jb250YWluZXJzLm1hcCgoYykgPT4gYy5lbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLm1pcnJvckNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLm1pcnJvckNvbnRhaW5lciA9IGNvbnRhaW5lci5lbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29udGFpbmVyIGZyb20gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcik6IHZvaWQge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NvbnRhaW5lcnMuaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UuY29udGFpbmVycyA9IHRoaXMuX2NvbnRhaW5lcnMubWFwKChjKSA9PiBjLmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZHJhZ3VsYSBpbnN0YW5jZSB3aXRoIHRoZSBjdXJyZW50IGNvbmZpZyBhbmQgYXR0YWNoZXMgdGhlIGV2ZW50cywgaWYgbm90IGFscmVhZHkgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBkcmFndWxhKHRoaXMuX2NvbnRhaW5lcnMubWFwKChjKSA9PiBjLmVsZW1lbnQpLCB0aGlzLl9jb25maWcpO1xuXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdkcmFnJywgKGVsZW1lbnQ6IEVsZW1lbnQsIHNvdXJjZTogRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnLmVtaXQoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdkcmFnZW5kJywgKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VuZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignZHJvcCcsIChlbGVtZW50OiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQsIHNvdXJjZTogRWxlbWVudCwgc2libGluZzogRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcm9wLmVtaXQoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgIHNpYmxpbmc6IHNpYmxpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2NhbmNlbCcsIChlbGVtZW50OiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignY2xvbmVkJywgKGNsb25lOiBFbGVtZW50LCBlbGVtZW50OiBFbGVtZW50LCB0eXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvbmVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNsb25lOiBjbG9uZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgZHJhZ3VsYSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBjb250YWluZXIgZm9yIHRoZSBjb250YWluZXJFbGVtZW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIG9mIGNhbk1vdmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYW5Nb3ZlKGVsZW1lbnQ6IEVsZW1lbnQsIGNvbnRhaW5lckVsZW1lbnQ6IEVsZW1lbnQsIGhhbmRsZTogRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGxldCBjb250YWluZXIgb2YgdGhpcy5fY29udGFpbmVycykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5lbGVtZW50LmlzU2FtZU5vZGUoY29udGFpbmVyRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmNhbk1vdmUoZWxlbWVudCwgY29udGFpbmVyRWxlbWVudCwgaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLW1vZGVsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZUNhbmNlbEV2ZW50LCBSZW9yZGVyYWJsZUNsb25lZEV2ZW50LCBSZW9yZGVyYWJsZUNvbnRhaW5lciwgUmVvcmRlcmFibGVEcmFnRW5kRXZlbnQsIFJlb3JkZXJhYmxlRHJhZ0V2ZW50LCBSZW9yZGVyYWJsZURyb3BFdmVudCwgUmVvcmRlcmFibGVTZXJ2aWNlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhSZW9yZGVyYWJsZV0nXG59KVxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgcmVvcmRlcmFibGVNb2RlbDogQXJyYXk8YW55PjtcbiAgICBASW5wdXQoKSByZW9yZGVyYWJsZUdyb3VwOiBzdHJpbmc7XG4gICAgQElucHV0KCkgcmVvcmRlcmluZ0Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQE91dHB1dCgpIHJlb3JkZXJhYmxlTW9kZWxDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEFycmF5PGFueT4+KCk7XG4gICAgQE91dHB1dCgpIHJlb3JkZXJTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlckV2ZW50PigpO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyQ2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyRXZlbnQ+KCk7XG4gICAgQE91dHB1dCgpIHJlb3JkZXJFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJFdmVudD4oKTtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUsIHsgcmVhZDogRWxlbWVudFJlZiwgZGVzY2VuZGFudHM6IHRydWUgfSkgaGFuZGxlczogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuICAgIEBDb250ZW50Q2hpbGRyZW4oUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZSkgbW9kZWxzOiBRdWVyeUxpc3Q8UmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZT47XG5cbiAgICBwcml2YXRlIF9jb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy51eC1yZW9yZGVyYWJsZS1jb250YWluZXItbW92aW5nJykgZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgcHJpdmF0ZSBfc2VydmljZTogUmVvcmRlcmFibGVTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgZHJhZ3VsYSBhbmQgYmluZCB0byBhbGwgdGhlIHJlcXVpcmVkIGV2ZW50c1xuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIElmIG5vIGdyb3VwIG5hbWUgdGhlbiBnZW5lcmF0ZSBhIHVuaXF1ZSBvbmUgZm9yIHRoaXMgaW5zdGFuY2Ugb25seVxuICAgICAgICBpZiAoIXRoaXMucmVvcmRlcmFibGVHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZUdyb3VwID0gdGhpcy5fc2VydmljZS5nZXRVbmlxdWVHcm91cE5hbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIGdldE1vZGVsRnJvbUVsZW1lbnQ6IHRoaXMuZ2V0TW9kZWxGcm9tRWxlbWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2FuTW92ZTogdGhpcy5jYW5Nb3ZlLmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWdpc3RlciBmb3IgZHJhZyBldmVudHMgb24gdGhpcyBlbGVtZW50XG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5fc2VydmljZS5yZWdpc3Rlcih0aGlzLnJlb3JkZXJhYmxlR3JvdXAsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmRyYWcuc3Vic2NyaWJlKHRoaXMub25EcmFnLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuZHJhZ0VuZC5zdWJzY3JpYmUodGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5kcm9wLnN1YnNjcmliZSh0aGlzLm9uRHJvcC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmNhbmNlbC5zdWJzY3JpYmUoKGV2ZW50OiBSZW9yZGVyYWJsZUNhbmNlbEV2ZW50KSA9PiB0aGlzLnJlb3JkZXJDYW5jZWwuZW1pdCh7IGVsZW1lbnQ6IGV2ZW50LmVsZW1lbnQsIG1vZGVsOiBldmVudC5tb2RlbCB9KSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5jbG9uZWQuc3Vic2NyaWJlKHRoaXMub25DbG9uZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zZXJ2aWNlLmluaXRpYWxpemUodGhpcy5yZW9yZGVyYWJsZUdyb3VwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIGRyYWd1bGEgaW5zdGFuY2Ugb24gY29tcG9uZW50IGRlc3Ryb3lcbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2VydmljZS51bnJlZ2lzdGVyKHRoaXMucmVvcmRlcmFibGVHcm91cCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIG9uRHJhZyhldmVudDogUmVvcmRlcmFibGVEcmFnRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnJlb3JkZXJTdGFydC5lbWl0KHsgZWxlbWVudDogZXZlbnQuZWxlbWVudCwgbW9kZWw6IGV2ZW50Lm1vZGVsIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgZmlyZWQgd2hlbiBpdGVtcyBnZXQgcmVvcmRlcmVkIC0gd2UgbmVlZCB0byBlbWl0IHRoZSBuZXcgb3JkZXIgb2YgdGhlIG1vZGVsc1xuICAgICAqL1xuICAgIG9uRHJvcChldmVudDogUmVvcmRlcmFibGVEcm9wRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBwcm92aWRlZCBtb2R1bGUgd2UgY2FuIHNraXAgdGhpc1xuICAgICAgICBpZiAoIXRoaXMucmVvcmRlcmFibGVNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZXZlbnQuc291cmNlLmlzU2FtZU5vZGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSkge1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBtb2RlbCBmcm9tIHRoZSBsaXN0IG9mIG1vZGVsc1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuaW5kZXhPZihldmVudC5tb2RlbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5pc1NhbWVOb2RlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBzaWJsaW5nIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuc2libGluZyAmJiAhZXZlbnQuc2libGluZy5jbGFzc0xpc3QuY29udGFpbnMoJ2d1LW1pcnJvcicpID9cbiAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuaW5kZXhPZih0aGlzLmdldE1vZGVsRnJvbUVsZW1lbnQoZXZlbnQuc2libGluZykpIDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIG1vZGVsIGF0IGl0cyBuZXcgbG9jYXRpb25cbiAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbC5zcGxpY2UoaW5kZXgsIDAsIGV2ZW50Lm1vZGVsKTtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW1pdCBldmVudCBpZiBhbnkgY2hhbmdlcyB3ZXJlIG1hZGVcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbENoYW5nZS5lbWl0KHRoaXMucmVvcmRlcmFibGVNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1vZGVsIGFzc2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAqIFRoaXMgc2hvdWxkIGVuc3VyZSB0aGF0IHRoZSBpdGVtcyBoYXZlIHRoZSBkcmFnZ2FibGUgbW9kZWwgZGlyZWN0aXZlIGFwcGxpZWRcbiAgICAgKi9cbiAgICBnZXRNb2RlbEZyb21FbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiBhbnkge1xuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbHMuZmluZChfbW9kZWwgPT4gX21vZGVsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCA9PT0gZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kZWwudXhSZW9yZGVyYWJsZU1vZGVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgZmluaXNoIGRyYWdnaW5nIHJlbW92ZSB0aGUgdXRpbGxpdHkgY2xhc3MgZnJvbSB0aGUgZWxlbWVudCBiZWluZyBtb3ZlZFxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChldmVudDogUmVvcmRlcmFibGVEcmFnRW5kRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC5lbGVtZW50KSkge1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyhldmVudC5lbGVtZW50LCAndXgtcmVvcmRlcmFibGUtbW92aW5nJyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVvcmRlckVuZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBldmVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgIG1vZGVsOiBldmVudC5tb2RlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IHRoZSBjbG9uZWQgZWxlbWVudCBpcyBpZGVudGljYWxcbiAgICAgKiB0byB0aGUgb3JpZ2luYWwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBsb2NhdGlvbiBpbiB0aGUgRE9NIHRyZWVcbiAgICAgKi9cbiAgICBvbkNsb25lKGV2ZW50OiBSZW9yZGVyYWJsZUNsb25lZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC5lbGVtZW50KSkge1xuXG4gICAgICAgICAgICB0aGlzLnNldFRhYmxlQ2VsbFdpZHRocyhldmVudC5lbGVtZW50LCBldmVudC5jbG9uZSk7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXNlcyhldmVudC5lbGVtZW50LCBldmVudC5jbG9uZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKGV2ZW50LmVsZW1lbnQsICd1eC1yZW9yZGVyYWJsZS1tb3ZpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnRzIGNvbnRhaW4gaGFuZGxlcyB0aGVuIG9ubHkgZHJhZyB3aGVuIHRoZSBoYW5kbGUgaXMgZHJhZ2dlZFxuICAgICAqIG90aGVyd2lzZSBkcmFnIHdoZW5ldmVyIGFuIGltbWVkaWF0ZSBjaGlsZCBpcyBzcGVjaWZpZWRcbiAgICAgKi9cbiAgICBjYW5Nb3ZlKGVsZW1lbnQ6IEVsZW1lbnQsIGNvbnRhaW5lcjogRWxlbWVudCwgaGFuZGxlOiBFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLnJlb3JkZXJpbmdEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXMubGVuZ3RoID09PSAwID8gdHJ1ZSA6ICEhdGhpcy5oYW5kbGVzLmZpbmQoX2hhbmRsZSA9PiBfaGFuZGxlLm5hdGl2ZUVsZW1lbnQgPT09IGhhbmRsZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUYWJsZUNlbGxXaWR0aHMoc291cmNlOiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBpdCBpcyBub3QgYSB0YWJsZSByb3cgdGhlbiBza2lwIHRoaXNcbiAgICAgICAgaWYgKHNvdXJjZS50YWdOYW1lICE9PSAnVFInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIGFueSBpbW1lZGlhdGUgdGQgY2hpbGRyZW4gYW5kIGZpeCB0aGVpciB3aWR0aFxuICAgICAgICBjb25zdCBzb3VyY2VDZWxscyA9IEFycmF5LmZyb20oc291cmNlLmNoaWxkcmVuKSBhcyBIVE1MVGFibGVDZWxsRWxlbWVudFtdO1xuICAgICAgICBjb25zdCB0YXJnZXRDZWxscyA9IEFycmF5LmZyb20odGFyZ2V0LmNoaWxkcmVuKSBhcyBIVE1MVGFibGVDZWxsRWxlbWVudFtdO1xuXG4gICAgICAgIC8vIGZpeCB0aGUgd2lkdGggb2YgdGhlc2UgY2VsbHNcbiAgICAgICAgc291cmNlQ2VsbHMuZm9yRWFjaCgoY2VsbCwgaWR4KSA9PiB0YXJnZXRDZWxsc1tpZHhdLnN0eWxlLm1pbldpZHRoID0gZ2V0Q29tcHV0ZWRTdHlsZShjZWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhcHR1cmVDYW52YXNlcyhzb3VyY2U6IEVsZW1lbnQsIHRhcmdldDogRWxlbWVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgYWxsIGNoaWxkIGNhbnZhcyBlbGVtZW50c1xuICAgICAgICBjb25zdCBzb3VyY2VDYW52YXNlcyA9IEFycmF5LmZyb20oc291cmNlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NhbnZhcycpKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2FudmFzZXMgPSBBcnJheS5mcm9tKHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKCdjYW52YXMnKSk7XG5cbiAgICAgICAgLy8gcmVwbGljYXRlIHRoZSBjYW52YXMgY29udGVudFxuICAgICAgICB0YXJnZXRDYW52YXNlcy5tYXAoY2FudmFzID0+IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKVxuICAgICAgICAgICAgLmZvckVhY2goKGNvbnRleHQsIGlkeCkgPT4gY29udGV4dC5kcmF3SW1hZ2Uoc291cmNlQ2FudmFzZXNbaWR4XSwgMCwgMCkpO1xuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlckV2ZW50IHtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIG1vZGVsOiBhbnk7XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLWhhbmRsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUtbW9kZWwuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlU2VydmljZSB9IGZyb20gJy4vcmVvcmRlcmFibGUuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSZW9yZGVyYWJsZURpcmVjdGl2ZSxcbiAgICAgICAgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUsXG4gICAgICAgIFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVvcmRlcmFibGVEaXJlY3RpdmUsXG4gICAgICAgIFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlLFxuICAgICAgICBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgUmVvcmRlcmFibGVTZXJ2aWNlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi9tb2RlbHMvZmFjZXQnO1xuXG5leHBvcnQgY2xhc3MgRmFjZXRTZWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWNldDogRmFjZXQpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBGYWNldERlc2VsZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFjZXQ6IEZhY2V0KSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRmFjZXREZXNlbGVjdEFsbCB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxufVxuXG5leHBvcnQgdHlwZSBGYWNldEV2ZW50ID0gRmFjZXRTZWxlY3QgfCBGYWNldERlc2VsZWN0IHwgRmFjZXREZXNlbGVjdEFsbDsiLCJpbXBvcnQgeyBMaXZlQW5ub3VuY2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVvcmRlckV2ZW50IH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9pbmRleCc7XG5pbXBvcnQgeyBGYWNldERlc2VsZWN0LCBGYWNldERlc2VsZWN0QWxsLCBGYWNldEV2ZW50LCBGYWNldFNlbGVjdCB9IGZyb20gJy4vZmFjZXQtZXZlbnRzJztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWNvbnRhaW5lcicsXG4gICAgdGVtcGxhdGU6IGA8IS0tIERpc3BsYXkgQW55IFNlbGVjdGVkIEZhY2V0cyAtLT5cbjxkaXYgY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtY29udGFpbmVyXCI+XG5cbiAgICA8IS0tIERpc3BsYXkgVGl0bGUgYW4gQ2xlYXIgQnV0dG9uIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtaGVhZGVyLWNvbnRhaW5lclwiPlxuXG4gICAgICAgIDwhLS0gU2hvdyBUaGUgU2VsZWN0ZWQgVGV4dCAtLT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtaGVhZGVyLWxhYmVsXCI+e3sgaGVhZGVyIH19PC9zcGFuPlxuXG4gICAgICAgIDwhLS0gQWRkIGEgQ2xlYXIgQnV0dG9uIC0tPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1saW5rIGJ0bi1pY29uIGJ1dHRvbi1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY2xlYXJUb29sdGlwXCJcbiAgICAgICAgICAgIFt1eFRvb2x0aXBdPVwiY2xlYXJUb29sdGlwXCJcbiAgICAgICAgICAgIHBsYWNlbWVudD1cImxlZnRcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImRlc2VsZWN0QWxsRmFjZXRzKClcIlxuICAgICAgICAgICAgKm5nSWY9XCJmYWNldHMubGVuZ3RoID4gMFwiPlxuXG4gICAgICAgICAgICA8c3ZnIGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLWNsZWFyLWdyYXBoaWNcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHZpZXdCb3g9XCIwIDAgMTkgMTJcIiBzaGFwZS1yZW5kZXJpbmc9XCJnZW9tZXRyaWNQcmVjaXNpb25cIj5cbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImxpZ2h0LWdyZXlcIiB4PVwiMFwiIHk9XCIyXCIgd2lkdGg9XCI3XCIgaGVpZ2h0PVwiMlwiPjwvcmVjdD5cbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImRhcmstZ3JleVwiIHg9XCIwXCIgeT1cIjVcIiB3aWR0aD1cIjlcIiBoZWlnaHQ9XCIyXCI+PC9yZWN0PlxuICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwibGlnaHQtZ3JleVwiIHg9XCIwXCIgeT1cIjhcIiB3aWR0aD1cIjdcIiBoZWlnaHQ9XCIyXCI+PC9yZWN0PlxuICAgICAgICAgICAgICAgIDxwYXRoIGNsYXNzPVwiZGFyay1ncmV5XCIgZD1cIk05LDEgaDEgbDksOSB2MSBoLTEgbC05LC05IHYtMSBaXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgIDxwYXRoIGNsYXNzPVwiZGFyay1ncmV5XCIgZD1cIk05LDExIHYtMSBsOSwtOSBoMSB2MSBsLTksOSBoLTEgWlwiPjwvcGF0aD5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2J1dHRvbj5cblxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBEaXNwbGF5IFRhZ3MgRm9yIFNlbGVjdGVkIEl0ZW1zIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtbGlzdFwiXG4gICAgICAgIHV4UmVvcmRlcmFibGVcbiAgICAgICAgcm9sZT1cImxpc3RcIlxuICAgICAgICBbcmVvcmRlcmluZ0Rpc2FibGVkXT1cIiFmYWNldHNSZW9yZGVyYWJsZVwiXG4gICAgICAgIFsocmVvcmRlcmFibGVNb2RlbCldPVwiZmFjZXRzXCJcbiAgICAgICAgKHJlb3JkZXJhYmxlTW9kZWxDaGFuZ2UpPVwiZmFjZXRzQ2hhbmdlLmVtaXQoZmFjZXRzKVwiPlxuXG4gICAgICAgIDwhLS0gU2hvdyBTZWxlY3RlZCBUYWdzIC0tPlxuICAgICAgICA8ZGl2ICN0YWdcbiAgICAgICAgICAgIGNsYXNzPVwiZmFjZXQtc2VsZWN0ZWQtdGFnXCJcbiAgICAgICAgICAgIHJvbGU9XCJsaXN0aXRlbVwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgdXhSZW9yZGVyYWJsZUhhbmRsZVxuICAgICAgICAgICAgKm5nRm9yPVwibGV0IGZhY2V0IG9mIGZhY2V0czsgdHJhY2tCeTogdHJhY2tCeVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImZhY2V0LnRpdGxlXCJcbiAgICAgICAgICAgIFt1eFJlb3JkZXJhYmxlTW9kZWxdPVwiZmFjZXRcIlxuICAgICAgICAgICAgKG1vdXNlZG93bik9XCJ0YWcuZm9jdXMoKVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5BcnJvd1JpZ2h0KT1cInNoaWZ0UmlnaHQoZmFjZXQsIHRhZylcIlxuICAgICAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cInNoaWZ0TGVmdChmYWNldCwgdGFnKVwiPlxuXG4gICAgICAgICAgICA8IS0tIERpc3BsYXkgTGFiZWwgLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhY2V0LXNlbGVjdGVkLXRhZy1sYWJlbFwiPnt7IGZhY2V0LnRpdGxlIH19PC9zcGFuPlxuXG4gICAgICAgICAgICA8IS0tIERpc3BsYXkgUmVtb3ZlIEljb24gLS0+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZmFjZXQtc2VsZWN0ZWQtcmVtb3ZlLWJ0blwiXG4gICAgICAgICAgICAgICAgaTE4bi1hcmlhLWxhYmVsXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkRlc2VsZWN0IEZhY2V0XCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiZGVzZWxlY3RGYWNldChmYWNldCwgdGFnKVwiPlxuXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtY2xvc2VcIj48L2k+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gU2hvdyBNZXNzYWdlIEhlcmUgaWYgTm8gRmFjZXRzIFNlbGVjdGVkIC0tPlxuICAgIDxwIGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLW5vbmUtbGFiZWxcIiAqbmdJZj1cImVtcHR5VGV4dCAmJiBmYWNldHMubGVuZ3RoID09PSAwXCI+e3sgZW1wdHlUZXh0IH19PC9wPlxuXG48L2Rpdj5cblxuPCEtLSBBbnkgRmFjZXQgRWxlbWVudHMgU2hvdWxkIGJlIEFkZGVkIEhlcmUgQnkgVXNlciAtLT5cbjxkaXYgY2xhc3M9XCJmYWNldHMtcmVnaW9uXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldENvbnRhaW5lckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZyA9ICdTZWxlY3RlZDonO1xuICAgIEBJbnB1dCgpIGNsZWFyVG9vbHRpcDogc3RyaW5nID0gJ0NsZWFyIEFsbCc7XG4gICAgQElucHV0KCkgZW1wdHlUZXh0OiBzdHJpbmcgPSAnTm8gSXRlbXMnO1xuICAgIEBJbnB1dCgpIGZhY2V0czogRmFjZXRbXSA9IFtdO1xuICAgIEBJbnB1dCgpIGZhY2V0c1Jlb3JkZXJhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgZmFjZXRzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmFjZXRbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZhY2V0W10+KCk7XG4gICAgQE91dHB1dCgpIGV2ZW50czogRXZlbnRFbWl0dGVyPEZhY2V0RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldEV2ZW50PigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfYW5ub3VuY2VyOiBMaXZlQW5ub3VuY2VyKSB7IH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50cy5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdEZhY2V0KGZhY2V0OiBGYWNldCk6IHZvaWQge1xuICAgICAgICAvLyBwdXNoIHRoZSBmYWNldCBvbiB0byB0aGUgbGlzdFxuICAgICAgICB0aGlzLmZhY2V0cy5wdXNoKGZhY2V0KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHR3byB3YXkgYmluZGluZ1xuICAgICAgICB0aGlzLmZhY2V0c0NoYW5nZS5lbWl0KHRoaXMuZmFjZXRzKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldFNlbGVjdChmYWNldCkpO1xuICAgIH1cblxuICAgIGRlc2VsZWN0RmFjZXQoZmFjZXQ6IEZhY2V0LCB0YWc/OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGluIHRoZSBzZWxlY3RlZCBhcnJheVxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZhY2V0cy5maW5kSW5kZXgoc2VsZWN0ZWRGYWNldCA9PiBmYWNldCA9PT0gc2VsZWN0ZWRGYWNldCk7XG5cbiAgICAgICAgLy8gaWYgbWF0Y2ggdGhlcmUgd2FzIG5vIG1hdGNoIHRoZW4gZmluaXNoXG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0aGlzLmZhY2V0cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHR3byB3YXkgYmluZGluZ1xuICAgICAgICB0aGlzLmZhY2V0c0NoYW5nZS5lbWl0KHRoaXMuZmFjZXRzKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldERlc2VsZWN0KGZhY2V0KSk7XG5cbiAgICAgICAgLy8gYW5ub3VuY2UgdGhlIGZhY2V0IHJlbW92YWxcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VyLmFubm91bmNlKGBPcHRpb24gJHtmYWNldC50aXRsZX0gZGVzZWxlY3RlZC5gLCAnYXNzZXJ0aXZlJyk7XG5cbiAgICAgICAgLy8gZm9jdXMgYW5vdGhlciB0YWcgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSB0YWcucHJldmlvdXNFbGVtZW50U2libGluZyB8fCB0YWcubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpYmxpbmcgdGhlbiBmb2N1cyBpdFxuICAgICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAoc2libGluZyBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc2VsZWN0QWxsRmFjZXRzKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGVtcHR5IHRoZSBzZWxlY3RlZCBhcnJheVxuICAgICAgICB0aGlzLmZhY2V0cyA9IFtdO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdHdvIHdheSBiaW5kaW5nXG4gICAgICAgIHRoaXMuZmFjZXRzQ2hhbmdlLmVtaXQodGhpcy5mYWNldHMpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0RGVzZWxlY3RBbGwoKSk7XG5cbiAgICAgICAgLy8gYW5ub3VuY2UgdGhlIGZhY2V0IHJlbW92YWxcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VyLmFubm91bmNlKGBBbGwgb3B0aW9ucyBkZXNlbGVjdGVkLmAsICdhc3NlcnRpdmUnKTtcbiAgICB9XG5cbiAgICB0cmFja0J5KF9pbmRleDogbnVtYmVyLCBmYWNldDogRmFjZXQpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICByZXR1cm4gZmFjZXQuaWQgfHwgZmFjZXQudGl0bGU7XG4gICAgfVxuXG4gICAgc2hpZnRSaWdodChmYWNldDogRmFjZXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgaXRlbSBpZiByZW9yZGVyaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgaWYgKHRoaXMuZmFjZXRzUmVvcmRlcmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHRoZSBtb3ZlbWVudFxuICAgICAgICB0aGlzLnNoaWZ0RmFjZXQoZmFjZXQsIDEpO1xuXG4gICAgICAgIC8vIHRoZSBpdGVtIG1heSBiZWNvbWUgdW5mb2N1c2VkIGR1cmluZyB0aGUgcmVvcmRlciBzbyB3ZSBzaG91bGQgcmVmb2N1cyBpdFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZWxlbWVudC5mb2N1cygpKTtcblxuICAgICAgICAvLyBhbm5vdW5jZSB0aGUgbW92ZVxuICAgICAgICB0aGlzLl9hbm5vdW5jZXIuYW5ub3VuY2UoYE9wdGlvbiAke2ZhY2V0LnRpdGxlfSBtb3ZlZCBkb3duLmApO1xuICAgIH1cblxuICAgIHNoaWZ0TGVmdChmYWNldDogRmFjZXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgaXRlbSBpZiByZW9yZGVyaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgaWYgKHRoaXMuZmFjZXRzUmVvcmRlcmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHRoZSBtb3ZlbWVudFxuICAgICAgICB0aGlzLnNoaWZ0RmFjZXQoZmFjZXQsIC0xKTtcblxuICAgICAgICAvLyB0aGUgaXRlbSBtYXkgYmVjb21lIHVuZm9jdXNlZCBkdXJpbmcgdGhlIHJlb3JkZXIgc28gd2Ugc2hvdWxkIHJlZm9jdXMgaXRcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGVsZW1lbnQuZm9jdXMoKSk7XG5cbiAgICAgICAgLy8gYW5ub3VuY2UgdGhlIG1vdmVcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VyLmFubm91bmNlKGBPcHRpb24gJHtmYWNldC50aXRsZX0gbW92ZWQgdXAuYCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaGlmdEZhY2V0KGZhY2V0OiBGYWNldCwgZGlzdGFuY2U6IG51bWJlcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmFjZXRzLmluZGV4T2YoZmFjZXQpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpbmRleCArIGRpc3RhbmNlO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgbW92ZSBpcyB2YWxpZFxuICAgICAgICBpZiAodGFyZ2V0IDwgMCB8fCB0YXJnZXQgPT09IHRoaXMuZmFjZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgbW92ZVxuICAgICAgICB0aGlzLmZhY2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmZhY2V0cy5zcGxpY2UodGFyZ2V0LCAwLCBmYWNldCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRXZlbnQoZXZlbnQ6IEZhY2V0RXZlbnQpIHtcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dChldmVudCk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZhY2V0UmVvcmRlckV2ZW50IGV4dGVuZHMgUmVvcmRlckV2ZW50IHtcbiAgICBpbmRleDogbnVtYmVyO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0LCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZmFjZXQtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldERlc2VsZWN0LCBGYWNldERlc2VsZWN0QWxsLCBGYWNldEV2ZW50LCBGYWNldFNlbGVjdCB9IGZyb20gJy4uLy4uL2ZhY2V0LWV2ZW50cyc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uLy4uL21vZGVscy9mYWNldCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtYmFzZScsXG4gICAgdGVtcGxhdGU6ICcnLFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBzZWxlY3RlZDogRmFjZXRbXSA9IFtdO1xuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPEZhY2V0W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldFtdPigpO1xuICAgIEBPdXRwdXQoKSBldmVudHM6IFN1YmplY3Q8RmFjZXRFdmVudD4gPSBuZXcgU3ViamVjdDxGYWNldEV2ZW50PigpO1xuXG4gICAgcHJvdGVjdGVkIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IoIEBIb3N0KCkgcHJpdmF0ZSBmYWNldENvbnRhaW5lcjogRmFjZXRDb250YWluZXJDb21wb25lbnQsIHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuXG4gICAgICAgIGlmIChmYWNldENvbnRhaW5lcikge1xuXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gYW55IGRlc2VsZWN0IGV2ZW50cyBmcm9tIHRoZSBmYWNldCBjb250YWluZXJcbiAgICAgICAgICAgIGZhY2V0Q29udGFpbmVyLmV2ZW50cy5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEZhY2V0RGVzZWxlY3QpLFxuICAgICAgICAgICAgICAgIGZpbHRlcigoZXZlbnQ6IEZhY2V0RGVzZWxlY3QpID0+ICEhdGhpcy5zZWxlY3RlZC5maW5kKGZhY2V0ID0+IGZhY2V0ID09PSBldmVudC5mYWNldCkpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICAgICApLnN1YnNjcmliZSgoZXZlbnQ6IEZhY2V0RGVzZWxlY3QpID0+IHRoaXMuZGVzZWxlY3RGYWNldChldmVudC5mYWNldCkpO1xuXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gYW55IGRlc2VsZWN0IGFsbCBldmVudHMgZnJvbSBmYWNldCBjb250YWluZXJcbiAgICAgICAgICAgIGZhY2V0Q29udGFpbmVyLmV2ZW50cy5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEZhY2V0RGVzZWxlY3RBbGwpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICAgICApLnN1YnNjcmliZShfID0+IHRoaXMuZGVzZWxlY3RBbGwoKSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBzaG91bGQgYmUgYW55IGZhY2V0cyBpbml0aWFsbHkgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuZmFjZXRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuZm9yRWFjaChmYWNldCA9PiB0aGlzLmZhY2V0Q29udGFpbmVyLnNlbGVjdEZhY2V0KGZhY2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0RmFjZXQoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGZhY2V0IGlzIGRpc2FibGVkIGl0IHNob3VsZCBub3QgYmUgc2VsZWN0ZWRcbiAgICAgICAgaWYgKGZhY2V0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIGZhY2V0IHRvIHRoZSBsaXN0IG9mIHNlbGVjdGVkIGZhY2V0c1xuICAgICAgICB0aGlzLnNlbGVjdGVkLnB1c2goZmFjZXQpO1xuXG4gICAgICAgIC8vIHNlbmQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgZXZlbnQgZW1pdHRlclxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZCk7XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgZXZlbnQgdG8gdGhlIG9ic2VydmFibGVcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0U2VsZWN0KGZhY2V0KSk7XG5cbiAgICAgICAgLy8gdGVsbCB0aGUgZmFjZXQgY29udGFpbmVyIGFib3V0IHRoZSBzZWxlY3RlZCBmYWNldFxuICAgICAgICBpZiAodGhpcy5mYWNldENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5mYWNldENvbnRhaW5lci5zZWxlY3RGYWNldChmYWNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEZhY2V0KGZhY2V0OiBGYWNldCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgZmFjZXQgdG8gcmVtb3ZlXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zZWxlY3RlZC5maW5kSW5kZXgoc2VsZWN0ZWRGYWNldCA9PiBzZWxlY3RlZEZhY2V0ID09PSBmYWNldCk7XG5cbiAgICAgICAgLy8gb25seSBjb250aW51ZSBpZiBmYWNldCBpcyBmb3VuZFxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZmFjZXQgZnJvbSB0aGUgc2VsZWN0ZWQgbGlzdFxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjaGFuZ2VzIHRvIHNlbGVjdGVkIGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkKTtcblxuICAgICAgICAgICAgLy8gZmlyZSB0aGUgZXZlbnQgdG8gdGhlIG9ic2VydmFibGVcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldERlc2VsZWN0KGZhY2V0KSk7XG5cbiAgICAgICAgICAgIC8vIGRlc2VsZWN0IHRoZSBmYWNldCBpbiB0aGUgZmFjZXQgY29udGFpbmVyXG4gICAgICAgICAgICBpZiAodGhpcy5mYWNldENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFjZXRDb250YWluZXIuZGVzZWxlY3RGYWNldChmYWNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcblxuICAgICAgICAvLyByZW1vdmUgYWxsIHNlbGVjdGVkIGZhY2V0c1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gW107XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgZXZlbnQgdG8gdGhlIG9ic2VydmFibGVcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0RGVzZWxlY3RBbGwoKSk7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgY2hhbmdlcyB0byB0aGUgc2VsZWN0ZWQgZXZlbnQgZW1pdHRlclxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRmFjZXRTZWxlY3Rpb24oZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGZhY2V0IGlzIHNlbGVjdGVkIHRoZW4gZGVzZWxlY3QgLSBvdGhlcndpc2Ugc2VsZWN0IGl0XG4gICAgICAgIGlmICh0aGlzLmlzRmFjZXRTZWxlY3RlZChmYWNldCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RGYWNldChmYWNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEZhY2V0KGZhY2V0KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaXNGYWNldFNlbGVjdGVkKGZhY2V0OiBGYWNldCk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgYSBmYWNldCBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zZWxlY3RlZC5maW5kKHNlbGVjdGVkRmFjZXQgPT4gc2VsZWN0ZWRGYWNldCA9PT0gZmFjZXQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJpZ2dlckV2ZW50KGV2ZW50OiBGYWNldEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXZlbnRzLm5leHQoZXZlbnQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWhlYWRlcicsXG4gICAgdGVtcGxhdGU6IGA8c3BhbiBjbGFzcz1cImZhY2V0LWhlYWRlci10aXRsZVwiPnt7IGhlYWRlciB9fTwvc3Bhbj5cbjxzcGFuIGNsYXNzPVwiaHBlLWljb25cIiBbY2xhc3MuaHBlLWRvd25dPVwiZXhwYW5kZWRcIiBbY2xhc3MuaHBlLXByZXZpb3VzXT1cIiFleHBhbmRlZFwiICpuZ0lmPVwiY2FuRXhwYW5kXCI+PC9zcGFuPmAsXG4gICAgaG9zdDoge1xuICAgICAgICAncm9sZSc6ICdidXR0b24nLFxuICAgICAgICAndGFiaW5kZXgnOiAnMCcsXG4gICAgICAgICcoY2xpY2spJzogJ3RvZ2dsZUV4cGFuZCgpJyxcbiAgICAgICAgJyhrZXl1cC5lbnRlciknOiAndG9nZ2xlRXhwYW5kKCknLFxuICAgICAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAnZXhwYW5kZWQnLFxuICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnaGVhZGVyICsgXFwnIEZhY2V0OiBBY3RpdmF0ZSB0byBcXCcgKyAoZXhwYW5kZWQgPyBcXCdjb2xsYXBzZVxcJyA6IFxcJ2V4cGFuZFxcJyknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBGYWNldEhlYWRlckNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBjYW5FeHBhbmQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBAT3V0cHV0KCkgZXhwYW5kZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIHRvZ2dsZUV4cGFuZCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBub3QgZXhwYW5kYWJsZSB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuY2FuRXhwYW5kKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgRm9jdXNhYmxlT3B0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2ZhY2V0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1jaGVjay1saXN0LWl0ZW0nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAjb3B0aW9uXG4gICAgY2xhc3M9XCJmYWNldC1jaGVjay1saXN0LWl0ZW1cIlxuICAgIFtjbGFzcy5mYWNldC1hY3RpdmVdPVwic2VsZWN0ZWRcIlxuICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJzZWxlY3RlZFwiXG4gICAgcm9sZT1cIm9wdGlvblwiXG4gICAgW3RhYmluZGV4XT1cInRhYmJhYmxlID8gMCA6IC0xXCJcbiAgICAoZm9jdXMpPVwiaXRlbUZvY3VzLmVtaXQoKVwiXG4gICAgKGJsdXIpPVwiaXRlbUJsdXIuZW1pdCgpXCJcbiAgICAoY2xpY2spPVwic2VsZWN0ZWRDaGFuZ2UuZW1pdChmYWNldClcIlxuICAgIChrZXlkb3duLmVudGVyKT1cInNlbGVjdGVkQ2hhbmdlLmVtaXQoZmFjZXQpXCJcbiAgICAoa2V5ZG93bi5zcGFjZSk9XCJzZWxlY3RlZENoYW5nZS5lbWl0KGZhY2V0KTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgIChrZXlkb3duLnNwYWNlYmFyKT1cInNlbGVjdGVkQ2hhbmdlLmVtaXQoZmFjZXQpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgW2NsYXNzLmRpc2FibGVkXT1cImZhY2V0Py5kaXNhYmxlZFwiPlxuXG4gICAgPCEtLSBTaG93IGNoZWNrIGljb24gdG8gaW5kaWNhdGUgdGhlIHN0YXRlIC0tPlxuICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtY2hlY2stbGlzdC1pdGVtLWNoZWNrXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWFjdGl2ZVwiPjwvc3Bhbj5cbiAgICA8L3NwYW4+XG5cbiAgICA8IS0tIERpc3BsYXkgdGhlIHRpdGxlIC0tPlxuICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtY2hlY2stbGlzdC1pdGVtLXRpdGxlXCI+XG4gICAgICAgIHt7IGZhY2V0Py50aXRsZSB9fVxuICAgIDwvc3Bhbj5cblxuICAgIDwhLS0gRGlzcGxheSB0aGUgY291bnQgaWYgc3BlY2lmaWVkIC0tPlxuICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtY2hlY2stbGlzdC1pdGVtLWNvdW50XCJcbiAgICAgICAgKm5nSWY9XCJmYWNldD8uY291bnQgIT09IHVuZGVmaW5lZFwiXG4gICAgICAgIGF0dHIuYXJpYS1sYWJlbD1cInt7IGZhY2V0Py5jb3VudCB9fVwiXG4gICAgICAgIGkxOG4tYXJpYS1sYWJlbD5cbiAgICAgICAgKHt7IGZhY2V0Py5jb3VudCB9fSlcbiAgICA8L3NwYW4+XG48L2Rpdj5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIEZvY3VzYWJsZU9wdGlvbiB7XG5cbiAgICBASW5wdXQoKSBmYWNldDogRmFjZXQgPSBudWxsO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgdGFiYmFibGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEZhY2V0PigpO1xuICAgIEBPdXRwdXQoKSBpdGVtRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIGl0ZW1CbHVyID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBWaWV3Q2hpbGQoJ29wdGlvbicpIG9wdGlvbjogRWxlbWVudFJlZjtcblxuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXQgJiYgdGhpcy5mYWNldC5kaXNhYmxlZDtcbiAgICB9XG5cbiAgICBnZXRMYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWNldCA/IHRoaXMuZmFjZXQudGl0bGUgOiAnJztcbiAgICB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcHRpb24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgSW5wdXQsIFF1ZXJ5TGlzdCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBGYWNldEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9iYXNlL2ZhY2V0LWJhc2UvZmFjZXQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi9tb2RlbHMvZmFjZXQnO1xuaW1wb3J0IHsgRmFjZXRDaGVja0xpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9jaGVjay1saXN0LWl0ZW0vZmFjZXQtY2hlY2stbGlzdC1pdGVtLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtY2hlY2stbGlzdCcsXG4gICAgdGVtcGxhdGU6IGA8dXgtZmFjZXQtaGVhZGVyIFtoZWFkZXJdPVwiaGVhZGVyXCIgWyhleHBhbmRlZCldPVwiZXhwYW5kZWRcIj48L3V4LWZhY2V0LWhlYWRlcj5cblxuPCEtLSBDcmVhdGUgYSBjb250YWluZXIgd2hpY2ggd2lsbCBzaG93IHdoZW4gc2VjdGlvbiBpcyBleHBhbmRlZCAtLT5cbjxkaXYgY2xhc3M9XCJmYWNldC1jaGVjay1saXN0LWNvbnRhaW5lclwiXG4gICAgdGFiaW5kZXg9XCItMVwiXG4gICAgcm9sZT1cImxpc3Rib3hcIlxuICAgIFtjbGFzcy5mYWNldC1jaGVjay1saXN0LXNjcm9sbGJhcl09XCJzY3JvbGxiYXJcIlxuICAgIFtjbGFzcy5mYWNldC1jaGVjay1saXN0LXNjcm9sbGJhci1mb2N1c2VkXT1cImlzRm9jdXNlZFwiXG4gICAgKm5nSWY9XCJleHBhbmRlZFwiPlxuXG4gICAgPCEtLSBJdGVyYXRlIHRocm91Z2ggZWFjaCBwb3NzaWJsZSBmYWNldCAtLT5cbiAgICA8dXgtZmFjZXQtY2hlY2stbGlzdC1pdGVtICpuZ0Zvcj1cImxldCBmYWNldCBvZiBmYWNldHM7IGxldCBpbmRleCA9IGluZGV4XCJcbiAgICAgICAgW2ZhY2V0XT1cImZhY2V0XCJcbiAgICAgICAgW3RhYmJhYmxlXT1cImFjdGl2ZUluZGV4ID09PSBpbmRleFwiXG4gICAgICAgIFtzZWxlY3RlZF09XCJpc0ZhY2V0U2VsZWN0ZWQoZmFjZXQpXCJcbiAgICAgICAgKHNlbGVjdGVkQ2hhbmdlKT1cInRvZ2dsZUZhY2V0KGluZGV4LCBmYWNldClcIlxuICAgICAgICAoa2V5ZG93bik9XCJvbktleWRvd24oJGV2ZW50KVwiXG4gICAgICAgIChpdGVtRm9jdXMpPVwiaXNGb2N1c2VkID0gdHJ1ZTsgb25Gb2N1cyhpbmRleClcIlxuICAgICAgICAoaXRlbUJsdXIpPVwiaXNGb2N1c2VkID0gZmFsc2VcIj5cbiAgICA8L3V4LWZhY2V0LWNoZWNrLWxpc3QtaXRlbT5cblxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldENoZWNrTGlzdENvbXBvbmVudCBleHRlbmRzIEZhY2V0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgQElucHV0KCkgZmFjZXRzOiBGYWNldFtdID0gW107XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2Nyb2xsYmFyOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBAVmlld0NoaWxkcmVuKEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudCkgb3B0aW9uczogUXVlcnlMaXN0PEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBpc0ZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhY3RpdmVJbmRleDogbnVtYmVyID0gMDtcblxuICAgIHByaXZhdGUgX2ZvY3VzS2V5TWFuYWdlcjogRm9jdXNLZXlNYW5hZ2VyPEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIodGhpcy5vcHRpb25zKVxuICAgICAgICAgICAgLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoaW5kZXggPT4gdGhpcy5hY3RpdmVJbmRleCA9IGluZGV4KTtcbiAgICB9XG5cbiAgICBvbkZvY3VzKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRmFjZXQoaW5kZXg6IG51bWJlciwgZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG4gICAgICAgIHRoaXMudG9nZ2xlRmFjZXRTZWxlY3Rpb24oZmFjZXQpO1xuICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgfVxufSIsImltcG9ydCB7IEZvY3VzYWJsZU9wdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uLy4uL21vZGVscy9mYWNldCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICNvcHRpb25cbiAgICByb2xlPVwib3B0aW9uXCJcbiAgICBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LXNlbGVjdGVkLW9wdGlvblwiXG4gICAgW2F0dHIuYXJpYS1jaGVja2VkXT1cInNlbGVjdGVkXCJcbiAgICBbdGFiaW5kZXhdPVwidGFiYmFibGUgPyAwIDogLTFcIlxuICAgIChmb2N1cyk9XCJpdGVtRm9jdXMuZW1pdCgpXCJcbiAgICAoY2xpY2spPVwic2VsZWN0ZWRDaGFuZ2UuZW1pdChmYWNldClcIlxuICAgIChrZXlkb3duLmVudGVyKT1cInNlbGVjdGVkQ2hhbmdlLmVtaXQoZmFjZXQpXCJcbiAgICAoa2V5ZG93bi5zcGFjZSk9XCJzZWxlY3RlZENoYW5nZS5lbWl0KGZhY2V0KTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgIChrZXlkb3duLnNwYWNlYmFyKT1cInNlbGVjdGVkQ2hhbmdlLmVtaXQoZmFjZXQpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG4gICAgPHV4LWNoZWNrYm94IFtjbGlja2FibGVdPVwiZmFsc2VcIiBbdmFsdWVdPVwic2VsZWN0ZWRcIiBbc2ltcGxpZmllZF09XCJzaW1wbGlmaWVkXCIgW3RhYmluZGV4XT1cIi0xXCIgW2Rpc2FibGVkXT1cImRpc2FibGVkXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtc2VsZWN0ZWQtb3B0aW9uLXRpdGxlXCI+e3sgZmFjZXQ/LnRpdGxlIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LXNlbGVjdGVkLW9wdGlvbi1jb3VudFwiPih7eyBmYWNldD8uY291bnQgfX0pPC9zcGFuPlxuICAgIDwvdXgtY2hlY2tib3g+XG5cbjwvZGl2PmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRUeXBlYWhlYWRMaXN0SXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIEZvY3VzYWJsZU9wdGlvbiB7XG5cbiAgICBASW5wdXQoKSBmYWNldDogRmFjZXQ7XG4gICAgQElucHV0KCkgc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzaW1wbGlmaWVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgdGFiYmFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKSBpdGVtRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldD4oKTtcblxuICAgIEBWaWV3Q2hpbGQoJ29wdGlvbicpIG9wdGlvbjogRWxlbWVudFJlZjtcblxuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXQgJiYgdGhpcy5mYWNldC5kaXNhYmxlZDtcbiAgICB9XG5cbiAgICBnZXRMYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWNldCA/IHRoaXMuZmFjZXQudGl0bGUgOiBudWxsO1xuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wdGlvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRm9jdXNLZXlNYW5hZ2VyLCBMaXZlQW5ub3VuY2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgUGlwZSwgUGlwZVRyYW5zZm9ybSwgUXVlcnlMaXN0LCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgbWFwLCBtZXJnZU1hcCwgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUeXBlYWhlYWRLZXlTZXJ2aWNlLCBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4uLy4uL3R5cGVhaGVhZC9pbmRleCc7XG5pbXBvcnQgeyBGYWNldEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9iYXNlL2ZhY2V0LWJhc2UvZmFjZXQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXRDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuLi9mYWNldC1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi4vbW9kZWxzL2ZhY2V0JztcbmltcG9ydCB7IEZhY2V0VHlwZWFoZWFkTGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL3R5cGVhaGVhZC1saXN0LWl0ZW0vZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbS5jb21wb25lbnQnO1xuXG5sZXQgdW5pcXVlSWQgPSAxO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LXR5cGVhaGVhZC1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDx1eC1mYWNldC1oZWFkZXIgW2hlYWRlcl09XCJoZWFkZXJcIiBbKGV4cGFuZGVkKV09XCJleHBhbmRlZFwiPjwvdXgtZmFjZXQtaGVhZGVyPlxuXG48ZGl2IGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3QtY29udGFpbmVyXCIgcm9sZT1cImxpc3Rib3hcIiAqbmdJZj1cImV4cGFuZGVkXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtc2VsZWN0ZWQtY29udGFpbmVyXCIgdGFiaW5kZXg9XCItMVwiICpuZ0lmPVwic3VnZ2VzdGlvbnM/Lmxlbmd0aCA+IDBcIj5cblxuICAgICAgICA8dXgtZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbVxuICAgICAgICAgICAgKm5nRm9yPVwibGV0IGZhY2V0IG9mIHN1Z2dlc3Rpb25zOyBsZXQgaW5kZXggPSBpbmRleFwiXG4gICAgICAgICAgICBbZmFjZXRdPVwiZmFjZXRcIlxuICAgICAgICAgICAgW3RhYmJhYmxlXT1cImFjdGl2ZUluZGV4ID09PSBpbmRleFwiXG4gICAgICAgICAgICBbc2VsZWN0ZWRdPVwiaXNGYWNldFNlbGVjdGVkKGZhY2V0KVwiXG4gICAgICAgICAgICAoc2VsZWN0ZWRDaGFuZ2UpPVwidG9nZ2xlRmFjZXQoaW5kZXgsIGZhY2V0KVwiXG4gICAgICAgICAgICAoa2V5ZG93bik9XCJvbktleWRvd24oJGV2ZW50KVwiXG4gICAgICAgICAgICAoaXRlbUZvY3VzKT1cIm9uRm9jdXMoaW5kZXgpXCI+XG4gICAgICAgIDwvdXgtZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbT5cblxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LWNvbnRyb2xcIj5cblxuICAgICAgICA8IS0tIENyZWF0ZSBUeXBlYWhlYWQgQ29udHJvbCAtLT5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJ0eXBlYWhlYWRDb25maWc/LnBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudF09XCJoaWdobGlnaHRlZEVsZW1lbnQ/LmlkXCJcbiAgICAgICAgICAgIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiXG4gICAgICAgICAgICBhcmlhLW11bHRpbGluZT1cImZhbHNlXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY29udHJvbHNdPVwidHlwZWFoZWFkSWRcIlxuICAgICAgICAgICAgW25nTW9kZWxdPVwicXVlcnkkIHwgYXN5bmNcIlxuICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwicXVlcnkkLm5leHQoJGV2ZW50KTsgdXBkYXRlVHlwZWFoZWFkKCRldmVudClcIlxuICAgICAgICAgICAgKGtleWRvd24pPVwidHlwZWFoZWFkS2V5U2VydmljZS5oYW5kbGVLZXkoJGV2ZW50LCB0eXBlYWhlYWQpXCJcbiAgICAgICAgICAgIChibHVyKT1cInR5cGVhaGVhZE9wZW4gPSBmYWxzZVwiPlxuXG4gICAgICAgIDx1eC10eXBlYWhlYWQgI3R5cGVhaGVhZFxuICAgICAgICAgICAgW2lkXT1cInR5cGVhaGVhZElkXCJcbiAgICAgICAgICAgIFsob3BlbildPVwidHlwZWFoZWFkT3BlblwiXG4gICAgICAgICAgICBbbG9hZGluZ109XCJsb2FkaW5nXCJcbiAgICAgICAgICAgIGRpc3BsYXk9XCJ0aXRsZVwiXG4gICAgICAgICAgICBbb3B0aW9uc109XCJ0eXBlYWhlYWRPcHRpb25zXCJcbiAgICAgICAgICAgIFtvcHRpb25UZW1wbGF0ZV09XCJmYWNldE9wdGlvblRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtzZWxlY3RPbkVudGVyXT1cInRydWVcIlxuICAgICAgICAgICAgKG9wdGlvblNlbGVjdGVkKT1cInNlbGVjdCgkZXZlbnQpXCJcbiAgICAgICAgICAgIChoaWdobGlnaHRlZEVsZW1lbnRDaGFuZ2UpPVwiaGlnaGxpZ2h0ZWRFbGVtZW50ID0gJGV2ZW50XCI+XG4gICAgICAgIDwvdXgtdHlwZWFoZWFkPlxuXG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2ZhY2V0T3B0aW9uVGVtcGxhdGUgbGV0LW9wdGlvbj1cIm9wdGlvblwiIGxldC1hcGk9XCJhcGlcIj5cbiAgICA8cCBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LW9wdGlvblwiIFthdHRyLmFyaWEtbGFiZWxdPVwib3B0aW9uLnRpdGxlXCI+XG4gICAgICAgIDxzcGFuIFtpbm5lckhUTUxdPVwib3B0aW9uLnRpdGxlIHwgZmFjZXRUeXBlYWhlYWRIaWdobGlnaHQ6IChxdWVyeSQgfCBhc3luYylcIj48L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtb3B0aW9uLWNvdW50XCJcbiAgICAgICAgICAgICpuZ0lmPVwib3B0aW9uLmNvdW50XCI+XG4gICAgICAgICAgICAoe3sgb3B0aW9uLmNvdW50IH19KVxuICAgICAgICA8L3NwYW4+XG4gICAgPC9wPlxuPC9uZy10ZW1wbGF0ZT5gXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0VHlwZWFoZWFkTGlzdENvbXBvbmVudCBleHRlbmRzIEZhY2V0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgQElucHV0KCkgZmFjZXRzOiBGYWNldFtdIHwgT2JzZXJ2YWJsZTxGYWNldFtdPjtcbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc3VnZ2VzdGlvbnM6IEZhY2V0W10gPSBbXTtcbiAgICBASW5wdXQoKSBzaW1wbGlmaWVkOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHR5cGVhaGVhZENvbmZpZyhjb25maWc6IEZhY2V0VHlwZWFoZWFkTGlzdENvbmZpZykge1xuICAgICAgICB0aGlzLl9jb25maWcgPSB7IHBsYWNlaG9sZGVyOiAnJywgbWF4UmVzdWx0czogNTAsIG1pbkNoYXJhY3RlcnM6IDEsIC4uLmNvbmZpZyB9O1xuICAgIH1cblxuICAgIGdldCB0eXBlYWhlYWRDb25maWcoKTogRmFjZXRUeXBlYWhlYWRMaXN0Q29uZmlnIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG5cbiAgICBAVmlld0NoaWxkcmVuKEZhY2V0VHlwZWFoZWFkTGlzdEl0ZW1Db21wb25lbnQpIG9wdGlvbnM6IFF1ZXJ5TGlzdDxGYWNldFR5cGVhaGVhZExpc3RJdGVtQ29tcG9uZW50PjtcblxuICAgIHF1ZXJ5JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XG4gICAgbG9hZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGFjdGl2ZUluZGV4OiBudW1iZXIgPSAwO1xuICAgIHR5cGVhaGVhZElkOiBzdHJpbmcgPSBgdXgtZmFjZXQtdHlwZWFoZWFkLSR7dW5pcXVlSWQrK31gO1xuICAgIHR5cGVhaGVhZE9wZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICB0eXBlYWhlYWRPcHRpb25zOiBGYWNldFtdID0gW107XG4gICAgaGlnaGxpZ2h0ZWRFbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICAgIHByaXZhdGUgX2NvbmZpZzogRmFjZXRUeXBlYWhlYWRMaXN0Q29uZmlnID0geyBwbGFjZWhvbGRlcjogJycsIG1heFJlc3VsdHM6IDUwLCBtaW5DaGFyYWN0ZXJzOiAxIH07XG4gICAgcHJpdmF0ZSBfZm9jdXNLZXlNYW5hZ2VyOiBGb2N1c0tleU1hbmFnZXI8RmFjZXRUeXBlYWhlYWRMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdHlwZWFoZWFkS2V5U2VydmljZTogVHlwZWFoZWFkS2V5U2VydmljZSwgZmFjZXRDb250YWluZXI6IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50LCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9hbm5vdW5jZXI6IExpdmVBbm5vdW5jZXIpIHtcbiAgICAgICAgc3VwZXIoZmFjZXRDb250YWluZXIsIGVsZW1lbnRSZWYpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzZXQgdXAgc2VhcmNoIHF1ZXJ5IHN1YnNjcmlwdGlvblxuICAgICAgICB0aGlzLnF1ZXJ5JC5waXBlKFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlYWhlYWRPcHRpb25zID0gW107XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1lcmdlTWFwKCgpID0+IHRoaXMuZ2V0RmFjZXRPYnNlcnZhYmxlKCkucGlwZShtYXAoZmFjZXRzID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjZXRzLmZpbHRlcihmYWNldCA9PiAhZmFjZXQuZGlzYWJsZWQgJiYgIXRoaXMuc2VsZWN0ZWQuZmluZChzZWxlY3RlZEZhY2V0ID0+IHNlbGVjdGVkRmFjZXQgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIHRoaXMuX2NvbmZpZy5tYXhSZXN1bHRzKTtcbiAgICAgICAgICAgIH0pKSlcbiAgICAgICAgKS5zdWJzY3JpYmUoZmFjZXRzID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50eXBlYWhlYWRPcHRpb25zID0gZmFjZXRzO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIgPSBuZXcgRm9jdXNLZXlNYW5hZ2VyKHRoaXMub3B0aW9ucykud2l0aFZlcnRpY2FsT3JpZW50YXRpb24oKTtcbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoaW5kZXggPT4gdGhpcy5hY3RpdmVJbmRleCA9IGluZGV4KTtcbiAgICB9XG5cbiAgICBvbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgfVxuXG4gICAgb25Gb2N1cyhpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c0tleU1hbmFnZXIuYWN0aXZlSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0oaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlRmFjZXQoaW5kZXg6IG51bWJlciwgZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG4gICAgICAgIHRoaXMudG9nZ2xlRmFjZXRTZWxlY3Rpb24oZmFjZXQpO1xuICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqIE9ubHkgc2hvdyB0eXBlYWhlYWQgaWYgd2UgaGF2ZSBlbm91Z2ggY2hhcmFjdGVycyAqL1xuICAgIHVwZGF0ZVR5cGVhaGVhZChxdWVyeTogc3RyaW5nID0gJycpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50eXBlYWhlYWRPcGVuID0gcXVlcnkubGVuZ3RoID49IHRoaXMuX2NvbmZpZy5taW5DaGFyYWN0ZXJzO1xuICAgIH1cblxuICAgIGdldEZhY2V0T2JzZXJ2YWJsZSgpOiBPYnNlcnZhYmxlPEZhY2V0W10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXRzIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSA/IHRoaXMuZmFjZXRzIDogb2YodGhpcy5mYWNldHMpO1xuICAgIH1cblxuICAgIHNlbGVjdChldmVudDogVHlwZWFoZWFkT3B0aW9uRXZlbnQpIHtcblxuICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCB0aGUgaXRlbSBpcyBub3QgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmZpbmQoZmFjZXQgPT4gZmFjZXQgPT09IGV2ZW50Lm9wdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlbGVjdCB0aGUgZmFjZXRcbiAgICAgICAgdGhpcy5zZWxlY3RGYWNldChldmVudC5vcHRpb24pO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSB0eXBlYWhlYWRcbiAgICAgICAgdGhpcy5xdWVyeSQubmV4dCgnJyk7XG5cbiAgICAgICAgLy8gYW5ub3VuY2UgdGhlIHNlbGVjdGVkIGZhY2V0XG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgJHsoZXZlbnQub3B0aW9uIGFzIEZhY2V0KS50aXRsZX0gc2VsZWN0ZWQuYCk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZhY2V0VHlwZWFoZWFkTGlzdENvbmZpZyB7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgbWluQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtYXhSZXN1bHRzPzogbnVtYmVyO1xuICAgIGRlbGF5PzogbnVtYmVyO1xufVxuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2ZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0J1xufSlcbmV4cG9ydCBjbGFzcyBGYWNldFR5cGVhaGVhZEhpZ2hsaWdodCBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nLCBzZWFyY2hRdWVyeTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cChzZWFyY2hRdWVyeSwgJ2knKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVnZXgsIGA8YiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1oaWdobGlnaHRlZFwiPiR7dmFsdWUubWF0Y2gocmVnZXgpfTwvYj5gKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBDaGVja2JveE1vZHVsZSB9IGZyb20gJy4uL2NoZWNrYm94L2luZGV4JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZU1vZHVsZSB9IGZyb20gJy4vLi4vLi4vZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS5tb2R1bGUnO1xuaW1wb3J0IHsgRmFjZXRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi9iYXNlL2ZhY2V0LWJhc2UvZmFjZXQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXRIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2Jhc2UvZmFjZXQtaGVhZGVyL2ZhY2V0LWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXRDaGVja0xpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9mYWNldC1jaGVjay1saXN0L2NoZWNrLWxpc3QtaXRlbS9mYWNldC1jaGVjay1saXN0LWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0Q2hlY2tMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi9mYWNldC1jaGVjay1saXN0L2ZhY2V0LWNoZWNrLWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9mYWNldC1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0LCBGYWNldFR5cGVhaGVhZExpc3RDb21wb25lbnQgfSBmcm9tICcuL2ZhY2V0LXR5cGVhaGVhZC1saXN0L2ZhY2V0LXR5cGVhaGVhZC1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldFR5cGVhaGVhZExpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9mYWNldC10eXBlYWhlYWQtbGlzdC90eXBlYWhlYWQtbGlzdC1pdGVtL2ZhY2V0LXR5cGVhaGVhZC1saXN0LWl0ZW0uY29tcG9uZW50JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIEZhY2V0Q29udGFpbmVyQ29tcG9uZW50LFxuICAgIEZhY2V0SGVhZGVyQ29tcG9uZW50LFxuICAgIEZhY2V0QmFzZUNvbXBvbmVudCxcbiAgICBGYWNldENoZWNrTGlzdENvbXBvbmVudCxcbiAgICBGYWNldENoZWNrTGlzdEl0ZW1Db21wb25lbnQsXG4gICAgRmFjZXRUeXBlYWhlYWRMaXN0Q29tcG9uZW50LFxuICAgIEZhY2V0VHlwZWFoZWFkTGlzdEl0ZW1Db21wb25lbnQsXG4gICAgRmFjZXRUeXBlYWhlYWRIaWdobGlnaHRcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBBMTF5TW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBDaGVja2JveE1vZHVsZSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZSxcbiAgICAgICAgUmVvcmRlcmFibGVNb2R1bGUsXG4gICAgICAgIFR5cGVhaGVhZE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0c01vZHVsZSB7IH1cbiIsImV4cG9ydCBjbGFzcyBGYWNldCB7XG4gICAgXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyB0aXRsZTogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgZGF0YTogYW55ID0ge30sXG4gICAgICAgIHB1YmxpYyBjb3VudD86IG51bWJlcixcbiAgICAgICAgcHVibGljIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2UsXG4gICAgICAgIHB1YmxpYyBpZD86IHN0cmluZyB8IG51bWJlclxuICAgICkgeyB9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25TZXJ2aWNlIHtcblxuICAgIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZT4obnVsbCk7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhNZW51TmF2aWdhdGlvbkl0ZW1dJ1xufSlcbmV4cG9ydCBjbGFzcyBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQE91dHB1dCgpIGFjdGl2YXRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3Ioc2VydmljZTogTWVudU5hdmlnYXRpb25TZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHNlcnZpY2UuYWN0aXZlJC5zdWJzY3JpYmUoKG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEFjdGl2ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkLmVtaXQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TWVudU5hdmlnYXRpb25dJyxcbiAgICBleHBvcnRBczogJ3V4TWVudU5hdmlnYXRpb24nLFxuICAgIHByb3ZpZGVyczogW01lbnVOYXZpZ2F0aW9uU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKVxuICAgIHRvZ2dsZUJ1dHRvbjogTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmU7XG5cbiAgICBASW5wdXQoKVxuICAgIHRvZ2dsZUJ1dHRvblBvc2l0aW9uOiAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JyA9ICd0b3AnO1xuXG4gICAgQE91dHB1dCgpXG4gICAgbmF2aWdhdGVkT3V0ID0gbmV3IEV2ZW50RW1pdHRlcjxLZXlib2FyZEV2ZW50PigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBpdGVtczogUXVlcnlMaXN0PE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZT47XG5cbiAgICBnZXQgYWN0aXZlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zT3JkZXJlZC5pbmRleE9mKHRoaXMuX3NlcnZpY2UuYWN0aXZlJC52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaXRlbXNPcmRlcmVkOiBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmVbXTtcblxuICAgIHByaXZhdGUgX2RvY3VtZW50OiBhbnk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfc2VydmljZTogTWVudU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBkb2N1bWVudDogYW55XG4gICAgKSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbi5rZXlFbnRlci5zdWJzY3JpYmUodGhpcy5mb2N1c0ZpcnN0LmJpbmQodGhpcykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICB0aGlzLml0ZW1zLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc09yZGVyZWQgPSB0aGlzLml0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5faXRlbXNPcmRlcmVkID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGZvY3VzRmlyc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW92ZUZpcnN0KCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6a2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAga2V5ZG93bkhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBPbmx5IGhhbmRsZSBldmVudHMgd2hlbiBmb2N1cyBpbiB3aXRoaW4gdGhlIGxpc3Qgb2YgbWVudSBpdGVtc1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgIGNhc2UgJ1VwJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVQcmV2aW91cyhldmVudCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVOZXh0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ0xlZnQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnUmlnaHQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVGaXJzdCgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUxhc3QoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlZE91dC5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVOZXh0KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGVyZSdzIG5vIGFjdGl2ZSBtZW51IGl0ZW0gcmVnaXN0ZXJlZFxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggKyAxO1xuICAgICAgICBpZiAobmV4dEluZGV4IDwgdGhpcy5faXRlbXNPcmRlcmVkLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBBY3RpdmF0ZSB0aGUgbmV4dCBtZW51IGl0ZW1cbiAgICAgICAgICAgIC8vICh1eE1lbnVOYXZpZ2F0aW9uSXRlbSBzdWJzY3JpYmVzIHRvIHRoaXMgYW5kIGFwcGxpZXMgZm9jdXMgaWYgaXQgbWF0Y2hlcylcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFtuZXh0SW5kZXhdKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmb2N1cyB3ZW50IG91dCBvZiBib3VuZHMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZVByZXZpb3VzKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGVyZSdzIG5vIGFjdGl2ZSBtZW51IGl0ZW0gcmVnaXN0ZXJlZFxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggLSAxO1xuICAgICAgICBpZiAobmV4dEluZGV4ID49IDApIHtcblxuICAgICAgICAgICAgLy8gQWN0aXZhdGUgdGhlIHByZXZpb3VzIG1lbnUgaXRlbVxuICAgICAgICAgICAgLy8gKHV4TWVudU5hdmlnYXRpb25JdGVtIHN1YnNjcmliZXMgdG8gdGhpcyBhbmQgYXBwbGllcyBmb2N1cyBpZiBpdCBtYXRjaGVzKVxuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmUkLm5leHQodGhpcy5faXRlbXNPcmRlcmVkW25leHRJbmRleF0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvY3VzIHdlbnQgb3V0IG9mIGJvdW5kcyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBvcmlnaW4gdG9nZ2xlIGJ1dHRvblxuICAgICAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uUG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlRmlyc3QoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtc09yZGVyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmUkLm5leHQodGhpcy5faXRlbXNPcmRlcmVkWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZUxhc3QoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtc09yZGVyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmUkLm5leHQodGhpcy5faXRlbXNPcmRlcmVkW3RoaXMuX2l0ZW1zT3JkZXJlZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbi5tZW51T3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0ZWRPdXQuZW1pdChldmVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhNZW51TmF2aWdhdGlvblRvZ2dsZV0nLFxuICAgIGV4cG9ydEFzOiAndXhNZW51TmF2aWdhdGlvblRvZ2dsZSdcbn0pXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgbWVudU9wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZW51T3BlbjtcbiAgICB9XG5cbiAgICBzZXQgbWVudU9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbWVudU9wZW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZW51T3BlbkNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIG1lbnVQb3NpdGlvbjogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCcgPSAnYm90dG9tJztcblxuICAgIEBPdXRwdXQoKVxuICAgIG1lbnVPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAga2V5RW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBwcml2YXRlIF9tZW51T3BlbjogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNLZXlNYXRjaChldmVudC5rZXkpKSB7XG5cbiAgICAgICAgICAgIC8vIE9wZW4gdGhlIG1lbnVcbiAgICAgICAgICAgIHRoaXMubWVudU9wZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgbWVudSB0byBpbml0LCB0aGVuIHNlbmQgdGhlIGV2ZW50IHRvIGdpdmUgaXQgZm9jdXNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5RW50ZXIuZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaXNLZXlNYXRjaChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ3RvcCc7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZW51UG9zaXRpb24gPT09ICdib3R0b20nO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudVBvc2l0aW9uID09PSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnUmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25EaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlJztcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBNZW51TmF2aWdhdGlvbkRpcmVjdGl2ZSxcbiAgICBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUsXG4gICAgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogRVhQT1JUUyxcbiAgICBkZWNsYXJhdGlvbnM6IEVYUE9SVFMsXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1maWx0ZXItY29udGFpbmVyJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblxuPCEtLSBBZGQgYSBDbGVhciBCdXR0b24gLS0+XG48YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1saW5rIGJ0bi1pY29uIGJ0bi1zZWNvbmRhcnkgbS1sLXhzXCJcbiAgICB0YWJpbmRleD1cIjBcIlxuICAgIGFyaWEtbGFiZWw9XCJDbGVhciBhbGwgZmlsdGVyc1wiXG4gICAgaTE4bi1hcmlhLWxhYmVsXG4gICAgKm5nSWY9XCJmaWx0ZXJzLmxlbmd0aCA+IDBcIlxuICAgIFt1eFRvb2x0aXBdPVwiY2xlYXJUb29sdGlwIHx8ICdDbGVhciBBbGwnXCJcbiAgICAoY2xpY2spPVwicmVtb3ZlQWxsKClcIj5cblxuICAgIDxzdmcgY2xhc3M9XCJmaWx0ZXItc2VsZWN0ZWQtY2xlYXItZ3JhcGhpY1wiIHdpZHRoPVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMTkgMTJcIiBzaGFwZS1yZW5kZXJpbmc9XCJnZW9tZXRyaWNQcmVjaXNpb25cIj5cbiAgICAgICAgPHJlY3QgY2xhc3M9XCJsaWdodC1ncmV5XCIgeD1cIjBcIiB5PVwiMlwiIHdpZHRoPVwiN1wiIGhlaWdodD1cIjJcIj48L3JlY3Q+XG4gICAgICAgIDxyZWN0IGNsYXNzPVwiZGFyay1ncmV5XCIgeD1cIjBcIiB5PVwiNVwiIHdpZHRoPVwiOVwiIGhlaWdodD1cIjJcIj48L3JlY3Q+XG4gICAgICAgIDxyZWN0IGNsYXNzPVwibGlnaHQtZ3JleVwiIHg9XCIwXCIgeT1cIjhcIiB3aWR0aD1cIjdcIiBoZWlnaHQ9XCIyXCI+PC9yZWN0PlxuICAgICAgICA8cGF0aCBjbGFzcz1cImRhcmstZ3JleVwiIGQ9XCJNOSwxIGgxIGw5LDkgdjEgaC0xIGwtOSwtOSB2LTEgWlwiPjwvcGF0aD5cbiAgICAgICAgPHBhdGggY2xhc3M9XCJkYXJrLWdyZXlcIiBkPVwiTTksMTEgdi0xIGw5LC05IGgxIHYxIGwtOSw5IGgtMSBaXCI+PC9wYXRoPlxuICAgIDwvc3ZnPlxuXG48L2J1dHRvbj5gXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBmaWx0ZXJzOiBGaWx0ZXJbXSA9IFtdO1xuICAgIEBJbnB1dCgpIGNsZWFyVG9vbHRpcDogc3RyaW5nO1xuICAgIEBPdXRwdXQoKSBmaWx0ZXJzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmlsdGVyW10+ID0gbmV3IEV2ZW50RW1pdHRlcjxGaWx0ZXJbXT4oKTtcbiAgICBAT3V0cHV0KCkgZXZlbnRzOiBFdmVudEVtaXR0ZXI8RmlsdGVyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxGaWx0ZXJFdmVudD4oKTtcblxuXG4gICAgYWRkRmlsdGVyKGZpbHRlcjogRmlsdGVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgIHRoaXMuZXZlbnRzLm5leHQobmV3IEZpbHRlckFkZEV2ZW50KGZpbHRlcikpO1xuICAgICAgICB0aGlzLmZpbHRlcnNDaGFuZ2UuZW1pdCh0aGlzLmZpbHRlcnMpO1xuICAgIH1cblxuICAgIHJlbW92ZUZpbHRlcihmaWx0ZXI6IEZpbHRlcik6IHZvaWQge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5maWx0ZXJzLmZpbmRJbmRleChmaWx0ZXJzID0+IGZpbHRlcnMgPT09IGZpbHRlcik7XG5cbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm5leHQobmV3IEZpbHRlclJlbW92ZUV2ZW50KGZpbHRlcikpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzQ2hhbmdlLmVtaXQodGhpcy5maWx0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dChuZXcgRmlsdGVyUmVtb3ZlQWxsRXZlbnQoKSk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyIHtcbiAgICBncm91cDogc3RyaW5nO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGluaXRpYWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgRmlsdGVyQWRkRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEZpbHRlcikge31cbn1cblxuZXhwb3J0IGNsYXNzIEZpbHRlclJlbW92ZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZmlsdGVyOiBGaWx0ZXIpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBGaWx0ZXJSZW1vdmVBbGxFdmVudCB7XG59XG5cbmV4cG9ydCB0eXBlIEZpbHRlckV2ZW50ID0gRmlsdGVyQWRkRXZlbnQgfCBGaWx0ZXJSZW1vdmVFdmVudCB8IEZpbHRlclJlbW92ZUFsbEV2ZW50OyIsIlxuaW1wb3J0IHsgTGl2ZUFubm91bmNlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdCwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJDb250YWluZXJDb21wb25lbnQsIEZpbHRlclJlbW92ZUFsbEV2ZW50IH0gZnJvbSAnLi4vZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3V4LWZpbHRlci1iYXNlJ1xufSlcbmV4cG9ydCBjbGFzcyBGaWx0ZXJCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGZpbHRlcnM6IEZpbHRlcltdO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihASG9zdCgpIHByaXZhdGUgZmlsdGVyc0NvbnRhaW5lcjogRmlsdGVyQ29udGFpbmVyQ29tcG9uZW50LCBwcml2YXRlIF9hbm5vdW5jZXI6IExpdmVBbm5vdW5jZXIpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gZmlsdGVyc0NvbnRhaW5lci5ldmVudHMucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBGaWx0ZXJSZW1vdmVBbGxFdmVudCkpLnN1YnNjcmliZSh0aGlzLnJlbW92ZUZpbHRlci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgYWRkRmlsdGVyKF9maWx0ZXI6IEZpbHRlcik6IHZvaWQge1xuICAgICAgICBpZiAoIV9maWx0ZXIuaW5pdGlhbCkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzQ29udGFpbmVyLmFkZEZpbHRlcihfZmlsdGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgRmlsdGVyICR7X2ZpbHRlci5uYW1lfSBzZWxlY3RlZC5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUZpbHRlcihfZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFfZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbHRlcnNDb250YWluZXIucmVtb3ZlRmlsdGVyKF9maWx0ZXIpO1xuICAgICAgICB0aGlzLl9hbm5vdW5jZXIuYW5ub3VuY2UoYEZpbHRlciAke19maWx0ZXIubmFtZX0gZGVzZWxlY3RlZC5gKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWx0ZXJCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZmlsdGVyLWJhc2UvZmlsdGVyLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1maWx0ZXItZHJvcGRvd24nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImJ0bi1ncm91cFwiIGRyb3Bkb3duIFthdXRvQ2xvc2VdPVwidHJ1ZVwiICNkcm9wZG93bj1cImJzLWRyb3Bkb3duXCI+XG5cbiAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICBkcm9wZG93blRvZ2dsZVxuICAgICAgICB1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlXG4gICAgICAgICNtZW51TmF2aWdhdGlvblRvZ2dsZT1cInV4TWVudU5hdmlnYXRpb25Ub2dnbGVcIlxuICAgICAgICBbKG1lbnVPcGVuKV09XCJkcm9wZG93bi5pc09wZW5cIlxuICAgICAgICBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiXG4gICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiZHJvcGRvd24uaXNPcGVuXCJcbiAgICAgICAgY2xhc3M9XCJmaWx0ZXItZHJvcGRvd24gYnRuIGRyb3Bkb3duLXRvZ2dsZVwiXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVwic2VsZWN0ZWQgIT09IGluaXRpYWxcIj5cbiAgICAgICAge3sgc2VsZWN0ZWQ/LnRpdGxlIH19XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWRvd25cIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG5cbiAgICA8dWwgKmRyb3Bkb3duTWVudVxuICAgICAgICB1eE1lbnVOYXZpZ2F0aW9uXG4gICAgICAgIFt0b2dnbGVCdXR0b25dPVwibWVudU5hdmlnYXRpb25Ub2dnbGVcIlxuICAgICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIiByb2xlPVwibWVudVwiPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIGZpbHRlcnNcIlxuICAgICAgICAgICAgcm9sZT1cIm5vbmVcIj5cblxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICByb2xlPVwibGlzdGl0ZW1cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIHV4TWVudU5hdmlnYXRpb25JdGVtXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJmaWx0ZXIgPT09IHNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0RmlsdGVyKGZpbHRlciwgJGV2ZW50KTsgZHJvcGRvd24uaGlkZSgpOyBtZW51TmF2aWdhdGlvblRvZ2dsZS5mb2N1cygpXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJzZWxlY3RGaWx0ZXIoZmlsdGVyLCAkZXZlbnQpOyBkcm9wZG93bi5oaWRlKCk7IG1lbnVOYXZpZ2F0aW9uVG9nZ2xlLmZvY3VzKClcIj5cblxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb25cIiBbY2xhc3MuaHBlLWNoZWNrbWFya109XCJmaWx0ZXIgPT09IHNlbGVjdGVkXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duLXRpdGxlXCI+e3sgZmlsdGVyLm5hbWUgfX08L3NwYW4+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cbjwvZGl2PmAsXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckRyb3Bkb3duQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyQmFzZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBpbml0aWFsOiBGaWx0ZXI7XG5cbiAgICBzZWxlY3RlZDogRmlsdGVyO1xuXG4gICAgcmVtb3ZlRmlsdGVyKCk6IHZvaWQge1xuICAgICAgICBzdXBlci5yZW1vdmVGaWx0ZXIodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgfVxuXG4gICAgc2VsZWN0RmlsdGVyKGZpbHRlcjogRmlsdGVyLCBldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmlsdGVyO1xuICAgICAgICB0aGlzLmFkZEZpbHRlcih0aGlzLnNlbGVjdGVkKTtcblxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBMaXZlQW5ub3VuY2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgUGlwZSwgUGlwZVRyYW5zZm9ybSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duRGlyZWN0aXZlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBUeXBlYWhlYWRNYXRjaCB9IGZyb20gJ25neC1ib290c3RyYXAvdHlwZWFoZWFkJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFR5cGVhaGVhZEtleVNlcnZpY2UsIFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IEZpbHRlckJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuLi9maWx0ZXItY29udGFpbmVyLmNvbXBvbmVudCc7XG5cbmxldCB1bmlxdWVJZCA9IDE7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmlsdGVyLWR5bmFtaWMnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCB1eC1keW5hbWljLWZpbHRlclwiXG4gICAgZHJvcGRvd25cbiAgICBbYXV0b0Nsb3NlXT1cInRydWVcIlxuICAgICNkeW5hbWljRHJvcGRvd249XCJicy1kcm9wZG93blwiPlxuXG4gICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgZHJvcGRvd25Ub2dnbGVcbiAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgICAgICB1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlXG4gICAgICAgICNtZW51TmF2aWdhdGlvblRvZ2dsZT1cInV4TWVudU5hdmlnYXRpb25Ub2dnbGVcIlxuICAgICAgICBbKG1lbnVPcGVuKV09XCJkeW5hbWljRHJvcGRvd24uaXNPcGVuXCJcbiAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJkeW5hbWljRHJvcGRvd24uaXNPcGVuXCJcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJzZWxlY3RlZCAhPT0gaW5pdGlhbFwiXG4gICAgICAgIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duIGJ0biBkcm9wZG93bi10b2dnbGVcIj5cbiAgICAgICAge3sgc2VsZWN0ZWQ/LnRpdGxlIH19XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWRvd25cIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG5cbiAgICA8dWwgKmRyb3Bkb3duTWVudVxuICAgICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIlxuICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25cbiAgICAgICAgW3RvZ2dsZUJ1dHRvbl09XCJtZW51TmF2aWdhdGlvblRvZ2dsZVwiPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiXG4gICAgICAgICAgICAqbmdJZj1cInNob3dUeXBlYWhlYWRcIlxuICAgICAgICAgICAgcm9sZT1cIm5vbmVcIj5cblxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICByb2xlPVwibWVudWl0ZW1cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIHV4TWVudU5hdmlnYXRpb25JdGVtXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpbml0aWFsID09PSBzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInJlbW92ZUZpbHRlcigpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBkeW5hbWljRHJvcGRvd24uaGlkZSgpOyBtZW51TmF2aWdhdGlvblRvZ2dsZS5mb2N1cygpXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJyZW1vdmVGaWx0ZXIoKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKTsgZHluYW1pY0Ryb3Bkb3duLmhpZGUoKTsgbWVudU5hdmlnYXRpb25Ub2dnbGUuZm9jdXMoKVwiPlxuXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvblwiIFtjbGFzcy5ocGUtY2hlY2ttYXJrXT1cImluaXRpYWwgPT09IHNlbGVjdGVkXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duLXRpdGxlXCI+e3sgaW5pdGlhbC5uYW1lIH19PC9zcGFuPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiXG4gICAgICAgICAgICAqbmdJZj1cInNlbGVjdGVkICE9PSBpbml0aWFsICYmIHNob3dUeXBlYWhlYWRcIlxuICAgICAgICAgICAgcm9sZT1cIm5vbmVcIj5cblxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICByb2xlPVwibWVudWl0ZW1cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIHV4TWVudU5hdmlnYXRpb25JdGVtPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb24gaHBlLWNoZWNrbWFya1wiPjwvaT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZpbHRlci1kcm9wZG93bi10aXRsZVwiPnt7IHNlbGVjdGVkLm5hbWUgfX08L3NwYW4+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPGhyPlxuXG4gICAgICAgIDxsaSAqbmdJZj1cInNob3dUeXBlYWhlYWRcIiBjbGFzcz1cInR5cGVhaGVhZC1ib3hcIiByb2xlPVwibm9uZVwiPlxuXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwib3B0aW9ucz8ucGxhY2Vob2xkZXIgfHwgZGVmYXVsdE9wdGlvbnMucGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiaGlnaGxpZ2h0ZWRFbGVtZW50Py5pZFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtY29udHJvbHNdPVwidHlwZWFoZWFkSWRcIlxuICAgICAgICAgICAgICAgICAgICBhcmlhLWF1dG9jb21wbGV0ZT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICBhcmlhLW11bHRpbGluZT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW25nTW9kZWxdPVwicXVlcnkkIHwgYXN5bmNcIlxuICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJxdWVyeSQubmV4dCgkZXZlbnQpOyB1cGRhdGVUeXBlYWhlYWQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZXlkb3duKT1cInR5cGVhaGVhZEtleVNlcnZpY2UuaGFuZGxlS2V5KCRldmVudCwgdHlwZWFoZWFkKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1wiXG4gICAgICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgICAgICAgICAgICAgKGJsdXIpPVwidHlwZWFoZWFkT3BlbiA9IGZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiPlxuXG4gICAgICAgICAgICAgICAgPHV4LXR5cGVhaGVhZCAjdHlwZWFoZWFkXG4gICAgICAgICAgICAgICAgICAgIFtpZF09XCJ0eXBlYWhlYWRJZFwiXG4gICAgICAgICAgICAgICAgICAgIFsob3BlbildPVwidHlwZWFoZWFkT3BlblwiXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk9XCJ0aXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzZWxlY3RPbkVudGVyXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICBbb3B0aW9uc109XCJ0eXBlYWhlYWRJdGVtc1wiXG4gICAgICAgICAgICAgICAgICAgIFtvcHRpb25UZW1wbGF0ZV09XCJmaWx0ZXJPcHRpb25UZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIChvcHRpb25TZWxlY3RlZCk9XCJzZWxlY3QoJGV2ZW50KTsgZHluYW1pY0Ryb3Bkb3duLmhpZGUoKTsgbWVudU5hdmlnYXRpb25Ub2dnbGUuZm9jdXMoKVwiXG4gICAgICAgICAgICAgICAgICAgIChoaWdobGlnaHRlZEVsZW1lbnRDaGFuZ2UpPVwiaGlnaGxpZ2h0ZWRFbGVtZW50ID0gJGV2ZW50XCI+XG4gICAgICAgICAgICAgICAgPC91eC10eXBlYWhlYWQ+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFzaG93VHlwZWFoZWFkXCI+XG5cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGZpbHRlciBvZiBmaWx0ZXJzXCJcbiAgICAgICAgICAgICAgICByb2xlPVwibm9uZVwiPlxuXG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgICAgIHV4TWVudU5hdmlnYXRpb25JdGVtXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiZmlsdGVyID09PSBzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3RGaWx0ZXIoZmlsdGVyKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKTsgZHluYW1pY0Ryb3Bkb3duLmhpZGUoKTsgbWVudU5hdmlnYXRpb25Ub2dnbGUuZm9jdXMoKVwiXG4gICAgICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cInNlbGVjdEZpbHRlcihmaWx0ZXIpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBkeW5hbWljRHJvcGRvd24uaGlkZSgpOyBtZW51TmF2aWdhdGlvblRvZ2dsZS5mb2N1cygpXCI+XG5cbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvblwiIFtjbGFzcy5ocGUtY2hlY2ttYXJrXT1cImZpbHRlciA9PT0gc2VsZWN0ZWRcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duLXRpdGxlXCI+e3sgZmlsdGVyLm5hbWUgfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9saT5cblxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgIDwvdWw+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNmaWx0ZXJPcHRpb25UZW1wbGF0ZSBsZXQtb3B0aW9uPVwib3B0aW9uXCIgbGV0LWFwaT1cImFwaVwiPlxuICAgIDxzcGFuIFthdHRyLmFyaWEtbGFiZWxdPVwib3B0aW9uXCIgW2lubmVySFRNTF09XCJvcHRpb24gfCBmaWx0ZXJUeXBlYWhlYWRIaWdobGlnaHQ6IChxdWVyeSQgfCBhc3luYylcIj48L3NwYW4+XG48L25nLXRlbXBsYXRlPmAsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGRvY3VtZW50OmNsaWNrKSc6ICdjbGlja09mZigkZXZlbnQpJyxcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckR5bmFtaWNDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJCYXNlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGZpbHRlcnM6IEZpbHRlcltdO1xuICAgIEBJbnB1dCgpIGluaXRpYWw6IEZpbHRlcjtcblxuICAgIEBJbnB1dCgpIHNldCBvcHRpb25zKG9wdGlvbnM6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHsuLi4gdGhpcy5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIH1cblxuICAgIGdldCBvcHRpb25zKCk6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG5cbiAgICBAVmlld0NoaWxkKEJzRHJvcGRvd25EaXJlY3RpdmUpIGRyb3Bkb3duOiBCc0Ryb3Bkb3duRGlyZWN0aXZlO1xuXG4gICAgZGVmYXVsdE9wdGlvbnM6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnID0ge1xuICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgIG1pbkNoYXJhY3RlcnM6IDMsXG4gICAgICAgIG1heFJlc3VsdHM6IEluZmluaXR5XG4gICAgfTtcblxuICAgIHR5cGVhaGVhZElkOiBzdHJpbmcgPSBgdXgtZmlsdGVyLWR5bmFtaWMtdHlwZWFoZWFkLSR7dW5pcXVlSWQrK31gO1xuICAgIHF1ZXJ5JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XG4gICAgc2VsZWN0ZWQ6IEZpbHRlcjtcbiAgICBzaG93VHlwZWFoZWFkOiBib29sZWFuID0gdHJ1ZTtcbiAgICB0eXBlYWhlYWRJdGVtczogc3RyaW5nW10gPSBbXTtcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIHR5cGVhaGVhZE9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX2NvbmZpZzogRmlsdGVyRHluYW1pY0xpc3RDb25maWcgPSB7IC4uLnRoaXMuZGVmYXVsdE9wdGlvbnMgfTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0eXBlYWhlYWRLZXlTZXJ2aWNlOiBUeXBlYWhlYWRLZXlTZXJ2aWNlLCBjb250YWluZXI6IEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCwgYW5ub3VuY2VyOiBMaXZlQW5ub3VuY2VyKSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lciwgYW5ub3VuY2VyKTtcbiAgICB9XG5cbiAgICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSQudmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMuaW5pdGlhbCAmJiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHF1ZXJ5KSAhPT0gLTEpXG4gICAgICAgICAgICAubWFwKGl0ZW0gPT4gaXRlbS5uYW1lKVxuICAgICAgICAgICAgLnNsaWNlKDAsIHRoaXMuX2NvbmZpZy5tYXhSZXN1bHRzKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuaW5pdGlhbDtcbiAgICAgICAgdGhpcy50eXBlYWhlYWRJdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tYXhJbmRpdmlkdWFsSXRlbXMgJiYgdGhpcy5vcHRpb25zLm1heEluZGl2aWR1YWxJdGVtcyArIDEgPj0gdGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaG93VHlwZWFoZWFkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RPcHRpb24odHlwZWFoZWFkT3B0aW9uOiBUeXBlYWhlYWRNYXRjaCkge1xuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlcigpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZpbHRlcnMuZmluZEluZGV4KGZpbHRlciA9PiBmaWx0ZXIubmFtZSA9PT0gdHlwZWFoZWFkT3B0aW9uLnZhbHVlKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuZmlsdGVyc1tpZHhdO1xuICAgICAgICB0aGlzLmFkZEZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5xdWVyeSQubmV4dCgnJyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgIH1cblxuICAgIGNsaWNrT2ZmKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG5cbiAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgbGV0IGhpZGVEcm9wZG93biA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3V4LWR5bmFtaWMtZmlsdGVyJykpIHtcbiAgICAgICAgICAgICAgICBoaWRlRHJvcGRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGlkZURyb3Bkb3duKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5JC5uZXh0KCcnKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZW1vdmVGaWx0ZXIoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkICE9PSB0aGlzLmluaXRpYWwpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWVyeSQubmV4dCgnJyk7XG4gICAgfVxuXG4gICAgc2VsZWN0RmlsdGVyKGZpbHRlcjogRmlsdGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMuYWRkRmlsdGVyKHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIHVwZGF0ZVR5cGVhaGVhZChxdWVyeTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMudHlwZWFoZWFkT3BlbiA9IHF1ZXJ5Lmxlbmd0aCA+PSB0aGlzLl9jb25maWcubWluQ2hhcmFjdGVycztcbiAgICAgICAgdGhpcy50eXBlYWhlYWRJdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpbHRlciB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVycy5maW5kKF9maWx0ZXIgPT4gX2ZpbHRlci5uYW1lID09PSBldmVudC5vcHRpb24pO1xuXG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZyB7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgbWluQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtYXhSZXN1bHRzPzogbnVtYmVyO1xuICAgIG1heEluZGl2aWR1YWxJdGVtcz86IG51bWJlcjtcbn1cblxuQFBpcGUoe1xuICAgIG5hbWU6ICdmaWx0ZXJUeXBlYWhlYWRIaWdobGlnaHQnXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlclR5cGVhaGVhZEhpZ2hsaWdodCBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nLCBzZWFyY2hRdWVyeTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHNlYXJjaFF1ZXJ5LCAnaScpO1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWdleCwgYDxiIGNsYXNzPVwiZmlsdGVyLXR5cGVhaGVhZC1oaWdobGlnaHRlZFwiPiR7dmFsdWUubWF0Y2gocmVnZXgpfTwvYj5gKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duTW9kdWxlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL2luZGV4JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC90eXBlYWhlYWQubW9kdWxlJztcbmltcG9ydCB7IEZpbHRlckJhc2VDb21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1iYXNlL2ZpbHRlci1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlckRyb3Bkb3duQ29tcG9uZW50IH0gZnJvbSAnLi9maWx0ZXItZHJvcGRvd24vZmlsdGVyLWRyb3Bkb3duLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJEeW5hbWljQ29tcG9uZW50LCBGaWx0ZXJUeXBlYWhlYWRIaWdobGlnaHQgfSBmcm9tICcuL2ZpbHRlci1keW5hbWljL2ZpbHRlci1keW5hbWljLmNvbXBvbmVudCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBGaWx0ZXJCYXNlQ29tcG9uZW50LFxuICAgIEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCxcbiAgICBGaWx0ZXJEcm9wZG93bkNvbXBvbmVudCxcbiAgICBGaWx0ZXJEeW5hbWljQ29tcG9uZW50LFxuICAgIEZpbHRlclR5cGVhaGVhZEhpZ2hsaWdodFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIEJzRHJvcGRvd25Nb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgTWVudU5hdmlnYXRpb25Nb2R1bGUsXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlLFxuICAgICAgICBBMTF5TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxpcHBhYmxlLWNhcmQnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInV4LWZsaXBwZXJcIlxuICAgICBbY2xhc3MudXgtZmxpcC1jYXJkXT1cImZsaXBwZWRcIlxuICAgICBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIlxuICAgICBbc3R5bGUuaGVpZ2h0LnB4XT1cImhlaWdodFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LWZsaXBwYWJsZS1jYXJkLWZyb250XCJcbiAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiXG4gICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT1cImhlaWdodFwiXG4gICAgICAgICBbYXR0ci5hcmlhLWhpZGRlbl09XCJmbGlwcGVkXCI+XG5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwidXgtZmxpcHBhYmxlLWNhcmQtZnJvbnRcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtZmxpcHBhYmxlLWNhcmQtYmFja1wiXG4gICAgICAgICBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIlxuICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09XCJoZWlnaHRcIlxuICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIWZsaXBwZWRcIj5cblxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJ1eC1mbGlwcGFibGUtY2FyZC1iYWNrXCI+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAgICAgJ1tjbGFzcy5ob3Jpem9udGFsXSc6ICdkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiJyxcbiAgICAgICAgJ1tjbGFzcy52ZXJ0aWNhbF0nOiAnZGlyZWN0aW9uID09PSBcInZlcnRpY2FsXCInXG4gICAgfSxcbiAgICBleHBvcnRBczogJ3V4LWZsaXBwYWJsZS1jYXJkJ1xufSlcbmV4cG9ydCBjbGFzcyBGbGlwcGFibGVDYXJkQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRpcmVjdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyA9ICdob3Jpem9udGFsJztcbiAgICBASW5wdXQoKSB0cmlnZ2VyOiAnY2xpY2snIHwgJ2hvdmVyJyB8ICdtYW51YWwnID0gJ2hvdmVyJztcbiAgICBASW5wdXQoKSB3aWR0aDogbnVtYmVyID0gMjgwO1xuICAgIEBJbnB1dCgpIGhlaWdodDogbnVtYmVyID0gMjAwO1xuICAgIEBJbnB1dCgpIGZsaXBwZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBAT3V0cHV0KCkgZmxpcHBlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgc2V0RmxpcHBlZChzdGF0ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmZsaXBwZWQgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5mbGlwcGVkQ2hhbmdlLmVtaXQodGhpcy5mbGlwcGVkKTtcbiAgICB9XG5cbiAgICB0b2dnbGVGbGlwcGVkKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldEZsaXBwZWQoIXRoaXMuZmxpcHBlZCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIGNsaWNrVHJpZ2dlcigpOiB2b2lkIHtcblxuICAgICAgICAvLyBhZGQgb3IgcmVtb3ZlIHRoZSBjbGFzcyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3QgdGhlIGNhcmQgaGFzIGJlZW4gZmxpcHBlZFxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUZsaXBwZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKVxuICAgIGhvdmVyRW50ZXIoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIHRoZSB0cmlnZ2VyIGlzIGhvdmVyIHRoZW4gYmVnaW4gdG8gZmxpcFxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZsaXBwZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJylcbiAgICBob3ZlckV4aXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmxpcHBlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLmVudGVyJywgWyckZXZlbnQnXSlcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLnNwYWNlJywgWyckZXZlbnQnXSlcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLnNwYWNlYmFyJywgWyckZXZlbnQnXSkgLy8gSUUgdXNlcyBkaWZmZXJlbnQgbmFtaW5nXG4gICAgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUZsaXBwZWQoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxpcHBhYmxlLWNhcmQtZnJvbnQnXG59KVxuZXhwb3J0IGNsYXNzIEZsaXBwYWJsZUNhcmRGcm9udERpcmVjdGl2ZSB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbGlwcGFibGUtY2FyZC1iYWNrJ1xufSlcbmV4cG9ydCBjbGFzcyBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSB7IH0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGbGlwcGFibGVDYXJkQ29tcG9uZW50LCBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSwgRmxpcHBhYmxlQ2FyZEZyb250RGlyZWN0aXZlIH0gZnJvbSAnLi9mbGlwcGFibGUtY2FyZC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtGbGlwcGFibGVDYXJkQ29tcG9uZW50LCBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSwgRmxpcHBhYmxlQ2FyZEZyb250RGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGbGlwcGFibGVDYXJkQ29tcG9uZW50LCBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSwgRmxpcHBhYmxlQ2FyZEZyb250RGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBGbGlwcGFibGVDYXJkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZSB7XG5cbiAgICBvcGVuJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgb3BlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KCF0aGlzLm9wZW4kLmdldFZhbHVlKCkpO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQoZmFsc2UpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBhbmltYXRlLCBxdWVyeSwgc3RhZ2dlciwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBRdWVyeUxpc3QsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUb29sdGlwRGlyZWN0aXZlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC90b29sdGlwJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsb2F0aW5nLWFjdGlvbi1idXR0b25zJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50IHNlbGVjdD1cIltmYWItcHJpbWFyeV1cIj48L25nLWNvbnRlbnQ+XG5cbjxkaXYgY2xhc3M9XCJmbG9hdGluZy1hY3Rpb24tYnV0dG9uLWxpc3RcIiBbQGZhYkFuaW1hdGlvbl09XCJmYWIub3BlbiQgfCBhc3luY1wiIFtuZ0NsYXNzXT1cImRpcmVjdGlvblwiICpuZ0lmPVwiZmFiLm9wZW4kIHwgYXN5bmNcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5gLFxuICAgIHByb3ZpZGVyczogW0Zsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2VdLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcignZmFiQW5pbWF0aW9uJywgW1xuICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiB0cnVlJywgW1xuICAgICAgICAgICAgICAgIHF1ZXJ5KCd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKSxcbiAgICAgICAgICAgICAgICBxdWVyeSgndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbicsIHN0YWdnZXIoNTAsIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpKSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdHJhbnNpdGlvbigndHJ1ZSA9PiB2b2lkJywgW1xuICAgICAgICAgICAgICAgIHF1ZXJ5KCd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJywgc3RhZ2dlcigtNTAsIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgZGlyZWN0aW9uOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbkRpcmVjdGlvbiA9ICd0b3AnO1xuICAgIEBDb250ZW50Q2hpbGRyZW4oVG9vbHRpcERpcmVjdGl2ZSkgdG9vbHRpcHM6IFF1ZXJ5TGlzdDxUb29sdGlwRGlyZWN0aXZlPjtcbiAgICBAT3V0cHV0KCkgb3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGZhYjogRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHRoaXMuZmFiLm9wZW4kLnN1YnNjcmliZSh2YWx1ZSA9PiB0aGlzLm9wZW5DaGFuZ2UuZW1pdCh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5mYWIub3BlbiQucGlwZShmaWx0ZXIob3BlbiA9PiBvcGVuID09PSBmYWxzZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudG9vbHRpcHMuZm9yRWFjaCh0b29sdGlwID0+IHRvb2x0aXAuaGlkZSgpKSkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIERldGVjdCBhbnkgY2xpY2tzIHRvIHRyaWdnZXIgY2xvc2Ugb2YgdGhlIG1lbnVcbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50LnRhcmdldCddKSBjbG9zZSh0YXJnZXQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmFiLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIEZsb2F0aW5nQWN0aW9uQnV0dG9uRGlyZWN0aW9uID0gJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCc7IiwiaW1wb3J0IHsgQXR0cmlidXRlLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsb2F0aW5nLWFjdGlvbi1idXR0b24nLFxuICAgIHRlbXBsYXRlOiBgPGJ1dHRvbiBjbGFzcz1cImJ0biBmbG9hdGluZy1hY3Rpb24tYnV0dG9uXCIgXG4gICAgICAgIFtjbGFzcy5idXR0b24tcHJpbWFyeV09XCJwcmltYXJ5XCIgXG4gICAgICAgIFtjbGFzcy5idXR0b24tc2Vjb25kYXJ5XT1cIiFwcmltYXJ5XCIgXG4gICAgICAgIChjbGljayk9XCJwcmltYXJ5ID8gZmFiLnRvZ2dsZSgpIDogZmFiLmNsb3NlKClcIj5cblxuICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi1pY29uXCIgKm5nSWY9XCJpY29uXCIgW25nQ2xhc3NdPVwiaWNvblwiPjwvc3Bhbj5cbiAgICA8bmctY29udGVudCAqbmdJZj1cIiFpY29uXCI+PC9uZy1jb250ZW50PlxuXG48L2J1dHRvbj5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlXG59KVxuZXhwb3J0IGNsYXNzIEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGljb246IHN0cmluZztcbiAgICBASG9zdEJpbmRpbmcoKSB0YWJpbmRleCA9IDE7XG5cbiAgICBwcmltYXJ5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihAQXR0cmlidXRlKCdmYWItcHJpbWFyeScpIHByaW1hcnk6IHN0cmluZywgcHVibGljIGZhYjogRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZSkge1xuICAgICAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5ICE9PSBudWxsO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgRmxvYXRpbmdBY3Rpb25CdXR0b25zQ29tcG9uZW50IH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnQgfSBmcm9tICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQsXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRmxvYXRpbmdBY3Rpb25CdXR0b25zQ29tcG9uZW50LFxuICAgICAgICBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25zTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJ3J4anMvT2JzZXJ2ZXInO1xyXG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XHJcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSGllcmFyY2h5QmFyU2VydmljZSB7XHJcblxyXG4gICAgbm9kZXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxIaWVyYXJjaHlCYXJOb2RlW10+KFtdKTtcclxuXHJcbiAgICBwcml2YXRlIF9yb290OiBIaWVyYXJjaHlCYXJOb2RlO1xyXG4gICAgcHJpdmF0ZSBfbm9kZXM6IEhpZXJhcmNoeUJhck5vZGVbXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcmUgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgaGllcmFyY2h5IHRyZWVcclxuICAgICAqL1xyXG4gICAgc2V0Um9vdE5vZGUocm9vdDogSGllcmFyY2h5QmFyTm9kZSkge1xyXG5cclxuICAgICAgICAvLyBzdG9yZSB0aGUgcm9vdCBub2RlXHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIGZsYXQgc3RydWN0dXJlIG9mIG5vZGVzXHJcbiAgICAgICAgdGhpcy5fbm9kZXMgPSB0aGlzLmdldE5vZGVMaXN0KHJvb3QpO1xyXG5cclxuICAgICAgICAvLyBmbGF0dGVuIHRoZSBhcnJheSAtIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBub2RlXHJcbiAgICAgICAgdGhpcy5ub2RlcyQubmV4dCh0aGlzLmdldFNlbGVjdGVkQ2hpbGRyZW4ocm9vdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IGEgbm9kZS4gVGhpcyBjYXVzZXMgYWxsIG5vZGVzIHRvIGJlXHJcbiAgICAgKiBkZXNlbGVjdGVkIGFuZCB0aGUgcGF0aCB0byB0aGUgc2VsZWN0ZWQgbm9kZVxyXG4gICAgICogdG8gYmUgc2VsZWN0ZWRcclxuICAgICAqL1xyXG4gICAgc2VsZWN0Tm9kZShub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogdm9pZCB7XHJcblxyXG4gICAgICAgIC8vIGRlc2VsZWN0IGFsbCBub2Rlc1xyXG4gICAgICAgIHRoaXMuZGVzZWxlY3RBbGwoKTtcclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBjdXJyZW50IG5vZGUgaXMgc2VsZWN0ZWQgYW5kIGl0cyBwYXJlbnRzXHJcbiAgICAgICAgdGhpcy5zZWxlY3Qobm9kZSk7XHJcblxyXG4gICAgICAgIC8vIGVtaXQgYSBuZXcgbm9kZSBsaXN0IHRvIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvblxyXG4gICAgICAgIHRoaXMubm9kZXMkLm5leHQodGhpcy5nZXRTZWxlY3RlZENoaWxkcmVuKHRoaXMuX3Jvb3QpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgZ2V0dGluZyBjaGlsZHJlbiB3aXRoIHN1cHBvcnQgZm9yIGJvdGggYXJyYXlzIGFuZCBvYnNlcnZhYmxlc1xyXG4gICAgICovXHJcbiAgICBnZXRDaGlsZHJlbihub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogT2JzZXJ2YWJsZTxIaWVyYXJjaHlCYXJOb2RlQ2hpbGRyZW4+IHtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9mKHsgbG9hZGluZzogZmFsc2UsIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4kOiBPYnNlcnZhYmxlPEhpZXJhcmNoeUJhck5vZGVbXT4gPSBub2RlLmNoaWxkcmVuO1xyXG5cclxuICAgICAgICAvLyBpZiBpdCBpcyBhbiBvYnNlcnZhYmxlIHRoZW4gaGFuZGxlIGxvYWRpbmdcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxIaWVyYXJjaHlCYXJOb2RlQ2hpbGRyZW4+KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGVtaXQgaW5pdGlhbCB2YWx1ZVxyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHsgbG9hZGluZzogdHJ1ZSwgY2hpbGRyZW46IFtdIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gbm93IHdhaXQgdW50aWwgdGhlIGNoaWxkcmVuIG9ic2VydmFibGUgY29tcGxldGVzXHJcbiAgICAgICAgICAgIGNoaWxkcmVuJC5waXBlKGZpcnN0KCkpLnN1YnNjcmliZShjaGlsZHJlbiA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgb2JzZXJ2YWJsZSB3aXRoIGFuIGFycmF5IGZvciBmdXR1cmUgbG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlYnVpbGQgdGhlIG5vZGUgdHJlZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb290Tm9kZSh0aGlzLl9yb290KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBlbWl0IHRoZSBsYXRlc3QgdmFsdWVcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyBsb2FkaW5nOiBmYWxzZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBvYnNlcnZhYmxlIHN0cmVhbVxyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYWxsIHRoZSBwYXJlbnRzIHRvIGVuc3VyZSB0aGV5IGFyZSBzZWxlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNlbGVjdChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgbm9kZS5zZWxlY3RlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChub2RlLnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzZWxlY3RzIGFsbCBub2Rlc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnNlbGVjdGVkID0gZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgdGhlIG5vZGVzIGluIHRoZSB0cmVlIGFzIGEgZmxhdCBhcnJheS5cclxuICAgICAqIEl0IGFsc28gc3RvcmVzIHRoZSBwYXJlbnQgbm9kZSBpbiBhIHBhcmVudCBwcm9wZXJ0eVxyXG4gICAgICogb24gdGhlIG5vZGUgZm9yIGVhc3kgdHJhdmVyc2FsIGluIGJvdGggZGlyZWN0aW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldE5vZGVMaXN0KG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiBIaWVyYXJjaHlCYXJOb2RlW10ge1xyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4gdGhlbiByZXR1cm4gb25seSBpdHNlbGZcclxuICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4gfHwgbm9kZS5jaGlsZHJlbiBpbnN0YW5jZW9mIE9ic2VydmFibGUgfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBwYXJlbnQgcHJvcGVydHlcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucGFyZW50ID0gbm9kZSk7XHJcblxyXG4gICAgICAgIC8vIGdldCBhbGwgZGVzY2VuZGFudHMgb2YgdGhpcyBub2RlXHJcbiAgICAgICAgY29uc3QgZGVzY2VuZGFudHMgPSBub2RlLmNoaWxkcmVuLnJlZHVjZTxIaWVyYXJjaHlCYXJOb2RlW10+KChub2RlcywgY3VycmVudCkgPT4gWy4uLm5vZGVzLCAuLi50aGlzLmdldE5vZGVMaXN0KGN1cnJlbnQpXSwgW10pO1xyXG5cclxuICAgICAgICByZXR1cm4gW25vZGUsIC4uLmRlc2NlbmRhbnRzXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIHNlbGVjdGVkIG5vZGVzIGZyb20gdGhlIHBhcmVudCBub2RlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFNlbGVjdGVkQ2hpbGRyZW4obm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IEhpZXJhcmNoeUJhck5vZGVbXSB7XHJcblxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW25vZGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSBjaGlsZHJlbiAtIGFuZCBhY2NvdW50IGZvciB3aGVuIHRoZXJlIGlzIG5vbmVcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgW107XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGlmIGFueSBjaGlsZCBpcyBzZWxlY3RlZFxyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW4uZmluZChfY2hpbGQgPT4gX2NoaWxkLnNlbGVjdGVkKTtcclxuXHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSByZW1haW5pbmcgY2hhaW4gb2Ygc2VsZWN0ZWQgaXRlbXNcclxuICAgICAgICByZXR1cm4gY2hpbGQgPyBbbm9kZSwgLi4udGhpcy5nZXRTZWxlY3RlZENoaWxkcmVuKGNoaWxkKV0gOiBbbm9kZV07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGllcmFyY2h5QmFyTm9kZSB7XHJcbiAgICBpY29uPzogc3RyaW5nO1xyXG4gICAgdGl0bGU6IHN0cmluZztcclxuICAgIHNlbGVjdGVkPzogYm9vbGVhbjtcclxuICAgIHBhcmVudD86IEhpZXJhcmNoeUJhck5vZGU7XHJcbiAgICBjaGlsZHJlbj86IEhpZXJhcmNoeUJhck5vZGVbXSB8IE9ic2VydmFibGU8SGllcmFyY2h5QmFyTm9kZVtdPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBIaWVyYXJjaHlCYXJOb2RlQ2hpbGRyZW4ge1xyXG4gICAgbG9hZGluZzogYm9vbGVhbjtcclxuICAgIGNoaWxkcmVuOiBIaWVyYXJjaHlCYXJOb2RlW107XHJcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkLCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgSGllcmFyY2h5QmFyTm9kZSwgSGllcmFyY2h5QmFyU2VydmljZSB9IGZyb20gJy4vaGllcmFyY2h5LWJhci5zZXJ2aWNlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC1oaWVyYXJjaHktYmFyJyxcclxuICAgIHRlbXBsYXRlOiBgPCEtLSBBbGxvdyBjb250ZW50IHRvIGJlIHBsYWNlZCBvbiB0aGUgbGVmdCBvZiB0aGUgaXRlbXMgLS0+XG48YXNpZGUgY2xhc3M9XCJoaWVyYXJjaHktYmFyLWFkZG9uc1wiPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIlt1eEhpZXJhcmNoeUJhckxlZnRBZGRvbl1cIj48L25nLWNvbnRlbnQ+XG48L2FzaWRlPlxuXG48bWFpbiAjbm9kZWxpc3QgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGVzXCIgKHV4UmVzaXplKT1cInNjcm9sbEludG9WaWV3KClcIj5cblxuICAgIDxkaXYgKm5nSWY9XCJvdmVyZmxvdyQgfCBhc3luY1wiXG4gICAgICAgICAjcG9wb3Zlcj1cInV4LXBvcG92ZXJcIlxuICAgICAgICAgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW92ZXJmbG93LWluZGljYXRvclwiXG4gICAgICAgICBbc3R5bGUubGVmdC5weF09XCJub2RlbGlzdC5zY3JvbGxMZWZ0XCJcbiAgICAgICAgIFt1eFBvcG92ZXJdPVwib3ZlcmZsb3dcIlxuICAgICAgICAgW3BvcG92ZXJDb250ZXh0XT1cInsgcG9wb3ZlcjogcG9wb3ZlciB9XCJcbiAgICAgICAgIHBsYWNlbWVudD1cImJvdHRvbVwiXG4gICAgICAgICBwb3BvdmVyQ2xhc3M9XCJoaWVyYXJjaHktYmFyLXBvcG92ZXJcIj5cbiAgICAgICAgLiAuIC5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgI25vZGVFbGVtZW50IGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlXCJcbiAgICAgICAgICpuZ0Zvcj1cImxldCBub2RlIG9mIGhpZXJhcmNoeUJhci5ub2RlcyQgfCBhc3luY1wiPlxuXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtY29udGVudFwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJub2RlLnRpdGxlXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiaGllcmFyY2h5QmFyLnNlbGVjdE5vZGUobm9kZSlcIj5cblxuICAgICAgICAgICAgPCEtLSBTaG93IGFuIGljb24gaWYgc3BlY2lmZWQgLS0+XG4gICAgICAgICAgICA8aW1nIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWljb25cIiAqbmdJZj1cIm5vZGUuaWNvblwiIFtzcmNdPVwibm9kZS5pY29uXCIgYWx0PVwiSGllcmFyY2h5IEJhciBJY29uXCI+XG5cbiAgICAgICAgICAgIDwhLS0gU2hvdyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBub2RlIC0tPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtdGl0bGVcIj57eyBub2RlLnRpdGxlIH19PC9zcGFuPlxuXG4gICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgIDwhLS0gU2hvdyBhIGRyb3Bkb3duIGFycm93IGlmIHRoZXJlIGFyZSBjaGlsZHJlbiAtLT5cbiAgICAgICAgPGJ1dHRvbiAqbmdJZj1cIm5vZGUuY2hpbGRyZW5cIlxuICAgICAgICAgICAgICAjcG9wb3Zlcj1cInV4LXBvcG92ZXJcIlxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiU2hvdyBjaGlsZHJlblwiXG4gICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1hcnJvdyBocGUtaWNvbiBocGUtbmV4dFwiXG4gICAgICAgICAgICAgIFt1eFBvcG92ZXJdPVwiY29udGVudFwiXG4gICAgICAgICAgICAgIFtwb3BvdmVyQ29udGV4dF09XCJ7IG5vZGU6IG5vZGUsIHBvcG92ZXI6IHBvcG92ZXIgfVwiXG4gICAgICAgICAgICAgIHBsYWNlbWVudD1cImJvdHRvbVwiXG4gICAgICAgICAgICAgIHBvcG92ZXJDbGFzcz1cImhpZXJhcmNoeS1iYXItcG9wb3ZlclwiXG4gICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiPlxuICAgICAgICA8L2J1dHRvbj5cblxuICAgIDwvZGl2PlxuXG48L21haW4+XG5cbjwhLS0gQWxsb3cgY29udGVudCB0byBiZSBwbGFjZWQgb24gdGhlIHJpZ2h0IG9mIHRoZSBpdGVtcyAtLT5cbjxhc2lkZSBjbGFzcz1cImhpZXJhcmNoeS1iYXItYWRkb25zXCI+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW3V4SGllcmFyY2h5QmFyUmlnaHRBZGRvbl1cIj48L25nLWNvbnRlbnQ+XG48L2FzaWRlPlxuXG48IS0tIFRlbXBsYXRlIGZvciB0aGUgcG9wb3ZlciBsaXN0IC0tPlxuPG5nLXRlbXBsYXRlICNjb250ZW50IGxldC1ub2RlPVwibm9kZVwiIGxldC1wb3BvdmVyPVwicG9wb3ZlclwiPlxuXG4gICAgPCEtLSBMb2FkaW5nIEluZGljYXRvciAtLT5cbiAgICA8dWwgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtbGlzdFwiICpuZ0lmPVwiKGhpZXJhcmNoeUJhci5nZXRDaGlsZHJlbihub2RlKSB8IGFzeW5jKS5sb2FkaW5nXCI+XG5cbiAgICAgICAgPGxpIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWxpc3QtaXRlbVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJsb2FkaW5nSW5kaWNhdG9yIHx8IGRlZmF1bHRMb2FkaW5nSW5kaWNhdG9yXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cblxuICAgIDwhLS0gTGlzdCBvZiBjaGlsZHJlbiAtLT5cbiAgICA8dWwgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtbGlzdFwiICpuZ0lmPVwiIShoaWVyYXJjaHlCYXIuZ2V0Q2hpbGRyZW4obm9kZSkgfCBhc3luYykubG9hZGluZ1wiPlxuXG4gICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgY2hpbGQgb2YgKGhpZXJhcmNoeUJhci5nZXRDaGlsZHJlbihub2RlKSB8IGFzeW5jKS5jaGlsZHJlbjsgbGV0IGZpcnN0ID0gZmlyc3RcIlxuICAgICAgICAgICAgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtbGlzdC1pdGVtXCJcbiAgICAgICAgICAgIFtmb2N1c0lmXT1cImZpcnN0XCJcbiAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJoaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShjaGlsZCk7IHBvcG92ZXIuaGlkZSgpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJoaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShjaGlsZCk7IHBvcG92ZXIuaGlkZSgpXCI+XG5cbiAgICAgICAgICAgIDwhLS0gU2hvdyBhbiBpY29uIGlmIHNwZWNpZmVkIC0tPlxuICAgICAgICAgICAgPGltZyBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1pY29uXCIgKm5nSWY9XCJjaGlsZC5pY29uXCIgW3NyY109XCJjaGlsZC5pY29uXCIgYWx0PVwiSGllcmFyY2h5IEJhciBJY29uXCI+XG5cbiAgICAgICAgICAgIDwhLS0gU2hvdyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBub2RlIC0tPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtdGl0bGVcIj57eyBjaGlsZC50aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICA8L2xpPlxuXG4gICAgPC91bD5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gVGVtcGxhdGUgZm9yIHRoZSBvdmVyZmxvdyBwb3BvdmVyIGxpc3QgLS0+XG48bmctdGVtcGxhdGUgI292ZXJmbG93IGxldC1wb3BvdmVyPVwicG9wb3ZlclwiPlxuXG4gICAgPHVsIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWxpc3RcIj5cblxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGNoaWxkIG9mIG92ZXJmbG93Tm9kZXMkIHwgYXN5bmM7IGxldCBmaXJzdCA9IGZpcnN0XCJcbiAgICAgICAgICAgIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWxpc3QtaXRlbVwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgW2ZvY3VzSWZdPVwiZmlyc3RcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImhpZXJhcmNoeUJhci5zZWxlY3ROb2RlKGNoaWxkKTsgcG9wb3Zlci5oaWRlKClcIlxuICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwiaGllcmFyY2h5QmFyLnNlbGVjdE5vZGUoY2hpbGQpOyBwb3BvdmVyLmhpZGUoKVwiPlxuXG4gICAgICAgICAgICA8IS0tIFNob3cgYW4gaWNvbiBpZiBzcGVjaWZlZCAtLT5cbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtaWNvblwiICpuZ0lmPVwiY2hpbGQuaWNvblwiIFtzcmNdPVwiY2hpbGQuaWNvblwiIGFsdD1cIkhpZXJhcmNoeSBCYXIgSWNvblwiPlxuXG4gICAgICAgICAgICA8IS0tIFNob3cgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbm9kZSAtLT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLXRpdGxlXCI+e3sgY2hpbGQudGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgPC9saT5cblxuICAgIDwvdWw+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tIExvYWRpbmcgSW5kaWNhdG9yIFRlbXBsYXRlIC0tPlxuPG5nLXRlbXBsYXRlICNkZWZhdWx0TG9hZGluZ0luZGljYXRvcj5cbiAgICA8ZGl2IGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWljb25cIiBhbHQ9XCJIaWVyYXJjaHkgQmFyIExvYWRpbmcgSW5kaWNhdG9yXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzcGlubmVyIHNwaW5uZXItYWNjZW50IHNwaW5uZXItYm91bmNlLW1pZGRsZVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBTaG93IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG5vZGUgLS0+XG4gICAgPHNwYW4gY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtdGl0bGVcIj5Mb2FkaW5nLi4uPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5gLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICB2aWV3UHJvdmlkZXJzOiBbSGllcmFyY2h5QmFyU2VydmljZV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCkgc2V0IHJvb3Qobm9kZTogSGllcmFyY2h5QmFyTm9kZSkge1xyXG4gICAgICAgIHRoaXMuaGllcmFyY2h5QmFyLnNldFJvb3ROb2RlKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpIHNldCBzZWxlY3RlZChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKSB7XHJcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSBsb2FkaW5nSW5kaWNhdG9yOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SGllcmFyY2h5QmFyTm9kZT4oKTtcclxuICAgIEBWaWV3Q2hpbGQoJ25vZGVsaXN0Jykgbm9kZWxpc3Q6IEVsZW1lbnRSZWY7XHJcbiAgICBAVmlld0NoaWxkcmVuKCdub2RlRWxlbWVudCcpIG5vZGVzOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XHJcblxyXG4gICAgb3ZlcmZsb3ckID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XHJcbiAgICBvdmVyZmxvd05vZGVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SGllcmFyY2h5QmFyTm9kZVtdPihbXSk7XHJcblxyXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBoaWVyYXJjaHlCYXI6IEhpZXJhcmNoeUJhclNlcnZpY2UpIHtcclxuXHJcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIHNlbGVjdGVkIG5vZGVcclxuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IGhpZXJhcmNoeUJhci5ub2RlcyQuc3Vic2NyaWJlKG5vZGVzID0+IHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdChub2Rlcy5sZW5ndGggPT09IDAgPyBudWxsIDogbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0pKTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkID0gaGllcmFyY2h5QmFyLm5vZGVzJC5waXBlKGRlYm91bmNlVGltZSgwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2Nyb2xsSW50b1ZpZXcoKSk7XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHNlbGVjdGVkKTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKGNoYW5nZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGVyZSBpcyBvdmVyZmxvdyBlbnN1cmUgdGhhdCB0aGUgcmlnaHRtb3N0XHJcbiAgICAgKiBub2RlIHJlbWFpbnMgaW4gdmlldyBhdCBhbGwgdGltZXMuIFRoZSBub2RlcyBubyBsb25nZXJcclxuICAgICAqIHZpc2libGUgYmUgYmUgZGlzcGxheWVkIGluIGEgcG9wb3ZlciBhdmFpbGFibGUgb24gdGhlXHJcbiAgICAgKiBvdmVyZmxvdyBpbmRpY2F0b3JcclxuICAgICAqL1xyXG4gICAgc2Nyb2xsSW50b1ZpZXcoKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5ub2RlbGlzdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIG5hdGl2ZSBlbGVtZW50XHJcbiAgICAgICAgY29uc3QgeyBuYXRpdmVFbGVtZW50IH0gPSB0aGlzLm5vZGVsaXN0O1xyXG5cclxuICAgICAgICAvLyBlbWl0IHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIG92ZXJmbG93XHJcbiAgICAgICAgdGhpcy5vdmVyZmxvdyQubmV4dChuYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoID4gbmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBoaWVyYXJjaHkgYmFyIGNvbnRlbnRzIGRvIG5vdCBvdmVyZmxvdyB0aGVuIGRvIG5vdGhpbmdcclxuICAgICAgICBpZiAobmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCA+IG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgYW1vdW50IG9mIG92ZXJmbG93XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93QW1vdW50ID0gbmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCAtIG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggbm9kZXMgYXJlIG5vdCBmdWxseSB2aXNpYmxlXHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmZsb3dOb2RlcyQubmV4dChcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgPCBvdmVyZmxvd0Ftb3VudClcclxuICAgICAgICAgICAgICAgICAgICAubWFwKChub2RlLCBpbmRleCkgPT4gdGhpcy5oaWVyYXJjaHlCYXIubm9kZXMkLnZhbHVlW2luZGV4XSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byBhbHdheXMgc2hvdyB0aGUgbGFzdCBpdG1lXHJcbiAgICAgICAgICAgIHRoaXMubm9kZWxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gb3ZlcmZsb3dBbW91bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eENsaWNrT3V0c2lkZV0nXG59KVxuZXhwb3J0IGNsYXNzIENsaWNrT3V0c2lkZURpcmVjdGl2ZSB7XG5cbiAgICBAT3V0cHV0KCkgdXhDbGlja091dHNpZGUgPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgICBjbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiYgIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLnV4Q2xpY2tPdXRzaWRlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVEaXJlY3RpdmUgfSBmcm9tICcuL2NsaWNrLW91dHNpZGUuZGlyZWN0aXZlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtDbGlja091dHNpZGVEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0NsaWNrT3V0c2lkZURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2xpY2tPdXRzaWRlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5cbmxldCB1bmlxdWVQb3BvdmVySWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1wb3BvdmVyJyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicG9wb3ZlciBzaG93XCIgW25nQ2xhc3NdPVwiW3BsYWNlbWVudCwgY3VzdG9tQ2xhc3NdXCIgW2lkXT1cImlkXCIgW2F0dHIucm9sZV09XCJyb2xlXCIgKHV4Q2xpY2tPdXRzaWRlKT1cImNsaWNrT3V0c2lkZSQubmV4dCgkZXZlbnQpXCI+XG4gICAgPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+XG4gICAgPGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiICpuZ0lmPVwidGl0bGVcIj57eyB0aXRsZSB9fTwvaDM+XG4gICAgPGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiIChjZGtPYnNlcnZlQ29udGVudCk9XCJyZXBvc2l0aW9uKClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlUmVmXCI+e3sgY29udGVudCB9fTwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaXNUZW1wbGF0ZVJlZlwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbnRlbnRcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiY29udGV4dFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUG9wb3ZlckNvbXBvbmVudCBleHRlbmRzIFRvb2x0aXBDb21wb25lbnQge1xuXG4gIC8qKiBEZWZpbmUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggcG9wb3ZlciAqL1xuICBpZDogc3RyaW5nID0gYHV4LXBvcG92ZXItJHsrK3VuaXF1ZVBvcG92ZXJJZH1gO1xuXG4gIC8qKiBJZiBzcGVjaWZpZWQgYWxsb3dzIHRoZSBwb3BvdmVyIHRvIHNob3cgYSB0aXRsZSAqL1xuICB0aXRsZTogc3RyaW5nO1xuXG4gIC8qKiBUaGlzIHdpbGwgZW1pdCBhbiBldmVudCBhbnkgdGltZSB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgcG9wb3ZlciAqL1xuICBjbGlja091dHNpZGUkID0gbmV3IFN1YmplY3Q8TW91c2VFdmVudD4oKTtcblxuICAvKiogVGhpcyB3aWxsIHVwZGF0ZSB0aGUgdGl0bGUgb2YgdGhlIHBvcG92ZXIgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRUaXRsZSh0aXRsZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG59IiwiaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IE92ZXJsYXlSZWYgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVG9vbHRpcERpcmVjdGl2ZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFBvcG92ZXJdJyxcbiAgICBleHBvcnRBczogJ3V4LXBvcG92ZXInXG59KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJEaXJlY3RpdmUgZXh0ZW5kcyBUb29sdGlwRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuXG4gICAgLyoqIENvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3BvdmVyIG9yIGEgVGVtcGxhdGVSZWYgZm9yIG1vcmUgZGV0YWlsZWQgY29udGVudCAqL1xuICAgIEBJbnB1dCgndXhQb3BvdmVyJykgY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKiBPcHRpb25hbGx5IGRpc3BsYXkgYSB0aXRsZSBpbiB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgncG9wb3ZlclRpdGxlJykgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKiBBbGxvdyB0aGUgcG9wb3ZlciB0byBiZSBjb25kaXRpb25hbGx5IGRpc2FibGVkICovXG4gICAgQElucHV0KCdwb3BvdmVyRGlzYWJsZWQnKSBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKiBBbGwgdGhlIHVzZXIgdG8gYWRkIGEgY3VzdG9tIGNsYXNzIHRvIHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCdwb3BvdmVyQ2xhc3MnKSBjdXN0b21DbGFzczogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIHJvbGUgdG8gdGhlIHBvcG92ZXIgLSBkZWZhdWx0IGlzIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJSb2xlJykgcm9sZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gICAgLyoqIFByb3ZpZGUgdGhlIFRlbXBsYXRlUmVmIGEgY29udGV4dCBvYmplY3QgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJDb250ZXh0JykgY29udGV4dDogYW55ID0ge307XG5cbiAgICAvKiogRGVsYXkgdGhlIHNob3dpbmcgb2YgdGhlIHBvcG92ZXIgYnkgYSBudW1iZXIgb2YgbWlsaXNlY29uZHMgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJEZWxheScpIGRlbGF5OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBzaG93IHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCkgc2hvd1RyaWdnZXJzOiBzdHJpbmdbXSA9IFsnY2xpY2snXTtcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgaGlkZSB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgpIGhpZGVUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ2NsaWNrJywgJ2NsaWNrb3V0c2lkZScsICdlc2NhcGUnXTtcblxuICAgIC8qKiBLZWVwIHRyYWNrIG9mIHRoZSB0b29sdGlwIHZpc2liaWxpdHkgYW5kIHVwZGF0ZSBhcmlhLWV4cGFuZGVkIGF0dHJpYnV0ZSAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWV4cGFuZGVkJykgaXNWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIENESyBwb3J0YWwgY29udGFpbmluZyB0aGUgb3ZlcmxheSAqL1xuICAgIHByb3RlY3RlZCBfcG9ydGFsOiBDb21wb25lbnRQb3J0YWw8UG9wb3ZlckNvbXBvbmVudD47XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSBwb3BvdmVyIGNvbXBvbmVudCB3aGVuIGNyZWF0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX2luc3RhbmNlOiBQb3BvdmVyQ29tcG9uZW50O1xuXG4gICAgLyoqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5IG9yaWdpbmFsbHkgZXhpc3RlZCBvbiB0aGUgZWxlbWVudCAqL1xuICAgIHByaXZhdGUgX2FyaWFEZXNjcmliZWRCeTogYm9vbGVhbjtcblxuICAgIC8qKiBJbnRlcm5hbGx5IHN0b3JlIHRoZSB0eXBlIG9mIHRoaXMgY29tcG9uZW50IC0gdXN1YWwgZm9yIGRpc3RpbmN0aW9ucyB3aGVuIGV4dGVuZGluZyB0aGUgdG9vbHRpcCBjbGFzcyAqL1xuICAgIHByb3RlY3RlZCBfdHlwZTogc3RyaW5nID0gJ3BvcG92ZXInO1xuXG4gICAgLyoqIFNldCB1cCB0aGUgdHJpZ2dlcnMgYW5kIGJpbmQgdG8gdGhlIHNob3cvaGlkZSBldmVudHMgdG8ga2VlcCB2aXNpYmlsaXR5IGluIHN5bmMgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGV2ZW50IHRyaWdnZXJzXG4gICAgICAgIGZyb21FdmVudChkb2N1bWVudCwgJ2tleWRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gYXJpYS1kZXNjcmliZWQgYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuX2FyaWFEZXNjcmliZWRCeSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGRlZmF1bHQgZXZlbnQgdHJpZ2dlcnNcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIHNlbmQgaW5wdXQgY2hhbmdlcyB0byB0aGUgcG9wb3ZlciBjb21wb25lbnRcbiAgICAgKiBXZSBjYW4ndCB1c2Ugc2V0dGVycyBhcyB0aGV5IG1heSB0cmlnZ2VyIGJlZm9yZSBwb3BvdmVyIGluaXRpYWxpc2VkIGFuZCBjYW4ndCByZXNlbmQgb25jZSBpbml0aWFsaXNlZFxuICAgICAqKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLnRpdGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRUaXRsZShjaGFuZ2VzLnRpdGxlLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5zdGFuY2Uob3ZlcmxheVJlZjogT3ZlcmxheVJlZik6IFBvcG92ZXJDb21wb25lbnQge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG92ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCkuaW5zdGFuY2UgYXMgUG9wb3ZlckNvbXBvbmVudDtcblxuICAgICAgICAvLyBzdXBwbHkgdGhlIHRvb2x0aXAgd2l0aCB0aGUgY29ycmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIGluc3RhbmNlLnNldFRpdGxlKHRoaXMudGl0bGUpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldFBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldENsYXNzKHRoaXMuY3VzdG9tQ2xhc3MpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIGluc3RhbmNlLnNldFJvbGUodGhpcy5yb2xlKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuc2V0QXJpYURlc2NyaWJlZEJ5KGluc3RhbmNlLmlkKTtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIG91dHNpZGUgY2xpY2sgZXZlbnRcbiAgICAgICAgaW5zdGFuY2UuY2xpY2tPdXRzaWRlJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkNsaWNrT3V0c2lkZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVBvcnRhbCgpOiBDb21wb25lbnRQb3J0YWw8UG9wb3ZlckNvbXBvbmVudD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsIHx8IG5ldyBDb21wb25lbnRQb3J0YWwoUG9wb3ZlckNvbXBvbmVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB2aXNpYmxlIGFuZCB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkIGFuZCBpdCBpcyBvbmUgb2YgdGhlIGhpZGUgdHJpZ2dlcnNcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnZXNjYXBlJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsaWNrT3V0c2lkZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgdmlzaWJsZSBhbmQgaXQgaXMgb25lIG9mIHRoZSBoaWRlIHRyaWdnZXJzXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnY2xpY2tvdXRzaWRlJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgdXBkYXRlIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5ICovXG4gICAgcHJvdGVjdGVkIHNldEFyaWFEZXNjcmliZWRCeShpZDogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBzZXQgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0ciB3aGVuIHRoZSBjb250ZW50IGlzIGEgc3RyaW5nIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBkZWZpbmVkIGF0dHJpYnV0ZSBhbHJlYWR5XG4gICAgICAgIGlmICh0aGlzLl9hcmlhRGVzY3JpYmVkQnkgPT09IGZhbHNlICYmIHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdXBlci5zZXRBcmlhRGVzY3JpYmVkQnkoaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgT2JzZXJ2ZXJzTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL29ic2VydmVycyc7XG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgUG9wb3ZlckRpcmVjdGl2ZSB9IGZyb20gJy4vcG9wb3Zlci5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgT2JzZXJ2ZXJzTW9kdWxlLFxuICAgIENsaWNrT3V0c2lkZU1vZHVsZSxcbiAgICBUb29sdGlwTW9kdWxlXG4gIF0sXG4gIGV4cG9ydHM6IFtQb3BvdmVyRGlyZWN0aXZlXSxcbiAgZGVjbGFyYXRpb25zOiBbUG9wb3ZlckNvbXBvbmVudCwgUG9wb3ZlckRpcmVjdGl2ZV0sXG4gIGVudHJ5Q29tcG9uZW50czogW1BvcG92ZXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IEhpZXJhcmNoeUJhckNvbXBvbmVudCB9IGZyb20gJy4vaGllcmFyY2h5LWJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL3BvcG92ZXIvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGUsXG4gICAgICAgIFBvcG92ZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtIaWVyYXJjaHlCYXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0hpZXJhcmNoeUJhckNvbXBvbmVudF0sXG59KVxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbFNlcnZpY2Uge1xuXG4gICAgb3BlbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KGZhbHNlKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgU2lkZVBhbmVsU2VydmljZSB9IGZyb20gJy4vc2lkZS1wYW5lbC5zZXJ2aWNlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC1zaWRlLXBhbmVsJyxcclxuICAgIGV4cG9ydEFzOiAndXgtc2lkZS1wYW5lbCcsXHJcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCJtb2RhbCAmJiBvcGVuXCIgY2xhc3M9XCJtb2RhbC1iYWNrZHJvcFwiXHJcbiAgICBbc3R5bGUucG9zaXRpb25dPVwicG9zaXRpb25cIlxyXG4gICAgW3N0eWxlLnRvcF09XCJjc3NUb3BcIj48L2Rpdj5cclxuXHJcbjxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWhvc3RcIlxyXG4gICAgW2NsYXNzLm1vZGFsLXBhbmVsXT1cIm1vZGFsXCJcclxuICAgIFtzdHlsZS5wb3NpdGlvbl09XCJwb3NpdGlvblwiXHJcbiAgICBbc3R5bGUud2lkdGhdPVwiaG9zdFdpZHRoXCJcclxuICAgIFtzdHlsZS50b3BdPVwiY3NzVG9wXCI+XHJcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbjwvZGl2PlxyXG5gLFxyXG4gICAgcHJvdmlkZXJzOiBbU2lkZVBhbmVsU2VydmljZV0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ2NsYXNzJzogJ3V4LXNpZGUtcGFuZWwnXHJcbiAgICB9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIEBIb3N0QmluZGluZygnY2xhc3Mub3BlbicpXHJcbiAgICBnZXQgb3BlbigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLm9wZW4kLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlLm9wZW4kLm5leHQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlubGluZScpXHJcbiAgICBpbmxpbmUgPSBmYWxzZTtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgYXR0YWNoVG86ICd3aW5kb3cnIHwgJ2NvbnRhaW5lcicgPSAnd2luZG93JztcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgd2lkdGg6IHN0cmluZyB8IG51bWJlciA9ICc1MCUnO1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICB0b3A6IHN0cmluZyB8IG51bWJlciA9ICcwJztcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtbW9kYWwnKVxyXG4gICAgbW9kYWwgPSBmYWxzZTtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hbmltYXRlJylcclxuICAgIGFuaW1hdGUgPSBmYWxzZTtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgY2xvc2VPbkV4dGVybmFsQ2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgICBAT3V0cHV0KClcclxuICAgIG9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3N0YXRpYyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF0dGFjaFRvID09PSAnY29udGFpbmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Fic29sdXRlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdmaXhlZCc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGNzc1dpZHRoKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndpZHRoID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gMCA/ICcwJyA6IHRoaXMud2lkdGggKyAncHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY3NzVG9wKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvcCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wID09PSAwID8gJzAnIDogdGhpcy50b3AgKyAncHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b3A7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aCcpXHJcbiAgICBnZXQgY29tcG9uZW50V2lkdGgoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMuY3NzV2lkdGggOiAnMCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBob3N0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5saW5lID8gJzEwMCUnIDogdGhpcy5jc3NXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcm90ZWN0ZWQgc2VydmljZTogU2lkZVBhbmVsU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmXHJcbiAgICApIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuc2VydmljZS5vcGVuJC5zdWJzY3JpYmUoKG5leHQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuQ2hhbmdlLmVtaXQobmV4dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb3BlblBhbmVsKCkge1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5vcGVuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6a2V5dXAuZXNjYXBlJylcclxuICAgIGNsb3NlUGFuZWwoKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudCddKVxyXG4gICAgY2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wZW4gfHwgIXRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpIHx8XHJcbiAgICAgICAgICAgICh0YXJnZXQgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnbW9kYWwtYmFja2Ryb3AnKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgU2lkZVBhbmVsQ29tcG9uZW50IH0gZnJvbSAnLi4vc2lkZS1wYW5lbC9zaWRlLXBhbmVsLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFNpZGVQYW5lbFNlcnZpY2UgfSBmcm9tICcuLi9zaWRlLXBhbmVsL3NpZGUtcGFuZWwuc2VydmljZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3V4SXRlbURpc3BsYXlQYW5lbENvbnRlbnRdJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbENvbnRlbnREaXJlY3RpdmUgeyB9XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3V4SXRlbURpc3BsYXlQYW5lbEZvb3Rlcl0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlIHsgfVxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LWl0ZW0tZGlzcGxheS1wYW5lbCcsXHJcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWhvc3QgdXgtaXRlbS1kaXNwbGF5LXBhbmVsXCJcclxuICAgIFtjbGFzcy5ib3gtc2hhZG93XT1cImJveFNoYWRvd1wiXHJcbiAgICBbc3R5bGUucG9zaXRpb25dPVwicG9zaXRpb25cIlxyXG4gICAgW3N0eWxlLndpZHRoXT1cImhvc3RXaWR0aFwiXHJcbiAgICBbc3R5bGUudG9wXT1cImNzc1RvcFwiPlxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWhlYWRlclwiIFtjbGFzcy5pdGVtLWRpc3BsYXktcGFuZWwtc2hhZG93XT1cInNoYWRvd1wiPlxyXG4gICAgICAgIDxoMz57eyBoZWFkZXIgfX08L2gzPlxyXG4gICAgICAgIDxidXR0b24gKm5nSWY9XCJjbG9zZVZpc2libGVcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxnIGJ0bi1saW5rIGJ0bi1pY29uIGJ1dHRvbi1zZWNvbmRhcnlcIiAoY2xpY2spPVwidmlzaWJsZSA9IGZhbHNlXCI+XHJcbiAgICAgICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb24gaHBlLWNsb3NlXCI+PC9pPlxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPGRpdiBjbGFzcz1cInV4LXNpZGUtcGFuZWwtY29udGVudFwiPlxyXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIlt1eEl0ZW1EaXNwbGF5UGFuZWxDb250ZW50XVwiPjwvbmctY29udGVudD5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWZvb3RlclwiICpuZ0lmPVwiZm9vdGVyXCI+XHJcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW3V4SXRlbURpc3BsYXlQYW5lbEZvb3Rlcl1cIj48L25nLWNvbnRlbnQ+XHJcbiAgICA8L2Rpdj5cclxuXHJcbjwvZGl2PlxyXG5gLFxyXG4gICAgcHJvdmlkZXJzOiBbU2lkZVBhbmVsU2VydmljZV0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ2NsYXNzJzogJ3V4LXNpZGUtcGFuZWwgdXgtaXRlbS1kaXNwbGF5LXBhbmVsJ1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCBleHRlbmRzIFNpZGVQYW5lbENvbXBvbmVudCB7XHJcblxyXG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XHJcblxyXG4gICAgQElucHV0KCkgYm94U2hhZG93OiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBASW5wdXQoKSBjbG9zZVZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIGdldCBwcmV2ZW50Q2xvc2UoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBzZXQgcHJldmVudENsb3NlKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayA9ICF2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSBzaGFkb3c6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBAQ29udGVudENoaWxkKEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmUpIGZvb3RlcjogSXRlbURpc3BsYXlQYW5lbEZvb3RlckRpcmVjdGl2ZTtcclxuXHJcbiAgICBAT3V0cHV0KCkgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIFRpdGxlIHVzZWQgZm9yIGFkZGluZyB0b29sdGlwcyBhbmQgc2hvdWxkbid0IGJlIHVzZWQgYXMgYW4gaW5wdXRcclxuICAgICAqIGluc3RlYWQgaGVhZGVyIHdpbGwgYmUgdXNlZC4gVGhpcyBpcyBoZXJlIHRvIHN1cHBvcnQgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbmx5XHJcbiAgICAgKiB0aGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgdXNlZC5cclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIHNldCB0aXRsZSh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdGl0bGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBzZXQgdmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5vcGVuID0gdmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdmlzaWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcGVuO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2l0ZW1EaXNwbGF5UGFuZWxTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlOiBTaWRlUGFuZWxTZXJ2aWNlLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XHJcbiAgICAgICAgc3VwZXIoc2VydmljZSwgZWxlbWVudFJlZik7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2sgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuX2l0ZW1EaXNwbGF5UGFuZWxTdWJzY3JpcHRpb24gPSB0aGlzLnNlcnZpY2Uub3BlbiQuc3Vic2NyaWJlKChuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KG5leHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2l0ZW1EaXNwbGF5UGFuZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCwgSXRlbURpc3BsYXlQYW5lbENvbnRlbnREaXJlY3RpdmUsIEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmUgfSBmcm9tICcuL2l0ZW0tZGlzcGxheS1wYW5lbC5jb21wb25lbnQnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCxcbiAgICBJdGVtRGlzcGxheVBhbmVsQ29udGVudERpcmVjdGl2ZSxcbiAgICBJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbE1vZHVsZSB7fSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXdpemFyZC1zdGVwJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nSWY9XCJhY3RpdmVcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L25nLWNvbnRhaW5lcj5gXG59KVxuZXhwb3J0IGNsYXNzIFdpemFyZFN0ZXBDb21wb25lbnQge1xuICAgIFxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSB2aXNpdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgcHJpdmF0ZSBfYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdmlzaXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KCkgXG4gICAgZ2V0IHZpc2l0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdGVkO1xuICAgIH1cblxuICAgIHNldCB2aXNpdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0ZWQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aXNpdGVkQ2hhbmdlLm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIHNldCBhY3RpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgXG4gICAgICAgIC8vIHN0b3JlIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHN0ZXBcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIHRydWUgdGhlbiB0aGUgc3RlcCBzaG91bGQgYWxzbyBiZSBtYXJrZWQgYXMgdmlzaXRlZFxuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cblxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC13aXphcmQnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cIndpemFyZC1ib2R5XCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwid2l6YXJkLXN0ZXBzXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cIndpemFyZC1zdGVwXCIgW2NsYXNzLmFjdGl2ZV09XCJzdHAuYWN0aXZlXCIgW2NsYXNzLnZpc2l0ZWRdPVwic3RwLnZpc2l0ZWRcIiBbY2xhc3MuaW52YWxpZF09XCJzdHAuYWN0aXZlICYmICFzdHAudmFsaWQgJiYgaW52YWxpZEluZGljYXRvclwiIChjbGljayk9XCJnb3RvU3RlcChzdHApXCIgKm5nRm9yPVwibGV0IHN0cCBvZiBzdGVwc1wiPlxuICAgICAgICAgICAge3sgc3RwLmhlYWRlciB9fVxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIndpemFyZC1jb250ZW50XCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJ3aXphcmQtZm9vdGVyXCI+XG4gICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1zZWNvbmRhcnlcIiAqbmdJZj1cInByZXZpb3VzVmlzaWJsZVwiIFt1eFRvb2x0aXBdPVwicHJldmlvdXNUb29sdGlwXCIgW2Rpc2FibGVkXT1cInByZXZpb3VzRGlzYWJsZWQgfHwgc3RlcCA9PT0gMFwiXG4gICAgICAgIChjbGljayk9XCJwcmV2aW91cygpOyB0aXAuaGlkZSgpXCI+e3sgcHJldmlvdXNUZXh0IH19PC9idXR0b24+XG5cbiAgICA8YnV0dG9uICN0aXA9XCJ1eC10b29sdGlwXCIgY2xhc3M9XCJidG4gYnV0dG9uLXByaW1hcnlcIiAqbmdJZj1cIm5leHRWaXNpYmxlICYmICFpc0xhc3RTdGVwKClcIiBbdXhUb29sdGlwXT1cIm5leHRUb29sdGlwXCIgW2Rpc2FibGVkXT1cIm5leHREaXNhYmxlZFwiXG4gICAgICAgIChjbGljayk9XCJuZXh0KCk7IHRpcC5oaWRlKClcIj57eyBuZXh0VGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1wcmltYXJ5XCIgKm5nSWY9XCJmaW5pc2hWaXNpYmxlICYmIGlzTGFzdFN0ZXAoKSB8fCBmaW5pc2hBbHdheXNWaXNpYmxlXCIgW3V4VG9vbHRpcF09XCJmaW5pc2hUb29sdGlwXCJcbiAgICAgICAgW2Rpc2FibGVkXT1cImZpbmlzaERpc2FibGVkXCIgKGNsaWNrKT1cImZpbmlzaCgpOyB0aXAuaGlkZSgpXCI+e3sgZmluaXNoVGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1zZWNvbmRhcnlcIiAqbmdJZj1cImNhbmNlbFZpc2libGUgJiYgIWlzTGFzdFN0ZXAoKSB8fCBjYW5jZWxBbHdheXNWaXNpYmxlXCIgW3V4VG9vbHRpcF09XCJjYW5jZWxUb29sdGlwXCJcbiAgICAgICAgW2Rpc2FibGVkXT1cImNhbmNlbERpc2FibGVkXCIgKGNsaWNrKT1cImNhbmNlbCgpOyB0aXAuaGlkZSgpXCI+e3sgY2FuY2VsVGV4dCB9fTwvYnV0dG9uPlxuPC9kaXY+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3NdJzogJ29yaWVudGF0aW9uJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBwcml2YXRlIF9zdGVwOiBudW1iZXIgPSAwO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihXaXphcmRTdGVwQ29tcG9uZW50KSBzdGVwcyA9IG5ldyBRdWVyeUxpc3Q8V2l6YXJkU3RlcENvbXBvbmVudD4oKTtcblxuICAgIEBJbnB1dCgpIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuXG4gICAgQElucHV0KCkgbmV4dFRleHQ6IHN0cmluZyA9ICdOZXh0JztcbiAgICBASW5wdXQoKSBwcmV2aW91c1RleHQ6IHN0cmluZyA9ICdQcmV2aW91cyc7XG4gICAgQElucHV0KCkgY2FuY2VsVGV4dDogc3RyaW5nID0gJ0NhbmNlbCc7XG4gICAgQElucHV0KCkgZmluaXNoVGV4dDogc3RyaW5nID0gJ0ZpbmlzaCc7XG5cbiAgICBASW5wdXQoKSBuZXh0VG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBuZXh0IHN0ZXAnO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBwcmV2aW91cyBzdGVwJztcbiAgICBASW5wdXQoKSBjYW5jZWxUb29sdGlwOiBzdHJpbmcgPSAnQ2FuY2VsIHRoZSB3aXphcmQnO1xuICAgIEBJbnB1dCgpIGZpbmlzaFRvb2x0aXA6IHN0cmluZyA9ICdGaW5pc2ggdGhlIHdpemFyZCc7XG5cbiAgICBASW5wdXQoKSBuZXh0RGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBwcmV2aW91c0Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgY2FuY2VsRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBmaW5pc2hEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KCkgbmV4dFZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgY2FuY2VsVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZmluaXNoVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgY2FuY2VsQWx3YXlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGZpbmlzaEFsd2F5c1Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKSBvbk5leHQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgICBAT3V0cHV0KCkgb25QcmV2aW91cyA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICAgIEBPdXRwdXQoKSBvbkNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgb25GaW5pc2hpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIG9uRmluaXNoID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBzdGVwQ2hhbmdpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFN0ZXBDaGFuZ2luZ0V2ZW50PigpO1xuICAgIEBPdXRwdXQoKSBzdGVwQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBpbnZhbGlkSW5kaWNhdG9yOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICB9XG4gICAgc2V0IHN0ZXAodmFsdWU6IG51bWJlcikge1xuXG4gICAgICAgIC8vIG9ubHkgYWNjZXB0IG51bWJlcnMgYXMgdmFsaWQgb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgYWN0aXZlIHN0ZXBcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHdoaWNoIHN0ZXBzIHNob3VsZCBiZSBhY3RpdmVcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgdGhpcy5zdGVwQ2hhbmdlLm5leHQodGhpcy5zdGVwKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludmFsaWQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEluZGljYXRvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGluaXRpYWxseSBzZXQgdGhlIGNvcnJlY3QgdmlzaWJpbGl0eSBvZiB0aGUgc3RlcHNcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byB0aGUgbmV4dCBzdGVwXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLnN0ZXBDaGFuZ2luZy5uZXh0KG5ldyBTdGVwQ2hhbmdpbmdFdmVudCh0aGlzLnN0ZXAsIHRoaXMuc3RlcCArIDEpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHN0ZXAgaXMgaW52YWxpZFxuICAgICAgICBpZiAoIXRoaXMuZ2V0Q3VycmVudFN0ZXAoKS52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkSW5kaWNhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gdGhlIGxhc3Qgc3RlcFxuICAgICAgICBpZiAoKHRoaXMuc3RlcCArIDEpIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcCsrO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgICAgIHRoaXMub25OZXh0Lm5leHQodGhpcy5zdGVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBzdGVwXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5zdGVwQ2hhbmdpbmcubmV4dChuZXcgU3RlcENoYW5naW5nRXZlbnQodGhpcy5zdGVwLCB0aGlzLnN0ZXAgLSAxKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiB0aGUgbGFzdCBzdGVwXG4gICAgICAgIGlmICh0aGlzLnN0ZXAgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAtLTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgY3VycmVudCBzdGVwXG4gICAgICAgICAgICB0aGlzLm9uUHJldmlvdXMubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhY3Rpb25zIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZpbmlzaCgpOiBQcm9taXNlPHZvaWQ+IHtcblxuICAgICAgICAvLyBmaXJlcyB3aGVuIHRoZSBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgYWx3YXlzXG4gICAgICAgIHRoaXMub25GaW5pc2hpbmcubmV4dCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2Ugd2UgbmVlZCB0byBlbnN1cmUgY2hhbmdlIGRldGVjdGlvbiBoYXMgcnVuXG4gICAgICAgICAqIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB3ZSBoYXZlIHRoZSBsYXRlc3QgdmFsdWUgZm9yIHRoZSAndmFsaWQnIGlucHV0XG4gICAgICAgICAqIG9uIHRoZSBjdXJyZW50IHN0ZXAuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QgdXNlIENoYW5nZURldGVjdG9yUmVmIGFzIHdlIGFyZSBsb29raW5nIHRvIHJ1blxuICAgICAgICAgKiBvbiBjb250ZW50IGNoaWxkcmVuLCBhbmQgd2UgY2FudCB1c2UgQXBwbGljYXRpb25SZWYudGljaygpIGFzIHRoaXMgZG9lcyBub3Qgd29yayBpbiBhIGh5YnJpZCBhcHAsIGVnLiBvdXIgZG9jc1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGZpcmVzIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIHN0ZXAgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50U3RlcCgpLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25GaW5pc2gubmV4dCgpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWN0aW9ucyB3aGVuIHRoZSBjYW5jZWwgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBjYW5jZWwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DYW5jZWwubmV4dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYWN0aXZlIHN0YXRlIG9mIGVhY2ggc3RlcFxuICAgICAqL1xuICAgIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gdXBkYXRlIHdoaWNoIHN0ZXBzIHNob3VsZCBiZSBhY3RpdmVcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwLCBpZHgpID0+IHN0ZXAuYWN0aXZlID0gaWR4ID09PSB0aGlzLnN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1bXAgdG8gYSBzcGVjaWZpYyBzdGVwIG9ubHkgaWYgdGhlIHN0ZXAgaGFzIHByZXZpb3VzbHkgYmVlbiB2aXNpdGVkXG4gICAgICovXG4gICAgZ290b1N0ZXAoc3RlcDogV2l6YXJkU3RlcENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoc3RlcC52aXNpdGVkKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJbmRleCA9IHRoaXMuc3RlcHMudG9BcnJheSgpLmZpbmRJbmRleChzdHAgPT4gc3RwID09PSBzdGVwKTtcblxuICAgICAgICAgICAgdGhpcy5zdGVwQ2hhbmdpbmcubmV4dChuZXcgU3RlcENoYW5naW5nRXZlbnQodGhpcy5zdGVwLCBzdGVwSW5kZXgpKTtcblxuICAgICAgICAgICAgdGhpcy5zdGVwID0gc3RlcEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHN0ZXAgaXMgdGhlIGxhc3Qgc3RlcFxuICAgICAqL1xuICAgIGlzTGFzdFN0ZXAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXAgPT09ICh0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB3aXphcmQgLSBnb2VzIHRvIGZpcnN0IHN0ZXAgYW5kIHJlc2V0cyB2aXNpdGVkIHN0YXRlXG4gICAgICovXG4gICAgcmVzZXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gbWFyayBhbGwgc3RlcHMgYXMgbm90IHZpc2l0ZWRcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gc3RlcC52aXNpdGVkID0gZmFsc2UpO1xuXG4gICAgICAgIC8vIGdvIHRvIHRoZSBmaXJzdCBzdGVwXG4gICAgICAgIHRoaXMuc3RlcCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGVwIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICovXG4gICAgZ2V0Q3VycmVudFN0ZXAoKTogV2l6YXJkU3RlcENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXBBdEluZGV4KHRoaXMuc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RlcCBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RlcEF0SW5kZXgoaW5kZXg6IG51bWJlcik6IFdpemFyZFN0ZXBDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy50b0FycmF5KClbaW5kZXhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0ZXBDaGFuZ2luZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZnJvbTogbnVtYmVyLCBwdWJsaWMgdG86IG51bWJlcikgeyB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBXaXphcmRDb21wb25lbnQgfSBmcm9tICcuL3dpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFdpemFyZENvbXBvbmVudCxcbiAgICBXaXphcmRTdGVwQ29tcG9uZW50XG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBpcyByZXF1aXJlZCB0byBwcm92aWRlIGEgZm9ybSBvZiBjb21tdW5pY2F0aW9uXG4gKiBiZXR3ZWVuIHRoZSBtYXJxdWVlIHdpemFyZCBzdGVwcyBhbmQgdGhlIGNvbnRhaW5pbmcgbWFycXVlZSB3aXphcmQuXG4gKiBXZSBjYW5ub3QgaW5qZWN0IHRoZSBIb3N0IGR1ZSB0byB0aGUgc3RlcHMgYmVpbmcgY29udGVudCBjaGlsZHJlbiBcbiAqIHJhdGhlciB0aGFuIHZpZXcgY2hpbGRyZW4uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkU2VydmljZSB7XG4gICAgdmFsaWQkID0gbmV3IFN1YmplY3Q8TWFycXVlZVdpemFyZFZhbGlkRXZlbnQ+KCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFZhbGlkRXZlbnQge1xuICAgIHN0ZXA6IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50O1xuICAgIHZhbGlkOiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTZXJ2aWNlIH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tYXJxdWVlLXdpemFyZC1zdGVwJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nSWY9XCJhY3RpdmVcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L25nLWNvbnRhaW5lcj5gXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50IGV4dGVuZHMgV2l6YXJkU3RlcENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBpY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY29tcGxldGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQE91dHB1dCgpIGNvbXBsZXRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgICBcbiAgICBnZXQgdmFsaWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgICB9XG5cbiAgICBzZXQgdmFsaWQodmFsaWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmFsaWQgPSB2YWxpZDtcblxuICAgICAgICBpZiAodGhpcy5fbWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcnF1ZWVXaXphcmRTZXJ2aWNlLnZhbGlkJC5uZXh0KHsgc3RlcDogdGhpcywgdmFsaWQ6IHZhbGlkIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFycXVlZVdpemFyZFNlcnZpY2U6IE1hcnF1ZWVXaXphcmRTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjb21wbGV0ZWQgc3RhdGUgYW5kIGVtaXQgdGhlIGxhdGVzdCB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb21wbGV0ZWQgd2hldGhlciBvciBub3QgdGhlIHN0ZXAgaXMgY29tcGxldGVkXG4gICAgICovXG4gICAgc2V0Q29tcGxldGVkKGNvbXBsZXRlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGNvbXBsZXRlZDtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWRDaGFuZ2UuZW1pdChjb21wbGV0ZWQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgSW5wdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFdpemFyZENvbXBvbmVudCB9IGZyb20gJy4uL3dpemFyZC9pbmRleCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZFNlcnZpY2UsIE1hcnF1ZWVXaXphcmRWYWxpZEV2ZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tYXJxdWVlLXdpemFyZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwibWFycXVlZS13aXphcmQtc2lkZS1wYW5lbFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLWRlc2NyaXB0aW9uLWNvbnRhaW5lclwiICpuZ0lmPVwiZGVzY3JpcHRpb25cIj5cbiAgICAgICAgPCEtLSBJZiBhIHRlbXBsYXRlIHdhcyBwcm92aWRlZCBkaXNwbGF5IGl0IC0tPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaXNUZW1wbGF0ZVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRlc2NyaXB0aW9uXCI+PC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPCEtLSBPdGhlcndpc2Ugd2ltcGx5IGRpc3BsYXkgdGhlIHN0cmluZyAtLT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlXCI+XG4gICAgICAgICAgICA8cD57eyBkZXNjcmlwdGlvbiB9fTwvcD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8dWwgY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1zdGVwc1wiPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLXN0ZXBcIiAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwc1wiIChjbGljayk9XCJnb3RvU3RlcChzdGVwKVwiIFtjbGFzcy5hY3RpdmVdPVwic3RlcC5hY3RpdmVcIiBbY2xhc3MudmlzaXRlZF09XCJzdGVwLnZpc2l0ZWRcIiBbY2xhc3MuaW52YWxpZF09XCIhc3RlcC52YWxpZFwiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1zdGVwLWljb25cIiBbbmdDbGFzc109XCJzdGVwLmljb25cIj48L2k+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLXN0ZXAtdGl0bGVcIj57eyBzdGVwLmhlYWRlciB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibWFycXVlZS13aXphcmQtc3RlcC1zdGF0dXMgaHBlLWljb24gaHBlLWNoZWNrbWFya1wiICpuZ0lmPVwic3RlcC5jb21wbGV0ZWRcIj48L3NwYW4+XG4gICAgICAgIDwvbGk+XG5cbiAgICA8L3VsPlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1jb250ZW50LXBhbmVsXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLWNvbnRlbnRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuXG4gICAgICAgIDxidXR0b24gI3RpcD1cInV4LXRvb2x0aXBcIiBjbGFzcz1cImJ0biBidXR0b24tc2Vjb25kYXJ5XCIgKm5nSWY9XCJwcmV2aW91c1Zpc2libGVcIiBbdXhUb29sdGlwXT1cInByZXZpb3VzVG9vbHRpcFwiIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cInByZXZpb3VzRGlzYWJsZWQgfHwgc3RlcCA9PT0gMFwiIChjbGljayk9XCJwcmV2aW91cygpOyB0aXAuaGlkZSgpXCI+e3sgcHJldmlvdXNUZXh0IH19PC9idXR0b24+XG5cbiAgICAgICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1wcmltYXJ5XCIgKm5nSWY9XCJuZXh0VmlzaWJsZSAmJiAhaXNMYXN0U3RlcCgpXCIgW3V4VG9vbHRpcF09XCJuZXh0VG9vbHRpcFwiIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cIm5leHREaXNhYmxlZFwiIChjbGljayk9XCJuZXh0KCk7IHRpcC5oaWRlKClcIj57eyBuZXh0VGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgICAgIDxidXR0b24gI3RpcD1cInV4LXRvb2x0aXBcIiBjbGFzcz1cImJ0biBidXR0b24tcHJpbWFyeVwiICpuZ0lmPVwiZmluaXNoVmlzaWJsZSAmJiBpc0xhc3RTdGVwKCkgfHwgZmluaXNoQWx3YXlzVmlzaWJsZVwiIFt1eFRvb2x0aXBdPVwiZmluaXNoVG9vbHRpcFwiXG4gICAgICAgICAgICBjb250YWluZXI9XCJib2R5XCIgW2Rpc2FibGVkXT1cImZpbmlzaERpc2FibGVkXCIgKGNsaWNrKT1cImZpbmlzaCgpOyB0aXAuaGlkZSgpXCI+e3sgZmluaXNoVGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgICAgIDxidXR0b24gI3RpcD1cInV4LXRvb2x0aXBcIiBjbGFzcz1cImJ0biBidXR0b24tc2Vjb25kYXJ5XCIgKm5nSWY9XCJjYW5jZWxWaXNpYmxlICYmICFpc0xhc3RTdGVwKCkgfHwgY2FuY2VsQWx3YXlzVmlzaWJsZVwiIFt1eFRvb2x0aXBdPVwiY2FuY2VsVG9vbHRpcFwiXG4gICAgICAgICAgICBjb250YWluZXI9XCJib2R5XCIgW2Rpc2FibGVkXT1cImNhbmNlbERpc2FibGVkXCIgKGNsaWNrKT1cImNhbmNlbCgpOyB0aXAuaGlkZSgpXCI+e3sgY2FuY2VsVGV4dCB9fTwvYnV0dG9uPlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBwcm92aWRlcnM6IFsgTWFycXVlZVdpemFyZFNlcnZpY2UgXVxufSlcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkQ29tcG9uZW50IGV4dGVuZHMgV2l6YXJkQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGRyZW4oTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQpIHN0ZXBzID0gbmV3IFF1ZXJ5TGlzdDxNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudD4oKTtcblxuICAgIGdldCBpc1RlbXBsYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbiAmJiB0aGlzLmRlc2NyaXB0aW9uIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IobWFycXVlZVdpemFyZFNlcnZpY2U6IE1hcnF1ZWVXaXphcmRTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgbWFycXVlZVdpemFyZFNlcnZpY2UudmFsaWQkLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGV2ZW50OiBNYXJxdWVlV2l6YXJkVmFsaWRFdmVudCkgPT4gIWV2ZW50LnZhbGlkKVxuICAgICAgICApLnN1YnNjcmliZSh0aGlzLnZhbGlkQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBjdXJyZW50IHN0ZXAgaXMgdmFsaWQsIG1hcmsgaXQgYXNcbiAgICAgKiBjb21wbGV0ZSBhbmQgZ28gdG8gdGhlIG5leHQgc3RlcFxuICAgICAqL1xuICAgIG5leHQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKSBhcyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudDtcblxuICAgICAgICBpZiAoc3RlcC52YWxpZCkge1xuICAgICAgICAgICAgc3VwZXIubmV4dCgpO1xuXG4gICAgICAgICAgICAvLyBtYXJrIHRoaXMgc3RlcCBhcyBjb21wbGV0ZWRcbiAgICAgICAgICAgIHN0ZXAuc2V0Q29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdCB0aGUgb25GaW5pc2hpbmcgZXZlbnQgYW5kIGlmIHZhbGlkIHRoZSBvbkZpbmlzaCBldmVudC5cbiAgICAgKiBBbHNvIG1hcmsgdGhlIGZpbmFsIHN0ZXAgYXMgY29tcGxldGVkIGlmIGl0IGlzIHZhbGlkXG4gICAgICovXG4gICAgZmluaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBzdGVwXG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCkgYXMgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQ7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgb3JpZ2luYWwgZmluaXNoIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBzdXBlci5maW5pc2goKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGVwIGlzIHZhbGlkIGluZGljYXRlIHRoYXQgaXQgaXMgbm93IGNvbXBsZXRlXG4gICAgICAgICAgICBpZiAoc3RlcC52YWxpZCkge1xuICAgICAgICAgICAgICAgIHN0ZXAuc2V0Q29tcGxldGVkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBhIHN0ZXAgaW4gdGhlIHdpemFyZCBiZWNvbWVzIGludmFsaWQsIGFsbCBzdGVwcyBzZXF1ZW50aWFsbHkgYWZ0ZXJcbiAgICAgKiBpdCwgc2hvdWxkIGJlY29tZSB1bnZpc2l0ZWQgYW5kIGluY29tcGxldGVcbiAgICAgKi9cbiAgICB2YWxpZENoYW5nZShzdGF0ZTogTWFycXVlZVdpemFyZFZhbGlkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBzdGVwcyA9IHRoaXMuc3RlcHMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gc3RlcHMuZmluZEluZGV4KHN0ZXAgPT4gc3RlcCA9PT0gc3RhdGUuc3RlcCk7XG4gICAgICAgIGNvbnN0IGFmZmVjdGVkID0gc3RlcHMuc2xpY2UoY3VycmVudCk7XG5cbiAgICAgICAgYWZmZWN0ZWQuZm9yRWFjaChzdGVwID0+IHtcblxuICAgICAgICAgICAgLy8gdGhlIHN0ZXAgc2hvdWxkIG5vIGxvbmdlciBiZSBjb21wbGV0ZWRcbiAgICAgICAgICAgIHN0ZXAuY29tcGxldGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGVwIGlzIG5vdCB0aGUgY3VycmVudCBzdGVwIHRoZW4gYWxzbyBtYXJrIGl0IGFzIHVudmlzaXRlZFxuICAgICAgICAgICAgaWYgKHN0ZXAgIT09IHN0YXRlLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBzdGVwLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFdpemFyZE1vZHVsZSB9IGZyb20gJy4uL3dpemFyZC9pbmRleCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgV2l6YXJkTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE1hcnF1ZWVXaXphcmRDb21wb25lbnQsXG4gICAgICAgIE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50XG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgTWFycXVlZVdpemFyZENvbXBvbmVudCxcbiAgICAgICAgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwLCBSZXNwb25zZUNvbnRlbnRUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBdWRpb1NlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBfYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyO1xuICAgIHByaXZhdGUgX2F1ZGlvQnVmZmVyU291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XG4gICAgcHJpdmF0ZSBfYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBfZ2Fpbk5vZGU6IEdhaW5Ob2RlO1xuICAgIHByaXZhdGUgX2FuYWx5c2VyTm9kZTogQW5hbHlzZXJOb2RlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaHR0cDogSHR0cCkgeyB9XG5cbiAgICBnZXRBdWRpb0ZpbGVNZXRhZGF0YShtZWRpYUVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9NZXRhZGF0YT4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAucmVxdWVzdChtZWRpYUVsZW1lbnQuc3JjLCB7IHJlc3BvbnNlVHlwZTogUmVzcG9uc2VDb250ZW50VHlwZS5CbG9iIH0pLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IG1lZGlhRWxlbWVudC5zcmMuc3Vic3RyaW5nKG1lZGlhRWxlbWVudC5zcmMubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1lZGlhRWxlbWVudC5zcmMuc3Vic3RyaW5nKG1lZGlhRWxlbWVudC5zcmMubGFzdEluZGV4T2YoJy4nKSArIDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb247XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnTVBFRyBhdWRpbyBsYXllciAzIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd21hJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ1dpbmRvd3MgbWVkaWEgYXVkaW8gZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YXYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnV0FWRSBhdWRpbyBmaWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdPZ2cgVm9yYmlzIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ0FkdmFuY2VkIGF1ZGlvIGNvZGluZyBmaWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGknOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnTXVzaWNhbCBpbnN0cnVtZW50IGRpZ2l0YWwgaW50ZXJmYWNlIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ0F1ZGlvIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogYmxvYi5zaXplXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0V2F2ZWZvcm1Gcm9tVXJsKHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxGbG9hdDMyQXJyYXlbXT4ge1xuXG4gICAgICAgIC8vIGlmIGF1ZGlvIGNvbnRleHQgaXMgbm90IHN1cHBvcnQgcmV0dXJuIGEgc3RyZWFtIG9mIGVtcHR5IGRhdGFcbiAgICAgICAgaWYgKCEoPGFueT53aW5kb3cpLkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG9mPEZsb2F0MzJBcnJheVtdPihbbmV3IEZsb2F0MzJBcnJheSgwKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZvbHVtZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVBbmFseXNlck5vZGUoKTtcblxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxGbG9hdDMyQXJyYXlbXT4pID0+IHtcblxuICAgICAgICAgICAgLy8gbG9hZCB0aGUgbWVkaWEgZnJvbSB0aGUgVVJMIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLl9odHRwLnJlcXVlc3QodXJsLCB7IHJlc3BvbnNlVHlwZTogUmVzcG9uc2VDb250ZW50VHlwZS5BcnJheUJ1ZmZlciB9KS5zdWJzY3JpYmUocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXVkaW9CdWZmZXIocmVzcG9uc2UuYXJyYXlCdWZmZXIoKSkuc3Vic2NyaWJlKGF1ZGlvQnVmZmVyID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGJ1ZmZlciBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhUG9pbnRzOiBGbG9hdDMyQXJyYXlbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuX2F1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgZGF0YSBmcm9tIGVhY2ggY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFubmVsSWR4ID0gMDsgY2hhbm5lbElkeCA8IGNoYW5uZWxzOyBjaGFubmVsSWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQb2ludHNbY2hhbm5lbElkeF0gPSB0aGlzLl9hdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZGF0YVBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW51cCBhZnRlciBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgZGF0YVBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRXYXZlZm9ybVBvaW50cyhjaGFubmVsczogRmxvYXQzMkFycmF5W10gPSBbXSwgc2tpcDogbnVtYmVyID0gMTAwMCk6IFdhdmVmb3JtUG9pbnRbXSB7XG5cbiAgICAgICAgY29uc3Qgd2F2ZWZvcm06IFdhdmVmb3JtUG9pbnRbXSA9IFtdO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGNoYW5uZWxzLmxlbmd0aCA+IDAgPyBjaGFubmVsc1swXS5sZW5ndGggOiAwO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBjaGFubmVsIGRhdGEgdG8gYSBzZXJpZXMgb2Ygd2F2ZWZvcm0gcG9pbnRzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGR1cmF0aW9uOyBpZHggKz0gc2tpcCkge1xuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIHRoZSBjaGFubmVsIGRhdGEgZm9yIGEgc3BlY2lmaWMgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGNoYW5uZWxzLm1hcChjaGFubmVsID0+IGNoYW5uZWxbaWR4XSk7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gcG9pbnQgYW5kIG1heGltdW0gcG9pbnRzIGF0IGVhY2ggcG9zaXRpb24gYWNyb3NzIGFsbCBjaGFubmVsc1xuICAgICAgICAgICAgd2F2ZWZvcm0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluOiBwb2ludHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gY3VycmVudCA8IHByZXZpb3VzID8gY3VycmVudCA6IHByZXZpb3VzKSxcbiAgICAgICAgICAgICAgICBtYXg6IHBvaW50cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBjdXJyZW50ID4gcHJldmlvdXMgPyBjdXJyZW50IDogcHJldmlvdXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3YXZlZm9ybTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEF1ZGlvQnVmZmVyKGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlcik6IE9ic2VydmFibGU8QXVkaW9CdWZmZXI+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9CdWZmZXI+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldE9mZmxpbmVBdWRpb0NvbnRleHQoKS5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIsIChhdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9mZmxpbmVBdWRpb0NvbnRleHQoKTogT2ZmbGluZUF1ZGlvQ29udGV4dCB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAyLCB0aGlzLl9hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSB8fCA0NDEwMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpO1xuXG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICB0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLl9hdWRpb0J1ZmZlcjtcbiAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl9hbmFseXNlck5vZGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlVm9sdW1lTm9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB0aGlzLl9nYWluTm9kZS5jb25uZWN0KHRoaXMuX2F1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVBbmFseXNlck5vZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FuYWx5c2VyTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICB0aGlzLl9hbmFseXNlck5vZGUuY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkaXNjb25uZWN0U291cmNlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYXZlZm9ybVBvaW50IHtcbiAgICBtaW46IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb01ldGFkYXRhIHtcbiAgICBmaWxlbmFtZTogc3RyaW5nO1xuICAgIGV4dGVuc2lvbjogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc2l6ZTogbnVtYmVyO1xufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG5pbXBvcnQgeyBBdWRpb1NlcnZpY2UgfSBmcm9tICcuL2F1ZGlvLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFsgSHR0cE1vZHVsZSBdLFxuICAgIHByb3ZpZGVyczogW0F1ZGlvU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQXVkaW9TZXJ2aWNlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvY29uY2F0JztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzL09ic2VydmVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZyYW1lRXh0cmFjdGlvblNlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBjcmVhdGVWaWRlb1BsYXllcihzb3VyY2U6IHN0cmluZyk6IEhUTUxWaWRlb0VsZW1lbnQge1xuICAgICAgICBsZXQgdmlkZW9QbGF5ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB2aWRlb1BsYXllci5wcmVsb2FkID0gJ2F1dG8nO1xuICAgICAgICB2aWRlb1BsYXllci5zcmMgPSBzb3VyY2U7XG4gICAgICAgIHJldHVybiB2aWRlb1BsYXllcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZUNhbnZhcyh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICBwcml2YXRlIGdvVG9GcmFtZSh2aWRlb1BsYXllcjogSFRNTFZpZGVvRWxlbWVudCwgdGltZTogbnVtYmVyKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICAgICAgdmlkZW9QbGF5ZXIuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50KHZpZGVvUGxheWVyLCB0aW1lID09PSAwID8gJ2xvYWRlZGRhdGEnIDogJ3NlZWtlZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyOiBIVE1MVmlkZW9FbGVtZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB0aW1lOiBudW1iZXIsIHdpZHRoOiBudW1iZXIgPSAxNjAsIGhlaWdodDogbnVtYmVyID0gOTApOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RXh0cmFjdGVkRnJhbWU+KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIGdvIHRvIHNwZWNpZmllZCBmcmFtZVxuICAgICAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHRoaXMuZ29Ub0ZyYW1lKHZpZGVvUGxheWVyLCB0aW1lKS5zdWJzY3JpYmUoKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaW1hZ2UgZnJvbSBjdXJyZW50IGZyYW1lXG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHZpZGVvUGxheWVyLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHsgaW1hZ2U6IGNhbnZhcy50b0RhdGFVUkwoKSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdGltZTogdGltZSB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEZyYW1lVGh1bWJuYWlsKHNvdXJjZTogc3RyaW5nLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgdGltZTogbnVtYmVyKTogT2JzZXJ2YWJsZTxFeHRyYWN0ZWRGcmFtZT4ge1xuXG4gICAgICAgIC8vIGNyZWF0ZSByZXF1aXJlZCBlbGVtZW50c1xuICAgICAgICBsZXQgdmlkZW9QbGF5ZXIgPSB0aGlzLmNyZWF0ZVZpZGVvUGxheWVyKHNvdXJjZSk7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBsZXQgZnJhbWVTdWJzY3JpcHRpb24gPSB0aGlzLmdldFRodW1ibmFpbCh2aWRlb1BsYXllciwgY2FudmFzLCB0aW1lLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBlbnN1cmUgd2UgcmVsZWFzZSBtZW1vcnkgYWZ0ZXIgd2UgYXJlIGZpbmlzaGVkXG4gICAgICAgIGZyYW1lU3Vic2NyaXB0aW9uLnN1YnNjcmliZShudWxsLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlb1BsYXllciA9IG51bGw7XG4gICAgICAgICAgICBjYW52YXMgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnJhbWVTdWJzY3JpcHRpb247XG4gICAgfVxuXG4gICAgZ2V0RnJhbWVUaHVtYm5haWxzKHNvdXJjZTogc3RyaW5nLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHNraXA6IG51bWJlciA9IDUpOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlcXVpcmVkIGVsZW1lbnRzXG4gICAgICAgIGxldCB2aWRlb1BsYXllciA9IHRoaXMuY3JlYXRlVmlkZW9QbGF5ZXIoc291cmNlKTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEV4dHJhY3RlZEZyYW1lPikgPT4ge1xuXG4gICAgICAgICAgICBmcm9tRXZlbnQodmlkZW9QbGF5ZXIsICdsb2FkZWRtZXRhZGF0YScpLnN1YnNjcmliZSgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGZyYW1lcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGxldCBmcmFtZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IHN0YXJ0OyBpZHggPCBlbmQ7IGlkeCArPSBza2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lcy5wdXNoKHRoaXMuZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyLCBjYW52YXMsIGlkeCwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbmNhdCguLi5mcmFtZXMpLnN1YnNjcmliZSgoZnJhbWU6IEV4dHJhY3RlZEZyYW1lKSA9PiBvYnNlcnZlci5uZXh0KGZyYW1lKSwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb1BsYXllciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHRyYWN0ZWRGcmFtZSB7XG4gICAgaW1hZ2U6IHN0cmluZztcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xuICAgIHRpbWU6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9mcmFtZS1leHRyYWN0aW9uLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIHByb3ZpZGVyczogW0ZyYW1lRXh0cmFjdGlvblNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBGcmFtZUV4dHJhY3Rpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbSc7XG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJ3J4anMvT2JzZXJ2ZXInO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBFeHRyYWN0ZWRGcmFtZSwgRnJhbWVFeHRyYWN0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ZyYW1lLWV4dHJhY3Rpb24vaW5kZXgnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJUeXBlIH0gZnJvbSAnLi9tZWRpYS1wbGF5ZXIuY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyU2VydmljZSB7XG5cbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICB0eXBlOiBNZWRpYVBsYXllclR5cGUgPSAndmlkZW8nO1xuICAgIGxvYWRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLypcbiAgICAgICAgQ3JlYXRlIG9ic2VydmFibGVzIGZvciBtZWRpYSBwbGF5ZXIgZXZlbnRzXG4gICAgKi9cbiAgICBwbGF5aW5nOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBpbml0RXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGFib3J0RXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIGNhblBsYXlFdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgY2FuUGxheVRocm91Z2hFdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgZHVyYXRpb25DaGFuZ2VFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIGVuZGVkRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIGVycm9yRXZlbnQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgICBsb2FkZWREYXRhRXZlbnQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgICBsb2FkZWRNZXRhZGF0YUV2ZW50OiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgbG9hZFN0YXJ0RXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHBhdXNlRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHBsYXlFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcGxheWluZ0V2ZW50OiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICByYXRlQ2hhbmdlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBzZWVrZWRFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHNlZWtpbmdFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHN0YWxsZWRFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgc3VzcGVuZEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICB0aW1lVXBkYXRlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICB2b2x1bWVDaGFuZ2VFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHdhaXRpbmdFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgbWVkaWFDbGlja0V2ZW50OiBTdWJqZWN0PE1vdXNlRXZlbnQ+ID0gbmV3IFN1YmplY3Q8TW91c2VFdmVudD4oKTtcbiAgICBmdWxsc2NyZWVuRXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHF1aWV0TW9kZUV2ZW50OiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBwcm9ncmVzc0V2ZW50OiBPYnNlcnZhYmxlPFRpbWVSYW5nZXM+ID0gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUaW1lUmFuZ2VzPikgPT4ge1xuXG4gICAgICAgIC8vIHJlcGVhdCB1bnRpbCB0aGUgd2hvbGUgdmlkZW8gaGFzIGZ1bGx5IGxvYWRlZFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBidWZmZXJlZCA9IHRoaXMuX21lZGlhUGxheWVyLmJ1ZmZlcmVkIGFzIFRpbWVSYW5nZXM7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGJ1ZmZlcmVkKTtcblxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA9PT0gMSAmJiBidWZmZXJlZC5zdGFydCgwKSA9PT0gMCAmJiBidWZmZXJlZC5lbmQoMCkgPT09IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTtcbiAgICB9KTtcblxuICAgIHByaXZhdGUgX21lZGlhUGxheWVyOiBIVE1MTWVkaWFFbGVtZW50O1xuICAgIHByaXZhdGUgX2hvc3RFbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9mdWxsc2NyZWVuOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfcXVpZXRNb2RlOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZnJhbWVFeHRyYWN0aW9uU2VydmljZTogRnJhbWVFeHRyYWN0aW9uU2VydmljZSkge31cblxuICAgIC8qXG4gICAgICAgIENyZWF0ZSBhbGwgdGhlIGdldHRlcnMgYW5kIHNldHRlcnMgdGhlIGNhbiBiZSB1c2VkIGJ5IG1lZGlhIHBsYXllciBleHRlbnNpb25zXG4gICAgKi9cbiAgICBnZXQgbWVkaWFQbGF5ZXIoKTogSFRNTE1lZGlhRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllcjtcbiAgICB9XG5cbiAgICBnZXQgcXVpZXRNb2RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVpZXRNb2RlO1xuICAgIH1cblxuICAgIHNldCBxdWlldE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcblxuICAgICAgICAvLyBxdWlldCBtb2RlIGNhbm5vdCBiZSBlbmFibGVkIG9uIGF1ZGlvIHBsYXllclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcXVpZXRNb2RlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucXVpZXRNb2RlRXZlbnQubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IG1lZGlhUGxheWVyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIub2Zmc2V0V2lkdGggOiAwO1xuICAgIH1cblxuICAgIGdldCBtZWRpYVBsYXllckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5vZmZzZXRIZWlnaHQgOiAwO1xuICAgIH1cblxuICAgIGdldCBhdWRpb1RyYWNrcygpOiBBdWRpb1RyYWNrTGlzdCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmF1ZGlvVHJhY2tzIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgYXV0b3BsYXkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmF1dG9wbGF5IDogZmFsc2U7XG4gICAgfVxuICAgIHNldCBhdXRvcGxheSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5hdXRvcGxheSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBidWZmZXJlZCgpOiBUaW1lUmFuZ2VzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuYnVmZmVyZWQgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBjcm9zc09yaWdpbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5jcm9zc09yaWdpbiA6IG51bGw7XG4gICAgfVxuICAgIHNldCBjcm9zc09yaWdpbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmNyb3NzT3JpZ2luID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRTcmMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuY3VycmVudFNyYyA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmN1cnJlbnRUaW1lIDogMDtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRUaW1lKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIuY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZGVmYXVsdE11dGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0TXV0ZWQgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRNdXRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0TXV0ZWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZGVmYXVsdFBsYXliYWNrUmF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0UGxheWJhY2tSYXRlIDogMTtcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRQbGF5YmFja1JhdGUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0UGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGR1cmF0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmR1cmF0aW9uIDogMDtcbiAgICB9XG5cbiAgICBnZXQgZW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmVuZGVkIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGxvb3AoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmxvb3AgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGxvb3AodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIubG9vcCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBtdXRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIubXV0ZWQgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IG11dGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLm11dGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IG5ldHdvcmtTdGF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIubmV0d29ya1N0YXRlO1xuICAgIH1cblxuICAgIGdldCBwYXVzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnBhdXNlZCA6IHRydWU7XG4gICAgfVxuXG4gICAgZ2V0IHBsYXliYWNrUmF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5wbGF5YmFja1JhdGUgOiAxO1xuICAgIH1cbiAgICBzZXQgcGxheWJhY2tSYXRlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHBsYXllZCgpOiBUaW1lUmFuZ2VzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIucGxheWVkIDogbmV3IFRpbWVSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBnZXQgcHJlbG9hZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5wcmVsb2FkIDogJ2F1dG8nO1xuICAgIH1cbiAgICBzZXQgcHJlbG9hZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnByZWxvYWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcmVhZHlTdGF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5yZWFkeVN0YXRlIDogMDtcbiAgICB9XG5cbiAgICBnZXQgc2Vla2FibGUoKTogVGltZVJhbmdlcyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnNlZWthYmxlIDogbmV3IFRpbWVSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBnZXQgc2Vla2luZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuc2Vla2luZyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBzcmMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuc3JjIDogJyc7XG4gICAgfVxuICAgIHNldCBzcmModmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5zcmMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdGV4dFRyYWNrcygpOiBUZXh0VHJhY2tMaXN0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIudGV4dFRyYWNrcyA6IG5ldyBUZXh0VHJhY2tMaXN0KCk7XG4gICAgfVxuXG4gICAgZ2V0IHZpZGVvVHJhY2tzKCk6IFZpZGVvVHJhY2tMaXN0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIudmlkZW9UcmFja3MgOiBuZXcgVmlkZW9UcmFja0xpc3QoKTtcbiAgICB9XG5cbiAgICBnZXQgdm9sdW1lKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnZvbHVtZSA6IDE7XG4gICAgfVxuICAgIHNldCB2b2x1bWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci52b2x1bWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZnVsbHNjcmVlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fZnVsbHNjcmVlbiA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgZnVsbHNjcmVlbih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9mdWxsc2NyZWVuID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbkV2ZW50Lm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIHNldE1lZGlhUGxheWVyKGhvc3RFbGVtZW50OiBIVE1MRWxlbWVudCwgbWVkaWFQbGF5ZXI6IEhUTUxNZWRpYUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIgPSBtZWRpYVBsYXllcjtcblxuICAgICAgICB0aGlzLmluaXRFdmVudC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBwbGF5aW5nIHN0YXRlXG4gICAgICovXG4gICAgdG9nZ2xlUGxheSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBwcmV2ZW50IGFueSBhY3Rpb24gaXMgbm90IGxvYWRlZFxuICAgICAgICBpZiAodGhpcy5sb2FkZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHBsYXlpbmcgdGhlIGF1ZGlvL3ZpZGVvXG4gICAgICovXG4gICAgcGxheSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucGxheSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgY3VycmVudGx5IHBsYXlpbmcgYXVkaW8vdmlkZW9cbiAgICAgKi9cbiAgICBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZS1sb2FkcyB0aGUgYXVkaW8vdmlkZW8gZWxlbWVudFxuICAgICAqL1xuICAgIGxvYWQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmxvYWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGJyb3dzZXIgY2FuIHBsYXkgdGhlIHNwZWNpZmllZCBhdWRpby92aWRlbyB0eXBlXG4gICAgICovXG4gICAgY2FuUGxheVR5cGUodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyLmNhblBsYXlUeXBlKHR5cGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgdGV4dCB0cmFjayB0byB0aGUgYXVkaW8vdmlkZW9cbiAgICAgKi9cbiAgICBhZGRUZXh0VHJhY2soa2luZDogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCBsYW5ndWFnZTogc3RyaW5nKTogVGV4dFRyYWNrIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZGlzcGxheSBtZWRpYSBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgKi9cbiAgICByZXF1ZXN0RnVsbHNjcmVlbigpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5faG9zdEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RFbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faG9zdEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RFbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+dGhpcy5faG9zdEVsZW1lbnQpLm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+dGhpcy5faG9zdEVsZW1lbnQpLm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4aXQgZnVsbCBzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIGV4aXRGdWxsc2NyZWVuKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+ZG9jdW1lbnQpLm1zRXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PmRvY3VtZW50KS5tc0V4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+ZG9jdW1lbnQpLm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PmRvY3VtZW50KS5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdWxsc2NyZWVuQ2hhbmdlKGV2ZW50OiBFdmVudCkge1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSAoPGFueT5kb2N1bWVudCkuZnVsbHNjcmVlbiB8fCBkb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW4gfHwgKDxhbnk+ZG9jdW1lbnQpLm1vekZ1bGxTY3JlZW4gfHwgKDxhbnk+ZG9jdW1lbnQpLm1zRnVsbHNjcmVlbkVsZW1lbnQgIT09IG51bGwgJiYgKDxhbnk+ZG9jdW1lbnQpLm1zRnVsbHNjcmVlbkVsZW1lbnQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuRXZlbnQubmV4dCh0aGlzLmZ1bGxzY3JlZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBGdWxsc2NyZWVuIFN0YXRlXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbHNjcmVlbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgZnJhbWVzIGZyb20gdGhlIHZpZGVvXG4gICAgICovXG4gICAgZ2V0RnJhbWVzKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBza2lwOiBudW1iZXIpOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lRXh0cmFjdGlvblNlcnZpY2UuZ2V0RnJhbWVUaHVtYm5haWxzKHRoaXMuc291cmNlLCB3aWR0aCwgaGVpZ2h0LCAwLCB0aGlzLmR1cmF0aW9uLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbShbXSk7XG4gICAgfVxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQXVkaW9NZXRhZGF0YSwgQXVkaW9TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYXVkaW8vaW5kZXgnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9tZWRpYS1wbGF5ZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbWVkaWEtcGxheWVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ2aWRlby1wbGF5ZXItY29udGFpbmVyXCIgKm5nSWY9XCJ0eXBlID09PSAndmlkZW8nXCI+XG5cbiAgICA8dmlkZW8gY2xhc3M9XCJ2aWRlby1wbGF5ZXJcIlxuICAgICAgICAjcGxheWVyXG4gICAgICAgIFtzcmNdPVwic291cmNlXCJcbiAgICAgICAgKGFib3J0KT1cIm1lZGlhUGxheWVyU2VydmljZS5hYm9ydEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChjYW5wbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5jYW5QbGF5RXZlbnQubmV4dCh0cnVlKVwiXG4gICAgICAgIChjYW5wbGF5dGhyb3VnaCk9XCJtZWRpYVBsYXllclNlcnZpY2UuY2FuUGxheVRocm91Z2hFdmVudC5uZXh0KHRydWUpXCJcbiAgICAgICAgKGR1cmF0aW9uY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbkNoYW5nZUV2ZW50Lm5leHQocGxheWVyLmR1cmF0aW9uKVwiXG4gICAgICAgIChlbmRlZCk9XCJtZWRpYVBsYXllclNlcnZpY2UuZW5kZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoZXJyb3IpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmVycm9yRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRlZGRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZERhdGFFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZGVkbWV0YWRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZE1ldGFkYXRhRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRzdGFydCk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZFN0YXJ0RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBhdXNlKT1cIm1lZGlhUGxheWVyU2VydmljZS5wYXVzZUV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChwbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5wbGF5RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBsYXlpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmdFdmVudC5uZXh0KCFwbGF5ZXIucGF1c2VkKVwiXG4gICAgICAgIChyYXRlY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5yYXRlQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIucGxheWJhY2tSYXRlKVwiXG4gICAgICAgIChzZWVrZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnNlZWtlZEV2ZW50Lm5leHQocGxheWVyLmN1cnJlbnRUaW1lKVwiXG4gICAgICAgIChzZWVraW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS5zZWVraW5nRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHN0YWxsZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnN0YWxsZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoc3VzcGVuZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc3VzcGVuZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgICh0aW1ldXBkYXRlKT1cIm1lZGlhUGxheWVyU2VydmljZS50aW1lVXBkYXRlRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHZvbHVtZWNoYW5nZSk9XCJtZWRpYVBsYXllclNlcnZpY2Uudm9sdW1lQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIudm9sdW1lKVwiXG4gICAgICAgICh3YWl0aW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS53YWl0aW5nRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKGNsaWNrKT1cIm1lZGlhUGxheWVyU2VydmljZS5tZWRpYUNsaWNrRXZlbnQubmV4dCgkZXZlbnQpXCI+XG4gICAgPC92aWRlbz5cblxuICAgIDxkaXYgY2xhc3M9XCJ2aWRlby1vdmVybGF5XCIgW2NsYXNzLnBsYXlpbmddPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmcgfCBhc3luY1wiPlxuICAgICAgICA8c3ZnIGNsYXNzPVwicGxheS1ncmFwaGljXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDY0IDY0XCI+XG4gICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwicGxheS1jaXJjbGVcIiBjeD1cIjMyLjJcIiBjeT1cIjMxLjhcIiByPVwiMzEuOFwiIC8+XG4gICAgICAgICAgICA8cG9seWdvbiBjbGFzcz1cInBsYXktdHJpYW5nbGVcIiBwb2ludHM9XCIyMywxNC4xIDIzLDUwLjggNDguMywzMi41XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuXG5cbjxkaXYgY2xhc3M9XCJhdWRpby1wbGF5ZXJcIiAqbmdJZj1cInR5cGUgPT09ICdhdWRpbydcIj5cblxuICAgIDxzdmcgd2lkdGg9XCIyNHB4XCIgaGVpZ2h0PVwiMjRweFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgPGcgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtOTguMDAwMDAwLCAtNDU4LjAwMDAwMClcIj5cbiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoOTguMDAwMDAwLCA0NTguMDAwMDAwKVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQuNSwwLjUgTDE4LjA0MzUzMDgsMC41IEwyMy41LDYuMjIyNTE1MDIgTDIzLjUsMjMuNSBMNC41LDIzLjUgTDQuNSwwLjUgWlwiIGZpbGw9XCIjQ0NFQUUyXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQuNSw4IEw0LjUsMC41IEwxOCwwLjUgTDIzLjUsNiBMMjMuNSwyMy41IEwxOCwyMy41XCIgc3Ryb2tlPVwiIzYwNzk4RFwiIGZpbGw9XCIjQ0NFQUUyXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQsMTMuNSBMMC41LDEzLjUgTDAuNSwxOC41IEw0LDE4LjUgTDkuNSwyMi41IEw5LjUsOS41IEw0LDEzLjUgWlwiIHN0cm9rZT1cIiM2MDc5OERcIiBmaWxsPVwiIzg1RDJCRVwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMS41LDEyLjUxMzc5MzkgQzEzLjc1NzYyMjUsMTIuNTEzNzkzOSAxNC41LDE0LjM3MDkyMzYgMTQuNSwxNiBDMTQuNSwxNy42ODQ5MjM2IDEzLjcwODkxNTIsMTkuNTQyMDUzMiAxMS41LDE5LjU0MjA1MzJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiIzYwNzk4RFwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMS41LDkgQzE1LjgwMzc2NDMsOS4wNDE2ODcwMSAxOC41LDExLjY2MDQ4MDUgMTguNSwxNiBDMTguNSwyMC4zMzk1MTk1IDE1Ljg4MDQzMDIsMjMuMDA3OTk1NiAxMS41LDIzXCIgc3Ryb2tlPVwiIzYwNzk4RFwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xNy41MjE5MTE2LDAuNzYxNDEzNTc0IEwxNy41MjE5MTE2LDYgTDIzLDZcIiBzdHJva2U9XCIjNjA3OThEXCIgZmlsbD1cIiM4NUQyQkVcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICA8L2c+XG4gICAgPC9zdmc+XG5cbiAgICA8cCBjbGFzcz1cImF1ZGlvLWZpbGUtbmFtZVwiPnt7IChhdWRpb01ldGFkYXRhIHwgYXN5bmMpPy5maWxlbmFtZSB9fTwvcD5cbiAgICA8cCBjbGFzcz1cImF1ZGlvLWZpbGUtZm9ybWF0XCI+e3sgKGF1ZGlvTWV0YWRhdGEgfCBhc3luYyk/LmRlc2NyaXB0aW9uIH19PC9wPlxuICAgIDxwIGNsYXNzPVwiYXVkaW8tZmlsZS1zaXplXCI+e3sgKGF1ZGlvTWV0YWRhdGEgfCBhc3luYyk/LnNpemUgfCBmaWxlU2l6ZSB9fTwvcD5cblxuICAgIDxhdWRpbyAjcGxheWVyXG4gICAgICAgIFtzcmNdPVwic291cmNlXCJcbiAgICAgICAgKGFib3J0KT1cIm1lZGlhUGxheWVyU2VydmljZS5hYm9ydEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChjYW5wbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5jYW5QbGF5RXZlbnQubmV4dCh0cnVlKVwiXG4gICAgICAgIChjYW5wbGF5dGhyb3VnaCk9XCJtZWRpYVBsYXllclNlcnZpY2UuY2FuUGxheVRocm91Z2hFdmVudC5uZXh0KHRydWUpXCJcbiAgICAgICAgKGR1cmF0aW9uY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbkNoYW5nZUV2ZW50Lm5leHQocGxheWVyLmR1cmF0aW9uKVwiXG4gICAgICAgIChlbmRlZCk9XCJtZWRpYVBsYXllclNlcnZpY2UuZW5kZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoZXJyb3IpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmVycm9yRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRlZGRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZERhdGFFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZGVkbWV0YWRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZE1ldGFkYXRhRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRzdGFydCk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZFN0YXJ0RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBhdXNlKT1cIm1lZGlhUGxheWVyU2VydmljZS5wYXVzZUV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChwbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5wbGF5RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBsYXlpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmdFdmVudC5uZXh0KCFwbGF5ZXIucGF1c2VkKVwiXG4gICAgICAgIChyYXRlY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5yYXRlQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIucGxheWJhY2tSYXRlKVwiXG4gICAgICAgIChzZWVrZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnNlZWtlZEV2ZW50Lm5leHQocGxheWVyLmN1cnJlbnRUaW1lKVwiXG4gICAgICAgIChzZWVraW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS5zZWVraW5nRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHN0YWxsZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnN0YWxsZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoc3VzcGVuZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc3VzcGVuZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgICh0aW1ldXBkYXRlKT1cIm1lZGlhUGxheWVyU2VydmljZS50aW1lVXBkYXRlRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHZvbHVtZWNoYW5nZSk9XCJtZWRpYVBsYXllclNlcnZpY2Uudm9sdW1lQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIudm9sdW1lKVwiXG4gICAgICAgICh3YWl0aW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS53YWl0aW5nRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKGNsaWNrKT1cIm1lZGlhUGxheWVyU2VydmljZS5tZWRpYUNsaWNrRXZlbnQubmV4dCgkZXZlbnQpXCI+XG4gICAgPC9hdWRpbz5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiY29udHJvbC1iYXJcIj5cbiAgICA8dXgtbWVkaWEtcGxheWVyLXRpbWVsaW5lPjwvdXgtbWVkaWEtcGxheWVyLXRpbWVsaW5lPlxuICAgIDx1eC1tZWRpYS1wbGF5ZXItY29udHJvbHM+PC91eC1tZWRpYS1wbGF5ZXItY29udHJvbHM+XG48L2Rpdj5gLFxuICAgIHByb3ZpZGVyczogW01lZGlhUGxheWVyU2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAndGFiaW5kZXgnOiAnMCcsXG4gICAgICAgICcoa2V5ZG93bi5TcGFjZSknOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLnRvZ2dsZVBsYXkoKScsXG4gICAgICAgICdbY2xhc3Muc3RhbmRhcmRdJzogJyFtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbicsXG4gICAgICAgICdbY2xhc3MuZnVsbHNjcmVlbl0nOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW4nLFxuICAgICAgICAnW2NsYXNzLnF1aWV0XSc6ICdxdWlldE1vZGUgJiYgdHlwZSA9PT0gXCJ2aWRlb1wiIHx8IG1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuJyxcbiAgICAgICAgJ1tjbGFzcy5ob3Zlcl0nOiAnaG92ZXJpbmcnLFxuICAgICAgICAnW2NsYXNzLnZpZGVvXSc6ICd0eXBlID09PSBcInZpZGVvXCInLFxuICAgICAgICAnW2NsYXNzLmF1ZGlvXSc6ICd0eXBlID09PSBcImF1ZGlvXCInLFxuICAgICAgICAnKG1vdXNlZW50ZXIpJzogJ2hvdmVyaW5nID0gdHJ1ZScsXG4gICAgICAgICcobW91c2VsZWF2ZSknOiAnaG92ZXJpbmcgPSBmYWxzZScsXG4gICAgICAgICcoZG9jdW1lbnQ6d2Via2l0ZnVsbHNjcmVlbmNoYW5nZSknOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5DaGFuZ2UoJGV2ZW50KScsXG4gICAgICAgICcoZG9jdW1lbnQ6bW96ZnVsbHNjcmVlbmNoYW5nZSknOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5DaGFuZ2UoJGV2ZW50KScsXG4gICAgICAgICcoZG9jdW1lbnQ6TVNGdWxsc2NyZWVuQ2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgkZXZlbnQpJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQFZpZXdDaGlsZCgncGxheWVyJykgcHJpdmF0ZSBfcGxheWVyUmVmOiBFbGVtZW50UmVmO1xuXG4gICAgaG92ZXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhdWRpb01ldGFkYXRhOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+O1xuXG4gICAgZ2V0IHNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2Uuc291cmNlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHNvdXJjZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnNvdXJjZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCk6IE1lZGlhUGxheWVyVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS50eXBlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHR5cGUodmFsdWU6IE1lZGlhUGxheWVyVHlwZSkge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS50eXBlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHF1aWV0TW9kZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBxdWlldE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBtZWRpYVBsYXllclNlcnZpY2U6IE1lZGlhUGxheWVyU2VydmljZSwgcHJpdmF0ZSBfYXVkaW9TZXJ2aWNlOiBBdWRpb1NlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICAvLyBzaG93IGNvbnRyb2xzIHdoZW4gaG92ZXJpbmcgYW5kIGluIHF1aWV0IG1vZGVcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlbW92ZScpLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKGV2ZW50KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVib3VuY2VUaW1lKDIwMDApLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5ob3ZlcmluZyA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnNldE1lZGlhUGxheWVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fcGxheWVyUmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMuYXVkaW9NZXRhZGF0YSA9IHRoaXMuX2F1ZGlvU2VydmljZS5nZXRBdWRpb0ZpbGVNZXRhZGF0YSh0aGlzLl9wbGF5ZXJSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmdFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheWluZy5uZXh0KHRydWUpKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheWluZy5uZXh0KGZhbHNlKSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLm1lZGlhQ2xpY2tFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudG9nZ2xlUGxheSgpKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UubG9hZGVkTWV0YWRhdGFFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UubG9hZGVkID0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgTWVkaWFQbGF5ZXJUeXBlID0gJ3ZpZGVvJyB8ICdhdWRpbyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVkaWFQbGF5ZXJCdWZmZXIge1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclNlcnZpY2UgfSBmcm9tICcuLi9tZWRpYS1wbGF5ZXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW21lZGlhUGxheWVyQmFzZUV4dGVuc2lvbl0nXG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIG1lZGlhUGxheWVyU2VydmljZTogTWVkaWFQbGF5ZXJTZXJ2aWNlKSB7IH1cbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXItdGltZWxpbmUnLFxuICAgIHRlbXBsYXRlOiBgPHAgY2xhc3M9XCJjdXJyZW50LXRpbWVcIj57eyBjdXJyZW50IHwgZHVyYXRpb24gfX08L3A+XG5cbjxkaXYgI3RpbWVsaW5lIGNsYXNzPVwidGltZWxpbmUtYmFyXCIgKG1vdXNlZW50ZXIpPVwic2NydWIudmlzaWJsZSA9IHRydWU7IHBvcC5zaG93KClcIiAobW91c2VsZWF2ZSk9XCJzY3J1Yi52aXNpYmxlID0gZmFsc2U7IHBvcC5oaWRlKClcIlxuICAgIChtb3VzZW1vdmUpPVwidXBkYXRlU2NydWIoJGV2ZW50KVwiIChtb3VzZXVwKT1cInVwZGF0ZVNjcnViKCRldmVudClcIiAobW91c2Vkb3duKT1cIm1vdXNlRG93biA9IHRydWU7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiYnVmZmVyZWQtYmFyXCIgKm5nRm9yPVwibGV0IGJ1ZmZlciBvZiBidWZmZXJlZFwiIFtzdHlsZS5sZWZ0LiVdPVwiYnVmZmVyLnN0YXJ0XCIgW3N0eWxlLndpZHRoLiVdPVwiYnVmZmVyLmVuZCAtIGJ1ZmZlci5zdGFydFwiPjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1lZGlhLXByb2dyZXNzLWJhclwiIFtzdHlsZS53aWR0aC4lXT1cInBvc2l0aW9uXCI+XG4gICAgICAgIDxkaXYgI3Byb2dyZXNzVGh1bWIgY2xhc3M9XCJtZWRpYS1wcm9ncmVzcy1iYXItdGh1bWJcIiAobW91c2VlbnRlcik9XCJzY3J1Yi52aXNpYmxlID0gZmFsc2U7IHBvcC5oaWRlKCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgICAobW91c2VsZWF2ZSk9XCJzY3J1Yi52aXNpYmxlID0gdHJ1ZTsgcG9wLnNob3coKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic2NydWItaGFuZGxlXCJcbiAgICAgICAgIFtjbGFzcy5zY3J1Yi1oYW5kbGUtaGlkZGVuXT1cIiFzY3J1Yi52aXNpYmxlXCJcbiAgICAgICAgIFtzdHlsZS5sZWZ0LnB4XT1cInNjcnViLnBvc2l0aW9uXCJcbiAgICAgICAgIFt1eFRvb2x0aXBdPVwicG9wVGVtcGxhdGVcIlxuICAgICAgICAgcGxhY2VtZW50PVwidG9wXCJcbiAgICAgICAgIFtzaG93VHJpZ2dlcnNdPVwiW11cIlxuICAgICAgICAgW2hpZGVUcmlnZ2Vyc109XCJbXVwiXG4gICAgICAgICAjcG9wPVwidXgtdG9vbHRpcFwiXG4gICAgICAgICBbdG9vbHRpcERlbGF5XT1cIjEwMFwiXG4gICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cImR1cmF0aW9uID09PSAwXCI+PC9kaXY+XG48L2Rpdj5cblxuPHAgY2xhc3M9XCJkdXJhdGlvbi10aW1lXCI+e3sgZHVyYXRpb24gfCBkdXJhdGlvbiB9fTwvcD5cblxuPG5nLXRlbXBsYXRlICNwb3BUZW1wbGF0ZT5cbiAgICA8c3Bhbj57eyBzY3J1Yi50aW1lIHwgZHVyYXRpb24gfX08L3NwYW4+XG48L25nLXRlbXBsYXRlPmAsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGRvY3VtZW50Om1vdXNldXApJzogJ21vdXNlRG93biA9IGZhbHNlJyxcbiAgICAgICAgJ1tjbGFzcy5xdWlldF0nOiAncXVpZXRNb2RlIHx8IGZ1bGxzY3JlZW4nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllclRpbWVsaW5lRXh0ZW5zaW9uQ29tcG9uZW50IGV4dGVuZHMgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQFZpZXdDaGlsZCgncHJvZ3Jlc3NUaHVtYicpIHRodW1iOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3RpbWVsaW5lJykgdGltZWxpbmVSZWY6IEVsZW1lbnRSZWY7XG5cbiAgICBjdXJyZW50OiBudW1iZXIgPSAwO1xuICAgIHBvc2l0aW9uOiBudW1iZXIgPSAwO1xuICAgIGR1cmF0aW9uOiBudW1iZXIgPSAwO1xuICAgIGJ1ZmZlcmVkOiBNZWRpYVBsYXllckJ1ZmZlcmVkW10gPSBbXTtcbiAgICBtb3VzZURvd246IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBxdWlldE1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBmdWxsc2NyZWVuOiBib29sZWFuID0gZmFsc2U7XG4gICAgc2NydWIgPSB7IHZpc2libGU6IGZhbHNlLCBwb3NpdGlvbjogMCwgdGltZTogMCB9O1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb25DaGFuZ2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZHVyYXRpb24gPT4gdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHF1aWV0TW9kZSA9PiB0aGlzLnF1aWV0TW9kZSA9IHF1aWV0TW9kZSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5FdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZnVsbHNjcmVlbiA9PiB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuO1xuICAgICAgICAgICAgdGhpcy5zY3J1Yi5wb3NpdGlvbiA9IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRpbWVVcGRhdGVFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoY3VycmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICh0aGlzLmN1cnJlbnQgLyB0aGlzLmR1cmF0aW9uKSAqIDEwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucHJvZ3Jlc3NFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKGJ1ZmZlcmVkOiBUaW1lUmFuZ2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGJ1ZmZlcmVkLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkLnB1c2goeyBzdGFydDogKGJ1ZmZlcmVkLnN0YXJ0KGlkeCkgLyB0aGlzLmR1cmF0aW9uKSAqIDEwMCwgZW5kOiAoYnVmZmVyZWQuZW5kKGlkeCkgLyB0aGlzLmR1cmF0aW9uKSAqIDEwMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtb3VzZWRvd24kID0gZnJvbUV2ZW50KHRoaXMudGh1bWIubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicpO1xuICAgICAgICBjb25zdCBtb3VzZW1vdmUkID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGNvbnN0IG1vdXNldXAkID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcpO1xuXG4gICAgICAgIG1vdXNlZG93biQucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiBtb3VzZW1vdmUkLnBpcGUodGFrZVVudGlsKG1vdXNldXAkKSkpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zY3J1Yi52aXNpYmxlID0gZmFsc2UpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTY3J1YihldmVudD86IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21lZGlhLXByb2dyZXNzLWJhci10aHVtYicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmVSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGltZWxpbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdGhpcy5zY3J1Yi5wb3NpdGlvbiA9IGV2ZW50Lm9mZnNldFg7XG4gICAgICAgIHRoaXMuc2NydWIudGltZSA9IChldmVudC5vZmZzZXRYIC8gYm91bmRzLndpZHRoKSAqIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5zY3J1Yi50aW1lO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lZGlhUGxheWVyQnVmZmVyZWQge1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgT25EZXN0cm95LCBPbkluaXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS90aW1lcic7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGZpbHRlciwgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbWVkaWEtcGxheWVyLWNvbnRyb2xzJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ2b2x1bWUtY29udGFpbmVyXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidm9sdW1lLXNsaWRlci1jb250YWluZXJcIiAjdm9sdW1lQ29udGFpbmVyIFtjbGFzcy5hY3RpdmVdPVwidm9sdW1lQWN0aXZlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ2b2x1bWUtc2xpZGVyLWljb25cIiAjdm9sdW1lSWNvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb25cIiBbY2xhc3MuaHBlLXZvbHVtZS1tdXRlXT1cInZvbHVtZSA9PT0gMFwiIFtjbGFzcy5ocGUtdm9sdW1lLWxvd109XCJ2b2x1bWUgPiAwICYmIHZvbHVtZSA8PSA3MFwiIFtjbGFzcy5ocGUtdm9sdW1lXT1cInZvbHVtZSA+IDcwXCIgW3V4VG9vbHRpcF09XCJtdXRlVG9vbHRpcFwiIChjbGljayk9XCJ0b2dnbGVNdXRlKClcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cInZvbHVtZS1zbGlkZXItbm9kZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZvbHVtZS1zbGlkZXJcIiAjdm9sdW1lU2xpZGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2b2x1bWUtdHJhY2stbG93ZXJcIiBbc3R5bGUud2lkdGguJV09XCJ2b2x1bWVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidm9sdW1lLXNsaWRlci10aHVtYlwiIChtb3VzZWRvd24pPVwiZHJhZ1N0YXJ0KCRldmVudClcIiBbc3R5bGUubGVmdC4lXT1cInZvbHVtZVwiIHRhYmluZGV4PVwiMFwiIChrZXlkb3duLkFycm93UmlnaHQpPVwidm9sdW1lID0gdm9sdW1lICsgMTBcIiAoa2V5ZG93bi5BcnJvd0xlZnQpPVwidm9sdW1lID0gdm9sdW1lIC0gMTBcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG5cbjxzdmcgdmlld0JveD1cIjAgMCA1MS41IDY0XCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE3XCIgY2xhc3M9XCJjb250cm9sLWJ1dHRvblwiIChjbGljayk9XCJnb1RvU3RhcnQoKVwiPlxuICAgIDxyZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjcuNVwiIGhlaWdodD1cIjY0XCIgLz5cbiAgICA8cG9seWdvbiBwb2ludHM9XCI1MS41LDY0IDUxLjUsMCA3LjQsMzIgXCIgLz5cbjwvc3ZnPlxuXG48c3ZnIHZpZXdCb3g9XCIwIDAgNDUgNjRcIiB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjlcIiBjbGFzcz1cImNvbnRyb2wtYnV0dG9uXCIgKm5nSWY9XCIhcGxheWluZ1wiIChjbGljayk9XCJ0b2dnbGVQbGF5KClcIj5cbiAgICA8cG9seWdvbiBwb2ludHM9XCIwLjQsMCAwLjQsNjQgNDQuNiwzMlwiIC8+XG48L3N2Zz5cblxuPHN2ZyB2aWV3Qm94PVwiMCAwIDQzIDU2LjlcIiBjbGFzcz1cImNvbnRyb2wtYnV0dG9uXCIgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjI5XCIgKm5nSWY9XCJwbGF5aW5nXCIgKGNsaWNrKT1cInRvZ2dsZVBsYXkoKVwiPlxuICAgIDxyZWN0IHk9XCIwLjFcIiB3aWR0aD1cIjE1LjdcIiBoZWlnaHQ9XCI1Ni45XCIgLz5cbiAgICA8cmVjdCB4PVwiMjcuM1wiIHk9XCIwLjFcIiB3aWR0aD1cIjE1LjdcIiBoZWlnaHQ9XCI1Ni45XCIgLz5cbjwvc3ZnPlxuXG48c3ZnIHZpZXdCb3g9XCIwIDAgNTEuNSA2NFwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxN1wiIGNsYXNzPVwiY29udHJvbC1idXR0b25cIiAoY2xpY2spPVwiZ29Ub0VuZCgpXCI+XG4gICAgPHJlY3QgeD1cIjQ0LjFcIiB5PVwiMFwiIHdpZHRoPVwiNy41XCIgaGVpZ2h0PVwiNjRcIiAvPlxuICAgIDxwb2x5Z29uIHBvaW50cz1cIjAsNjQgMCwwIDQ0LjEsMzIgXCIgLz5cbjwvc3ZnPlxuXG48ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG5cbjxzcGFuIGNsYXNzPVwiaHBlLWljb25cIiAqbmdJZj1cIm1lZGlhUGxheWVyU2VydmljZS50eXBlICE9PSAnYXVkaW8nXCIgW2NsYXNzLmhwZS1leHBhbmRdPVwiIW1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuXCIgW2NsYXNzLmhwZS1jb250cmFjdF09XCJtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlblwiXG4gICAgKGNsaWNrKT1cInNldEZ1bGxzY3JlZW4oKVwiPjwvc3Bhbj5cblxuPG5nLXRlbXBsYXRlICNtdXRlVG9vbHRpcD57eyB2b2x1bWUgPT09IDAgPyAnVW5tdXRlJyA6ICdNdXRlJyB9fTwvbmctdGVtcGxhdGU+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MucXVpZXRdJzogJ3F1aWV0TW9kZSB8fCBmdWxsc2NyZWVuJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJDb250cm9sc0V4dGVuc2lvbkNvbXBvbmVudCBleHRlbmRzIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIHBsYXlpbmc6IGJvb2xlYW47XG4gICAgcXVpZXRNb2RlOiBib29sZWFuO1xuICAgIGZ1bGxzY3JlZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICB2b2x1bWVBY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICB2b2x1bWVEcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQFZpZXdDaGlsZCgndm9sdW1lSWNvbicpIHZvbHVtZUljb246IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndm9sdW1lU2xpZGVyJykgdm9sdW1lU2xpZGVyOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3ZvbHVtZUNvbnRhaW5lcicpIHZvbHVtZUNvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIHByaXZhdGUgX3ZvbHVtZTogbnVtYmVyID0gNTA7XG4gICAgcHJpdmF0ZSBfcHJldmlvdXNWb2x1bWUgPSA1MDtcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgZ2V0IHZvbHVtZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xuICAgIH1cblxuICAgIHNldCB2b2x1bWUodmFsdWU6IG51bWJlcikge1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB0aGlzLl92b2x1bWUgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVm9sdW1lID0gdGhpcy5fdm9sdW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdm9sdW1lID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxMDApO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS52b2x1bWUgPSB0aGlzLl92b2x1bWUgLyAxMDA7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoXyA9PiB0aGlzLnBsYXlpbmcgPSB0cnVlKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoXyA9PiB0aGlzLnBsYXlpbmcgPSBmYWxzZSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShxdWlldE1vZGUgPT4gdGhpcy5xdWlldE1vZGUgPSBxdWlldE1vZGUpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS52b2x1bWVDaGFuZ2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodm9sdW1lID0+IHRoaXMudm9sdW1lID0gdm9sdW1lICogMTAwKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuaW5pdEV2ZW50LnBpcGUoZGVib3VuY2VUaW1lKDEpLCBmaWx0ZXIoaW5pdCA9PiBpbml0ID09PSB0cnVlKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnZvbHVtZSA9IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnZvbHVtZSAqIDEwMCk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5FdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZnVsbHNjcmVlbiA9PiB0aGlzLmZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuKTtcblxuICAgICAgICBjb25zdCBtb3VzZWVudGVyJCA9IGZyb21FdmVudCh0aGlzLnZvbHVtZUljb24ubmF0aXZlRWxlbWVudCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgY29uc3QgbW91c2VlbnRlckNvbnRhaW5lciQgPSBmcm9tRXZlbnQodGhpcy52b2x1bWVDb250YWluZXIubmF0aXZlRWxlbWVudCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgY29uc3QgbW91c2VsZWF2ZUNvbnRhaW5lciQgPSBmcm9tRXZlbnQodGhpcy52b2x1bWVDb250YWluZXIubmF0aXZlRWxlbWVudCwgJ21vdXNlbGVhdmUnKTtcblxuICAgICAgICBtb3VzZWVudGVyJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy52b2x1bWVBY3RpdmUgPSB0cnVlKTtcbiAgICAgICAgbW91c2VsZWF2ZUNvbnRhaW5lciQucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0aW1lcigxNTAwKS5waXBlKHRha2VVbnRpbChtb3VzZWVudGVyQ29udGFpbmVyJCkpKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMudm9sdW1lQWN0aXZlID0gZmFsc2UpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVNdXRlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy52b2x1bWUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fcHJldmlvdXNWb2x1bWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZvbHVtZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGVQbGF5KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wYXVzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0RnVsbHNjcmVlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgIH1cblxuICAgIGdvVG9TdGFydCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIGdvVG9FbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb247XG4gICAgfVxuXG4gICAgZHJhZ1N0YXJ0KGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMudm9sdW1lRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IHRodW1iID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICB0aHVtYi5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50Om1vdXNlbW92ZScsIFsnJGV2ZW50J10pXG4gICAgZHJhZ01vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnZvbHVtZURyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IHNsaWRlciA9IHRoaXMudm9sdW1lU2xpZGVyLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHNsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBNYXRoLm1heCgwLCBldmVudC5wYWdlWCAtIGJvdW5kcy5sZWZ0KSk7XG5cbiAgICAgICAgLy8gY29udmVydCB0byBhIHBlcmNlbnRhZ2VcbiAgICAgICAgdGhpcy52b2x1bWUgPSAoeCAvIGJvdW5kcy53aWR0aCkgKiAxMDA7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2V1cCcpXG4gICAgZHJhZ0VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52b2x1bWVEcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cblxufSIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICdkdXJhdGlvbidcbn0pXG5leHBvcnQgY2xhc3MgRHVyYXRpb25QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgXG4gICAgdHJhbnNmb3JtKHNlY29uZHM6IG51bWJlcik6IGFueSB7XG5cbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgbGV0IGRheXMgPSBNYXRoLmZsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIGhvdXJzID0gaG91cnMgLSAoZGF5cyAqIDI0KTtcbiAgICAgICAgbWludXRlcyA9IG1pbnV0ZXMgLSAoZGF5cyAqIDI0ICogNjApIC0gKGhvdXJzICogNjApO1xuICAgICAgICBzZWNvbmRzID0gTWF0aC5mbG9vcihzZWNvbmRzIC0gKGRheXMgKiAyNCAqIDYwICogNjApIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG5cbiAgICAgICAgaWYgKGhvdXJzID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMucGFkKGhvdXJzKX06JHt0aGlzLnBhZChtaW51dGVzKX06JHt0aGlzLnBhZChzZWNvbmRzKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMucGFkKG1pbnV0ZXMpfToke3RoaXMucGFkKHNlY29uZHMpfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYWQodmFsdWU6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gYDAke3ZhbHVlfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHVyYXRpb25QaXBlIH0gZnJvbSAnLi9kdXJhdGlvbi5waXBlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRHVyYXRpb25QaXBlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtEdXJhdGlvblBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIER1cmF0aW9uUGlwZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICdmaWxlU2l6ZSdcbn0pXG5leHBvcnQgY2xhc3MgRmlsZVNpemVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICB0cmFuc2Zvcm0odmFsdWU6IG51bWJlcik6IGFueSB7XG5cbiAgICAgICAgLy8gYWxsb3cgZm9yIGFzeW5jIHZhbHVlc1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQiddO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgd2hpY2ggdW5pdCBicmFja2V0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIGEgcGFydCBvZlxuICAgICAgICBsZXQgaWR4ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLmxvZygxMDI0KSk7XG4gICAgICAgIGxldCBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAyNCwgaWR4KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBgJHtmb3JtYXR0ZWRWYWx1ZS50b0ZpeGVkKDIpfSAke3VuaXRzW2lkeF19YDtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRmlsZVNpemVQaXBlIH0gZnJvbSAnLi9maWxlLXNpemUucGlwZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZpbGVTaXplUGlwZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRmlsZVNpemVQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBGaWxlU2l6ZVBpcGVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgTWVkaWFQbGF5ZXJDb21wb25lbnQgfSBmcm9tICcuL21lZGlhLXBsYXllci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJUaW1lbGluZUV4dGVuc2lvbkNvbXBvbmVudCB9IGZyb20gJy4vZXh0ZW5zaW9ucy90aW1lbGluZS90aW1lbGluZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIH0gZnJvbSAnLi9leHRlbnNpb25zL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZWRpYVBsYXllckNvbnRyb2xzRXh0ZW5zaW9uQ29tcG9uZW50IH0gZnJvbSAnLi9leHRlbnNpb25zL2NvbnRyb2xzL2NvbnRyb2xzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGcmFtZUV4dHJhY3Rpb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24ubW9kdWxlJztcbmltcG9ydCB7IEF1ZGlvU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2F1ZGlvL2luZGV4JztcbmltcG9ydCB7IER1cmF0aW9uUGlwZU1vZHVsZSB9IGZyb20gJy4uLy4uL3BpcGVzL2R1cmF0aW9uL2luZGV4JztcbmltcG9ydCB7IEZpbGVTaXplUGlwZU1vZHVsZSB9IGZyb20gJy4uLy4uL3BpcGVzL2ZpbGUtc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclNlcnZpY2UgfSBmcm9tICcuL21lZGlhLXBsYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIE1lZGlhUGxheWVyQ29tcG9uZW50LFxuICAgIE1lZGlhUGxheWVyVGltZWxpbmVFeHRlbnNpb25Db21wb25lbnQsXG4gICAgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlLFxuICAgIE1lZGlhUGxheWVyQ29udHJvbHNFeHRlbnNpb25Db21wb25lbnRcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZyYW1lRXh0cmFjdGlvbk1vZHVsZSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZSxcbiAgICAgICAgQXVkaW9TZXJ2aWNlTW9kdWxlLFxuICAgICAgICBEdXJhdGlvblBpcGVNb2R1bGUsXG4gICAgICAgIEZpbGVTaXplUGlwZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TLFxuICAgIHByb3ZpZGVyczogW01lZGlhUGxheWVyU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbmF2aWdhdGlvbicsXG4gICAgdGVtcGxhdGU6IGA8bmF2IGNsYXNzPVwidHJlZVwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XG4gICAgPG9sIGNsYXNzPVwibmF2XCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L29sPlxuPC9uYXY+XG5gXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Db21wb25lbnQge1xuXG59IiwiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPcHRpb25hbCwgUXVlcnlMaXN0LCBSZW5kZXJlcjIsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSwgTmF2aWdhdGlvbkVuZCwgUm91dGVyLCBVcmxUcmVlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdbdXgtbmF2aWdhdGlvbi1pdGVtXScsXG4gICAgdGVtcGxhdGU6IGA8YSAqbmdJZj1cImxpbmtcIiBbY2xhc3MuaGFzLWFycm93XT1cImNoaWxkcmVuLmxlbmd0aCA+IDBcIiBbY2xhc3Mubm8tYXJyb3ddPVwiaW5kZW50V2l0aG91dEFycm93XCIgW3JvdXRlckxpbmtdPVwibGlua1wiPlxyXG4gICAgPHNwYW4+e3toZWFkZXJ9fTwvc3Bhbj5cclxuPC9hPlxyXG48YSAqbmdJZj1cIiFsaW5rXCIgKGNsaWNrKT1cImV4cGFuZGVkID0gIWV4cGFuZGVkXCIgW2NsYXNzLmhhcy1hcnJvd109XCJjaGlsZHJlbi5sZW5ndGggPiAwXCIgW2NsYXNzLm5vLWFycm93XT1cImluZGVudFdpdGhvdXRBcnJvd1wiPlxyXG4gICAgPHNwYW4+e3toZWFkZXJ9fTwvc3Bhbj5cclxuPC9hPlxyXG48bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbmAsXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25JdGVtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGljb246IHN0cmluZztcbiAgICBASW5wdXQoKSBsaW5rOiBzdHJpbmc7XG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdjbGFzcy5zZWxlY3RlZCcpIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmFjdGl2ZScpXG4gICAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMubGluaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlci5pc0FjdGl2ZSh0aGlzLmxpbmssIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV2ZWw6IG51bWJlciA9IDE7XG4gICAgaW5kZW50V2l0aG91dEFycm93OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX25hdmlnYXRpb25FbmQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9jaGlsZHJlbkNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBwcml2YXRlIF9jaGlsZHJlbjogUXVlcnlMaXN0PE5hdmlnYXRpb25JdGVtQ29tcG9uZW50PjtcblxuICAgIGdldCBjaGlsZHJlbigpOiBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBwcml2YXRlIF9wYXJlbnQ6IE5hdmlnYXRpb25JdGVtQ29tcG9uZW50LFxuICAgICAgICBwcml2YXRlIF9yb3V0ZXI6IFJvdXRlcixcbiAgICAgICAgcHJpdmF0ZSBfYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlXG4gICAgKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBfcGFyZW50ID8gX3BhcmVudC5sZXZlbCArIDEgOiAxO1xuXG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25FbmQgPSBfcm91dGVyLmV2ZW50cy5waXBlKGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmV4cGFuZGVkID0gdGhpcy5oYXNBY3RpdmVMaW5rKHRoaXMubGluaykpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gQWRkIGNsYXNzZXMgdG8gcGFyZW50IGZvciBzdHlsaW5nXG4gICAgICAgIGNvbnN0IHBhcmVudExpc3RFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChwYXJlbnRMaXN0RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxDbGFzczogc3RyaW5nID0gdGhpcy5nZXRMZXZlbENsYXNzKCk7XG4gICAgICAgICAgICBpZiAobGV2ZWxDbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MocGFyZW50TGlzdEVsZW1lbnQsICduYXYnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhwYXJlbnRMaXN0RWxlbWVudCwgbGV2ZWxDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIFNldCAnaW5kZW50V2l0aG91dEFycm93J1xuICAgICAgICB0aGlzLnNldEluZGVudFdpdGhvdXRBcnJvdygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSAnaW5kZW50V2l0aG91dEFycm93JyBpbiByZXNwb25zZSB0byBjaGFuZ2VzIHRvIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuQ2hhbmdlcyA9IHRoaXMuX2NoaWxkcmVuLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2V0SW5kZW50V2l0aG91dEFycm93KCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uRW5kLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFzQWN0aXZlTGluayhsaW5rOiBzdHJpbmcgfCBVcmxUcmVlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgY29uc3QgdHJlZSA9IHRoaXMuX3JvdXRlci5jcmVhdGVVcmxUcmVlKFtsaW5rXSwge1xuICAgICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5fYWN0aXZhdGVkUm91dGUsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczogdGhpcy5fYWN0aXZhdGVkUm91dGUuc25hcHNob3QucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBmcmFnbWVudDogdGhpcy5fYWN0aXZhdGVkUm91dGUuc25hcHNob3QuZnJhZ21lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGxpbmsgJiYgdGhpcy5fcm91dGVyLmlzQWN0aXZlKHRyZWUsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGhhcyBjaGlsZHJlbiwgY2hlY2sgaWYgYW55IG9mIHRoZW0sIG9yIHRoZWlyIGRlc2NlbmRhbnRzLCBhcmUgYWN0aXZlLlxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKChpdGVtKSA9PiBpdGVtLmhhc0FjdGl2ZUxpbmsoaXRlbS5saW5rKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMZXZlbENsYXNzKCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LXNlY29uZC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtdGhpcmQtbGV2ZWwnO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LWZvdXJ0aC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtZmlmdGgtbGV2ZWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0SW5kZW50V2l0aG91dEFycm93KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IHdpbGwgYmUgaW5kZW50ZWQgYW5kIHdpbGwgaGF2ZSBhbiBhcnJvd1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBhIHBhcmVudCwgaW5kZW50IGl0IGlmIGFueSBvZiBpdHMgc2libGluZ3MgaGF2ZSBjaGlsZHJlblxuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSAhdGhpcy5fcGFyZW50LmNoaWxkcmVuLmV2ZXJ5KChpdGVtKSA9PiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUb3AtbGV2ZWwgZWxlbWVudHMgc2hvdWxkIGJlIGluZGVudGVkXG4gICAgICAgICAgICB0aGlzLmluZGVudFdpdGhvdXRBcnJvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgTmF2aWdhdGlvbkl0ZW1Db21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgICAgICBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yQ2xhc3NTZXQsIENvbG9yVmFsdWVTZXQgfSBmcm9tICcuL2NvbG9yLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29sb3JTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX2h0bWw6IHN0cmluZztcbiAgICBwcml2YXRlIF9lbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9jb2xvcnM6IFRoZW1lQ29sb3JzO1xuICAgIHByaXZhdGUgX2NvbG9yU2V0OiBhbnkgPSBjb2xvclNldHMua2VwcGVsO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnNba2V5XSA9IHRoaXMuZ2V0Q29sb3JWYWx1ZUJ5SGV4KHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENvbG9ycygpIHtcblxuICAgICAgICB0aGlzLl9odG1sID0gJyc7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0bWwgKz0gJzxkaXYgY2xhc3M9XCInICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtrZXldICsgJy1jb2xvclwiPjwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lID0gJ2NvbG9yLWNoYXJ0JztcbiAgICAgICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9odG1sO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXRba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlQnlIZXgoY29sb3I6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCBoZXggPSBjb2xvci5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHIsIGcsIGIsICcxJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlKGNvbG9yOiBDb2xvcklkZW50aWZpZXIpOiBUaGVtZUNvbG9yIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtjb2xvcl0gKyAnLWNvbG9yJyk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHJnYmEgPSBjb2xvclZhbHVlLm1hdGNoKC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvKTtcblxuICAgICAgICByZXR1cm4gbmV3IFRoZW1lQ29sb3IocmdiYVsxXSwgcmdiYVsyXSwgcmdiYVszXSwgcmdiYVs0XSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3IoY29sb3I6IENvbG9ySWRlbnRpZmllcik6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCB0aGVtZUNvbG9yID0gdGhpcy5fY29sb3JzW3RoaXMucmVzb2x2ZUNvbG9yTmFtZShjb2xvcildO1xuICAgICAgICBpZiAoIXRoZW1lQ29sb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sb3Igbm90IGZvdW5kOiAnICsgY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHRoZW1lQ29sb3IuZ2V0UmVkKCksIHRoZW1lQ29sb3IuZ2V0R3JlZW4oKSwgdGhlbWVDb2xvci5nZXRCbHVlKCksIHRoZW1lQ29sb3IuZ2V0QWxwaGEoKSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3JTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvclNldDtcbiAgICB9XG5cbiAgICBzZXRDb2xvclNldChjb2xvclNldDogQ29sb3JTZXQpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTZXQgPSBjb2xvclNldDtcbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlQnlIZXgodGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9yTmFtZSA9IHRoaXMucmVzb2x2ZUNvbG9yTmFtZSh2YWx1ZSk7XG5cbiAgICAgICAgZm9yIChsZXQgY29sb3IgaW4gdGhpcy5fY29sb3JzKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lID09PSBjb2xvci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sb3IoY29sb3JOYW1lKS50b1JnYmEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlQ29sb3JOYW1lKHZhbHVlOiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHMrL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUaGVtZUNvbG9yIHtcblxuICAgIHByaXZhdGUgX3I6IHN0cmluZztcbiAgICBwcml2YXRlIF9nOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfYjogc3RyaW5nO1xuICAgIHByaXZhdGUgX2E6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHI6IHN0cmluZywgZzogc3RyaW5nLCBiOiBzdHJpbmcsIGE6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yID0gcjtcbiAgICAgICAgdGhpcy5fZyA9IGc7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9hID0gYSA9PT0gdW5kZWZpbmVkID8gJzEnIDogYTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2UodmFsdWU6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBsZXQgciwgZywgYiwgYSA9ICcxJztcblxuICAgICAgICBjb25zdCByZ2JhUGF0dGVybiA9IC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvO1xuICAgICAgICBjb25zdCBzaG9ydEhleFBhdHRlcm4gPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICAgICAgICBjb25zdCBsb25nSGV4UGF0dGVybiA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkLztcblxuICAgICAgICBjb25zdCByZ2JhTWF0Y2ggPSB2YWx1ZS5tYXRjaChyZ2JhUGF0dGVybik7XG4gICAgICAgIGNvbnN0IHNob3J0SGV4TWF0Y2ggPSB2YWx1ZS5tYXRjaChzaG9ydEhleFBhdHRlcm4pO1xuICAgICAgICBjb25zdCBsb25nSGV4TWF0Y2ggPSB2YWx1ZS5tYXRjaChsb25nSGV4UGF0dGVybik7XG5cbiAgICAgICAgaWYgKHJnYmFNYXRjaCkge1xuICAgICAgICAgICAgciA9IHJnYmFNYXRjaFsxXTtcbiAgICAgICAgICAgIGcgPSByZ2JhTWF0Y2hbMl07XG4gICAgICAgICAgICBiID0gcmdiYU1hdGNoWzNdO1xuICAgICAgICAgICAgYSA9IHJnYmFNYXRjaFs0XSA/IHJnYmFNYXRjaFs0XSA6ICcxJztcbiAgICAgICAgfSBlbHNlIGlmIChsb25nSGV4TWF0Y2gpIHtcbiAgICAgICAgICAgIHIgPSBwYXJzZUludChsb25nSGV4TWF0Y2hbMV0sIDE2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgZyA9IHBhcnNlSW50KGxvbmdIZXhNYXRjaFsyXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQobG9uZ0hleE1hdGNoWzNdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG9ydEhleE1hdGNoKSB7XG4gICAgICAgICAgICByID0gcGFyc2VJbnQoc2hvcnRIZXhNYXRjaFsxXSArIHNob3J0SGV4TWF0Y2hbMV0sIDE2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgZyA9IHBhcnNlSW50KHNob3J0SGV4TWF0Y2hbMl0gKyBzaG9ydEhleE1hdGNoWzJdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGIgPSBwYXJzZUludChzaG9ydEhleE1hdGNoWzNdICsgc2hvcnRIZXhNYXRjaFszXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBjb2xvciAtICR7dmFsdWV9IGlzIG5vdCBhIHZhbGlkIGNvbG9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGhlbWVDb2xvcihyLCBnLCBiLCBhKTtcbiAgICB9XG5cbiAgICB0b0hleCgpIHtcbiAgICAgICAgbGV0IHJlZCA9IHBhcnNlSW50KHRoaXMuX3IpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgbGV0IGdyZWVuID0gcGFyc2VJbnQodGhpcy5fZykudG9TdHJpbmcoMTYpO1xuICAgICAgICBsZXQgYmx1ZSA9IHBhcnNlSW50KHRoaXMuX2IpLnRvU3RyaW5nKDE2KTtcblxuICAgICAgICBpZiAocmVkLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJlZCA9ICcwJyArIHJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JlZW4ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgZ3JlZW4gPSAnMCcgKyBncmVlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmx1ZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBibHVlID0gJzAnICsgYmx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnIycgKyByZWQgKyBncmVlbiArIGJsdWU7XG4gICAgfVxuXG4gICAgdG9SZ2IoKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLl9yICsgJywgJyArIHRoaXMuX2cgKyAnLCAnICsgdGhpcy5fYiArICcpJztcbiAgICB9XG5cbiAgICB0b1JnYmEoKSB7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgdGhpcy5fciArICcsICcgKyB0aGlzLl9nICsgJywgJyArIHRoaXMuX2IgKyAnLCAnICsgdGhpcy5fYSArICcpJztcbiAgICB9XG5cbiAgICBnZXRSZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yO1xuICAgIH1cblxuICAgIGdldEdyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZztcbiAgICB9XG5cbiAgICBnZXRCbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYjtcbiAgICB9XG5cbiAgICBnZXRBbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfVxuXG4gICAgc2V0UmVkKHJlZDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3IgPSByZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldEdyZWVuKGdyZWVuOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZyA9IGdyZWVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRCbHVlKGJsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9iID0gYmx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0QWxwaGEoYWxwaGE6IHN0cmluZyB8IG51bWJlcikge1xuICAgICAgICB0aGlzLl9hID0gYWxwaGEudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgY29sb3JTZXRzID0ge1xuICAgIGtlcHBlbDoge1xuICAgICAgICBjb2xvckNsYXNzU2V0OiB7XG4gICAgICAgICAgICAncHJpbWFyeSc6ICdwcmltYXJ5JyxcbiAgICAgICAgICAgICdhY2NlbnQnOiAnYWNjZW50JyxcbiAgICAgICAgICAgICdzZWNvbmRhcnknOiAnc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUxJzogJ2FsdGVybmF0ZTEnLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTInOiAnYWx0ZXJuYXRlMicsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMyc6ICdhbHRlcm5hdGUzJyxcbiAgICAgICAgICAgICd2aWJyYW50MSc6ICd2aWJyYW50MScsXG4gICAgICAgICAgICAndmlicmFudDInOiAndmlicmFudDInLFxuICAgICAgICAgICAgJ2dyZXkxJzogJ2dyZXkxJyxcbiAgICAgICAgICAgICdncmV5Mic6ICdncmV5MicsXG4gICAgICAgICAgICAnZ3JleTMnOiAnZ3JleTMnLFxuICAgICAgICAgICAgJ2dyZXk0JzogJ2dyZXk0JyxcbiAgICAgICAgICAgICdncmV5NSc6ICdncmV5NScsXG4gICAgICAgICAgICAnZ3JleTYnOiAnZ3JleTYnLFxuICAgICAgICAgICAgJ2dyZXk3JzogJ2dyZXk3JyxcbiAgICAgICAgICAgICdncmV5OCc6ICdncmV5OCcsXG4gICAgICAgICAgICAnY2hhcnQxJzogJ2NoYXJ0MScsXG4gICAgICAgICAgICAnY2hhcnQyJzogJ2NoYXJ0MicsXG4gICAgICAgICAgICAnY2hhcnQzJzogJ2NoYXJ0MycsXG4gICAgICAgICAgICAnY2hhcnQ0JzogJ2NoYXJ0NCcsXG4gICAgICAgICAgICAnY2hhcnQ1JzogJ2NoYXJ0NScsXG4gICAgICAgICAgICAnY2hhcnQ2JzogJ2NoYXJ0NicsXG4gICAgICAgICAgICAnb2snOiAnb2snLFxuICAgICAgICAgICAgJ3dhcm5pbmcnOiAnd2FybmluZycsXG4gICAgICAgICAgICAnY3JpdGljYWwnOiAnY3JpdGljYWwnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEnOiAncGFydGl0aW9uMScsXG4gICAgICAgICAgICAncGFydGl0aW9uOSc6ICdwYXJ0aXRpb245JyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMCc6ICdwYXJ0aXRpb24xMCcsXG4gICAgICAgICAgICAncGFydGl0aW9uMTEnOiAncGFydGl0aW9uMTEnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEyJzogJ3BhcnRpdGlvbjEyJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMyc6ICdwYXJ0aXRpb24xMycsXG4gICAgICAgICAgICAncGFydGl0aW9uMTQnOiAncGFydGl0aW9uMTQnLFxuICAgICAgICAgICAgJ3NvY2lhbC1jaGFydC1ub2RlJzogJ3NvY2lhbC1jaGFydC1ub2RlJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtZWRnZSc6ICdzb2NpYWwtY2hhcnQtZWRnZSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWljcm9Gb2N1czoge1xuICAgICAgICAnY29sb3JWYWx1ZVNldCc6IHtcbiAgICAgICAgICAgICdjZXJ1bGVhbic6ICcjMTY2OGMxJyxcbiAgICAgICAgICAgICdhcXVhJzogJyMyOWNlZmYnLFxuICAgICAgICAgICAgJ2FxdWFtYXJpbmUnOiAnIzJmZDZjMycsXG4gICAgICAgICAgICAnZnVjaHNpYSc6ICcjYzYxNzlkJyxcbiAgICAgICAgICAgICdpbmRpZ28nOiAnIzc0MjVhZCcsXG4gICAgICAgICAgICAnZGFyay1ibHVlJzogJyMyMzFjYTUnLFxuICAgICAgICAgICAgJ3doaXRlJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgJ3NsaWdodGx5LWdyYXknOiAnI2Y1ZjdmOCcsXG4gICAgICAgICAgICAnYnJpZ2h0LWdyYXknOiAnI2YxZjJmMycsXG4gICAgICAgICAgICAnZ3JheSc6ICcjZGNkZWRmJyxcbiAgICAgICAgICAgICdzaWx2ZXInOiAnI2JkYmVjMCcsXG4gICAgICAgICAgICAnZGltLWdyYXknOiAnIzY1NjY2OCcsXG4gICAgICAgICAgICAnZGFyay1ncmF5JzogJyMzMjM0MzUnLFxuICAgICAgICAgICAgJ2JsYWNrJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgJ2NyaW1zb24tbmVnYXRpdmUnOiAnI2U1MDA0YycsXG4gICAgICAgICAgICAnYXByaWNvdCc6ICcjZjQ4YjM0JyxcbiAgICAgICAgICAgICd5ZWxsb3cnOiAnI2ZjZGIxZicsXG4gICAgICAgICAgICAnZ3JlZW4tcG9zaXRpdmUnOiAnIzFhYWM2MCcsXG4gICAgICAgICAgICAndWx0cmFtYXJpbmUnOiAnIzM5MzljNicsXG4gICAgICAgICAgICAnc2t5Ymx1ZSc6ICcjMDBhYmYzJyxcbiAgICAgICAgICAgICdwYWxlLWFxdWEnOiAnIzQzZTRmZicsXG4gICAgICAgICAgICAncGFsZS1ncmVlbic6ICcjMWZmYmJhJyxcbiAgICAgICAgICAgICdsaW1lJzogJyM3NWRhNGQnLFxuICAgICAgICAgICAgJ29yYW5nZSc6ICcjZmZjZTAwJyxcbiAgICAgICAgICAgICdtYWdlbnRhJzogJyNlYjIzYzInLFxuICAgICAgICAgICAgJ3BhbGUtcHVycGxlJzogJyNiYTQ3ZTInLFxuICAgICAgICAgICAgJ2RhcmstdWx0cmFtYXJpbmUnOiAnIzI3MTc4MicsXG4gICAgICAgICAgICAnc3RlZWxibHVlJzogJyMwMTQyNzInLFxuICAgICAgICAgICAgJ2FyY3RpYy1ibHVlJzogJyMwYjhlYWMnLFxuICAgICAgICAgICAgJ2VtZXJhbGQnOiAnIzAwYTk4OScsXG4gICAgICAgICAgICAnb2xpdmUnOiAnIzViYmEzNicsXG4gICAgICAgICAgICAnZ29sZGVucm9kJzogJyNmZmIwMDAnLFxuICAgICAgICAgICAgJ3B1cnBsZSc6ICcjOWIxZTgzJyxcbiAgICAgICAgICAgICdwYWxlLWVnZ3BsYW50JzogJyM1MjE2YWMnLFxuICAgICAgICAgICAgJ3JlZCc6ICcjZmY0NTRmJyxcbiAgICAgICAgICAgICdwYWxlLWFtYmVyJzogJyNmZmIyNGQnLFxuICAgICAgICAgICAgJ3BhbGUtbGVtb24nOiAnI2ZkZTE1OScsXG4gICAgICAgICAgICAncGFsZS1lbWVyYWxkJzogJyMzM2MxODAnLFxuICAgICAgICAgICAgJ3BsdW0nOiAnI2IyMTY0NicsXG4gICAgICAgICAgICAnY29wcGVyJzogJyNlNTc4MjgnLFxuICAgICAgICAgICAgJ2FtYmVyJzogJyNmZmMwMDInLFxuICAgICAgICAgICAgJ2xlYWYtZ3JlZW4nOiAnIzExOGM0ZicsXG4gICAgICAgICAgICAnZm9yZXN0LWdyZWVuJzogJyMwMDY0NWEnLFxuICAgICAgICAgICAgJ3ByaW1hcnknOiAnIzAwNzNlNycsXG4gICAgICAgICAgICAnYWNjZW50JzogJyM3NDI1YWQnLFxuICAgICAgICAgICAgJ3NlY29uZGFyeSc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUxJzogJyMyOWNlZmYnLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTInOiAnIzJmZDZjMycsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMyc6ICcjYzYxNzlkJyxcbiAgICAgICAgICAgICd2aWJyYW50MSc6ICcjNDNlNGZmJyxcbiAgICAgICAgICAgICd2aWJyYW50Mic6ICcjZmZjZTAwJyxcbiAgICAgICAgICAgICdncmV5MSc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICdncmV5Mic6ICcjMzIzNDM1JyxcbiAgICAgICAgICAgICdncmV5Myc6ICcjNjU2NjY4JyxcbiAgICAgICAgICAgICdncmV5NCc6ICcjYmRiZWMwJyxcbiAgICAgICAgICAgICdncmV5NSc6ICcjZGNkZWRmJyxcbiAgICAgICAgICAgICdncmV5Nic6ICcjZjFmMmYzJyxcbiAgICAgICAgICAgICdncmV5Nyc6ICcjZjVmN2Y4JyxcbiAgICAgICAgICAgICdncmV5OCc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdjaGFydDEnOiAnIzM5MzljNicsXG4gICAgICAgICAgICAnY2hhcnQyJzogJyMwMGFiZjMnLFxuICAgICAgICAgICAgJ2NoYXJ0Myc6ICcjNzVkYTRkJyxcbiAgICAgICAgICAgICdjaGFydDQnOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnY2hhcnQ1JzogJyNlYjIzYzInLFxuICAgICAgICAgICAgJ2NoYXJ0Nic6ICcjYmE0N2UyJyxcbiAgICAgICAgICAgICdvayc6ICcjMWFhYzYwJyxcbiAgICAgICAgICAgICd3YXJuaW5nJzogJyNmNDhiMzQnLFxuICAgICAgICAgICAgJ2NyaXRpY2FsJzogJ2U1MDA0YycsXG4gICAgICAgICAgICAncGFydGl0aW9uMSc6ICcjNzQyNWFkJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb245JzogJyM1MjE2YWMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEwJzogJyM1YmJhMzYnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjExJzogJyMwMTQyNzInLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEyJzogJyNmZmIwMDAnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEzJzogJyNiZGJlYzAnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjE0JzogJyMyNzE3ODInLFxuICAgICAgICAgICAgJ3NvY2lhbC1jaGFydC1ub2RlJzogJyNmZjAwZmYnLFxuICAgICAgICAgICAgJ3NvY2lhbC1jaGFydC1lZGdlJzogJyNmZjAwZmYnXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRoZW1lQ29sb3JzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogVGhlbWVDb2xvcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xvclNldCB7XG4gICAgY29sb3JDbGFzc1NldD86IENvbG9yQ2xhc3NTZXQ7XG4gICAgY29sb3JWYWx1ZVNldD86IENvbG9yVmFsdWVTZXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JDbGFzc1NldCB7XG4gICAgW25hbWU6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xvclZhbHVlU2V0IHtcbiAgICBbbmFtZTogc3RyaW5nXTogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBDb2xvcklkZW50aWZpZXIgPSBzdHJpbmc7XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi9jb2xvci5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgICBwcm92aWRlcnM6IFtDb2xvclNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDb2xvclNlcnZpY2VNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvblNlcnZpY2Uge1xyXG5cclxuICAgIC8vIHByb3ZpZGUgZGVmYXVsdCBvcHRpb25zXHJcbiAgICBvcHRpb25zOiBOb3RpZmljYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgIGR1cmF0aW9uOiA0LFxyXG4gICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgIHNwYWNpbmc6IDEwLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fY29sb3JTZXJ2aWNlLmdldENvbG9yKCdhY2NlbnQnKS50b0hleCgpLFxyXG4gICAgICAgIGljb25Db2xvcjogdGhpcy5fY29sb3JTZXJ2aWNlLmdldENvbG9yKCdhY2NlbnQnKS50b0hleCgpXHJcbiAgICB9O1xyXG5cclxuICAgIGRpcmVjdGlvbjogTm90aWZpY2F0aW9uTGlzdERpcmVjdGlvbiA9ICdhYm92ZSc7XHJcblxyXG4gICAgbm90aWZpY2F0aW9ucyQ6IEJlaGF2aW9yU3ViamVjdDxOb3RpZmljYXRpb25SZWZbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE5vdGlmaWNhdGlvblJlZltdPihbXSk7ICAgIFxyXG5cclxuICAgIHNob3codGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIG9wdGlvbnM6IE5vdGlmaWNhdGlvbk9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIGRhdGE6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSk6IE5vdGlmaWNhdGlvblJlZiB7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgICAgICBjb25zdCBub3RpZmljYXRpb25SZWY6IE5vdGlmaWNhdGlvblJlZiA9IHtcclxuICAgICAgICAgICAgdGVtcGxhdGVSZWY6IHRlbXBsYXRlUmVmLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcclxuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcclxuICAgICAgICAgICAgc3BhY2luZzogb3B0aW9ucy5zcGFjaW5nLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICBpY29uQ29sb3I6IG9wdGlvbnMuaWNvbkNvbG9yLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYWJvdmUnKSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMudW5zaGlmdChub3RpZmljYXRpb25SZWYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMucHVzaChub3RpZmljYXRpb25SZWYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zJC5uZXh0KG5vdGlmaWNhdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyByZW1vdmUgbm90aWZpY2F0aW9uIGFmdGVyIGRlbGF5XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IDApIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpc21pc3Mobm90aWZpY2F0aW9uUmVmKSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvblJlZjtcclxuICAgIH1cclxuXHJcbiAgICBnZXRIaXN0b3J5KCk6IE5vdGlmaWNhdGlvblJlZltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc21pc3Mobm90aWZpY2F0aW9uUmVmOiBOb3RpZmljYXRpb25SZWYpOiB2b2lkIHtcclxuICAgICAgICBub3RpZmljYXRpb25SZWYudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQubmV4dCh0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkaXNtaXNzQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKS5mb3JFYWNoKG5vdGlmaWNhdGlvblJlZiA9PiBub3RpZmljYXRpb25SZWYudmlzaWJsZSA9IGZhbHNlKTtcclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMkLm5leHQodGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpKTsgICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlKSB7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uUmVmIHtcclxuICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgZHVyYXRpb246IG51bWJlcjtcclxuICAgIGRhdGU6IERhdGU7XHJcbiAgICB2aXNpYmxlPzogYm9vbGVhbjtcclxuICAgIGhlaWdodD86IG51bWJlcjtcclxuICAgIHNwYWNpbmc/OiBudW1iZXI7XHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XHJcbiAgICBpY29uQ29sb3I/OiBzdHJpbmc7XHJcbiAgICBkYXRhOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlmaWNhdGlvbk9wdGlvbnMge1xyXG4gICAgZHVyYXRpb24/OiBudW1iZXI7XHJcbiAgICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgICBzcGFjaW5nPzogbnVtYmVyO1xyXG4gICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4gICAgaWNvbkNvbG9yPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOb3RpZmljYXRpb25MaXN0RGlyZWN0aW9uID0gJ2Fib3ZlJyB8ICdiZWxvdyc7IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlLCBOb3RpZmljYXRpb25SZWYsIE5vdGlmaWNhdGlvbkxpc3REaXJlY3Rpb24gfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IHRyaWdnZXIsIHN0YXRlLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMvbWFwJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LW5vdGlmaWNhdGlvbi1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJub3RpZmljYXRpb25cIiAqbmdGb3I9XCJsZXQgbm90aWZpY2F0aW9uUmVmIG9mIG5vdGlmaWNhdGlvbnMkIHwgYXN5bmM7IGxldCBpZHggPSBpbmRleFwiXHJcbiAgICBbc3R5bGUudG9wLnB4XT1cIihub3RpZmljYXRpb25SZWYuaGVpZ2h0ICsgbm90aWZpY2F0aW9uUmVmLnNwYWNpbmcpICogaWR4XCJcclxuICAgIFtzdHlsZS5oZWlnaHQucHhdPVwibm90aWZpY2F0aW9uUmVmLmhlaWdodFwiXHJcbiAgICBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XCJub3RpZmljYXRpb25SZWYuYmFja2dyb3VuZENvbG9yXCJcclxuICAgIFtAbm90aWZpY2F0aW9uU3RhdGVdPlxyXG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5vdGlmaWNhdGlvblJlZi50ZW1wbGF0ZVJlZjsgY29udGV4dDogeyAkaW1wbGljaXQ6IG5vdGlmaWNhdGlvblJlZiwgZGF0YTogbm90aWZpY2F0aW9uUmVmLmRhdGEgfVwiPjwvbmctY29udGFpbmVyPlxyXG48L2Rpdj5cclxuYCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ25vdGlmaWNhdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgc3RhdGUoJ2luJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJywgb3BhY2l0eTogMC45IH0pKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtcbiAgICAgICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTUwcHgpJywgb3BhY2l0eTogMCB9KSxcbiAgICAgICAgICAgICAgICBhbmltYXRlKDUwMClcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xuICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoNTBweCknLCBvcGFjaXR5OiAwIH0pKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnQge1xuICAgIFxuICAgIEBJbnB1dCgpIFxuICAgIHNldCBkaXJlY3Rpb24oZGlyZWN0aW9uOiBOb3RpZmljYXRpb25MaXN0RGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvblNlcnZpY2UuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnY2xhc3MnKSBwb3NpdGlvbjogTm90aWZpY2F0aW9uTGlzdFBvc3Rpb24gPSAndG9wLXJpZ2h0JztcblxuICAgIG5vdGlmaWNhdGlvbnMkOiBPYnNlcnZhYmxlPE5vdGlmaWNhdGlvblJlZltdPiA9IHRoaXMuX25vdGlmaWNhdGlvblNlcnZpY2Uubm90aWZpY2F0aW9ucyQucGlwZShcbiAgICAgICAgbWFwKChub3RpZmljYXRpb25SZWZzOiBOb3RpZmljYXRpb25SZWZbXSkgPT4gbm90aWZpY2F0aW9uUmVmcy5maWx0ZXIobm90aWZpY2F0aW9uUmVmID0+IG5vdGlmaWNhdGlvblJlZi52aXNpYmxlKSxcbiAgICApKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX25vdGlmaWNhdGlvblNlcnZpY2U6IE5vdGlmaWNhdGlvblNlcnZpY2UpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgTm90aWZpY2F0aW9uTGlzdFBvc3Rpb24gPSAndG9wLWxlZnQnIHwgJ3RvcC1yaWdodCcgfCAnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1yaWdodCc7IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uTGlzdENvbXBvbmVudCB9IGZyb20gJy4vbm90aWZpY2F0aW9uLWxpc3QuY29tcG9uZW50JztcclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDb2xvclNlcnZpY2VNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIENvbW1vbk1vZHVsZSxcclxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGVcclxuICAgIF0sXHJcbiAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgTm90aWZpY2F0aW9uTGlzdENvbXBvbmVudFxyXG4gICAgXSxcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnRcclxuICAgIF0sXHJcbiAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBOb3RpZmljYXRpb25TZXJ2aWNlXHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25Nb2R1bGUgeyB9XHJcbiIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBOVU1CRVJfUElDS0VSX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnVtYmVyUGlja2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1udW1iZXItcGlja2VyJyxcbiAgICB0ZW1wbGF0ZTogYDxpbnB1dCB0eXBlPVwibnVtYmVyXCJcbiAgICAgICByb2xlPVwic3BpbmJ1dHRvblwiXG4gICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbnVtYmVyLXBpY2tlci1pbnB1dFwiXG4gICAgICAgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiXG4gICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAoa2V5ZG93bi5BcnJvd0Rvd24pPVwiZGVjcmVtZW50KCRldmVudClcIlxuICAgICAgIChrZXlkb3duLkFycm93VXApPVwiaW5jcmVtZW50KCRldmVudClcIlxuICAgICAgICh3aGVlbCk9XCJvblNjcm9sbCgkZXZlbnQpXCJcbiAgICAgICBzdGVwPVwiYW55XCJcbiAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgIFthdHRyLmFyaWEtdmFsdWVtaW5dPVwibWluXCJcbiAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cInZhbHVlXCJcbiAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiPlxuXG48ZGl2IGNsYXNzPVwibnVtYmVyLXBpY2tlci1jb250cm9sc1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cIm51bWJlci1waWNrZXItY29udHJvbC11cFwiXG4gICAgICAgICAoY2xpY2spPVwiaW5jcmVtZW50KCRldmVudClcIlxuICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkIHx8IHZhbHVlID49IG1heFwiPlxuXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLXVwXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm51bWJlci1waWNrZXItY29udHJvbC1kb3duXCJcbiAgICAgICAgIChjbGljayk9XCJkZWNyZW1lbnQoJGV2ZW50KVwiXG4gICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwiZGlzYWJsZWQgfHwgdmFsdWUgPD0gbWluXCI+XG5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtZG93blwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cblxuPC9kaXY+YCxcbiAgICBwcm92aWRlcnM6IFtOVU1CRVJfUElDS0VSX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MuaGFzLWVycm9yXSc6ICchaXNWYWxpZCgpJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTnVtYmVyUGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfbWluOiBudW1iZXIgPSAtSW5maW5pdHk7XG4gICAgcHJpdmF0ZSBfbWF4OiBudW1iZXIgPSBJbmZpbml0eTtcbiAgICBwcml2YXRlIF9zdGVwOiBudW1iZXIgPSAxO1xuICAgIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdmFsdWU6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBfcHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4geyB9O1xuXG4gICAgQElucHV0KCkgdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgQElucHV0KCd2YWx1ZScpXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBtaW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgc2V0IG1pbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9taW4gPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBtYXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG4gICAgc2V0IG1heCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXggPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgIH1cbiAgICBzZXQgc3RlcCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGVwID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdkaXNhYmxlZCcpIHx8IHZhbHVlID09PSB0cnVlO1xuICAgIH1cblxuICAgIGluY3JlbWVudChldmVudDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLnZhbHVlICsgdGhpcy5zdGVwLCB0aGlzLm1heCksIHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY3JlbWVudChldmVudDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLnZhbHVlIC0gdGhpcy5zdGVwLCB0aGlzLm1pbiksIHRoaXMubWF4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzVmFsaWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlIDwgdGhpcy5taW4gfHwgdGhpcy52YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgICB9XG5cbiAgICBvblNjcm9sbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGxldCBzY3JvbGxWYWx1ZSA9IGV2ZW50LmRlbHRhWSB8fCBldmVudC53aGVlbERlbHRhO1xuXG4gICAgICAgIGlmIChzY3JvbGxWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50KGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7IH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBOdW1iZXJQaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL251bWJlci1waWNrZXIuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtOdW1iZXJQaWNrZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW051bWJlclBpY2tlckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgTnVtYmVyUGlja2VyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eFBhZ2VIZWFkZXJDdXN0b21NZW51XScgXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlIHsgfSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtLCBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlclNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgaXRlbXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1bXT4oW10pO1xuICAgIHNlbGVjdGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPihudWxsKTtcbiAgICBzZWxlY3RlZFJvb3QkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0+KG51bGwpO1xuICAgIHNlY29uZGFyeSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBhY3RpdmVJY29uTWVudSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJJY29uTWVudT4obnVsbCk7XG4gICAgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuc2VsZWN0ZWQkLnBpcGUobWFwKHNlbGVjdGVkID0+IHRoaXMuZ2V0Um9vdChzZWxlY3RlZCkpKS5zdWJzY3JpYmUocm9vdCA9PiB0aGlzLnNlbGVjdGVkUm9vdCQubmV4dChyb290KSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0pOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdCAmJiBpdGVtICYmIGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgZmlyc3QgY2hpbGQgaW4gc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgbW9kZVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCQubmV4dChpdGVtLmNoaWxkcmVuWzBdKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaW4gc2Vjb25kYXJ5IG5hdmlnYXRpb24gbW9kZSBhbmQgd2UgY2xpY2sgYSBwYXJlbnQgLSBkb250IGRlc2VsZWN0IHRoZSBjaGlsZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpID09PSB0cnVlICYmIHRoaXMuaXNQYXJlbnRPZih0aGlzLnNlbGVjdGVkJC5nZXRWYWx1ZSgpLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNlbGVjdCB0aGUgZ2l2ZW4gaXRlbVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCQubmV4dChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc2VsZWN0KGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB8IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGVzZWxlY3QgdGhlIGN1cnJlbnQgaXRlbVxuICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBhbnkgY2hpbGRyZW4gYW5kIGRlc2VsZWN0IHRoZW1cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChfaXRlbSA9PiB0aGlzLmRlc2VsZWN0KF9pdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtcyQuZ2V0VmFsdWUoKS5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5kZXNlbGVjdChpdGVtKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlSXRlbShpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0sIHNlbGVjdGVkOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0pOiB2b2lkIHtcblxuICAgICAgICAvLyBJdGVtIGlzIHNlbGVjdGVkIGlmIGl0IGlzIHRoZSBzZWxlY3RlZCBpdGVtLCBvciBvbmUgb2YgdGhlIHNlbGVjdGVkIGl0ZW0ncyBhbmNlc3RvcnMuXG4gICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSAoaXRlbSA9PT0gc2VsZWN0ZWQpIHx8IHRoaXMuaXNQYXJlbnRPZihzZWxlY3RlZCwgaXRlbSk7XG5cbiAgICAgICAgaWYgKGl0ZW0gPT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBzZWxlY3QgZnVuY3Rpb24gaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3QuY2FsbChpdGVtLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEl0ZW1zKGl0ZW1zOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1bXSA9IFtdKTogdm9pZCB7XG4gICAgICAgIC8vIGlkZW50aWZ5IGFsbCBwYXJlbnQgZWxlbWVudHNcbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHRoaXMuc2V0UGFyZW50KGl0ZW0pKTtcblxuICAgICAgICB0aGlzLml0ZW1zJC5uZXh0KGl0ZW1zKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGluaXRhbGx5IHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgY29uc3QgaW5pdGlhbFNlbGVjdGVkSXRlbSA9IGl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnNlbGVjdGVkID09PSB0cnVlKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoaW5pdGlhbFNlbGVjdGVkSXRlbSk7XG4gICAgfVxuXG4gICAgc2V0U2Vjb25kYXJ5TmF2aWdhdGlvbihlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5JC5uZXh0KGVuYWJsZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Um9vdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5wYXJlbnQgPyB0aGlzLmdldFJvb3QoaXRlbS5wYXJlbnQpIDogaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBhcmVudChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb24gfCBudWxsKTogdm9pZCB7XG4gICAgICAgIC8vIHNldCB0aGUgcGFyZW50IGZpZWxkXG4gICAgICAgIGl0ZW0ucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIC8vIGNhbGwgdGhpcyBmdW5jdGlvbiByZWN1cnNpdmVseSBvbiBhbGwgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB0aGlzLnNldFBhcmVudChjaGlsZCwgaXRlbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1BhcmVudE9mKG5vZGU6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uLCBwYXJlbnQ6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBhcmVudHMgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgaXMgdGhlIG1hdGNoIHdlIGFyZSBsb29raW5nIGZvciByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgcG90ZW50aWFsbHkgZ3JhbmRwYXJlbnRzIHRoZW4gY2hlY2sgdGhlbSB0b29cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihub2RlLnBhcmVudCwgcGFyZW50KTtcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uID0gUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIHwgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW07IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51LCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0gfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcGFnZS1oZWFkZXItaWNvbi1tZW51JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1pY29uLW1lbnVcIlxuICAgIGRyb3Bkb3duXG4gICAgcGxhY2VtZW50PVwiYm90dG9tIHJpZ2h0XCJcbiAgICBbKGlzT3BlbildPVwiaXNPcGVuXCI+XG5cbiAgICA8YSByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9XCJwYWdlLWhlYWRlci1pY29uLW1lbnUtYnV0dG9uXCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJtZW51LmxhYmVsXCJcbiAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAoY2xpY2spPVwic2VsZWN0KG1lbnUpXCJcbiAgICAgICAgZHJvcGRvd25Ub2dnbGVcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblRvZ2dsZVxuICAgICAgICAjbWVudU5hdmlnYXRpb25Ub2dnbGU9XCJ1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlXCJcbiAgICAgICAgWyhtZW51T3BlbildPVwiaXNPcGVuXCI+XG5cbiAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvblwiIFtuZ0NsYXNzXT1cIm1lbnUuaWNvblwiPjwvaT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1wcmltYXJ5XCIgKm5nSWY9XCJtZW51Py5iYWRnZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt7IG1lbnUuYmFkZ2UgfX08L3NwYW4+XG5cbiAgICA8L2E+XG5cbiAgICA8dWwgKmRyb3Bkb3duTWVudVxuICAgICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIlxuICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25cbiAgICAgICAgW3RvZ2dsZUJ1dHRvbl09XCJtZW51TmF2aWdhdGlvblRvZ2dsZVwiPlxuXG4gICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgZHJvcGRvd24gb2YgbWVudT8uZHJvcGRvd25cIlxuICAgICAgICAgICAgcm9sZT1cIm5vbmVcIlxuICAgICAgICAgICAgW2NsYXNzLmRyb3Bkb3duLWhlYWRlcl09XCJkcm9wZG93bi5oZWFkZXJcIlxuICAgICAgICAgICAgW2NsYXNzLmRyb3Bkb3duLWRpdmlkZXJdPVwiZHJvcGRvd24uZGl2aWRlclwiPlxuXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZvbnQtYm9sZFwiICpuZ0lmPVwiZHJvcGRvd24uaGVhZGVyXCI+e3sgZHJvcGRvd24udGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgICAgIDxhICpuZ0lmPVwiIWRyb3Bkb3duLmhlYWRlclwiXG4gICAgICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3QoZHJvcGRvd24pXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bik9XCJrZXlkb3duSGFuZGxlcihkcm9wZG93biwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgdXhNZW51TmF2aWdhdGlvbkl0ZW0+XG5cblxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZHJvcGRvd24taXRlbS10aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1md1wiIFtuZ0NsYXNzXT1cImRyb3Bkb3duLmljb25cIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIHt7IGRyb3Bkb3duLnRpdGxlIH19XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiZHJvcGRvd24uc3VidGl0bGVcIiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0tc3VidGl0bGVcIj57eyBkcm9wZG93bi5zdWJ0aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuXG4gICAgPC91bD5cbjwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckljb25NZW51Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIG1lbnU6IFBhZ2VIZWFkZXJJY29uTWVudTtcblxuICAgIGdldCBpc09wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc09wZW47XG4gICAgfVxuXG4gICAgc2V0IGlzT3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9pc09wZW4gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmFjdGl2ZUljb25NZW51JC5uZXh0KHRoaXMubWVudSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBAVmlld0NoaWxkKCdtZW51TmF2aWdhdGlvblRvZ2dsZScpIG1lbnVOYXZpZ2F0aW9uVG9nZ2xlOiBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZTtcblxuICAgIHByaXZhdGUgX2lzT3BlbjogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9zZXJ2aWNlLmFjdGl2ZUljb25NZW51JC5zdWJzY3JpYmUoKG5leHQpID0+IHtcbiAgICAgICAgICAgIC8vIENsb3NlIGFsbCBidXQgdGhlIG1vc3QgcmVjZW50bHkgb3BlbmVkIG1lbnVcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSB0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVySWNvbk1lbnUgfCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0KSB7XG4gICAgICAgICAgICBpdGVtLnNlbGVjdC5jYWxsKGl0ZW0sIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAga2V5ZG93bkhhbmRsZXIoaXRlbTogUGFnZUhlYWRlckljb25NZW51IHwgUGFnZUhlYWRlckljb25NZW51RHJvcGRvd25JdGVtLCBldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubWVudU5hdmlnYXRpb25Ub2dnbGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSB9IGZyb20gJy4uL25hdmlnYXRpb24uY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24tZHJvcGRvd24taXRlbScsXG4gICAgZXhwb3J0QXM6ICd1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24tZHJvcGRvd24taXRlbScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDBcIlxuICAgIGRyb3Bkb3duXG4gICAgI3N1Yk1lbnU9XCJicy1kcm9wZG93blwiXG4gICAgW2lzT3Blbl09XCJkcm9wZG93bk9wZW5cIlxuICAgIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgIHBsYWNlbWVudD1cInJpZ2h0XCJcbiAgICAobW91c2VlbnRlcik9XCJob3ZlclN0YXJ0KClcIlxuICAgIChtb3VzZWxlYXZlKT1cImhvdmVyTGVhdmUoKVwiPlxuXG4gICAgPGEgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiXG4gICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiZHJvcGRvd25PcGVuXCJcbiAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICNidXR0b25cbiAgICAgICAgZHJvcGRvd25Ub2dnbGVcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblRvZ2dsZVxuICAgICAgICAjbWVudU5hdmlnYXRpb25Ub2dnbGU9XCJ1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlXCJcbiAgICAgICAgWyhtZW51T3BlbildPVwiZHJvcGRvd25PcGVuXCJcbiAgICAgICAgbWVudVBvc2l0aW9uPVwicmlnaHRcIj5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0tdGl0bGVcIj57eyBpdGVtLnRpdGxlIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0taWNvbiBocGUtaWNvbiBocGUtbmV4dFwiPjwvc3Bhbj5cblxuICAgIDwvYT5cblxuICAgIDx1bCAqZHJvcGRvd25NZW51XG4gICAgICAgIHJvbGU9XCJtZW51XCJcbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1tZW51IGhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1zdWJtZW51XCJcbiAgICAgICAgKG1vdXNlZW50ZXIpPVwiaG92ZXJTdGFydCgpXCJcbiAgICAgICAgKG1vdXNlbGVhdmUpPVwiaG92ZXJMZWF2ZSgpXCJcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblxuICAgICAgICAjbWVudU5hdmlnYXRpb249XCJ1eE1lbnVOYXZpZ2F0aW9uXCJcbiAgICAgICAgW3RvZ2dsZUJ1dHRvbl09XCJtZW51TmF2aWdhdGlvblRvZ2dsZVwiXG4gICAgICAgIHRvZ2dsZUJ1dHRvblBvc2l0aW9uPVwibGVmdFwiPlxuXG4gICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgc3ViSXRlbSBvZiBpdGVtLmNoaWxkcmVuXCIgcm9sZT1cIm5vbmVcIj5cblxuICAgICAgICAgICAgPGEgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJzdWJJdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cInN1Ykl0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3Qoc3ViSXRlbSlcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duKT1cImtleWRvd25IYW5kbGVyKCRldmVudCwgc3ViSXRlbSlcIlxuICAgICAgICAgICAgICAgIHV4TWVudU5hdmlnYXRpb25JdGVtPlxuXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJkcm9wZG93bi1pdGVtLXRpdGxlXCI+e3sgc3ViSXRlbS50aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICAgICAgPC9hPlxuXG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cblxuPC9kaXY+XG5cbjxkaXYgKm5nSWY9XCIhaXRlbS5jaGlsZHJlbiB8fCBpdGVtLmNoaWxkcmVuLmxlbmd0aCA9PT0gMFwiXG4gICAgKG1vdXNlZW50ZXIpPVwiaG92ZXJTdGFydCgpXCJcbiAgICAobW91c2VsZWF2ZSk9XCJob3ZlckxlYXZlKClcIj5cblxuICAgIDxhIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICNidXR0b25cbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgKGNsaWNrKT1cInNlbGVjdChpdGVtKVwiXG4gICAgICAgIChrZXlkb3duKT1cImtleWRvd25IYW5kbGVyKCRldmVudCwgaXRlbSlcIj5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0tdGl0bGVcIj57eyBpdGVtLnRpdGxlIH19PC9zcGFuPlxuXG4gICAgPC9hPlxuXG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtO1xuXG4gICAgQFZpZXdDaGlsZCgnYnV0dG9uJylcbiAgICBidXR0b246IEVsZW1lbnRSZWY7XG5cbiAgICBkcm9wZG93bk9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX2hvdmVyJDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gc3RyZWFtIHdpdGggYSBkZWJvdW5jZSAoYSBzbWFsbCBkZWJvdW5jZSBpcyBhbGwgdGhhdCBpcyByZXF1aXJlZClcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5faG92ZXIkLnBpcGUoZGVib3VuY2VUaW1lKDEpKS5zdWJzY3JpYmUodmlzaWJsZSA9PiB0aGlzLmRyb3Bkb3duT3BlbiA9IHZpc2libGUpO1xuXG4gICAgICAgIC8vIENsb3NlIHN1Ym1lbnVzIHdoZW4gc2VsZWN0ZWQgaXRlbSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICBfcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0ZWQkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSkge1xuXG4gICAgICAgIC8vIGNsaWNraW5nIG9uIGFuIGl0ZW0gd2l0aCBjaGlsZHJlbiB0aGVuIHJldHVyblxuICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgc2VsZWN0ZWQgaXRlbSBpbiBhbiBldmVudFxuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3QoaXRlbSk7XG4gICAgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBob3ZlclN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9ob3ZlciQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICBob3ZlckxlYXZlKCkge1xuICAgICAgICB0aGlzLl9ob3ZlciQubmV4dChmYWxzZSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5ZG93bkhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIFF1ZXJ5TGlzdCwgVmlld0NoaWxkLCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJzRHJvcGRvd25EaXJlY3RpdmUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2Ryb3Bkb3duJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1pdGVtJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCJpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhKHNlY29uZGFyeSQgfCBhc3luYylcIlxuICAgIGRyb3Bkb3duXG4gICAgI21lbnU9XCJicy1kcm9wZG93blwiXG4gICAgWyhpc09wZW4pXT1cImlzT3BlblwiXG4gICAgY29udGFpbmVyPVwiYm9keVwiXG4gICAgcGxhY2VtZW50PVwiYm90dG9tIGxlZnRcIj5cblxuICAgIDxidXR0b24gcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgY2xhc3M9XCJob3Jpem9udGFsLW5hdmlnYXRpb24tYnV0dG9uXCJcbiAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICBbY2xhc3Mub3Blbl09XCJpc09wZW5cIlxuICAgICAgICBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiXG4gICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiaXNPcGVuXCJcbiAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgZHJvcGRvd25Ub2dnbGVcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblRvZ2dsZVxuICAgICAgICAjYnV0dG9uPVwidXhNZW51TmF2aWdhdGlvblRvZ2dsZVwiXG4gICAgICAgIFsobWVudU9wZW4pXT1cImlzT3BlblwiPlxuXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gbmF2aWdhdGlvbi1pdGVtLWljb25cIiAqbmdJZj1cIml0ZW0uaWNvblwiIFtuZ0NsYXNzXT1cIml0ZW0/Lmljb25cIj48L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibmF2aWdhdGlvbi1pdGVtLWxhYmVsXCI+e3sgaXRlbT8udGl0bGUgfX08L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWRvd25cIj48L3NwYW4+XG5cbiAgICA8L2J1dHRvbj5cblxuICAgIDxkaXYgKmRyb3Bkb3duTWVudVxuICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgIGNsYXNzPVwiZHJvcGRvd24tbWVudSBob3Jpem9udGFsLW5hdmlnYXRpb24tZHJvcGRvd24tbWVudVwiXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25cbiAgICAgICAgW3RvZ2dsZUJ1dHRvbl09XCJidXR0b25cIlxuICAgICAgICB0b2dnbGVCdXR0b25Qb3NpdGlvbj1cInRvcFwiPlxuXG4gICAgICAgIDxkaXYgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbT8uY2hpbGRyZW5cIiB1eE1lbnVOYXZpZ2F0aW9uSXRlbSAoYWN0aXZhdGVkKT1cImRyb3Bkb3duSXRlbS5mb2N1cygpXCI+XG4gICAgICAgICAgICA8dXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW1cbiAgICAgICAgICAgICAgICAjZHJvcGRvd25JdGVtPVwidXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW1cIlxuICAgICAgICAgICAgICAgIFtpdGVtXT1cIml0ZW1cIj5cbiAgICAgICAgICAgIDwvdXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuXG48YnV0dG9uICpuZ0lmPVwiIWl0ZW0uY2hpbGRyZW4gfHwgaXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgKHNlY29uZGFyeSQgfCBhc3luYylcIlxuICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgY2xhc3M9XCJob3Jpem9udGFsLW5hdmlnYXRpb24tYnV0dG9uXCJcbiAgICBbY2xhc3Muc2VsZWN0ZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG4gICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAoY2xpY2spPVwic2VsZWN0KClcIj5cblxuICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gbmF2aWdhdGlvbi1pdGVtLWljb25cIiAqbmdJZj1cIml0ZW0uaWNvblwiIFtuZ0NsYXNzXT1cIml0ZW0/Lmljb25cIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJuYXZpZ2F0aW9uLWl0ZW0tbGFiZWxcIj57eyBpdGVtPy50aXRsZSB9fTwvc3Bhbj5cblxuPC9idXR0b24+YFxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdidXR0b24nKSBidXR0b246IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGQoJ21lbnUnKSBtZW51OiBCc0Ryb3Bkb3duRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGRyZW4oUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1Db21wb25lbnQpIGRyb3Bkb3duczogUXVlcnlMaXN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50PjtcblxuICAgIEBJbnB1dCgpIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbTtcblxuICAgIHNlY29uZGFyeSQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlY29uZGFyeSQ7XG5cbiAgICBpc09wZW46IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJC5zdWJzY3JpYmUobmV4dCA9PiB7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3RlZCBzdGF0ZSBmb3IgdGhpcyBpdGVtXG4gICAgICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS51cGRhdGVJdGVtKHRoaXMuaXRlbSwgbmV4dCk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIElmIG1lbnUgd2FzIGNsb3NlZCwga2VlcCBmb2N1cyBvbiB0aGUgdG9nZ2xlIGJ1dHRvblxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51Lm9uSGlkZGVuLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyb3Bkb3ducy5mb3JFYWNoKGRyb3Bkb3duID0+IGRyb3Bkb3duLmNsb3NlKCkpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoKSB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaGFzIGNoaWxkcmVuIHRoZW4gZG8gbm90aGluZyBhdCB0aGlzIHN0YWdlXG4gICAgICAgIGlmICh0aGlzLml0ZW0uY2hpbGRyZW4gJiYgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNlbGVjdCB0aGUgY3VycmVudCBpdGVtXG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdCh0aGlzLml0ZW0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBkZWxheSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbV0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCd1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbScpXHJcbiAgICBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW07XHJcblxyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG5cclxuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQucGlwZShkZWxheSgwKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShuZXh0ID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3RlZCBzdGF0ZSBmb3IgdGhpcyBpdGVtXHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnVwZGF0ZUl0ZW0odGhpcy5pdGVtLCBuZXh0KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBRdWVyeUxpc3QsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb24sIFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24nLFxuICAgIHRlbXBsYXRlOiBgPHV4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1pdGVtXHJcbiAgICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtcyQgfCBhc3luY1wiXHJcbiAgICBbaXRlbV09XCJpdGVtXCI+XHJcbjwvdXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWl0ZW0+XHJcblxyXG48ZGl2IGNsYXNzPVwic2VsZWN0ZWQtaW5kaWNhdG9yXCJcclxuICAgIFtzdHlsZS5vcGFjaXR5XT1cImluZGljYXRvclZpc2libGUgPyAxIDogMFwiXHJcbiAgICBbc3R5bGUubWFyZ2luLWxlZnQucHhdPVwiaW5kaWNhdG9yWFwiXHJcbiAgICBbc3R5bGUud2lkdGgucHhdPVwiaW5kaWNhdG9yV2lkdGhcIj5cclxuPC9kaXY+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICdyb2xlJzogJ21lbnViYXInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkcmVuKFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCkgbWVudUl0ZW1zOiBRdWVyeUxpc3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50PjtcblxuICAgIGl0ZW1zJDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbVtdPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLml0ZW1zJDtcbiAgICBpbmRpY2F0b3JWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgaW5kaWNhdG9yWDogbnVtYmVyID0gMDtcbiAgICBpbmRpY2F0b3JXaWR0aDogbnVtYmVyID0gMDtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHJlc2l6ZVNlcnZpY2U6IFJlc2l6ZVNlcnZpY2UsIHByaXZhdGUgX3BhZ2VIZWFkZXJTZXJ2aWNlOiBQYWdlSGVhZGVyU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KS5zdWJzY3JpYmUodGhpcy51cGRhdGVTZWxlY3RlZEluZGljYXRvci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChfcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yLmJpbmQodGhpcykpKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IoKTogdm9pZCB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLm1lbnVJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pdGVtLnNlbGVjdGVkKTtcblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIGluZGljYXRvclxuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3JWaXNpYmxlID0gISFzZWxlY3RlZDtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSB3aWR0aCBvZiB0aGUgaW5kaWNhdG9yIHRvIG1hdGNoIHRoZSB3aWR0aCBvZiB0aGUgbmF2aWdhdGlvbiBpdGVtXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNlbGVjdGVkLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvclggPSBzZWxlY3RlZC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvcldpZHRoID0gcGFyc2VJbnQoc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0ge1xuICAgIGljb24/OiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBzZWxlY3RlZD86IGJvb2xlYW47XG4gICAgc2VsZWN0PzogKGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSkgPT4gdm9pZDtcbiAgICBjaGlsZHJlbj86IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtW107XG4gICAgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0ge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgc2VsZWN0ZWQ/OiBib29sZWFuO1xuICAgIHNlbGVjdD86IChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSkgPT4gdm9pZDtcbiAgICBjaGlsZHJlbj86IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtW107XG4gICAgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb247XG59XG5cbi8vIFRoaXMgaXMgYW4gYWxpYXMgZm9yIE1GIHVzZSBhcyBcIkRyb3Bkb3duSXRlbVwiIGRvZXNuJ3QgbWFrZSBzZW5zZSBpbiBjb250ZXh0IHdpdGggaG93IGl0IGlzIHVzZWRcbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUhlYWRlclNlY29uZGFyeU5hdmlnYXRpb25JdGVtIGV4dGVuZHMgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0geyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgQnJlYWRjcnVtYiB9IGZyb20gJy4uL2JyZWFkY3J1bWJzL2luZGV4JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlIH0gZnJvbSAnLi9jdXN0b20tbWVudS9jdXN0b20tbWVudS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuL3BhZ2UtaGVhZGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyJyxcbiAgICBleHBvcnRBczogJ3V4LXBhZ2UtaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1wYWdlLWhlYWRlclwiIFtjbGFzcy5wYWdlLWhlYWRlci1jb25kZW5zZWRdPVwiY29uZGVuc2VkXCIgcm9sZT1cImJhbm5lclwiPlxuXG4gICAgPCEtLSBEaXNwbGF5IFVwcGVyIFNlY3Rpb24gd2hlbiBub3QgY29uZGVuc2VkIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1hY3Rpb25zXCIgKm5nSWY9XCIhY29uZGVuc2VkXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWxvZ28tY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiIFtoaWRkZW5dPVwiIWxvZ29cIj5cbiAgICAgICAgICAgIDxpbWcgW2F0dHIuc3JjXT1cImxvZ29cIiBjbGFzcz1cInBhZ2UtaGVhZGVyLWxvZ29cIj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLW5hdmlnYXRpb25cIiBbbmdDbGFzc109XCJhbGlnbm1lbnRcIiByb2xlPVwibmF2aWdhdGlvblwiIGFyaWEtbGFiZWw9XCJQcmltYXJ5IE5hdmlnYXRpb25cIj5cblxuICAgICAgICAgICAgPCEtLSBUaGUgVG9wIE5hdmlnYXRpb24gT3B0aW9ucyAtLT5cbiAgICAgICAgICAgIDx1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24+PC91eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1pY29uLW1lbnVzXCIgcm9sZT1cInRvb2xiYXJcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IG1lbnUgb2YgY3VzdG9tTWVudXNcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJtZW51XCI+PC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDx1eC1wYWdlLWhlYWRlci1pY29uLW1lbnUgKm5nRm9yPVwibGV0IG1lbnUgb2YgaWNvbk1lbnVzXCIgW21lbnVdPVwibWVudVwiPjwvdXgtcGFnZS1oZWFkZXItaWNvbi1tZW51PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRGlzcGxheSBMb3dlciBTZWN0aW9uIFdoZW4gTm90IENvbmRlbnNlZCAtLT5cbiAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItZGV0YWlsc1wiICpuZ0lmPVwiIWNvbmRlbnNlZFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1zdGF0ZS1jb250YWluZXJcIiByb2xlPVwibmF2aWdhdGlvblwiPlxuXG4gICAgICAgICAgICA8YnV0dG9uICpuZ0lmPVwiYmFja1Zpc2libGUgPT09IHRydWVcIiBjbGFzcz1cInBhZ2UtaGVhZGVyLWJhY2stYnV0dG9uXCIgKGNsaWNrKT1cImdvQmFjaygpXCIgYXJpYS1sYWJlbD1cIkdvIEJhY2tcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1wcmV2aW91cyB0ZXh0LXByaW1hcnlcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLXRpdGxlLWNvbnRhaW5lclwiPlxuXG4gICAgICAgICAgICAgICAgPHV4LWJyZWFkY3J1bWJzIFtjcnVtYnNdPVwiY3J1bWJzXCI+PC91eC1icmVhZGNydW1icz5cblxuICAgICAgICAgICAgICAgIDxoMSBjbGFzcz1cInBhZ2UtaGVhZGVyLXRpdGxlXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJmYW1pbHlCYWNrZ3JvdW5kXCIgW3N0eWxlLmNvbG9yXT1cImZhbWlseUZvcmVncm91bmRcIj57eyBoZWFkZXIgfX08L2gxPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRGlzcGxheSBUaGlzIFNlY3Rpb24gT3B0aW1pemVkIGZvciBDb25kZW5zZWQgTW9kZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItY29uZGVuc2VkLWNvbnRlbnRcIiAqbmdJZj1cImNvbmRlbnNlZFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1icmVhZGNydW1ic1wiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XG4gICAgICAgICAgICA8dXgtYnJlYWRjcnVtYnMgW2NydW1ic109XCJjcnVtYnNcIj48L3V4LWJyZWFkY3J1bWJzPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItbmF2aWdhdGlvblwiIFtuZ0NsYXNzXT1cImFsaWdubWVudFwiIHJvbGU9XCJuYXZpZ2F0aW9uXCIgYXJpYS1sYWJlbD1cIlByaW1hcnkgTmF2aWdhdGlvblwiPlxuXG4gICAgICAgICAgICA8IS0tIFRoZSBUb3AgTmF2aWdhdGlvbiBPcHRpb25zIC0tPlxuICAgICAgICAgICAgPHV4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbj48L3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWljb24tbWVudXNcIiByb2xlPVwidG9vbGJhclwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgbWVudSBvZiBjdXN0b21NZW51c1wiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm1lbnVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDx1eC1wYWdlLWhlYWRlci1pY29uLW1lbnUgKm5nRm9yPVwibGV0IG1lbnUgb2YgaWNvbk1lbnVzXCIgW21lbnVdPVwibWVudVwiPjwvdXgtcGFnZS1oZWFkZXItaWNvbi1tZW51PlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLXNlY29uZGFyeVwiIFtuZ0NsYXNzXT1cInNlY29uZGFyeU5hdmlnYXRpb25BbGlnbm1lbnRcIiByb2xlPVwibmF2aWdhdGlvblwiICpuZ0lmPVwic2Vjb25kYXJ5TmF2aWdhdGlvbiAmJiAoc2VsZWN0ZWRSb290JCB8IGFzeW5jKVwiPlxuICAgIDx1bCBjbGFzcz1cIm5hdiBuYXYtdGFic1wiIHJvbGU9XCJ0YWJsaXN0XCIgYXJpYS1sYWJlbD1cIlNlY29uZGFyeSBOYXZpZ2F0aW9uXCIgKm5nSWY9XCIoc2VsZWN0ZWRSb290JCB8IGFzeW5jKT8uY2hpbGRyZW47IGxldCBjaGlsZHJlblwiPlxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGNoaWxkIG9mIGNoaWxkcmVuXCJcbiAgICAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwiY2hpbGQuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgcm9sZT1cIm5vbmVcIlxuICAgICAgICAgICAgW3V4UGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtXT1cImNoaWxkXCI+XG5cbiAgICAgICAgICAgIDxhIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiY2hpbGQuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInNlbGVjdChjaGlsZClcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cInNlbGVjdChjaGlsZClcIj57eyBjaGlsZC50aXRsZSB9fTwvYT5cblxuICAgICAgICA8L2xpPlxuICAgIDwvdWw+XG48L2Rpdj5gLFxuICAgIHByb3ZpZGVyczogWyBQYWdlSGVhZGVyU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgbG9nbzogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGFsaWdubWVudDogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInID0gJ2NlbnRlcic7XG4gICAgQElucHV0KCkgY29uZGVuc2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaWNvbk1lbnVzOiBQYWdlSGVhZGVySWNvbk1lbnVbXTtcbiAgICBASW5wdXQoKSBiYWNrVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2Vjb25kYXJ5TmF2aWdhdGlvbkFsaWdubWVudDogc3RyaW5nID0gJ2NlbnRlcic7XG5cbiAgICBASW5wdXQoKSBzZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdDtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzZXQgaXRlbXMoaXRlbXM6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbVtdKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNldEl0ZW1zKGl0ZW1zKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNldFNlY29uZGFyeU5hdmlnYXRpb24oZW5hYmxlZCk7XG4gICAgfVxuXG4gICAgZ2V0IHNlY29uZGFyeU5hdmlnYXRpb24oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnkkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgQElucHV0KCkgc2V0IGNydW1icyhjcnVtYnM6IEJyZWFkY3J1bWJbXSkge1xuICAgICAgICB0aGlzLl9jcnVtYnMgPSBjcnVtYnM7XG4gICAgfVxuXG4gICAgZ2V0IGNydW1icygpOiBCcmVhZGNydW1iW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kZW5zZWQgPyBbLi4udGhpcy5fY3J1bWJzLCB7IHRpdGxlOiB0aGlzLmhlYWRlciB9XSA6IHRoaXMuX2NydW1icztcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmYW1pbHlCYWNrZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZmFtaWx5QmFja2dyb3VuZCA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKGNvbG9yKTtcbiAgICB9XG5cbiAgICBnZXQgZmFtaWx5QmFja2dyb3VuZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFtaWx5QmFja2dyb3VuZDtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmYW1pbHlGb3JlZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZmFtaWx5Rm9yZWdyb3VuZCA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKGNvbG9yKTtcbiAgICB9XG5cbiAgICBnZXQgZmFtaWx5Rm9yZWdyb3VuZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFtaWx5Rm9yZWdyb3VuZDtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgYmFja0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBjdXN0b21NZW51czogUXVlcnlMaXN0PFRlbXBsYXRlUmVmPGFueT4+O1xuXG4gICAgc2VsZWN0ZWQkOiBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJDtcbiAgICBzZWxlY3RlZFJvb3QkOiBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkUm9vdCQ7XG5cbiAgICBwcml2YXRlIF9jcnVtYnM6IEJyZWFkY3J1bWJbXSA9IFtdO1xuICAgIHByaXZhdGUgX2ZhbWlseUJhY2tncm91bmQ6IHN0cmluZztcbiAgICBwcml2YXRlIF9mYW1pbHlGb3JlZ3JvdW5kOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb2xvclNlcnZpY2U6IENvbG9yU2VydmljZSwgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7IH1cblxuICAgIGdvQmFjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iYWNrQ2xpY2suZW1pdCgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3QoaXRlbSk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnNEcm9wZG93bk1vZHVsZSB9IGZyb20gJ25neC1ib290c3RyYXAvZHJvcGRvd24nO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9pbmRleCc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2VNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5pbXBvcnQgeyBCcmVhZGNydW1ic01vZHVsZSB9IGZyb20gJy4uL2JyZWFkY3J1bWJzL2luZGV4JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlIH0gZnJvbSAnLi9jdXN0b20tbWVudS9jdXN0b20tbWVudS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51Q29tcG9uZW50IH0gZnJvbSAnLi9pY29uLW1lbnUvaWNvbi1tZW51LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0vbmF2aWdhdGlvbi1zZWNvbmRhcnktaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vcGFnZS1oZWFkZXIuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBCcmVhZGNydW1ic01vZHVsZSxcbiAgICAgICAgQ29sb3JTZXJ2aWNlTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGUsXG4gICAgICAgIE1lbnVOYXZpZ2F0aW9uTW9kdWxlLFxuICAgICAgICBCc0Ryb3Bkb3duTW9kdWxlLmZvclJvb3QoKVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJJY29uTWVudUNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmUsXG4gICAgICAgIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW1EaXJlY3RpdmVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXByb2dyZXNzLWJhcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiIWluZGV0ZXJtaW5hdGVcIiBjbGFzcz1cInByb2dyZXNzYmFyLXRyYWNrXCIgW3N0eWxlLndpZHRoLiVdPVwiKHZhbHVlIC8gbWF4KSAqIDEwMFwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiYmFyQ29sb3JcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cbjxkaXYgKm5nSWY9XCJpbmRldGVybWluYXRlXCIgY2xhc3M9XCJwcm9ncmVzc2Jhci10cmFjayBpbmRldGVybWluYXRlXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJiYXJDb2xvclwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NCYXJDb21wb25lbnQge1xuICAgIEBJbnB1dCgpIHZhbHVlOiBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIG1heDogbnVtYmVyID0gMTAwO1xuICAgIEBJbnB1dCgpIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSB0cmFja0NvbG9yOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYmFyQ29sb3I6IHN0cmluZztcbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBQcm9ncmVzc0JhckNvbXBvbmVudCB9IGZyb20gJy4vcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtQcm9ncmVzc0JhckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbUHJvZ3Jlc3NCYXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFJBRElPQlVUVE9OX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5sZXQgdW5pcXVlUmFkaW9JZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcmFkaW8tYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZTogYDxsYWJlbCBbYXR0ci5mb3JdPVwiaW5wdXRJZFwiIGNsYXNzPVwidXgtcmFkaW8tYnV0dG9uXCJcbiAgICAgICBbY2xhc3MudXgtcmFkaW8tYnV0dG9uLWNoZWNrZWRdPVwidmFsdWUgPT09IG9wdGlvblwiXG4gICAgICAgW2NsYXNzLnV4LXJhZGlvLWJ1dHRvbi1zaW1wbGlmaWVkXT1cInNpbXBsaWZpZWRcIlxuICAgICAgIFtjbGFzcy51eC1yYWRpby1idXR0b24tZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgIFtjbGFzcy51eC1yYWRpby1idXR0b24tZm9jdXNlZF09XCJmb2N1c2VkXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtcmFkaW8tYnV0dG9uLWNvbnRhaW5lclwiPlxuICAgICAgICA8aW5wdXQgY2xhc3M9XCJ1eC1yYWRpby1idXR0b24taW5wdXRcIlxuICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgIFtpZF09XCJpbnB1dElkXCJcbiAgICAgICAgICAgIFtjaGVja2VkXT1cInZhbHVlID09PSBvcHRpb25cIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJpbmRleCB8fCB2YWx1ZSA9PT0gb3B0aW9uID8gMCA6IC0xXCJcbiAgICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICBbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJhcmlhTGFiZWxcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiYXJpYURlc2NyaWJlZGJ5XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJ2YWx1ZSA9PT0gb3B0aW9uXCJcbiAgICAgICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgICAgICAoYmx1cik9XCJmb2N1c2VkID0gZmFsc2VcIlxuICAgICAgICAgICAgKGNoYW5nZSk9XCJ0b2dnbGUoKVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCI+XG4gICAgPC9kaXY+XG5cbiAgICA8c3BhbiBjbGFzcz1cInV4LXJhZGlvLWJ1dHRvbi1sYWJlbFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9zcGFuPlxuXG48L2xhYmVsPmAsXG4gICAgcHJvdmlkZXJzOiBbUkFESU9CVVRUT05fVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfcmFkaW9CdXR0b25JZDogc3RyaW5nID0gYHV4LXJhZGlvLWJ1dHRvbi0keysrdW5pcXVlUmFkaW9JZH1gO1xuXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZyA9IHRoaXMuX3JhZGlvQnV0dG9uSWQ7XG4gICAgQElucHV0KCkgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgICBASW5wdXQoKSByZXF1aXJlZDogYm9vbGVhbjtcbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBjbGlja2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgc2ltcGxpZmllZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIG9wdGlvbjogYW55O1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nID0gbnVsbDtcbiAgICBASW5wdXQoJ2FyaWEtZGVzY3JpYmVkYnknKSBhcmlhRGVzY3JpYmVkYnk6IHN0cmluZyA9IG51bGw7XG5cbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIGludm9rZSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTsgICAgICAgIFxuICAgIH1cblxuICAgIGdldCBpbnB1dElkKCk6IHN0cmluZyB7IFxuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZCB8fCB0aGlzLl9yYWRpb0J1dHRvbklkfS1pbnB1dGA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmFsdWU6IGFueSA9IGZhbHNlO1xuXG4gICAgZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gKCkgPT4geyB9O1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2dnbGUgdGhlIGNoZWNrZWQgc3RhdGVcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9uO1xuXG4gICAgICAgIC8vIGNhbGwgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9ucyByZXF1aXJlZCB0byB1cGRhdGUgbmctbW9kZWxcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IFJhZGlvQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9yYWRpb2J1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtGb3Jtc01vZHVsZV0sXG4gICAgZXhwb3J0czogW1JhZGlvQnV0dG9uQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtSYWRpb0J1dHRvbkNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgUmFkaW9CdXR0b25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbXBvbmVudC1kZWZpbml0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyUXVlcnkgfSBmcm9tICcuL2ludGVyZmFjZXMvcXVlcnkuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIHtcblxuICBxdWVyeTogU2VhcmNoQnVpbGRlclF1ZXJ5ID0ge307XG4gIHF1ZXJ5Q2hhbmdlOiBTdWJqZWN0PFNlYXJjaEJ1aWxkZXJRdWVyeT4gPSBuZXcgU3ViamVjdDxTZWFyY2hCdWlsZGVyUXVlcnk+KCk7XG4gIHZhbGlkYXRpb25DaGFuZ2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odHJ1ZSk7XG5cbiAgcHJpdmF0ZSBfY29tcG9uZW50SWQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX2NvbXBvbmVudHM6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBfdmFsaWRhdGlvbjogeyBba2V5OiBudW1iZXJdOiBib29sZWFuIH0gPSB7fTtcblxuICAvKipcbiAgICogQWRkIGEgY29tcG9uZW50IHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGNvbXBvbmVudHNcbiAgICovXG4gIHJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudDogU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb24pOiB2b2lkIHtcblxuICAgIC8vIGVuc3VyZSB0aGVyZSBhcmUgbm8gY29tcG9uZW50cyB3aXRoIGEgbWF0Y2hpbmcgbmFtZVxuICAgIGlmICh0aGlzLl9jb21wb25lbnRzLmZpbmQoY21wID0+IGNtcC5uYW1lID09PSBjb21wb25lbnQubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VhcmNoIGJ1aWxkZXIgY29tcG9uZW50cyBtdXN0IGhhdmUgYSB1bmlxdWUgbmFtZS4gVGhlIG5hbWUgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiB1c2VkLmApO1xuICAgIH1cblxuICAgIC8vIGlmIHVuaXF1ZSB0aGVuIGFkZCB0aGUgY29tcG9uZW50IHRvIHRoZSBsaXN0XG4gICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQnVsayByZWdpc3RyYXRpb24gb2YgY29tcG9uZW50c1xuICAgKiAoSnVzdCBhIGhlbHBlciBtZXRob2QpXG4gICAqL1xuICByZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50czogU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb25bXSk6IHZvaWQge1xuICAgIGNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4gdGhpcy5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWdpc3RlcmVkIGNvbXBvbmVudCBjbGFzc1xuICAgKi9cbiAgZ2V0Q29tcG9uZW50KG5hbWU6IHN0cmluZyk6IGFueSB7XG5cbiAgICAvLyBmaW5kIHRoZSBjb21wb25lbnRcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9jb21wb25lbnRzLmZpbmQoY21wID0+IGNtcC5uYW1lID09PSBuYW1lKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hdGNoIHRocm93IGFuIGV4Y2VwdGlvblxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlYXJjaCBidWlsZCBjb21wb25lbnQgd2l0aCB0aGUgbmFtZSAke25hbWV9IGV4aXN0c2ApO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBjb25maWcgaXMgZGVmaW5lZCAtIGF0IGxlYXN0IHRvIGFuIGVtcHR5IG9iamVjdFxuICAgIGNvbXBvbmVudC5jb25maWcgPSBjb21wb25lbnQuY29uZmlnIHx8IHt9O1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIHNlYXJjaCBxdWVyeSBzdGF0ZVxuICAgKiBub3RlIHRoYXQgdGhlIHF1ZXJ5IHdpbGwgYmUgaW1tdXRhYmxlXG4gICAqL1xuICBzZXRRdWVyeShxdWVyeTogU2VhcmNoQnVpbGRlclF1ZXJ5KTogdm9pZCB7XG4gICAgdGhpcy5xdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgcXVlcnkgc3RhdGVcbiAgICovXG4gIGdldFF1ZXJ5KCk6IFNlYXJjaEJ1aWxkZXJRdWVyeSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgb2JzZXJ2YWJsZSB0byBpbmRpY2F0ZSB0aGUgcXVlcnkgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgcXVlcnlIYXNDaGFuZ2VkKCk6IHZvaWQge1xuICAgIHRoaXMucXVlcnlDaGFuZ2UubmV4dCh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgdmFsaWRhdGlvbiBzdGF0ZSBvZiB0aGUgcXVlcnlcbiAgICovXG4gIHNldFZhbGlkKGlkOiBudW1iZXIsIHZhbGlkOiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAvLyBzdG9yZSB0aGUgc3RhdGUgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50XG4gICAgdGhpcy5fdmFsaWRhdGlvbltpZF0gPSB2YWxpZDtcblxuICAgIC8vIGV2YWx1YXRlIHRoZSBlbnRpcmUgdmFsaWRhdGlvbiBzdGF0ZVxuICAgIHRoaXMudmFsaWRhdGlvbkNoYW5nZS5uZXh0KCFPYmplY3Qua2V5cyh0aGlzLl92YWxpZGF0aW9uKS5zb21lKGtleSA9PiAhdGhpcy5fdmFsaWRhdGlvbltrZXldKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggY29tcG9uZW50XG4gICAqL1xuICBnZW5lcmF0ZUNvbXBvbmVudElkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudElkKys7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ncm91cC1xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2Uge1xuXG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VhcmNoQnVpbGRlclNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlKSB7IH1cblxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgZ3JvdXAgYnkgZGVmaW5pbmcgYW4gaWRcbiAgICovXG4gIGluaXQoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIHN0b3JlIHRoZSBuYW1lIG9mIHRoZSBncm91cFxuICAgIHRoaXMuX2lkID0gaWQ7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGVudHJ5IGluIHRoZSBxdWVyeSBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdKSB7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VjdGlvblxuICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdID0gW107XG5cbiAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZXMgYWZ0ZXIgdGhlIGluaXRpYWwgc2V0dXBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlIYXNDaGFuZ2VkKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmaWVsZCBmcm9tIHRoZSBzZWFyY2ggYnVpbGRlciBxdWVyeVxuICAgKi9cbiAgcmVtb3ZlKGZpZWxkOiBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSk6IHZvaWQge1xuICAgIC8vIGdldCB0aGUgcXVlcnkgZm9yIHRoaXMgZ3JvdXBcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuZ2V0UXVlcnkoKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgZmllbGQgZnJvbSB0aGUgYXJyYXlcbiAgICBxdWVyeS5zcGxpY2UocXVlcnkuaW5kZXhPZihmaWVsZCksIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVlcnkgZm9yIHRoaXMgc3BlY2lmaWMgc2VhcmNoIGdyb3VwXG4gICAqL1xuICBnZXRRdWVyeSgpOiBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeVtdIHtcbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdID8gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdIDogW107XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3JvdXAtcXVlcnkuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLWJ1aWxkZXItZ3JvdXAnLFxuICB0ZW1wbGF0ZTogYDxoNCBjbGFzcz1cInNlYXJjaC1ncm91cC10aXRsZVwiPnt7IGhlYWRlciB9fTwvaDQ+XG5cbjxtYWluIGNsYXNzPVwic2VhcmNoLWdyb3VwLWNvbnRlbnRcIj5cblxuICA8c2VjdGlvbiBjbGFzcz1cInNlYXJjaC1ncm91cC1vcGVyYXRvciBzZWFyY2gtZ3JvdXAtb3BlcmF0b3Ite3sgb3BlcmF0b3IgfX1cIiBbY2xhc3MuaGlkZGVuLW9wZXJhdG9yXT1cInNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UuZ2V0UXVlcnkoKS5sZW5ndGggPCAyXCI+e3sgb3BlcmF0b3IgfX08L3NlY3Rpb24+XG5cbiAgPHNlY3Rpb24gY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbXNcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbS1jb250YWluZXJcIiAqbmdGb3I9XCJsZXQgZmllbGQgb2Ygc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZS5nZXRRdWVyeSgpXCI+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICp1eFNlYXJjaEJ1aWxkZXJPdXRsZXQ9XCJmaWVsZC50eXBlOyBjb250ZXh0OiBmaWVsZFwiPjwvbmctY29udGFpbmVyPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbS1yZW1vdmVcIiAoY2xpY2spPVwicmVtb3ZlRmllbGQoZmllbGQpXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWNsb3NlXCI+PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIFBsYWNlaG9sZGVyIEl0ZW0gLS0+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInNob3dQbGFjZWhvbGRlclwiPlxuXG4gICAgICA8IS0tIFRoZSBEZWZhdWx0IFBsYWNlaG9sZGVyIC0tPlxuICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaC1ncm91cC1pdGVtLWNvbnRhaW5lciBwbGFjZWhvbGRlci1pdGVtXCIgKm5nSWY9XCIhcGxhY2Vob2xkZXJcIj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbVwiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWxcIj5OZXcgZmllbGQ8L2xhYmVsPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gIFxuICAgICAgPC9kaXY+XG5cbiAgICAgIDwhLS0gQWxsb3cgYSBjdXN0b20gcGxhY2Vob2xkZXIgLS0+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInBsYWNlaG9sZGVyXCI+PC9uZy1jb250YWluZXI+XG5cbiAgICA8L25nLWNvbnRhaW5lcj5cblxuICA8L3NlY3Rpb24+XG5cbiAgPHNlY3Rpb24gY2xhc3M9XCJzZWFyY2gtYnVpbGRlci1ncm91cC1hZGQtZmllbGRcIiAoY2xpY2spPVwiYWRkLmVtaXQoJGV2ZW50KVwiPlxuXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWljb24gYnRuLWNpcmN1bGFyIGJ1dHRvbi1hY2NlbnRcIiBhcmlhLWxhYmVsPVwiQWRkIEZpZWxkXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1hZGRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG5cbiAgICA8c3BhbiBjbGFzcz1cInNlYXJjaC1idWlsZGVyLWdyb3VwLWFkZC1maWVsZC1sYWJlbFwiPnt7IGFkZFRleHQgfX08L3NwYW4+XG5cbiAgPC9zZWN0aW9uPlxuXG48L21haW4+XG5cbjxociBjbGFzcz1cInNlYXJjaC1idWlsZGVyLWdyb3VwLWRpdmlkZXJcIj5cbmAsXG4gIHByb3ZpZGVyczogW1NlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgaWQ6IHN0cmluZztcbiAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gIEBJbnB1dCgpIG9wZXJhdG9yOiBTZWFyY2hCdWlsZGVyR3JvdXBPcGVyYXRvciA9ICdhbmQnO1xuICBASW5wdXQoKSBhZGRUZXh0OiBzdHJpbmcgPSAnQWRkIGEgZmllbGQnO1xuICBASW5wdXQoKSBwbGFjZWhvbGRlcjogVGVtcGxhdGVSZWY8YW55PjtcbiAgQElucHV0KCkgc2hvd1BsYWNlaG9sZGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQE91dHB1dCgpIGFkZDogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuICBAT3V0cHV0KCkgcmVtb3ZlOiBFdmVudEVtaXR0ZXI8U2VhcmNoQnVpbGRlckdyb3VwUXVlcnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeT4oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZTogU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZSwgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlclNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlKSB7IH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgIC8vIGVuc3VyZSB3ZSBoYXZlIGEgbmFtZSBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoIGJ1aWxkZXIgZ3JvdXAgbXVzdCBoYXZlIGEgbmFtZSBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIHJlZ2lzdGVyIHRoZSBncm91cFxuICAgIHRoaXMuc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZS5pbml0KHRoaXMuaWQpO1xuICB9XG5cbiAgcmVtb3ZlRmllbGQoZmllbGQ6IFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5KTogdm9pZCB7XG4gICAgdGhpcy5zZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlLnJlbW92ZShmaWVsZCk7XG4gICAgdGhpcy5yZW1vdmUuZW1pdChmaWVsZCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2VhcmNoQnVpbGRlckdyb3VwT3BlcmF0b3IgPSAnYW5kJyB8ICdvcicgfCAnbm90JztcbiIsImltcG9ydCB7IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIElucHV0LCBPbkluaXQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2VhcmNoQnVpbGRlck91dGxldF0nXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgQElucHV0KCkgdXhTZWFyY2hCdWlsZGVyT3V0bGV0OiBzdHJpbmc7XG4gICAgQElucHV0KCkgdXhTZWFyY2hCdWlsZGVyT3V0bGV0Q29udGV4dDogYW55O1xuXG4gICAgcHJpdmF0ZSBfY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8YW55PjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcml2YXRlIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlclNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY2xhc3MgZnJvbSB0aGUgdHlwZVxuICAgICAgICBjb25zdCBjb21wb25lbnREZWZpbml0aW9uID0gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UuZ2V0Q29tcG9uZW50KHRoaXMudXhTZWFyY2hCdWlsZGVyT3V0bGV0KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbXBvbmVudCBmYWN0b3J5XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50RGVmaW5pdGlvbi5jb21wb25lbnQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZiA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnkpO1xuXG4gICAgICAgIC8vIGNvbWJpbmUgdGhlIHByZWRlZmluZWQgY29uZmlnIHdpdGggYW55IGR5bm1haWMgY29uZmlnXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbXBvbmVudERlZmluaXRpb24uY29uZmlnLCB0aGlzLnV4U2VhcmNoQnVpbGRlck91dGxldENvbnRleHQuY29uZmlnIHx8IHt9KTtcblxuICAgICAgICAvLyBzZXQgdGhlIGNvbnRleHQgYW5kIGNvbmZpZyBwcm9wZXJ0eSBvbiB0aGUgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZS5jb250ZXh0ID0gdGhpcy51eFNlYXJjaEJ1aWxkZXJPdXRsZXRDb250ZXh0O1xuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2UuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50Q29udGV4dCB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29tcG9uZW50LWNvbnRleHQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtYmFzZS1zZWFyY2gnLFxuICAgIHRlbXBsYXRlOiAnJ1xufSlcbmV4cG9ydCBjbGFzcyBCYXNlU2VhcmNoQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHR5cGU6IHN0cmluZztcbiAgICBjb25maWc6IGFueTtcbiAgICBjb250ZXh0OiBTZWFyY2hCdWlsZGVyQ29tcG9uZW50Q29udGV4dDtcblxuICAgIHByaXZhdGUgX2lkOiBudW1iZXIgPSB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5nZW5lcmF0ZUNvbXBvbmVudElkKCk7XG4gICAgcHJpdmF0ZSBfdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLmNvbnRleHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlIYXNDaGFuZ2VkKCk7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgaGFzIGJlZW4gc2V0IHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gICAgfVxuXG4gICAgc2V0IHZhbGlkKHZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkID0gdmFsaWQ7XG4gICAgICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnNldFZhbGlkKHRoaXMuX2lkLCB2YWxpZCk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZTogU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZVxuICAgICkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgd2UgY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW55IHJlcXVpcmVkIHZhbGlkYXRpb24gb24gdGhlIHZhbHVlXG4gICAgICovXG4gICAgdmFsaWRhdGUoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24gaGFzIGJlZW4gcHJvdmlkZWQgdGhlbiB1c2UgaXRcbiAgICAgICAgdGhpcy52YWxpZCA9IHRoaXMuY29uZmlnLnZhbGlkYXRpb24gPyB0aGlzLmNvbmZpZy52YWxpZGF0aW9uKHRoaXMsIHRoaXMudmFsdWUpIDogdHJ1ZTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIHtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICB2YWxpZGF0aW9uPzogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLXRleHQnLFxuICB0ZW1wbGF0ZTogYDxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWxcIiAqbmdJZj1cImxhYmVsXCI+e3sgbGFiZWwgfX08L2xhYmVsPlxuPGlucHV0IFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiIFsobmdNb2RlbCldPVwidmFsdWVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiPmBcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoVGV4dENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICd0ZXh0JztcblxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgJ0VudGVyIHRleHQnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoVGV4dENvbmZpZyBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJhc2VTZWFyY2hDb21wb25lbnQsIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgfSBmcm9tICcuLi9iYXNlLXNlYXJjaC5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtZGF0ZScsXG4gIHRlbXBsYXRlOiBgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbFwiICpuZ0lmPVwibGFiZWxcIj57eyBsYWJlbCB9fTwvbGFiZWw+XG5cbjxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBkYXRlIG0tbmlsXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiIHRhYmluZGV4PVwiMVwiIChjbGljayk9XCJwb3BvdmVyLnNob3coKVwiPlxuICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1jYWxlbmRhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICA8L3NwYW4+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgI3BvcG92ZXI9XCJ1eC1wb3BvdmVyXCIgW25nTW9kZWxdPVwidmFsdWUgfCBkYXRlOidkZCBNTU1NIHl5eXknXCIgW3V4UG9wb3Zlcl09XCJwb3BvdmVyVGVtcGxhdGVcIlxuICAgICAgICBwbGFjZW1lbnQ9XCJib3R0b21cIiBwb3BvdmVyQ2xhc3M9XCJkYXRlLXRpbWUtcGlja2VyLXBvcG92ZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGFyaWEtbGFiZWw9XCJTZWxlY3RlZCBkYXRlXCIgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCI+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNwb3BvdmVyVGVtcGxhdGU+XG4gICAgPHV4LWRhdGUtdGltZS1waWNrZXIgWyhkYXRlKV09XCJ2YWx1ZVwiIFtzaG93VGltZV09XCJmYWxzZVwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlcj5cbjwvbmctdGVtcGxhdGU+YFxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hEYXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZVNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgdHlwZTogc3RyaW5nID0gJ2RhdGUnO1xuXG4gIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5sYWJlbDtcbiAgfVxuXG4gIGdldCBwbGFjZWhvbGRlcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciB8fCAnRW50ZXIgZGF0ZSc7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgIC8vIGJ5IGRlZmF1bHQgc2V0IHRvIHRoZSBjdXJyZW50IGRhdGUgaWYgbm90IHNwZWNpZmllZFxuICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoRGF0ZUNvbmZpZyBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtZGF0ZS1yYW5nZScsXG4gICAgdGVtcGxhdGU6IGA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCIgKm5nSWY9XCJsYWJlbFwiPnt7IGxhYmVsIH19PC9sYWJlbD5cblxuPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0taW5saW5lXCIgW2NsYXNzLmhhcy1lcnJvcl09XCIhdmFsaWRcIj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcC1yLW1kXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbCBtLXIteHNcIj57eyBmcm9tTGFiZWwgfX08L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGRhdGUgbS1uaWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBwLXIteHNcIiB0YWJpbmRleD1cIjFcIiAoY2xpY2spPVwiZnJvbVBvcG92ZXIuc2hvdygpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1jYWxlbmRhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiAjZnJvbVBvcG92ZXI9XCJ1eC1wb3BvdmVyXCIgW25nTW9kZWxdPVwiZnJvbSB8IGRhdGU6J2RkIE1NTU0geXl5eSdcIiBbdXhQb3BvdmVyXT1cImZyb21Qb3BvdmVyVGVtcGxhdGVcIiBwbGFjZW1lbnQ9XCJib3R0b21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3ZlckNsYXNzPVwiZGF0ZS10aW1lLXBpY2tlci1wb3BvdmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBhcmlhLWxhYmVsPVwiU2VsZWN0ZWQgZGF0ZVwiIFtwbGFjZWhvbGRlcl09XCJmcm9tUGxhY2Vob2xkZXJcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBwLXIteHNcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsIG0tci14c1wiPnt7IHRvTGFiZWwgfX08L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGRhdGUgbS1uaWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiIHRhYmluZGV4PVwiMVwiIChjbGljayk9XCJ0b1BvcG92ZXIuc2hvdygpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1jYWxlbmRhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiAjdG9Qb3BvdmVyPVwidXgtcG9wb3ZlclwiIFtuZ01vZGVsXT1cInRvIHwgZGF0ZTonZGQgTU1NTSB5eXl5J1wiIFt1eFBvcG92ZXJdPVwidG9Qb3BvdmVyVGVtcGxhdGVcIiBwbGFjZW1lbnQ9XCJib3R0b21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3ZlckNsYXNzPVwiZGF0ZS10aW1lLXBpY2tlci1wb3BvdmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBhcmlhLWxhYmVsPVwiU2VsZWN0ZWQgZGF0ZVwiIFtwbGFjZWhvbGRlcl09XCJ0b1BsYWNlaG9sZGVyXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2Zyb21Qb3BvdmVyVGVtcGxhdGU+XG4gICAgPHV4LWRhdGUtdGltZS1waWNrZXIgWyhkYXRlKV09XCJmcm9tXCIgW3Nob3dUaW1lXT1cImZhbHNlXCI+PC91eC1kYXRlLXRpbWUtcGlja2VyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICN0b1BvcG92ZXJUZW1wbGF0ZT5cbiAgICA8dXgtZGF0ZS10aW1lLXBpY2tlciBbKGRhdGUpXT1cInRvXCIgW3Nob3dUaW1lXT1cImZhbHNlXCI+PC91eC1kYXRlLXRpbWUtcGlja2VyPlxuPC9uZy10ZW1wbGF0ZT5gXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaERhdGVSYW5nZUNvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gICAgdHlwZTogc3RyaW5nID0gJ2RhdGUtcmFuZ2UnO1xuXG4gICAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sYWJlbDtcbiAgICB9XG5cbiAgICBnZXQgZnJvbSgpIHtcblxuICAgICAgICAvLyBpZiB2YWx1ZSBkb2VzIG5vdCBleGlzdCB0aGUgc2V0IGl0XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSB8fCAhdGhpcy52YWx1ZS5mcm9tKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGZyb20gdmFsdWUgaXMgYSBkYXRlIG9iamVjdFxuICAgICAgICBpZiAodGhpcy52YWx1ZS5mcm9tIGluc3RhbmNlb2YgRGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuZnJvbSA9IG5ldyBEYXRlKHRoaXMudmFsdWUuZnJvbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5mcm9tO1xuICAgIH1cblxuICAgIHNldCBmcm9tKGZyb21WYWx1ZTogYW55KSB7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYmplY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZhbHVlKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgZnJvbSB2YWx1ZSBpcyBhIGRhdGVcbiAgICAgICAgaWYgKGZyb21WYWx1ZSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmcm9tVmFsdWUgPSBuZXcgRGF0ZShmcm9tVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBsYXRlc3QgdmFsdWVcbiAgICAgICAgdmFsdWUuZnJvbSA9IGZyb21WYWx1ZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpbW11dGFiaWxpdHlcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0bygpIHtcblxuICAgICAgICAvLyBpZiB2YWx1ZSBkb2VzIG5vdCBleGlzdCB0aGUgc2V0IGl0XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSB8fCAhdGhpcy52YWx1ZS50bykge1xuICAgICAgICAgICAgdGhpcy50byA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdG8gdmFsdWUgaXMgYSBkYXRlIG9iamVjdFxuICAgICAgICBpZiAodGhpcy52YWx1ZS50byBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnRvID0gbmV3IERhdGUodGhpcy52YWx1ZS50byk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50bztcbiAgICB9XG5cbiAgICBzZXQgdG8odG9WYWx1ZTogYW55KSB7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYmplY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZhbHVlKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdG8gdmFsdWUgaXMgYSBkYXRlXG4gICAgICAgIGlmICh0b1ZhbHVlIGluc3RhbmNlb2YgRGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvVmFsdWUgPSBuZXcgRGF0ZSh0b1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICAgIHZhbHVlLnRvID0gdG9WYWx1ZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpbW11dGFiaWxpdHlcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBmcm9tTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmZyb21MYWJlbCB8fCAnRnJvbSc7XG4gICAgfVxuXG4gICAgZ2V0IHRvTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnRvTGFiZWwgfHwgJ1RvJztcbiAgICB9XG5cbiAgICBnZXQgZnJvbVBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5mcm9tUGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgZ2V0IHRvUGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnRvUGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgdmFsaWRhdGlvblxuICAgICAqL1xuICAgIHZhbGlkYXRlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgY29uZmlnIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci52YWxpZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGNvcGllcyBvZiB0aGUgZGF0ZXMgc28gd2UgY2FuIG1vZGlmeSB0aW1lIHZhbHVlICh0byBpZ25vcmUgaXQpXG4gICAgICAgIGNvbnN0IGZyb20gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLmZyb20pO1xuICAgICAgICBjb25zdCB0byA9IG5ldyBEYXRlKHRoaXMudmFsdWUudG8pO1xuXG4gICAgICAgIC8vIHNldCB0aGUgdGltZSB0byB0aGUgc2FtZSBzbyB3ZSBkb250IGNvbXBhcmUgaXRcbiAgICAgICAgZnJvbS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgdG8uc2V0SG91cnMoMCwgMCwgMCwgMCk7XG5cbiAgICAgICAgLy8gdmFsaWQgaWYgdGhlIGZyb20gZGF0ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRvIGRhdGVcbiAgICAgICAgdGhpcy52YWxpZCA9IGZyb20gPD0gdG87XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaERhdGVSYW5nZUNvbmZpZyB7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgZnJvbUxhYmVsPzogc3RyaW5nO1xuICAgIHRvTGFiZWw/OiBzdHJpbmc7XG4gICAgZnJvbVBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIHRvUGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgdmFsaWRhdGlvbjogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vaW5kZXgnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtc2VsZWN0JyxcbiAgdGVtcGxhdGU6IGA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCIgKm5nSWY9XCJsYWJlbFwiPnt7IGxhYmVsIH19PC9sYWJlbD5cblxuPHV4LXNlbGVjdCBbKHZhbHVlKV09XCJ2YWx1ZVwiIFxuICAgICAgICAgICBbb3B0aW9uc109XCJvcHRpb25zXCIgXG4gICAgICAgICAgIFttdWx0aXBsZV09XCJtdWx0aXBsZVwiIFxuICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIiBcbiAgICAgICAgICAgW2Ryb3BEaXJlY3Rpb25dPVwiZHJvcERpcmVjdGlvblwiXG4gICAgICAgICAgIFtwYWdlU2l6ZV09XCJwYWdlU2l6ZVwiXG4gICAgICAgICAgIFthbGxvd051bGxdPVwiYWxsb3dOdWxsXCJcbiAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgW21heEhlaWdodF09XCJtYXhIZWlnaHRcIlxuICAgICAgICAgICBba2V5XT1cImNvbmZpZy5rZXlcIlxuICAgICAgICAgICBbZGlzcGxheV09XCJjb25maWcuZGlzcGxheVwiXG4gICAgICAgICAgIFtsb2FkaW5nVGVtcGxhdGVdPVwiY29uZmlnLmxvYWRpbmdUZW1wbGF0ZVwiXG4gICAgICAgICAgIFtvcHRpb25UZW1wbGF0ZV09XCJjb25maWcub3B0aW9uVGVtcGxhdGVcIlxuICAgICAgICAgICBbbm9PcHRpb25zVGVtcGxhdGVdPVwiY29uZmlnLm5vT3B0aW9uc1RlbXBsYXRlXCI+XG48L3V4LXNlbGVjdD5gXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFNlbGVjdENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICdzZWxlY3QnO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxhYmVsO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm9wdGlvbnMgfHwgW107XG4gIH1cblxuICBnZXQgbXVsdGlwbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm11bHRpcGxlIHx8IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICdTZWxlY3QgaXRlbSc7XG4gIH1cblxuICBnZXQgZHJvcERpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kcm9wRGlyZWN0aW9uIHx8ICdkb3duJztcbiAgfVxuXG4gIGdldCBhbGxvd051bGwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmFsbG93TnVsbCB8fCBmYWxzZTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGlzYWJsZWQgfHwgZmFsc2U7XG4gIH1cblxuICBnZXQgbWF4SGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heEhlaWdodCB8fCAnMjUwcHgnO1xuICB9XG5cbiAgZ2V0IHBhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBhZ2VTaXplIHx8IDIwO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoU2VsZWN0Q29uZmlnIGV4dGVuZHMgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB7XG4gIG9wdGlvbnM/OiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xuICBtdWx0aXBsZT86IGJvb2xlYW47XG4gIGRyb3BEaXJlY3Rpb24/OiAndXAnIHwgJ2Rvd24nO1xuICBhbGxvd051bGw/OiBib29sZWFuO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIG1heEhlaWdodD86IHN0cmluZztcbiAgcGFnZVNpemU/OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb21wb25lbnQtZGVmaW5pdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclF1ZXJ5IH0gZnJvbSAnLi9pbnRlcmZhY2VzL3F1ZXJ5LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXNlYXJjaC1idWlsZGVyJyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgcHJvdmlkZXJzOiBbU2VhcmNoQnVpbGRlclNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIEBJbnB1dCgpXG4gIHNldCBjb21wb25lbnRzKGNvbXBvbmVudHM6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uW10pIHtcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5yZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50cyk7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgcXVlcnkodmFsdWU6IFNlYXJjaEJ1aWxkZXJRdWVyeSkge1xuICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnNldFF1ZXJ5KHZhbHVlKTtcbiAgfVxuXG4gIGdldCBxdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UuZ2V0UXVlcnkoKTtcbiAgfVxuXG4gIEBPdXRwdXQoKSBxdWVyeUNoYW5nZTogRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJRdWVyeT4gPSBuZXcgRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJRdWVyeT4oKTtcbiAgQE91dHB1dCgpIHZhbGlkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIHByaXZhdGUgX3F1ZXJ5U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX3ZhbGlkU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRoZSBkZWZhdWx0IHNlYXJjaCBidWlsZGVyIGNvbXBvbmVudHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSkge1xuXG4gICAgLy8gd2F0Y2ggZm9yIGFueSBxdWVyeSBjaGFuZ2VzXG4gICAgdGhpcy5fcXVlcnlTdWJzY3JpcHRpb24gPSBfc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlDaGFuZ2Uuc3Vic2NyaWJlKHF1ZXJ5ID0+IHRoaXMucXVlcnlDaGFuZ2UuZW1pdChxdWVyeSkpO1xuXG4gICAgLy8gd2F0Y2ggZm9yIGFueSBjaGFuZ2VzIHRvIHRoZSB2YWxpZGF0aW9uXG4gICAgdGhpcy5fdmFsaWRTdWJzY3JpcHRpb24gPSBfc2VhcmNoQnVpbGRlclNlcnZpY2UudmFsaWRhdGlvbkNoYW5nZS5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh2YWxpZCA9PiB0aGlzLnZhbGlkLmVtaXQodmFsaWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IHN1YnNjcmlwdGlvbnMgYW5kIGNsZWFudXBcbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fdmFsaWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcywgU3RhdGljUHJvdmlkZXIsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEtleVNlcnZpY2UsIFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcclxuXHJcbmxldCB1bmlxdWVJZCA9IDA7XHJcblxyXG5leHBvcnQgY29uc3QgU0VMRUNUX1ZBTFVFX0FDQ0VTU09SOiBTdGF0aWNQcm92aWRlciA9IHtcclxuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2VsZWN0Q29tcG9uZW50KSxcclxuICAgIG11bHRpOiB0cnVlXHJcbn07XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtc2VsZWN0JyxcclxuICAgIHRlbXBsYXRlOiBgPHV4LXRhZy1pbnB1dCAqbmdJZj1cIm11bHRpcGxlXCJcclxuICAgIFtpZF09XCJpZCArICctaW5wdXQnXCJcclxuICAgIFsodGFncyldPVwidmFsdWVcIlxyXG4gICAgWyhpbnB1dCldPVwiaW5wdXRcIlxyXG4gICAgW2FkZE9uUGFzdGVdPVwiZmFsc2VcIlxyXG4gICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcclxuICAgIFtkaXNwbGF5XT1cImRpc3BsYXlcIlxyXG4gICAgW2ZyZWVJbnB1dF09XCJmYWxzZVwiXHJcbiAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxyXG4gICAgW3Nob3dUeXBlYWhlYWRPbkNsaWNrXT1cInRydWVcIj5cclxuXHJcbiAgICA8dXgtdHlwZWFoZWFkICNtdWx0aXBsZVR5cGVhaGVhZFxyXG4gICAgICAgIFtpZF09XCJpZCArICctdHlwZWFoZWFkJ1wiXHJcbiAgICAgICAgW29wdGlvbnNdPVwib3B0aW9uc1wiXHJcbiAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXIkIHwgYXN5bmNcIlxyXG4gICAgICAgIFsob3BlbildPVwiZHJvcGRvd25PcGVuXCJcclxuICAgICAgICBbZGlzcGxheV09XCJkaXNwbGF5XCJcclxuICAgICAgICBba2V5XT1cImtleVwiXHJcbiAgICAgICAgW2Rpc2FibGVkT3B0aW9uc109XCJ2YWx1ZVwiXHJcbiAgICAgICAgW2Ryb3BEaXJlY3Rpb25dPVwiZHJvcERpcmVjdGlvblwiXHJcbiAgICAgICAgW21heEhlaWdodF09XCJtYXhIZWlnaHRcIlxyXG4gICAgICAgIFttdWx0aXNlbGVjdGFibGVdPVwidHJ1ZVwiXHJcbiAgICAgICAgW3BhZ2VTaXplXT1cInBhZ2VTaXplXCJcclxuICAgICAgICBbc2VsZWN0Rmlyc3RdPVwidHJ1ZVwiXHJcbiAgICAgICAgW2xvYWRpbmdUZW1wbGF0ZV09XCJsb2FkaW5nVGVtcGxhdGVcIlxyXG4gICAgICAgIFtvcHRpb25UZW1wbGF0ZV09XCJvcHRpb25UZW1wbGF0ZVwiXHJcbiAgICAgICAgW25vT3B0aW9uc1RlbXBsYXRlXT1cIm5vT3B0aW9uc1RlbXBsYXRlXCI+XHJcbiAgICA8L3V4LXR5cGVhaGVhZD5cclxuXHJcbjwvdXgtdGFnLWlucHV0PlxyXG5cclxuPGRpdiAqbmdJZj1cIiFtdWx0aXBsZVwiXHJcbiAgICBjbGFzcz1cImlubmVyLWFkZG9uIHJpZ2h0LWFkZG9uXCJcclxuICAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXHJcbiAgICByb2xlPVwiY29tYm9ib3hcIlxyXG4gICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJkcm9wZG93bk9wZW5cIlxyXG4gICAgYXJpYS1oYXNwb3B1cD1cImxpc3Rib3hcIj5cclxuXHJcbiAgICA8aSBjbGFzcz1cImhwZS1pY29uXCJcclxuICAgICAgICBbY2xhc3MuaHBlLWRvd25dPVwiZHJvcERpcmVjdGlvbiA9PT0gJ2Rvd24nXCJcclxuICAgICAgICBbY2xhc3MuaHBlLXVwXT1cImRyb3BEaXJlY3Rpb24gPT09ICd1cCdcIj48L2k+XHJcblxyXG4gICAgPGlucHV0ICNzaW5nbGVJbnB1dCB0eXBlPVwidGV4dFwiIFthdHRyLmlkXT1cImlkICsgJy1pbnB1dCdcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiXHJcbiAgICAgICAgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImhpZ2hsaWdodGVkRWxlbWVudD8uaWRcIlxyXG4gICAgICAgIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiXHJcbiAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCJzaW5nbGVUeXBlYWhlYWQuaWRcIlxyXG4gICAgICAgIGFyaWEtbXVsdGlsaW5lPVwiZmFsc2VcIlxyXG4gICAgICAgIFsobmdNb2RlbCldPVwiaW5wdXRcIlxyXG4gICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXHJcbiAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcclxuICAgICAgICAoY2xpY2spPVwiaW5wdXRDbGlja0hhbmRsZXIoJGV2ZW50KVwiXHJcbiAgICAgICAgKGJsdXIpPVwiaW5wdXRCbHVySGFuZGxlcigkZXZlbnQpXCJcclxuICAgICAgICAoa2V5ZG93bik9XCJpbnB1dEtleUhhbmRsZXIoJGV2ZW50KVwiPlxyXG5cclxuICAgIDx1eC10eXBlYWhlYWQgI3NpbmdsZVR5cGVhaGVhZFxyXG4gICAgICAgIFtpZF09XCJpZCArICctdHlwZWFoZWFkJ1wiXHJcbiAgICAgICAgW29wdGlvbnNdPVwib3B0aW9uc1wiXHJcbiAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXIkIHwgYXN5bmNcIlxyXG4gICAgICAgIFsob3BlbildPVwiZHJvcGRvd25PcGVuXCJcclxuICAgICAgICBbZGlzcGxheV09XCJkaXNwbGF5XCJcclxuICAgICAgICBba2V5XT1cImtleVwiXHJcbiAgICAgICAgW2Ryb3BEaXJlY3Rpb25dPVwiZHJvcERpcmVjdGlvblwiXHJcbiAgICAgICAgW21heEhlaWdodF09XCJtYXhIZWlnaHRcIlxyXG4gICAgICAgIFttdWx0aXNlbGVjdGFibGVdPVwiZmFsc2VcIlxyXG4gICAgICAgIFtvcGVuT25GaWx0ZXJDaGFuZ2VdPVwiZmFsc2VcIlxyXG4gICAgICAgIFtwYWdlU2l6ZV09XCJwYWdlU2l6ZVwiXHJcbiAgICAgICAgW3NlbGVjdEZpcnN0XT1cInRydWVcIlxyXG4gICAgICAgIFtsb2FkaW5nVGVtcGxhdGVdPVwibG9hZGluZ1RlbXBsYXRlXCJcclxuICAgICAgICBbb3B0aW9uVGVtcGxhdGVdPVwib3B0aW9uVGVtcGxhdGVcIlxyXG4gICAgICAgIFtub09wdGlvbnNUZW1wbGF0ZV09XCJub09wdGlvbnNUZW1wbGF0ZVwiXHJcbiAgICAgICAgKG9wdGlvblNlbGVjdGVkKT1cInNpbmdsZU9wdGlvblNlbGVjdGVkKCRldmVudClcIlxyXG4gICAgICAgIChoaWdobGlnaHRlZEVsZW1lbnRDaGFuZ2UpPVwiaGlnaGxpZ2h0ZWRFbGVtZW50ID0gJGV2ZW50XCI+XHJcbiAgICA8L3V4LXR5cGVhaGVhZD5cclxuXHJcbjwvZGl2PlxyXG5gLFxyXG4gICAgcHJvdmlkZXJzOiBbU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xyXG5cclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGlkOiBzdHJpbmcgPSBgdXgtc2VsZWN0LSR7Kyt1bmlxdWVJZH1gO1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UodmFsdWUpO1xyXG5cclxuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGFsbG93IG11bHRpcGxlIHNlbGVjdGlvbiB1cGRhdGUgdGhlIGlucHV0IHZhbHVlIChzdXBwb3J0aW5nIG5nTW9kZWwpXHJcbiAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdldERpc3BsYXkodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGlucHV0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dCQudmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgaW5wdXQodmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2lucHV0JC5uZXh0KHZhbHVlKTtcclxuICAgICAgICB0aGlzLmlucHV0Q2hhbmdlLmVtaXQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgZHJvcGRvd25PcGVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wZG93bk9wZW47XHJcbiAgICB9XHJcbiAgICBzZXQgZHJvcGRvd25PcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fZHJvcGRvd25PcGVuID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5kcm9wZG93bk9wZW5DaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KCkgb3B0aW9uczogYW55W10gfCBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcclxuICAgIEBJbnB1dCgpIGRpc3BsYXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkga2V5OiAob3B0aW9uOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGFsbG93TnVsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIGRyb3BEaXJlY3Rpb246ICd1cCcgfCAnZG93bicgPSAnZG93bic7XHJcbiAgICBASW5wdXQoKSBtYXhIZWlnaHQ6IHN0cmluZyA9ICcyNTBweCc7XHJcbiAgICBASW5wdXQoKSBtdWx0aXBsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgcGFnZVNpemU6IG51bWJlciA9IDIwO1xyXG4gICAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZztcclxuXHJcbiAgICBASW5wdXQoKSBsb2FkaW5nVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBub09wdGlvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIG9wdGlvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgQE91dHB1dCgpIGlucHV0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XHJcbiAgICBAT3V0cHV0KCkgZHJvcGRvd25PcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ3NpbmdsZUlucHV0Jykgc2luZ2xlSW5wdXQ6IEVsZW1lbnRSZWY7XHJcbiAgICBAVmlld0NoaWxkKCdtdWx0aXBsZVR5cGVhaGVhZCcpIG11bHRpcGxlVHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQ7XHJcbiAgICBAVmlld0NoaWxkKCdzaW5nbGVUeXBlYWhlYWQnKSBzaW5nbGVUeXBlYWhlYWQ6IFR5cGVhaGVhZENvbXBvbmVudDtcclxuXHJcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gICAgZmlsdGVyJDogT2JzZXJ2YWJsZTxzdHJpbmc+O1xyXG4gICAgcHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4geyB9O1xyXG5cclxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnk7XHJcbiAgICBwcml2YXRlIF9pbnB1dCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4oJycpO1xyXG4gICAgcHJpdmF0ZSBfZHJvcGRvd25PcGVuOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55LFxyXG4gICAgICAgIHByaXZhdGUgX3R5cGVhaGVhZEtleVNlcnZpY2U6IFR5cGVhaGVhZEtleVNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG5cclxuICAgICAgICAvLyBDaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxyXG4gICAgICAgIGNvbnN0IG9uSW5wdXQgPSB0aGlzLl9pbnB1dCQucGlwZShcclxuICAgICAgICAgICAgZmlsdGVyKHZhbHVlID0+IHRoaXMuYWxsb3dOdWxsKSxcclxuICAgICAgICAgICAgZmlsdGVyKHZhbHVlID0+ICF0aGlzLm11bHRpcGxlICYmIHZhbHVlICE9PSB0aGlzLmdldERpc3BsYXkodGhpcy52YWx1ZSkpXHJcbiAgICAgICAgKS5zdWJzY3JpYmUodmFsdWUgPT4gdGhpcy52YWx1ZSA9IG51bGwpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdXAgZmlsdGVyIGZyb20gaW5wdXRcclxuICAgICAgICB0aGlzLmZpbHRlciQgPSB0aGlzLl9pbnB1dCQucGlwZShcclxuICAgICAgICAgICAgbWFwKGlucHV0ID0+ICF0aGlzLm11bHRpcGxlICYmIGlucHV0ID09PSB0aGlzLmdldERpc3BsYXkodGhpcy52YWx1ZSkgPyAnJyA6IGlucHV0KSxcclxuICAgICAgICAgICAgZGVib3VuY2VUaW1lKDIwMClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBPcGVuIHRoZSBkcm9wZG93biB3aGVuIGZpbHRlciBpcyBub25lbXB0eS5cclxuICAgICAgICBjb25zdCBvbkZpbHRlciA9IHRoaXMuZmlsdGVyJC5waXBlKGZpbHRlcih2YWx1ZSA9PiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuZHJvcGRvd25PcGVuID0gdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBzdWJzY3JpcHRpb25zXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChvbklucHV0KTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKG9uRmlsdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMubXVsdGlwbGUgJiYgIWNoYW5nZXMubXVsdGlwbGUuZmlyc3RDaGFuZ2UgJiYgY2hhbmdlcy5tdWx0aXBsZS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMubXVsdGlwbGUucHJldmlvdXNWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSB0aGlzLl92YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZSA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHsgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Q2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RJbnB1dFRleHQoKTtcclxuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRCbHVySGFuZGxlcihldmVudDogRXZlbnQpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgYSBjbGljayBvbiB0aGUgdHlwZWFoZWFkIGlzIGluIHByb2dyZXNzLCBqdXN0IHJlZm9jdXMgdGhlIGlucHV0LlxyXG4gICAgICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIGFuIGlzc3VlIGluIElFIHdoZXJlIGNsaWNraW5nIGEgc2Nyb2xsYmFyIGRyb3BzIGZvY3VzLlxyXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVR5cGVhaGVhZCAmJiB0aGlzLnNpbmdsZVR5cGVhaGVhZC5jbGlja2luZykge1xyXG4gICAgICAgICAgICB0aGlzLnNpbmdsZUlucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xvc2UgZHJvcGRvd24gYW5kIHJlc2V0IHRleHQgaW5wdXQgaWYgZm9jdXMgaXMgbG9zdFxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyh0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdldERpc3BsYXkodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2V5IGhhbmRsZXIgZm9yIHNpbmdsZSBzZWxlY3Qgb25seS4gTXVsdGlwbGUgc2VsZWN0IGtleSBoYW5kbGluZyBpcyBpbiBUYWdJbnB1dENvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgaW5wdXRLZXlIYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFN0YW5kYXJkIGtleXMgZm9yIHR5cGVhaGVhZCAodXAvZG93bi9lc2MpXHJcbiAgICAgICAgdGhpcy5fdHlwZWFoZWFkS2V5U2VydmljZS5oYW5kbGVLZXkoZXZlbnQsIHRoaXMuc2luZ2xlVHlwZWFoZWFkKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcclxuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3Bkb3duT3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uIGFzIHRoZSB2YWx1ZSBhbmQgY2xvc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zaW5nbGVUeXBlYWhlYWQuaGlnaGxpZ2h0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0IGZpZWxkLiBJZiBkcm9wZG93biBpc24ndCBvcGVuIHRoZW4gcmVzZXQgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2luZ2xlT3B0aW9uU2VsZWN0ZWQoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lm9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZXZlbnQub3B0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheShvcHRpb246IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdzdHJpbmcnICYmIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSh0aGlzLmRpc3BsYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25bPHN0cmluZz50aGlzLmRpc3BsYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2VsZWN0SW5wdXRUZXh0KCkge1xyXG4gICAgICAgIHRoaXMuc2luZ2xlSW5wdXQubmF0aXZlRWxlbWVudC5zZWxlY3QoKTtcclxuICAgIH1cclxufSIsImV4cG9ydCBjbGFzcyBUYWdJbnB1dEV2ZW50IHtcblxuICAgIHByaXZhdGUgX2RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWc6IGFueSkge31cblxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZWZhdWx0UHJldmVudGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBRdWVyeUxpc3QsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTElEQVRPUlMsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBkZWxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzL2RlbGF5JztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEtleVNlcnZpY2UgfSBmcm9tICcuLi90eXBlYWhlYWQvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4uL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQnO1xyXG5pbXBvcnQgeyBUYWdJbnB1dEV2ZW50IH0gZnJvbSAnLi90YWctaW5wdXQtZXZlbnQnO1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbmNvbnN0IFRBR0lOUFVUX1ZBTFVFX0FDQ0VTU09SID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUYWdJbnB1dENvbXBvbmVudCksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5jb25zdCBUQUdJTlBVVF9WQUxJREFUT1IgPSB7XHJcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGFnSW5wdXRDb21wb25lbnQpLFxyXG4gICAgbXVsdGk6IHRydWVcclxufTtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10YWctaW5wdXQnLFxyXG4gICAgdGVtcGxhdGU6IGA8b2wgW2F0dHIucm9sZV09XCJ0eXBlYWhlYWQgPyAnY29tYm9ib3gnIDogJ25vbmUnXCIgW2F0dHIuYXJpYS1oYXNwb3B1cF09XCJ0eXBlYWhlYWQgPyAnbGlzdGJveCcgOiBudWxsXCI+XG4gICAgPGxpICpuZ0Zvcj1cImxldCB0YWcgb2YgdGFnczsgbGV0IGkgPSBpbmRleFwiIGNsYXNzPVwidXgtdGFnXCJcbiAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgW25nQ2xhc3NdPVwidGFnQ2xhc3ModGFnLCBpLCBpc1NlbGVjdGVkKGkpKVwiXG4gICAgICAgIFthdHRyLnRhYmluZGV4XT1cImRpc2FibGVkID8gbnVsbCA6IDBcIlxuICAgICAgICBbZm9jdXNJZl09XCJpc1NlbGVjdGVkKGkpXCJcbiAgICAgICAgKGNsaWNrKT1cInRhZ0NsaWNrSGFuZGxlcigkZXZlbnQsIHRhZywgaSlcIlxuICAgICAgICAoZm9jdXMpPVwic2VsZWN0VGFnQXQoaSlcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhZ1RlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7dGFnOiB0YWcsIGluZGV4OiBpLCBkaXNhYmxlZDogZGlzYWJsZWQsIGFwaTogdGFnQXBpfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgIDwvbGk+XG4gICAgPGxpICpuZ0lmPVwiaXNJbnB1dFZpc2libGUoKVwiIGNsYXNzPVwidXgtdGFnLWlucHV0XCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgPGlucHV0ICN0YWdJbnB1dCB0eXBlPVwidGV4dFwiIFthdHRyLmlkXT1cImlkXCIgY2xhc3M9XCJ1eC10YWctaW5wdXRcIlxuICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJpbnB1dFwiXG4gICAgICAgICAgICBbY2xhc3MuaW52YWxpZF09XCIhaW5wdXRWYWxpZFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiaGlnaGxpZ2h0ZWRFbGVtZW50Py5pZFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWF1dG9jb21wbGV0ZV09XCJ0eXBlYWhlYWQgPyAnbGlzdCcgOiAnbm9uZSdcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCJ0eXBlYWhlYWQ/LmlkXCJcbiAgICAgICAgICAgIGFyaWEtbXVsdGlsaW5lPVwiZmFsc2VcIlxuICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cImRpc2FibGVkID8gJycgOiAocGxhY2Vob2xkZXIgfHwgJycpXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbZm9jdXNJZl09XCJpc1NlbGVjdGVkKHRhZ3MubGVuZ3RoKVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiaW5wdXRDbGlja0hhbmRsZXIoKVwiXG4gICAgICAgICAgICAoZm9jdXMpPVwiaW5wdXRGb2N1c0hhbmRsZXIoKVwiXG4gICAgICAgICAgICAocGFzdGUpPVwiaW5wdXRQYXN0ZUhhbmRsZXIoJGV2ZW50KVwiPlxuICAgIDwvbGk+XG48L29sPlxuXG48bmctY29udGVudCAjdHlwZWFoZWFkPjwvbmctY29udGVudD5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0VGFnVGVtcGxhdGUgbGV0LXRhZz1cInRhZ1wiIGxldC1pbmRleD1cImluZGV4XCIgbGV0LWRpc2FibGVkPVwiZGlzYWJsZWRcIiBsZXQtYXBpPVwiYXBpXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJ1eC10YWctdGV4dFwiPnt7YXBpLmdldFRhZ0Rpc3BsYXkodGFnKX19PC9zcGFuPlxuICAgIDxidXR0b24gKm5nSWY9XCJhcGkuY2FuUmVtb3ZlVGFnQXQoaW5kZXgpXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwidXgtdGFnLXJlbW92ZVwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJSZW1vdmUgSXRlbVwiXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIChjbGljayk9XCJhcGkucmVtb3ZlVGFnQXQoaW5kZXgpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWNsb3NlXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuPC9uZy10ZW1wbGF0ZT5gLFxyXG4gICAgcHJvdmlkZXJzOiBbVEFHSU5QVVRfVkFMVUVfQUNDRVNTT1IsIFRBR0lOUFVUX1ZBTElEQVRPUl0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxyXG4gICAgICAgICdbY2xhc3MuZm9jdXNdJzogJ2hhc0ZvY3VzKCknLFxyXG4gICAgICAgICdbY2xhc3MuaW52YWxpZF0nOiAnIXZhbGlkIHx8ICFpbnB1dFZhbGlkJ1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGFnSW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJykgaWQ6IHN0cmluZyA9IGB1eC10YWctaW5wdXQtJHsrK3VuaXF1ZUlkfWA7XHJcblxyXG4gICAgQElucHV0KCd0YWdzJylcclxuICAgIGdldCB0YWdzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdGFncykge1xyXG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWdzO1xyXG4gICAgfVxyXG4gICAgc2V0IHRhZ3ModmFsdWU6IGFueVtdKSB7XHJcbiAgICAgICAgdGhpcy5fdGFncyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlSGFuZGxlcih0aGlzLl90YWdzKTtcclxuICAgICAgICB0aGlzLnRhZ3NDaGFuZ2UuZW1pdCh0aGlzLl90YWdzKTtcclxuICAgIH1cclxuXHJcbiAgICBAT3V0cHV0KCkgdGFnc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XHJcblxyXG4gICAgQElucHV0KCdpbnB1dCcpXHJcbiAgICBnZXQgaW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0O1xyXG4gICAgfVxyXG4gICAgc2V0IGlucHV0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9pbnB1dCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaW5wdXRDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQE91dHB1dCgpIGlucHV0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XHJcblxyXG4gICAgQElucHV0KCkgZGlzcGxheTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBhZGRPblBhc3RlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBlbmZvcmNlVGFnTGltaXRzOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBmcmVlSW5wdXQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgQElucHV0KCkgbWF4VGFnczogbnVtYmVyID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIEBJbnB1dCgpIG1pblRhZ3M6IG51bWJlciA9IDA7XHJcbiAgICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nID0gJyc7XHJcbiAgICBASW5wdXQoKSBzaG93VHlwZWFoZWFkT25DbGljazogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgdGFnRGVsaW1pdGVyczogc3RyaW5nID0gJyc7XHJcbiAgICBASW5wdXQoKSB0YWdQYXR0ZXJuOiBSZWdFeHA7XHJcbiAgICBASW5wdXQoKSB0YWdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIHRhZ0NsYXNzOiBUYWdDbGFzc0Z1bmN0aW9uID0gKCkgPT4gdW5kZWZpbmVkO1xyXG4gICAgQElucHV0KCkgdmFsaWRhdGlvbkVycm9yczogYW55ID0ge307XHJcbiAgICBASW5wdXQoJ2NyZWF0ZVRhZycpIGNyZWF0ZVRhZ0hhbmRsZXI6ICh2YWx1ZTogc3RyaW5nKSA9PiBhbnk7XHJcblxyXG4gICAgQE91dHB1dCgpIHRhZ0FkZGluZyA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdBZGRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdJbnZhbGlkYXRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdSZW1vdmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdSZW1vdmVkID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG4gICAgQE91dHB1dCgpIHRhZ0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG5cclxuICAgIEBDb250ZW50Q2hpbGRyZW4oVHlwZWFoZWFkQ29tcG9uZW50KSB0eXBlYWhlYWRRdWVyeTogUXVlcnlMaXN0PFR5cGVhaGVhZENvbXBvbmVudD47XHJcblxyXG4gICAgQFZpZXdDaGlsZCgndGFnSW5wdXQnKSB0YWdJbnB1dDogRWxlbWVudFJlZjtcclxuXHJcbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0VGFnVGVtcGxhdGUnKSBwcml2YXRlIF9kZWZhdWx0VGFnVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyID0gLTE7XHJcblxyXG4gICAgdGFnQXBpOiBUYWdBcGkgPSB7XHJcbiAgICAgICAgZ2V0VGFnRGlzcGxheTogdGhpcy5nZXRUYWdEaXNwbGF5LmJpbmQodGhpcyksXHJcbiAgICAgICAgcmVtb3ZlVGFnQXQ6IHRoaXMucmVtb3ZlVGFnQXQuYmluZCh0aGlzKSxcclxuICAgICAgICBjYW5SZW1vdmVUYWdBdDogdGhpcy5jYW5SZW1vdmVUYWdBdC5iaW5kKHRoaXMpXHJcbiAgICB9O1xyXG5cclxuICAgIHZhbGlkOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIGlucHV0VmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50O1xyXG5cclxuICAgIGhpZ2hsaWdodGVkRWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgcHJpdmF0ZSBfaW5wdXQ6IHN0cmluZyA9ICcnO1xyXG4gICAgcHJpdmF0ZSBfdGFnczogYW55W10gPSBbXTtcclxuICAgIHByaXZhdGUgX29uQ2hhbmdlSGFuZGxlcjogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcclxuICAgIHByaXZhdGUgX29uVG91Y2hlZEhhbmRsZXI6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XHJcbiAgICBwcml2YXRlIF90eXBlYWhlYWRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICAgICAgcHJpdmF0ZSBfdHlwZWFoZWFkS2V5U2VydmljZTogVHlwZWFoZWFkS2V5U2VydmljZSkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRhZ1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnVGVtcGxhdGUgPSB0aGlzLl9kZWZhdWx0VGFnVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgICAgICAvLyBXYXRjaCBmb3Igb3B0aW9uYWwgY2hpbGQgdHlwZWFoZWFkIGNvbnRyb2xcclxuICAgICAgICB0aGlzLmNvbm5lY3RUeXBlYWhlYWQodGhpcy50eXBlYWhlYWRRdWVyeS5maXJzdCk7XHJcbiAgICAgICAgdGhpcy50eXBlYWhlYWRRdWVyeS5jaGFuZ2VzLnN1YnNjcmliZSgocXVlcnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VHlwZWFoZWFkKHF1ZXJ5LmZpcnN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZXMuZGlzYWJsZWQuY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBzZWxlY3Rpb24gYW5kIGNsb3NlIGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHZhbGlkYXRpb24gc3RhdHVzXHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueVtdKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFncyA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLl9vbkNoYW5nZUhhbmRsZXIgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkSGFuZGxlciA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sICh0YWdzIHByb3BlcnR5KS5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgbGV0IHRhZ1JhbmdlRXJyb3IgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ3MgJiYgKHRoaXMudGFncy5sZW5ndGggPCB0aGlzLm1pblRhZ3MgfHwgdGhpcy50YWdzLmxlbmd0aCA+IHRoaXMubWF4VGFncykpIHtcclxuICAgICAgICAgICAgdGFnUmFuZ2VFcnJvciA9IHtcclxuICAgICAgICAgICAgICAgIGdpdmVuOiB0aGlzLnRhZ3MubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pblRhZ3MsXHJcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4VGFnc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yc1sndGFnUmFuZ2VFcnJvciddID0gdGFnUmFuZ2VFcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcclxuICAgIGtleUhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgaW5wdXQgZmllbGQgY3Vyc29yIGxvY2F0aW9uXHJcbiAgICAgICAgY29uc3QgaW5wdXRDdXJzb3JQb3MgPSB0aGlzLnRhZ0lucHV0Lm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgaW5wdXQgZmllbGQgaGFzIGFueSB0ZXh0IHNlbGVjdGVkXHJcbiAgICAgICAgY29uc3QgaGFzU2VsZWN0aW9uID0gdGhpcy50YWdJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnRhZ0lucHV0Lm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uRW5kO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYSB0YWcgaGFzIGZvY3VzXHJcbiAgICAgICAgY29uc3QgdGFnU2VsZWN0ZWQgPSB0aGlzLmlzVmFsaWRUYWdJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBpbnB1dExlbmd0aCA9IHRoaXMuaW5wdXQgPyB0aGlzLmlucHV0Lmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGFycm93IGtleXMgY2FuIG1vdmUgdGhlIHNlbGVjdGlvbi4gT3RoZXJ3aXNlIHRoZSBpbnB1dCBmaWVsZCB0YWtlcyB0aGUgZXZlbnQuXHJcbiAgICAgICAgY29uc3QgY2FuTmF2aWdhdGVMZWZ0ID0gdGFnU2VsZWN0ZWQgfHwgKGlucHV0Q3Vyc29yUG9zIDw9IDAgJiYgIWhhc1NlbGVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgY2FuTmF2aWdhdGVSaWdodCA9IHRhZ1NlbGVjdGVkIHx8IChpbnB1dEN1cnNvclBvcyA+PSBpbnB1dExlbmd0aCAmJiAhaGFzU2VsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gRm9yd2FyZCBrZXkgZXZlbnRzIHRvIHRoZSB0eXBlYWhlYWQgY29tcG9uZW50LlxyXG4gICAgICAgIHRoaXMuX3R5cGVhaGVhZEtleVNlcnZpY2UuaGFuZGxlS2V5KGV2ZW50LCB0aGlzLnR5cGVhaGVhZCk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgdHlwZWFoZWFkIG9wdGlvbiBpcyBoaWdobGlnaHRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMudHlwZWFoZWFkLm9wZW4gJiYgdGhpcy50eXBlYWhlYWQuaGlnaGxpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHR5cGVhaGVhZCBvcHRpb24gYXMgYSB0YWcsIGNsZWFyIHRoZSBpbnB1dCwgYW5kIGNsb3NlIHRoZSBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0VHlwZWFoZWFkKHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGVhaGVhZC5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIGFuZCBhZGQgdGhlIGlucHV0IHRleHQgYXMgYSB0YWcsIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRJbnB1dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja3NwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdEZWxldGUnOlxyXG4gICAgICAgICAgICBjYXNlICdEZWwnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRhZ1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWdBdCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0xlZnQnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcclxuICAgICAgICAgICAgY2FzZSAnUmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGtleXMgaW4gdGhlIHRhZ0RlbGltaXRlcnNcclxuICAgICAgICBpZiAodGhpcy50YWdEZWxpbWl0ZXJzICYmIHRoaXMudGFnRGVsaW1pdGVycy5pbmRleE9mKHRoaXMuZ2V0S2V5Q2hhcihldmVudCkpID49IDApIHtcclxuICAgICAgICAgICAgLy8gQ29tbWl0IHByZXZpb3VzIHRleHRcclxuICAgICAgICAgICAgdGhpcy5jb21taXRJbnB1dCgpO1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXNvdXQnLCBbJyRldmVudCddKVxyXG4gICAgZm9jdXNPdXRIYW5kbGVyKGV2ZW50OiBGb2N1c0V2ZW50KSB7XHJcblxyXG4gICAgICAgIC8vIElmIGEgY2xpY2sgb24gdGhlIHR5cGVhaGVhZCBpcyBpbiBwcm9ncmVzcywgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgYW4gaXNzdWUgaW4gSUUgd2hlcmUgY2xpY2tpbmcgYSBzY3JvbGxiYXIgZHJvcHMgZm9jdXMuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMudHlwZWFoZWFkLmNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBvbiBibHVyXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFnQ2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50LCB0YWc6IGFueSwgaW5kZXg6IG51bWJlcikge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gU2VuZCB0YWdDbGljayBldmVudFxyXG4gICAgICAgIGNvbnN0IHRhZ0NsaWNrRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgIHRoaXMudGFnQ2xpY2suZW1pdCh0YWdDbGlja0V2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBmb2N1cyBpZiBwcmV2ZW50RGVmYXVsdCgpIHdhcyBjYWxsZWRcclxuICAgICAgICBpZiAodGFnQ2xpY2tFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VsZWN0IHRoZSB0YWcgKGZvciBJRSB0aGF0IGRvZXNuJ3QgcHJvcGFnYXRlIGZvY3VzKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0VGFnQXQoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Q2xpY2tIYW5kbGVyKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMuc2hvd1R5cGVhaGVhZE9uQ2xpY2spIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Rm9jdXNIYW5kbGVyKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0UGFzdGVIYW5kbGVyKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWRkT25QYXN0ZSkge1xyXG4gICAgICAgICAgICAvLyBHZXQgdGV4dCBmcm9tIHRoZSBjbGlwYm9hcmRcclxuICAgICAgICAgICAgbGV0IGlucHV0OiBzdHJpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuY2xpcGJvYXJkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgoPGFueT53aW5kb3cpLmNsaXBib2FyZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIG9ubHlcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gKDxhbnk+d2luZG93KS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSBjbGlwYm9hcmQgdGV4dCBkaXJlY3RseVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21taXQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHlwZWFoZWFkT3B0aW9uU2VsZWN0ZWRIYW5kbGVyKGV2ZW50OiBUeXBlYWhlYWRPcHRpb25FdmVudCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgdHlwZWFoZWFkIHNlbmRzIHRoZSBvcHRpb25TZWxlY3RlZCBldmVudCwgY29tbWl0IHRoZSBvYmplY3QgZGlyZWN0bHlcclxuICAgICAgICB0aGlzLmNvbW1pdFR5cGVhaGVhZChldmVudC5vcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBjdXJyZW50IGlucHV0IHZhbHVlIGFuZCBjbGVhciB0aGUgaW5wdXQgZmllbGQgaWYgc3VjY2Vzc2Z1bC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0SW5wdXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tbWl0KHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbW1pdCB0aGUgZ2l2ZW4gdGFnIG9iamVjdCBhbmQgY2xlYXIgdGhlIGlucHV0IGlmIHN1Y2Nlc3NmdWwuXHJcbiAgICAgKi9cclxuICAgIGNvbW1pdFR5cGVhaGVhZCh0YWc6IGFueSkge1xyXG4gICAgICAgIGlmICh0aGlzLmFkZFRhZyh0YWcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbW1pdCB0aGUgZ2l2ZW4gc3RyaW5nIHZhbHVlIGFzIG9uZSBvciBtb3JlIHRhZ3MsIGlmIHZhbGlkYXRpb24gcGFzc2VzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyhzKSB3ZXJlIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbW1pdChpbnB1dDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKGlucHV0ICYmIHRoaXMuZnJlZUlucHV0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgdGFncyBieSB0aGUgdGFnRGVsaW1pdGVycyBpZiBjb25maWd1cmVkXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSB0aGlzLnNwbGl0VGFnSW5wdXQoaW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGFnIHZhbGlkYXRpb24gZm9yIGFsbCBvZiB0aGUgaW5kaXZpZHVhbCB2YWx1ZXNcclxuICAgICAgICAgICAgbGV0IGFsbFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbmV3VGFnIG9mIG5ld1RhZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZVRhZyhuZXdUYWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgdGFncyBpZiBhbGwgYXJlIHZhbGlkXHJcbiAgICAgICAgICAgIGlmIChhbGxWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbmV3VGFnIG9mIG5ld1RhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0aGlzLmNyZWF0ZVRhZyhuZXdUYWcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgbm8gdGFnIGlzIHNlbGVjdGVkLCBzZWxlY3QgdGhlIHJpZ2h0bW9zdCB0YWcuIElmIGEgdGFnIGlzIHNlbGVjdGVkLCByZW1vdmUgaXQuXHJcbiAgICAgKi9cclxuICAgIGJhY2tzcGFjZSgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkVGFnSW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdFRhZ0F0KHRoaXMudGFncy5sZW5ndGggLSAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ0F0KHRoaXMuc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aGUgbGlzdC4gV3JhcHMgYXQgdGhlIGxpbWl0cy5cclxuICAgICAqIEBwYXJhbSBkIFZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoZSBzZWxlY3RlZCBpbmRleCwgaS5lLiAtMSB0byBtb3ZlIGJhY2t3YXJkcywgKzEgdG8gbW92ZSBmb3J3YXJkcy5cclxuICAgICAqL1xyXG4gICAgbW92ZVNlbGVjdGlvbihkOiBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRTZWxlY3RJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCArPSBkO1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gd3JhcHBpbmcgb2Ygc2VsZWN0aW9uIHdoZW4gb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy50YWdzLmxlbmd0aDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPiB0aGlzLnRhZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHZhbHVlIHRvIGRpc3BsYXkgZm9yIHRoZSBnaXZlbiB0YWcuIFVzZXMgZGlzcGxheSBmdW5jdGlvbi9wcm9wZXJ0eSBuYW1lIGlmIHNldCwgb3RoZXJ3aXNlIGFzc3VtZXMgdGhhdCB0aGUgdGFnIGlzIGEgc2ltcGxlIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZ2V0VGFnRGlzcGxheSh0YWc6IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheSh0YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhZ1s8c3RyaW5nPnRoaXMuZGlzcGxheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGluZGV4IGlzIHNlbGVjdGVkICh0YWcgaW5kZXggb3IgaW5wdXQgZmllbGQpLlxyXG4gICAgICovXHJcbiAgICBpc1NlbGVjdGVkKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleC4gRG9lcyBub3RoaW5nIGlmIGRpc2FibGVkIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdFRhZ0F0KHRhZ0luZGV4OiBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRUYWdJbmRleCh0YWdJbmRleCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGFnSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSBpbnB1dCBmaWVsZCwgZ2l2aW5nIGl0IGZvY3VzLiBEb2VzIG5vdGhpbmcgaWYgZGlzYWJsZWQgaXMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc2VsZWN0SW5wdXQoKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4LiBEb2VzIG5vdGhpbmcgaWYgZGlzYWJsZWQgaXMgdHJ1ZSBvciB0aGUgbWluVGFncyBwcm9wZXJ0eSBwcmV2ZW50cyByZW1vdmFsLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWdBdCh0YWdJbmRleDogbnVtYmVyKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNhblJlbW92ZVRhZ0F0KHRhZ0luZGV4KSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdGFnSW5kZXggaXMgaW4gcmFuZ2VcclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnc1t0YWdJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ1JlbW92aW5nRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ1JlbW92aW5nLmVtaXQodGFnUmVtb3ZpbmdFdmVudCk7XHJcbiAgICAgICAgICAgIGlmICghdGFnUmVtb3ZpbmdFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpbnB1dCBmaXJzdCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBkcm9wcGluZyBmb2N1c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YWdcclxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5zcGxpY2UodGFnSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIGFnYWluIHNpbmNlIGluZGljZXMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ1JlbW92ZWQuZW1pdChuZXcgVGFnSW5wdXRFdmVudCh0YWcpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgY2FuUmVtb3ZlVGFnQXQodGFnSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoID4gdGhpcy5taW5UYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGZpZWxkIHNob3VsZCBiZSBhdmFpbGFibGUuXHJcbiAgICAgKi9cclxuICAgIGlzSW5wdXRWaXNpYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoIDwgdGhpcy5tYXhUYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IHBhcnQgb2YgdGhlIGNvbnRyb2wgaGFzIGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBoYXNGb2N1cygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU2VsZWN0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbm5lY3RUeXBlYWhlYWQodHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50eXBlYWhlYWQgPSB0eXBlYWhlYWQ7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkKSB7XHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciBzZWxlY3RlZCBvcHRpb25zXHJcbiAgICAgICAgICAgIHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbiA9IHRoaXMudHlwZWFoZWFkLm9wdGlvblNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLnR5cGVhaGVhZE9wdGlvblNlbGVjdGVkSGFuZGxlci5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciB0aGUgaGlnaGxpZ2h0ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBBZGRlZCBhIGRlbGF5IHRvIG1vdmUgaXQgb3V0IG9mIHRoZSBjdXJyZW50IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGVcclxuICAgICAgICAgICAgdGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkRWxlbWVudENoYW5nZS5waXBlKGRlbGF5KDApKS5zdWJzY3JpYmUoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gdGFnVmFsdWUgd2l0aCB0aGUgdGFnUGF0dGVybiwgaWYgc2V0LiBVcGRhdGUgdmFsaWRhdGlvbkVycm9ycyBvbiB2YWxpZGF0aW9uIGZhaWx1cmUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdmFsaWRhdGVUYWcodGFnVmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBpbnB1dFBhdHRlcm4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5wdXRWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMudGFnUGF0dGVybiAmJiAhdGhpcy50YWdQYXR0ZXJuLnRlc3QodGFnVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlucHV0UGF0dGVybiA9IHtcclxuICAgICAgICAgICAgICAgIGdpdmVuOiB0YWdWYWx1ZSxcclxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHRoaXMudGFnUGF0dGVyblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0VmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRXJyb3JzWydpbnB1dFBhdHRlcm4nXSA9IGlucHV0UGF0dGVybjtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFZhbGlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgdGFnIG9iamVjdCBmb3IgdGhlIGdpdmVuIHRhZ1ZhbHVlLiBJZiBjcmVhdGVUYWdIYW5kbGVyIGlzIHNwZWNpZmllZCwgdXNlIGl0OyBvdGhlcndpc2UgaWYgZGlzcGxheVByb3BlcnR5IGlzIHNwZWNpZmllZCwgY3JlYXRlIGFuIG9iamVjdCB3aXRoIHRoZSB0YWdWYWx1ZSBhcyB0aGUgc2luZ2xlIG5hbWVkIHByb3BlcnR5OyBvdGhlcndpc2UgcmV0dXJuIHRoZSB0YWdWYWx1ZSBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlVGFnKHRhZ1ZhbHVlOiBzdHJpbmcpOiBhbnkge1xyXG4gICAgICAgIGxldCB0YWcgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLmNyZWF0ZVRhZ0hhbmRsZXIgJiYgdHlwZW9mIHRoaXMuY3JlYXRlVGFnSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0YWcgPSB0aGlzLmNyZWF0ZVRhZ0hhbmRsZXIodGFnVmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGFnID0ge307XHJcbiAgICAgICAgICAgIHRhZ1s8c3RyaW5nPnRoaXMuZGlzcGxheV0gPSB0YWdWYWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YWcgPSB0YWdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRhZyBvYmplY3QsIGNhbGxpbmcgdGhlIHRhZ0FkZGluZyBhbmQgdGFnQWRkZWQgZXZlbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyB3YXMgYWRkZWQgdG8gdGhlIHRhZ3MgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWRkVGFnKHRhZzogYW55KTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgbmV3IHRhZyBjYW4gYmUgZGlzcGxheWVkXHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IHRoaXMuZ2V0VGFnRGlzcGxheSh0YWcpO1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheVZhbHVlICYmIHR5cGVvZiBkaXNwbGF5VmFsdWUgPT09ICdzdHJpbmcnICYmIGRpc3BsYXlWYWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdBZGRpbmdFdmVudCA9IG5ldyBUYWdJbnB1dEV2ZW50KHRhZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0FkZGluZy5lbWl0KHRhZ0FkZGluZ0V2ZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGFnQWRkaW5nRXZlbnQuZGVmYXVsdFByZXZlbnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdBZGRlZC5lbWl0KG5ldyBUYWdJbnB1dEV2ZW50KHRhZykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB0YWdJbmRleCBpcyBhIHZhbGlkIHRhZyBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0YWdJbmRleCA+PSAwICYmIHRhZ0luZGV4IDwgdGhpcy50YWdzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gaW5kZXggaXMgYSB2YWxpZCBzZWxlY3Rpb24gaW5kZXggKHRhZ3Mgb3IgaW5wdXQgZmllbGQpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzVmFsaWRTZWxlY3RJbmRleChpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy50YWdzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXkgZXZlbnQsIG1haW5seSBmb3IgSUUgY29tcGF0aWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRLZXlDaGFyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xyXG4gICAgICAgICAgICBjYXNlICdTcGFjZWJhcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnQua2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlucHV0IHN0cmluZyBzcGxpdCBieSB0aGUgdGFnRGVsaW1pdGVycyBjaGFyYWN0ZXJzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNwbGl0VGFnSW5wdXQoaW5wdXQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICAgICAgICBsZXQgdGFnVmFsdWVzID0gW2lucHV0XTtcclxuICAgICAgICBpZiAodGhpcy50YWdEZWxpbWl0ZXJzICYmIHR5cGVvZiB0aGlzLnRhZ0RlbGltaXRlcnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWREZWxpbWl0ZXJzID0gdGhpcy50YWdEZWxpbWl0ZXJzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXJSZWdleCA9IG5ldyBSZWdFeHAoYFske2VzY2FwZWREZWxpbWl0ZXJzfV1gLCAnZycpO1xyXG4gICAgICAgICAgICB0YWdWYWx1ZXMgPSBpbnB1dC5zcGxpdChkZWxpbWl0ZXJSZWdleCkuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFnVmFsdWVzO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIEFQSSBhdmFpbGFibGUgdG8gdGFnIHRlbXBsYXRlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFnQXBpIHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gdGFnLCBhY2NvcmRpbmcgdG8gdGhlIGRpc3BsYXlQcm9wZXJ0eSBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0VGFnRGlzcGxheTogKHRhZzogYW55KSA9PiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBwb3NzaWJsZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVGFnQXQ6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogXHRSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXggY2FuIGJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIGNhblJlbW92ZVRhZ0F0OiAoaW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiB1c2VkIHRvIHJldHVybiBjdXN0b20gY2xhc3MgaW5mb3JtYXRpb24sIGZvciB1c2UgaW4gYG5nQ2xhc3NgLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgVGFnQ2xhc3NGdW5jdGlvbiA9ICh0YWc6IGFueSwgaW5kZXg6IG51bWJlciwgc2VsZWN0ZWQ6IGJvb2xlYW4pID0+IChzdHJpbmcgfCBzdHJpbmdbXSB8IFNldDxzdHJpbmc+KTsiLCJpbXBvcnQgeyBGb2N1c0lmTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb2N1cy1pZi9pbmRleCc7XG5pbXBvcnQgeyBUeXBlYWhlYWRNb2R1bGUgfSBmcm9tICcuLi90eXBlYWhlYWQvaW5kZXgnO1xuaW1wb3J0IHsgVGFnSW5wdXRDb21wb25lbnQgfSBmcm9tICcuL3RhZy1pbnB1dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGUsXG4gICAgICAgIFR5cGVhaGVhZE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1RhZ0lucHV0Q29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtUYWdJbnB1dENvbXBvbmVudF0sXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgVGFnSW5wdXRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvaW5maW5pdGUtc2Nyb2xsL2luZGV4JztcbmltcG9ydCB7IFRhZ0lucHV0TW9kdWxlIH0gZnJvbSAnLi4vdGFnLWlucHV0L2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XG5pbXBvcnQgeyBTZWxlY3RDb21wb25lbnQgfSBmcm9tICcuL3NlbGVjdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTW9kdWxlLFxuICAgICAgICBUYWdJbnB1dE1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbU2VsZWN0Q29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTZWxlY3RDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoVGV4dENvbXBvbmVudCB9IGZyb20gJy4vc2VhcmNoLWNvbXBvbmVudHMvdGV4dC90ZXh0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hEYXRlQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9kYXRlL2RhdGUuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLW91dGxldC9zZWFyY2gtYnVpbGRlci1vdXRsZXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IEJhc2VTZWFyY2hDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1jb21wb25lbnRzL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlck1vZHVsZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci5tb2R1bGUnO1xuaW1wb3J0IHsgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9kYXRlLXJhbmdlL2RhdGUtcmFuZ2UuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaFNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4vc2VhcmNoLWNvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0TW9kdWxlIH0gZnJvbSAnLi4vc2VsZWN0L2luZGV4JztcbmltcG9ydCB7IFBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9wb3BvdmVyL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBEYXRlVGltZVBpY2tlck1vZHVsZSxcbiAgICBQb3BvdmVyTW9kdWxlLFxuICAgIFNlbGVjdE1vZHVsZVxuICBdLFxuICBleHBvcnRzOiBbXG4gICAgU2VhcmNoQnVpbGRlckNvbXBvbmVudCxcbiAgICBTZWFyY2hCdWlsZGVyR3JvdXBDb21wb25lbnQsXG4gICAgQmFzZVNlYXJjaENvbXBvbmVudFxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBTZWFyY2hCdWlsZGVyQ29tcG9uZW50LFxuICAgIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCxcbiAgICBTZWFyY2hUZXh0Q29tcG9uZW50LFxuICAgIFNlYXJjaERhdGVDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50LFxuICAgIFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUsXG4gICAgU2VhcmNoU2VsZWN0Q29tcG9uZW50LFxuICAgIEJhc2VTZWFyY2hDb21wb25lbnRcbiAgXSxcbiAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgU2VhcmNoVGV4dENvbXBvbmVudCxcbiAgICBTZWFyY2hEYXRlQ29tcG9uZW50LFxuICAgIFNlYXJjaERhdGVSYW5nZUNvbXBvbmVudCxcbiAgICBTZWFyY2hTZWxlY3RDb21wb25lbnRcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNpZGVQYW5lbFNlcnZpY2UgfSBmcm9tICcuL3NpZGUtcGFuZWwuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2lkZVBhbmVsQ2xvc2VdJ1xufSlcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxDbG9zZURpcmVjdGl2ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZXJ2aWNlOiBTaWRlUGFuZWxTZXJ2aWNlKSB7IH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBjbGlja0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFNpZGVQYW5lbENvbXBvbmVudCB9IGZyb20gJy4vc2lkZS1wYW5lbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2lkZVBhbmVsQ2xvc2VEaXJlY3RpdmUgfSBmcm9tICcuL3NpZGUtcGFuZWwtY2xvc2UuZGlyZWN0aXZlJztcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBTaWRlUGFuZWxDb21wb25lbnQsXG4gICAgU2lkZVBhbmVsQ2xvc2VEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IEVYUE9SVFMsXG4gICAgZGVjbGFyYXRpb25zOiBFWFBPUlRTXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBEb0NoZWNrLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2xpZGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ0cmFja1wiICN0cmFjayBbY2xhc3MubmFycm93XT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLk5hcnJvd1wiIFtjbGFzcy53aWRlXT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLldpZGVcIiBbY2xhc3MucmFuZ2VdPVwib3B0aW9ucy50eXBlID09PSBzbGlkZXJUeXBlLlJhbmdlXCI+XG5cbiAgICA8IS0tIFNlY3Rpb24gQmVuZWF0aCBMb3dlciBUaHVtYiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidHJhY2stc2VjdGlvbiB0cmFjay1sb3dlclwiIFtzdHlsZS5mbGV4LWdyb3ddPVwidHJhY2tzLmxvd2VyLnNpemVcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJ0cmFja3MubG93ZXIuY29sb3JcIj48L2Rpdj5cblxuICAgIDwhLS0gTG93ZXIgVGh1bWIgQnV0dG9uIC8gTGluZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidGh1bWIgbG93ZXJcIlxuICAgICAgICB1eERyYWdcbiAgICAgICAgcm9sZT1cInNsaWRlclwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICNsb3dlcnRodW1iXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwib3B0aW9ucy50eXBlID09PSBzbGlkZXJUeXBlLlJhbmdlID8gb3B0aW9ucy5oYW5kbGVzLmFyaWEubG93ZXJUaHVtYiA6IG9wdGlvbnMuaGFuZGxlcy5hcmlhLnRodW1iXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJvcHRpb25zPy50cmFjaz8ubWluXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJvcHRpb25zLnR5cGUgPT09IHNsaWRlclR5cGUuUmFuZ2UgPyBnZXRUaHVtYlZhbHVlKHNsaWRlclRodW1iLlVwcGVyKSA6IG9wdGlvbnM/LnRyYWNrPy5tYXhcIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cImdldFRodW1iVmFsdWUoc2xpZGVyVGh1bWIuTG93ZXIpXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZXRleHRdPVwiZ2V0QXJpYVZhbHVlVGV4dChzbGlkZXJUaHVtYi5Mb3dlcilcIlxuICAgICAgICBbc3R5bGUubGVmdC4lXT1cInRodW1icy5sb3dlci5wb3NpdGlvblwiXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVwidGh1bWJzLmxvd2VyLmRyYWdcIlxuICAgICAgICBbc3R5bGUuei1pbmRleF09XCJ0aHVtYnMubG93ZXIub3JkZXJcIlxuICAgICAgICBbY2xhc3MuYnV0dG9uXT1cIm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gc2xpZGVyU3R5bGUuQnV0dG9uXCJcbiAgICAgICAgW2NsYXNzLmxpbmVdPVwib3B0aW9ucy5oYW5kbGVzLnN0eWxlID09PSBzbGlkZXJTdHlsZS5MaW5lXCJcbiAgICAgICAgW2NsYXNzLm5hcnJvd109XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5OYXJyb3dcIlxuICAgICAgICBbY2xhc3Mud2lkZV09XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5XaWRlXCJcbiAgICAgICAgKGRyYWdzdGFydCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdTdGFydCk7IGxvd2VydGh1bWIuZm9jdXMoKVwiXG4gICAgICAgIChkcmFnKT1cInVwZGF0ZVRodW1iUG9zaXRpb24oJGV2ZW50LCBzbGlkZXJUaHVtYi5Mb3dlcilcIlxuICAgICAgICAoZHJhZ2VuZCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdFbmQpXCJcbiAgICAgICAgKG1vdXNlZW50ZXIpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5Mb3dlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXIpXCJcbiAgICAgICAgKG1vdXNlbGVhdmUpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5Mb3dlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZUxlYXZlKVwiXG4gICAgICAgIChmb2N1cyk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlT3ZlcilcIlxuICAgICAgICAoYmx1cik9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlTGVhdmUpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclNuYXAuQWxsLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJzbmFwVG9OZWFyZXN0VGljayhzbGlkZXJUaHVtYi5Mb3dlciwgc2xpZGVyU25hcC5BbGwsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLlBhZ2VEb3duKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLk1ham9yLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uUGFnZVVwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLk1ham9yLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5Ib21lKT1cInNuYXBUb0VuZChzbGlkZXJUaHVtYi5Mb3dlciwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkVuZCk9XCJzbmFwVG9FbmQoc2xpZGVyVGh1bWIuTG93ZXIsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG4gICAgICAgIDwhLS0gTG93ZXIgVGh1bWIgQ2FsbG91dCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAgdG9wIHRvb2x0aXAtbG93ZXJcIiAjbG93ZXJUb29sdGlwXG4gICAgICAgICAgICBbY2xhc3MudG9vbHRpcC1keW5hbWljXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IHNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMgJiYgdGh1bWJzLmxvd2VyLmRyYWcgPT09IGZhbHNlXCJcbiAgICAgICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cInRvb2x0aXBzLmxvd2VyLnZpc2libGUgPyAxIDogMFwiXG4gICAgICAgICAgICBbc3R5bGUubGVmdC5weF09XCJ0b29sdGlwcy5sb3dlci5wb3NpdGlvblwiPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiIFtzdHlsZS5ib3JkZXItdG9wLWNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmJhY2tncm91bmRcIj48L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmJhY2tncm91bmRcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5jb2xvcl09XCJvcHRpb25zLmhhbmRsZXMuY2FsbG91dC5jb2xvclwiPlxuICAgICAgICAgICAgICAgIHt7IHRvb2x0aXBzLmxvd2VyLmxhYmVsIH19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gU2VjdGlvbiBvZiBUcmFjayBCZXR3ZWVuIExvd2VyIGFuZCBVcHBlciBUaHVtYnMgLS0+XG4gICAgPGRpdiBjbGFzcz1cInRyYWNrLXNlY3Rpb24gdHJhY2stcmFuZ2VcIiAqbmdJZj1cIm9wdGlvbnMudHlwZSA9PT0gc2xpZGVyVHlwZS5SYW5nZVwiIFtzdHlsZS5mbGV4LWdyb3ddPVwidHJhY2tzLm1pZGRsZS5zaXplXCIgW3N0eWxlLmJhY2tncm91bmRdPVwidHJhY2tzLm1pZGRsZS5jb2xvclwiPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBVcHBlciBUaHVtYiBCdXR0b24gLyBMaW5lIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJ0aHVtYiB1cHBlclwiXG4gICAgICAgIHV4RHJhZ1xuICAgICAgICByb2xlPVwic2xpZGVyXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgI3VwcGVydGh1bWJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJvcHRpb25zLmhhbmRsZXMuYXJpYS51cHBlclRodW1iXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJnZXRUaHVtYlZhbHVlKHNsaWRlclRodW1iLkxvd2VyKSB8fCBvcHRpb25zPy50cmFjaz8ubWluXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJvcHRpb25zPy50cmFjaz8ubWF4XCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJnZXRUaHVtYlZhbHVlKHNsaWRlclRodW1iLlVwcGVyKVwiXG4gICAgICAgIFthdHRyLmFyaWEtdmFsdWV0ZXh0XT1cImdldEFyaWFWYWx1ZVRleHQoc2xpZGVyVGh1bWIuVXBwZXIpXCJcbiAgICAgICAgW2hpZGRlbl09XCJvcHRpb25zLnR5cGUgIT09IHNsaWRlclR5cGUuUmFuZ2VcIlxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cInRodW1icy51cHBlci5kcmFnXCJcbiAgICAgICAgW3N0eWxlLmxlZnQuJV09XCJ0aHVtYnMudXBwZXIucG9zaXRpb25cIlxuICAgICAgICBbc3R5bGUuei1pbmRleF09XCJ0aHVtYnMudXBwZXIub3JkZXJcIlxuICAgICAgICBbY2xhc3MuYnV0dG9uXT1cIm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gc2xpZGVyU3R5bGUuQnV0dG9uXCJcbiAgICAgICAgW2NsYXNzLmxpbmVdPVwib3B0aW9ucy5oYW5kbGVzLnN0eWxlID09PSBzbGlkZXJTdHlsZS5MaW5lXCJcbiAgICAgICAgW2NsYXNzLm5hcnJvd109XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5OYXJyb3dcIlxuICAgICAgICBbY2xhc3Mud2lkZV09XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5XaWRlXCJcbiAgICAgICAgKGRyYWdzdGFydCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdTdGFydCk7IHVwcGVydGh1bWIuZm9jdXMoKVwiXG4gICAgICAgIChkcmFnKT1cInVwZGF0ZVRodW1iUG9zaXRpb24oJGV2ZW50LCBzbGlkZXJUaHVtYi5VcHBlcilcIlxuICAgICAgICAoZHJhZ2VuZCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdFbmQpXCJcbiAgICAgICAgKG1vdXNlZW50ZXIpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5VcHBlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXIpXCJcbiAgICAgICAgKG1vdXNlbGVhdmUpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5VcHBlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZUxlYXZlKVwiXG4gICAgICAgIChmb2N1cyk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlT3ZlcilcIlxuICAgICAgICAoYmx1cik9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlTGVhdmUpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclNuYXAuQWxsLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJzbmFwVG9OZWFyZXN0VGljayhzbGlkZXJUaHVtYi5VcHBlciwgc2xpZGVyU25hcC5BbGwsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLlBhZ2VEb3duKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLk1ham9yLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uUGFnZVVwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLk1ham9yLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5Ib21lKT1cInNuYXBUb0VuZChzbGlkZXJUaHVtYi5VcHBlciwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkVuZCk9XCJzbmFwVG9FbmQoc2xpZGVyVGh1bWIuVXBwZXIsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG4gICAgICAgIDwhLS0gVXBwZXIgVGh1bWIgQ2FsbG91dCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAgdG9wIHRvb2x0aXAtdXBwZXJcIiAjdXBwZXJUb29sdGlwXG4gICAgICAgICAgICBbY2xhc3MudG9vbHRpcC1keW5hbWljXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IHNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMgJiYgdGh1bWJzLnVwcGVyLmRyYWcgPT09IGZhbHNlXCJcbiAgICAgICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cInRvb2x0aXBzLnVwcGVyLnZpc2libGUgPyAxIDogMFwiXG4gICAgICAgICAgICBbc3R5bGUubGVmdC5weF09XCJ0b29sdGlwcy51cHBlci5wb3NpdGlvblwiPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiIFtzdHlsZS5ib3JkZXItdG9wLWNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmJhY2tncm91bmRcIj48L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwib3B0aW9ucy50eXBlID09PSBzbGlkZXJUeXBlLlJhbmdlXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XCJvcHRpb25zLmhhbmRsZXMuY2FsbG91dC5iYWNrZ3JvdW5kXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuY29sb3JdPVwib3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuY29sb3JcIj5cbiAgICAgICAgICAgICAgICB7eyB0b29sdGlwcy51cHBlci5sYWJlbCB9fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBTZWN0aW9uIG9mIFRyYWNrIEFib3ZlciBVcHBlciBUaHVtYiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidHJhY2stc2VjdGlvbiB0cmFjay1oaWdoZXJcIiBbc3R5bGUuZmxleC1ncm93XT1cInRyYWNrcy51cHBlci5zaXplXCIgW3N0eWxlLmJhY2tncm91bmRdPVwidHJhY2tzLnVwcGVyLmNvbG9yXCI+PC9kaXY+XG5cbjwvZGl2PlxuXG48IS0tIENoYXJ0IFRpY2tzIGFuZCBUaWNrIExhYmVscyAtLT5cbjxkaXYgY2xhc3M9XCJ0aWNrLWNvbnRhaW5lclwiXG4gICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgKm5nSWY9XCIob3B0aW9ucy50cmFjay50aWNrcy5tYWpvci5zaG93IHx8IG9wdGlvbnMudHJhY2sudGlja3MubWlub3Iuc2hvdykgJiYgb3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlciAhPT0gc2xpZGVyQ2FsbG91dFRyaWdnZXIuRHluYW1pY1wiXG4gICAgW2NsYXNzLnNob3ctbGFiZWxzXT1cIm9wdGlvbnMudHJhY2sudGlja3MubWFqb3IubGFiZWxzIHx8IG9wdGlvbnMudHJhY2sudGlja3MubWlub3IubGFiZWxzXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidGlja1wiXG4gICAgICAgICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzXCJcbiAgICAgICAgW2NsYXNzLm1ham9yXT1cInRpY2sudHlwZSA9PT0gc2xpZGVyVGlja1R5cGUuTWFqb3JcIlxuICAgICAgICBbY2xhc3MubWlub3JdPVwidGljay50eXBlID09PSBzbGlkZXJUaWNrVHlwZS5NaW5vclwiXG4gICAgICAgIFtzdHlsZS5sZWZ0LiVdPVwidGljay5wb3NpdGlvblwiXG4gICAgICAgIFtoaWRkZW5dPVwiIXRpY2suc2hvd1RpY2tzXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpY2staW5kaWNhdG9yXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0aWNrLWxhYmVsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgW2hpZGRlbl09XCIhdGljay5zaG93TGFiZWxzXCI+e3sgdGljay5sYWJlbCB9fTwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIERvQ2hlY2sge1xuXG4gICAgQElucHV0KCkgdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBTbGlkZXJPcHRpb25zO1xuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPFNsaWRlclZhbHVlIHwgbnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8U2xpZGVyVmFsdWUgfCBudW1iZXI+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdsb3dlclRvb2x0aXAnKSBsb3dlclRvb2x0aXA6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndXBwZXJUb29sdGlwJykgdXBwZXJUb29sdGlwOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3RyYWNrJykgdHJhY2s6IEVsZW1lbnRSZWY7XG5cbiAgICAvLyBzdG9yZSBjdXJyZW50IHZhbHVlcyBmb3IgZGVlcCBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgcHJpdmF0ZSBfdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyO1xuXG4gICAgLy8gZXhwb3NlIGVudW1zIHRvIEFuZ3VsYXIgdmlld1xuICAgIHNsaWRlclR5cGUgPSBTbGlkZXJUeXBlO1xuICAgIHNsaWRlclN0eWxlID0gU2xpZGVyU3R5bGU7XG4gICAgc2xpZGVyU2l6ZSA9IFNsaWRlclNpemU7XG4gICAgc2xpZGVyU25hcCA9IFNsaWRlclNuYXA7XG4gICAgc2xpZGVyVGh1bWIgPSBTbGlkZXJUaHVtYjtcbiAgICBzbGlkZXJUaWNrVHlwZSA9IFNsaWRlclRpY2tUeXBlO1xuICAgIHNsaWRlclRodW1iRXZlbnQgPSBTbGlkZXJUaHVtYkV2ZW50O1xuICAgIHNsaWRlckNhbGxvdXRUcmlnZ2VyID0gU2xpZGVyQ2FsbG91dFRyaWdnZXI7XG5cbiAgICB0cmFja3MgPSB7XG4gICAgICAgIGxvd2VyOiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRvb2x0aXBzID0ge1xuICAgICAgICBsb3dlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRodW1icyA9IHtcbiAgICAgICAgbG93ZXI6IHtcbiAgICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWc6IGZhbHNlLFxuICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICBvcmRlcjogMTAwLFxuICAgICAgICAgICAgdmFsdWU6IG51bGwgYXMgbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyOiB7XG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICBkcmFnOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgb3JkZXI6IDEwMSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsIGFzIG51bWJlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0b3JlIGFsbCB0aGUgdGlja3MgdG8gZGlzcGxheVxuICAgIHRpY2tzOiBTbGlkZXJUaWNrW10gPSBbXTtcbiAgICBkZWZhdWx0T3B0aW9uczogU2xpZGVyT3B0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKGNvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlLCBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcblxuICAgICAgICAvLyBzZXR1cCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFNsaWRlclR5cGUuVmFsdWUsXG4gICAgICAgICAgICBoYW5kbGVzOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IFNsaWRlclN0eWxlLkJ1dHRvbixcbiAgICAgICAgICAgICAgICBjYWxsb3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IFNsaWRlckNhbGxvdXRUcmlnZ2VyLk5vbmUsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTInKS50b0hleCgpLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXlib2FyZDoge1xuICAgICAgICAgICAgICAgICAgICBtYWpvcjogNSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyaWE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWI6ICdTbGlkZXIgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICBsb3dlclRodW1iOiAnU2xpZGVyIGxvd2VyIHZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJUaHVtYjogJ1NsaWRlciB1cHBlciB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFNsaWRlclNpemUuV2lkZSxcbiAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc25hcDogU2xpZGVyU25hcC5Ob25lLFxuICAgICAgICAgICAgICAgICAgICBtYWpvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgfCBudW1iZXIgPT4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwczogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogY29sb3JTZXJ2aWNlLmdldENvbG9yKCdncmV5NicpLnRvSGV4KCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjb2xvclNlcnZpY2UuZ2V0Q29sb3IoJ2FjY2VudCcpLnNldEFscGhhKDAuNzUpLnRvUmdiYSgpLFxuICAgICAgICAgICAgICAgICAgICBoaWdoZXI6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTYnKS50b0hleCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlcygpO1xuXG4gICAgICAgIHRoaXMuc2V0VGh1bWJTdGF0ZShTbGlkZXJUaHVtYi5Mb3dlciwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKFNsaWRlclRodW1iLlVwcGVyLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGluaXRpYWwgdmFsdWVcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5uZXh0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCB0aGlzLl92YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHBlcnNpc3RlbnQgdG9vbHRpcHMgd2lsbCBuZWVkIHBvc2l0aW9uZWQgY29ycmVjdGx5IGF0IHRoaXMgc3RhZ2VcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5Mb3dlcik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgICAgIC8vIG1hcmsgYXMgZGlydHlcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzbmFwVG9OZWFyZXN0VGljayh0aHVtYjogU2xpZGVyVGh1bWIsIHNuYXBUYXJnZXQ6IFNsaWRlclNuYXAsIGZvcndhcmRzOiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSBmb3IgdGhlIHRodW1iXG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tzIC0gcmVtb3ZlIGFueSB0aWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gaXRcbiAgICAgICAgY29uc3QgY2xvc2VzdCA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHNuYXBUYXJnZXQpXG4gICAgICAgICAgICAuZmlsdGVyKHRpY2sgPT4gdGljay52YWx1ZSAhPT0gdmFsdWUpXG4gICAgICAgICAgICAuZmluZCh0aWNrID0+IGZvcndhcmRzID8gdGljay52YWx1ZSA+IHZhbHVlIDogdGljay52YWx1ZSA8IHZhbHVlKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIHRpY2tzIHRoZW4gbW92ZSBieSBhIHByZWRlZmluZWQgYW1vdW50XG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIGNsb3Nlc3QudmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzbmFwVGFyZ2V0ID09PSBTbGlkZXJTbmFwLk1ham9yID8gdGhpcy5vcHRpb25zLmhhbmRsZXMua2V5Ym9hcmQubWFqb3IgOiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5rZXlib2FyZC5taW5vcjtcblxuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgdmFsdWUgKyAoZm9yd2FyZHMgPyBzdGVwIDogLXN0ZXApKSk7XG5cbiAgICB9XG5cbiAgICBzbmFwVG9FbmQodGh1bWI6IFNsaWRlclRodW1iLCBmb3J3YXJkczogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgZm9yd2FyZHMgPyB0aGlzLm9wdGlvbnMudHJhY2subWF4IDogdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpO1xuICAgIH1cblxuICAgIGdldFRodW1iVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuZm9ybWF0dGVyKHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJTdGF0ZSh0aHVtYjogU2xpZGVyVGh1bWIpIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMudGh1bWJzLmxvd2VyIDogdGhpcy50aHVtYnMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlN0YXRlKHRodW1iOiBTbGlkZXJUaHVtYiwgaG92ZXI6IGJvb2xlYW4sIGRyYWc6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy5sb3dlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMubG93ZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy51cHBlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMudXBwZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXBzXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcHModGh1bWIpO1xuICAgIH1cblxuICAgIHRodW1iRXZlbnQodGh1bWI6IFNsaWRlclRodW1iLCBldmVudDogU2xpZGVyVGh1bWJFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCB0aHVtYiBzdGF0ZVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJhc2VkIHVwb24gZXZlbnRcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ1N0YXJ0OlxuICAgICAgICAgICAgICAgIHN0YXRlLmRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ0VuZDpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXI6XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTW91c2VMZWF2ZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTm9uZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgc3RhdGVcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKHRodW1iLCBzdGF0ZS5ob3Zlciwgc3RhdGUuZHJhZyk7XG4gICAgfVxuXG4gICAgZ2V0QXJpYVZhbHVlVGV4dCh0aHVtYjogU2xpZGVyVGh1bWIpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdGh1bWIgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFRodW1iVmFsdWUodGh1bWIpO1xuXG4gICAgICAgIC8vIGdldCBhbGwgdGhlIHRpY2tzXG4gICAgICAgIGNvbnN0IHRpY2sgPSB0aGlzLnRpY2tzLmZpbmQoX3RpY2sgPT4gX3RpY2sudmFsdWUgPT09IHZhbHVlKTtcblxuICAgICAgICBpZiAodGljayAmJiB0aWNrLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGljay5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBzaW1wbHkgZGlzcGxheSB0aGUgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZvcm1hdHRlZFZhbHVlKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBzKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlcikge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlckNhbGxvdXRUcmlnZ2VyLlBlcnNpc3RlbnQ6XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyQ2FsbG91dFRyaWdnZXIuRHJhZzpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5Ib3ZlcjpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuaG92ZXIgfHwgc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5EeW5hbWljOlxuICAgICAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgdGh1bWJcbiAgICAgICAgdGhpcy5nZXRUb29sdGlwKHRodW1iKS52aXNpYmxlID0gdmlzaWJsZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgdGV4dFxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFBvc2l0aW9uKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iOiBTbGlkZXJUaHVtYikge1xuXG4gICAgICAgIC8vIGdldCB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmdldFRvb2x0aXAodGh1bWIpO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBmb3JtYXR0ZWQgbGFiZWxcbiAgICAgICAgdG9vbHRpcC5sYWJlbCA9IHRoaXMuZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWIpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwRWxlbWVudCh0aHVtYjogU2xpZGVyVGh1bWIpOiBFbGVtZW50UmVmIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMubG93ZXJUb29sdGlwIDogdGhpcy51cHBlclRvb2x0aXA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwKHRodW1iOiBTbGlkZXJUaHVtYikge1xuICAgICAgICByZXR1cm4gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gdGhpcy50b29sdGlwcy5sb3dlciA6IHRoaXMudG9vbHRpcHMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUb29sdGlwUG9zaXRpb24odGh1bWI6IFNsaWRlclRodW1iKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuZ2V0VG9vbHRpcCh0aHVtYik7XG5cbiAgICAgICAgLy8gaWYgdG9vbHRpcCBpcyBub3QgdmlzaWJsZSB0aGVuIHN0b3AgaGVyZVxuICAgICAgICBpZiAodG9vbHRpcC52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRvb2x0aXBFbGVtZW50ID0gdGhpcy5nZXRUb29sdGlwRWxlbWVudCh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50IHdpZHRoc1xuICAgICAgICBsZXQgdGh1bWJXaWR0aDogbnVtYmVyO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gU2xpZGVyU3R5bGUuQnV0dG9uKSB7XG4gICAgICAgICAgICB0aHVtYldpZHRoID0gdGhpcy5vcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gU2xpZGVyU2l6ZS5OYXJyb3cgPyAxNiA6IDI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGh1bWJXaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9vbHRpcFdpZHRoID0gdG9vbHRpcEVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvb2x0aXBzIG5ldyBwb3NpdGlvblxuICAgICAgICBsZXQgdG9vbHRpcFBvc2l0aW9uID0gTWF0aC5jZWlsKCh0b29sdGlwV2lkdGggLSB0aHVtYldpZHRoKSAvIDIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uXG4gICAgICAgIHRvb2x0aXAucG9zaXRpb24gPSAtdG9vbHRpcFBvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5SYW5nZSAmJiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IFNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFRvb2x0aXBPdmVybGFwKHRvb2x0aXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmV2ZW50VG9vbHRpcE92ZXJsYXAodG9vbHRpcDogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy5sb3dlci5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdXBwZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy51cHBlci5wb3NpdGlvbjtcblxuICAgICAgICBjb25zdCBsb3dlcldpZHRoID0gdGhpcy5sb3dlclRvb2x0aXAubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHVwcGVyV2lkdGggPSB0aGlzLnVwcGVyVG9vbHRpcC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcblxuICAgICAgICBjb25zdCBkaWZmID0gKGxvd2VyICsgbG93ZXJXaWR0aCkgLSAodXBwZXIgLSB1cHBlcldpZHRoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcHMgYXJlIGNsb3NlciB0aGFuIDE2cHggdGhlbiBhZGp1c3Qgc28gdGhlIGRvbnQgbW92ZSBhbnkgY2xvc2VcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy5sb3dlciAmJiB0aGlzLnRodW1icy5sb3dlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gLT0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy51cHBlciAmJiB0aGlzLnRodW1icy51cHBlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gKz0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRodW1iUG9zaXRpb24oZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCB0aHVtYjogU2xpZGVyVGh1bWIpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgZXZlbnQgcG9zaXRpb24gLSBlaXRoZXIgbW91c2Ugb3IgdG91Y2hcbiAgICAgICAgbGV0IGV2ZW50UG9zaXRpb24gPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDAgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBudWxsO1xuXG4gICAgICAgIC8vIGlmIGV2ZW50IHBvc2l0aW9uIGlzIG51bGwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoZXZlbnRQb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGxldCBtb3VzZVggPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBldmVudFBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGdldCB0cmFjayBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICBsZXQgdHJhY2tCb3VuZHMgPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gcmVzdHJpY3QgdGhlIHZhbHVlIHdpdGhpbiB0aGUgcmFuZ2Ugc2l6ZVxuICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLmNsYW1wKG1vdXNlWCAtIHRyYWNrQm91bmRzLmxlZnQsIDAsIHRyYWNrQm91bmRzLndpZHRoKTtcblxuICAgICAgICAvLyBnZXQgZnJhY3Rpb24gcmVwcmVzZW50YXRpb24gb2YgbG9jYXRpb24gd2l0aGluIHRoZSB0cmFja1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSAocG9zaXRpb24gLyB0cmFja0JvdW5kcy53aWR0aCk7XG5cbiAgICAgICAgLy8gY29udmVydCB0byB2YWx1ZSB3aXRoaW4gdGhlIHJhbmdlXG4gICAgICAgIGxldCB2YWx1ZSA9ICgodGhpcy5vcHRpb25zLnRyYWNrLm1heCAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pICogZnJhY3Rpb24pICsgdGhpcy5vcHRpb25zLnRyYWNrLm1pbjtcblxuICAgICAgICAvLyBlbnN1cmUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIHZhbHVlKTtcblxuICAgICAgICAvLyBzbmFwIHRvIGEgdGljayBpZiByZXF1aXJlZFxuICAgICAgICB2YWx1ZSA9IHRoaXMuc25hcFRvVGljayh2YWx1ZSwgdGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVPcmRlcih0aHVtYik7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRvb2x0aXAgdGV4dCAmIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQodGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYWxsIHZpc2libGUgdG9vbHRpcHNcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwUG9zaXRpb24oU2xpZGVyVGh1bWIuTG93ZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgLy8gbWFyayBhcyBkaXJ0eSBmb3IgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU9yZGVyKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCBsb3dlciA9IHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IDEwMSA6IDEwMDtcbiAgICAgICAgbGV0IHVwcGVyID0gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gMTAwIDogMTAxO1xuXG4gICAgICAgIC8vIFRoZSBtb3N0IHJlY2VudGx5IHVzZWQgdGh1bWIgc2hvdWxkIGJlIGFib3ZlXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLm9yZGVyID0gbG93ZXI7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLm9yZGVyID0gdXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaWNrRGlzdGFuY2VzKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYiwgc25hcFRhcmdldDogU2xpZGVyU25hcCk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gaWYgc25hcCB0YXJnZXQgaXMgbm9uZSB0aGVuIHJldHVybiBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICBpZiAoc25hcFRhcmdldCA9PT0gU2xpZGVyU25hcC5Ob25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZmlsdGVyZWQgdGlja3NcbiAgICAgICAgbGV0IHRpY2tzOiBTbGlkZXJUaWNrW107XG5cbiAgICAgICAgc3dpdGNoIChzbmFwVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NaW5vcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NaW5vcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NYWpvcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBsaW1pdFxuICAgICAgICBsZXQgbG93ZXJMaW1pdCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCB1cHBlckxpbWl0ID0gdGhpcy5vcHRpb25zLnRyYWNrLm1heDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy50aHVtYnMudXBwZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLlVwcGVyKSB7XG4gICAgICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy50aHVtYnMubG93ZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHRpY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWNrcy5maWx0ZXIodGljayA9PiB0aWNrLnZhbHVlID49IGxvd2VyTGltaXQgJiYgdGljay52YWx1ZSA8PSB1cHBlckxpbWl0KTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY2xvc2UgdGlja3MgaW4gdGhlIHZhbGlkIHJhbmdlIHRoZW4gZG9udCBzbmFwXG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZS5zb3J0KCh0aWNrT25lLCB0aWNrVHdvKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRpY2tPbmVEZWx0YSA9IE1hdGgubWF4KHRpY2tPbmUudmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tPbmUudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tUd29EZWx0YSA9IE1hdGgubWF4KHRpY2tUd28udmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tUd28udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRpY2tPbmVEZWx0YSAtIHRpY2tUd29EZWx0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzbmFwVG9UaWNrKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgdGlja0Rpc3RhbmNlcyA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5zbmFwKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdGlja3MgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGlmICh0aWNrRGlzdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tcbiAgICAgICAgcmV0dXJuIHRpY2tEaXN0YW5jZXNbMF0udmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgLy8gaWYgc2xpZGVyIGlzIG5vdCBhIHJhbmdlIHZhbHVlIGlzIGFsd2F5cyB2YWxpZCBwcm92aWRpbmcgaXQgaXMgd2l0aGluIHRoZSBjaGFydCBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBTbGlkZXJUeXBlLlZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIHRoaXMub3B0aW9ucy50cmFjay5tYXgpLCB0aGlzLm9wdGlvbnMudHJhY2subWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIHdpdGggY2hhcnQgcmFuZ2VzXG4gICAgICAgIGlmICh2YWx1ZSA+IHRoaXMub3B0aW9ucy50cmFjay5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIgPyBNYXRoLm1pbih0aGlzLm9wdGlvbnMudHJhY2subWF4LCB0aGlzLnRodW1icy51cHBlci52YWx1ZSkgOiB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5vcHRpb25zLnRyYWNrLm1pbikge1xuICAgICAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5VcHBlciA/IE1hdGgubWF4KHRoaXMub3B0aW9ucy50cmFjay5taW4sIHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlKSA6IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayB0byBtYWtlIHN1cmUgbG93ZXIgdGh1bWIgY2Fubm90IGdvIGFib3ZlIGhpZ2hlciBhbmQgdmljZSB2ZXJzYVxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRodW1icy51cHBlci52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID8gdmFsdWUgOiB0aGlzLnRodW1icy51cHBlci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aHVtYiA9PT0gU2xpZGVyVGh1bWIuVXBwZXIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPyB2YWx1ZSA6IHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVPcHRpb25zKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFkZCBpbiB0aGUgZGVmYXVsdCBvcHRpb25zIHRoYXQgdXNlciBoYXNuJ3Qgc3BlY2lmaWVkXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuZGVlcE1lcmdlKHRoaXMub3B0aW9ucyB8fCB7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFja0NvbG9ycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpY2tzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVWYWx1ZXMoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb3dlclZhbHVlID0gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUubG93O1xuICAgICAgICBsZXQgdXBwZXJWYWx1ZSA9IHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJyA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmhpZ2g7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdmFsdWVzXG4gICAgICAgIGxvd2VyVmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUoU2xpZGVyVGh1bWIuTG93ZXIsIE51bWJlcihsb3dlclZhbHVlLnRvRml4ZWQoNCkpKTtcbiAgICAgICAgdXBwZXJWYWx1ZSA9IHRoaXMudmFsaWRhdGVWYWx1ZShTbGlkZXJUaHVtYi5VcHBlciwgTnVtYmVyKHVwcGVyVmFsdWUudG9GaXhlZCg0KSkpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGFzIHBlcmNlbnRhZ2VzXG4gICAgICAgIGxldCBsb3dlclBvc2l0aW9uID0gKCgobG93ZXJWYWx1ZSAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pIC8gKHRoaXMub3B0aW9ucy50cmFjay5tYXggLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSkgKiAxMDApO1xuICAgICAgICBsZXQgdXBwZXJQb3NpdGlvbiA9ICgoKHVwcGVyVmFsdWUgLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSAvICh0aGlzLm9wdGlvbnMudHJhY2subWF4IC0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpICogMTAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGh1bWIgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLnBvc2l0aW9uID0gbG93ZXJQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50aHVtYnMudXBwZXIucG9zaXRpb24gPSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhY2sgc2l6ZXNcbiAgICAgICAgdGhpcy50cmFja3MubG93ZXIuc2l6ZSA9IGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLm1pZGRsZS5zaXplID0gdXBwZXJQb3NpdGlvbiAtIGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLnVwcGVyLnNpemUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IDEwMCAtIGxvd2VyUG9zaXRpb24gOiAxMDAgLSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgaW5wdXRcbiAgICAgICAgdGhpcy5zZXRWYWx1ZShsb3dlclZhbHVlLCB1cHBlclZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFZhbHVlKGxvdzogbnVtYmVyLCBoaWdoPzogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPSBsb3c7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID0gaGlnaDtcblxuICAgICAgICBsZXQgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY2xvbmUodGhpcy5fdmFsdWUpO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IGxvdyA6IHsgbG93OiBsb3csIGhpZ2g6IGhpZ2ggfTtcblxuICAgICAgICAvLyBjYWxsIHRoZSBldmVudCBlbWl0dGVyIGlmIGNoYW5nZXMgb2NjdXJlZFxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCBwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KFNsaWRlclRodW1iLkxvd2VyKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQoU2xpZGVyVGh1bWIuVXBwZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIGZvcndhcmQgdGhlc2UgY2hhbmdlcyB0byB0aGUgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnRodW1icy5sb3dlci52YWx1ZSwgdGhpcy50aHVtYnMudXBwZXIudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVGlja3MoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRpY2sgb3B0aW9uc1xuICAgICAgICBjb25zdCBtYWpvck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudHJhY2sudGlja3MubWFqb3I7XG4gICAgICAgIGNvbnN0IG1pbm9yT3B0aW9ucyA9IHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5taW5vcjtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzaG91bGQgc2hvdyB0aWNrc1xuICAgICAgICBpZiAobWFqb3JPcHRpb25zLnNob3cgPT09IGZhbHNlICYmIG1pbm9yT3B0aW9ucy5zaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2tzIGZvciBib3RoIG1ham9yIGFuZCBtaW5vciAtIG9ubHkgZ2V0IHRoZSBvbmVzIHRvIGJlIHNob3duXG4gICAgICAgIGNvbnN0IG1ham9yVGlja3MgPSB0aGlzLmdldFRpY2tzKG1ham9yT3B0aW9ucywgU2xpZGVyVGlja1R5cGUuTWFqb3IpLmZpbHRlcih0aWNrID0+IHRpY2suc2hvd1RpY2tzKTtcbiAgICAgICAgY29uc3QgbWlub3JUaWNrcyA9IHRoaXMuZ2V0VGlja3MobWlub3JPcHRpb25zLCBTbGlkZXJUaWNrVHlwZS5NaW5vcikuZmlsdGVyKHRpY2sgPT4gdGljay5zaG93VGlja3MpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgbWlub3IgdGlja3MgdGhhdCBhcmUgb24gYSBtYWpvciBpbnRlcnZhbFxuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy51bmlvblRpY2tzKG1ham9yVGlja3MsIG1pbm9yVGlja3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVHJhY2tDb2xvcnMoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IGNvbG9ycyBmb3IgZWFjaCBwYXJ0IG9mIHRoZSB0cmFja1xuICAgICAgICBjb25zdCB7IGxvd2VyLCByYW5nZSwgaGlnaGVyIH0gPSB0aGlzLm9wdGlvbnMudHJhY2suY29sb3JzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29udHJvbGxlciB2YWx1ZVxuICAgICAgICB0aGlzLnRyYWNrcy5sb3dlci5jb2xvciA9IHR5cGVvZiBsb3dlciA9PT0gJ3N0cmluZycgPyBsb3dlciA6IGBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICR7bG93ZXIuam9pbignLCAnKX0pYDtcbiAgICAgICAgdGhpcy50cmFja3MubWlkZGxlLmNvbG9yID0gdHlwZW9mIHJhbmdlID09PSAnc3RyaW5nJyA/IHJhbmdlIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtyYW5nZS5qb2luKCcsICcpfSlgO1xuICAgICAgICB0aGlzLnRyYWNrcy51cHBlci5jb2xvciA9IHR5cGVvZiBoaWdoZXIgPT09ICdzdHJpbmcnID8gaGlnaGVyIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtoaWdoZXIuam9pbignLCAnKX0pYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFN0ZXBzKHN0ZXBzOiBudW1iZXIgfCBudW1iZXJbXSk6IG51bWJlcltdIHtcblxuICAgICAgICAvLyBpZiB0aGV5IGFyZSBhbHJlYWR5IGFuIGFycmF5IGp1c3QgcmV0dXJuIGl0XG4gICAgICAgIGlmIChzdGVwcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIHN0ZXBzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47IGlkeCA8PSB0aGlzLm9wdGlvbnMudHJhY2subWF4OyBpZHggKz0gc3RlcHMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGlja3Mob3B0aW9uczogU2xpZGVyVGlja09wdGlvbnMsIHR5cGU6IFNsaWRlclRpY2tUeXBlKTogU2xpZGVyVGlja1tdIHtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgdGhlIHRpY2tzIGFuZCBzdGVwIHBvaW50c1xuICAgICAgICBsZXQgc3RlcHMgPSB0aGlzLmdldFN0ZXBzKG9wdGlvbnMuc3RlcHMpO1xuXG4gICAgICAgIC8vIGdldCBzb21lIGNoYXJ0IG9wdGlvbnNcbiAgICAgICAgbGV0IG1pbiA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCBtYXggPSB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBzdGVwIHRvIGEgc2xpZGVyIHRpY2sgYW5kIHJlbW92ZSBpbnZhbGlkIHRpY2tzXG4gICAgICAgIHJldHVybiBzdGVwcy5tYXAoc3RlcCA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNob3dUaWNrczogb3B0aW9ucy5zaG93LFxuICAgICAgICAgICAgICAgIHNob3dMYWJlbHM6IG9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICgoc3RlcCAtIG1pbikgLyAobWF4IC0gbWluKSkgKiAxMDAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0ZXAsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbnMuZm9ybWF0dGVyKHN0ZXApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIodGljayA9PiB0aWNrLnBvc2l0aW9uID49IDAgJiYgdGljay5wb3NpdGlvbiA8PSAxMDApO1xuICAgIH1cblxuICAgIHByaXZhdGUgdW5pb25UaWNrcyhtYWpvclRpY2tzOiBTbGlkZXJUaWNrW10sIG1pbm9yVGlja3M6IFNsaWRlclRpY2tbXSk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCB0aWNrcyBjb21iaW5lZCByZW1vdmluZyBhbnkgbWlub3IgdGlja3Mgd2l0aCB0aGUgc2FtZSB2YWx1ZSBhcyBtYWpvciB0aWNrc1xuICAgICAgICByZXR1cm4gbWFqb3JUaWNrcy5jb25jYXQobWlub3JUaWNrcylcbiAgICAgICAgICAgIC5maWx0ZXIoKHRpY2ssIGluZGV4LCBhcnJheSkgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciB8fCAhYXJyYXkuZmluZCh0ayA9PiB0ay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciAmJiB0ay5wb3NpdGlvbiA9PT0gdGljay5wb3NpdGlvbikpXG4gICAgICAgICAgICAuc29ydCgodDEsIHQyKSA9PiB0MS52YWx1ZSAtIHQyLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlZXBNZXJnZTxUPihkZXN0aW5hdGlvbjogVCwgc291cmNlOiBUKTogVCB7XG5cbiAgICAgICAgLy8gbG9vcCB0aG91Z2ggYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHByb3BlcnR5IGFjcm9zc1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGFuZCBpcyBub3QgYW4gb2JqZWN0IHRoZW4gc2tpcFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltwcm9wXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgcHJvcGVydHkgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbltwcm9wXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIG9iamVjdCB0aGVuIHBlcmZvcm0gYSByZWN1cnNpdmUgY2hlY2tcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gdGhpcy5kZWVwTWVyZ2UoZGVzdGluYXRpb25bcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZXRlY3RWYWx1ZUNoYW5nZSh2YWx1ZTE6IG51bWJlciB8IFNsaWRlclZhbHVlLCB2YWx1ZTI6IG51bWJlciB8IFNsaWRlclZhbHVlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY29tcGFyZSB0d28gc2xpZGVyIHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMSkgJiYgdGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMikpIHtcblxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0cyBpbiB0aGUgY29ycmVjdCB0eXBlc1xuICAgICAgICAgICAgY29uc3Qgb2JqMSA9IHZhbHVlMSBhcyBTbGlkZXJWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9iajIgPSB2YWx1ZTIgYXMgU2xpZGVyVmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBvYmoxLmxvdyAhPT0gb2JqMi5sb3cgfHwgb2JqMS5oaWdoICE9PSBvYmoyLmhpZ2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3QgYSBzbGlkZXIgdmFsdWUgLSBzaG91bGQgYmUgbnVtYmVyIG9mIG51bGxhYmxlIHR5cGUgLSBjb21wYXJlIG5vcm1hbGx5XG4gICAgICAgIHJldHVybiB2YWx1ZTEgIT09IHZhbHVlMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb25mb3JtcyB0byB0aGVcbiAgICAgKiBTbGlkZXJWYWx1ZSBpbnRlcmZhY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG9iamVjdCB0byBjaGVjayAtIHRoaXMgbXVzdCBiZSB0eXBlIGFueVxuICAgICAqL1xuICAgIHByaXZhdGUgaXNTbGlkZXJWYWx1ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IGNoZWNrIGlmIGl0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgICAgICByZXR1cm4gJ2xvdycgaW4gdmFsdWUgJiYgJ2hpZ2gnIGluIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xvbmUodmFsdWU6IG51bWJlciB8IFNsaWRlclZhbHVlKTogbnVtYmVyIHwgU2xpZGVyVmFsdWUge1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIG5vdCBhbiBvYmplY3Qgc2ltcGx5IHJldHVybiB0aGUgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0geyAuLi52YWx1ZSB9O1xuXG4gICAgICAgIC8vIGRlbGV0ZSByZW1vdmUgdGhlIHZhbHVlIGZyb20gdGhlIG9sZCBvYmplY3RcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBuZXcgaW5zdGFuY2Ugb2YgdGhlIG9iamVjdFxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUeXBlIHtcbiAgICBWYWx1ZSxcbiAgICBSYW5nZVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTdHlsZSB7XG4gICAgQnV0dG9uLFxuICAgIExpbmVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyU2l6ZSB7XG4gICAgTmFycm93LFxuICAgIFdpZGVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyQ2FsbG91dFRyaWdnZXIge1xuICAgIE5vbmUsXG4gICAgSG92ZXIsXG4gICAgRHJhZyxcbiAgICBQZXJzaXN0ZW50LFxuICAgIER5bmFtaWNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJWYWx1ZSB7XG4gICAgbG93OiBudW1iZXI7XG4gICAgaGlnaDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTbmFwIHtcbiAgICBOb25lLFxuICAgIE1pbm9yLFxuICAgIE1ham9yLFxuICAgIEFsbFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaWNrVHlwZSB7XG4gICAgTWlub3IsXG4gICAgTWFqb3Jcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJPcHRpb25zIHtcbiAgICB0eXBlPzogU2xpZGVyVHlwZTtcbiAgICBoYW5kbGVzPzogU2xpZGVySGFuZGxlT3B0aW9ucztcbiAgICB0cmFjaz86IFNsaWRlclRyYWNrT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJIYW5kbGVPcHRpb25zIHtcbiAgICBzdHlsZT86IFNsaWRlclN0eWxlO1xuICAgIGNhbGxvdXQ/OiBTbGlkZXJDYWxsb3V0O1xuICAgIGtleWJvYXJkPzogU2xpZGVyS2V5Ym9hcmRPcHRpb25zO1xuICAgIGFyaWE/OiBTbGlkZXJBcmlhT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJBcmlhT3B0aW9ucyB7XG4gICAgdGh1bWI6IHN0cmluZztcbiAgICBsb3dlclRodW1iOiBzdHJpbmc7XG4gICAgdXBwZXJUaHVtYjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlcktleWJvYXJkT3B0aW9ucyB7XG4gICAgbWFqb3I/OiBudW1iZXI7XG4gICAgbWlub3I/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVHJhY2tPcHRpb25zIHtcbiAgICBoZWlnaHQ/OiBTbGlkZXJTaXplO1xuICAgIG1pbj86IG51bWJlcjtcbiAgICBtYXg/OiBudW1iZXI7XG4gICAgdGlja3M/OiBTbGlkZXJUaWNrc09wdGlvbnM7XG4gICAgY29sb3JzPzogU2xpZGVyVHJhY2tDb2xvcnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja3NPcHRpb25zIHtcbiAgICBzbmFwPzogU2xpZGVyU25hcDtcbiAgICBtYWpvcj86IFNsaWRlclRpY2tPcHRpb25zO1xuICAgIG1pbm9yPzogU2xpZGVyVGlja09wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja09wdGlvbnMge1xuICAgIHNob3c/OiBib29sZWFuO1xuICAgIHN0ZXBzPzogbnVtYmVyIHwgbnVtYmVyW107XG4gICAgbGFiZWxzPzogYm9vbGVhbjtcbiAgICBmb3JtYXR0ZXI/OiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRpY2sge1xuICAgIHNob3dUaWNrczogYm9vbGVhbjtcbiAgICBzaG93TGFiZWxzOiBib29sZWFuO1xuICAgIHR5cGU6IFNsaWRlclRpY2tUeXBlO1xuICAgIHBvc2l0aW9uOiBudW1iZXI7XG4gICAgdmFsdWU6IG51bWJlcjtcbiAgICBsYWJlbDogc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRyYWNrQ29sb3JzIHtcbiAgICBsb3dlcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHJhbmdlPzogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgaGlnaGVyPzogc3RyaW5nIHwgc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyQ2FsbG91dCB7XG4gICAgdHJpZ2dlcj86IFNsaWRlckNhbGxvdXRUcmlnZ2VyO1xuICAgIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gICAgY29sb3I/OiBzdHJpbmc7XG4gICAgZm9ybWF0dGVyPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyVGh1bWJFdmVudCB7XG4gICAgTm9uZSxcbiAgICBNb3VzZU92ZXIsXG4gICAgTW91c2VMZWF2ZSxcbiAgICBEcmFnU3RhcnQsXG4gICAgRHJhZ0VuZFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaHVtYiB7XG4gICAgTG93ZXIsXG4gICAgVXBwZXJcbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcblxuaW1wb3J0IHsgU2xpZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGUsXG4gICAgICAgIERyYWdNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTbGlkZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NsaWRlckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyTW9kdWxlIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5pbXBvcnQgeyBDb2xvcklkZW50aWZpZXIgfSBmcm9tICcuLi8uLi9pbmRleCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc3BhcmsnLFxuICAgIHRlbXBsYXRlOiBgPCEtLSBJbmxpbmUgU3BhcmsgQ2hhcnQgLS0+XG48ZGl2ICpuZ0lmPVwiaW5saW5lTGFiZWxcIiBjbGFzcz1cInV4LXNwYXJrLWlubGluZS1sYWJlbC1jb250YWluZXJcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1pbmxpbmUtbGFiZWwtbGVmdFwiIFtpbm5lckh0bWxdPVwiaW5saW5lTGFiZWxcIj48L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1saW5lXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLXRvcC1jb250YWluZXJcIiAqbmdJZj1cInRvcExlZnRMYWJlbCB8fCB0b3BSaWdodExhYmVsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtdG9wLWxlZnRcIiAqbmdJZj1cInRvcExlZnRMYWJlbFwiIFtpbm5lckh0bWxdPVwidG9wTGVmdExhYmVsXCI+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtdG9wLXJpZ2h0XCIgKm5nSWY9XCJ0b3BSaWdodExhYmVsXCIgW2lubmVySHRtbF09XCJ0b3BSaWdodExhYmVsXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyayB1eC1pbmxpbmUgdXgtc3BhcmstdGhlbWUte3t0aGVtZX19XCIgW3N0eWxlLmhlaWdodC5weF09XCJiYXJIZWlnaHRcIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cInRyYWNrQ29sb3JcIiBbdXhUb29sdGlwXT1cInRvb2x0aXBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1iYXJcIiAqbmdGb3I9XCJsZXQgbGluZSBvZiB2YWx1ZXM7IGxldCBpZHggPSBpbmRleDtcIiBbc3R5bGUud2lkdGguJV09XCJsaW5lXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJiYXJDb2xvcltpZHhdXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1ib3R0b20tY29udGFpbmVyXCIgKm5nSWY9XCJib3R0b21MZWZ0TGFiZWwgfHwgYm90dG9tUmlnaHRMYWJlbFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLWJvdHRvbS1sZWZ0XCIgKm5nSWY9XCJib3R0b21MZWZ0TGFiZWxcIiBbaW5uZXJIdG1sXT1cImJvdHRvbUxlZnRMYWJlbFwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLWJvdHRvbS1yaWdodFwiICpuZ0lmPVwiYm90dG9tUmlnaHRMYWJlbFwiIFtpbm5lckh0bWxdPVwiYm90dG9tUmlnaHRMYWJlbFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjwhLS0gRW5kIElubGluZSBTcGFyayBDaGFydCAtLT5cblxuXG48IS0tIE5vbiBJbmxpbmUgU3BhcmsgQ2hhcnQgLS0+XG48ZGl2ICpuZ0lmPVwiIWlubGluZUxhYmVsXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstdG9wLWNvbnRhaW5lclwiICpuZ0lmPVwidG9wTGVmdExhYmVsIHx8IHRvcFJpZ2h0TGFiZWxcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLXRvcC1sZWZ0XCIgKm5nSWY9XCJ0b3BMZWZ0TGFiZWxcIiBbaW5uZXJIdG1sXT1cInRvcExlZnRMYWJlbFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtdG9wLXJpZ2h0XCIgKm5nSWY9XCJ0b3BSaWdodExhYmVsXCIgW2lubmVySHRtbF09XCJ0b3BSaWdodExhYmVsXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmsgdXgtc3BhcmstdGhlbWUte3t0aGVtZX19XCIgW2NsYXNzLnV4LXNwYXJrLW11bHRpLXZhbHVlXT1cInZhbHVlcy5sZW5ndGggPiAxXCIgW3N0eWxlLmhlaWdodC5weF09XCJiYXJIZWlnaHRcIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cInRyYWNrQ29sb3JcIlxuICAgICAgICBbdXhUb29sdGlwXT1cInRvb2x0aXBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWJhclwiICpuZ0Zvcj1cImxldCBsaW5lIG9mIHZhbHVlOyBsZXQgaWR4ID0gaW5kZXg7XCIgW3N0eWxlLndpZHRoLiVdPVwibGluZVwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiYmFyQ29sb3JbaWR4XVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWJvdHRvbS1jb250YWluZXJcIiAqbmdJZj1cImJvdHRvbUxlZnRMYWJlbCB8fCBib3R0b21SaWdodExhYmVsXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1sYWJlbC1ib3R0b20tbGVmdFwiICpuZ0lmPVwiYm90dG9tTGVmdExhYmVsXCIgW2lubmVySHRtbF09XCJib3R0b21MZWZ0TGFiZWxcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLWJvdHRvbS1yaWdodFwiICpuZ0lmPVwiYm90dG9tUmlnaHRMYWJlbFwiIFtpbm5lckh0bWxdPVwiYm90dG9tUmlnaHRMYWJlbFwiPjwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjwhLS0gRW5kIE5vbiBJbmxpbmUgU3BhcmsgQ2hhcnQgLS0+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTcGFya0NvbXBvbmVudCB7XG5cbiAgICB2YWx1ZXM6IG51bWJlcltdID0gW107XG5cbiAgICBASW5wdXQoKSBiYXJIZWlnaHQ6IG51bWJlciA9IDEwO1xuICAgIEBJbnB1dCgpIGlubGluZUxhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgdG9wTGVmdExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgdG9wUmlnaHRMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGJvdHRvbUxlZnRMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGJvdHRvbVJpZ2h0TGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b29sdGlwOiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIF90cmFja0NvbG9yOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfdGhlbWU6IENvbG9ySWRlbnRpZmllciA9ICdwcmltYXJ5JzsgICAgXG4gICAgcHJpdmF0ZSBfYmFyQ29sb3I6IHN0cmluZyB8IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgQElucHV0KCkgXG4gICAgc2V0IHRoZW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdGhlbWUgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZUNvbG9yTmFtZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHRoZW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVtZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBcbiAgICBzZXQgdHJhY2tDb2xvcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrQ29sb3IgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHRyYWNrQ29sb3IoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrQ29sb3I7XG4gICAgfVxuXG4gICAgQElucHV0KCkgXG4gICAgc2V0IGJhckNvbG9yKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fYmFyQ29sb3IgPSB2YWx1ZS5tYXAoY29sb3IgPT4gdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUoY29sb3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JhckNvbG9yID0gW3RoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKHZhbHVlKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYmFyQ29sb3IoKTogc3RyaW5nIHwgc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFyQ29sb3I7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgdmFsdWUodmFsdWU6IG51bWJlciB8IG51bWJlcltdKSB7XG5cbiAgICAgICAgLy8gZW5zdXJlICd2YWx1ZScgaXMgYW4gYXJyYXkgYXQgdGhpcyBwb2ludFxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcblxuICAgICAgICAvLyBnZXQgdGhlIHRvdGFsIHZhbHVlIG9mIGFsbCBsaW5lc1xuICAgICAgICBjb25zdCB0b3RhbCA9IE1hdGgubWF4KHZhbHVlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBwcmV2aW91cyArIGN1cnJlbnQsIDApLCAxMDApO1xuXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIHBlcmNlbnRhZ2VzIGZvciBlYWNoIHNwYXJrIGxpbmVcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXMubWFwKHZhbCA9PiAodmFsIC8gdG90YWwpICogMTAwKTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcztcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb2xvclNlcnZpY2U6IENvbG9yU2VydmljZSkgeyB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFNwYXJrQ29tcG9uZW50IH0gZnJvbSAnLi9zcGFyay5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTcGFya0NvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbU3BhcmtDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFNwYXJrTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIvdGFiLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUYWJzZXRTZXJ2aWNlIHtcblxuICAgIHRhYnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUYWJDb21wb25lbnRbXT4oW10pO1xuICAgIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRhYkNvbXBvbmVudD4obnVsbCk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBoaWdobGlnaHRlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRhYkNvbXBvbmVudD4obnVsbCk7XG5cbiAgICBhZGQodGFiOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YWJzJC5uZXh0KFsuLi50aGlzLnRhYnMkLnZhbHVlLCB0YWJdKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHRoZSBvbmx5IHRhYi4gSWYgc28gc2VsZWN0IHRoaXMgYnkgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlJC52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGFiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZSh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdGFiXG4gICAgICAgIHRoaXMudGFicyQubmV4dCh0aGlzLnRhYnMkLnZhbHVlLmZpbHRlcihfdGFiID0+IF90YWIgIT09IHRhYikpO1xuICAgIH1cblxuICAgIHNlbGVjdCh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUkLm5leHQodGFiKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQodGFiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdEF0SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB0YWJzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy50YWJzJC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbmRleCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RBdEluZGV4KHRoaXMudGFicyQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gdGhpcy50YWJzJC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEF0SW5kZXgoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhYnMkLnZhbHVlW2luZGV4XTtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0TmV4dFRhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5pbmRleE9mKHRoaXMuYWN0aXZlJC52YWx1ZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgdGhlIHRhYnMgYWZ0ZXIgdGhlIGFjdGl2ZSBvbmUgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0YWJsZSB0YWJzXG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMkLnZhbHVlLnNsaWNlKGluZGV4ICsgMSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IG9mIHRoZSB0YWJzIGFyZSBub3QgZGlzYWJsZWRcbiAgICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgICAgIGlmICghdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHRhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSByZWFjaCBoZXJlIHRoZW4gbm8gdGFiIGNvdWxkIGJlIHNlbGVjdGVkIC0gc2VsZWN0IHRoZSBmaXJzdCB0YWJcbiAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFRhYigpO1xuICAgIH1cblxuICAgIHNlbGVjdFByZXZpb3VzVGFiKCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLmluZGV4T2YodGhpcy5hY3RpdmUkLnZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0aGUgdGFicyBiZWZvcmUgdGhlIGFjdGl2ZSBvbmUgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0YWJsZSB0YWJzXG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMkLnZhbHVlLnNsaWNlKDAsIGluZGV4KTtcblxuICAgICAgICAvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHRhYnMgYXJlIG5vdCBkaXNhYmxlZFxuICAgICAgICBmb3IgKGxldCB0YWIgb2YgdGFicy5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGlmICghdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHRhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSByZWFjaCBoZXJlIHRoZW4gbm8gcHJldmlvdXMgdGFiIGNvdWxkIGJlIHNlbGVjdGVkIC0gc2VsZWN0IHRoZSBsYXN0IHRhYlxuICAgICAgICB0aGlzLnNlbGVjdExhc3RUYWIoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RGaXJzdFRhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCB0YWJcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLmZpbmRJbmRleCh0YWIgPT4gIXRhYi5kaXNhYmxlZCk7XG5cbiAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RBdEluZGV4KHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdExhc3RUYWIoKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgdGFiXG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5zbGljZSgpLnJldmVyc2UoKS5maW5kSW5kZXgodGFiID0+ICF0YWIuZGlzYWJsZWQpO1xuXG4gICAgICAgIGlmICh0YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QXRJbmRleCgodGhpcy50YWJzJC52YWx1ZS5sZW5ndGggLSAxKSAtIHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn0gIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuLi90YWJzZXQuc2VydmljZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRhYkZvY3VzXSdcbn0pXG5leHBvcnQgY2xhc3MgVGFiRm9jdXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB1eFRhYkZvY3VzOiBUYWJDb21wb25lbnQ7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYnNldDogVGFic2V0U2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fdGFic2V0LmhpZ2hsaWdodGVkJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3RhYnNldC5mb2N1c2VkJC52YWx1ZSA9PT0gdHJ1ZSksXG4gICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fdGFic2V0LmhpZ2hsaWdodGVkJC52YWx1ZSA9PT0gdGhpcy51eFRhYkZvY3VzKSxcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuLi90YWJzZXQuc2VydmljZSc7XG5cbmxldCB1bmlxdWVUYWJJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtdGFiJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgcm9sZT1cInRhYnBhbmVsXCJcbiAgICAgY2xhc3M9XCJ0YWItcGFuZVwiXG4gICAgIFtjbGFzcy5hY3RpdmVdPVwiYWN0aXZlJCB8IGFzeW5jXCJcbiAgICAgW2lkXT1cImlkICsgJy1wYW5lbCdcIlxuICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiaWRcIlxuICAgICBbYXR0ci5hcmlhLWhpZGRlbl09XCIhKGFjdGl2ZSQgfCBhc3luYylcIj5cbiAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBUYWJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZyA9IGB1eC10YWItJHsrK3VuaXF1ZVRhYklkfWA7XG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBoZWFkaW5nOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY3VzdG9tQ2xhc3M6IHN0cmluZztcblxuICAgIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIGRlc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgQElucHV0KCkgc2V0IGFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYnNldC5zZWxlY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoZWFkaW5nUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIGFjdGl2ZSQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLl90YWJzZXQuYWN0aXZlJC5waXBlKG1hcChhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzKSk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYnNldDogVGFic2V0U2VydmljZSkge1xuICAgICAgICBfdGFic2V0LmFkZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLmFjdGl2ZSQuc3Vic2NyaWJlKGFjdGl2ZSA9PiBhY3RpdmUgPyB0aGlzLnNlbGVjdC5lbWl0KCkgOiB0aGlzLmRlc2VsZWN0LmVtaXQoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhYnNldC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiLmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VGFiSGVhZGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIFRhYkhlYWRpbmdEaXJlY3RpdmUge1xuXG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIHRhYjogVGFiQ29tcG9uZW50KSB7XG4gICAgICAgIHRhYi5oZWFkaW5nUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiL3RhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGFic2V0U2VydmljZSB9IGZyb20gJy4vdGFic2V0LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRhYnNldCcsXG4gICAgdGVtcGxhdGU6IGA8IS0tIE5hdiB0YWJzIC0tPlxuPHVsIHJvbGU9XCJ0YWJsaXN0XCJcbiAgICBjbGFzcz1cIm5hdiBuYXYtdGFic1wiXG4gICAgW2NsYXNzLm1pbmltYWwtdGFiXT1cIm1pbmltYWxcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcbiAgICBbYXR0ci5hcmlhLW9yaWVudGF0aW9uXT1cInN0YWNrZWQgPT09ICdub25lJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCdcIj5cblxuXHQ8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiIFxuICAgICAgICBjbGFzcz1cIm5hdi1pdGVtXCJcbiAgICAgICAgKm5nRm9yPVwibGV0IHRhYiBvZiB0YWJzZXQudGFicyQgfCBhc3luYzsgbGV0IGluZGV4ID0gaW5kZXhcIlxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cInRhYi5hY3RpdmUkIHwgYXN5bmNcIlxuICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwidGFiLmRpc2FibGVkXCJcbiAgICAgICAgW25nQ2xhc3NdPVwidGFiLmN1c3RvbUNsYXNzXCI+XG5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiXG4gICAgICAgICAgICBbaWRdPVwidGFiLmlkXCJcbiAgICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgICAgW3V4VGFiRm9jdXNdPVwidGFiXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCIodGFiLmFjdGl2ZSQgfCBhc3luYykgPyAwIDogLTFcIlxuICAgICAgICAgICAgW2NsYXNzLmhpZ2hsaWdodGVkXT1cIih0YWJzZXQuZm9jdXNlZCQgfCBhc3luYykgJiYgKHRhYnNldC5oaWdobGlnaHRlZCQgfCBhc3luYykgPT09IHRhYlwiICAgICAgICAgICAgXG4gICAgICAgICAgICAobW91c2Vkb3duKT1cInRhYnNldC5zZWxlY3QodGFiKVwiXG4gICAgICAgICAgICAoZm9jdXMpPVwidGFic2V0LmZvY3VzZWQkLm5leHQodHJ1ZSlcIlxuICAgICAgICAgICAgKGJsdXIpPVwidGFic2V0LmZvY3VzZWQkLm5leHQoZmFsc2UpXCJcbiAgICAgICAgICAgIChtb3VzZWRvd24pPVwidGFic2V0LmZvY3VzZWQkLm5leHQodHJ1ZSlcIlxuICAgICAgICAgICAgKGtleWRvd24uQXJyb3dVcCk9XCJzZWxlY3RQcmV2aW91c1RhYigkZXZlbnQpXCJcbiAgICAgICAgICAgIChrZXlkb3duLkFycm93TGVmdCk9XCJzZWxlY3RQcmV2aW91c1RhYigkZXZlbnQpXCJcbiAgICAgICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwic2VsZWN0TmV4dFRhYigkZXZlbnQpXCJcbiAgICAgICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJzZWxlY3ROZXh0VGFiKCRldmVudClcIlxuICAgICAgICAgICAgKGtleWRvd24uSG9tZSk9XCJ0YWJzZXQuc2VsZWN0Rmlyc3RUYWIoKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgKGtleWRvd24uRW5kKT1cInRhYnNldC5zZWxlY3RMYXN0VGFiKCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY29udHJvbHNdPVwidGFiLmlkXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwidGFiLmFjdGl2ZSQgfCBhc3luY1wiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cInRhYi5kaXNhYmxlZFwiPlxuXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiF0YWIuaGVhZGluZ1JlZlwiPnt7IHRhYi5oZWFkaW5nIH19PC9zcGFuPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidGFiLmhlYWRpbmdSZWZcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWIuaGVhZGluZ1JlZlwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2E+XG5cblx0PC9saT5cblxuPC91bD5cblxuPCEtLSBUYWIgcGFuZXMgLS0+XG48ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRcIj5cblx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcm92aWRlcnM6IFtUYWJzZXRTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MudGFicy1sZWZ0XSc6ICdzdGFja2VkID09PSBcImxlZnRcIicsXG4gICAgICAgICdbY2xhc3MudGFicy1yaWdodF0nOiAnc3RhY2tlZCA9PT0gXCJyaWdodFwiJyxcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFRhYnNldENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBtaW5pbWFsOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzdGFja2VkOiAnbGVmdCcgfCAncmlnaHQnIHwgJ25vbmUnID0gJ25vbmUnO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHRhYnNldDogVGFic2V0U2VydmljZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyBtYW51YWwgdGFiIHNlbGVjdGVkXG4gICAgICovXG4gICAgc2VsZWN0KHRhYjogVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMudGFic2V0LnNlbGVjdCh0YWIpO1xuICAgIH1cblxuICAgIHNlbGVjdFByZXZpb3VzVGFiKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGFycm93IGtleSBpcyBwcmVzc2VkXG4gICAgICAgIGNvbnN0IGFycm93TGVmdCA9IGV2ZW50LmtleSA9PT0gJ0Fycm93TGVmdCcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzc7XG4gICAgICAgIGNvbnN0IGFycm93VXAgPSBldmVudC5rZXkgPT09ICdBcnJvd1VwJyB8fCBldmVudC5rZXlDb2RlID09PSAzODtcblxuICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWN0aW9uIGlmIHRoZSBhcnJvdyBrZXkgbWF0Y2hlcyB0aGUgb3JpZW50YXRpb25cbiAgICAgICAgaWYgKGFycm93TGVmdCAmJiB0aGlzLnN0YWNrZWQgIT09ICdub25lJyB8fCBhcnJvd1VwICYmIHRoaXMuc3RhY2tlZCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnRhYnNldC5zZWxlY3RQcmV2aW91c1RhYigpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcgd2hlbiBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgc2VsZWN0TmV4dFRhYihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBhcnJvdyBrZXkgaXMgcHJlc3NlZFxuICAgICAgICBjb25zdCBhcnJvd1JpZ2h0ID0gZXZlbnQua2V5ID09PSAnQXJyb3dSaWdodCcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzk7XG4gICAgICAgIGNvbnN0IGFycm93RG93biA9IGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHwgZXZlbnQua2V5Q29kZSA9PT0gNDA7XG5cbiAgICAgICAgLy8gb25seSBwZXJmb3JtIGFjdGlvbiBpZiB0aGUgYXJyb3cga2V5IG1hdGNoZXMgdGhlIG9yaWVudGF0aW9uXG4gICAgICAgIGlmIChhcnJvd1JpZ2h0ICYmIHRoaXMuc3RhY2tlZCAhPT0gJ25vbmUnIHx8IGFycm93RG93biAmJiB0aGlzLnN0YWNrZWQgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy50YWJzZXQuc2VsZWN0TmV4dFRhYigpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcgd2hlbiBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGFiRm9jdXNEaXJlY3RpdmUgfSBmcm9tICcuL3RhYi90YWItZm9jdXMuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRhYkhlYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL3RhYi90YWItaGVhZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIvdGFiLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUYWJzZXRDb21wb25lbnQgfSBmcm9tICcuL3RhYnNldC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVGFic2V0Q29tcG9uZW50LCBUYWJDb21wb25lbnQsIFRhYkhlYWRpbmdEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW1RhYnNldENvbXBvbmVudCwgVGFiQ29tcG9uZW50LCBUYWJIZWFkaW5nRGlyZWN0aXZlLCBUYWJGb2N1c0RpcmVjdGl2ZV0sXG59KVxuZXhwb3J0IGNsYXNzIFRhYnNldE1vZHVsZSB7IH0iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10aW1lbGluZScsXHJcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ0aW1lbGluZVwiPlxyXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxyXG48L2Rpdj5cclxuYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGltZWxpbmVDb21wb25lbnQge1xyXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXRpbWVsaW5lLWV2ZW50JyxcclxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInRpbWVsaW5lLWJhZGdlXCIgW25nQ2xhc3NdPVwiYmFkZ2VDb2xvclwiPlxyXG4gICAgPHNwYW4+e3tiYWRnZVRpdGxlfX08L3NwYW4+XHJcbjwvZGl2PlxyXG48ZGl2IGNsYXNzPVwidGltZWxpbmUtcGFuZWxcIj5cclxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuPC9kaXY+XHJcbmBcclxufSlcclxuZXhwb3J0IGNsYXNzIFRpbWVsaW5lRXZlbnRDb21wb25lbnQge1xyXG5cclxuICAgIEBJbnB1dCgpIGJhZGdlQ29sb3I6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGJhZGdlVGl0bGU6IHN0cmluZztcclxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IFRpbWVsaW5lQ29tcG9uZW50IH0gZnJvbSAnLi90aW1lbGluZS5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBUaW1lbGluZUV2ZW50Q29tcG9uZW50IH0gZnJvbSAnLi90aW1lbGluZS1ldmVudC90aW1lbGluZS1ldmVudC5jb21wb25lbnQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGVcclxuICAgIF0sXHJcbiAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgVGltZWxpbmVDb21wb25lbnQsXHJcbiAgICAgICAgVGltZWxpbmVFdmVudENvbXBvbmVudFxyXG4gICAgXSxcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIFRpbWVsaW5lQ29tcG9uZW50LFxyXG4gICAgICAgIFRpbWVsaW5lRXZlbnRDb21wb25lbnRcclxuICAgIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIFRpbWVsaW5lTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5jb25zdCBUT0dHTEVTV0lUQ0hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVG9nZ2xlU3dpdGNoQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxubGV0IHVuaXF1ZVRvZ2dsZVN3aXRjaElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10b2dnbGVzd2l0Y2gnLFxuICAgIHRlbXBsYXRlOiBgPGxhYmVsIFthdHRyLmZvcl09XCJpbnB1dElkXCJcbiAgICAgICBjbGFzcz1cInV4LXRvZ2dsZXN3aXRjaFwiXG4gICAgICAgW2NsYXNzLnV4LXRvZ2dsZXN3aXRjaC1jaGVja2VkXT1cInZhbHVlXCJcbiAgICAgICBbY2xhc3MudXgtdG9nZ2xlc3dpdGNoLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbY2xhc3MudXgtdG9nZ2xlc3dpdGNoLWZvY3VzZWRdPVwiZm9jdXNlZFwiPlxuXG4gICAgPGlucHV0IGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoLWlucHV0XCJcbiAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgcm9sZT1cInN3aXRjaFwiXG4gICAgICAgICAgIFtpZF09XCJpbnB1dElkXCJcbiAgICAgICAgICAgW2NoZWNrZWRdPVwidmFsdWVcIlxuICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiaW5kZXhcIlxuICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG4gICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG4gICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJ2YWx1ZVwiXG4gICAgICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgICAgIChibHVyKT1cImZvY3VzZWQgPSBmYWxzZVwiXG4gICAgICAgICAgIChjaGFuZ2UpPVwidG9nZ2xlKClcIlxuICAgICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoLWJnXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC10b2dnbGVzd2l0Y2gtbnViXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8c3BhbiBjbGFzcz1cInV4LXRvZ2dsZXN3aXRjaC1sYWJlbFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9zcGFuPlxuPC9sYWJlbD5gLFxuICAgIHByb3ZpZGVyczogW1RPR0dMRVNXSVRDSF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfdG9nZ2xlU3dpdGNoSWQ6IHN0cmluZyA9IGB1eC10b2dnbGVzd2l0Y2gtJHsrK3VuaXF1ZVRvZ2dsZVN3aXRjaElkfWA7XG5cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nID0gdGhpcy5fdG9nZ2xlU3dpdGNoSWQ7XG4gICAgQElucHV0KCkgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBjbGlja2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmcgPSAnJztcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmcgPSBudWxsO1xuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB2YWx1ZSBvdXRwdXRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcblxuICAgICAgICAvLyBOb3RpZnkgbmdNb2RlbFxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZ2V0IGlucHV0SWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fdG9nZ2xlU3dpdGNoSWR9LWlucHV0YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gKCkgPT4geyB9O1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gISF2YWx1ZTtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IH0gZnJvbSAnLi90b2dnbGVzd2l0Y2guY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbIEZvcm1zTW9kdWxlIF0sXG4gICAgZXhwb3J0czogWyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFsgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IF1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VG9vbGJhclNlYXJjaEJ1dHRvbl0nXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmUge1xuXG4gICAgQE91dHB1dCgpXG4gICAgY2xpY2tlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIGNsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5jbGlja2VkLmVtaXQoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBPcHRpb25hbCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ01vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5jb25zdCBLRVlTID0ge1xuICAgIEVOVEVSOiAxMyxcbiAgICBFU0NBUEU6IDI3XG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRvb2xiYXJTZWFyY2hGaWVsZF0nXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSB7XG5cbiAgICBAT3V0cHV0KClcbiAgICBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIGdldCB0ZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIC8vIFVzZSBuZ01vZGVsIGlmIHNwZWNpZmllZCBvbiB0aGUgaG9zdDsgb3RoZXJ3aXNlIHJlYWQgdGhlIERPTVxuICAgICAgICBpZiAodGhpcy5fbmdNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25nTW9kZWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9uZ01vZGVsOiBOZ01vZGVsKSB7IH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBibHVyKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICAvLyBVc2UgbmdNb2RlbCBpZiBzcGVjaWZpZWQgb24gdGhlIGhvc3Q7IG90aGVyd2lzZSB1c2UgdGhlIERPTVxuICAgICAgICBpZiAodGhpcy5fbmdNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5fbmdNb2RlbC5yZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlTLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXQuZW1pdCh0aGlzLnRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlTLkVTQ0FQRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25FdmVudCwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2NvbG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWZpZWxkLmRpcmVjdGl2ZSc7XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10b29sYmFyLXNlYXJjaCcsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ2V4cGFuZGVkJywgW1xuICAgICAgICAgICAgc3RhdGUoXG4gICAgICAgICAgICAgICAgJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJ3t7aW5pdGlhbFdpZHRofX0nXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgaW5pdGlhbFdpZHRoOiAnMzBweCcgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzdGF0ZShcbiAgICAgICAgICAgICAgICAnZXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignY29sbGFwc2VkIDw9PiBleHBhbmRlZCcsIFthbmltYXRlKCcwLjNzIGVhc2Utb3V0JyldKVxuICAgICAgICBdKVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5leHBhbmRlZCcpXG4gICAgQElucHV0KClcbiAgICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgICB9XG5cbiAgICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWQgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBpbnB1dCB3aGVuIGV4cGFuZGVkXG4gICAgICAgICAgICB0aGlzLmZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0ZXh0IHdoZW4gY29udHJhY3RlZFxuICAgICAgICAgICAgdGhpcy5maWVsZC5jbGVhcigpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZm9jdXMgKHdvcmtzIGFyb3VuZCBhbiBJRSBpc3N1ZSB3aGVyZSB0aGUgY2FyZXQgcmVtYWlucyB2aXNpYmxlKVxuICAgICAgICAgICAgdGhpcy5maWVsZC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyA9ICdyaWdodCc7XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaW52ZXJzZScpXG4gICAgaW52ZXJzZSA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgYmFja2dyb3VuZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUodmFsdWUpIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpXG4gICAgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzZWFyY2ggPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIHByaXZhdGUgX2V4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASG9zdEJpbmRpbmcoJ0BleHBhbmRlZCcpXG4gICAgZ2V0IGV4cGFuZGVkQW5pbWF0aW9uKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5leHBhbmRlZCA/ICdleHBhbmRlZCcgOiAnY29sbGFwc2VkJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGluaXRpYWxXaWR0aDogdGhpcy5idXR0b24ud2lkdGggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5wb3NpdGlvbicpIHBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmJhY2tncm91bmQtY29sb3InKSBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgIEBDb250ZW50Q2hpbGQoVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlKSBmaWVsZDogVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlO1xuICAgIEBDb250ZW50Q2hpbGQoVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSkgYnV0dG9uOiBUb29sYmFyU2VhcmNoQnV0dG9uRGlyZWN0aXZlO1xuXG4gICAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHN1Ym1pdCBldmVudCBvbiB0aGUgaW5wdXQgZmllbGQsIHRyaWdnZXJpbmcgdGhlIHNlYXJjaCBldmVudFxuICAgICAgICB0aGlzLmZpZWxkLnN1Ym1pdC5zdWJzY3JpYmUoKHRleHQ6IHN0cmluZykgPT4gdGhpcy5zZWFyY2guZW1pdCh0ZXh0KSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNhbmNlbCBldmVudHMgY29taW5nIGZyb20gdGhlIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuZmllbGQuY2FuY2VsLnN1YnNjcmliZSgoKSA9PiB0aGlzLmV4cGFuZGVkID0gZmFsc2UpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgYnV0dG9uIGNsaWNrIGV2ZW50XG4gICAgICAgIHRoaXMuYnV0dG9uLmNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZGVkICYmIHRoaXMuZmllbGQudGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLmVtaXQodGhpcy5maWVsZC50ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgZWxlbWVudCB0byBhdm9pZCBjaGFuZ2luZyBsYXlvdXQgd2hlbiBzd2l0Y2hpbmcgdG8gcG9zaXRpb246IGFic29sdXRlXG4gICAgICAgIHRoaXMuY3JlYXRlUGxhY2Vob2xkZXIoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdAZXhwYW5kZWQuc3RhcnQnLCBbJyRldmVudCddKVxuICAgIGFuaW1hdGlvblN0YXJ0KGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ2V4cGFuZGVkJykge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignQGV4cGFuZGVkLmRvbmUnLCBbJyRldmVudCddKVxuICAgIGFuaW1hdGlvbkRvbmUoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAnY29sbGFwc2VkJykge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlUGxhY2Vob2xkZXIoKSB7XG4gICAgICAgIC8vIEdldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBpbnZpc2libGUgZGl2IHdpdGggdGhlIHNhbWUgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS53aWR0aCA9IHRoaXMuYnV0dG9uLndpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUuaGVpZ2h0ID0gc3R5bGVzLmhlaWdodDtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICAgIC8vIEFkZCBhcyBhIHNpYmxpbmdcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX3BsYWNlaG9sZGVyLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW5hYmxlUGxhY2Vob2xkZXIoZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gKGVuYWJsZWQgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hDb21wb25lbnQgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtZmllbGQuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtYnV0dG9uLmRpcmVjdGl2ZSc7XHJcblxyXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXHJcbiAgICBUb29sYmFyU2VhcmNoQ29tcG9uZW50LFxyXG4gICAgVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlLFxyXG4gICAgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZVxyXG5dO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGVcclxuICAgIF0sXHJcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXHJcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OUyxcclxuICAgIHByb3ZpZGVyczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUb29sYmFyU2VhcmNoTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IFxuICAgIHNlbGVjdG9yOiAnW3V4VmlydHVhbFNjcm9sbExvYWRpbmddJyBcbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VmlydHVhbFNjcm9sbExvYWRCdXR0b25dJyBcbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eFZpcnR1YWxTY3JvbGxDZWxsXScgXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIHtcblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCwgSW5wdXQsIEhvc3RMaXN0ZW5lciwgRWxlbWVudFJlZiwgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkLCBUZW1wbGF0ZVJlZiwgT25EZXN0cm95LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXZpcnR1YWwtc2Nyb2xsJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ2aXJ0dWFsLXNjcm9sbC1jb250ZW50LWhlaWdodFwiIFtzdHlsZS5oZWlnaHQucHhdPVwiZ2V0VG90YWxIZWlnaHQoKVwiPjwvZGl2PlxuPGRpdiBjbGFzcz1cInZpcnR1YWwtc2Nyb2xsLWNvbnRlbnRcIiBbc3R5bGUudHJhbnNmb3JtXT1cIid0cmFuc2xhdGVZKCcgKyBzY3JvbGxUb3AgKyAncHgpJ1wiPlxuXG4gICAgPCEtLSBWaXJ0dWFsbHkgUmVuZGVyIENlbGxzIC0tPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNlbGwgb2YgY2VsbHMgfCBhc3luY1wiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY2VsbFRlbXBsYXRlOyBjb250ZXh0OiB7IGNlbGw6IGNlbGwgfVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgPCEtLSBMb2FkaW5nIEluZGljYXRvciAtLT5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibG9hZGluZ0luZGljYXRvclRlbXBsYXRlICYmIGlzTG9hZGluZ1wiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuXG4gICAgPCEtLSBMb2FkaW5nIEJ1dHRvbiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b25cIiAqbmdJZj1cImxvYWRCdXR0b25UZW1wbGF0ZSAmJiAhbG9hZE9uU2Nyb2xsICYmICFsb2FkaW5nQ29tcGxldGUgJiYgIWlzTG9hZGluZ1wiIChjbGljayk9XCJsb2FkTmV4dFBhZ2UoKVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibG9hZEJ1dHRvblRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gICAgXG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBjb2xsZWN0aW9uOiBPYnNlcnZhYmxlPGFueVtdPiA9IE9ic2VydmFibGUuY3JlYXRlKCk7XG4gICAgQElucHV0KCkgY2VsbEhlaWdodDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIGxvYWRPblNjcm9sbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBAT3V0cHV0KCkgbG9hZGluZzogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbENlbGxEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgbG9hZGluZ0luZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgbG9hZEJ1dHRvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgY2VsbHM6IEJlaGF2aW9yU3ViamVjdDxhbnlbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICBzY3JvbGxUb3A6IG51bWJlciA9IDA7XG4gICAgaXNMb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gICAgcGFnZU51bWJlcjogbnVtYmVyID0gMDtcbiAgICBkYXRhOiBhbnlbXSA9IFtdO1xuICAgIGxvYWRpbmdDb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfaGVpZ2h0OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGFueSBmdXR1cmUgY2hhbmdlcyB0byBzaXplXG4gICAgICAgIHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkuc3Vic2NyaWJlKGV2ZW50ID0+IHRoaXMuX2hlaWdodCA9IGV2ZW50LmhlaWdodCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNlbGxIZWlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmlydHVhbCBTY3JvbGwgQ29tcG9uZW50IHJlcXVpcmVzIFwiY2VsbEhlaWdodFwiIHByb3BlcnR5IHRvIGJlIGRlZmluZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5zZXR1cE9ic2VydmFibGUoKTtcblxuICAgICAgICAvLyBsb2FkIHRoZSBmaXJzdCBwYWdlIG9mIGRhdGFcbiAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHJlLXJlbmRlciBjZWxscyBub3cgdGhhdCB3ZSBjYW4gZGlzcGxheSBhbnkgbG9hZGluZyBpbmRpY2F0b3Igb3IgbG9hZGluZyBidXR0b25cbiAgICAgICAgdGhpcy5yZW5kZXJDZWxscygpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuY29sbGVjdGlvbiAmJiBjaGFuZ2VzLmNvbGxlY3Rpb24uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmNvbGxlY3Rpb24ucHJldmlvdXNWYWx1ZSAmJiAhY2hhbmdlcy5jb2xsZWN0aW9uLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cE9ic2VydmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXR1cE9ic2VydmFibGUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBjdXJyZW50IHN1YnNjcmlwdGlvbiwgdW5zdWJzY3JpYmVcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbiAmJiB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5jb2xsZWN0aW9uLnN1YnNjcmliZShjb2xsZWN0aW9uID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKC4uLmNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDZWxscygpO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdzY3JvbGwnKSByZW5kZXJDZWxscygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jZWxscy5uZXh0KHRoaXMuZ2V0VmlzaWJsZUNlbGxzKCkpO1xuXG4gICAgICAgIGlmICh0aGlzLmxvYWRPblNjcm9sbCAmJiAhdGhpcy5pc0xvYWRpbmcgJiYgIXRoaXMubG9hZGluZ0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdTY3JvbGwgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgKyB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbHMgdGFrZSB1cCBsZXNzIHRoYW4gdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IHRoZW4gbG9hZCB0aGUgbmV4dCBwYWdlXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nU2Nyb2xsIDw9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmlzaWJsZUNlbGxzKCk6IGFueVtdIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBlbGVtZW50IGhlaWdodFxuICAgICAgICBpZiAoIXRoaXMuX2hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gc29tZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gTWF0aC5mbG9vcihzY3JvbGxUb3AgLyB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICBjb25zdCBlbmRDZWxsID0gTWF0aC5jZWlsKHRoaXMuX2hlaWdodCAvIHRoaXMuY2VsbEhlaWdodCkgKyAxO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC0gKHNjcm9sbFRvcCAlIHRoaXMuY2VsbEhlaWdodCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGEgc3VibGlzdCBvZiBpdGVtcyB2aXNpYmxlIG9uIHRoZSBzY3JlZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydENlbGwsIHN0YXJ0Q2VsbCArIGVuZENlbGwpO1xuICAgIH1cblxuICAgIGdldFRvdGFsSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxIZWlnaHQgKiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGxvYWROZXh0UGFnZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvYWRpbmcubmV4dCh0aGlzLnBhZ2VOdW1iZXIpO1xuICAgICAgICB0aGlzLnBhZ2VOdW1iZXIrKztcbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcblxuICAgICAgICAvLyByZXNldCBhbGwgdmFsdWVzXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5sb2FkaW5nQ29tcGxldGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBzZXQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjdXJyZW50IGNlbGxzXG4gICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoKTtcblxuICAgICAgICAvLyByZWxvYWQgZmlyc3QgcGFnZVxuICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xuICAgIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsQ29tcG9uZW50IH0gZnJvbSAnLi92aXJ0dWFsLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlJztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFZpcnR1YWxTY3JvbGxDb21wb25lbnQsXG4gICAgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUsXG4gICAgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsXG4gICAgVmlydHVhbFNjcm9sbENlbGxEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJlc2l6ZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eEF1dG9Hcm93XSdcbn0pXG5leHBvcnQgY2xhc3MgQXV0b0dyb3dEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgLy8gZW5zdXJlIHRoaXMgaXMgYSB0ZXh0YXJlYSBvciBlbHNlIHRocm93IGVycm9yXG4gICAgaWYgKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGV4dGFyZWEnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V4QXV0b0dyb3cgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgb24gPHRleHRhcmVhPiBlbGVtZW50cy4nKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JylcbiAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgLy8gcGVyZm9ybSBzaXppbmdcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvd1knLCAnaGlkZGVuJyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgJ2F1dG8nKTtcblxuICAgIC8vIGdldCB0aGUgbmV3IHRvdGFsIGhlaWdodCBhbmQgZWxlbWVudCBoZWlnaHRcbiAgICBjb25zdCB7IHNjcm9sbEhlaWdodCB9ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IHsgbWF4SGVpZ2h0IH0gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hhdCB0aGUgbWF4aW11bSBhbGxvd2VkIGhlaWdodCBpc1xuICAgIGNvbnN0IG1heGltdW0gPSAhaXNOYU4ocGFyc2VGbG9hdChtYXhIZWlnaHQpKSA/IHBhcnNlRmxvYXQobWF4SGVpZ2h0KSA6IEluZmluaXR5O1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBtYXggaGVpZ2h0IHNwZWNpZmVkIHdlIHdhbnQgdG8gc2hvdyB0aGUgc2Nyb2xsYmFyc1xuICAgIGlmIChtYXhpbXVtIDwgc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvd1knLCAnYXV0bycpO1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgbWF4aW11bSArICdweCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCBzY3JvbGxIZWlnaHQgKyAncHgnKTtcbiAgICB9XG4gIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBBdXRvR3Jvd0RpcmVjdGl2ZSB9IGZyb20gJy4vYXV0by1ncm93LmRpcmVjdGl2ZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgZXhwb3J0czogW0F1dG9Hcm93RGlyZWN0aXZlXSxcclxuICAgIGRlY2xhcmF0aW9uczogW0F1dG9Hcm93RGlyZWN0aXZlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXV0b0dyb3dNb2R1bGUgeyB9XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhGaXhlZEhlYWRlclRhYmxlXSdcbn0pXG5leHBvcnQgY2xhc3MgRml4ZWRIZWFkZXJUYWJsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgdGFibGVIZWlnaHQ6IG51bWJlciB8IHN0cmluZztcbiAgQE91dHB1dCgpIHRhYmxlUGFnaW5nOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIHByaXZhdGUgX3RhYmxlSGVhZDogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgX3RhYmxlQm9keTogSFRNTEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikgeyB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBhZGQgY2xhc3MgdG8gdGhlIHRhYmxlXG4gICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndXgtZml4ZWQtaGVhZGVyLXRhYmxlJyk7XG5cbiAgICAvLyBsb2NhdGUgdGhlIGltcG9ydGFudCBlbGVtZW50c1xuICAgIHRoaXMuX3RhYmxlSGVhZCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpO1xuICAgIHRoaXMuX3RhYmxlQm9keSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpO1xuXG4gICAgLy8gYmluZCB0byBzY3JvbGwgZXZlbnRzIG9uIHRoZSB0YWJsZSBib2R5XG4gICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuX3RhYmxlQm9keSwgJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG5cbiAgICAvLyByZXNpemUgdGhlIHRhYmxlIGhlYWRlciB0byBhY2NvdW50IGZvciBzY3JvbGxiYXJcbiAgICB0aGlzLnNldExheW91dCgpO1xuXG4gICAgLy8gdHJpZ2dlciB0aGUgbG9hZGluZyBvZiB0aGUgZmlyc3QgcGFnZVxuICAgIHRoaXMudGFibGVQYWdpbmcuZW1pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFibGUgZWxlbWVudFxuICAgKiBQcmltYXJpbHkgdXNlZCBieSBjb2x1bW4gd2lkdGggZGlyZWN0aXZlXG4gICAqL1xuICBnZXRUYWJsZSgpOiBIVE1MVGFibGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzY3JvbGwgZXZlbnRzXG4gICAqL1xuICBwcml2YXRlIG9uU2Nyb2xsKCk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHdlIGFyZSBzY3JvbGxlZCB0byB0aGUgYm90dG9tIGFuZCBpZiBzbyBsb2FkIHRoZSBuZXh0IHBhZ2VcbiAgICBpZiAodGhpcy5fdGFibGVCb2R5LnNjcm9sbFRvcCA9PT0gKHRoaXMuX3RhYmxlQm9keS5zY3JvbGxIZWlnaHQgLSB0aGlzLl90YWJsZUJvZHkub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgdGhpcy50YWJsZVBhZ2luZy5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgdGFibGUgaGVhZGVyIHRvIGFjY291bnQgZm9yIHRoZSBzY3JvbGxiYXIuXG4gICAqIFRoaXMgaXMgaW1wb3J0YW50IHRvIGtlZXAgdGhlIGNvbHVtbnMgYWxpZ25lZFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRMYXlvdXQoKTogdm9pZCB7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhlIHNjcm9sbGJhclxuICAgIGNvbnN0IHNjcm9sbGJhciA9IHRoaXMuX3RhYmxlQm9keS5vZmZzZXRXaWR0aCAtIHRoaXMuX3RhYmxlQm9keS5jbGllbnRXaWR0aDtcblxuICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBoZWFkZXIgdG8gYWNjb3VudCBmb3IgdGhpc1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX3RhYmxlSGVhZCwgJ3BhZGRpbmctcmlnaHQnLCBzY3JvbGxiYXIgKyAncHgnKTtcblxuICAgIC8vIHNldCB0aGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIHRhYmxlIGJvZHlcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJsZUJvZHksICdoZWlnaHQnLCB0eXBlb2YgdGhpcy50YWJsZUhlaWdodCA9PT0gJ251bWJlcicgPyBgJHt0aGlzLnRhYmxlSGVpZ2h0fXB4YCA6IHRoaXMudGFibGVIZWlnaHQpO1xuICB9XG5cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZpeGVkSGVhZGVyVGFibGVEaXJlY3RpdmUgfSBmcm9tICcuL2ZpeGVkLWhlYWRlci10YWJsZS5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBGaXhlZEhlYWRlclRhYmxlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEZsb2F0TGFiZWxdJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd1eC1mbG9hdC1sYWJlbCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZsb2F0TGFiZWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgndXhGbG9hdExhYmVsJylcbiAgICBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcblxuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbW9kZTogJ2ZvY3VzJyB8ICdpbnB1dCcgPSAnZm9jdXMnO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy51eC1mbG9hdC1sYWJlbC1yYWlzZWQnKVxuICAgIHJhaXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBwcml2YXRlIF9mb2N1c2VkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfZXZlbnRIYW5kbGVzOiBhbnlbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVzLnB1c2goXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4odGhpcy5pbnB1dCwgJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuaW5wdXQsICdibHVyJywgdGhpcy5pbnB1dEJsdXIuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4odGhpcy5pbnB1dCwgJ2lucHV0JywgdGhpcy5pbnB1dENoYW5nZS5iaW5kKHRoaXMpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENoZWNrIGluaXRpYWwgaW5wdXQgdmFsdWVcbiAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYGZvcmAgYXR0cmlidXRlIGlzIHNldFxuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvcicpICYmIHRoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZm9yJywgdGhpcy5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgICAgIGlmICghKHRoaXMubW9kZSA9PT0gJ2ZvY3VzJyAmJiB0aGlzLl9mb2N1c2VkKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyBVbnN1YnNjcmliZSBldmVudCBoYW5kbGVzXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcy5mb3JFYWNoKChldmVudEhhbmRsZSkgPT4gZXZlbnRIYW5kbGUoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNUZXh0KCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmlucHV0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnB1dEZvY3VzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmFpc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW5wdXRCbHVyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJhaXNlZCA9IHRoaXMuaGFzVGV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnB1dENoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGbG9hdExhYmVsRGlyZWN0aXZlIH0gZnJvbSAnLi9mbG9hdC1sYWJlbC5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IFtGbG9hdExhYmVsRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGbG9hdExhYmVsRGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdExhYmVsTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGVscENlbnRlclNlcnZpY2Uge1xuXG4gICAgaXRlbXM6IEJlaGF2aW9yU3ViamVjdDxIZWxwQ2VudGVySXRlbVtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SGVscENlbnRlckl0ZW1bXT4oW10pO1xuXG4gICAgcmVnaXN0ZXJJdGVtKGl0ZW06IEhlbHBDZW50ZXJJdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGl0ZW1zXG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBpdGVtIHRvIHRoZSBsaXN0XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMuaXRlbXMubmV4dChpdGVtcyk7XG4gICAgfVxuXG4gICAgdW5yZWdpc3Rlckl0ZW0oaXRlbTogSGVscENlbnRlckl0ZW0pOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgaXRlbXNcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBiZWluZyB1bnJlZ2lzdGVyZWRcbiAgICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRtID0+IGl0bSAhPT0gaXRlbSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMuaXRlbXMubmV4dChpdGVtcyk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlbHBDZW50ZXJJdGVtIHtcbiAgICBpY29uPzogc3RyaW5nO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgc2VsZWN0PzogKCkgPT4gdm9pZDtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGVscENlbnRlclNlcnZpY2UsIEhlbHBDZW50ZXJJdGVtIH0gZnJvbSAnLi9oZWxwLWNlbnRlci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW3V4SGVscENlbnRlckl0ZW1dJyB9KVxuZXhwb3J0IGNsYXNzIEhlbHBDZW50ZXJJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgdXhIZWxwQ2VudGVySXRlbTogSGVscENlbnRlckl0ZW07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9oZWxwQ2VudGVyU2VydmljZTogSGVscENlbnRlclNlcnZpY2UpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGl0ZW0gaW4gdGhlIHNlcnZpY2VcbiAgICAgICAgdGhpcy5faGVscENlbnRlclNlcnZpY2UucmVnaXN0ZXJJdGVtKHRoaXMudXhIZWxwQ2VudGVySXRlbSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGlzIGl0ZW0gd2hlbiBpdCBpcyBkZXN0cm95ZWRcbiAgICAgICAgdGhpcy5faGVscENlbnRlclNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy51eEhlbHBDZW50ZXJJdGVtKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhlbHBDZW50ZXJJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9oZWxwLWNlbnRlci1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIZWxwQ2VudGVyU2VydmljZSB9IGZyb20gJy4vaGVscC1jZW50ZXIuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogW0hlbHBDZW50ZXJJdGVtRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtIZWxwQ2VudGVySXRlbURpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbSGVscENlbnRlclNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBIZWxwQ2VudGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmUgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi1jb250YWluZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24uZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uU2VydmljZSB7XG5cbiAgICBhY3RpdmU6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgcHJpdmF0ZSBfY29udGFpbmVyOiBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZTtcbiAgICBwcml2YXRlIF9mb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfaG92ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2FjdGlvbnM6IEhvdmVyQWN0aW9uRGlyZWN0aXZlW10gPSBbXTtcblxuICAgIHJlZ2lzdGVyKGFjdGlvbjogSG92ZXJBY3Rpb25EaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlcihhY3Rpb246IEhvdmVyQWN0aW9uRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLmZpbHRlcihhY3RuID0+IGFjdG4gIT09IGFjdGlvbik7XG4gICAgfVxuXG4gICAgc2V0Q29udGFpbmVyKGNvbnRhaW5lcjogSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cblxuICAgIHNldEZvY3VzU3RhdGUoZm9jdXM6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBzZXRIb3ZlclN0YXRlKGhvdmVyOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSBob3ZlcjtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBjb250YWluZXIgaGFzIGZvY3VzIHRoZW4gZm9jdXMgdGhlIGZpcnN0IGhvdmVyIGFjdGlvblxuICAgICAgICBpZiAodGhpcy5jb250YWluZXJIYXNGb2N1cygpKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWN0aW9uQXRJbmRleCgwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGEgaG92ZXIgYWN0aW9uIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBuZXh0IGFjdGlvblxuICAgICAgICBpZiAodGhpcy5hY3Rpb25IYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldEZvY3VzZWRBY3Rpb25JbmRleCgpICsgMTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNBY3Rpb25BdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIGEgaG92ZXIgYWN0aW9uIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBwcmV2aW91cyBhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uSGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRGb2N1c2VkQWN0aW9uSW5kZXgoKSAtIDE7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0FjdGlvbkF0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZpc2liaWxpdHkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWN0aXZlLm5leHQodGhpcy5fZm9jdXNlZCB8fCB0aGlzLl9ob3ZlcmVkIHx8IHRoaXMuYWN0aW9uSGFzRm9jdXMoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb2N1c0FjdGlvbkF0SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zW2luZGV4XS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGb2N1c2VkQWN0aW9uSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuZmluZEluZGV4KGFjdGlvbiA9PiBhY3Rpb24gPT09IHRoaXMuZ2V0Rm9jdXNlZEFjdGlvbigpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbnRhaW5lckhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFjdGlvbkhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldEZvY3VzZWRBY3Rpb24oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZvY3VzZWRBY3Rpb24oKTogSG92ZXJBY3Rpb25EaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5maW5kKGFjdGlvbiA9PiBhY3Rpb24uZm9jdXNlZCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBIb3ZlckFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhIb3ZlckFjdGlvbkNvbnRhaW5lcl0nLFxuICAgIHByb3ZpZGVyczogW0hvdmVyQWN0aW9uU2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1jb250YWluZXItYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAnW3RhYmluZGV4XSc6ICd0YWJpbmRleCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICAgIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBhY3RpdmUkOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9ob3ZlckFjdGlvblNlcnZpY2U6IEhvdmVyQWN0aW9uU2VydmljZSkge1xuICAgICAgICAvLyByZWdpc3RlciB0aGUgY29udGFpbmVyIGVsZW1lbnQgd2l0aCB0aGUgc2VydmljZVxuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Q29udGFpbmVyKHRoaXMpO1xuXG4gICAgICAgIC8vIGFwcGx5IGEgY2xhc3MgYmFzZWQgb24gdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgY29udGFpbmVyIGFuZCBpdCdzIGFjdGlvbnNcbiAgICAgICAgdGhpcy5hY3RpdmUkID0gdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLmFjdGl2ZS5zdWJzY3JpYmUoYWN0aXZlID0+IHRoaXMuYWN0aXZlID0gYWN0aXZlKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hY3RpdmUkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKSBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBvbkZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Rm9jdXNTdGF0ZSh0cnVlKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJykgb25CbHVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Rm9jdXNTdGF0ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpIG9uSG92ZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5zZXRIb3ZlclN0YXRlKHRydWUpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSBvbkxlYXZlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0SG92ZXJTdGF0ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3JpZ2h0JykgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLm5leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIE9uRGVzdHJveSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uU2VydmljZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEhvdmVyQWN0aW9uXScsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgICAgICdbY2xhc3MuaG92ZXItYWN0aW9uLWZvY3VzZWRdJzogJ2ZvY3VzZWQnLFxuICAgICAgICAnW3RhYmluZGV4XSc6ICd0YWJpbmRleCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAxO1xuICAgIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYWN0aXZlJDogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfaG92ZXJBY3Rpb25TZXJ2aWNlOiBIb3ZlckFjdGlvblNlcnZpY2UpIHtcblxuICAgICAgICAvLyByZWdpc3RlciB0aGUgYWN0aW9uXG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5yZWdpc3Rlcih0aGlzKTtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlcyB0byB0aGUgYWN0aXZlbmVzcyBvZiB0aGUgY29udGFpbmVyXG4gICAgICAgIHRoaXMuYWN0aXZlJCA9IHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5hY3RpdmUuc3Vic2NyaWJlKGFjdGl2ZSA9PiB0aGlzLmFjdGl2ZSA9IGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2ZSQudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBvbkZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2JsdXInKSBvbkJsdXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dsZWZ0JywgWyckZXZlbnQnXSkgcHJldmlvdXMoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7ICAgICAgICBcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3JpZ2h0JywgWyckZXZlbnQnXSkgbmV4dChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLm5leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24tY29udGFpbmVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZSc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBIb3ZlckFjdGlvbkRpcmVjdGl2ZSxcbiAgICBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgSG92ZXJBY3Rpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVtYmVkZGVkVmlld1JlZiwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TGF5b3V0U3dpdGNoZXJJdGVtXSdcbn0pXG5leHBvcnQgY2xhc3MgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgndXhMYXlvdXRTd2l0Y2hlckl0ZW0nKSBwcml2YXRlIF9jb25maWc6IExheW91dFN3aXRjaGVySXRlbTtcblxuICAgIHByaXZhdGUgX2VtYmVkZGVkVmlldzogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PiwgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikgeyB9XG5cbiAgICBnZXRMYXlvdXQoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZVJlZjtcbiAgICB9XG5cbiAgICBnZXRDb25maWcoKTogTGF5b3V0U3dpdGNoZXJJdGVtIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3ID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLl9lbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLnJlbW92ZShpbmRleCk7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlldyA9IG51bGw7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5b3V0U3dpdGNoZXJJdGVtIHtcbiAgICBncm91cD86IHN0cmluZztcbiAgICBtaW5XaWR0aD86IG51bWJlcjtcbiAgICBtYXhXaWR0aD86IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIFF1ZXJ5TGlzdCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgQWZ0ZXJDb250ZW50SW5pdCwgVmlld0NvbnRhaW5lclJlZiwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vcmVzaXplL2luZGV4JztcbmltcG9ydCB7IExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbGF5b3V0LXN3aXRjaGVyLWl0ZW0uZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhMYXlvdXRTd2l0Y2hlcl0nXG59KVxuZXhwb3J0IGNsYXNzIExheW91dFN3aXRjaGVyRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIEBJbnB1dCgpIGdyb3VwOiBzdHJpbmc7XG4gICAgQENvbnRlbnRDaGlsZHJlbihMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUpIHByaXZhdGUgX2xheW91dHM6IFF1ZXJ5TGlzdDxMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmU+O1xuICAgIFxuICAgIHByaXZhdGUgX3dpZHRoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfYWN0aXZlTGF5b3V0OiBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKSB7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIGNvbnRhaW5lciBzaXplXG4gICAgICAgIHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gZXZlbnQud2lkdGg7XG5cbiAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUxheW91dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGFjdGl2ZSBncm91cCBoYXMgY2hhbmdlZCB0aGVuIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgICAgIGlmIChjaGFuZ2VzLmdyb3VwLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5ncm91cC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QWN0aXZlTGF5b3V0KCk6IExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB8IG51bGwge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBjdXJyZW50bHkgbm8gbGF5b3V0cyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLl9sYXlvdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBmaW5kIGxheW91dHMgdGhhdCBtYXRjaCB0aGUgYWN0aXZlIGdyb3VwIGFuZCB0aGF0IG1lZXQgdGhlIGNvbnN0cmFpbnRzXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRzLmZpbHRlcihsYXlvdXQgPT4gdGhpcy5ncm91cCA9PT0gbGF5b3V0LmdldENvbmZpZygpLmdyb3VwKS5maW5kKGxheW91dCA9PiB7XG5cbiAgICAgICAgICAgIGxldCBtaW5XaWR0aCA9IGxheW91dC5nZXRDb25maWcoKS5taW5XaWR0aCB8fCAwO1xuICAgICAgICAgICAgbGV0IG1heFdpZHRoID0gbGF5b3V0LmdldENvbmZpZygpLm1heFdpZHRoIHx8IEluZmluaXR5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggPj0gbWluV2lkdGggJiYgdGhpcy5fd2lkdGggPCBtYXhXaWR0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlQWN0aXZlTGF5b3V0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgbGF5b3V0IHRoYXQgc2hvdWxkIGJlIHNob3duXG4gICAgICAgIGxldCBsYXlvdXQgPSB0aGlzLmdldEFjdGl2ZUxheW91dCgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgc2hvd2luZyB0aGUgbGF5b3V0XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVMYXlvdXQgPT09IGxheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGxheW91dFxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVMYXlvdXQuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG5ldyBhY3RpdmUgbGF5b3V0XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxheW91dCA9IGxheW91dDtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgbGF5b3V0IHRoZW4gYWN0aXZhdGVcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGF5b3V0LmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgY3VycmVudCBlbGVtZW50IHdpZHRoXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0IC0gbmVlZCBhIGRlbGF5IGFzIEFuZ3VsYXIgZG9lc24ndCBsaWtlIGNoYW5nZXMgbGlrZSB0aGlzIGluIHRoZXNlIGxpZmVjeWNsZSBob29rc1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVBY3RpdmVMYXlvdXQuYmluZCh0aGlzKSk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckRpcmVjdGl2ZSB9IGZyb20gJy4vbGF5b3V0LXN3aXRjaGVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi9yZXNpemUvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgTGF5b3V0U3dpdGNoZXJEaXJlY3RpdmUsXG4gICAgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgUmVzaXplTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgTGF5b3V0U3dpdGNoZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eE92ZXJmbG93T2JzZXJ2ZXJdLCBbdXhPdmVyZmxvd0hvcml6b250YWxPYnNlcnZlcl0sIFt1eE92ZXJmbG93VmVydGljYWxPYnNlcnZlcl0nLFxuICBleHBvcnRBczogJ3V4LW92ZXJmbG93LW9ic2VydmVyJ1xufSlcbmV4cG9ydCBjbGFzcyBPdmVyZmxvd0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAvKiogQWxsb3cgYSBvYnNlcnZhYmxlIHRvIGJlIHVzZWQgdG8gY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIEBJbnB1dCgpIHRyaWdnZXI6IE9ic2VydmFibGU8dm9pZD47XG5cbiAgLyoqIEFsbG93IG92ZXJmbG93IHRvIGJlIHdpdGhpbiBhIHJhbmdlIGJlZm9yZSBlbWl0dGluZyAqL1xuICBASW5wdXQoKSB0b2xlcmFuY2U6IG51bWJlciA9IDA7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSB0byB0aGUgb3ZlcmZsb3cgc3RhdGUgLSBob3Jpem9udGFsIG9yIHZlcnRpY2FsICovXG4gIEBPdXRwdXQoKSB1eE92ZXJmbG93T2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSB0byBvdmVyZmxvdyBvbiB0aGUgaG9yaXpvbnRhbCBheGlzICovXG4gIEBPdXRwdXQoKSB1eE92ZXJmbG93SG9yaXpvbnRhbE9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBFbWl0IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2UgdG8gb3ZlcmZsb3cgb24gdGhlIHZlcnRpY2FsIGF4aXMgKi9cbiAgQE91dHB1dCgpIHV4T3ZlcmZsb3dWZXJ0aWNhbE9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBTdG9yZSB0aGUgb3ZlcmZsb3cgc3RhdGUgb24gYm90aCBheGlzICovXG4gIHByaXZhdGUgX3N0YXRlID0geyBob3Jpem9udGFsT3ZlcmZsb3c6IGZhbHNlLCB2ZXJ0aWNhbE92ZXJmbG93OiBmYWxzZSB9O1xuXG4gIC8qKiBVbnN1YnNjcmliZSBmcm9tIGFsbCB0aGUgb2JzZXJ2YWJsZXMgKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAvKiogU2V0IHVwIHRoZSB0cmlnZ2VyIGlmIHNwZWNpZmllZCAqL1xuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50cmlnZ2VyKSB7XG4gICAgICB0aGlzLnRyaWdnZXIucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2hlY2tGb3JPdmVyZmxvdygpKTtcbiAgICB9XG4gIH1cblxuICAvKiogUGVyZm9ybSBhbiBpbnRpYWwgY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5jaGVja0Zvck92ZXJmbG93KCkpO1xuICB9XG5cbiAgLyoqIFVuc3Vic2NyaWJlIGZyb20gdGhlIHRyaWdnZXIgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBQcm9ncmFtbWF0aWNhbGx5IHRyaWdnZXIgY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIGNoZWNrRm9yT3ZlcmZsb3coKTogdm9pZCB7XG5cbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQsIHNjcm9sbFdpZHRoLCBzY3JvbGxIZWlnaHQgfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBob3Jpem9udGFsT3ZlcmZsb3cgPSAoc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aCkgPiB0aGlzLnRvbGVyYW5jZTtcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJmbG93ID0gKHNjcm9sbEhlaWdodCAtIG9mZnNldEhlaWdodCkgPiB0aGlzLnRvbGVyYW5jZTtcblxuICAgIGlmIChob3Jpem9udGFsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLmhvcml6b250YWxPdmVyZmxvdykge1xuICAgICAgdGhpcy51eE92ZXJmbG93SG9yaXpvbnRhbE9ic2VydmVyLmVtaXQoaG9yaXpvbnRhbE92ZXJmbG93KTtcbiAgICB9XG5cbiAgICBpZiAodmVydGljYWxPdmVyZmxvdyAhPT0gdGhpcy5fc3RhdGUudmVydGljYWxPdmVyZmxvdykge1xuICAgICAgdGhpcy51eE92ZXJmbG93VmVydGljYWxPYnNlcnZlci5lbWl0KHZlcnRpY2FsT3ZlcmZsb3cpO1xuICAgIH1cblxuICAgIGlmIChob3Jpem9udGFsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLmhvcml6b250YWxPdmVyZmxvdyB8fCB2ZXJ0aWNhbE92ZXJmbG93ICE9PSB0aGlzLl9zdGF0ZS52ZXJ0aWNhbE92ZXJmbG93KSB7XG4gICAgICB0aGlzLnV4T3ZlcmZsb3dPYnNlcnZlci5lbWl0KChob3Jpem9udGFsT3ZlcmZsb3cgfHwgdmVydGljYWxPdmVyZmxvdykpO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlID0geyBob3Jpem9udGFsT3ZlcmZsb3csIHZlcnRpY2FsT3ZlcmZsb3cgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE92ZXJmbG93RGlyZWN0aXZlIH0gZnJvbSAnLi9vdmVyZmxvdy9vdmVyZmxvdy1vYnNlcnZlci5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBleHBvcnRzOiBbT3ZlcmZsb3dEaXJlY3RpdmVdLFxuICBkZWNsYXJhdGlvbnM6IFtPdmVyZmxvd0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZXJzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlbGVjdGlvbi5zZXJ2aWNlJztcblxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvblN0cmF0ZWd5IHtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgc2VsZWN0aW9uU2VydmljZT86IFNlbGVjdGlvblNlcnZpY2UpIHsgfVxuXG4gIHNldFNlbGVjdGlvblNlcnZpY2Uoc2VsZWN0aW9uU2VydmljZTogU2VsZWN0aW9uU2VydmljZSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gIH1cblxuICBtb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQgeyB9XG5cbiAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQgeyB9XG5cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7IH1cblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBpdGVtIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgc2VsZWN0KC4uLmRhdGE6IGFueVtdKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdCguLi5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIGl0ZW0ncyBzZWxlY3RlZCBzdGF0ZSAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIHRvZ2dsZSguLi5kYXRhOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS50b2dnbGUoLi4uZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzZWxlY3QgdGhlIGl0ZW0gLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICBkZXNlbGVjdCguLi5kYXRhOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdCguLi5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYWxsIGl0ZW1zIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0KC4uLnRoaXMuc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhbGwgaXRlbXMgLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc2VsZWN0KC4uLnRoaXMuc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0KTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7IH1cbn1cbiIsImltcG9ydCB7IEtleUNvZGUgfSBmcm9tICcuL2tleWNvZGUuZW51bSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc2VsZWN0aW9uLnN0cmF0ZWd5JztcblxuZXhwb3J0IGNsYXNzIFJvd1NlbGVjdGlvblN0cmF0ZWd5IGV4dGVuZHMgU2VsZWN0aW9uU3RyYXRlZ3kge1xuXG4gIC8vIHN0b3JlIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIHJvd1xuICBwcml2YXRlIF9zZWxlY3Rpb246IFNlbGVjdGlvbiA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IG9uIHNoaWZ0IGNsaWNrIHRoZSBicm93c2VyIHdpbGwgaGlnaGxpZ2h0XG4gICAqIHRleHQuIFRoaXMgbG9va3MgYmFkIGFuZCB3ZSBkb24ndCB3YW50IHRoaXMgdG8gb2NjdXJcbiAgICovXG4gIG1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIHJvdyBpcyBjbGlja2VkIHdlIHdhbnQgdG8gaGFuZGxlIHNlbGVjdGlvblxuICAgKi9cbiAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcbiAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblxuICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB3ZSB3YW50IHRvIHBlcmZvcm0gYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGxlU2VsZWN0KGRhdGEpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBjb250cm9sIGtleSBpcyBwcmVzc2VkIHdlIHdhbnQgdG8gcGVyZm9ybSBhbiBhZGRpdGl2ZSB0b2dnbGUgc2VsZWN0aW9uXG4gICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvZ2dsZShkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGEgc2luZ2xlIHNlbGVjdGlvbiB3aGVyZSBhbGwgb3RoZXIgcm93cyBhcmUgZGVzZWxlY3RlZFxuICAgIHRoaXMuc2luZ2xlU2VsZWN0KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvIHN1cHBvcnQgZnVsbCBrZXlib2FyZCBjb250cm9sIHdlIG5lZWQgdG8gc3VwcG9ydCB0aGUgZm9sbG93aW5nOlxuICAgKiAxLiBBcnJvdyBrZXlzIHRvIG5hdmlnYXRlIHVwIGFuZCBkb3duXG4gICAqIDIuIFNwYWNlYmFyIHRvIHRvZ2dsZSBzZWxlY3Rpb25cbiAgICogMy4gU2hpZnQgKyBBcnJvdyBrZXlzIHRvIG11bHRpcGxlIHNlbGVjdFxuICAgKiA0LiBDdHJsICsgQXJyb3cga2V5cyB0byBhbGxvdyByZXRhaW5lZCBzZWxlY3Rpb24gYW5kIG5hdmlnYXRpb25cbiAgICovXG4gIGtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG5cbiAgICAgIGNhc2UgS2V5Q29kZS5VcEFycm93OlxuICAgICAgY2FzZSBLZXlDb2RlLkRvd25BcnJvdzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZShldmVudCwgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEtleUNvZGUuU3BhY2ViYXI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS50b2dnbGUoZGF0YSwgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBzdGFuZGFyZCB0b2dnbGUgZnVuY3Rpb24gdG8gc3RvcmUgb3IgY2xlYXIgdGhlXG4gICAqIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgaXRlbVxuICAgKi9cbiAgdG9nZ2xlKGRhdGE6IGFueSwgYWN0aXZhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIHN1cGVyLnRvZ2dsZShkYXRhKTtcblxuICAgIC8vIHN0b3JlIG9yIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNTZWxlY3RlZChkYXRhKSA/IHRoaXMuc2V0U2VsZWN0aW9uU3RhcnQoZGF0YSkgOiB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG5cbiAgICAvLyBpZiB3ZSB3YW50IHRvIGtlZXAgdGhlIGl0ZW0gYWN0aXZhdGVkIHRoZW4gYWN0aXZhdGVcbiAgICBpZiAoYWN0aXZhdGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG90aGVyIHNlbGVjdGVkIGl0ZW1zIGFuZCBzZWxlY3Qgb25seVxuICAgKiB0aGUgbW9zdCByZWNlbnRseSBzZWxlY3RlZCBpdGVtXG4gICAqL1xuICBwcml2YXRlIHNpbmdsZVNlbGVjdChkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgIC8vIGRlc2VsZWN0IGFsbCBvdGhlciByb3dzIGlmIG5laXRoZXIgbW9kaWZpZXIga2V5IGlzIHByZXNzZWRcbiAgICB0aGlzLmRlc2VsZWN0QWxsKCk7XG5cbiAgICAvLyBzZWxlY3QgdGhlIGN1cnJlbnQgcm93XG4gICAgdGhpcy5zZWxlY3QoZGF0YSk7XG5cbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBpdGVtIGFzIHRoZSBzZWxlY3Rpb24gc3RhcnRcbiAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtdWx0aXBsZSBzZWxlY3Rpb246XG4gICAqIDEuIElmIG5vIHN0YXJ0IGl0ZW0gc2VsZWN0ZWQgLSBzZWxlY3QgaXRcbiAgICogMi4gSWYgYSBzdGFydCBpdGVtIGhhcyBiZWVuIHNlbGVjdGVkIC0gc2VsZWN0IGFsbCBpbiBiZXR3ZWVuXG4gICAqIDMuIElmIGEgc3RhcnQgYW5kIGVuZCBpdGVtIGhhdmUgYmVlbiBzZWxlY3RlZCBjbGVhciB0aGUgcmFuZ2UgYW5kIHRoZW4gc2VsZWN0IHRoZSBuZXcgcmFuZ2VcbiAgICovXG4gIHByb3RlY3RlZCBtdWx0aXBsZVNlbGVjdChkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgIC8vIGlmIG5vIHNlbGVjdGlvbiBjdXJyZW50bHkgZXhpc3RzIHRoZW4gcGVyZm9ybSBpbml0aWFsIHNlbGVjdGlvblxuICAgIGlmICghdGhpcy5fc2VsZWN0aW9uLnN0YXJ0KSB7XG5cbiAgICAgIC8vIHNlbGVjdCB0aGUgcm93XG4gICAgICB0aGlzLnNlbGVjdChkYXRhKTtcblxuICAgICAgLy8gc3RvcmUgdGhlIHN0YXJ0aW5nIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb25TdGFydChkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBpZiBhIG11bHRpcGxlIHNlbGVjdGlvbiBhbHJlYWR5IHRvb2sgcGxhY2UgLSBjbGVhciB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbi5zdGFydCAmJiB0aGlzLl9zZWxlY3Rpb24uZW5kKSB7XG4gICAgICB0aGlzLmRlc2VsZWN0KC4uLnRoaXMuZ2V0U2VsZWN0ZWRJdGVtcygpKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIG5ldyBzZWxlY3Rpb24gZW5kIHBvaW50XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25FbmQoZGF0YSk7XG5cbiAgICAvLyBzZWxlY3QgYWxsIHRoZSBpdGVtcyBpbiB0aGUgcmFuZ2VcbiAgICB0aGlzLnNlbGVjdCguLi50aGlzLmdldFNlbGVjdGVkSXRlbXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzZWxlY3Rpb24gc3RhcnQgcG9pbnQuIElmIHRoZXJlIHdhcyBwcmV2aW91c2x5IGFcbiAgICogc2VsZWN0aW9uIGVuZCBwb2ludCB0aGVuIGNsZWFyIGl0IGFzIHRoaXMgaXMgYSBuZXcgc2VsZWN0aW9uXG4gICAqL1xuICBwcml2YXRlIHNldFNlbGVjdGlvblN0YXJ0KGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGlvbi5zdGFydCA9IGRhdGE7XG4gICAgdGhpcy5fc2VsZWN0aW9uLmVuZCA9IG51bGw7XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiBlbmQgcG9pbnRcbiAgICovXG4gIHByaXZhdGUgc2V0U2VsZWN0aW9uRW5kKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGlvbi5lbmQgPSBkYXRhO1xuXG4gICAgLy8gYWN0aXZhdGUgdGhlIGl0ZW1cbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYm90aCBzdGFydCBhbmQgZW5kIHNlbGVjdGlvbiBwb2ludHNcbiAgICovXG4gIHByb3RlY3RlZCBjbGVhclNlbGVjdGlvbihkZWFjdGl2YXRlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuXG4gICAgLy8gcmVzZXQgdGhlIHNlbGVjdGVkIGl0ZW1cbiAgICB0aGlzLl9zZWxlY3Rpb24gPSB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTtcblxuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgIGlmIChkZWFjdGl2YXRlKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgYWxsIHRoZSBpdGVtcyBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAqIE5vdGUgdGhhdCB0aGUgZW5kIHBvaW50IG1heSBiZSBhYm92ZSB0aGUgc3RhcnQgcG9pbnQgc29cbiAgICogd2UgbmVlZCB0byBhY2NvdW50IGZvciB0aGlzLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTZWxlY3RlZEl0ZW1zKCk6IGFueVtdIHtcblxuICAgIC8vIGdldCB0aGUgbGF0ZXN0IGRhdGFzZXRcbiAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXMuc2VsZWN0aW9uU2VydmljZTtcblxuICAgIC8vIGdldCB0aGUgaW5kZXhlcyBvZiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludFxuICAgIGNvbnN0IHN0YXJ0SWR4ID0gZGF0YXNldC5pbmRleE9mKHRoaXMuX3NlbGVjdGlvbi5zdGFydCk7XG4gICAgY29uc3QgZW5kSWR4ID0gZGF0YXNldC5pbmRleE9mKHRoaXMuX3NlbGVjdGlvbi5lbmQpO1xuXG4gICAgLy8gZ2V0IHRoZSByZWdpb24gb2YgdGhlIGFycmF5IHRoYXQgaXMgc2VsZWN0ZWQgLSBub3RlIHRoZSBlbmRJZHggbWF5IGJlIGJlZm9yZSB0aGUgc3RhcnRJZHggc28gYWNjb3VudCBmb3IgdGhpc1xuICAgIHJldHVybiBkYXRhc2V0LnNsaWNlKE1hdGgubWluKHN0YXJ0SWR4LCBlbmRJZHgpLCBNYXRoLm1heChzdGFydElkeCwgZW5kSWR4KSArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBzaWJsaW5nIGl0ZW0gd2hlbiBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAqL1xuICBwcml2YXRlIG5hdmlnYXRlKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSB3aGljaCBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkXG4gICAgY29uc3QgeyBjdHJsS2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG5cbiAgICAvLyBpZiBubyBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkIHRoZW4gZGVzZWxlY3QgYWxsIGFuZCBjbGVhciB0aGUgc2VsZWN0aW9uXG4gICAgaWYgKCFjdHJsS2V5ICYmICFzaGlmdEtleSkge1xuICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xuICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbihmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gYWN0aXZhdGUgdGhlIHNpYmxpbmcgLSBpZiB0aGUgdXAgYXJyb3cgaXMgcHJlc3NlZCB0aGVuIG5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBzaWJsaW5nXG4gICAgY29uc3Qgc2libGluZyA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcoZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5VcEFycm93KTtcblxuICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB0aGVuIHdlIGFsc28gd2FudCB0byB0b2dnbGUgdGhlIHN0YXRlIGlmIHRoZSBpdGVtXG4gICAgaWYgKHNoaWZ0S2V5ICYmIHNpYmxpbmcpIHtcblxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24gc3RhcnQgdGhlbiBzZWxlY3QgdGhlIGN1cnJlbnQgcm93XG4gICAgICBpZiAoIXRoaXMuX3NlbGVjdGlvbi5zdGFydCkge1xuICAgICAgICB0aGlzLm11bHRpcGxlU2VsZWN0KGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm11bHRpcGxlU2VsZWN0KHNpYmxpbmcpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvbiB7XG4gIHN0YXJ0OiBhbnk7XG4gIGVuZDogYW55O1xufVxuIiwiaW1wb3J0IHsgS2V5Q29kZSB9IGZyb20gJy4va2V5Y29kZS5lbnVtJztcclxuaW1wb3J0IHsgUm93U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3Jvdy1zZWxlY3Rpb24uc3RyYXRlZ3knO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJvd0FsdFNlbGVjdGlvblN0cmF0ZWd5IGV4dGVuZHMgUm93U2VsZWN0aW9uU3RyYXRlZ3kge1xyXG4gICAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgS2V5Q29kZS5VcEFycm93OlxyXG4gICAgICAgICAgICBjYXNlIEtleUNvZGUuRG93bkFycm93OlxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ3Vyc29yS2V5KGV2ZW50LCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBLZXlDb2RlLlNwYWNlYmFyOlxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS50b2dnbGUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgdGhlIHNpYmxpbmcgaXRlbSB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVDdXJzb3JLZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkXHJcbiAgICAgICAgY29uc3QgeyBjdHJsS2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vIGlmIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQgdGhlbiBkZXNlbGVjdCBhbGwgYW5kIGNsZWFyIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICBpZiAoIWN0cmxLZXkgJiYgIXNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbihmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3RybEtleSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKGV2ZW50LmtleUNvZGUgPT09IEtleUNvZGUuVXBBcnJvdyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5nZXRTaWJsaW5nKGV2ZW50LmtleUNvZGUgPT09IEtleUNvZGUuVXBBcnJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3Qoc2libGluZyA/IHNpYmxpbmcgOiBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgS2V5Q29kZSB9IGZyb20gJy4va2V5Y29kZS5lbnVtJztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5leHBvcnQgY2xhc3MgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGl0ZW0gaXMgY2xpY2tlZCBzaW1wbHkgdG9nZ2xlIHRoZSBjdXJyZW50IHNlbGVjdGVkIHN0YXRlXG4gICAqL1xuICBjbGljayhldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy50b2dnbGUoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGJhc2ljIGtleWJvYXJkIHN1cHBvcnQgZm9yIG5hdmlnYXRpbmdcbiAgICogYW5kIHNlbGVjdGluZy9kZXNlbGVjdGluZyBpdGVtc1xuICAgKi9cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcblxuICAgICAgY2FzZSBLZXlDb2RlLlVwQXJyb3c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKHRydWUpO1xuXG4gICAgICBjYXNlIEtleUNvZGUuRG93bkFycm93OlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyhmYWxzZSk7XG5cbiAgICAgIGNhc2UgS2V5Q29kZS5TcGFjZWJhcjpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgc3RhbmRhcmQgdG9nZ2xlIGZ1bmN0aW9uIHRvIGFsd2F5cyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgKi9cbiAgdG9nZ2xlKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHN1cGVyLnRvZ2dsZShkYXRhKTtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LWFsdC1zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgUm93U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LXNlbGVjdGlvbi5zdHJhdGVneSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvc2ltcGxlLXNlbGVjdGlvbi5zdHJhdGVneSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zZWxlY3Rpb24gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3N0cmF0ZWd5VG9EZXN0cm95OiBTZWxlY3Rpb25TdHJhdGVneTtcblxuICBkYXRhc2V0OiBhbnlbXSA9IFtdO1xuICBlbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgY2xpY2tFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAga2V5Ym9hcmRFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgc3RyYXRlZ3k6IFNlbGVjdGlvblN0cmF0ZWd5ID0gbmV3IFNpbXBsZVNlbGVjdGlvblN0cmF0ZWd5KHRoaXMpO1xuXG4gIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGFueT4obnVsbCk7XG4gIGZvY3VzVGFyZ2V0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcbiAgc2VsZWN0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55W10+KFtdKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zdHJhdGVneVRvRGVzdHJveSA9IHRoaXMuc3RyYXRlZ3k7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kpIHtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIGl0ZW0gaXMgbm90IGN1cnJlbnRseSBzZWxlY3RlZCB0aGVuIGFkZCBpdFxuICAgKiB0byB0aGUgbGlzdCBvZiBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG5cbiAgICAvLyBhZGQgZWFjaCBzZWxlY3Rpb24gdG8gdGhlIHNldFxuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5fc2VsZWN0aW9uLmFkZChzZWxlY3Rpb24pKTtcblxuICAgIC8vIHByb3BhZ2F0ZSB0aGUgY2hhbmdlc1xuICAgIHRoaXMuc2VsZWN0aW9uSGFzTXV0YXRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIGRlc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG4gICAgLy8gcmVtb3ZlIGVhY2ggaXRlbSBmcm9tIHRoZSBzZXRcbiAgICBzZWxlY3Rpb25zLmZvckVhY2goc2VsZWN0aW9uID0+IHRoaXMuX3NlbGVjdGlvbi5kZWxldGUoc2VsZWN0aW9uKSk7XG5cbiAgICAvLyBwcm9wYWdhdGUgdGhlIGNoYW5nZXNcbiAgICB0aGlzLnNlbGVjdGlvbkhhc011dGF0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIGFueSBzcGVjaWZpZWQgaXRlbXNcbiAgICovXG4gIHRvZ2dsZSguLi5zZWxlY3Rpb25zOiBhbnlbXSk6IHZvaWQge1xuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5pc1NlbGVjdGVkKHNlbGVjdGlvbikgPyB0aGlzLmRlc2VsZWN0KHNlbGVjdGlvbikgOiB0aGlzLnNlbGVjdChzZWxlY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKi9cbiAgaXNTZWxlY3RlZChkYXRhOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmhhcyhkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JzZXJ2YWJsZSBzcGVjaWZpY2FsbHkgZm9yIG5vdGlmeWluZyB0aGUgc3Vic2NyaWJlclxuICAgKiBvbmx5IHdoZW4gdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiBhIHNwZWNpZmljIG9iamVjdCBoYXMgY2hhbmdlZFxuICAgKi9cbiAgc2VsZWN0ZWQkKGRhdGE6IGFueSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiQucGlwZShtYXAoKCkgPT4gdGhpcy5pc1NlbGVjdGVkKGRhdGEpKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGhvdyBzZWxlY3Rpb25zIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gICAqIFRoaXMgYWxsb3dzIHVzIHRvIHVzZSBhbiBzdHJhdGVneSBwYXR0ZXJuIHRvIGhhbmRsZSB0aGUgdmFyaW91cyBrZXlib2FyZFxuICAgKiBhbmQgbW91c2UgaW50ZXJhY3Rpb25zIHdoaWxlIGtlZXBpbmcgZWFjaCBtb2RlIHNlcGFyYXRlZCBhbmRcbiAgICogZWFzaWx5IGV4dGVuc2libGUgaWYgd2Ugd2FudCB0byBhZGQgbW9yZSBtb2RlcyBpbiBmdXR1cmUhXG4gICAqL1xuICBzZXRNb2RlKG1vZGU6IFNlbGVjdGlvbk1vZGUgfCBTZWxlY3Rpb25TdHJhdGVneSk6IHZvaWQge1xuXG4gICAgaWYgKHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95KSB7XG4gICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHN0cmF0ZWd5IGlmIGl0IHdhcyBjcmVhdGVkIGludGVybmFsbHlcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobW9kZSBpbnN0YW5jZW9mIFNlbGVjdGlvblN0cmF0ZWd5KSB7XG5cbiAgICAgIC8vIEN1c3RvbSBzdHJhdGVneSAtIHBhc3MgaW4gdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgIHRoaXMuc3RyYXRlZ3kgPSBtb2RlO1xuICAgICAgdGhpcy5zdHJhdGVneS5zZXRTZWxlY3Rpb25TZXJ2aWNlKHRoaXMpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc3dpdGNoIChtb2RlLnRvTG93ZXJDYXNlKCkudHJpbSgpKSB7XG5cbiAgICAgICAgY2FzZSAnc2ltcGxlJzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgUm93U2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93LWFsdCc6XG4gICAgICAgICAgdGhpcy5zdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbmV3IFJvd0FsdFNlbGVjdGlvblN0cmF0ZWd5KHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2VsZWN0aW9uIG1vZGUgJyR7bW9kZX0nIGRvZXMgbm90IGV4aXN0LiBWYWxpZCBtb2RlcyBhcmUgJ3NpbXBsZScsICdyb3cnLCBvciAncm93LWFsdCcuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgKi9cbiAgYWN0aXZhdGUoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmUkLm5leHQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmUgYWxsIGl0ZW1zXG4gICAqL1xuICBkZWFjdGl2YXRlKCk6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlJC5uZXh0KG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBvciBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtLlxuICAgKiBAcGFyYW0gcHJldmlvdXMgSWYgdHJ1ZSwgdGhlIHByZXZpb3VzIHNpYmxpbmcgd2lsbCBiZSByZXR1cm5lZC5cbiAgICovXG4gIGdldFNpYmxpbmcocHJldmlvdXM6IGJvb2xlYW4gPSBmYWxzZSk6IGFueSB7XG5cbiAgICAvLyBnZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbVxuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmFjdGl2ZSQuZ2V0VmFsdWUoKTtcblxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgaXRlbVxuICAgIGNvbnN0IGlkeCA9IHRoaXMuZGF0YXNldC5pbmRleE9mKGN1cnJlbnQpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZGF0YXNldFtwcmV2aW91cyA/IGlkeCAtIDEgOiBpZHggKyAxXTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIHNpYmxpbmcgb2YgdGhlIGN1cnJlbnQgYWN0aXZlIGl0ZW0uXG4gICAqIElmIHByZXZpb3VzIGlzIHNldCB0byB0cnVlIHRoZSBwcmV2aW91cyBzaWJsaW5nIHdpbGwgYmUgYWN0aXZhdGVkXG4gICAqIHJhdGhlciB0aGFuIHRoZSBuZXh0IHNpYmxpbmcuIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIHJldHVybiB0aGVcbiAgICogZGF0YSBvZiB0aGUgbmV3bHkgYWN0aXZhdGVkIHNpYmxpbmdcbiAgICovXG4gIGFjdGl2YXRlU2libGluZyhwcmV2aW91czogYm9vbGVhbiA9IGZhbHNlKTogYW55IHtcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0U2libGluZyhwcmV2aW91cyk7XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgdGFyZ2V0IGV4aXN0c1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBkaXNhYmxlZCBzdGF0ZVxuICAgIHRoaXMuZW5hYmxlZCA9ICFkaXNhYmxlZDtcblxuICAgIC8vIGNsZWFyIGFueSBzdGF0ZWZ1bCBkYXRhXG4gICAgdGhpcy5hY3RpdmUkLm5leHQobnVsbCk7XG4gICAgdGhpcy5fc2VsZWN0aW9uLmNsZWFyKCk7XG5cbiAgICAvLyBlbWl0IHRoZSBzZWxlY3Rpb24gY2hhbmdlIGluZm9ybWF0aW9uXG4gICAgdGhpcy5zZWxlY3Rpb25IYXNNdXRhdGVkKCk7XG4gIH1cblxuICBwcml2YXRlIHNlbGVjdGlvbkhhc011dGF0ZWQoKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3Rpb24kLm5leHQoQXJyYXkuZnJvbSh0aGlzLl9zZWxlY3Rpb24pKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25Nb2RlID0gJ3NpbXBsZScgfCAncm93JyB8ICdyb3ctYWx0JztcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vc2VsZWN0aW9uLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbdXhTZWxlY3Rpb25JdGVtXScsXHJcbiAgZXhwb3J0QXM6ICd1eC1zZWxlY3Rpb24taXRlbSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gIEBJbnB1dCgpIHV4U2VsZWN0aW9uSXRlbTogYW55O1xyXG5cclxuICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2NsYXNzLnV4LXNlbGVjdGlvbi1zZWxlY3RlZCcpXHJcbiAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkOiBib29sZWFuKSB7XHJcbiAgICBzZWxlY3RlZCA/IHRoaXMuc2VsZWN0KCkgOiB0aGlzLmRlc2VsZWN0KCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnV4LXNlbGVjdGlvbi1mb2N1c2VkJykgYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXHJcbiAgZ2V0IGF0dHJUYWJJbmRleCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuICh0aGlzLnRhYmluZGV4ICE9PSBudWxsKSA/IHRoaXMudGFiaW5kZXggOiB0aGlzLl9tYW5hZ2VkVGFiSW5kZXg7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHByaXZhdGUgX21hbmFnZWRUYWJJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VsZWN0aW9uU2VydmljZTogU2VsZWN0aW9uU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG5cclxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGFzc29jaWF0ZWQgZGF0YSB0aGVuIHRocm93IGFuIGVycm9yXHJcbiAgICBpZiAoIXRoaXMudXhTZWxlY3Rpb25JdGVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHV4U2VsZWN0aW9uSXRlbSBkaXJlY3RpdmUgbXVzdCBoYXZlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0LicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBzZWxlY3Rpb24gY2hhbmdlcyBvbiB0aGlzIGl0ZW1cclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0ZWQkKHRoaXMudXhTZWxlY3Rpb25JdGVtKS5zdWJzY3JpYmUoc2VsZWN0ZWQgPT4ge1xyXG5cclxuICAgICAgLy8gc3RvcmUgdGhlIHNlbGVjdGVkIHN0YXRlXHJcbiAgICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcblxyXG4gICAgICAvLyBlbWl0IHRoZSBzZWxlY3RlZCBzdGF0ZVxyXG4gICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0ZWQpO1xyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIHRoZSBhY3RpdmUgc3RhdGVcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuYWN0aXZlJC5waXBlKG1hcChhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzLnV4U2VsZWN0aW9uSXRlbSkpLnN1YnNjcmliZShhY3RpdmUgPT4ge1xyXG5cclxuICAgICAgLy8gc3RvcmUgdGhlIGZvY3VzIHN0YXRlXHJcbiAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xyXG5cclxuICAgICAgLy8gaWYgaXQgaXMgYWN0aXZlIHRoZW4gZm9jdXMgdGhlIGVsZW1lbnRcclxuICAgICAgaWYgKGFjdGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZm9jdXNUYXJnZXQkLm5leHQodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gdGhlIGZvY3VzIHRhcmdldFxyXG4gICAgLy8gVGhpcyBpcyBtb3N0bHkgdGhlIHNhbWUgYXMgYWN0aXZlJCwgZXhjZXB0IHRoYXQgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWUgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZCh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzVGFyZ2V0JC5zdWJzY3JpYmUoZm9jdXNUYXJnZXQgPT4ge1xyXG4gICAgICB0aGlzLl9tYW5hZ2VkVGFiSW5kZXggPSAoZm9jdXNUYXJnZXQgPT09IHRoaXMudXhTZWxlY3Rpb25JdGVtKSA/IDAgOiAtMTtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKSBjbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmNsaWNrRW5hYmxlZCkge1xyXG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LmNsaWNrKGV2ZW50LCB0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nLCBbJyRldmVudCddKSBtb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQgJiYgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5jbGlja0VuYWJsZWQpIHtcclxuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS5tb3VzZWRvd24oZXZlbnQsIHRoaXMudXhTZWxlY3Rpb25JdGVtKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKSBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkICYmIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uua2V5Ym9hcmRFbmFibGVkKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kua2V5ZG93bihldmVudCwgdGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBmb2N1cygpOiB2b2lkIHtcclxuICAgIC8vIElmIHRhYmJlZCB0byBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudCwgYWN0aXZhdGUuXHJcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmUkLmdldFZhbHVlKCkgIT09IHRoaXMudXhTZWxlY3Rpb25JdGVtKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0IHRoaXMgaXRlbSB1c2luZyB0aGUgY3VycmVudCBzdHJhdGVneVxyXG4gICAqL1xyXG4gIHNlbGVjdCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS5zZWxlY3QodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzZWxlY3QgdGhpcyBpdGVtIHVzaW5nIHRoZSBjdXJyZW50IHN0cmF0ZWd5XHJcbiAgICovXHJcbiAgZGVzZWxlY3QoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuZGVzZWxlY3QodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTZWxlY3Rpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9zZWxlY3Rpb24taXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZSwgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvc2VsZWN0aW9uLnN0cmF0ZWd5JztcblxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhTZWxlY3Rpb25dJyxcbiAgZXhwb3J0QXM6ICd1eC1zZWxlY3Rpb24nLFxuICBwcm92aWRlcnM6IFsgU2VsZWN0aW9uU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KCkgc2V0IHV4U2VsZWN0aW9uKGl0ZW1zOiBhbnlbXSkge1xuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0KC4uLml0ZW1zKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBkaXNhYmxlZChkaXNhYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2V0RGlzYWJsZWQoZGlzYWJsZWQpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IG1vZGUobW9kZTogU2VsZWN0aW9uTW9kZSB8IFNlbGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZXRNb2RlKG1vZGUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGNsaWNrU2VsZWN0aW9uKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmNsaWNrRW5hYmxlZCA9IGVuYWJsZWQ7XG4gIH1cblxuICBASW5wdXQoKSBzZXQga2V5Ym9hcmRTZWxlY3Rpb24oZW5hYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uua2V5Ym9hcmRFbmFibGVkID0gZW5hYmxlZDtcbiAgfVxuXG4gIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpIHRhYmluZGV4OiBudW1iZXIgPSBudWxsO1xuXG4gIEBPdXRwdXQoKSB1eFNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihTZWxlY3Rpb25JdGVtRGlyZWN0aXZlKSBpdGVtczogUXVlcnlMaXN0PFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmU+O1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VsZWN0aW9uU2VydmljZTogU2VsZWN0aW9uU2VydmljZSwgcHJpdmF0ZSBfY2RSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uJC5zdWJzY3JpYmUoaXRlbXMgPT4gdGhpcy51eFNlbGVjdGlvbkNoYW5nZS5lbWl0KGl0ZW1zKSkpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIC8vIHByb3ZpZGUgdGhlIGluaXRpYWwgbGlzdCBvZiBzZWxlY3Rpb24gaXRlbXNcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgLy8gaWYgdGhlIGxpc3QgY2hhbmdlcyB0aGVuIGluZm9ybSB0aGUgc2VydmljZVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHRoaXMuaXRlbXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGUoKSkpO1xuXG4gICAgLy8gVGhlIGFib3ZlIGNvdWxkIHRyaWdnZXIgYSBjaGFuZ2UgaW4gdGhlIGNvbXB1dGVkIHRhYmluZGV4IGZvciBzZWxlY3Rpb24gaXRlbXNcbiAgICB0aGlzLl9jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkYXRhc2V0IHRvIHJlZmxlY3QgdGhlIGxhdGVzdCBzZWxlY3Rpb24gaXRlbXNcbiAgICovXG4gIHVwZGF0ZSgpOiB2b2lkIHtcblxuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZGF0YXNldCA9IHRoaXMuaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS51eFNlbGVjdGlvbkl0ZW0pO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYSB0YWIgdGFyZ2V0IGhhcyBiZWVuIGRlZmluZWQgc28gdGhhdCB0aGUgY29tcG9uZW50IGNhbiBiZSB0YWJiZWQgdG8uXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZm9jdXNUYXJnZXQkLmdldFZhbHVlKCkgPT09IG51bGwgJiYgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZm9jdXNUYXJnZXQkLm5leHQodGhpcy5fc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0WzBdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGFsbCB0aGUgaXRlbXMgaW4gdGhlIGxpc3RcbiAgICovXG4gIHNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnNlbGVjdEFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhbGwgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LmRlc2VsZWN0QWxsKCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL3NlbGVjdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuL3NlbGVjdGlvbi5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW1NlbGVjdGlvbkRpcmVjdGl2ZSwgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtTZWxlY3Rpb25EaXJlY3RpdmUsIFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdjb250YWN0LWdyb3VwJ1xufSlcbmV4cG9ydCBjbGFzcyBDb250YWN0c05nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgY29udGFjdHM6IENvbnRhY3RbXTtcbiAgICBASW5wdXQoKSBvcmdhbml6YXRpb246IHN0cmluZztcbiAgICBASW5wdXQoKSBzaXplOiAnbWVkaXVtJyB8ICdzbWFsbCc7XG4gICAgQElucHV0KCkgY29sb3JzOiBhbnk7XG4gICAgQElucHV0KCkgbWF4Q29udGFjdHM6IG51bWJlcjtcblxuICAgIEBPdXRwdXQoKSBvdmVyZmxvd0NsaWNrOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2NvbnRhY3RHcm91cCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFjdCB7XG4gICAgdGVzdDogc3RyaW5nO1xuICAgIHN0YXR1czogJ2FjdGl2ZScgfCAncGFzc2l2ZSc7XG4gICAgY3VzdG9tVG9vbHRpcD86IHtcbiAgICAgICAgdGVtcGxhdGU6IHN0cmluZyxcbiAgICAgICAgdG9vbHRpcFBvc2l0aW9uOiBzdHJpbmc7XG4gICAgICAgIGRhdGE/OiBhbnk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcmdhbml6YXRpb24ge1xuICAgIHRleHQ6IHN0cmluZztcbiAgICBsYWJlbDogJ2V4dGVybmFsJyB8ICdyaXNrJztcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIGN1c3RvbVRvb2x0aXA/OiB7XG4gICAgICAgIHRlbXBsYXRlOiBzdHJpbmcsXG4gICAgICAgIHRvb2x0aXBQb3NpdGlvbjogc3RyaW5nO1xuICAgICAgICBkYXRhPzogYW55O1xuICAgIH07XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2V4cGFuZC1pbnB1dCdcbn0pXG5leHBvcnQgY2xhc3MgRXhwYW5kSW5wdXROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGVsbmFtZTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHBsYWNlSG9sZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xlYXJUZXh0SWNvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNsb3NlU2VhcmNoOiBzdHJpbmc7XG4gICAgQElucHV0KCkgZXhwYW5kQWx3YXlzOiBib29sZWFuO1xuICAgIEBJbnB1dCgpIG9uRW50ZXI6IEZ1bmN0aW9uO1xuXG4gICAgQE91dHB1dCgpIGZvY3VzOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdleHBhbmRJbnB1dCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZmxvYXRpbmctYWN0aW9uLWJ1dHRvbidcbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25OZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGl0ZW1zOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbkl0ZW1bXSA9IFtdO1xuICAgIEBJbnB1dCgpIHByaW1hcnk6IHN0cmluZztcbiAgICBASW5wdXQoKSBkaXJlY3Rpb246ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnO1xuICAgIEBJbnB1dCgpIGZhYlRvb2x0aXA6IHN0cmluZztcbiAgICBASW5wdXQoKSBmYWJUb29sdGlwUGxhY2VtZW50OiAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JztcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignZmxvYXRpbmdBY3Rpb25CdXR0b24nLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZsb2F0aW5nQWN0aW9uQnV0dG9uSXRlbSB7XG4gICAgaWNvbjogc3RyaW5nO1xuICAgIGV2ZW50OiBGdW5jdGlvbjtcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIHRvb2x0aXBQbGFjZW1lbnQ/OiBzdHJpbmc7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2Zsb3QnXG59KVxuZXhwb3J0IGNsYXNzIEZsb3ROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGFzZXQ6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgY2FsbGJhY2s6IGFueTtcbiAgICBASW5wdXQoKSBkb251dExhYmVsczogYW55O1xuICAgIEBPdXRwdXQoKSBvblBsb3RDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICAgIEBPdXRwdXQoKSBvblBsb3RIb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eEZsb3ROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2dyaWQnXG59KVxuZXhwb3J0IGNsYXNzIEdyaWROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIHNvdXJjZTogYW55W10gPSBbXTtcbiAgICBASW5wdXQoKSBjb2x1bW5zOiBHcmlkQ29sdW1uW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaW5wdXRzIGFyZSB1bmRvY3VtZW50ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgZXZlbnRzOiBhbnk7XG4gICAgQElucHV0KCkgcGx1Z2luczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdncmlkJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkQ29sdW1uIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHRlbXBsYXRlOiBzdHJpbmc7XG4gICAgd2lkdGg/OiBzdHJpbmc7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnaGllcmFyY2h5LWJhcidcbn0pXG5leHBvcnQgY2xhc3MgSGllcmFyY2h5QmFyTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnlbXTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBIaWVyYXJjaHlCYXJPcHRpb25zO1xuICAgIEBJbnB1dCgpIHNlbGVjdE5vZGU6IGFueTtcbiAgICBASW5wdXQoKSBjb250YWluZXJDbGFzczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdoaWVyYXJjaHlCYXInLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpZXJhcmNoeUJhck9wdGlvbnMge1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgb3ZlcnZpZXc/OiBGdW5jdGlvbjtcbiAgICBpbWFnZTogRnVuY3Rpb247XG4gICAgdmFsdWVGb3JtYXR0ZXI6IEZ1bmN0aW9uO1xuICAgIGFjdGlvbj86IHtcbiAgICAgICAgdGl0bGU6IHN0cmluZztcbiAgICAgICAgZXZlbnQ6IEZ1bmN0aW9uO1xuICAgIH07XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ21hcnF1ZWUtd2l6YXJkJ1xufSlcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSB3aXphcmRJY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgd2l6YXJkU3RlcHM6IE1hcnF1ZWVXaXphcmRTdGVwW107XG4gICAgQElucHV0KCkgYnV0dG9uT3B0aW9uczogTWFycXVlZVdpemFyZE9wdGlvbnM7XG4gICAgQElucHV0KCkgb25DaGFuZ2luZzogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25GaW5pc2hlZDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25GaW5pc2hpbmc6IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIG9uQ2FuY2VsZWQ6IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIGlzVmlzaXRlZDogYm9vbGVhbjtcbiAgICBASW5wdXQoKSBzaWRlSW5mbzogTWFycXVlZVdpemFyZFNpZGVJbmZvO1xuXG4gICAgQE91dHB1dCgpIHdpemFyZFN0ZXBzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TWFycXVlZVdpemFyZFN0ZXBbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPE1hcnF1ZWVXaXphcmRTdGVwW10+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ21hcnF1ZWVXaXphcmQnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcnF1ZWVXaXphcmRTdGVwIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGh0bWw/OiBzdHJpbmc7XG4gICAgaGVhZGVyPzogc3RyaW5nO1xuICAgIHRlbXBsYXRlVXJsPzogc3RyaW5nO1xuICAgIGhpZGRlbj86IGJvb2xlYW47XG4gICAgZXJyb3I/OiBib29sZWFuO1xuICAgIGNvbXBsZXRlZD86IGJvb2xlYW47XG4gICAgdmlzaXRlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZE9wdGlvbnMge1xuICAgIG5leHRUZXh0Pzogc3RyaW5nO1xuICAgIHByZXZpb3VzVGV4dD86IHN0cmluZztcbiAgICBmaW5pc2hUZXh0Pzogc3RyaW5nO1xuICAgIHNob3dOZXh0PzogYm9vbGVhbjtcbiAgICBzaG93UHJldmlvdXM/OiBib29sZWFuO1xuICAgIHNob3dGaW5pc2g/OiBib29sZWFuO1xuICAgIG5leHRUb29sdGlwPzogc3RyaW5nO1xuICAgIHByZXZpb3VzVG9vbHRpcD86IHN0cmluZztcbiAgICBmaW5pc2hUb29sdGlwPzogc3RyaW5nO1xuICAgIHByZXZpb3VzRW5hYmxlZD86IGJvb2xlYW47XG4gICAgbmV4dEVuYWJsZWQ/OiBib29sZWFuO1xuICAgIGZpbmlzaEVuYWJsZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcnF1ZWVXaXphcmRTaWRlSW5mbyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ25lc3RlZC1kb251dCdcbn0pXG5leHBvcnQgY2xhc3MgTmVzdGVkRG9udXROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGFzZXQ6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4TmVzdGVkRG9udXROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdvcmdhbml6YXRpb24tY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBPdXRwdXQoKSBkYXRhQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gICAgQE91dHB1dCgpIG9wdGlvbnNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhPcmdhbml6YXRpb25DaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAncGFydGl0aW9uLW1hcCdcbn0pXG5leHBvcnQgY2xhc3MgUGFydGl0aW9uTWFwTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydE9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydExvYWRpbmc6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQYXJ0aXRpb25NYXBOZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2Jhci1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgUGVpdHlCYXJDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YTogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQZWl0eUJhckNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdsaW5lLWNoYXJ0J1xufSlcbmV4cG9ydCBjbGFzcyBQZWl0eUxpbmVDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YTogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQZWl0eUxpbmVDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAncGllLWNoYXJ0J1xufSlcbmV4cG9ydCBjbGFzcyBQZWl0eVBpZUNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5UGllQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3VwZGF0aW5nLWxpbmUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5VXBkYXRpbmdMaW5lQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgbWV0aG9kOiBhbnk7XG4gICAgQElucHV0KCkgdXBkYXRlaW50ZXJ2YWw6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQZWl0eVVwZGF0aW5nTGluZUNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzYW5rZXknXG59KVxuZXhwb3J0IGNsYXNzIFNhbmtleU5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgY2hhcnRTaXplOiBhbnk7XG4gICAgQElucHV0KCkgY2hhcnREYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIGNsaWNrOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4U2Fua2V5TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzZWFyY2gtdG9vbGJhcidcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc2VhcmNoVHlwZWFoZWFkOiBhbnlbXTtcbiAgICBASW5wdXQoKSBwbGFjZUhvbGRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNsb3NlU2VhcmNoOiBzdHJpbmc7XG4gICAgQElucHV0KCkgb25TZWFyY2g6IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIG9uRm9jdXM6IEZ1bmN0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzZWFyY2hUb29sYmFyJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnc2VsZWN0LXRhYmxlJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3RUYWJsZU5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgdmFsdWVzOiBhbnlbXTtcbiAgICBASW5wdXQoKSBtdWx0aXBsZVNlbGVjdDogYm9vbGVhbjtcbiAgICBASW5wdXQoKSBzZWxlY3RLZXk6IHN0cmluZztcbiAgICBASW5wdXQoKSBzZWxlY3RlZDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlYXJjaFRleHQ6IHN0cmluZztcbiAgICBASW5wdXQoKSB0YWJsZUhlaWdodDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdEhpZGRlbkl0ZW1zOiAnY2xlYXInIHwgJ3Jlc2VsZWN0JztcblxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignc2VsZWN0VGFibGUnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFNMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNsaWRlckNoYXJ0TmcxQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzbGlkZXItY2hhcnQnLFxuICAgIHByb3ZpZGVyczogW1NMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgQElucHV0KCkgc2xpZGVyT3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIG5nTW9kZWw6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydE9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcblxuICAgIEBPdXRwdXQoKSBuZ01vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzbGlkZXJDaGFydCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKG9iajogYW55KTogdm9pZCB7IH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQgeyB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7IH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzb2NpYWwtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFNvY2lhbENoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIHdpZHRoOiBhbnk7XG4gICAgQElucHV0KCkgaGVpZ2h0OiBhbnk7XG4gICAgQElucHV0KCkgYXBpOiBhbnk7XG4gICAgQElucHV0KCkgY29tbXVuaXRpZXM6IGFueTtcbiAgICBASW5wdXQoKSBkZXRhaWxTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIHBvcG92ZXJTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVEZXRhaWw6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlRGV0YWlsOiBhbnk7XG4gICAgQElucHV0KCkgbm9kZVBvcG92ZXI6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlUG9wb3ZlcjogYW55O1xuICAgIEBJbnB1dCgpIGZvcmNlQXRsYXNEdXJhdGlvbjogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVTaXplQXR0cmlidXRlOiBhbnk7XG4gICAgQElucHV0KCkgc3RhcnRNYXhpbWl6ZWQ6IGFueTtcbiAgICBASW5wdXQoKSBzdGFydE1heGltaXNlZDogYW55O1xuICAgIEBJbnB1dCgpIHNob3dNYXhpbWl6ZUNvbnRyb2w6IGFueTtcbiAgICBASW5wdXQoKSBzaG93TWF4aW1pc2VDb250cm9sOiBhbnk7XG4gICAgQElucHV0KCkgc29jaWFsQ2hhcnRDb250YWluZXI6IGFueTtcbiAgICBASW5wdXQoKSBmdWxsc2NyZWVuQnV0dG9uUG9zaXRpb246IGFueTtcbiAgICBASW5wdXQoKSBsb2NhbFN0cmluZ3M6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydFRpdGxlOiBhbnk7XG4gICAgQElucHV0KCkgdGl0bGVEaXNwbGF5VGltZTogYW55O1xuICAgIEBJbnB1dCgpIGVkZ2VXZWlnaHRJbmZsdWVuY2U6IGFueTtcbiAgICBASW5wdXQoKSBtaW5MYWJlbHM6IGFueTtcbiAgICBcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhTb2NpYWxDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnc29ydC1kaXJlY3Rpb24tdG9nZ2xlJ1xufSlcbmV4cG9ydCBjbGFzcyBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNvcnRlcnM6IFNvcnREaXJlY3Rpb25Ub2dnbGVTb3J0ZXJbXTtcbiAgICBASW5wdXQoKSBkZXNjZW5kOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzb3J0RGlyZWN0aW9uVG9nZ2xlJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0RGlyZWN0aW9uVG9nZ2xlU29ydGVyIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc29ydDogc3RyaW5nO1xuICAgIGRlZmF1bHRTb3J0ZXI6IGJvb2xlYW47XG4gICAgc2VsZWN0OiBGdW5jdGlvbjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndHJlZWdyaWQnXG59KVxuZXhwb3J0IGNsYXNzIFRyZWVHcmlkTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnlbXSB8IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIGNvbHVtbnM6IFRyZWVHcmlkQ29sdW1uW107XG4gICAgQElucHV0KCkgdHJlZURhdGE6IFRyZWVHcmlkRGF0YVtdO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBhbnlbXTtcbiAgICBASW5wdXQoKSBjdXJyZW50Um93OiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogVHJlZUdyaWRPcHRpb25zO1xuXG4gICAgQE91dHB1dCgpIG9wdGlvbnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+KCk7XG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcbiAgICBAT3V0cHV0KCkgY3VycmVudFJvd0NoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgICBAT3V0cHV0KCkgdHJlZURhdGFDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZERhdGFbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPFRyZWVHcmlkRGF0YVtdPigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd0cmVlZ3JpZCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJlZUdyaWRDb2x1bW4ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZT86IHN0cmluZyB8IEZ1bmN0aW9uO1xuICAgIHRlbXBsYXRlPzogc3RyaW5nO1xuICAgIGhlYWRlckNsYXNzPzogc3RyaW5nO1xuICAgIGNlbGxDbGFzcz86IHN0cmluZztcbiAgICB3aWR0aD86IHN0cmluZztcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIHRvb2x0aXBQbGFjZW1lbnQ/OiAndG9wJyB8ICdib3R0b20nIHwgJ2xlZnQnIHwgJ3JpZ2h0Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmVlR3JpZERhdGEge1xuICAgIGRhdGFJdGVtOiBhbnk7XG4gICAgY2hpbGRyZW46IGFueVtdO1xuICAgIGV4cGFuZGVkOiBib29sZWFuO1xuICAgIGV4cGFuZGluZzogYm9vbGVhbjtcbiAgICBsZXZlbDogbnVtYmVyO1xuICAgIGFwaTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyZWVHcmlkT3B0aW9ucyB7XG4gICAgY2hpbGRyZW5Qcm9wZXJ0eT86IHN0cmluZztcbiAgICBoYXNDaGlsZHJlbj86IEZ1bmN0aW9uO1xuICAgIG1heERlcHRoPzogbnVtYmVyO1xuICAgIGV4cGFuZFRvcExldmVsPzogYm9vbGVhbjtcbiAgICBzZWxlY3Q/OiBhbnk7XG4gICAgZXhwYW5kZXI/OiBhbnk7XG4gICAgaWNvbnM/OiBhbnk7XG4gICAgcm93Q2xhc3M/OiBzdHJpbmcgfCBGdW5jdGlvbjtcbiAgICBzb3J0PzogRnVuY3Rpb247XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd0aHVtYm5haWwnXG59KVxuZXhwb3J0IGNsYXNzIFRodW1ibmFpbE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgdXJsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2hvdzogYm9vbGVhbjtcbiAgICBASW5wdXQoKSB3aWR0aDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGhlaWdodDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd0aHVtYm5haWwnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElOYXZpZ2F0aW9uTWVudVNlcnZpY2UgfSBmcm9tICcuL25hdmlnYXRpb24tbWVudS5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlIGltcGxlbWVudHMgSU5hdmlnYXRpb25NZW51U2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvciggQEluamVjdCgnJG5hdmlnYXRpb25NZW51JykgcHJpdmF0ZSBfbmF2aWdhdGlvbk1lbnVTZXJ2aWNlOiBJTmF2aWdhdGlvbk1lbnVTZXJ2aWNlKSB7IH1cblxuICAgIHNob3coKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5zaG93KCk7XG4gICAgfVxuXG4gICAgaGlkZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICB2aXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLnZpc2libGUoKTtcbiAgICB9XG5cbiAgICBjb2xsYXBzZUF0V2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5jb2xsYXBzZUF0V2lkdGgoKTtcbiAgICB9XG5cbiAgICBzZXRDb2xsYXBzZUF0V2lkdGgod2lkdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2Uuc2V0Q29sbGFwc2VBdFdpZHRoKHdpZHRoKTtcbiAgICB9XG5cbiAgICBzZXREZWZhdWx0Q29sbGFwc2VBdFdpZHRoKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2Uuc2V0RGVmYXVsdENvbGxhcHNlQXRXaWR0aCgpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGlvbk1lbnVTZXJ2aWNlRmFjdG9yeShpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KCckbmF2aWdhdGlvbk1lbnUnKTtcbn1cblxuZXhwb3J0IGNvbnN0IG5hdmlnYXRpb25NZW51U2VydmljZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6ICckbmF2aWdhdGlvbk1lbnUnLFxuICAgIHVzZUZhY3Rvcnk6IG5hdmlnYXRpb25NZW51U2VydmljZUZhY3RvcnksXG4gICAgZGVwczogWyckaW5qZWN0b3InXVxufTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJUGRmU2VydmljZSwgUGRmQ29sdW1ucywgUGRmT3B0aW9ucywgUGRmRG9jdW1lbnQgfSBmcm9tICcuL3BkZi5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGRmU2VydmljZSBpbXBsZW1lbnRzIElQZGZTZXJ2aWNlIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KCckcGRmJykgcHJpdmF0ZSBfcGRmU2VydmljZTogSVBkZlNlcnZpY2UpIHsgfVxuICAgIFxuICAgIGNyZWF0ZVRhYmxlKGNvbHVtbnM6IFBkZkNvbHVtbnMsIHJvd3M6IGFueVtdLCBvcHRpb25zOiBQZGZPcHRpb25zID0ge30pOiBQZGZEb2N1bWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZGZTZXJ2aWNlLmNyZWF0ZVRhYmxlKGNvbHVtbnMsIHJvd3MsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBkZlNlcnZpY2VGYWN0b3J5KGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHJldHVybiBpbmplY3Rvci5nZXQoJyRwZGYnKTtcbn1cblxuZXhwb3J0IGNvbnN0IHBkZlNlcnZpY2VQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiAnJHBkZicsXG4gICAgdXNlRmFjdG9yeTogcGRmU2VydmljZUZhY3RvcnksXG4gICAgZGVwczogWyckaW5qZWN0b3InXVxufTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJVGltZUFnb1NlcnZpY2UsIFRpbWVBZ29Mb2NhbGl6ZWRUaW1lcyB9IGZyb20gJy4vdGltZS1hZ28uaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRpbWVBZ29TZXJ2aWNlIGltcGxlbWVudHMgSVRpbWVBZ29TZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoJ3RpbWVBZ29TZXJ2aWNlJykgcHJpdmF0ZSBfdGltZUFnb1NlcnZpY2U6IElUaW1lQWdvU2VydmljZSkgeyB9XG5cbiAgICBzZXRTdHJpbmdzKHN0cmluZ3M6IFRpbWVBZ29Mb2NhbGl6ZWRUaW1lcyk6IHZvaWQge1xuICAgICAgICB0aGlzLl90aW1lQWdvU2VydmljZS5zZXRTdHJpbmdzKHN0cmluZ3MpO1xuICAgIH1cblxuICAgIHRpbWVTaW5jZShwYXN0OiBEYXRlLCBwcmVzZW50OiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVBZ29TZXJ2aWNlLnRpbWVTaW5jZShwYXN0LCBwcmVzZW50KTtcbiAgICB9XG5cbiAgICB0aW1lU2luY2VOb3cobW9tZW50OiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVBZ29TZXJ2aWNlLnRpbWVTaW5jZU5vdyhtb21lbnQpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUFnb1NlcnZpY2VGYWN0b3J5KGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHJldHVybiBpbmplY3Rvci5nZXQoJ3RpbWVBZ29TZXJ2aWNlJyk7XG59XG5cbmV4cG9ydCBjb25zdCB0aW1lQWdvU2VydmljZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6ICd0aW1lQWdvU2VydmljZScsXG4gICAgdXNlRmFjdG9yeTogdGltZUFnb1NlcnZpY2VGYWN0b3J5LFxuICAgIGRlcHM6IFsnJGluamVjdG9yJ11cbn07IiwiaW1wb3J0IHsgTmdNb2R1bGUsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmxvdE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9mbG90L2Zsb3QuY29tcG9uZW50JztcbmltcG9ydCB7IE5lc3RlZERvbnV0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL25lc3RlZC1kb251dC9uZXN0ZWQtZG9udXQuY29tcG9uZW50JztcbmltcG9ydCB7IE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL29yZ2FuaXphdGlvbi1jaGFydC9vcmdhbml6YXRpb24tY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFBhcnRpdGlvbk1hcE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wYXJ0aXRpb24tbWFwL3BhcnRpdGlvbi1tYXAuY29tcG9uZW50JztcbmltcG9ydCB7IFBlaXR5QmFyQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktYmFyLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eUxpbmVDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1saW5lLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eVBpZUNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LXBpZS1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS11cGRhdGluZy1saW5lLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTYW5rZXlOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2Fua2V5LWNoYXJ0L3NhbmtleS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU29jaWFsQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc29jaWFsLWNoYXJ0L3NvY2lhbC1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGltZUFnb1NlcnZpY2UsIHRpbWVBZ29TZXJ2aWNlUHJvdmlkZXIgfSBmcm9tICcuL3NlcnZpY2VzL3RpbWUtYWdvL3RpbWUtYWdvLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGRmU2VydmljZSwgcGRmU2VydmljZVByb3ZpZGVyIH0gZnJvbSAnLi9zZXJ2aWNlcy9wZGYvcGRmLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlLCBuYXZpZ2F0aW9uTWVudVNlcnZpY2VQcm92aWRlciB9IGZyb20gJy4vc2VydmljZXMvbmF2aWdhdGlvbi1tZW51L25hdmlnYXRpb24tbWVudS5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZ3JpZC9ncmlkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaHVtYm5haWxOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvdGh1bWJuYWlsL3RodW1ibmFpbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSGllcmFyY2h5QmFyTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29udGFjdHNOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvY29udGFjdHMvY29udGFjdHMuY29tcG9uZW50JztcbmltcG9ydCB7IEV4cGFuZElucHV0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2V4cGFuZC1pbnB1dC9leHBhbmQtaW5wdXQuY29tcG9uZW50JztcbmltcG9ydCB7IFNvcnREaXJlY3Rpb25Ub2dnbGVOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc29ydC1kaXJlY3Rpb24tdG9nZ2xlL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2gtdG9vbGJhci9zZWFyY2gtdG9vbGJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgVHJlZUdyaWROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0VGFibGVOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2VsZWN0LXRhYmxlL3NlbGVjdC10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2xpZGVyLWNoYXJ0L3NsaWRlci1jaGFydC5kaXJlY3RpdmUnO1xuXG5jb25zdCBkZWNsYXJhdGlvbnMgPSBbXG4gICAgQ29udGFjdHNOZzFDb21wb25lbnQsXG4gICAgRXhwYW5kSW5wdXROZzFDb21wb25lbnQsXG4gICAgRmxvYXRpbmdBY3Rpb25CdXR0b25OZzFDb21wb25lbnQsXG4gICAgRmxvdE5nMUNvbXBvbmVudCxcbiAgICBHcmlkTmcxQ29tcG9uZW50LFxuICAgIEhpZXJhcmNoeUJhck5nMUNvbXBvbmVudCxcbiAgICBNYXJxdWVlV2l6YXJkTmcxQ29tcG9uZW50LFxuICAgIE5lc3RlZERvbnV0TmcxQ29tcG9uZW50LFxuICAgIE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBhcnRpdGlvbk1hcE5nMUNvbXBvbmVudCxcbiAgICBQZWl0eUJhckNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBlaXR5TGluZUNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBlaXR5UGllQ2hhcnROZzFDb21wb25lbnQsXG4gICAgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTYW5rZXlOZzFDb21wb25lbnQsXG4gICAgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCxcbiAgICBTZWxlY3RUYWJsZU5nMUNvbXBvbmVudCxcbiAgICBTbGlkZXJDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTb2NpYWxDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50LFxuICAgIFRyZWVHcmlkTmcxQ29tcG9uZW50LFxuICAgIFRodW1ibmFpbE5nMUNvbXBvbmVudCxcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogZGVjbGFyYXRpb25zLFxuICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBuYXZpZ2F0aW9uTWVudVNlcnZpY2VQcm92aWRlcixcbiAgICAgICAgcGRmU2VydmljZVByb3ZpZGVyLFxuICAgICAgICB0aW1lQWdvU2VydmljZVByb3ZpZGVyLFxuICAgICAgICBUaW1lQWdvU2VydmljZSxcbiAgICAgICAgUGRmU2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlLFxuICAgIF0sXG59KVxuZXhwb3J0IGNsYXNzIEh5YnJpZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFBpcGUsIEluamVjdGFibGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICdzdHJpbmdGaWx0ZXInXG59KVxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0cmluZ0ZpbHRlclBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICB0cmFuc2Zvcm0oaXRlbXM6IGFueVtdLCB2YWx1ZTogc3RyaW5nKTogYW55W10geyAgXG4gICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGl0ID0+IGl0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWx1ZS50b0xvd2VyQ2FzZSgpKSA+PSAwKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgU3RyaW5nRmlsdGVyUGlwZSB9IGZyb20gJy4vc3RyaW5nLWZpbHRlci5waXBlJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW1N0cmluZ0ZpbHRlclBpcGVdLFxuICAgIGRlY2xhcmF0aW9uczogW1N0cmluZ0ZpbHRlclBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIFN0cmluZ0ZpbHRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9zdG9yYWdlLWFkYXB0ZXInO1xuXG5leHBvcnQgY2xhc3MgQ29va2llQWRhcHRlciBpbXBsZW1lbnRzIFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5jb29raWUpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IGFsbCB0aGUgY29va2llcyBmb3IgdGhpcyBzaXRlXG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGNvb2tpZXMgaW50byBhIGZyb20gd2UgY2FuIGVhc2lseSBtYW5hZ2VcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gY29va2llc1xuICAgICAgICAgICAgICAgIC5tYXAoY29va2llID0+ICh7IGtleTogY29va2llLnNwbGl0KCc9JylbMF0udHJpbSgpLCB2YWx1ZTogY29va2llLnNwbGl0KCc9JylbMV0udHJpbSgpIH0pKVxuICAgICAgICAgICAgICAgIC5maW5kKGNvb2tpZSA9PiBjb29raWUua2V5ID09PSBrZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC52YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke2tleX09JHt2YWx1ZX07IHBhdGg9L2A7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpLmZvckVhY2goY29va2llID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVxUG9zID0gY29va2llLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlcVBvcyA+IC0xID8gY29va2llLnN1YnN0cigwLCBlcVBvcykudHJpbSgpIDogY29va2llO1xuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLnRyaW0oKS5yZXBsYWNlKC89LiovLCBgPTtleHBpcmVzPSR7bmV3IERhdGUoKS50b1VUQ1N0cmluZygpfTtwYXRoPS9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gY2FsbCByZW1vdmUgaXRlbSBvbiBlYWNoIGNvb2tpZVxuICAgICAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKS5tYXAoY29va2llID0+IGNvb2tpZS5zcGxpdCgnPScpWzBdLnRyaW0oKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvb2tpZSA9PiB0aGlzLnJlbW92ZUl0ZW0oY29va2llKSk7XG4gICAgfVxuXG4gICAgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyIHtcbiAgICAgICAgLy8gY29va2llcyBhcmUgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vyc1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IENvb2tpZUFkYXB0ZXIgfSBmcm9tICcuL2Nvb2tpZS1hZGFwdGVyJztcblxuZXhwb3J0IGNsYXNzIExvY2FsU3RvcmFnZUFkYXB0ZXIgaW1wbGVtZW50cyBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgIH1cblxuICAgIGdldFN1cHBvcnRlZCgpOiBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICAgICAgLy8gaWYgbG9jYWwgc3RvcmFnZSB2YXJpYWJsZSBkb2VzIG5vdCBleGlzdCBmYWxsIGJhY2sgdG8gY29va2llc1xuICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gbWFrZSBhIHRlc3Qgc2F2ZSB0byBsb2NhbCBzdG9yYWdlIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IGV4Y2VwdGlvbnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScsICd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL3N0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBDb29raWVBZGFwdGVyIH0gZnJvbSAnLi9jb29raWUtYWRhcHRlcic7XG5cbmV4cG9ydCBjbGFzcyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIgaW1wbGVtZW50cyBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgICAgICAvLyBpZiBsb2NhbCBzdG9yYWdlIHZhcmlhYmxlIGRvZXMgbm90IGV4aXN0IGZhbGwgYmFjayB0byBjb29raWVzXG4gICAgICAgIGlmICghc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgYSB0ZXN0IHNhdmUgdG8gbG9jYWwgc3RvcmFnZSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBleGNlcHRpb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScsICd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IENvb2tpZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL2Nvb2tpZS1hZGFwdGVyJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL2xvY2FsLXN0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL3Nlc3Npb24tc3RvcmFnZS1hZGFwdGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBlcnNpc3RlbnREYXRhU2VydmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBpdGVtIGluIHNvbWUgZm9ybSBvZiBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgKi9cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCB0eXBlOiBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlID0gUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Mb2NhbFN0b3JhZ2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nZXRBZGFwdGVyKHR5cGUpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgZ2V0SXRlbShrZXk6IHN0cmluZywgdHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5nZXRJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZywgdHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgY2xlYXIodHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgYWRhcHRlciBiYXNlZCBvbiB0aGUgdHlwZSByZXF1ZXN0ZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEFkYXB0ZXIodHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSk6IFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkNvb2tpZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvb2tpZUFkYXB0ZXIoKTtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkxvY2FsU3RvcmFnZTpcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0b3JhZ2VBZGFwdGVyID0gbmV3IExvY2FsU3RvcmFnZUFkYXB0ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlQWRhcHRlci5nZXRTdXBwb3J0ZWQoKTtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLlNlc3Npb25TdG9yYWdlOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25TdG9yYWdlQWRhcHRlciA9IG5ldyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2VBZGFwdGVyLmdldFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlIHtcbiAgICBMb2NhbFN0b3JhZ2UsXG4gICAgQ29va2llLFxuICAgIFNlc3Npb25TdG9yYWdlXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUGVyc2lzdGVudERhdGFTZXJ2aWNlIH0gZnJvbSAnLi9wZXJzaXN0ZW50LWRhdGEuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgcHJvdmlkZXJzOiBbUGVyc2lzdGVudERhdGFTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgUGVyc2lzdGVudERhdGFNb2R1bGUgeyB9XG4iLCJleHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RvcmFnZUFkYXB0ZXIge1xuICAgIGFic3RyYWN0IGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgYWJzdHJhY3Qgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgY2xlYXIoKTogdm9pZDtcbiAgICBhYnN0cmFjdCBnZXRTdXBwb3J0ZWQoKTogU3RvcmFnZUFkYXB0ZXI7XG59Il0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIklucHV0IiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiLCJSb3V0ZXJNb2R1bGUiLCJTdWJzY3JpcHRpb24iLCJCZWhhdmlvclN1YmplY3QiLCJmcm9tRXZlbnQiLCJJbmplY3RhYmxlIiwiUmVuZGVyZXJGYWN0b3J5MiIsIk5nWm9uZSIsIkV2ZW50RW1pdHRlciIsImRlYm91bmNlVGltZSIsIkRpcmVjdGl2ZSIsIkVsZW1lbnRSZWYiLCJPdXRwdXQiLCJmaWx0ZXIiLCJtYXAiLCJDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSIsIkNvbnRlbnRDaGlsZCIsIlRlbXBsYXRlUmVmIiwiSG9zdEJpbmRpbmciLCJWaWV3Q2hpbGQiLCJOR19WQUxVRV9BQ0NFU1NPUiIsImZvcndhcmRSZWYiLCJGb3Jtc01vZHVsZSIsIlN1YmplY3QiLCJ0YWtlVW50aWwiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsIk9wdGlvbmFsIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJ0c2xpYl8xLl9fYXNzaWduIiwiZGVsYXkiLCJSZW5kZXJlcjIiLCJWaWV3RW5jYXBzdWxhdGlvbiIsIlBpcGUiLCJjb21iaW5lTGF0ZXN0IiwibW9udGhzIiwiQ2hhbmdlRGV0ZWN0b3JSZWYiLCJ0b29sdGlwIiwiQ29tcG9uZW50UG9ydGFsIiwiVmlld0NvbnRhaW5lclJlZiIsIk92ZXJsYXkiLCJTY3JvbGxEaXNwYXRjaGVyIiwiT3ZlcmxheU1vZHVsZSIsIk9ic2VydmVyc01vZHVsZSIsIkhvc3RMaXN0ZW5lciIsImZpbHRlck9wZXJhdG9yIiwiYXVkaXRUaW1lIiwib2YiLCJmcm9tIiwiZmlyc3QiLCJDb250ZW50Q2hpbGRyZW4iLCIoKGRyYWd1bGFOYW1lc3BhY2UpKS5kZWZhdWx0IiwidHNsaWJfMS5fX3ZhbHVlcyIsIkxpdmVBbm5vdW5jZXIiLCJIb3N0IiwiRm9jdXNLZXlNYW5hZ2VyIiwiVmlld0NoaWxkcmVuIiwidW5pcXVlSWQiLCJ0YXAiLCJtZXJnZU1hcCIsIk9ic2VydmFibGUiLCJERUNMQVJBVElPTlMiLCJBMTF5TW9kdWxlIiwiSW5qZWN0IiwiRE9DVU1FTlQiLCJCc0Ryb3Bkb3duRGlyZWN0aXZlIiwiQnNEcm9wZG93bk1vZHVsZSIsInRyaWdnZXIiLCJ0cmFuc2l0aW9uIiwicXVlcnkiLCJzdHlsZSIsInN0YWdnZXIiLCJhbmltYXRlIiwiVG9vbHRpcERpcmVjdGl2ZSIsIkF0dHJpYnV0ZSIsIkVTQ0FQRSIsIlF1ZXJ5TGlzdCIsIlJlc3BvbnNlQ29udGVudFR5cGUiLCJIdHRwIiwiSHR0cE1vZHVsZSIsImNvbmNhdCIsInN3aXRjaE1hcCIsInRpbWVyIiwiTmF2aWdhdGlvbkVuZCIsIlNraXBTZWxmIiwiUm91dGVyIiwiQWN0aXZhdGVkUm91dGUiLCJzdGF0ZSIsImRyb3Bkb3duIiwiQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIiwiTkdfVkFMSURBVE9SUyIsIkVYUE9SVFMiLCJOZ01vZGVsIiwiSW5qZWN0b3IiLCJVcGdyYWRlQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7UUE2QkkseUNBQVU7WUFBVixVQUFXLEtBQWlCLEVBQUUsS0FBaUI7Z0JBQzNDLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRTtvQkFDZixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7aUJBQ25DO2FBQ0o7O29CQS9CSkEsY0FBUyxTQUFDO3dCQUNQLFFBQVEsRUFBRSxnQkFBZ0I7d0JBQzFCLFFBQVEsRUFBRSwwdEJBa0JQO3FCQUNOOzs7OzsrQkFJSUMsVUFBSzs7bUNBM0JWOzs7Ozs7O0FDQUE7Ozs7b0JBTUNDLGFBQVEsU0FBQzt3QkFDTixPQUFPLEVBQUU7NEJBQ0xDLG1CQUFZOzRCQUNaQyxtQkFBWTt5QkFDZjt3QkFDRCxPQUFPLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQzt3QkFDL0IsWUFBWSxFQUFFLENBQUMsb0JBQW9CLENBQUM7cUJBQ3ZDOzs7O2dDQWJEOzs7Ozs7Ozs7Ozs7QUNBQTtRQVlJLHVCQUFZLGVBQWlDLEVBQVUsT0FBZTtZQUFmLFlBQU8sR0FBUCxPQUFPLENBQVE7aUNBRjlDLElBQUlDLHlCQUFZLEVBQUU7WUFHdEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUMvRDs7OztRQUVELG1DQUFXO1lBQVg7Z0JBQ0ksSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUNwQzs7Ozs7UUFFRCx5Q0FBaUI7WUFBakIsVUFBa0IsYUFBMEI7Z0JBQTVDLGlCQTREQzs7Z0JBekRHLHFC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