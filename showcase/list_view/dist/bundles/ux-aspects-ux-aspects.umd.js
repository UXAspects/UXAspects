(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/router'), require('rxjs/BehaviorSubject'), require('rxjs/observable/fromEvent'), require('rxjs/Subscription'), require('rxjs/operators'), require('@angular/forms'), require('rxjs/Subject'), require('rxjs/observable/combineLatest'), require('rxjs/Observable'), require('rxjs/observable/from'), require('rxjs/observable/of'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/cdk/observers'), require('dragula'), require('ngx-bootstrap/typeahead'), require('ngx-bootstrap/dropdown'), require('@angular/animations'), require('ngx-bootstrap/tooltip'), require('@angular/cdk/keycodes'), require('@angular/http'), require('rxjs/observable/concat'), require('rxjs/observable/timer'), require('rxjs/operators/map'), require('@angular/platform-browser'), require('rxjs/operators/delay'), require('rxjs'), require('@angular/upgrade/static')) :
    typeof define === 'function' && define.amd ? define('@ux-aspects/ux-aspects', ['exports', '@angular/core', '@angular/common', '@angular/router', 'rxjs/BehaviorSubject', 'rxjs/observable/fromEvent', 'rxjs/Subscription', 'rxjs/operators', '@angular/forms', 'rxjs/Subject', 'rxjs/observable/combineLatest', 'rxjs/Observable', 'rxjs/observable/from', 'rxjs/observable/of', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/cdk/observers', 'dragula', 'ngx-bootstrap/typeahead', 'ngx-bootstrap/dropdown', '@angular/animations', 'ngx-bootstrap/tooltip', '@angular/cdk/keycodes', '@angular/http', 'rxjs/observable/concat', 'rxjs/observable/timer', 'rxjs/operators/map', '@angular/platform-browser', 'rxjs/operators/delay', 'rxjs', '@angular/upgrade/static'], factory) :
    (factory((global['ux-aspects'] = global['ux-aspects'] || {}, global['ux-aspects']['ux-aspects'] = {}),global.ng.core,global.ng.common,global.ng.router,global.rxjs.BehaviorSubject,global.rxjs['observable/fromEvent'],global.rxjs.Subscription,global.rxjs.operators,global.ng.forms,global.rxjs.Subject,global.rxjs['observable/combineLatest'],global.rxjs.Observable,global.rxjs['observable/from'],global.rxjs['observable/of'],global.ng.cdk.overlay,global.ng.cdk.portal,global.ng.cdk.observers,null,null,null,global.ng.animations,null,global.ng.cdk.keycodes,global.ng.http,global.rxjs['observable/concat'],global.rxjs['observable/timer'],global.rxjs['operators/map'],global.ng.platformBrowser,global.rxjs['operators/delay'],global.rxjs,global.ng.upgrade.static));
}(this, (function (exports,core,common,router,BehaviorSubject,fromEvent,Subscription,operators,forms,Subject,combineLatest,Observable,from,of,overlay,portal,observers,dragulaNamespace,typeahead,dropdown,animations,tooltip,keycodes,http,concat,timer,map,platformBrowser,delay,rxjs,_static) { 'use strict';

    var dragulaNamespace__default = 'default' in dragulaNamespace ? dragulaNamespace['default'] : dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsComponent = (function () {
        function BreadcrumbsComponent() {
        }
        /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
        BreadcrumbsComponent.prototype.clickCrumb =
            function (event, crumb) {
                if (crumb.onClick) {
                    crumb.onClick.call(null, event);
                }
            };
        BreadcrumbsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-breadcrumbs',
                        template: "<nav aria-label=\"Breadcrumb\">\n    <ol class=\"breadcrumb\">\n        <li *ngFor=\"let crumb of crumbs\">\n\n            <!-- If there is a router link then use a tag -->\n            <a *ngIf=\"crumb.routerLink || crumb.onClick\"\n                tabindex=\"0\"\n                [routerLink]=\"crumb.routerLink\"\n                [fragment]=\"crumb.fragment\"\n                [queryParams]=\"crumb.queryParams\"\n                (click)=\"clickCrumb($event, crumb)\">\n                {{ crumb.title }}\n            </a>\n\n            <!-- If there is not router link then display text in a span -->\n            <span *ngIf=\"!crumb.routerLink && !crumb.onClick\">{{ crumb.title }}</span>\n        </li>\n    </ol>\n</nav>"
                    },] },
        ];
        /** @nocollapse */
        BreadcrumbsComponent.ctorParameters = function () { return []; };
        BreadcrumbsComponent.propDecorators = {
            "crumbs": [{ type: core.Input },],
        };
        return BreadcrumbsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsModule = (function () {
        function BreadcrumbsModule() {
        }
        BreadcrumbsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [BreadcrumbsComponent],
                        declarations: [BreadcrumbsComponent]
                    },] },
        ];
        /** @nocollapse */
        BreadcrumbsModule.ctorParameters = function () { return []; };
        return BreadcrumbsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeService = (function () {
        function ResizeService(rendererFactory, _ngZone) {
            this._ngZone = _ngZone;
            this._subscription = new Subscription.Subscription();
            this._renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * @return {?}
         */
        ResizeService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} nativeElement
         * @return {?}
         */
        ResizeService.prototype.addResizeListener =
            function (nativeElement) {
                var _this = this;
                // create a behavior subject subject
                var /** @type {?} */ subject = new BehaviorSubject.BehaviorSubject({ width: nativeElement.offsetWidth, height: nativeElement.offsetHeight });
                // determine the style of the element
                var /** @type {?} */ displayMode = window.getComputedStyle(nativeElement).getPropertyValue('display');
                // create the iframe element
                var /** @type {?} */ iframe = this._renderer.createElement('iframe');
                // style the iframe to be invisible but fill containing element
                this._renderer.setStyle(iframe, 'position', 'absolute');
                this._renderer.setStyle(iframe, 'width', '100%');
                this._renderer.setStyle(iframe, 'height', '100%');
                this._renderer.setStyle(iframe, 'top', '0');
                this._renderer.setStyle(iframe, 'right', '0');
                this._renderer.setStyle(iframe, 'bottom', '0');
                this._renderer.setStyle(iframe, 'left', '0');
                this._renderer.setStyle(iframe, 'z-index', '-1');
                this._renderer.setStyle(iframe, 'opacity', '0');
                this._renderer.setStyle(iframe, 'border', 'none');
                this._renderer.setStyle(iframe, 'margin', '0');
                this._renderer.setStyle(iframe, 'pointer-events', 'none');
                this._renderer.setStyle(iframe, 'overflow', 'hidden');
                // ensure the iframe ignores any tabbing
                this._renderer.setAttribute(iframe, 'tabindex', '-1');
                this._renderer.setAttribute(iframe, 'aria-hidden', 'true');
                // statically positioned elements need changed to relative for this method to work
                if (displayMode !== 'relative' && displayMode !== 'absolute' && displayMode !== 'fixed') {
                    this._renderer.setStyle(nativeElement, 'position', 'relative');
                }
                // add the iframe to the container element
                this._renderer.appendChild(nativeElement, iframe);
                this.waitUntilReady(iframe, function () {
                    var /** @type {?} */ iframeDoc = iframe.contentDocument || (iframe.contentWindow.document);
                    var /** @type {?} */ attachListener = function () {
                        // watch for any future resizes - run inside ngzone as an iframe event listener is not patched
                        // watch for any future resizes - run inside ngzone as an iframe event listener is not patched
                        _this._subscription.add(fromEvent.fromEvent(iframe.contentWindow, 'resize').subscribe(function (event) {
                            return _this._ngZone.run(function () { return subject.next({ width: nativeElement.offsetWidth, height: nativeElement.offsetHeight }); });
                        }));
                    };
                    if (iframeDoc.readyState === 'complete') {
                        attachListener();
                    }
                    else {
                        // wait for iframe to load
                        iframe.addEventListener('load', function () { return attachListener(); });
                    }
                });
                return subject;
            };
        /**
         * @param {?} iframe
         * @param {?} callback
         * @return {?}
         */
        ResizeService.prototype.waitUntilReady =
            function (iframe, callback) {
                var _this = this;
                if (iframe.contentDocument || iframe.contentWindow) {
                    callback.call(this);
                }
                else {
                    setTimeout(function () { return _this.waitUntilReady(iframe, callback); });
                }
            };
        ResizeService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ResizeService.ctorParameters = function () {
            return [
                { type: core.RendererFactory2, },
                { type: core.NgZone, },
            ];
        };
        return ResizeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeDirective = (function () {
        function ResizeDirective(_elementRef, _resizeService, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._ngZone = _ngZone;
            this.throttle = 0;
            this.uxResize = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this._resizeService.addResizeListener(this._elementRef.nativeElement)
                    .pipe(operators.debounceTime(this.throttle))
                    .subscribe(function (event) { return _this._ngZone.run(function () { return _this.uxResize.emit(event); }); });
            };
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        ResizeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxResize]',
                        providers: [ResizeService]
                    },] },
        ];
        /** @nocollapse */
        ResizeDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
                { type: core.NgZone, },
            ];
        };
        ResizeDirective.propDecorators = {
            "throttle": [{ type: core.Input },],
            "uxResize": [{ type: core.Output },],
        };
        return ResizeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeModule = (function () {
        function ResizeModule() {
        }
        ResizeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ResizeDirective],
                        declarations: [ResizeDirective],
                        providers: [ResizeService]
                    },] },
        ];
        /** @nocollapse */
        ResizeModule.ctorParameters = function () { return []; };
        return ResizeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabContentDirective = (function () {
        function CardTabContentDirective() {
        }
        CardTabContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxCardTabContent]'
                    },] },
        ];
        /** @nocollapse */
        CardTabContentDirective.ctorParameters = function () { return []; };
        return CardTabContentDirective;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsService = (function () {
        function CardTabsService() {
            var _this = this;
            this.tab$ = new BehaviorSubject.BehaviorSubject(null);
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.position$ = new BehaviorSubject.BehaviorSubject('top');
            // when a tab is added or removed ensure we always select one if any are available
            this._subscription = this.tabs$.pipe(operators.filter(function (tabs) { return !_this.tab$.value || !tabs.find(function (tab) { return tab === _this.tab$.value; }); })).subscribe(function (tabs) { return _this.tab$.next(tabs.length > 0 ? tabs[0] : null); });
        }
        /**
         * @return {?}
         */
        CardTabsService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Add a tab to the list of tabs
         */
        /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.addTab =
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
            };
        /**
         * Remove a tab from the list
         */
        /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.removeTab =
            function (tab) {
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * Select the tab
         */
        /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.select =
            function (tab) {
                this.tab$.next(tab);
            };
        /**
         * Set the position of the tab content
         */
        /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
        CardTabsService.prototype.setPosition =
            function (position) {
                this.position$.next(position);
            };
        CardTabsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        CardTabsService.ctorParameters = function () { return []; };
        return CardTabsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabComponent = (function () {
        function CardTabComponent(_tabService) {
            var _this = this;
            this._tabService = _tabService;
            this.active$ = this._tabService.tab$.pipe(operators.map(function (tab) { return tab === _this; }));
            this._tabService.addTab(this);
        }
        /**
         * @return {?}
         */
        CardTabComponent.prototype.ngOnDestroy =
            function () {
                this._tabService.removeTab(this);
            };
        CardTabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tab',
                        template: "<ng-content *ngIf=\"active$ | async\"></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        CardTabComponent.ctorParameters = function () {
            return [
                { type: CardTabsService, },
            ];
        };
        CardTabComponent.propDecorators = {
            "content": [{ type: core.ContentChild, args: [CardTabContentDirective, { read: core.TemplateRef },] },],
        };
        return CardTabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsetComponent = (function () {
        function CardTabsetComponent(tabService) {
            this.tabService = tabService;
            this.offset = 0;
            this.bounds = { lower: 0, upper: 0 };
        }
        Object.defineProperty(CardTabsetComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabService.position$.getValue();
            },
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this.tabService.setPosition(direction);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.select =
            function (tab, element) {
                // select the tab
                this.tabService.select(tab);
                // ensure the tab is moved into view if required
                this.moveIntoView(element);
            };
        /**
         * @param {?} dimensions
         * @return {?}
         */
        CardTabsetComponent.prototype.resize =
            function (dimensions) {
                this._width = dimensions.width;
                this._innerWidth = this.tablist.nativeElement.scrollWidth;
                this.bounds.lower = 0;
                this.bounds.upper = -(this._innerWidth - this._width);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.previous =
            function () {
                this.offset += this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.min(this.offset, this.bounds.lower);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.next =
            function () {
                this.offset -= this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.max(this.offset, this.bounds.upper);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.moveIntoView =
            function (element) {
                // if we dont have the dimensions we cant check
                if (!this._width || !this._innerWidth) {
                    return;
                }
                // get the current element bounds
                var offsetLeft = element.offsetLeft, offsetWidth = element.offsetWidth;
                var _a = getComputedStyle(element), marginLeft = _a.marginLeft, marginRight = _a.marginRight;
                // calculate the visible area
                var /** @type {?} */ viewportStart = Math.abs(this.offset);
                var /** @type {?} */ viewportEnd = viewportStart + this._width;
                var /** @type {?} */ cardWidth = parseFloat(marginLeft) + offsetWidth + parseFloat(marginRight);
                // if we need to move to the left - figure out how much
                if (offsetLeft < viewportStart) {
                    this.offset -= (offsetLeft - parseFloat(marginLeft)) - viewportStart;
                }
                // if we need to move to the right - figure out how much
                if ((offsetLeft + cardWidth) > viewportEnd) {
                    this.offset -= (offsetLeft + cardWidth) - viewportEnd;
                }
            };
        CardTabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tabset',
                        template: "<div class=\"card-tab-content\" role=\"tabpanel\" *ngIf=\"(tabService.tab$ | async)\">\n    <ng-content></ng-content>\n</div>\n\n<div class=\"card-tabs\" #tabs>\n\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-previous\" aria-label=\"Previous Tabs\" (click)=\"previous()\" *ngIf=\"offset < bounds.lower\">\n        <i class=\"hpe-icon hpe-previous\"></i>\n    </button>\n\n    <div class=\"card-tabs-list\" role=\"tablist\" #tablist (uxResize)=\"resize($event)\" [style.transform]=\"'translateX(' + offset + 'px)'\">\n\n        <div class=\"card-tab\"\n            role=\"tab\"\n            tabindex=\"0\" #card\n            *ngFor=\"let tab of tabService.tabs$ | async\"\n            [ngClass]=\"tabService.position$ | async\"\n            [class.active]=\"tab.active$ | async\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            (click)=\"select(tab, card)\"\n            (focus)=\"tabs.scrollLeft = 0\"\n            (keydown.enter)=\"select(tab, card)\">\n\n            <ng-container [ngTemplateOutlet]=\"tab.content\"></ng-container>\n        </div>\n\n    </div>\n\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-next\" aria-label=\"Next Tabs\" (click)=\"next()\" *ngIf=\"offset > bounds.upper\">\n        <i class=\"hpe-icon hpe-next\"></i>\n    </button>\n</div>",
                        providers: [CardTabsService]
                    },] },
        ];
        /** @nocollapse */
        CardTabsetComponent.ctorParameters = function () {
            return [
                { type: CardTabsService, },
            ];
        };
        CardTabsetComponent.propDecorators = {
            "position": [{ type: core.HostBinding, args: ['class',] }, { type: core.Input },],
            "tablist": [{ type: core.ViewChild, args: ['tablist',] },],
        };
        return CardTabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsModule = (function () {
        function CardTabsModule() {
        }
        CardTabsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        declarations: [CardTabsetComponent, CardTabComponent, CardTabContentDirective],
                        exports: [CardTabsetComponent, CardTabComponent, CardTabContentDirective]
                    },] },
        ];
        /** @nocollapse */
        CardTabsModule.ctorParameters = function () { return []; };
        return CardTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueCheckboxId = 0;
    var CheckboxComponent = (function () {
        function CheckboxComponent() {
            this._checkboxId = "ux-checkbox-" + ++uniqueCheckboxId;
            this.id = this._checkboxId;
            this.tabindex = 0;
            this.clickable = true;
            this.simplified = false;
            this.indeterminateValue = -1;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.indeterminate = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(CheckboxComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // determine if it is in the indeterminate state
                this.indeterminate = this._value === this.indeterminateValue;
                // determine the checked state
                this.ariaChecked = this.indeterminate ? 'mixed' : this._value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._checkboxId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.toggle =
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                if (this.value === this.indeterminateValue) {
                    this.value = true;
                    return;
                }
                // toggle the checked state
                this.value = !this.value;
            };
        // Functions required to update ngModel
        /**
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue =
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        CheckboxComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-checkbox',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-checkbox\"\n       [class.ux-checkbox-checked]=\"value === true\"\n       [class.ux-checkbox-indeterminate]=\"indeterminate\"\n       [class.ux-checkbox-simplified]=\"simplified\"\n       [class.ux-checkbox-disabled]=\"disabled\"\n       [class.ux-checkbox-focused]=\"focused\">\n\n    <div class=\"ux-checkbox-container\">\n        <input type=\"checkbox\"\n               class=\"ux-checkbox-input\"\n               [id]=\"inputId\"\n               [required]=\"required\"\n               [checked]=\"value\"\n               [attr.value]=\"value\"\n               [disabled]=\"disabled\"\n               [attr.name]=\"name\"\n               [tabindex]=\"tabindex\"\n               [indeterminate]=\"indeterminate\"\n               [attr.aria-label]=\"ariaLabel\"\n               [attr.aria-labelledby]=\"ariaLabelledby\"\n               [attr.aria-checked]=\"ariaChecked\"\n               (focus)=\"focused = true\"\n               (blur)=\"focused = false\"\n               (change)=\"$event.stopPropagation()\"\n               (click)=\"toggle()\">\n    </div>\n\n    <span class=\"ux-checkbox-label\">\n        <ng-content></ng-content>\n    </span>\n</label>\n",
                        providers: [CHECKBOX_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        CheckboxComponent.ctorParameters = function () { return []; };
        CheckboxComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "name": [{ type: core.Input },],
            "required": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "clickable": [{ type: core.Input },],
            "simplified": [{ type: core.Input },],
            "indeterminateValue": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
            "ariaLabelledby": [{ type: core.Input, args: ['aria-labelledby',] },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input },],
        };
        return CheckboxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CheckboxModule = (function () {
        function CheckboxModule() {
        }
        CheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [CheckboxComponent],
                        declarations: [CheckboxComponent]
                    },] },
        ];
        /** @nocollapse */
        CheckboxModule.ctorParameters = function () { return []; };
        return CheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingComponent = (function () {
        function ColumnSortingComponent() {
            this.stateChange = new core.EventEmitter();
            this.columnSortingState = ColumnSortingState;
        }
        /**
         * @param {?} parent
         * @return {?}
         */
        ColumnSortingComponent.prototype.initParent =
            function (parent) {
                var _this = this;
                this._parent = parent;
                // watch for any events
                this._parent.events.subscribe(function (event) {
                    var /** @type {?} */ idx = event.findIndex(function (column) { return column.key === _this.key; });
                    if (idx == -1) {
                        _this.state = ColumnSortingState.NoSort;
                    }
                    // only store the number if we have 2 or more columns being sorted
                    if (event.length > 1) {
                        _this.orderNumber = idx === -1 ? null : idx + 1;
                    }
                    else {
                        _this.orderNumber = null;
                    }
                    _this.stateChange.emit(_this.state);
                });
            };
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.changeState =
            function () {
                if (this.state === ColumnSortingState.Ascending) {
                    this.state = ColumnSortingState.Descending;
                }
                else if (this.state === ColumnSortingState.Descending) {
                    this.state = ColumnSortingState.NoSort;
                }
                else {
                    this.state = ColumnSortingState.Ascending;
                }
                // inform parent
                return this._parent.toggleColumn(this.key, this.state);
            };
        ColumnSortingComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-column-sorting',
                        template: "<div class=\"ux-column-sorting\">\n    <i class=\"ux-column-sorting-icon hpe-icon\" \n        [class.hpe-ascend]=\"state === columnSortingState.Ascending\" \n        [class.hpe-descend]=\"state === columnSortingState.Descending\" \n        [class.column-sorting-icon-hidden]=\"state === columnSortingState.NoSort\"></i>\n    <p class=\"ux-column-sorting-number\">{{ orderNumber }}</p>\n</div>",
                        exportAs: 'ux-column-sorting'
                    },] },
        ];
        /** @nocollapse */
        ColumnSortingComponent.ctorParameters = function () { return []; };
        ColumnSortingComponent.propDecorators = {
            "state": [{ type: core.Input },],
            "key": [{ type: core.Input },],
            "orderNumber": [{ type: core.Input },],
            "stateChange": [{ type: core.Output },],
        };
        return ColumnSortingComponent;
    }());
    /** @enum {number} */
    var ColumnSortingState = {
        Ascending: 0,
        Descending: 1,
        NoSort: 2,
    };
    ColumnSortingState[ColumnSortingState.Ascending] = "Ascending";
    ColumnSortingState[ColumnSortingState.Descending] = "Descending";
    ColumnSortingState[ColumnSortingState.NoSort] = "NoSort";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingDirective = (function () {
        function ColumnSortingDirective() {
            this.events = new Subject.Subject();
            this.order = [];
        }
        /**
         * @return {?}
         */
        ColumnSortingDirective.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                this.components.forEach(function (component) { return component.initParent(_this); });
            };
        /**
         * @param {?} key
         * @param {?} state
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleColumn =
            function (key, state) {
                if (this.singleSort) {
                    if (state === ColumnSortingState.NoSort) {
                        this.order = [];
                    }
                    else {
                        this.order = [{ key: key, state: state }];
                    }
                }
                else {
                    // reorder columns here
                    var /** @type {?} */ idx = this.order.findIndex(function (column) { return column.key === key; });
                    // if wasnt previously selected add to list
                    if (idx === -1) {
                        this.order.push({ key: key, state: state });
                    }
                    else if (state === ColumnSortingState.Ascending || state === ColumnSortingState.Descending) {
                        this.order.splice(idx, 1);
                        this.order.push({ key: key, state: state });
                    }
                    else {
                        this.order.splice(idx, 1);
                    }
                }
                this.events.next(this.order);
                // return the order
                return this.order;
            };
        ColumnSortingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxColumnSorting]'
                    },] },
        ];
        /** @nocollapse */
        ColumnSortingDirective.ctorParameters = function () { return []; };
        ColumnSortingDirective.propDecorators = {
            "singleSort": [{ type: core.Input },],
            "components": [{ type: core.ContentChildren, args: [ColumnSortingComponent,] },],
        };
        return ColumnSortingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingModule = (function () {
        function ColumnSortingModule() {
        }
        ColumnSortingModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ColumnSortingComponent, ColumnSortingDirective],
                        declarations: [ColumnSortingComponent, ColumnSortingDirective]
                    },] },
        ];
        /** @nocollapse */
        ColumnSortingModule.ctorParameters = function () { return []; };
        return ColumnSortingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitSubject = (function () {
        function ConduitSubject(conduit, _zone, zoneId) {
            this.conduit = conduit;
            this._zone = _zone;
            this.zoneId = zoneId;
            this._onDestroy = new Subject.Subject();
            // store the target subject object
            this._subject = conduit.subject;
            // check if there are any conduits that have supplied an initial value
            this.getInitialValue();
            // subscribe to changes to the source subject
            this._subject.pipe(operators.distinctUntilChanged(conduit.changeDetection), operators.takeUntil(this._onDestroy))
                .subscribe(this.onOutput.bind(this));
            // subscribe to the zone events and root zone events
            _zone.getEvents().pipe(operators.filter(function (event) { return event.conduit.id === conduit.id; }), operators.takeUntil(this._onDestroy)).subscribe(this.onInput.bind(this));
        }
        /** Check all allow inputs to see if there is a value we should initially set the conduit to */
        /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
        ConduitSubject.prototype.getInitialValue =
            function () {
                var _this = this;
                // if we do not accept inputs then do nothing
                if (this.conduit.acceptsInput === false) {
                    return;
                }
                // return all subjects that are 1) Not itself 2) In a zone that is listed in acceptsInput 3) Have a currentValue set
                var /** @type {?} */ subjects = this._zone.getSubjects().filter(function (subject) {
                    // If this is itself or if it has not value to give us then do nothing
                    if (subject === _this || subject.conduit.id !== _this.conduit.id || !subject.conduit.hasOwnProperty('currentValue')) {
                        return false;
                    }
                    // if acceptsInput is true then we return every time
                    if (_this.conduit.acceptsInput === true) {
                        return true;
                    }
                    if (Array.isArray(_this.conduit.acceptsInput)) {
                        return _this.conduit.acceptsInput.indexOf(subject.zoneId) !== -1;
                    }
                });
                // if there are no matches then do nothing
                if (subjects.length === 0) {
                    return;
                }
                // otherwise sort by the last modified field
                subjects.sort(function (subjectOne, subjectTwo) { return subjectOne.conduit.lastModified.getTime() < subjectTwo.conduit.lastModified.getTime() ? 1 : -1; });
                // get the most recent value
                this._subject.next(subjects[0].conduit.currentValue);
            };
        /** This will be triggered when a conduits value has changed */
        /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
        ConduitSubject.prototype.onInput =
            function (event) {
                // if we dont accept input or we emitted this value then do nothing
                if (this.conduit.acceptsInput === false || event.conduit === this.conduit) {
                    return;
                }
                // check if the conduit produces output - if not we only do something if we are in the same zone
                if (event.conduit.producesOutput === false && event.zoneId !== this.zoneId) {
                    return;
                }
                // check if we only accept inputs from specific zones
                if (Array.isArray(this.conduit.acceptsInput)) {
                    // check if the event came from an acceptable zone
                    if (!this.conduit.acceptsInput.find(function (zone) { return zone === event.zoneId; })) {
                        return;
                    }
                }
                // if required transform the value
                var /** @type {?} */ outputValue = this.conduit.map ? this.conduit.map(event.value) : event.value;
                // update the subject
                this._subject.next(outputValue);
            };
        /** This will be fired when this conduit emits a new value */
        /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
        ConduitSubject.prototype.onOutput =
            function (value) {
                // store the most recent value and when it was modified - can be used for any new conduits to lookup a value
                this.conduit.currentValue = value;
                this.conduit.lastModified = new Date();
                // check if this should produce output
                if (this.conduit.producesOutput) {
                    this._zone.emit({ conduit: this.conduit, zoneId: this.zoneId, value: value });
                }
            };
        /** Unsubscribe once this subject is destroyed */
        /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
        ConduitSubject.prototype.destroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        return ConduitSubject;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This utility is to ensure a all functions with the specified name are called in all super classes
     * @param {?} target
     * @param {?} functionName
     * @return {?}
     */
    function invokeSuperFunction(target, functionName) {
        // get all instances of the function
        var /** @type {?} */ functionList = [];
        // store the current prototype we are checking
        var /** @type {?} */ prototype = target;
        // look through every base class and check it
        do {
            if (prototype.hasOwnProperty(functionName)) {
                functionList.push(prototype[functionName]);
            }
            prototype = prototype.__proto__;
        } while (prototype.__proto__);
        // augment the top level function to call all the functions
        target[functionName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            functionList.forEach(function (func) { return func.call.apply(func, __spread([target], args)); });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitZone = (function () {
        function ConduitZone() {
        }
        /**
         * @return {?}
         */
        ConduitZone.prototype.ngOnDestroy =
            function () {
                var _this = this;
                // find all conduit subjects that are part of this zone
                ConduitZone.subjects.filter(function (_subject) { return _subject.zoneId === _this._zoneId; })
                    .forEach(function (_subject) { return _this.unregisterConduit(_subject.conduit); });
            };
        /** Store reference to the repository and begin watching for and emitting changes */
        /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.registerConduit =
            function (conduit) {
                ConduitZone.subjects.push(new ConduitSubject(conduit, this, this._zoneId));
            };
        /** Destroy a conduit */
        /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduit =
            function (conduit) {
                var /** @type {?} */ subject = this.getConduitSubject(conduit.subject);
                if (subject) {
                    // remove the subject from the internal list of conduit subjects
                    ConduitZone.subjects = ConduitZone.subjects.filter(function (_subject) { return _subject !== subject; });
                    // perform all unsubscriptions
                    subject.destroy();
                }
            };
        /** Provide the zone with an ID */
        /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
        ConduitZone.prototype.setZoneId =
            function (zoneId) {
                this._zoneId = zoneId;
            };
        /** Emit a value to all zones for checking */
        /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
        ConduitZone.prototype.emit =
            function (event) {
                ConduitZone.events.next(event);
            };
        /** Retrieve a conduit subsject object from the rxjs subject */
        /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
        ConduitZone.prototype.getConduitSubject =
            function (subject) {
                return ConduitZone.subjects.find(function (_subject) { return _subject.conduit.subject === subject; });
            };
        /** Get all subjects from all zones */
        /**
         * Get all subjects from all zones
         * @return {?}
         */
        ConduitZone.prototype.getSubjects =
            function () {
                return ConduitZone.subjects;
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.setConduitProperties =
            function (subject, properties) {
                // find the conduit with the matching subject
                var /** @type {?} */ conduitSubject = this.getSubjects().find(function (_conduit) { return _conduit.conduit.subject === subject; });
                // if a match was found update the properties
                if (conduitSubject) {
                    // update each specified property
                    for (var /** @type {?} */ prop in properties) {
                        conduitSubject.conduit[prop] = properties[prop];
                    }
                }
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.createConduit =
            function (subject, properties) {
                // register the conduit with the zone
                this.registerConduit(__assign({}, properties, { subject: subject }));
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.registerConduits =
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.registerConduit(__assign({}, conduit, { subject: component[conduit.propertyKey] })); });
                }
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduits =
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.unregisterConduit(conduit); });
                }
            };
        /** Return the global event stream */
        /**
         * Return the global event stream
         * @return {?}
         */
        ConduitZone.prototype.getEvents =
            function () {
                return ConduitZone.events;
            };
        /**
         * Create a global subject store
         */
        ConduitZone.subjects = [];
        /**
         * Expose an event stream of new values
         */
        ConduitZone.events = new Subject.Subject();
        ConduitZone.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ConduitZone.ctorParameters = function () { return []; };
        return ConduitZone;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitComponent = (function () {
        function ConduitComponent(_zone) {
            this._zone = _zone;
            // we want to ensure these functions get called even if a class overrides them
            invokeSuperFunction(this, 'ngOnInit');
            invokeSuperFunction(this, 'ngOnDestroy');
        }
        /** We need to register the conduits with the zone when the component is initialised */
        /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
        ConduitComponent.prototype.ngOnInit =
            function () {
                // register the conduit in the zone and ensure it gets the correct instance of the target
                this._zone.registerConduits(this);
            };
        /** We need to unregister the conduits when the component is destroyed */
        /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
        ConduitComponent.prototype.ngOnDestroy =
            function () {
                this._zone.unregisterConduits(this);
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.setConduitProperties =
            function (subject, properties) {
                this._zone.setConduitProperties(subject, properties);
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.createConduit =
            function (subject, properties) {
                this._zone.createConduit(subject, properties);
            };
        /** @nocollapse */
        ConduitComponent.ctorParameters = function () {
            return [
                { type: ConduitZone, decorators: [{ type: core.Optional },] },
            ];
        };
        return ConduitComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ ConduitZoneComponent = (function (_super) {
        __extends(ConduitZoneComponent, _super);
        function ConduitZoneComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        ConduitZoneComponent.prototype.ngOnInit =
            function () {
                this._zone.setZoneId(this.zoneId);
            };
        return ConduitZoneComponent;
    }(ConduitComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ defaultConduitProps = {
        acceptsInput: true,
        producesOutput: true,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Expose the property that conduits will be stored in
     */
    var /** @type {?} */ CONDUITS = '_conduits';
    /**
     * Create the conduit property decorator
     * @param {?} properties
     * @return {?}
     */
    function Conduit(properties) {
        return function (target, propertyKey) {
            if (typeof properties === 'function') {
                properties = properties.call(null);
            }
            // if the target does not already have a conduit list then create one
            if (!target.hasOwnProperty(CONDUITS)) {
                Object.defineProperty(target, CONDUITS, { value: [] });
            }
            // add the conduit to the list ensuring all required properties are provided
            target[CONDUITS].push(/** @type {?} */ (__assign({}, defaultConduitProps, properties, { target: target, propertyKey: propertyKey })));
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardService = (function () {
        function DashboardService() {
            var _this = this;
            this._rowHeight = 0;
            this.widgets$ = new BehaviorSubject.BehaviorSubject([]);
            this.options$ = new BehaviorSubject.BehaviorSubject(defaultOptions);
            this.dimensions$ = new BehaviorSubject.BehaviorSubject({});
            this.height$ = this.dimensions$.pipe(operators.delay(0), operators.map(function (dimensions) { return dimensions.height; }), operators.distinctUntilChanged());
            this.placeholder$ = new BehaviorSubject.BehaviorSubject({ visible: false, x: 0, y: 0, width: 0, height: 0 });
            this.layout$ = new Subject.Subject();
            this.stacked$ = new BehaviorSubject.BehaviorSubject(false);
            this.layout$.subscribe(this.setLayoutData.bind(this));
            this.stacked$.pipe(operators.filter(function (stacked) { return stacked === true; })).subscribe(this.updateWhenStacked.bind(this));
            this.widgets$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
            this.dimensions$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
        }
        Object.defineProperty(DashboardService.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.options$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "widgets", {
            get: /**
             * @return {?}
             */ function () {
                return this.widgets$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "stacked", {
            get: /**
             * @return {?}
             */ function () {
                return this.stacked$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "dimensions", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "columnWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions.width / this.options.columns;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add a widget to the dashboard
         * @param widget The widget component to add to the dashboard
         */
        /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
        DashboardService.prototype.addWidget =
            function (widget) {
                this.widgets$.next(__spread(this.widgets$.getValue(), [widget]));
            };
        /**
         * Remove a widget from the dashboard
         * @param widget The widget to remove
         */
        /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
        DashboardService.prototype.removeWidget =
            function (widget) {
                this.widgets$.next(this.widgets$.getValue().filter(function (_widget) { return _widget !== widget; }));
            };
        /**
         * Indicate that the dashboard element has been resized
         * @param width The width of the dashboard element in px
         * @param height The height of the dashboard element in px
         */
        /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
        DashboardService.prototype.setDimensions =
            function (width, height) {
                if (width === void 0) {
                    width = this.dimensions.width;
                }
                if (height === void 0) {
                    height = this.dimensions.height;
                }
                if (this.dimensions.width !== width || this.dimensions.height !== height) {
                    this.dimensions$.next({ width: width, height: height });
                }
            };
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         */
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
        DashboardService.prototype.getLayoutData =
            function () {
                return this.widgets.map(function (widget) {
                    return { id: widget.id, col: widget.getColumn(), row: widget.getRow(), colSpan: widget.getColumnSpan(), rowSpan: widget.getRowSpan() };
                });
            };
        /**
         * Position widgets programatically
         */
        /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
        DashboardService.prototype.setLayoutData =
            function (widgets) {
                var _this = this;
                // iterate through each widget data and find a match
                widgets.forEach(function (widget) {
                    // find the matching widget
                    var /** @type {?} */ target = _this.widgets.find(function (_widget) { return _widget.id === widget.id; });
                    if (target) {
                        target.setColumn(widget.col);
                        target.setRow(widget.row);
                        target.setColumnSpan(widget.colSpan);
                        target.setRowSpan(widget.rowSpan);
                    }
                });
            };
        /**
         * Update the positions and sizes of the widgets
         */
        /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
        DashboardService.prototype.renderDashboard =
            function () {
                var _this = this;
                // get the dimensions of the dashboard
                this._rowHeight = this.options.rowHeight || this.columnWidth;
                // ensure the column width is not below the min widths
                this.stacked$.next(this.columnWidth < this.options.minWidth);
                // ensure the row height is not below the min widths
                if (this._rowHeight < this.options.minWidth) {
                    this._rowHeight = this.options.minWidth;
                }
                this.setDashboardLayout();
                // iterate through each widget and set the size - except the one being resized
                this.widgets.filter(function (widget) { return !_this._actionWidget || widget !== _this._actionWidget.widget; })
                    .forEach(function (widget) { return widget.render(); });
            };
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         */
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
        DashboardService.prototype.setDashboardLayout =
            function () {
                var _this = this;
                // find any widgets that do not currently have a position set
                this.widgets.filter(function (widget) { return widget.getColumn() === undefined || widget.getRow() === undefined; })
                    .forEach(function (widget) { return _this.setWidgetPosition(widget); });
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.updateWhenStacked =
            function () {
                // iterate through each widget set it's stacked state and
                this.getWidgetsByOrder().forEach(function (widget, idx) {
                    widget.setColumn(0);
                    widget.setRow(idx);
                });
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getWidgetsByOrder =
            function () {
                return this.widgets.sort(function (w1, w2) {
                    var /** @type {?} */ w1Position = w1.getColumn() * w1.getRow();
                    var /** @type {?} */ w2Position = w2.getColumn() * w2.getRow();
                    if (w1Position < w2Position) {
                        return -1;
                    }
                    if (w1Position > w2Position) {
                        return 1;
                    }
                    return 0;
                });
            };
        /**
         * Find a position that a widget can fit in the dashboard
         * @param widget The widget to try and position
         */
        /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
        DashboardService.prototype.setWidgetPosition =
            function (widget) {
                // find a position for the widget
                var /** @type {?} */ position = 0;
                var /** @type {?} */ success = false;
                // repeat until a space is found
                while (!success) {
                    // get a position to try
                    var /** @type {?} */ column = position % this.options.columns;
                    var /** @type {?} */ row = Math.floor(position / this.options.columns);
                    // check the current position
                    if (this.getPositionAvailable(column, row, widget.getColumnSpan(), widget.getRowSpan())) {
                        success = true;
                        widget.setColumn(column);
                        widget.setRow(row);
                        return;
                    }
                    if (column === 0 && widget.colSpan > this.options.columns) {
                        throw new Error('Dashboard widgets have a colSpan greater than the max number of dashboard columns!');
                    }
                    position++;
                }
            };
        /**
         * Check if a position in the dashboard is vacant or not
         */
        /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
        DashboardService.prototype.getPositionAvailable =
            function (column, row, columnSpan, rowSpan, ignoreWidget) {
                // get a list of grid spaces that are populated
                var /** @type {?} */ spaces = this.getOccupiedSpaces();
                // check if the block would still be in bounds
                if (column + columnSpan > this.options.columns) {
                    return false;
                }
                var _loop_1 = function (x) {
                    var _loop_2 = function (y) {
                        if (spaces.find(function (block) { return block.column === x && block.row === y && block.widget !== ignoreWidget; })) {
                            return { value: false };
                        }
                    };
                    for (var /** @type {?} */ y = row; y < row + rowSpan; y++) {
                        var state_1 = _loop_2(y);
                        if (typeof state_1 === "object")
                            return state_1;
                    }
                };
                // check each required position
                for (var /** @type {?} */ x = column; x < column + columnSpan; x++) {
                    var state_2 = _loop_1(x);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
                return true;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getOccupiedSpaces =
            function () {
                var _this = this;
                // find all spaces that are currently occupied
                return this.widgets.filter(function (widget) { return widget.getColumn() !== undefined && widget.getRow() !== undefined; })
                    .reduce(function (value, widget) {
                    _this.forEachBlock(widget, function (column, row) { return value.push({ widget: widget, column: column, row: row }); });
                    return value;
                }, []);
            };
        /**
         * Begin resizing a widget
         * @param action The the widget to resize
         */
        /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
        DashboardService.prototype.onResizeStart =
            function (action) {
                // store the mouse event
                this._mouseEvent = action.event;
                this._actionWidget = action;
                // bring the widget to the font
                this.bringToFront(action.widget);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onResizeDrag =
            function (action) {
                var /** @type {?} */ mousePosX = this._mouseEvent.pageX - pageXOffset;
                var /** @type {?} */ mousePosY = this._mouseEvent.pageY - pageYOffset;
                // if there was no movement then do nothing
                if (action.event.x === mousePosX && action.event.y === mousePosY) {
                    return;
                }
                // update the stored mouse event
                this._mouseEvent = action.event;
                // get handle for direction
                var handle = action.handle;
                // get the bounds of the handle
                var /** @type {?} */ bounds = handle.getBoundingClientRect();
                // get the center of the handle
                var /** @type {?} */ centerX = bounds.left + (bounds.width / 2);
                var /** @type {?} */ centerY = bounds.top + (bounds.height / 2);
                // get the current mouse position
                var /** @type {?} */ mouseX = mousePosX - centerX;
                var /** @type {?} */ mouseY = mousePosY - centerY;
                // store the new proposed dimensions for the widget
                var /** @type {?} */ dimensions = {
                    x: action.widget.x,
                    y: action.widget.y,
                    width: action.widget.width,
                    height: action.widget.height
                };
                // update widget based on the handle being dragged
                switch (action.direction) {
                    case ActionDirection.Right:
                        dimensions.width += mouseX;
                        break;
                    case ActionDirection.Left:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.Bottom:
                        dimensions.height += mouseY;
                        break;
                    case ActionDirection.Top:
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    // Support resizing on multiple axis simultaneously
                    case ActionDirection.TopLeft:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.TopRight:
                        dimensions.width += mouseX;
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.BottomLeft:
                        dimensions.height += mouseY;
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.BottomRight:
                        dimensions.height += mouseY;
                        dimensions.width += mouseX;
                        break;
                }
                var /** @type {?} */ currentWidth = action.widget.x + action.widget.width;
                var /** @type {?} */ currentHeight = action.widget.y + action.widget.height;
                // ensure values are within the dashboard bounds
                if (dimensions.x < 0) {
                    dimensions.x = 0;
                    dimensions.width = currentWidth;
                }
                if (dimensions.y < 0) {
                    dimensions.y = 0;
                    dimensions.height = currentHeight;
                }
                if ((dimensions.x + dimensions.width) > this.dimensions.width) {
                    dimensions.width = this.dimensions.width - dimensions.x;
                }
                // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
                if (dimensions.width < this.options.minWidth) {
                    dimensions.x = action.widget.x;
                    dimensions.width = this.options.minWidth;
                }
                // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
                if (dimensions.height < this.options.minHeight) {
                    dimensions.y = action.widget.y;
                    dimensions.height = this.options.minHeight;
                }
                // update the widget actual values
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.updateWidgetPositions(action.widget);
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onResizeEnd =
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // commit resize changes
                this.commitWidgetChanges();
                // hide placeholder
                placeholder.visible = false;
                // update the placeholder
                this.placeholder$.next(placeholder);
                this._actionWidget = null;
                this._mouseEvent = null;
                // ensure any vacant upper spaces are filled where required
                this.shiftWidgetsUp();
                // update dashboard height
                this.setDashboardHeight();
                // emit information about the layout
                this.layout$.next(this.getLayoutData());
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDragStart =
            function (action) {
                this.onResizeStart(action);
                // store the starting placeholder position
                this.setWidgetOrigin();
                this.cacheWidgets();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onDragEnd =
            function () {
                this.onResizeEnd();
                this._widgetOrigin = {};
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDrag =
            function (action) {
                // if there was no movement then do nothing
                if (action.event.pageX === this._mouseEvent.pageX && action.event.pageY === this._mouseEvent.pageY) {
                    return;
                }
                // get the current mouse position
                var /** @type {?} */ mouseX = action.event.pageX - this._mouseEvent.pageX;
                var /** @type {?} */ mouseY = action.event.pageY - this._mouseEvent.pageY;
                // store the latest event
                this._mouseEvent = action.event;
                var /** @type {?} */ dimensions = {
                    x: action.widget.x + mouseX,
                    y: action.widget.y + mouseY,
                    width: action.widget.width,
                    height: action.widget.height
                };
                this.restoreWidgets(true);
                // update widget position
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.shiftWidgets();
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getRowHeight =
            function () {
                return this._rowHeight;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.cacheWidgets =
            function () {
                this._cache = this.widgets.map(function (widget) { return ({ id: widget.id, column: widget.getColumn(), row: widget.getRow() }); });
            };
        /**
         * @param {?=} ignoreActionWidget
         * @return {?}
         */
        DashboardService.prototype.restoreWidgets =
            function (ignoreActionWidget) {
                var _this = this;
                if (ignoreActionWidget === void 0) {
                    ignoreActionWidget = false;
                }
                this._cache.filter(function (widget) { return !ignoreActionWidget || widget.id !== _this._actionWidget.widget.id; }).forEach(function (widget) {
                    var /** @type {?} */ match = _this.widgets.find(function (wgt) { return wgt.id === widget.id; });
                    if (match) {
                        match.setColumn(widget.column);
                        match.setRow(widget.row);
                    }
                });
            };
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         */
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
        DashboardService.prototype.shiftWidgets =
            function () {
                var _this = this;
                var /** @type {?} */ widgetsToMove = [];
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var _loop_3 = function (row) {
                    var _loop_4 = function (column) {
                        // store reference to any widgets that need moved
                        this_1.getOccupiedSpaces()
                            .filter(function (space) { return space.column === column && space.row === row && space.widget !== _this._actionWidget.widget; })
                            .forEach(function (space) { return widgetsToMove.push(space.widget); });
                    };
                    for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                        _loop_4(column);
                    }
                };
                var this_1 = this;
                // check if there are any widgets under the placeholder
                for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                    _loop_3(row);
                }
                // remove any duplicates
                widgetsToMove = widgetsToMove.filter(function (widget, idx, array) { return array.indexOf(widget) === idx; });
                // if no widgets need moved then we can stop here
                if (widgetsToMove.length === 0) {
                    return;
                }
                // create a duplicate we can use to keep track of which have been moved
                var /** @type {?} */ unmovedWidgets = widgetsToMove.slice();
                // attempt to move any widgets to the previous widget position
                widgetsToMove.forEach(function (widget) {
                    // get a grid off all occupied spaces - taking into account the placeholder and ignoring widgets that need moved
                    var /** @type {?} */ grid = _this.getOccupiedSpaces().filter(function (space) { return !unmovedWidgets.find(function (wgt) { return wgt === space.widget; }); });
                    // iterate each free block
                    for (var /** @type {?} */ row = _this._widgetOrigin.row; row < _this._widgetOrigin.row + _this._widgetOrigin.rowSpan; row++) {
                        for (var /** @type {?} */ column = _this._widgetOrigin.column; column < _this._widgetOrigin.column + _this._widgetOrigin.columnSpan; column++) {
                            // determine if the block can fit in this space
                            var /** @type {?} */ requiredSpaces = _this.getRequiredSpacesFromPoint(widget, column, row);
                            // check if widget would fit in space
                            var /** @type {?} */ available = requiredSpaces.every(function (space) {
                                return !grid.find(function (gridSpace) { return gridSpace.column === space.column && gridSpace.row === space.row; }) && space.column < _this.getColumnCount();
                            });
                            if (available) {
                                widget.setColumn(column);
                                widget.setRow(row);
                                unmovedWidgets.splice(unmovedWidgets.findIndex(function (wgt) { return wgt === widget; }), 1);
                                return;
                            }
                        }
                    }
                    // if we get to here then we can't simply swap the positions - next try moving right
                    if (_this.canWidgetMoveRight(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Right);
                        return;
                    }
                    // next try moving left
                    if (_this.canWidgetMoveLeft(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Left);
                        return;
                    }
                    // determine the distance that the widget needs to be moved down
                    var /** @type {?} */ distance = (_this._actionWidget.widget.getRow() - widget.getRow()) + _this._actionWidget.widget.getRowSpan();
                    // as a last resort move the widget downwards
                    // as a last resort move the widget downwards
                    _this.moveWidgetDown(widget, distance);
                });
            };
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param shiftDirection - the position widgets were shifted
         */
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
        DashboardService.prototype.validatePlaceholderPosition =
            function (shiftDirection) {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check if the placeholder is over a widget
                if (this.getWidgetsAtPosition(placeholder.column, placeholder.row, true).length > 0) {
                    // move the placeholder the opposite direction
                    switch (shiftDirection) {
                        case ActionDirection.Left:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x + this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                        case ActionDirection.Right:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x - this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                    }
                    // validate this new position again
                    this.validatePlaceholderPosition(shiftDirection);
                }
            };
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveLeft =
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the action widget or occupies the first column
                if (widget === this._actionWidget.widget || widget.getColumn() === 0) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column - widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveLeft(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveLeft(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() - 1);
                }
                return moveable;
            };
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveRight =
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the dragging widget or the widget occupies the final column
                if (widget === this._actionWidget.widget || widget.getColumn() + widget.getColumnSpan() === this.options.columns) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column + widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveRight(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveRight(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() + 1);
                }
                return moveable;
            };
        /**
         * Store the initial position of the widget being dragged
         */
        /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
        DashboardService.prototype.setWidgetOrigin =
            function () {
                this._widgetOrigin = {
                    column: this._actionWidget.widget.getColumn(),
                    row: this._actionWidget.widget.getRow(),
                    columnSpan: this._actionWidget.widget.getColumnSpan(),
                    rowSpan: this._actionWidget.widget.getRowSpan()
                };
            };
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         */
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
        DashboardService.prototype.getRequiredSpacesFromPoint =
            function (widget, column, row) {
                var /** @type {?} */ spaces = [];
                for (var /** @type {?} */ y = row; y < row + widget.getRowSpan(); y++) {
                    for (var /** @type {?} */ x = column; x < column + widget.getColumnSpan(); x++) {
                        spaces.push({ column: x, row: y, widget: widget });
                    }
                }
                return spaces;
            };
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         */
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
        DashboardService.prototype.updateWidgetPositions =
            function (widget) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check all spaces the placeholder will occupy and move any widget currently in them down
                for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                    for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                        this.getWidgetsAtPosition(column, row, true)
                            .filter(function (wgt) { return wgt !== widget; })
                            .forEach(function (wgt) { return _this.moveWidgetDown(wgt); });
                    }
                }
                // update the height of the dashboard
                this.setDashboardHeight();
                // if we arent dragging the top handle then fill spaces
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Determine if a widget is occupying a specific row and column
         * @param column The columns to check if occupied
         * @param row The row to check if occupied
         * @param ignoreResizing Whether or not to ignore the widget currently being resized
         */
        /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
        DashboardService.prototype.getWidgetsAtPosition =
            function (column, row, ignoreResizing) {
                var _this = this;
                if (ignoreResizing === void 0) {
                    ignoreResizing = false;
                }
                return this.getOccupiedSpaces()
                    .filter(function (space) { return space.column === column && space.row === row; })
                    .filter(function (space) { return space.widget !== _this._actionWidget.widget || !ignoreResizing; })
                    .map(function (space) { return space.widget; });
            };
        /**
         * Update the placeholder visibility, position and size
         */
        /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.setPlaceholderBounds =
            function (visible, x, y, width, height) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var /** @type {?} */ rounding = this._actionWidget.direction === ActionDirection.Left ||
                    this._actionWidget.direction === ActionDirection.Top ? Rounding.RoundDownBelowHalf : Rounding.RoundUpOverHalf;
                placeholder.visible = visible;
                placeholder.column = this.getPlaceholderColumn(x, width);
                placeholder.row = this.getPlaceholderRow(y, height);
                placeholder.columnSpan = this.getPlaceholderColumnSpan(width);
                placeholder.rowSpan = this.getPlaceholderRowSpan(height);
                // calculate the maximum number of rows
                var /** @type {?} */ rowCount = this.widgets.filter(function (widget) { return widget !== _this._actionWidget.widget; })
                    .reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
                // constrain maximum placeholder row
                placeholder.row = Math.min(placeholder.row, rowCount);
                placeholder.x = (placeholder.column * this.getColumnWidth()) + this.options.padding;
                placeholder.y = (placeholder.row * this._rowHeight) + this.options.padding;
                placeholder.width = (placeholder.columnSpan * this.getColumnWidth()) - (this.options.padding * 2);
                placeholder.height = (placeholder.rowSpan * this._rowHeight) - (this.options.padding * 2);
                // set the values of the widget to match the values of the placeholder - however do not render the changes
                this._actionWidget.widget.setColumn(placeholder.column, false);
                this._actionWidget.widget.setRow(placeholder.row, false);
                this._actionWidget.widget.setColumnSpan(placeholder.columnSpan, false);
                this._actionWidget.widget.setRowSpan(placeholder.rowSpan, false);
                // update the placeholder
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the placeholder column position
         */
        /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumn =
            function (x, width) {
                var /** @type {?} */ column = this.getColumnFromPx(x, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ columnSpan = Math.floor(width / this.getColumnWidth());
                var /** @type {?} */ upperLimit = this.getColumnCount() - columnSpan;
                // if we arent dragging left then just return the column
                if (this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(Math.min(column, upperLimit), 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (x <= 0 || overflow === 0 || columnSpan === 0 || overflow > (this.getColumnWidth() / 2)) ?
                    Math.max(Math.min(column, upperLimit), 0) :
                    Math.max(Math.min(column + 1, upperLimit), 0);
            };
        /**
         * Get the column span of the placeholder
         */
        /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumnSpan =
            function (width) {
                var /** @type {?} */ columnSpan = this.getColumnFromPx(width);
                // if we arent dragging right or left then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Right &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.BottomRight &&
                    this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(columnSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (columnSpan > 0 && overflow > (this.getColumnWidth() / 2)) ? Math.max(columnSpan + 1, 1) : Math.max(columnSpan, 1);
            };
        /**
         * Get the row position of the placeholder
         */
        /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRow =
            function (y, height) {
                var /** @type {?} */ row = this.getRowFromPx(y, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ rowSpan = Math.ceil(height / this._rowHeight);
                // if we arent dragging up then just return the row
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    return Math.max(row, 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = height < this._rowHeight ? 0 : height % this._rowHeight;
                return (y <= 0 || rowSpan === 0 || overflow === 0 || overflow > (this._rowHeight / 2)) ? Math.max(row, 0) : Math.max(row + 1, 0);
            };
        /**
         * Get the row span of the placeholder
         */
        /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRowSpan =
            function (height) {
                var /** @type {?} */ rowSpan = this.getRowFromPx(height);
                // if we arent dragging up or down then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.Bottom &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomRight) {
                    return Math.max(rowSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = height % this._rowHeight;
                return (overflow > (this._rowHeight / 2)) ? Math.max(rowSpan + 1, 1) : Math.max(rowSpan, 1);
            };
        /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getColumnFromPx =
            function (x, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ column = Math.floor(x / Math.floor(this.getColumnWidth()));
                var /** @type {?} */ overflow = (x % Math.floor(this.getColumnWidth()));
                var /** @type {?} */ half = this.getColumnWidth() / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return column;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? column : column + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? column + 1 : column;
                    case Rounding.RoundUp:
                        return overflow > 0 ? column + 1 : column;
                }
            };
        /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getRowFromPx =
            function (y, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ row = Math.floor(y / Math.floor(this._rowHeight));
                var /** @type {?} */ overflow = (y % Math.floor(this._rowHeight));
                var /** @type {?} */ half = this._rowHeight / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return row;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? row : row + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? row + 1 : row;
                    case Rounding.RoundUp:
                        return overflow > 0 ? row + 1 : row;
                }
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.commitWidgetChanges =
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check that we have all the values we need
                if (placeholder.column === undefined || placeholder.row === undefined ||
                    placeholder.columnSpan === undefined || placeholder.rowSpan === undefined) {
                    return;
                }
                if (this._actionWidget) {
                    this._actionWidget.widget.setColumn(placeholder.column);
                    this._actionWidget.widget.setRow(placeholder.row);
                    this._actionWidget.widget.setColumnSpan(placeholder.columnSpan);
                    this._actionWidget.widget.setRowSpan(placeholder.rowSpan);
                }
                // reset all placeholder values
                placeholder.column = undefined;
                placeholder.row = undefined;
                placeholder.columnSpan = undefined;
                placeholder.rowSpan = undefined;
                // emit the new placeholder values
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the current column width
         */
        /**
         * Get the current column width
         * @return {?}
         */
        DashboardService.prototype.getColumnWidth =
            function () {
                return Math.floor(this.columnWidth);
            };
        /**
         * Calculate the number of rows populated with widgets
         */
        /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
        DashboardService.prototype.getRowCount =
            function () {
                return this.widgets.reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
            };
        /**
         * Set the height of the dashboard container element
         */
        /**
         * Set the height of the dashboard container element
         * @return {?}
         */
        DashboardService.prototype.setDashboardHeight =
            function () {
                // size the dashboard container to ensure all rows fit
                var /** @type {?} */ rowCount = this.getRowCount();
                // if we should show an empty row increment the row count by 1
                if (this.options.emptyRow) {
                    rowCount++;
                }
                this.setDimensions(undefined, rowCount * this._rowHeight);
            };
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param widget The widget that should be brought to the front
         */
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
        DashboardService.prototype.bringToFront =
            function (widget) {
                this.widgets.forEach(function (_widget) { return _widget === widget ? _widget.bringToFront() : _widget.sendToBack(); });
            };
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param widget The widget to move downwards
         */
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
        DashboardService.prototype.moveWidgetDown =
            function (widget, distance) {
                var _this = this;
                if (distance === void 0) {
                    distance = 1;
                }
                // move the widget down one position
                widget.setRow(widget.getRow() + distance);
                // check every space the widget occupies for collisions
                this.forEachBlock(widget, function (column, row) {
                    return _this.getWidgetsAtPosition(column, row, true)
                        .filter(function (wgt) { return wgt !== widget; })
                        .forEach(function (wgt) { return _this.moveWidgetDown(wgt, distance); });
                });
            };
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         */
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
        DashboardService.prototype.shiftWidgetsUp =
            function () {
                var _this = this;
                // check whether or not changes have been made - if so we need to repeat until stable
                var /** @type {?} */ stable = true;
                // iterate each widget and
                this.widgets.forEach(function (widget) {
                    // if widget is already on the top row then do nothing
                    if (widget.getRow() === 0) {
                        return;
                    }
                    // if we are currently dragging and this is the dragging widget then skip
                    if (_this._actionWidget && _this._actionWidget.widget === widget) {
                        return;
                    }
                    if (_this.getPositionAvailable(widget.getColumn(), widget.getRow() - 1, widget.getColumnSpan(), 1)) {
                        widget.setRow(widget.getRow() - 1);
                        stable = false;
                    }
                });
                // if changes occurred then we should repeat the process
                if (!stable) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Iterate over each space a widget occupied
         * @param widget The widget to determine spaces
         * @param callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         */
        /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
        DashboardService.prototype.forEachBlock =
            function (widget, callback) {
                for (var /** @type {?} */ row = widget.getRow(); row < widget.getRow() + widget.getRowSpan(); row++) {
                    for (var /** @type {?} */ column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                        callback.call(widget, column, row);
                    }
                }
            };
        /**
         * Returns the number of columns available
         */
        /**
         * Returns the number of columns available
         * @return {?}
         */
        DashboardService.prototype.getColumnCount =
            function () {
                return this.stacked ? 1 : this.options.columns;
            };
        DashboardService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DashboardService.ctorParameters = function () { return []; };
        return DashboardService;
    }());
    var /** @type {?} */ defaultOptions = { columns: 5, padding: 5, minWidth: 100, minHeight: 100, emptyRow: true };
    /** @enum {number} */
    var ActionDirection = {
        Top: 0,
        TopRight: 1,
        Right: 2,
        BottomRight: 3,
        Bottom: 4,
        BottomLeft: 5,
        Left: 6,
        TopLeft: 7,
        Move: 8,
    };
    ActionDirection[ActionDirection.Top] = "Top";
    ActionDirection[ActionDirection.TopRight] = "TopRight";
    ActionDirection[ActionDirection.Right] = "Right";
    ActionDirection[ActionDirection.BottomRight] = "BottomRight";
    ActionDirection[ActionDirection.Bottom] = "Bottom";
    ActionDirection[ActionDirection.BottomLeft] = "BottomLeft";
    ActionDirection[ActionDirection.Left] = "Left";
    ActionDirection[ActionDirection.TopLeft] = "TopLeft";
    ActionDirection[ActionDirection.Move] = "Move";
    /** @enum {number} */
    var Rounding = {
        RoundDown: 0,
        RoundDownBelowHalf: 1,
        RoundUp: 2,
        RoundUpOverHalf: 3,
    };
    Rounding[Rounding.RoundDown] = "RoundDown";
    Rounding[Rounding.RoundDownBelowHalf] = "RoundDownBelowHalf";
    Rounding[Rounding.RoundUp] = "RoundUp";
    Rounding[Rounding.RoundUpOverHalf] = "RoundUpOverHalf";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardComponent = (function () {
        function DashboardComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.layoutChange = new core.EventEmitter();
            dashboardService.layout$.subscribe(function (layout) { return _this.layoutChange.emit(layout); });
        }
        Object.defineProperty(DashboardComponent.prototype, "layout", {
            set: /**
             * @param {?} layout
             * @return {?}
             */ function (layout) {
                if (layout) {
                    this.dashboardService.layout$.next(layout);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardComponent.prototype, "options", {
            set: /**
             * @param {?} options
             * @return {?}
             */ function (options) {
                this.dashboardService.options$.next(__assign({}, defaultOptions, options));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set the initial dimensions
         */
        /**
         * Set the initial dimensions
         * @return {?}
         */
        DashboardComponent.prototype.ngAfterViewInit =
            function () {
                this.dashboardService.setDimensions(this.dashboardElement.nativeElement.offsetWidth, this.dashboardElement.nativeElement.offsetHeight);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DashboardComponent.prototype.onResize =
            function (event) {
                this.dashboardService.setDimensions(event.width, event.height);
            };
        DashboardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard',
                        template: "<div #dashboard class=\"dashboard-container\" [style.height.px]=\"dashboardService.height$ | async\">\n    <div (uxResize)=\"onResize($event)\" [throttle]=\"16\" class=\"dashboard\">\n        <ng-content></ng-content>\n    </div>\n    \n    <div class=\"position-indicator\" *ngIf=\"(dashboardService.placeholder$ | async).visible\" \n        [style.left.px]=\"(dashboardService.placeholder$ | async).x\" \n        [style.top.px]=\"(dashboardService.placeholder$ | async).y\" \n        [style.width.px]=\"(dashboardService.placeholder$ | async).width\"\n        [style.height.px]=\"(dashboardService.placeholder$ | async).height\"></div>\n</div>",
                        providers: [DashboardService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        DashboardComponent.ctorParameters = function () {
            return [
                { type: DashboardService, },
            ];
        };
        DashboardComponent.propDecorators = {
            "layout": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "layoutChange": [{ type: core.Output },],
            "dashboardElement": [{ type: core.ViewChild, args: ['dashboard',] },],
        };
        return DashboardComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardWidgetComponent = (function () {
        function DashboardWidgetComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.colSpan = 1;
            this.rowSpan = 1;
            this.resizable = false;
            this.x = 0;
            this.y = 0;
            this.width = 100;
            this.height = 100;
            this.padding = 0;
            this.zIndex = 0;
            this._column = { regular: undefined, stacked: undefined };
            this._row = { regular: undefined, stacked: undefined };
            this._columnSpan = { regular: 1, stacked: 1 };
            this._rowSpan = { regular: 1, stacked: 1 };
            this._subscription = dashboardService.options$.subscribe(function () { return _this.update(); });
        }
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnInit =
            function () {
                this._columnSpan.regular = this.colSpan;
                this._rowSpan.regular = this.rowSpan;
                if (!this.id) {
                    console.warn('Dashboard Widget is missing an ID.');
                    // set random id - keeps things working but prevents exporting of positions
                    this.id = Math.floor(Math.random() * 100000).toString();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngAfterViewInit =
            function () {
                // add the widget to the dashboard
                this.dashboardService.addWidget(this);
                // apply the current options
                this.update();
            };
        /**
         * If component is removed, then unregister it from the service
         */
        /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
                this.dashboardService.removeWidget(this);
            };
        /**
         * Apply the current dashboard options
         */
        /**
         * Apply the current dashboard options
         * @return {?}
         */
        DashboardWidgetComponent.prototype.update =
            function () {
                // get the current options at the time
                var _a = this.dashboardService.options, padding = _a.padding, columns = _a.columns;
                this.padding = padding;
                this._columnSpan.stacked = columns;
            };
        /**
         * Set the actual position and size values
         */
        /**
         * Set the actual position and size values
         * @return {?}
         */
        DashboardWidgetComponent.prototype.render =
            function () {
                this.x = this.getColumn() * this.dashboardService.getColumnWidth();
                this.y = this.getRow() * this.dashboardService.getRowHeight();
                this.width = this.getColumnSpan() * this.dashboardService.getColumnWidth();
                this.height = this.getRowSpan() * this.dashboardService.getRowHeight();
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumn =
            function () {
                return this.getStackableValue(this._column);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRow =
            function () {
                return this.getStackableValue(this._row);
            };
        /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumn =
            function (column, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._column, column);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRow =
            function (row, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._row, row);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumnSpan =
            function () {
                return this.getStackableValue(this._columnSpan);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRowSpan =
            function () {
                return this.getStackableValue(this._rowSpan);
            };
        /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumnSpan =
            function (columnSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._columnSpan, columnSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRowSpan =
            function (rowSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._rowSpan, rowSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.bringToFront =
            function () {
                this.zIndex = 1;
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.sendToBack =
            function () {
                this.zIndex = 0;
            };
        /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setBounds =
            function (x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragstart =
            function (handle, event, direction) {
                this.dashboardService.onResizeStart({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.drag =
            function (handle, event, direction) {
                this.dashboardService.onResizeDrag({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragend =
            function () {
                this.dashboardService.onResizeEnd();
            };
        /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setStackableValue =
            function (property, value) {
                if (this.dashboardService.stacked) {
                    property.stacked = value;
                }
                else {
                    property.regular = value;
                }
            };
        /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getStackableValue =
            function (property) {
                return this.dashboardService.stacked ? property.stacked : property.regular;
            };
        DashboardWidgetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard-widget',
                        template: "<div class=\"widget-content widget-col-span-{{ getColumnSpan() }} widget-row-span-{{ getRowSpan() }}\">\n    <ng-content></ng-content>\n</div>\n\n<div uxDrag #handleTop class=\"resizer-handle handle-top\" \n    (dragstart)=\"dragstart(handleTop, $event, 0)\"\n    (drag)=\"drag(handleTop, $event, 0)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag #handleTopRight class=\"resizer-handle handle-top-right\" \n    (dragstart)=\"dragstart(handleTopRight, $event, 1)\"\n    (drag)=\"drag(handleTopRight, $event, 1)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleRight class=\"resizer-handle handle-right\" \n    (dragstart)=\"dragstart(handleRight, $event, 2)\"\n    (drag)=\"drag(handleRight, $event, 2)\"\n    (dragend)=\"dragend()\"\n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleBottomRight class=\"resizer-handle handle-bottom-right\" \n    (dragstart)=\"dragstart(handleBottomRight, $event, 3)\"\n    (drag)=\"drag(handleBottomRight, $event, 3)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleBottom class=\"resizer-handle handle-bottom\" \n    (dragstart)=\"dragstart(handleBottom, $event, 4)\"\n    (drag)=\"drag(handleBottom, $event, 4)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag #handleBottomLeft class=\"resizer-handle handle-bottom-left\" \n    (dragstart)=\"dragstart(handleBottomLeft, $event, 5)\"\n    (drag)=\"drag(handleBottomLeft, $event, 5)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleLeft class=\"resizer-handle handle-left\" \n    (dragstart)=\"dragstart(handleLeft, $event, 6)\"\n    (drag)=\"drag(handleLeft, $event, 6)\"\n    (dragend)=\"dragend()\"\n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleTopLeft class=\"resizer-handle handle-top-left\" \n    (dragstart)=\"dragstart(handleTopLeft, $event, 7)\"\n    (drag)=\"drag(handleTopLeft, $event, 7)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>"
                    },] },
        ];
        /** @nocollapse */
        DashboardWidgetComponent.ctorParameters = function () {
            return [
                { type: DashboardService, },
            ];
        };
        DashboardWidgetComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "col": [{ type: core.Input },],
            "row": [{ type: core.Input },],
            "colSpan": [{ type: core.Input },],
            "rowSpan": [{ type: core.Input },],
            "resizable": [{ type: core.Input },],
            "x": [{ type: core.HostBinding, args: ['style.left.px',] },],
            "y": [{ type: core.HostBinding, args: ['style.top.px',] },],
            "width": [{ type: core.HostBinding, args: ['style.width.px',] },],
            "height": [{ type: core.HostBinding, args: ['style.height.px',] },],
            "padding": [{ type: core.HostBinding, args: ['style.padding.px',] },],
            "zIndex": [{ type: core.HostBinding, args: ['style.z-index',] },],
        };
        return DashboardWidgetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragDirective = (function () {
        function DragDirective(_elementRef, _ngZone, _renderer) {
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            this._renderer = _renderer;
            /**
             * Detemine if we should show a clone when dragging
             */
            this.clone = false;
            /**
             * Emit an event when dragging starts
             */
            this.dragstart = new core.EventEmitter();
            /**
             * Emit an event when the mouse moves while dragging
             */
            this.drag = new core.EventEmitter();
            /**
             * Emit an event when the dragging finishes
             */
            this.dragend = new core.EventEmitter();
            /**
             * Create an observable from the mouse down event
             */
            this._mousedown$ = fromEvent.fromEvent(this._elementRef.nativeElement, 'mousedown');
            /**
             * Create an observable from the mouse move event
             */
            this._mousemove$ = fromEvent.fromEvent(document, 'mousemove');
            /**
             * Create an observable from the mouse up event
             */
            this._mouseup$ = fromEvent.fromEvent(document, 'mouseup');
            /**
             * Use an observable to unsubscribe from all subscriptions
             */
            this._onDestroy = new Subject.Subject();
            this._mousedown$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.dragStart.bind(this));
        }
        /** Emit events and create clone when drag starts */
        /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragStart =
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this.clone) {
                    // clone the node
                    this.cloneNode(event);
                }
                // apply a class to the element being dragged
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // emit the drag start event
                this._ngZone.run(function () { return _this.dragstart.emit(event); });
                this._mousemove$.pipe(operators.takeUntil(this._mouseup$), operators.takeUntil(this._onDestroy))
                    .subscribe(this.dragMove.bind(this), null, this.dragEnd.bind(this));
            };
        /** Emit event and update clone position when dragging moves */
        /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragMove =
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this._clone) {
                    this.updateNodePosition(event);
                }
                // emit the drag start event
                this._ngZone.run(function () { return _this.drag.emit(event); });
            };
        /** Emit event and destroy clone when dragging ends */
        /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
        DragDirective.prototype.dragEnd =
            function () {
                var _this = this;
                // if there was a clone, remove it
                if (this._clone) {
                    this._renderer.removeChild(document.body, this._clone);
                    this._clone = null;
                }
                // remove the dragging class
                this._renderer.removeClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                this._ngZone.run(function () { return _this.dragend.emit(); });
            };
        /** Create an exact clone of an element */
        /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.cloneNode =
            function (event) {
                // duplicate the node
                this._clone = this._elementRef.nativeElement.cloneNode(true);
                // store the position within the draggable element
                var _a = this._elementRef.nativeElement.getBoundingClientRect(), top = _a.top, left = _a.left;
                this._offset = { x: event.clientX - left, y: event.clientY - top };
                // inline all styles so it looks identical regardless of its position in the DOM
                this.inlineStyles(this._elementRef.nativeElement, this._clone);
                // ensure we can easily position the node an it is above all other elements
                this._renderer.setAttribute(this._clone, 'aria-hidden', 'true');
                this._renderer.setStyle(this._clone, 'position', 'absolute');
                this._renderer.setStyle(this._clone, 'z-index', '99999');
                // apply a class to allow custom styling
                this._renderer.addClass(this._clone, 'ux-drag-dragging-clone');
                // insert the cloned element
                this._renderer.appendChild(document.body, this._clone);
                // set the cloned element initial position
                this.updateNodePosition(event);
            };
        /** Position the clone relative to the mouse */
        /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.updateNodePosition =
            function (event) {
                this._renderer.setStyle(this._clone, 'left', (event.pageX - this._offset.x) + 'px');
                this._renderer.setStyle(this._clone, 'top', (event.pageY - this._offset.y) + 'px');
            };
        /** Inline all styles to ensure styling is consistent regardless of its position in the dom */
        /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        DragDirective.prototype.inlineStyles =
            function (source, target) {
                // get all the computed styles from the source element
                var /** @type {?} */ styles = getComputedStyle(source);
                // inline every specified style
                for (var /** @type {?} */ idx = 0; idx < styles.length; idx++) {
                    var /** @type {?} */ style = styles.item(idx);
                    if (style !== undefined) {
                        this._renderer.setStyle(target, styles[idx], styles[style]);
                    }
                }
                // ensure we dont capture any move events
                this._renderer.setStyle(target, 'pointer-events', 'none');
                // do the same for all the child elements
                for (var /** @type {?} */ idx = 0; idx < source.children.length; idx++) {
                    this.inlineStyles(source.children[idx], target.children[idx]);
                }
            };
        /** Unsubscribe from all subscriptions */
        /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
        DragDirective.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        DragDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDrag]'
                    },] },
        ];
        /** @nocollapse */
        DragDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.NgZone, },
                { type: core.Renderer2, },
            ];
        };
        DragDirective.propDecorators = {
            "clone": [{ type: core.Input },],
            "dragstart": [{ type: core.Output },],
            "drag": [{ type: core.Output },],
            "dragend": [{ type: core.Output },],
        };
        return DragDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardDragHandleDirective = (function (_super) {
        __extends(DashboardDragHandleDirective, _super);
        function DashboardDragHandleDirective(widget, dashboardService, elementRef, ngZone, renderer) {
            var _this = _super.call(this, elementRef, ngZone, renderer) || this;
            _this.dragstart.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDragStart({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.drag.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDrag({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.dragend.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function () { return dashboardService.onDragEnd(); });
            return _this;
        }
        DashboardDragHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDashboardWidgetDragHandle], [ux-dashboard-widget-drag-handle]'
                    },] },
        ];
        /** @nocollapse */
        DashboardDragHandleDirective.ctorParameters = function () {
            return [
                { type: DashboardWidgetComponent, },
                { type: DashboardService, },
                { type: core.ElementRef, },
                { type: core.NgZone, },
                { type: core.Renderer2, },
            ];
        };
        return DashboardDragHandleDirective;
    }(DragDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragModule = (function () {
        function DragModule() {
        }
        DragModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DragDirective],
                        declarations: [DragDirective]
                    },] },
        ];
        /** @nocollapse */
        DragModule.ctorParameters = function () { return []; };
        return DragModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS = [
        DashboardComponent,
        DashboardWidgetComponent,
        DashboardDragHandleDirective
    ];
    var DashboardModule = (function () {
        function DashboardModule() {
        }
        DashboardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            DragModule
                        ],
                        exports: DECLARATIONS,
                        declarations: DECLARATIONS,
                        providers: [DashboardService],
                    },] },
        ];
        /** @nocollapse */
        DashboardModule.ctorParameters = function () { return []; };
        return DashboardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SPIN_BUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SpinButtonComponent; }),
        multi: true
    };
    var SpinButtonComponent = (function () {
        function SpinButtonComponent() {
            this.type = 'text';
            this.placeholder = '';
            this.disabled = false;
            this.spinners = true;
            this.readOnly = true;
            this.scrolling = true;
            this.arrowkeys = true;
            this.valueChange = new core.EventEmitter();
            this.increment = new core.EventEmitter();
            this.decrement = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(SpinButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        SpinButtonComponent.prototype.scroll =
            function (event) {
                if (!this.scrolling) {
                    return;
                }
                if (event.deltaY > 0) {
                    this.triggerDecrement();
                }
                else {
                    this.triggerIncrement();
                }
                event.preventDefault();
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerIncrement =
            function () {
                if (!this.disabled) {
                    this.increment.emit();
                }
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerDecrement =
            function () {
                if (!this.disabled) {
                    this.decrement.emit();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SpinButtonComponent.prototype.writeValue =
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SpinButtonComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        SpinButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spin-button',
                        template: "<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"incrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerIncrement()\">\n\n  <span class=\"hpe-icon hpe-up\"></span>\n</button>\n\n<input [type]=\"type\"\n       role=\"spinbutton\"\n       [min]=\"min\"\n       [max]=\"max\"\n       [tabindex]=\"0\"\n       class=\"form-control\"\n       [placeholder]=\"placeholder\"\n       [readOnly]=\"readOnly\"\n       [disabled]=\"disabled\"\n       [attr.aria-label]=\"inputAriaLabel\"\n       [attr.aria-disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\"\n       [attr.aria-readonly]=\"readOnly\"\n       [ngModel]=\"value\"\n       (ngModelChange)=\"valueChange.emit($event)\"\n       (wheel)=\"scroll($event)\"\n       (keydown.arrowup)=\"arrowkeys ? triggerIncrement() : null; $event.preventDefault()\"\n       (keydown.arrowdown)=\"arrowkeys ? triggerDecrement() : null; $event.preventDefault()\">\n\n<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"decrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerDecrement()\">\n\n  <span class=\"hpe-icon hpe-down\"></span>\n</button>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [SPIN_BUTTON_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        SpinButtonComponent.ctorParameters = function () { return []; };
        SpinButtonComponent.propDecorators = {
            "value": [{ type: core.Input },],
            "type": [{ type: core.Input },],
            "min": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "spinners": [{ type: core.Input },],
            "readOnly": [{ type: core.Input },],
            "scrolling": [{ type: core.Input },],
            "arrowkeys": [{ type: core.Input },],
            "incrementAriaLabel": [{ type: core.Input },],
            "inputAriaLabel": [{ type: core.Input },],
            "decrementAriaLabel": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "increment": [{ type: core.Output },],
            "decrement": [{ type: core.Output },],
        };
        return SpinButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SpinButtonModule = (function () {
        function SpinButtonModule() {
        }
        SpinButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [SpinButtonComponent],
                        declarations: [SpinButtonComponent]
                    },] },
        ];
        /** @nocollapse */
        SpinButtonModule.ctorParameters = function () { return []; };
        return SpinButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeFormatPipe = (function () {
        function TimeFormatPipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        TimeFormatPipe.prototype.transform =
            function (value) {
                return value < 10 ? '0' + value : value;
            };
        TimeFormatPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'timeFormat'
                    },] },
        ];
        /** @nocollapse */
        TimeFormatPipe.ctorParameters = function () { return []; };
        return TimeFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TIME_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TimePickerComponent; }),
        multi: true
    };
    var TimePickerComponent = (function () {
        function TimePickerComponent() {
            var _this = this;
            this.arrowkeys = true;
            this.mousewheel = true;
            this.disabled = false;
            this.readOnly = false;
            this.showMeridian = false;
            this.showHours = true;
            this.showMinutes = true;
            this.showSeconds = false;
            this.showSpinners = true;
            this.hourStep = 1;
            this.minuteStep = 1;
            this.secondStep = 1;
            this.meridians = ['AM', 'PM'];
            this.valueChange = new core.EventEmitter();
            this.isValid = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this.value$ = new BehaviorSubject.BehaviorSubject(new Date());
            // create observables that are derived from the latest value
            this.hour$ = this.value$.pipe(operators.map(function (date) { return date.getHours(); }), operators.map(function (hour) { return _this.showMeridian ? _this.getMeridianTime(hour) : hour; }));
            this.minute$ = this.value$.pipe(operators.map(function (date) { return date.getMinutes(); }));
            this.second$ = this.value$.pipe(operators.map(function (date) { return date.getSeconds(); }));
            this.meridian$ = this.value$.pipe(operators.map(function (date) { return date.getHours() < 12 ? _this.meridians[0] : _this.meridians[1]; }));
            this.valid$ = this.value$.pipe(operators.map(function (date) { return _this.checkValidity(date); }));
            this._meridian = this.meridians[0];
            this._subscription = this.valid$.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.isValid.emit(valid); });
        }
        Object.defineProperty(TimePickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return new Date(this.value$.value);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.value$.next(new Date(value));
                this.valueChange.emit(this.value$.value);
                this.onChangeCallback(this.value$.value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TimePickerComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.writeValue =
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TimePickerComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.getMeridianTime =
            function (hour) {
                return hour > 12 ? hour - 12 : hour;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.setHour =
            function (hour) {
                var /** @type {?} */ date = this.value;
                date.setHours(hour ? hour : 0);
                this.value = date;
            };
        /**
         * @param {?} minute
         * @return {?}
         */
        TimePickerComponent.prototype.setMinute =
            function (minute) {
                var /** @type {?} */ date = this.value;
                date.setMinutes(minute ? minute : 0);
                this.value = date;
            };
        /**
         * @param {?} seconds
         * @return {?}
         */
        TimePickerComponent.prototype.setSeconds =
            function (seconds) {
                var /** @type {?} */ date = this.value;
                date.setSeconds(seconds ? seconds : 0);
                this.value = date;
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementHour =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() + this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementHour =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() - this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementMinute =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() + this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementMinute =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() - this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementSecond =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() + this.secondStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementSecond =
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() - this.secondStep);
            };
        /**
         * @param {?} meridian
         * @return {?}
         */
        TimePickerComponent.prototype.selectMeridian =
            function (meridian) {
                this._meridian = meridian;
                // get the current time
                var /** @type {?} */ hour = this.value.getHours();
                // if we have selected AM
                if (meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        this.setHour(hour - 12);
                    }
                }
                // if we have selected PM
                if (meridian === this.meridians[1]) {
                    if (hour < 12) {
                        this.setHour(hour + 12);
                    }
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        TimePickerComponent.prototype.checkValidity =
            function (date) {
                var /** @type {?} */ valid = true;
                if (this.min && date.getTime() <= this.min.getTime()) {
                    valid = false;
                }
                if (this.max && date.getTime() >= this.max.getTime()) {
                    valid = false;
                }
                return valid;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.hourChange =
            function (value) {
                // convert the string to a number
                var /** @type {?} */ hour = parseInt(value);
                var /** @type {?} */ currentHour = this.value.getHours();
                // if the value hasn't changed, do nothing
                if (hour === currentHour) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(hour)) {
                    if (hour < 0) {
                        hour = 0;
                    }
                    if (hour > (this.showMeridian ? 12 : 23)) {
                        hour = this.showMeridian ? 12 : 23;
                    }
                }
                hour = isNaN(hour) ? currentHour : hour;
                // if the number is invalid then restore it to the previous value
                if (this._meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        hour -= 12;
                    }
                }
                // if we have selected PM
                if (this._meridian === this.meridians[1]) {
                    if (hour < 12) {
                        hour += 12;
                    }
                }
                this.setHour(hour);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.minuteChange =
            function (value) {
                // convert the string to a number
                var /** @type {?} */ minute = parseInt(value);
                var /** @type {?} */ currentMinute = this.value.getMinutes();
                // if the value hasn't changed, do nothing
                if (minute === currentMinute) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(minute)) {
                    if (minute < 0) {
                        minute = 59;
                    }
                    if (minute > 59) {
                        minute = 0;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setMinute(isNaN(minute) ? currentMinute : minute);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.secondChange =
            function (value) {
                // convert the string to a number
                var /** @type {?} */ second = parseInt(value);
                var /** @type {?} */ currentSecond = this.value.getSeconds();
                // if the value hasn't changed, do nothing
                if (second === currentSecond) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(second)) {
                    if (second < 0) {
                        second = 0;
                    }
                    if (second > 59) {
                        second = 59;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setSeconds(isNaN(second) ? currentSecond : second);
            };
        TimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-time-picker',
                        template: "<div class=\"time-picker\" aria-label=\"Time picker\">\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showHours\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"HH\"\n            [min]=\"0\"\n            [max]=\"showMeridian ? 12 : 23\"\n            [value]=\"hour$ | async | timeFormat\"\n            (valueChange)=\"hourChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"hour\"\n            incrementAriaLabel=\"Increment the hour\"\n            decrementAriaLabel=\"Decrement the hour\"\n            (increment)=\"incrementHour()\"\n            (decrement)=\"decrementHour()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showMinutes\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showMinutes\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"MM\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"minute$ | async | timeFormat\"\n            (valueChange)=\"minuteChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"minute\"\n            incrementAriaLabel=\"Increment the minute\"\n            decrementAriaLabel=\"Decrement the minute\"\n            (increment)=\"incrementMinute()\"\n            (decrement)=\"decrementMinute()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showSeconds\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showSeconds\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            type=\"number\"\n            placeholder=\"SS\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"second$ | async | timeFormat\"\n            (valueChange)=\"secondChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"seconds\"\n            incrementAriaLabel=\"Increment the second\"\n            decrementAriaLabel=\"Decrement the second\"\n            (increment)=\"incrementSecond()\"\n            (decrement)=\"decrementSecond()\">\n        </ux-spin-button>\n\n    </div>\n</div>\n\n<div class=\"time-picker-meridian\" *ngIf=\"showMeridian\">\n\n    <div class=\"btn-group\" role=\"radiogroup\">\n\n        <button class=\"btn button-toggle-accent\"\n                *ngFor=\"let meridian of meridians\"\n                role=\"radio\"\n                tabindex=\"0\"\n                [disabled]=\"disabled\"\n                (click)=\"selectMeridian(meridian)\"\n                [class.active]=\"meridian === (meridian$ | async)\"\n                [attr.aria-label]=\"meridian\"\n                [attr.aria-checked]=\"meridian === (meridian$ | async)\"\n                [attr.aria-disabled]=\"disabled\">\n                {{ meridian }}\n        </button>\n\n    </div>\n</div>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TIME_PICKER_VALUE_ACCESSOR],
                        host: {
                            'aria-label': 'Time Picker'
                        }
                    },] },
        ];
        /** @nocollapse */
        TimePickerComponent.ctorParameters = function () { return []; };
        TimePickerComponent.propDecorators = {
            "arrowkeys": [{ type: core.Input },],
            "mousewheel": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "readOnly": [{ type: core.Input },],
            "showMeridian": [{ type: core.Input },],
            "showHours": [{ type: core.Input },],
            "showMinutes": [{ type: core.Input },],
            "showSeconds": [{ type: core.Input },],
            "showSpinners": [{ type: core.Input },],
            "hourStep": [{ type: core.Input },],
            "minuteStep": [{ type: core.Input },],
            "secondStep": [{ type: core.Input },],
            "min": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "meridians": [{ type: core.Input },],
            "value": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "isValid": [{ type: core.Output },],
        };
        return TimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimePickerModule = (function () {
        function TimePickerModule() {
        }
        TimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            SpinButtonModule
                        ],
                        exports: [TimePickerComponent],
                        declarations: [TimePickerComponent, TimeFormatPipe],
                    },] },
        ];
        /** @nocollapse */
        TimePickerModule.ctorParameters = function () { return []; };
        return TimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Convert a single dimension array to a double dimension array
     * @template T
     * @param {?} items the single dimension array to convert
     * @param {?} columns the number of items each array should have
     * @return {?}
     */
    function gridify(items, columns) {
        // create a copy of array so not to effect the original
        items = items.slice(0);
        var /** @type {?} */ grid = [];
        while (items.length) {
            grid.push(items.splice(0, columns));
        }
        return grid;
    }
    /**
     * Create an array of numbers between two limits
     * @param {?} start the lower limit
     * @param {?} end the upper limit
     * @return {?}
     */
    function range(start, end) {
        var /** @type {?} */ list = [];
        for (var /** @type {?} */ idx = start; idx <= end; idx++) {
            list.push(idx);
        }
        return list;
    }
    /**
     * Create an array of dates between two points
     * @param {?} start the date to start the array
     * @param {?} end the date to end the array
     * @return {?}
     */
    function dateRange(start, end) {
        var /** @type {?} */ dates = [];
        // loop through all the days between the date range
        while (start <= end) {
            // add the date to the array
            dates.push(new Date(start));
            // move to the next day
            start.setDate(start.getDate() + 1);
        }
        return dates;
    }
    /**
     * Compare two dates to see if they are on the same day
     * @param {?} day1 the first date to compare
     * @param {?} day2 the second date to compare
     * @return {?}
     */
    function compareDays(day1, day2) {
        return day1.getDate() === day2.getDate() &&
            day1.getMonth() === day2.getMonth() &&
            day1.getFullYear() === day2.getFullYear();
    }
    /**
     * Date comparison for use primarily with distinctUntilChanged
     * @param {?} dateOne
     * @param {?} dateTwo
     * @return {?}
     */
    function dateComparator(dateOne, dateTwo) {
        return dateOne.getTime() === dateTwo.getTime();
    }
    /**
     * Timezone comparison for use primarily with distinctUntilChanged
     * @param {?} zoneOne
     * @param {?} zoneTwo
     * @return {?}
     */
    function timezoneComparator(zoneOne, zoneTwo) {
        return zoneOne.name === zoneTwo.name && zoneOne.offset === zoneTwo.offset;
    }
    /**
     * Export an array of all the available months
     */
    var /** @type {?} */ months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var /** @type {?} */ monthsShort = months.map(function (month) { return month.substring(0, 3); });
    /**
     * Export an array of all the available days of the week
     */
    var /** @type {?} */ weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    var /** @type {?} */ weekdaysShort = weekdays.map(function (weekday) { return weekday.substring(0, 3); });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerConfig = (function () {
        function DateTimePickerConfig() {
            this.showDate = true;
            this.showTime = true;
            this.showTimezone = true;
            this.showSeconds = false;
            this.showMeridian = true;
            this.showSpinners = true;
            this.weekdays = weekdaysShort;
            this.nowBtnText = 'Today';
            this.timezones = [
                { name: 'GMT-11', offset: 660 },
                { name: 'GMT-10', offset: 600 },
                { name: 'GMT-9', offset: 540 },
                { name: 'GMT-8', offset: 480 },
                { name: 'GMT-7', offset: 420 },
                { name: 'GMT-6', offset: 360 },
                { name: 'GMT-5', offset: 300 },
                { name: 'GMT-4', offset: 240 },
                { name: 'GMT-3', offset: 180 },
                { name: 'GMT-2', offset: 120 },
                { name: 'GMT-1', offset: 60 },
                { name: 'GMT', offset: 0 },
                { name: 'GMT+1', offset: -60 },
                { name: 'GMT+2', offset: -120 },
                { name: 'GMT+3', offset: -180 },
                { name: 'GMT+4', offset: -240 },
                { name: 'GMT+5', offset: -300 },
                { name: 'GMT+6', offset: -360 },
                { name: 'GMT+7', offset: -420 },
                { name: 'GMT+8', offset: -480 },
                { name: 'GMT+9', offset: -540 },
                { name: 'GMT+10', offset: -600 },
                { name: 'GMT+11', offset: -660 },
                { name: 'GMT+12', offset: -720 }
            ];
        }
        DateTimePickerConfig.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DateTimePickerConfig.ctorParameters = function () { return []; };
        return DateTimePickerConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerService = (function () {
        function DateTimePickerService(_config) {
            var _this = this;
            this._config = _config;
            this.mode$ = new BehaviorSubject.BehaviorSubject(DatePickerMode.Day);
            this.date$ = new BehaviorSubject.BehaviorSubject(new Date());
            this.timezone$ = new BehaviorSubject.BehaviorSubject(this.getCurrentTimezone());
            this.selected$ = new BehaviorSubject.BehaviorSubject(new Date());
            // the month and year to display in the viewport
            this.month$ = new BehaviorSubject.BehaviorSubject(new Date().getMonth());
            this.year$ = new BehaviorSubject.BehaviorSubject(new Date().getFullYear());
            this.showDate$ = new BehaviorSubject.BehaviorSubject(this._config.showDate);
            this.showTime$ = new BehaviorSubject.BehaviorSubject(this._config.showTime);
            this.showTimezone$ = new BehaviorSubject.BehaviorSubject(this._config.showTimezone);
            this.showSeconds$ = new BehaviorSubject.BehaviorSubject(this._config.showSeconds);
            this.showMeridian$ = new BehaviorSubject.BehaviorSubject(this._config.showMeridian);
            this.showSpinners$ = new BehaviorSubject.BehaviorSubject(this._config.showSpinners);
            this.weekdays$ = new BehaviorSubject.BehaviorSubject(this._config.weekdays);
            this.nowBtnText$ = new BehaviorSubject.BehaviorSubject(this._config.nowBtnText);
            this.timezones$ = new BehaviorSubject.BehaviorSubject(this._config.timezones);
            this.header$ = new BehaviorSubject.BehaviorSubject(null);
            this.headerEvent$ = new Subject.Subject();
            this.modeDirection = ModeDirection.None;
            // when the active date changes set the currently selected date
            this._subscription = this.selected$.pipe(operators.distinctUntilChanged(dateComparator)).subscribe(function (date) {
                // the month and year displayed in the viewport should reflect the newly selected items
                // the month and year displayed in the viewport should reflect the newly selected items
                _this.setViewportMonth(date.getMonth());
                _this.setViewportYear(date.getFullYear());
                // emit the new date to the component host
                // emit the new date to the component host
                _this.date$.next(date);
            });
        }
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMonth =
            function (month) {
                if (month < 0) {
                    this.month$.next(11);
                    this.year$.next(this.year$.value - 1);
                }
                else if (month > 11) {
                    this.month$.next(0);
                    this.year$.next(this.year$.value + 1);
                }
                else {
                    this.month$.next(month);
                }
            };
        /**
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportYear =
            function (year) {
                this.year$.next(year);
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setDate =
            function (day, month, year) {
                var /** @type {?} */ date = new Date(this.selected$.value);
                date.setDate(day);
                date.setMonth(month);
                date.setFullYear(year);
                this.selected$.next(date);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.setDateToNow =
            function () {
                this.selected$.next(new Date());
            };
        /**
         * @param {?} mode
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMode =
            function (mode) {
                this.mode$.next(mode);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToChildMode =
            function () {
                this.modeDirection = ModeDirection.Descend;
                switch (this.mode$.value) {
                    case DatePickerMode.Year:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Day);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToParentMode =
            function () {
                this.modeDirection = ModeDirection.Ascend;
                switch (this.mode$.value) {
                    case DatePickerMode.Day:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Year);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToNext =
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Next);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToPrevious =
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Previous);
            };
        /**
         * @param {?} header
         * @return {?}
         */
        DateTimePickerService.prototype.setHeader =
            function (header) {
                this.header$.next(header);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.getCurrentTimezone =
            function () {
                var /** @type {?} */ offset = new Date().getTimezoneOffset();
                return this._config.timezones.find(function (timezone) { return timezone.offset === offset; });
            };
        /**
         * @param {?} timezone
         * @return {?}
         */
        DateTimePickerService.prototype.setTimezone =
            function (timezone) {
                this.timezone$.next(timezone);
            };
        DateTimePickerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DateTimePickerService.ctorParameters = function () {
            return [
                { type: DateTimePickerConfig, },
            ];
        };
        return DateTimePickerService;
    }());
    /** @enum {number} */
    var DatePickerMode = {
        Day: 0,
        Month: 1,
        Year: 2,
    };
    DatePickerMode[DatePickerMode.Day] = "Day";
    DatePickerMode[DatePickerMode.Month] = "Month";
    DatePickerMode[DatePickerMode.Year] = "Year";
    /** @enum {number} */
    var ModeDirection = {
        None: 0,
        Ascend: 1,
        Descend: 2,
    };
    ModeDirection[ModeDirection.None] = "None";
    ModeDirection[ModeDirection.Ascend] = "Ascend";
    ModeDirection[ModeDirection.Descend] = "Descend";
    /** @enum {number} */
    var DatePickerHeaderEvent = {
        Previous: 0,
        Next: 1,
    };
    DatePickerHeaderEvent[DatePickerHeaderEvent.Previous] = "Previous";
    DatePickerHeaderEvent[DatePickerHeaderEvent.Next] = "Next";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerComponent = (function () {
        function DateTimePickerComponent(datepicker) {
            var _this = this;
            this.datepicker = datepicker;
            this.dateChange = new core.EventEmitter();
            this.timezoneChange = new core.EventEmitter();
            // expose enum to view
            this.DatePickerMode = DatePickerMode;
            this._subscription = new Subscription.Subscription();
            var /** @type {?} */ valueChange = datepicker.selected$.pipe(operators.distinctUntilChanged(dateComparator))
                .subscribe(function (date) { return _this.dateChange.emit(date); });
            var /** @type {?} */ timezoneChange = datepicker.timezone$.pipe(operators.distinctUntilChanged(timezoneComparator))
                .subscribe(function (timezone) { return _this.timezoneChange.emit(timezone); });
        }
        Object.defineProperty(DateTimePickerComponent.prototype, "showDate", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showDate$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTime", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTime$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTimezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTimezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSeconds", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSeconds$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showMeridian", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showMeridian$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSpinners", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSpinners$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "weekdays", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.weekdays$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "nowBtnText", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.nowBtnText$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezones", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezones$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "date", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!dateComparator(value, this.datepicker.selected$.value)) {
                    this.datepicker.selected$.next(new Date(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateTimePickerComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Change the date to the current date and time
         */
        /**
         * Change the date to the current date and time
         * @return {?}
         */
        DateTimePickerComponent.prototype.setToNow =
            function () {
                // set the date to the current moment
                this.datepicker.setDateToNow();
            };
        DateTimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker',
                        template: "<div class=\"calendar-container\">\n\n  <ux-date-time-picker-header></ux-date-time-picker-header>\n\n  <ng-container *ngIf=\"datepicker.showDate$ | async\" [ngSwitch]=\"datepicker.mode$ | async\">\n\n      <!-- Display days in the current month -->\n      <ux-date-time-picker-day-view *ngSwitchCase=\"DatePickerMode.Day\"></ux-date-time-picker-day-view>\n\n      <!-- Display the months in the current year -->\n      <ux-date-time-picker-month-view *ngSwitchCase=\"DatePickerMode.Month\"></ux-date-time-picker-month-view>\n\n      <!-- Display a decade -->\n      <ux-date-time-picker-year-view *ngSwitchCase=\"DatePickerMode.Year\"></ux-date-time-picker-year-view>\n\n  </ng-container>\n\n  <!-- Display a Time Picker -->\n  <ux-date-time-picker-time-view *ngIf=\"datepicker.showTime$ | async\"></ux-date-time-picker-time-view>\n\n</div>\n\n<button class=\"now-button\" aria-label=\"Set date to now\" (click)=\"setToNow()\">{{ datepicker.nowBtnText$ | async }}</button>",
                        providers: [DateTimePickerService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        DateTimePickerComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        DateTimePickerComponent.propDecorators = {
            "showDate": [{ type: core.Input },],
            "showTime": [{ type: core.Input },],
            "showTimezone": [{ type: core.Input },],
            "showSeconds": [{ type: core.Input },],
            "showMeridian": [{ type: core.Input },],
            "showSpinners": [{ type: core.Input },],
            "weekdays": [{ type: core.Input },],
            "nowBtnText": [{ type: core.Input },],
            "timezones": [{ type: core.Input },],
            "dateChange": [{ type: core.Output },],
            "timezoneChange": [{ type: core.Output },],
            "date": [{ type: core.Input },],
            "timezone": [{ type: core.Input },],
        };
        return DateTimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewService = (function () {
        function DayViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = combineLatest.combineLatest(_datepicker.month$, _datepicker.year$)
                .subscribe(function (_a) {
                var _b = __read(_a, 2), month = _b[0], year = _b[1];
                return _this.createDayGrid(month, year);
            });
        }
        /**
         * @return {?}
         */
        DayViewService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.setFocus =
            function (day, month, year) {
                this.focused$.next({ day: day, month: month, year: year });
                // update the date picker to show the required month and year
                this._datepicker.setViewportMonth(month);
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.createDayGrid =
            function (month, year) {
                var _this = this;
                // update the header
                this._datepicker.setHeader(months[month] + ' ' + year);
                // find the lower and upper boundaries
                var /** @type {?} */ start = new Date(year, month, 1);
                var /** @type {?} */ end = new Date(year, month + 1, 0);
                // we always want to show from the sunday - this may include showing some dates from the previous month
                start.setDate(start.getDate() - start.getDay());
                // we also want to make sure that the range ends on a saturday
                end.setDate(end.getDate() + (6 - end.getDay()));
                // create an array of all the days to display
                var /** @type {?} */ dates = dateRange(start, end).map(function (date) {
                    return ({
                        day: date.getDate(),
                        month: date.getMonth(),
                        year: date.getFullYear(),
                        date: date,
                        isToday: _this.isToday(date),
                        isActive: _this.isActive(date),
                        isCurrentMonth: date.getMonth() === month
                    });
                });
                // turn the dates into a grid
                var /** @type {?} */ items = gridify(dates, 7);
                this.grid$.next(items);
                // if no item has yet been focused then focus the first day of the month
                if ((this._datepicker.modeDirection === ModeDirection.None || this._datepicker.modeDirection === ModeDirection.Descend) && this.focused$.value === null) {
                    // check if the selected item is visible
                    var /** @type {?} */ selectedDay = dates.find(function (day) { return day.isCurrentMonth && day.isActive; });
                    if (selectedDay) {
                        this.setFocus(selectedDay.day, selectedDay.month, selectedDay.year);
                    }
                    else {
                        // find the first day of the month
                        var /** @type {?} */ first = dates.find(function (date) { return date.day === 1; });
                        // focus the date
                        this.setFocus(first.day, first.month, first.year);
                    }
                }
            };
        /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
        DayViewService.prototype.isToday =
            function (date) {
                return compareDays(new Date(), date);
            };
        /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
        DayViewService.prototype.isActive =
            function (date) {
                return compareDays(this._datepicker.selected$.value, date);
            };
        DayViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DayViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return DayViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewComponent = (function () {
        function DayViewComponent(datePicker, dayService) {
            var _this = this;
            this.datePicker = datePicker;
            this.dayService = dayService;
            this._subscription = datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        DayViewComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Navigate to the previous page of dates
         */
        /**
         * Navigate to the previous page of dates
         * @return {?}
         */
        DayViewComponent.prototype.previous =
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value - 1);
            };
        /**
         * Navigate to the next page of dates
         */
        /**
         * Navigate to the next page of dates
         * @return {?}
         */
        DayViewComponent.prototype.next =
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value + 1);
            };
        /**
         * Select a particular date
         * @param date the date to select
         */
        /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
        DayViewComponent.prototype.select =
            function (date) {
                // update the current date object
                this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear());
                // focus the newly selected date
                this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        DayViewComponent.prototype.trackWeekByFn =
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.trackDayByFn =
            function (index, item) {
                return item.day + " " + item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
        DayViewComponent.prototype.focusDate =
            function (item, dayOffset) {
                // determine the date of the day
                var /** @type {?} */ target = new Date(item.date.setDate(item.date.getDate() + dayOffset));
                // identify which date should be focused
                this.dayService.setFocus(target.getDate(), target.getMonth(), target.getFullYear());
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.getTabbable =
            function (item) {
                var /** @type {?} */ focused = this.dayService.focused$.value;
                var /** @type {?} */ grid = this.dayService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused day is visible
                    var /** @type {?} */ isFocusedDayVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.day === focused.day && _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedDayVisible) {
                        return focused.day === item.day && focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable day then check if there is a selected day
                var /** @type {?} */ isSelectedDayVisible = !!grid.find(function (row) { return !!row.find(function (day) { return day.isActive; }); });
                if (isSelectedDayVisible) {
                    return item.isActive;
                }
                // otherwise make the first day tabbable
                return item.day === 1;
            };
        DayViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-day-view',
                        template: "<table class=\"calendar\">\n    <thead>\n        <tr>\n            <th *ngFor=\"let day of datePicker.weekdays$ | async\" class=\"weekday\" [attr.aria-label]=\"day\">{{ day }}</th>\n        </tr>\n    </thead>\n\n    <tbody role=\"grid\">\n        <tr role=\"row\" *ngFor=\"let row of dayService.grid$ | async; trackBy: trackWeekByFn\">\n\n            <td *ngFor=\"let item of row; trackBy: trackDayByFn\" class=\"date-cell\" role=\"gridcell\">\n\n                <button class=\"date-button\"\n                        [focusIf]=\"(dayService.focused$ | async)?.day === item.day && (dayService.focused$ | async)?.month === item.month && (dayService.focused$ | async)?.year === item.year\"\n                        [attr.aria-label]=\"item.date | date\"\n                        [attr.aria-selected]=\"item.isActive\"\n                        [attr.aria-hidden]=\"!item.isCurrentMonth\"\n                        [class.current]=\"item.isToday\"\n                        [class.active]=\"item.isActive\"\n                        [class.preview]=\"!item.isCurrentMonth\"\n                        [tabindex]=\"getTabbable(item) ? 0 : -1\"\n                        (click)=\"select(item.date); $event.stopPropagation()\"\n                        (keydown.ArrowLeft)=\"focusDate(item, -1); $event.preventDefault()\"\n                        (keydown.ArrowRight)=\"focusDate(item, 1); $event.preventDefault()\"\n                        (keydown.ArrowUp)=\"focusDate(item, -7); $event.preventDefault()\"\n                        (keydown.ArrowDown)=\"focusDate(item, 7); $event.preventDefault()\">\n\n                    {{ item.date.getDate() }}\n                </button>\n\n            </td>\n        </tr>\n    </tbody>\n</table>",
                        providers: [DayViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        DayViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
                { type: DayViewService, },
            ];
        };
        return DayViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HeaderComponent = (function () {
        function HeaderComponent(datepicker) {
            this.datepicker = datepicker;
            this.canAscend$ = this.datepicker.mode$.pipe(operators.map(function (mode) { return mode !== DatePickerMode.Year; }));
            this.mode$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Day';
                    case DatePickerMode.Month:
                        return 'Month';
                    case DatePickerMode.Year:
                        return 'Year';
                }
            }));
            this.headerAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Switch to show months in the year';
                    case DatePickerMode.Month:
                        return 'Switch to show years in the decade';
                    case DatePickerMode.Year:
                        return '';
                }
            }));
            this.previousAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Previous month';
                    case DatePickerMode.Month:
                        return 'Previous year';
                    case DatePickerMode.Year:
                        return 'Previous decade';
                }
            }));
            this.nextAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Next month';
                    case DatePickerMode.Month:
                        return 'Next year';
                    case DatePickerMode.Year:
                        return 'Next decade';
                }
            }));
        }
        /**
         * @return {?}
         */
        HeaderComponent.prototype.previous =
            function () {
                this.datepicker.goToPrevious();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.ascend =
            function () {
                this.datepicker.goToParentMode();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.next =
            function () {
                this.datepicker.goToNext();
            };
        HeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-header',
                        template: "<header class=\"header\">\n\n  <button class=\"header-navigation\"\n          (click)=\"previous(); $event.stopPropagation()\"\n          [attr.aria-label]=\"previousAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-previous\"></i>\n  </button>\n\n  <button class=\"header-title\"\n          [attr.aria-label]=\"headerAria$ | async\"\n          [class.active]=\"canAscend$ | async\"\n          (click)=\"ascend(); $event.stopPropagation()\"\n          [tabindex]=\"(canAscend$ | async) ? 0 : -1\">\n       {{ datepicker.header$ | async }}\n  </button>\n\n  <button class=\"header-navigation\"\n          (click)=\"next(); $event.stopPropagation()\"\n          [attr.aria-label]=\"nextAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-next\"></i>\n  </button>\n</header>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        HeaderComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return HeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewService = (function () {
        function MonthViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = _datepicker.year$.subscribe(function (year) { return _this.createMonthGrid(year); });
        }
        /**
         * @return {?}
         */
        MonthViewService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.setFocus =
            function (month, year) {
                this.focused$.next({ month: month, year: year });
                // update the viewport to ensure focused month is visible
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.createMonthGrid =
            function (year) {
                // update the header
                this._datepicker.setHeader(year.toString());
                // get the current year and month
                var /** @type {?} */ currentMonth = new Date().getMonth();
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // get the currently selected month
                var /** @type {?} */ activeMonth = this._datepicker.selected$.value.getMonth();
                var /** @type {?} */ activeYear = this._datepicker.selected$.value.getFullYear();
                // create a 4x3 grid of month numbers
                var /** @type {?} */ months$$1 = range(0, 11).map(function (month) {
                    return {
                        name: monthsShort[month],
                        month: month,
                        year: year,
                        isCurrentMonth: year === currentYear && month === currentMonth,
                        isActiveMonth: year === activeYear && month === activeMonth
                    };
                });
                // map these to the appropriate format
                var /** @type {?} */ items = gridify(months$$1, 4);
                // update the grid
                this.grid$.next(items);
                // if there is no focused month select the first one
                if (this._datepicker.modeDirection === ModeDirection.Descend && this.focused$.value === null) {
                    // check if the selected month is in view
                    var /** @type {?} */ selectedMonth = months$$1.find(function (month) { return month.isActiveMonth; });
                    this.setFocus(selectedMonth ? selectedMonth.month : 0, year);
                }
            };
        MonthViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MonthViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return MonthViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewComponent = (function () {
        function MonthViewComponent(_datePicker, monthService) {
            var _this = this;
            this._datePicker = _datePicker;
            this.monthService = monthService;
            this._subscription = _datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        MonthViewComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Go to the previous year
         */
        /**
         * Go to the previous year
         * @return {?}
         */
        MonthViewComponent.prototype.previous =
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value - 1);
            };
        /**
         * Go to the next year
         */
        /**
         * Go to the next year
         * @return {?}
         */
        MonthViewComponent.prototype.next =
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value + 1);
            };
        /**
         * Select a month in the calendar
         * @param month the index of the month to select
         */
        /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
        MonthViewComponent.prototype.select =
            function (month) {
                this._datePicker.setViewportMonth(month);
                // show the day picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
        MonthViewComponent.prototype.focusMonth =
            function (item, monthOffset) {
                var /** @type {?} */ targetMonth = item.month + monthOffset;
                var /** @type {?} */ targetYear = item.year;
                if (targetMonth < 0) {
                    targetMonth += 12;
                    targetYear -= 1;
                }
                if (targetMonth >= 12) {
                    targetMonth -= 12;
                    targetYear += 1;
                }
                this.monthService.setFocus(targetMonth, targetYear);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        MonthViewComponent.prototype.trackRowByFn =
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.trackMonthByFn =
            function (index, item) {
                return item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.getTabbable =
            function (item) {
                var /** @type {?} */ focused = this.monthService.focused$.value;
                var /** @type {?} */ grid = this.monthService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused month is visible
                    var /** @type {?} */ isFocusedMonthVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedMonthVisible) {
                        return focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable month then check if there is a selected month
                var /** @type {?} */ isSelectedMonthVisible = !!grid.find(function (row) { return !!row.find(function (month) { return month.isActiveMonth; }); });
                if (isSelectedMonthVisible) {
                    return item.isActiveMonth;
                }
                // otherwise make the first month tabbable
                return item.month === 0;
            };
        MonthViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-month-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" *ngFor=\"let row of monthService.grid$ | async; trackBy: trackRowByFn\" role=\"row\">\n\n    <button role=\"gridcell\"\n         class=\"calendar-item\"\n         *ngFor=\"let item of row; trackBy: trackMonthByFn\"\n         [focusIf]=\"(monthService.focused$ | async)?.month === item.month && (monthService.focused$ | async)?.year === item.year\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\"\n         [attr.aria-label]=\"item.name + ' ' + item.year\"\n         [attr.aria-selected]=\"item.isActiveMonth\"\n         [class.active]=\"item.isActiveMonth\"\n         [class.current]=\"item.isCurrentMonth\"\n         (click)=\"select(item.month); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusMonth(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusMonth(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusMonth(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusMonth(item, 4); $event.preventDefault()\">\n         {{ item.name }}\n    </button>\n  </div>\n</div>\n",
                        providers: [MonthViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MonthViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
                { type: MonthViewService, },
            ];
        };
        return MonthViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeViewComponent = (function () {
        function TimeViewComponent(datepicker) {
            this.datepicker = datepicker;
        }
        /**
         * @param {?} name
         * @return {?}
         */
        TimeViewComponent.prototype.selectTimezone =
            function (name) {
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                // find matching timezone
                var /** @type {?} */ timezone = timezones.find(function (_timezone) { return _timezone.name === name; });
                if (timezone) {
                    this.datepicker.setTimezone(timezone);
                }
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.incrementTimezone =
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone + 1] ? timezones[currentZone + 1] : timezones[currentZone]);
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.decrementTimezone =
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone - 1] ? timezones[currentZone - 1] : timezones[currentZone]);
            };
        TimeViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-time-view',
                        template: "<ux-time-picker *ngIf=\"datepicker.showTime$ | async\"\n    [value]=\"datepicker.selected$ | async\"\n    (valueChange)=\"datepicker.selected$.next($event)\"\n    [showSeconds]=\"datepicker.showSeconds$ | async\"\n    [showMeridian]=\"datepicker.showMeridian$ | async\"\n    [showSpinners]=\"datepicker.showSpinners$ | async\">\n</ux-time-picker>\n\n<ng-container *ngIf=\"datepicker.showTimezone$ | async\">\n\n    <div class=\"time-zone-picker\" *ngIf=\"datepicker.showSpinners$ | async\">\n\n        <ux-spin-button\n            class=\"time-zone-spinner\"\n            [value]=\"(datepicker.timezone$ | async).name\"\n            [readOnly]=\"true\"\n            (increment)=\"incrementTimezone()\"\n            (decrement)=\"decrementTimezone()\"\n            inputAriaLabel=\"Time Zone\"\n            incrementAriaLabel=\"Switch to the next time zone\"\n            decrementAriaLabel=\"Switch to the previous time zone\">\n        </ux-spin-button>\n    </div>\n\n    <div class=\"time-zone-picker\" *ngIf=\"!(datepicker.showSpinners$ | async)\">\n\n        <select class=\"form-control time-zone-select\"\n                tabindex=\"0\"\n                [ngModel]=\"(datepicker.timezone$ | async).name\"\n                (ngModelChange)=\"selectTimezone($event)\"\n                aria-label=\"Timezone\"\n                [attr.aria-valuenow]=\"(datepicker.timezone$ | async).name\">\n\n            <option *ngFor=\"let zone of datepicker.timezones$ | async\"\n                    [selected]=\"zone.name === (datepicker.timezone$ | async).name\"\n                    [value]=\"zone.name\">\n                {{ zone?.name }}\n            </option>\n\n        </select>\n    </div>\n\n</ng-container>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        TimeViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return TimeViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewService = (function () {
        function YearViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._year = new Date().getFullYear();
            this._subscription = new Subscription.Subscription();
            var /** @type {?} */ year = _datepicker.year$.subscribe(function (_year) { return _this.createYearGrid(_year); });
            var /** @type {?} */ event = _datepicker.headerEvent$
                .subscribe(function (_event) { return _event === DatePickerHeaderEvent.Next ? _this.goToNextDecade() : _this.goToPreviousDecade(); });
            this._subscription.add(year);
            this._subscription.add(event);
        }
        /**
         * @return {?}
         */
        YearViewService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.setFocus =
            function (year) {
                this.focused$.next(year);
                this.createYearGrid(year);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToPreviousDecade =
            function () {
                this.createYearGrid(this._year - 10);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToNextDecade =
            function () {
                this.createYearGrid(this._year + 10);
            };
        /**
         * @param {?=} year
         * @return {?}
         */
        YearViewService.prototype.createYearGrid =
            function (year) {
                var _this = this;
                if (year === void 0) {
                    year = this._year;
                }
                this._year = year;
                // get the years to display
                var /** @type {?} */ decade = this.getDecade(year);
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // produce items in the correct format
                var /** @type {?} */ items = decade.range.map(function (_year) {
                    return {
                        year: _year,
                        isCurrentYear: _year === currentYear,
                        isActiveYear: _year === _this._datepicker.year$.value
                    };
                });
                // update the header text
                this._datepicker.setHeader(decade.start + ' - ' + decade.end);
                // create the grid
                this.grid$.next(gridify(items, 4));
            };
        /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.getDecade =
            function (year) {
                // figure the start and end points
                var /** @type {?} */ start = (year - (year % 10));
                var /** @type {?} */ end = start + 9;
                // create an array containing all the numbers between the start and end points
                return { start: start, end: end, range: range(start, end) };
            };
        YearViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        YearViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
            ];
        };
        return YearViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewComponent = (function () {
        function YearViewComponent(_datePicker, yearService) {
            this._datePicker = _datePicker;
            this.yearService = yearService;
        }
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewComponent.prototype.select =
            function (year) {
                this._datePicker.setViewportYear(year);
                // show the month picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
        YearViewComponent.prototype.focusYear =
            function (item, yearOffset) {
                this.yearService.setFocus(item.year + yearOffset);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        YearViewComponent.prototype.trackRowByFn =
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.trackYearByFn =
            function (index, item) {
                return item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.getTabbable =
            function (item) {
                var /** @type {?} */ focused = this.yearService.focused$.value;
                var /** @type {?} */ grid = this.yearService.grid$.value;
                // if there is a focused year check if this is it
                if (focused) {
                    // check if the focused year is visible
                    var /** @type {?} */ isFocusedYearVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.year === focused; }); });
                    if (isFocusedYearVisible) {
                        return focused === item.year;
                    }
                }
                // if there is no focusable year then check if there is a selected year
                var /** @type {?} */ isSelectedYearVisible = !!grid.find(function (row) { return !!row.find(function (year) { return year.isActiveYear; }); });
                if (isSelectedYearVisible) {
                    return item.isActiveYear;
                }
                // otherwise make the first month tabbable
                return grid[0][0].year === item.year;
            };
        YearViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-year-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" role=\"row\" *ngFor=\"let row of yearService.grid$ | async; trackBy: trackRowByFn\">\n\n    <button *ngFor=\"let item of row; trackBy: trackYearByFn\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         [focusIf]=\"(yearService.focused$ | async) === item.year\"\n         [attr.aria-label]=\"item.year\"\n         [attr.aria-selected]=\"item.isActiveYear\"\n         [class.current]=\"item.isCurrentYear\"\n         [class.active]=\"item.isActiveYear\"\n         (click)=\"select(item.year); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusYear(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusYear(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusYear(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusYear(item, 4); $event.preventDefault()\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\">\n         {{ item.year }}\n    </button>\n  </div>\n</div>\n",
                        providers: [YearViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        YearViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService, },
                { type: YearViewService, },
            ];
        };
        return YearViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfDirective = (function () {
        function FocusIfDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.focusIfDelay = 0;
            this._timeout = null;
        }
        Object.defineProperty(FocusIfDirective.prototype, "focusIf", {
            set: /**
             * @param {?} focus
             * @return {?}
             */ function (focus) {
                var _this = this;
                // if a timeout is pending then cancel it
                if (!focus && this._timeout !== null) {
                    clearTimeout(this._timeout);
                    this._timeout = null;
                }
                if (focus && this._timeout === null) {
                    this._timeout = window.setTimeout(function () {
                        _this._elementRef.nativeElement.focus();
                        _this._timeout = null;
                    }, this.focusIfDelay);
                }
            },
            enumerable: true,
            configurable: true
        });
        FocusIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[focusIf]'
                    },] },
        ];
        /** @nocollapse */
        FocusIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        FocusIfDirective.propDecorators = {
            "focusIfDelay": [{ type: core.Input },],
            "focusIf": [{ type: core.Input },],
        };
        return FocusIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfModule = (function () {
        function FocusIfModule() {
        }
        FocusIfModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FocusIfDirective],
                        declarations: [FocusIfDirective]
                    },] },
        ];
        /** @nocollapse */
        FocusIfModule.ctorParameters = function () { return []; };
        return FocusIfModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerModule = (function () {
        function DateTimePickerModule() {
        }
        DateTimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            TimePickerModule,
                            SpinButtonModule,
                            FocusIfModule
                        ],
                        exports: [DateTimePickerComponent],
                        declarations: [DateTimePickerComponent, HeaderComponent, DayViewComponent, MonthViewComponent, YearViewComponent, TimeViewComponent],
                        providers: [
                            DateTimePickerConfig
                        ]
                    },] },
        ];
        /** @nocollapse */
        DateTimePickerModule.ctorParameters = function () { return []; };
        return DateTimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxComponent = (function () {
        function EboxComponent() {
        }
        EboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-ebox',
                        template: "<div class=\"ux-ebox-header\">\n    <ng-content select=\"ux-ebox-header\"></ng-content>\n</div>\n\n<div class=\"ux-ebox-content\">\n    <ng-content select=\"ux-ebox-content\"></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        EboxComponent.ctorParameters = function () { return []; };
        return EboxComponent;
    }());
    var EboxHeaderDirective = (function () {
        function EboxHeaderDirective() {
        }
        EboxHeaderDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-header'
                    },] },
        ];
        /** @nocollapse */
        EboxHeaderDirective.ctorParameters = function () { return []; };
        return EboxHeaderDirective;
    }());
    var EboxContentDirective = (function () {
        function EboxContentDirective() {
        }
        EboxContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-content'
                    },] },
        ];
        /** @nocollapse */
        EboxContentDirective.ctorParameters = function () { return []; };
        return EboxContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxModule = (function () {
        function EboxModule() {
        }
        EboxModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [EboxComponent, EboxContentDirective, EboxHeaderDirective],
                        declarations: [EboxComponent, EboxContentDirective, EboxHeaderDirective]
                    },] },
        ];
        /** @nocollapse */
        EboxModule.ctorParameters = function () { return []; };
        return EboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetSelect = (function () {
        function FacetSelect(facet) {
            this.facet = facet;
        }
        return FacetSelect;
    }());
    var FacetDeselect = (function () {
        function FacetDeselect(facet) {
            this.facet = facet;
        }
        return FacetDeselect;
    }());
    var FacetDeselectAll = (function () {
        function FacetDeselectAll() {
        }
        return FacetDeselectAll;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetContainerComponent = (function () {
        function FacetContainerComponent() {
            this.header = 'Selected:';
            this.clearTooltip = 'Clear All';
            this.emptyText = 'No Items';
            this.facets = [];
            this.facetsReorderable = false;
            this.facetsChange = new core.EventEmitter();
            this.events = new core.EventEmitter();
        }
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.selectFacet =
            function (facet) {
                // push the facet on to the list
                this.facets.push(facet);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetSelect(facet));
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectFacet =
            function (facet) {
                // find the index of the item in the selected array
                var /** @type {?} */ idx = this.facets.findIndex(function (selectedFacet) { return facet === selectedFacet; });
                // if match there was no match then finish
                if (idx === -1) {
                    return;
                }
                // remove the last item
                this.facets.splice(idx, 1);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselect(facet));
            };
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectAllFacets =
            function () {
                // empty the selected array
                this.facets = [];
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselectAll());
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetContainerComponent.prototype.triggerEvent =
            function (event) {
                this.events.next(event);
            };
        FacetContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-container',
                        template: "<!-- Display Any Selected Facets -->\n<div class=\"facets-selected-container\">\n\n    <!-- Display Title an Clear Button -->\n    <div class=\"facets-selected-header-container\">\n\n        <!-- Show The Selected Text -->\n        <span class=\"facets-selected-header-label\">{{ header }}</span>\n\n        <!-- Add a Clear Button -->\n        <div class=\"facets-selected-clear-button\" tabindex=\"0\" [uxTooltip]=\"clearTooltip\" placement=\"left\" (click)=\"deselectAllFacets()\"\n            (keyup.enter)=\"deselectAllFacets()\" *ngIf=\"facets.length > 0\">\n\n            <svg class=\"facets-selected-clear-graphic\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n                <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n                <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n                <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n                <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n                <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n            </svg>\n        </div>\n\n    </div>\n\n    <!-- Display Tags For Selected Items -->\n    <div class=\"facets-selected-list\" uxReorderable [reorderingDisabled]=\"!facetsReorderable\" [(reorderableModel)]=\"facets\" (reorderableModelChange)=\"facetsChange.emit(facets)\">\n\n        <!-- Show Selected Tags -->\n        <div class=\"facet-selected-tag\" tabindex=\"0\" *ngFor=\"let facet of facets\" (mousedown)=\"$event.preventDefault()\" (click)=\"deselectFacet(facet)\" (keyup.enter)=\"deselectFacet(facet)\"\n             [uxReorderableModel]=\"facet\">\n\n            <!-- Display Label -->\n            <span class=\"facet-selected-tag-label\" uxReorderableHandle>{{ facet.title }}</span>\n\n            <!-- Display Remove Icon -->\n            <span class=\"hpe-icon hpe-close\"></span>\n        </div>\n\n    </div>\n\n    <!-- Show Message Here if No Facets Selected -->\n    <p class=\"facets-selected-none-label\" *ngIf=\"emptyText && facets.length === 0\">{{ emptyText }}</p>\n\n</div>\n\n<!-- Any Facet Elements Should be Added Here By User -->\n<div class=\"facets-region\">\n    <ng-content></ng-content>\n</div>"
                    },] },
        ];
        /** @nocollapse */
        FacetContainerComponent.ctorParameters = function () { return []; };
        FacetContainerComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "clearTooltip": [{ type: core.Input },],
            "emptyText": [{ type: core.Input },],
            "facets": [{ type: core.Input },],
            "facetsReorderable": [{ type: core.Input },],
            "facetsChange": [{ type: core.Output },],
            "events": [{ type: core.Output },],
        };
        return FacetContainerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetBaseComponent = (function () {
        function FacetBaseComponent(facetContainer, _elementRef) {
            var _this = this;
            this.facetContainer = facetContainer;
            this._elementRef = _elementRef;
            this.selected = [];
            this.selectedChange = new core.EventEmitter();
            this.events = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
            if (facetContainer) {
                // subscribe to any deselect events from the facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselect; }), operators.filter(function (event) { return !!_this.selected.find(function (facet) { return facet === event.facet; }); }), operators.takeUntil(this._onDestroy)).subscribe(function (event) { return _this.deselectFacet(event.facet); });
                // subscribe to any deselect all events from facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselectAll; }), operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.deselectAll(); });
            }
        }
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                // check if there should be any facets initially selected
                if (this.facetContainer) {
                    this.selected.forEach(function (facet) { return _this.facetContainer.selectFacet(facet); });
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.selectFacet =
            function (facet) {
                // if the facet is disabled it should not be selected
                if (facet.disabled) {
                    return;
                }
                // add the facet to the list of selected facets
                this.selected.push(facet);
                // send the new value to the event emitter
                this.selectedChange.emit(this.selected);
                // fire the event to the observable
                this.triggerEvent(new FacetSelect(facet));
                // tell the facet container about the selected facet
                if (this.facetContainer) {
                    this.facetContainer.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectFacet =
            function (facet) {
                // find facet to remove
                var /** @type {?} */ index = this.selected.findIndex(function (selectedFacet) { return selectedFacet === facet; });
                // only continue if facet is found
                if (index !== -1) {
                    // remove the facet from the selected list
                    this.selected.splice(index, 1);
                    // emit the changes to selected event emitter
                    this.selectedChange.emit(this.selected);
                    // fire the event to the observable
                    this.triggerEvent(new FacetDeselect(facet));
                    // deselect the facet in the facet container
                    if (this.facetContainer) {
                        this.facetContainer.deselectFacet(facet);
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectAll =
            function () {
                // remove all selected facets
                this.selected = [];
                // fire the event to the observable
                this.triggerEvent(new FacetDeselectAll());
                // emit the changes to the selected event emitter
                this.selectedChange.emit(this.selected);
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.toggleFacetSelection =
            function (facet) {
                // if the facet is selected then deselect - otherwise select it
                if (this.isFacetSelected(facet)) {
                    this.deselectFacet(facet);
                }
                else {
                    this.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.isFacetSelected =
            function (facet) {
                // determine if a facet is currently selected
                return !!this.selected.find(function (selectedFacet) { return selectedFacet === facet; });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetBaseComponent.prototype.triggerEvent =
            function (event) {
                this.events.next(event);
            };
        FacetBaseComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-base',
                        template: '',
                    },] },
        ];
        /** @nocollapse */
        FacetBaseComponent.ctorParameters = function () {
            return [
                { type: FacetContainerComponent, decorators: [{ type: core.Host },] },
                { type: core.ElementRef, },
            ];
        };
        FacetBaseComponent.propDecorators = {
            "selected": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
            "events": [{ type: core.Output },],
        };
        return FacetBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetHeaderComponent = (function () {
        function FacetHeaderComponent() {
            this.canExpand = true;
            this.expanded = true;
            this.expandedChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FacetHeaderComponent.prototype.toggleExpand =
            function () {
                // if not expandable then do nothing
                if (this.canExpand) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        FacetHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-header',
                        template: "<span class=\"facet-header-title\">{{ header }}</span>\n<span class=\"hpe-icon\" [class.hpe-down]=\"expanded\" [class.hpe-previous]=\"!expanded\" *ngIf=\"canExpand\"></span>",
                        host: {
                            'tabindex': '0',
                            '(click)': 'toggleExpand()',
                            '(keyup.enter)': 'toggleExpand()'
                        }
                    },] },
        ];
        /** @nocollapse */
        FacetHeaderComponent.ctorParameters = function () { return []; };
        FacetHeaderComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "canExpand": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
            "expandedChange": [{ type: core.Output },],
        };
        return FacetHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetCheckListComponent = (function (_super) {
        __extends(FacetCheckListComponent, _super);
        function FacetCheckListComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.facets = [];
            _this.scrollbar = true;
            _this.expanded = true;
            return _this;
        }
        FacetCheckListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-check-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<!-- Create a container which will show when section is expanded -->\n<div class=\"facet-check-list-container\" [class.facet-check-list-scrollbar]=\"scrollbar\" *ngIf=\"expanded\">\n\n    <!-- Iterate through each possible facet -->\n    <div class=\"facet-check-list-item\" *ngFor=\"let facet of facets\" [class.facet-active]=\"isFacetSelected(facet)\" tabindex=\"0\"\n        (click)=\"toggleFacetSelection(facet)\" (keyup.enter)=\"toggleFacetSelection(facet)\" [class.disabled]=\"facet.disabled\">\n\n        <!-- Show check icon to indicate the state -->\n        <span class=\"facet-check-list-item-check\">\n            <span class=\"hpe-icon hpe-active\"></span>\n        </span>\n\n        <!-- Display the title -->\n        <span class=\"facet-check-list-item-title\">{{ facet.title }}</span>\n\n        <!-- Display the count if specified -->\n        <span class=\"facet-check-list-item-count\" *ngIf=\"facet.count !== undefined\">({{ facet.count }})</span>\n    </div>\n</div>"
                    },] },
        ];
        /** @nocollapse */
        FacetCheckListComponent.ctorParameters = function () { return []; };
        FacetCheckListComponent.propDecorators = {
            "facets": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "scrollbar": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
        };
        return FacetCheckListComponent;
    }(FacetBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetTypeaheadListComponent = (function (_super) {
        __extends(FacetTypeaheadListComponent, _super);
        function FacetTypeaheadListComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.expanded = true;
            _this.typeaheadConfig = {};
            _this.suggestions = [];
            _this.simplified = true;
            _this._nativeElement = (_this._elementRef.nativeElement);
            _this._defaultTypeaheadConfig = {
                placeholder: '',
                maxResults: 50,
                minCharacters: 1
            };
            return _this;
        }
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                // wrap the observable and filter out any already selected items or any disabled items
                if (this.facets instanceof Observable.Observable) {
                    // handle an observable of data
                    this.typeaheadOptions = from.from(this.facets).pipe(operators.map(function (facets) {
                        // remove disabled facets, selected facets and facets that dont match search term
                        return facets.filter(function (facet) { return !facet.disabled; })
                            .filter(function (facet) { return !_this.selected.find(function (selectedFacet) { return selectedFacet === facet; }); })
                            .filter(function (facet) { return facet.title.toUpperCase().includes(_this.searchQuery.toUpperCase()); });
                    }));
                }
                else {
                    // handle an array of data
                    this.typeaheadOptions = of.of(this.facets).pipe(operators.map(function (facets) {
                        // remove disabled facets, selected facets and facets that dont match search term
                        return facets.filter(function (facet) { return !facet.disabled; })
                            .filter(function (facet) { return !_this.selected.find(function (selectedFacet) { return selectedFacet === facet; }); })
                            .filter(function (facet) { return facet.title.toUpperCase().includes(_this.searchQuery.toUpperCase()); });
                    }));
                }
                // provide default values for typeahead config
                for (var /** @type {?} */ prop in this._defaultTypeaheadConfig) {
                    // check if prop has been defined in the users typeahead config - if not set default value
                    if (this.typeaheadConfig.hasOwnProperty(prop) === false) {
                        this.typeaheadConfig[prop] = this._defaultTypeaheadConfig[prop];
                    }
                }
            };
        /**
         * @param {?} typeaheadOption
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.selectOption =
            function (typeaheadOption) {
                // check to make sure that the item is not currently selected
                if (this.selected.find(function (facet) { return facet === typeaheadOption.item; })) {
                    return;
                }
                // select the facet
                this.selectFacet(typeaheadOption.item);
                // clear the typeahead
                this.searchQuery = '';
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.scrollToFocused =
            function () {
                var /** @type {?} */ dropdown$$1 = this._nativeElement.querySelector('.dropdown-menu');
                // delay to allow the typeahead ui to update
                setTimeout(function () {
                    // find the currently active element if there is one
                    var /** @type {?} */ activeElement = dropdown$$1.querySelector('.dropdown-menu > li.active');
                    if (activeElement) {
                        // check if element is not in view
                        var /** @type {?} */ elementBounds = activeElement.getBoundingClientRect();
                        var /** @type {?} */ dropdownBounds = dropdown$$1.getBoundingClientRect();
                        if (elementBounds.top < dropdownBounds.top) {
                            dropdown$$1.scrollTop += elementBounds.top - dropdownBounds.top;
                        }
                        if (elementBounds.bottom > dropdownBounds.bottom) {
                            dropdown$$1.scrollTop += elementBounds.bottom - dropdownBounds.bottom;
                        }
                    }
                });
            };
        FacetTypeaheadListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-typeahead-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<div class=\"facet-typeahead-list-container\" *ngIf=\"expanded\">\n\n    <div class=\"facet-typeahead-list-selected-container\" *ngIf=\"suggestions?.length > 0\">\n\n        <div class=\"facet-typeahead-list-selected-option\" tabindex=\"0\" *ngFor=\"let facet of suggestions\" (click)=\"toggleFacetSelection(facet)\"\n            (keyup.enter)=\"toggleFacetSelection(facet)\">\n\n            <ux-checkbox [clickable]=\"false\" [value]=\"isFacetSelected(facet)\" [simplified]=\"simplified\">\n                <span class=\"facet-typeahead-list-selected-option-title\">{{ facet.title }}</span>\n                <span class=\"facet-typeahead-list-selected-option-count\">({{ facet.count }})</span>\n            </ux-checkbox>\n\n        </div>\n\n    </div>\n\n    <div class=\"facet-typeahead-list-control\">\n\n        <!-- Create Typeahead Control -->\n        <input type=\"text\" class=\"form-control\" [placeholder]=\"typeaheadConfig?.placeholder\" [typeahead]=\"typeaheadOptions\" [(ngModel)]=\"searchQuery\"\n            [typeaheadMinLength]=\"typeaheadConfig?.minCharacters\" [typeaheadOptionsLimit]=\"typeaheadConfig?.maxResults\" [typeaheadWaitMs]=\"typeaheadConfig?.delay\"\n            (typeaheadOnSelect)=\"selectOption($event)\" [typeaheadItemTemplate]=\"facetOptionTemplate\" (keyup.ArrowUp)=\"scrollToFocused()\" (keyup.ArrowDown)=\"scrollToFocused()\">\n\n    </div>\n\n</div>\n\n<ng-template #facetOptionTemplate let-model=\"item\" let-index=\"index\">\n    <p class=\"facet-typeahead-list-option\"><span [innerHTML]=\"model.title | facetTypeaheadHighlight: searchQuery\"></span> <span class=\"facet-typeahead-list-option-count\"\n            *ngIf=\"model.count\">({{ model.count }})</span></p>\n</ng-template>"
                    },] },
        ];
        /** @nocollapse */
        FacetTypeaheadListComponent.ctorParameters = function () { return []; };
        FacetTypeaheadListComponent.propDecorators = {
            "facets": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
            "typeaheadConfig": [{ type: core.Input },],
            "suggestions": [{ type: core.Input },],
            "simplified": [{ type: core.Input },],
        };
        return FacetTypeaheadListComponent;
    }(FacetBaseComponent));
    var FacetTypeaheadHighlight = (function () {
        function FacetTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FacetTypeaheadHighlight.prototype.transform =
            function (value, searchQuery) {
                var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"facet-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FacetTypeaheadHighlight.decorators = [
            { type: core.Pipe, args: [{
                        name: 'facetTypeaheadHighlight'
                    },] },
        ];
        /** @nocollapse */
        FacetTypeaheadHighlight.ctorParameters = function () { return []; };
        return FacetTypeaheadHighlight;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTooltipId = 0;
    var TooltipComponent = (function () {
        function TooltipComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Define a unique id for each tooltip
             */
            this.id = "ux-tooltip-" + ++uniqueTooltipId;
            /**
             * Define the tooltip role
             */
            this.role = 'tooltip';
            /**
             * Allow a custom class to be added to the tooltip to allow custom styling
             */
            this.customClass = '';
            /**
             * Indicates whether or not the content is a string or a TemplateRef
             */
            this.isTemplateRef = false;
            /**
             * Emit when the tooltip need to update it's position
             */
            this.reposition$ = new Subject.Subject();
        }
        /** Cleanup after the component is destroyed */
        /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
        TooltipComponent.prototype.ngOnDestroy =
            function () {
                this.reposition$.complete();
            };
        /** Inform the parent directive that it needs to recalulate the position */
        /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
        TooltipComponent.prototype.reposition =
            function () {
                this.reposition$.next();
            };
        /** This will update the content of the tooltip and trigger change detection */
        /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
        TooltipComponent.prototype.setContent =
            function (content) {
                this.content = content;
                this.isTemplateRef = content instanceof core.TemplateRef;
                this._changeDetectorRef.markForCheck();
            };
        /** This will update the tooltip placement and trigger change detection */
        /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
        TooltipComponent.prototype.setPlacement =
            function (placement) {
                if (!placement) {
                    return;
                }
                this.placement = placement;
                this._changeDetectorRef.markForCheck();
            };
        /** This will set a custom class on the tooltip and trigger change detection */
        /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
        TooltipComponent.prototype.setClass =
            function (customClass) {
                if (!customClass) {
                    return;
                }
                this.customClass = customClass;
                this._changeDetectorRef.markForCheck();
            };
        /** Updates the context used by the TemplateRef */
        /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
        TooltipComponent.prototype.setContext =
            function (context) {
                if (!context) {
                    return;
                }
                this.context = context;
                this._changeDetectorRef.markForCheck();
            };
        /** Specify the tooltip role attribute */
        /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
        TooltipComponent.prototype.setRole =
            function (role) {
                if (!role) {
                    return;
                }
                this.role = role;
                this._changeDetectorRef.markForCheck();
            };
        TooltipComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tooltip',
                        template: "<div class=\"tooltip in\" [id]=\"id\" [attr.role]=\"role\" [ngClass]=\"[placement, customClass]\">\n    <div class=\"tooltip-arrow\"></div>\n    <div class=\"tooltip-inner\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        TooltipComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef, },
            ];
        };
        return TooltipComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipService = (function () {
        function TooltipService() {
            this.shown$ = new Subject.Subject();
        }
        TooltipService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TooltipService.ctorParameters = function () { return []; };
        return TooltipService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipDirective = (function () {
        function TooltipDirective(_elementRef, _viewContainerRef, _overlay, _scrollDispatcher, _changeDetectorRef, _renderer, _tooltipService) {
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._overlay = _overlay;
            this._scrollDispatcher = _scrollDispatcher;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._tooltipService = _tooltipService;
            /**
             * All the user to add a custom class to the tooltip
             */
            this.customClass = '';
            /**
             * All the user to add a role to the tooltip - default is tooltip
             */
            this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            this.context = {};
            /**
             * Delay the showing of the tooltip by a number of miliseconds
             */
            this.delay = 0;
            /**
             * Programmatically show and hide the tooltip
             */
            this.isOpen = false;
            /**
             * Customize how the tooltip should be positioned relative to the element
             */
            this.placement = 'top';
            /**
             * Specify which events should show the tooltip
             */
            this.showTriggers = ['mouseenter', 'focus'];
            /**
             * Specify which events should hide the tooltip
             */
            this.hideTriggers = ['mouseleave', 'blur'];
            /**
             * Emits an event when the tooltip is shown
             */
            this.shown = new core.EventEmitter();
            /**
             * Emits a event when the tooltip is hidden
             */
            this.hidden = new core.EventEmitter();
            /**
             * Allow two way binding to track the visibility of the tooltip
             */
            this.isOpenChange = new core.EventEmitter();
            /**
             * Keep track of the tooltip visibility
             */
            this.isVisible = false;
            /**
             * This will emit when the directive is destroyed allowing us to unsubscribe all subscriptions automatically
             */
            this._onDestroy = new Subject.Subject();
            /**
             * Internally store the type of this component - usual for distinctions when extending this class
             */
            this._type = 'tooltip';
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        TooltipDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                // set up show and hide event triggers
                fromEvent.fromEvent(this._elementRef.nativeElement, 'click').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClick.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseEnter.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseleave').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseLeave.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'focus').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onFocus.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'blur').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onBlur.bind(this));
                // when any other tooltips open hide this one
                this._tooltipService.shown$.pipe(operators.filter(function () { return _this._type === 'tooltip'; }), operators.filter(function (tooltip$$1) { return tooltip$$1 !== _this._instance; }), operators.takeUntil(this._onDestroy)).subscribe(this.hide.bind(this));
                // if the tooltip should be initially visible then open it
                if (this.isOpen) {
                    this.show();
                }
            };
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        TooltipDirective.prototype.ngOnChanges =
            function (changes) {
                // we can ignore the first change as it's handled in ngOnInit
                if (changes["isOpen"] && !changes["isOpen"].firstChange && changes["isOpen"].currentValue !== this.isVisible) {
                    changes["isOpen"].currentValue ? this.show() : this.hide();
                }
                // destroy the overlay ref so a new correctly positioned instance will be created next time
                if (changes["placement"]) {
                    this.destroyOverlay();
                }
                if (this._instance && changes["placement"]) {
                    this._instance.setPlacement(changes["placement"].currentValue);
                }
                if (this._instance && changes["content"]) {
                    this._instance.setContent(changes["content"].currentValue);
                }
                if (this._instance && changes["customClass"]) {
                    this._instance.setClass(changes["customClass"].currentValue);
                }
                if (this._instance && changes["context"]) {
                    this._instance.setContext(changes["context"].currentValue);
                }
                if (this._instance && changes["role"]) {
                    this._instance.setContext(changes["role"].currentValue);
                }
            };
        /** Ensure we clean up after ourselves */
        /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
        TooltipDirective.prototype.ngOnDestroy =
            function () {
                // ensure we close the tooltip when the host is destroyed
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._instance = null;
                }
                // emit this event to automatically unsubscribe from all subscriptions
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Make the tooltip open */
        /**
         * Make the tooltip open
         * @return {?}
         */
        TooltipDirective.prototype.show =
            function () {
                var _this = this;
                // if the tooltip is disabled then do nothing
                if (this.disabled || this.isVisible || this._showTimeoutId || !this.content) {
                    return;
                }
                // delay the show by the delay amount
                this._showTimeoutId = window.setTimeout(function () {
                    // create the tooltip and get the overlay ref
                    var /** @type {?} */ overlayRef = _this.createOverlay();
                    // create the portal to create the tooltip component
                    // create the portal to create the tooltip component
                    _this._portal = _this.createPortal();
                    _this._instance = _this.createInstance(overlayRef);
                    // watch for any changes to the content
                    // watch for any changes to the content
                    _this._instance.reposition$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.reposition.bind(_this));
                    // store the visible state
                    // store the visible state
                    _this.isVisible = true;
                    // ensure the overlay has the correct initial position
                    // ensure the overlay has the correct initial position
                    _this.reposition();
                    // emit the show events
                    // emit the show events
                    _this.shown.emit();
                    _this.isOpenChange.next(true);
                    // clear the interval id
                    // clear the interval id
                    _this._showTimeoutId = null;
                    // emit the show event to close any other tooltips
                    // emit the show event to close any other tooltips
                    _this._tooltipService.shown$.next(_this._instance);
                    // ensure change detection is run
                    // ensure change detection is run
                    _this._changeDetectorRef.detectChanges();
                }, this.delay);
            };
        /** If a tooltip exists and is visible, hide it */
        /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
        TooltipDirective.prototype.hide =
            function () {
                // if we are waiting to show a tooltip then cancel the pending timeout
                if (this._showTimeoutId) {
                    clearTimeout(this._showTimeoutId);
                    this._showTimeoutId = null;
                    return;
                }
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                this.setAriaDescribedBy(null);
                this._instance = null;
                // store the visible state
                this.isVisible = false;
                // emit the hide events
                this.hidden.emit();
                this.isOpenChange.next(false);
                // ensure change detection is run
                this._changeDetectorRef.detectChanges();
            };
        /** Toggle the visibility of the tooltip */
        /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
        TooltipDirective.prototype.toggle =
            function () {
                this.isVisible ? this.hide() : this.show();
            };
        /** Recalculate the position of the popover */
        /**
         * Recalculate the position of the popover
         * @return {?}
         */
        TooltipDirective.prototype.reposition =
            function () {
                if (this.isVisible && this._overlayRef) {
                    this._overlayRef.updatePosition();
                }
            };
        /** Create an instance from the overlay ref - allows overriding and additional logic here */
        /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
        TooltipDirective.prototype.createInstance =
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                return instance;
            };
        /** Create the component portal - allows overriding to allow other portals eg. popovers */
        /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
        TooltipDirective.prototype.createPortal =
            function () {
                return this._portal || new portal.ComponentPortal(TooltipComponent, this._viewContainerRef);
            };
        /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
        TooltipDirective.prototype.createOverlay =
            function () {
                // if the tooltip has already been created then just return the existing instance
                if (this._overlayRef) {
                    return this._overlayRef;
                }
                // configure the tooltip
                var /** @type {?} */ strategy = this._overlay.position()
                    .connectedTo(this._elementRef, this.getOrigin(), this.getOverlayPosition());
                // correctly handle scrolling
                var /** @type {?} */ scrollableAncestors = this._scrollDispatcher
                    .getAncestorScrollContainers(this._elementRef);
                strategy.withScrollableContainers(scrollableAncestors);
                this._overlayRef = this._overlay.create({
                    positionStrategy: strategy,
                    panelClass: 'ux-overlay-pane',
                    scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                    hasBackdrop: false
                });
                return this._overlayRef;
            };
        /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
        TooltipDirective.prototype.destroyOverlay =
            function () {
                // destroy the existing overlay
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
                this.isVisible = false;
            };
        /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOrigin =
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top' || this.placement == 'bottom') {
                    return { originX: 'center', originY: this.placement };
                }
                else if (this.placement == 'left') {
                    return { originX: 'start', originY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { originX: 'end', originY: 'center' };
                }
            };
        /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOverlayPosition =
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top') {
                    return { overlayX: 'center', overlayY: 'bottom' };
                }
                else if (this.placement == 'bottom') {
                    return { overlayX: 'center', overlayY: 'top' };
                }
                else if (this.placement == 'left') {
                    return { overlayX: 'end', overlayY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { overlayX: 'start', overlayY: 'center' };
                }
            };
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         **/
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
        TooltipDirective.prototype.includes =
            function (array, value) {
                return Array.isArray(array) && !!array.find(function (item) { return item === value; });
            };
        /** Handle the click event - show or hide accordingly */
        /**
         * Handle the click event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onClick =
            function (event) {
                // if its not visible and click is a show trigger open it
                if (!this.isVisible && this.includes(this.showTriggers, 'click')) {
                    return this.show();
                }
                // if its visible and click is a hide trigger close it
                if (this.isVisible && this.includes(this.hideTriggers, 'click')) {
                    return this.hide();
                }
            };
        /** Handle the mouse enter event - show or hide accordingly */
        /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseEnter =
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'mouseenter')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the mouse leave event - show or hide accordingly */
        /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseLeave =
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'mouseleave')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /** Handle the focus event - show or hide accordingly */
        /**
         * Handle the focus event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onFocus =
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'focus')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the blur event - show or hide accordingly */
        /**
         * Handle the blur event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onBlur =
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'blur')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /**
         * Determine if the trigger element is focused
         * @return {?}
         */
        TooltipDirective.prototype.isFocused =
            function () {
                return document.activeElement === this._elementRef.nativeElement;
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        TooltipDirective.prototype.setAriaDescribedBy =
            function (id) {
                if (id === null) {
                    this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
                }
                else {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', id);
                }
            };
        TooltipDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTooltip]',
                        exportAs: 'ux-tooltip'
                    },] },
        ];
        /** @nocollapse */
        TooltipDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.ViewContainerRef, },
                { type: overlay.Overlay, },
                { type: overlay.ScrollDispatcher, },
                { type: core.ChangeDetectorRef, },
                { type: core.Renderer2, },
                { type: TooltipService, },
            ];
        };
        TooltipDirective.propDecorators = {
            "content": [{ type: core.Input, args: ['uxTooltip',] },],
            "disabled": [{ type: core.Input, args: ['tooltipDisabled',] },],
            "customClass": [{ type: core.Input, args: ['tooltipClass',] },],
            "role": [{ type: core.Input, args: ['tooltipRole',] },],
            "context": [{ type: core.Input, args: ['tooltipContext',] },],
            "delay": [{ type: core.Input, args: ['tooltipDelay',] },],
            "isOpen": [{ type: core.Input },],
            "placement": [{ type: core.Input },],
            "showTriggers": [{ type: core.Input },],
            "hideTriggers": [{ type: core.Input },],
            "shown": [{ type: core.Output },],
            "hidden": [{ type: core.Output },],
            "isOpenChange": [{ type: core.Output },],
        };
        return TooltipDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipModule = (function () {
        function TooltipModule() {
        }
        TooltipModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule
                        ],
                        exports: [TooltipDirective],
                        declarations: [TooltipComponent, TooltipDirective],
                        providers: [TooltipService],
                        entryComponents: [TooltipComponent]
                    },] },
        ];
        /** @nocollapse */
        TooltipModule.ctorParameters = function () { return []; };
        return TooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableHandleDirective = (function () {
        function ReorderableHandleDirective() {
        }
        ReorderableHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableHandle]'
                    },] },
        ];
        /** @nocollapse */
        ReorderableHandleDirective.ctorParameters = function () { return []; };
        return ReorderableHandleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModelDirective = (function () {
        // this can be used to identify which instance of the directive relates to which element
        function ReorderableModelDirective(elementRef) {
            this.elementRef = elementRef;
        }
        ReorderableModelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableModel]'
                    },] },
        ];
        /** @nocollapse */
        ReorderableModelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ReorderableModelDirective.propDecorators = {
            "uxReorderableModel": [{ type: core.Input },],
        };
        return ReorderableModelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    // WORKAROUND: Angular Cli 6 has removed the globals patch, dragular requires this to we can patch it here
    ((window)).global = ((window)).global || {};
    var /** @type {?} */ dragula = dragulaNamespace__default || dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableService = (function () {
        function ReorderableService() {
            this._groups = {};
            this._uniqueGroupId = 0;
        }
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         */
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
        ReorderableService.prototype.getUniqueGroupName =
            function () {
                return '_uxReorderable_' + this._uniqueGroupId++;
            };
        /**
         * Adds the container to the named group.
         */
        /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.register =
            function (groupName, container) {
                if (!this._groups[groupName]) {
                    this._groups[groupName] = new ReorderableGroup();
                }
                this._groups[groupName].register(container);
                return this._groups[groupName];
            };
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         */
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.unregister =
            function (groupName, container) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.unregister(container);
                    if (group.isEmpty()) {
                        group.destroy();
                        delete this._groups[groupName];
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
        ReorderableService.prototype.initialize =
            function (groupName) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.initialize();
                }
                return group;
            };
        /**
         * Returns the group object for the given name.
         */
        /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
        ReorderableService.prototype.getGroup =
            function (group) {
                return this._groups[group];
            };
        ReorderableService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ReorderableService.ctorParameters = function () { return []; };
        return ReorderableService;
    }());
    /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */
    var /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */ ReorderableGroup = (function () {
        function ReorderableGroup() {
            this.drag = new core.EventEmitter();
            this.dragEnd = new core.EventEmitter();
            this.drop = new core.EventEmitter();
            this.cancel = new core.EventEmitter();
            this.cloned = new core.EventEmitter();
            this._containers = [];
            this._config = {
                moves: this.canMove.bind(this)
            };
        }
        /**
         * Returns true if there are no containers registered with the group.
         */
        /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
        ReorderableGroup.prototype.isEmpty =
            function () {
                return this._containers.length === 0;
            };
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         */
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
        ReorderableGroup.prototype.getModelForElement =
            function (element) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        var /** @type {?} */ model = container.getModelFromElement(element);
                        if (model) {
                            return model;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return null;
                var e_1, _c;
            };
        /**
         * Adds the container to the group.
         */
        /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.register =
            function (container) {
                this._containers.push(container);
                if (this._instance) {
                    this._instance.containers = this._containers.map(function (c) { return c.element; });
                }
                if (!this._config.mirrorContainer) {
                    this._config.mirrorContainer = container.element;
                }
            };
        /**
         * Removes the container from the group.
         */
        /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.unregister =
            function (container) {
                var /** @type {?} */ index = this._containers.indexOf(container);
                if (index >= 0) {
                    this._containers.splice(index, 1);
                    if (this._instance) {
                        this._instance.containers = this._containers.map(function (c) { return c.element; });
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
        ReorderableGroup.prototype.initialize =
            function () {
                var _this = this;
                if (this._instance) {
                    return;
                }
                this._instance = dragula(this._containers.map(function (c) { return c.element; }), this._config);
                this._instance.on('drag', function (element, source) {
                    _this.drag.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        source: source
                    });
                });
                this._instance.on('dragend', function (element) {
                    _this.dragEnd.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('drop', function (element, target, source, sibling) {
                    _this.drop.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        target: target,
                        source: source,
                        sibling: sibling
                    });
                });
                this._instance.on('cancel', function (element) {
                    _this.cancel.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('cloned', function (clone, element, type) {
                    _this.cloned.emit({
                        clone: clone,
                        element: element,
                        type: type
                    });
                });
            };
        /**
         * Destroys the dragula instance.
         */
        /**
         * Destroys the dragula instance.
         * @return {?}
         */
        ReorderableGroup.prototype.destroy =
            function () {
                if (this._instance) {
                    this._instance.destroy();
                    this._instance = null;
                }
            };
        /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
        ReorderableGroup.prototype.canMove =
            function (element, containerElement, handle) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        if (container.element.isSameNode(containerElement)) {
                            return container.canMove(element, containerElement, handle);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                var e_2, _c;
            };
        return ReorderableGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableDirective = (function () {
        function ReorderableDirective(_elementRef, _renderer, _service) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._service = _service;
            this.reorderingDisabled = false;
            this.reorderableModelChange = new core.EventEmitter();
            this.reorderStart = new core.EventEmitter();
            this.reorderCancel = new core.EventEmitter();
            this.reorderEnd = new core.EventEmitter();
            this.dragging = false;
            this._subscriptions = new Subscription.Subscription();
        }
        /**
         * Initialise dragula and bind to all the required events
         */
        /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                // If no group name then generate a unique one for this instance only
                if (!this.reorderableGroup) {
                    this.reorderableGroup = this._service.getUniqueGroupName();
                }
                this._container = {
                    element: this._elementRef.nativeElement,
                    getModelFromElement: this.getModelFromElement.bind(this),
                    canMove: this.canMove.bind(this)
                };
                // Register for drag events on this element
                var /** @type {?} */ group = this._service.register(this.reorderableGroup, this._container);
                this._subscriptions.add(group.drag.subscribe(this.onDrag.bind(this)));
                this._subscriptions.add(group.dragEnd.subscribe(this.onDragEnd.bind(this)));
                this._subscriptions.add(group.drop.subscribe(this.onDrop.bind(this)));
                this._subscriptions.add(group.cancel.subscribe(function (event) { return _this.reorderCancel.emit({ element: event.element, model: event.model }); }));
                this._subscriptions.add(group.cloned.subscribe(this.onClone.bind(this)));
            };
        /**
         * @return {?}
         */
        ReorderableDirective.prototype.ngAfterViewInit =
            function () {
                this._service.initialize(this.reorderableGroup);
            };
        /**
         * We need to destroy the dragula instance on component destroy
         */
        /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnDestroy =
            function () {
                this._service.unregister(this.reorderableGroup, this._container);
                this._subscriptions.unsubscribe();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrag =
            function (event) {
                this.dragging = true;
                this.reorderStart.emit({ element: event.element, model: event.model });
            };
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         */
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrop =
            function (event) {
                // if there is no provided module we can skip this
                if (!this.reorderableModel) {
                    return;
                }
                var /** @type {?} */ changed = false;
                if (event.source.isSameNode(this._elementRef.nativeElement)) {
                    // remove this model from the list of models
                    var /** @type {?} */ index = this.reorderableModel.indexOf(event.model);
                    if (index >= 0) {
                        this.reorderableModel.splice(index, 1);
                        changed = true;
                    }
                }
                if (event.target.isSameNode(this._elementRef.nativeElement)) {
                    // get the position of sibling element
                    var /** @type {?} */ index = event.sibling && !event.sibling.classList.contains('gu-mirror') ?
                        this.reorderableModel.indexOf(this.getModelFromElement(event.sibling)) :
                        this.reorderableModel.length;
                    // insert the model at its new location
                    this.reorderableModel.splice(index, 0, event.model);
                    changed = true;
                }
                // Emit event if any changes were made
                if (changed) {
                    this.reorderableModelChange.emit(this.reorderableModel);
                }
            };
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         */
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
        ReorderableDirective.prototype.getModelFromElement =
            function (element) {
                var /** @type {?} */ model = this.models.find(function (_model) { return _model.elementRef.nativeElement === element; });
                if (!model) {
                    return null;
                }
                return model.uxReorderableModel;
            };
        /**
         * When we finish dragging remove the utillity class from the element being moved
         */
        /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDragEnd =
            function (event) {
                this.dragging = false;
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this._renderer.removeClass(event.element, 'ux-reorderable-moving');
                    this.reorderEnd.emit({
                        element: event.element,
                        model: event.model
                    });
                }
            };
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         */
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onClone =
            function (event) {
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this.setTableCellWidths(event.element, event.clone);
                    this.captureCanvases(event.element, event.clone);
                    this._renderer.addClass(event.element, 'ux-reorderable-moving');
                }
            };
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         */
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
        ReorderableDirective.prototype.canMove =
            function (element, container, handle) {
                if (this.reorderingDisabled) {
                    return false;
                }
                return this.handles.length === 0 ? true : !!this.handles.find(function (_handle) { return _handle.nativeElement === handle; });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.setTableCellWidths =
            function (source, target) {
                // if it is not a table row then skip this
                if (source.tagName !== 'TR') {
                    return;
                }
                // find any immediate td children and fix their width
                var /** @type {?} */ sourceCells = (Array.from(source.children));
                var /** @type {?} */ targetCells = (Array.from(target.children));
                // fix the width of these cells
                sourceCells.forEach(function (cell, idx) { return targetCells[idx].style.minWidth = getComputedStyle(cell).getPropertyValue('width'); });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.captureCanvases =
            function (source, target) {
                // find all child canvas elements
                var /** @type {?} */ sourceCanvases = Array.from(source.querySelectorAll('canvas'));
                var /** @type {?} */ targetCanvases = Array.from(target.querySelectorAll('canvas'));
                // replicate the canvas content
                targetCanvases.map(function (canvas) { return canvas.getContext('2d'); })
                    .forEach(function (context, idx) { return context.drawImage(sourceCanvases[idx], 0, 0); });
            };
        ReorderableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderable]'
                    },] },
        ];
        /** @nocollapse */
        ReorderableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
                { type: ReorderableService, },
            ];
        };
        ReorderableDirective.propDecorators = {
            "reorderableModel": [{ type: core.Input },],
            "reorderableGroup": [{ type: core.Input },],
            "reorderingDisabled": [{ type: core.Input },],
            "reorderableModelChange": [{ type: core.Output },],
            "reorderStart": [{ type: core.Output },],
            "reorderCancel": [{ type: core.Output },],
            "reorderEnd": [{ type: core.Output },],
            "handles": [{ type: core.ContentChildren, args: [ReorderableHandleDirective, { read: core.ElementRef, descendants: true },] },],
            "models": [{ type: core.ContentChildren, args: [ReorderableModelDirective,] },],
            "dragging": [{ type: core.HostBinding, args: ['class.ux-reorderable-container-moving',] },],
        };
        return ReorderableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModule = (function () {
        function ReorderableModule() {
        }
        ReorderableModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        exports: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        providers: [
                            ReorderableService
                        ]
                    },] },
        ];
        /** @nocollapse */
        ReorderableModule.ctorParameters = function () { return []; };
        return ReorderableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$1 = [
        FacetContainerComponent,
        FacetHeaderComponent,
        FacetBaseComponent,
        FacetCheckListComponent,
        FacetTypeaheadListComponent,
        FacetTypeaheadHighlight
    ];
    var FacetsModule = (function () {
        function FacetsModule() {
        }
        FacetsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            CheckboxModule,
                            TooltipModule,
                            ReorderableModule,
                            typeahead.TypeaheadModule.forRoot()
                        ],
                        exports: DECLARATIONS$1,
                        declarations: DECLARATIONS$1
                    },] },
        ];
        /** @nocollapse */
        FacetsModule.ctorParameters = function () { return []; };
        return FacetsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Facet = (function () {
        function Facet(title, data, count, disabled, id) {
            if (data === void 0) {
                data = {};
            }
            if (disabled === void 0) {
                disabled = false;
            }
            this.title = title;
            this.data = data;
            this.count = count;
            this.disabled = disabled;
            this.id = id;
        }
        return Facet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterContainerComponent = (function () {
        function FilterContainerComponent() {
            this.filters = [];
            this.filtersChange = new core.EventEmitter();
            this.events = new core.EventEmitter();
        }
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterContainerComponent.prototype.addFilter =
            function (filter) {
                this.filters.push(filter);
                this.events.next(new FilterAddEvent(filter));
                this.filtersChange.emit(this.filters);
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterContainerComponent.prototype.removeFilter =
            function (filter) {
                var /** @type {?} */ idx = this.filters.findIndex(function (filters) { return filters === filter; });
                if (idx !== -1) {
                    this.filters.splice(idx, 1);
                    this.events.next(new FilterRemoveEvent(filter));
                    this.filtersChange.emit(this.filters);
                }
            };
        /**
         * @return {?}
         */
        FilterContainerComponent.prototype.removeAll =
            function () {
                this.events.next(new FilterRemoveAllEvent());
            };
        FilterContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-container',
                        template: "<ng-content></ng-content>\n\n<!-- Add a Clear Button -->\n<div class=\"filter-selected-clear-button\" *ngIf=\"filters.length > 0\" [uxTooltip]=\"clearTooltip || 'Clear All'\" (click)=\"removeAll()\">\n\n    <svg class=\"filter-selected-clear-graphic\" width=\"19\" height=\"12\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n        <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n        <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n        <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n        <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n        <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n    </svg>\n\n</div>"
                    },] },
        ];
        /** @nocollapse */
        FilterContainerComponent.ctorParameters = function () { return []; };
        FilterContainerComponent.propDecorators = {
            "filters": [{ type: core.Input },],
            "clearTooltip": [{ type: core.Input },],
            "filtersChange": [{ type: core.Output },],
            "events": [{ type: core.Output },],
        };
        return FilterContainerComponent;
    }());
    var FilterAddEvent = (function () {
        function FilterAddEvent(filter) {
            this.filter = filter;
        }
        return FilterAddEvent;
    }());
    var FilterRemoveEvent = (function () {
        function FilterRemoveEvent(filter) {
            this.filter = filter;
        }
        return FilterRemoveEvent;
    }());
    var FilterRemoveAllEvent = (function () {
        function FilterRemoveAllEvent() {
        }
        return FilterRemoveAllEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterBaseComponent = (function () {
        function FilterBaseComponent(filtersContainer) {
            this.filtersContainer = filtersContainer;
            this._subscription = filtersContainer.events.pipe(operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; })).subscribe(this.removeFilter.bind(this));
        }
        /**
         * @return {?}
         */
        FilterBaseComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.addFilter =
            function (_filter) {
                if (!_filter.initial) {
                    this.filtersContainer.addFilter(_filter);
                }
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.removeFilter =
            function (_filter) {
                if (!_filter) {
                    return;
                }
                this.filtersContainer.removeFilter(_filter);
            };
        FilterBaseComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-filter-base'
                    },] },
        ];
        /** @nocollapse */
        FilterBaseComponent.ctorParameters = function () {
            return [
                { type: FilterContainerComponent, decorators: [{ type: core.Host },] },
            ];
        };
        FilterBaseComponent.propDecorators = {
            "filters": [{ type: core.Input },],
        };
        return FilterBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterDropdownComponent = (function (_super) {
        __extends(FilterDropdownComponent, _super);
        function FilterDropdownComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.removeFilter =
            function () {
                _super.prototype.removeFilter.call(this, this.selected);
                this.selected = this.initial;
            };
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.ngOnInit =
            function () {
                this.selected = this.initial;
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterDropdownComponent.prototype.selectFilter =
            function (filter) {
                this.removeFilter();
                this.selected = filter;
                this.addFilter(this.selected);
            };
        FilterDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dropdown',
                        template: "<div class=\"btn-group\" dropdown>\n    <button dropdownToggle type=\"button\" class=\"filter-dropdown btn dropdown-toggle\" [class.active]=\"selected !== initial\">{{ selected?.title }} \n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n    <ul *dropdownMenu class=\"dropdown-menu\" role=\"menu\">\n        <li class=\"dropdown-list-item\" *ngFor=\"let filter of filters\" role=\"menuitem\">\n            <a class=\"dropdown-item\" (click)=\"selectFilter(filter)\">\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n            </a>\n        </li>\n    </ul>\n</div>",
                    },] },
        ];
        /** @nocollapse */
        FilterDropdownComponent.ctorParameters = function () { return []; };
        FilterDropdownComponent.propDecorators = {
            "initial": [{ type: core.Input },],
        };
        return FilterDropdownComponent;
    }(FilterBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterDynamicComponent = (function (_super) {
        __extends(FilterDynamicComponent, _super);
        function FilterDynamicComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.defaultOptions = {
                placeholder: '',
                minCharacters: 3
            };
            _this.showTypeahead = true;
            _this.typeaheadItems = [];
            return _this;
        }
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.getItems =
            function () {
                var _this = this;
                return this.filters.filter(function (item) { return item !== _this.initial; }).map(function (item) { return item.name; });
            };
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.ngOnInit =
            function () {
                this.selected = this.initial;
                this.typeaheadItems = this.getItems();
                if (this.options && this.options.maxIndividualItems && this.options.maxIndividualItems + 1 >= this.filters.length) {
                    this.showTypeahead = false;
                }
            };
        /**
         * @param {?} typeaheadOption
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectOption =
            function (typeaheadOption) {
                this.removeFilter();
                var /** @type {?} */ idx = this.filters.findIndex(function (filter) { return filter.name === typeaheadOption.value; });
                this.selected = this.filters[idx];
                this.addFilter(this.selected);
                this.searchQuery = '';
                this.dropdown.hide();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FilterDynamicComponent.prototype.clickOff =
            function (event) {
                var /** @type {?} */ target = (event.target);
                var /** @type {?} */ hideDropdown = true;
                while (target && target.nodeName !== 'BODY') {
                    if (target.classList.contains('ux-dynamic-filter')) {
                        hideDropdown = false;
                        break;
                    }
                    else {
                        target = target.parentElement;
                    }
                }
                if (hideDropdown) {
                    this.searchQuery = '';
                    this.dropdown.hide();
                }
            };
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.removeFilter =
            function () {
                if (this.selected !== this.initial) {
                    _super.prototype.removeFilter.call(this, this.selected);
                    this.selected = this.initial;
                }
                this.searchQuery = '';
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectFilter =
            function (filter) {
                this.removeFilter();
                this.selected = filter;
                this.addFilter(this.selected);
            };
        FilterDynamicComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dynamic',
                        template: "<div class=\"btn-group ux-dynamic-filter\" dropdown #dynamicDropdown=\"bs-dropdown\">\n    <button (click)=\"dynamicDropdown.show()\" type=\"button\" [class.active]=\"selected !== initial\" class=\"filter-dropdown btn dropdown-toggle\">{{ selected?.title }} \n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n    <ul *dropdownMenu class=\"dropdown-menu\" role=\"menu\">\n\n        <li class=\"dropdown-list-item\" *ngIf=\"showTypeahead\" role=\"menuitem\">\n            <a class=\"dropdown-item\" (click)=\"removeFilter(); dynamicDropdown.hide();\">\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"initial === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ initial.name }}</span>\n            </a>\n        </li>\n\n        <li class=\"dropdown-list-item\" *ngIf=\"selected !== initial && showTypeahead\" role=\"menuitem\">\n            <a class=\"dropdown-item\">\n                <i class=\"hpe-icon hpe-checkmark\"></i>\n                <span class=\"filter-dropdown-title\">{{ selected.name }}</span>\n            </a>\n        </li>\n\n        <hr>\n\n        <li *ngIf=\"showTypeahead\" class=\"typeahead-box\">\n            <input [(ngModel)]=\"searchQuery\" [typeahead]=\"typeaheadItems\" class=\"form-control\" \n            (typeaheadOnSelect)=\"selectOption($event)\" \n            [placeholder]=\"options?.placeholder || defaultOptions.placeholder\"\n            [typeaheadMinLength]=\"options?.minCharacters || defaultOptions.minCharacters\"\n            [typeaheadOptionsLimit]=\"options?.maxResults\">\n        </li>\n\n        <span *ngIf=\"!showTypeahead\">\n            <li class=\"dropdown-list-item\" *ngFor=\"let filter of filters\" role=\"menuitem\">\n                <a class=\"dropdown-item\" (click)=\"selectFilter(filter)\">\n                    <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                    <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n                </a>\n            </li>\n        </span>\n\n    </ul>\n</div>",
                        host: {
                            '(document:click)': 'clickOff($event)',
                        }
                    },] },
        ];
        /** @nocollapse */
        FilterDynamicComponent.ctorParameters = function () { return []; };
        FilterDynamicComponent.propDecorators = {
            "filters": [{ type: core.Input },],
            "initial": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "dropdown": [{ type: core.ViewChild, args: [dropdown.BsDropdownDirective,] },],
        };
        return FilterDynamicComponent;
    }(FilterBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$2 = [
        FilterBaseComponent,
        FilterContainerComponent,
        FilterDropdownComponent,
        FilterDynamicComponent
    ];
    var FilterModule = (function () {
        function FilterModule() {
        }
        FilterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            dropdown.BsDropdownModule.forRoot(),
                            typeahead.TypeaheadModule.forRoot(),
                            TooltipModule,
                            forms.FormsModule,
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$2,
                        declarations: DECLARATIONS$2
                    },] },
        ];
        /** @nocollapse */
        FilterModule.ctorParameters = function () { return []; };
        return FilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardComponent = (function () {
        function FlippableCardComponent() {
            this.direction = 'horizontal';
            this.trigger = 'hover';
            this.width = 280;
            this.height = 200;
            this.flipped = false;
            this.flippedChange = new core.EventEmitter();
        }
        /**
         * @param {?} state
         * @return {?}
         */
        FlippableCardComponent.prototype.setFlipped =
            function (state) {
                this.flipped = state;
                this.flippedChange.emit(this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.toggleFlipped =
            function () {
                this.setFlipped(!this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.clickTrigger =
            function () {
                // add or remove the class depending on whether or not the card has been flipped
                if (this.trigger === 'click') {
                    this.toggleFlipped();
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverEnter =
            function () {
                // if the trigger is hover then begin to flip
                if (this.trigger === 'hover') {
                    this.setFlipped(true);
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverExit =
            function () {
                if (this.trigger === 'hover') {
                    this.setFlipped(false);
                }
            };
        FlippableCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-flippable-card',
                        template: "<div class=\"ux-flipper\" [class.ux-flip-card]=\"flipped\" [style.width.px]=\"width\" [style.height.px]=\"height\">\n\n    <div class=\"ux-flippable-card-front\" [style.width.px]=\"width\" [style.height.px]=\"height\">\n        <ng-content select=\"ux-flippable-card-front\"></ng-content>\n    </div>\n\n    <div class=\"ux-flippable-card-back\" [style.width.px]=\"width\" [style.height.px]=\"height\">\n        <ng-content select=\"ux-flippable-card-back\"></ng-content>\n    </div>\n</div>",
                        host: {
                            '[class.horizontal]': 'direction === "horizontal"',
                            '[class.vertical]': 'direction === "vertical"'
                        },
                        exportAs: 'ux-flippable-card'
                    },] },
        ];
        /** @nocollapse */
        FlippableCardComponent.ctorParameters = function () { return []; };
        FlippableCardComponent.propDecorators = {
            "direction": [{ type: core.Input },],
            "trigger": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "height": [{ type: core.Input },],
            "flipped": [{ type: core.Input },],
            "flippedChange": [{ type: core.Output },],
            "clickTrigger": [{ type: core.HostListener, args: ['click',] },],
            "hoverEnter": [{ type: core.HostListener, args: ['mouseenter',] },],
            "hoverExit": [{ type: core.HostListener, args: ['mouseleave',] },],
        };
        return FlippableCardComponent;
    }());
    var FlippableCardFrontDirective = (function () {
        function FlippableCardFrontDirective() {
        }
        FlippableCardFrontDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-front'
                    },] },
        ];
        /** @nocollapse */
        FlippableCardFrontDirective.ctorParameters = function () { return []; };
        return FlippableCardFrontDirective;
    }());
    var FlippableCardBackDirective = (function () {
        function FlippableCardBackDirective() {
        }
        FlippableCardBackDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-back'
                    },] },
        ];
        /** @nocollapse */
        FlippableCardBackDirective.ctorParameters = function () { return []; };
        return FlippableCardBackDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardModule = (function () {
        function FlippableCardModule() {
        }
        FlippableCardModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective],
                        declarations: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective]
                    },] },
        ];
        /** @nocollapse */
        FlippableCardModule.ctorParameters = function () { return []; };
        return FlippableCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsService = (function () {
        function FloatingActionButtonsService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.open =
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.toggle =
            function () {
                this.open$.next(!this.open$.getValue());
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.close =
            function () {
                this.open$.next(false);
            };
        FloatingActionButtonsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        FloatingActionButtonsService.ctorParameters = function () { return []; };
        return FloatingActionButtonsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsComponent = (function () {
        function FloatingActionButtonsComponent(fab, _elementRef) {
            this.fab = fab;
            this._elementRef = _elementRef;
            this.direction = 'top';
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                this._subscription = this.fab.open$.pipe(operators.filter(function (open) { return open === false; }))
                    .subscribe(function () { return _this.tooltips.forEach(function (tooltip$$1) { return tooltip$$1.hide(); }); });
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} target
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.close =
            function (target) {
                if (!this._elementRef.nativeElement.contains(target)) {
                    this.fab.close();
                }
            };
        FloatingActionButtonsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-buttons',
                        template: "<ng-content select=\"[fab-primary]\"></ng-content>\n\n<div class=\"floating-action-button-list\" [@fabAnimation]=\"fab.open$ | async\" [ngClass]=\"direction\" *ngIf=\"fab.open$ | async\">\n    <ng-content></ng-content>\n</div>",
                        providers: [FloatingActionButtonsService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        animations: [
                            animations.trigger('fabAnimation', [
                                animations.transition('void => true', [
                                    animations.query('ux-floating-action-button', animations.style({ opacity: 0 })),
                                    animations.query('ux-floating-action-button', animations.stagger(50, animations.animate(250, animations.style({ opacity: 1 }))))
                                ]),
                                animations.transition('true => void', [
                                    animations.query('ux-floating-action-button', animations.stagger(-50, animations.animate(250, animations.style({ opacity: 0 }))))
                                ])
                            ])
                        ]
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonsComponent.ctorParameters = function () {
            return [
                { type: FloatingActionButtonsService, },
                { type: core.ElementRef, },
            ];
        };
        FloatingActionButtonsComponent.propDecorators = {
            "direction": [{ type: core.Input },],
            "tooltips": [{ type: core.ContentChildren, args: [tooltip.TooltipDirective,] },],
            "close": [{ type: core.HostListener, args: ['document:click', ['$event.target'],] },],
        };
        return FloatingActionButtonsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonComponent = (function () {
        function FloatingActionButtonComponent(primary, fab) {
            this.fab = fab;
            this.tabindex = 1;
            this.primary = false;
            this.primary = primary !== null;
        }
        FloatingActionButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-button',
                        template: "<button class=\"btn floating-action-button\" \n        [class.button-primary]=\"primary\" \n        [class.button-secondary]=\"!primary\" \n        (click)=\"primary ? fab.toggle() : fab.close()\">\n\n    <span class=\"hpe-icon floating-action-button-icon\" *ngIf=\"icon\" [ngClass]=\"icon\"></span>\n    <ng-content *ngIf=\"!icon\"></ng-content>\n\n</button>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonComponent.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Attribute, args: ['fab-primary',] },] },
                { type: FloatingActionButtonsService, },
            ];
        };
        FloatingActionButtonComponent.propDecorators = {
            "icon": [{ type: core.Input },],
            "tabindex": [{ type: core.HostBinding },],
        };
        return FloatingActionButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsModule = (function () {
        function FloatingActionButtonsModule() {
        }
        FloatingActionButtonsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ],
                        declarations: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonsModule.ctorParameters = function () { return []; };
        return FloatingActionButtonsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarService = (function () {
        function HierarchyBarService() {
            this.nodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._nodes = [];
        }
        /**
         * Store the root node of the hierarchy tree
         */
        /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
        HierarchyBarService.prototype.setRootNode =
            function (root) {
                // store the root node
                this._root = root;
                // create a flat structure of nodes
                this._nodes = this.getNodeList(root);
                // flatten the array - based on the selected node
                this.nodes$.next(this.getSelectedChildren(root));
            };
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         */
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.selectNode =
            function (node) {
                // deselect all nodes
                this.deselectAll();
                // ensure the current node is selected and its parents
                this.select(node);
                // emit a new node list to trigger change detection
                this.nodes$.next(this.getSelectedChildren(this._root));
            };
        /**
         * Handles getting children with support for both arrays and observables
         */
        /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getChildren =
            function (node) {
                var _this = this;
                if (Array.isArray(node.children)) {
                    return of.of({ loading: false, children: node.children });
                }
                var /** @type {?} */ children$ = node.children;
                // if it is an observable then handle loading
                return Observable.Observable.create(function (observer) {
                    // emit initial value
                    observer.next({ loading: true, children: [] });
                    // now wait until the children observable completes
                    children$.pipe(operators.first()).subscribe(function (children) {
                        // replace the observable with an array for future loading
                        node.children = children;
                        // rebuild the node tree
                        // rebuild the node tree
                        _this.setRootNode(_this._root);
                        // emit the latest value
                        observer.next({ loading: false, children: children });
                        // close the observable stream
                        observer.complete();
                    });
                });
            };
        /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.select =
            function (node) {
                node.selected = true;
                if (node.parent) {
                    this.select(node.parent);
                }
            };
        /**
         * Deselects all nodes
         * @return {?}
         */
        HierarchyBarService.prototype.deselectAll =
            function () {
                this._nodes.forEach(function (node) { return node.selected = false; });
            };
        /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getNodeList =
            function (node) {
                var _this = this;
                // if there are no children then return only itself
                if (!node.children || node.children instanceof Observable.Observable || node.children.length === 0) {
                    return [node];
                }
                // store the parent property
                node.children.forEach(function (child) { return child.parent = node; });
                // get all descendants of this node
                var /** @type {?} */ descendants = node.children.reduce(function (nodes, current) { return __spread(nodes, _this.getNodeList(current)); }, []);
                return __spread([node], descendants);
            };
        /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getSelectedChildren =
            function (node) {
                if (node.children instanceof Observable.Observable) {
                    return [node];
                }
                // get the children - and account for when there is none
                var /** @type {?} */ children = node.children || [];
                // check if any child is selected
                var /** @type {?} */ child = children.find(function (_child) { return _child.selected; });
                // return the remaining chain of selected items
                return child ? __spread([node], this.getSelectedChildren(child)) : [node];
            };
        HierarchyBarService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        HierarchyBarService.ctorParameters = function () { return []; };
        return HierarchyBarService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarComponent = (function () {
        function HierarchyBarComponent(hierarchyBar) {
            var _this = this;
            this.hierarchyBar = hierarchyBar;
            this.selectedChange = new core.EventEmitter();
            this.overflow$ = new BehaviorSubject.BehaviorSubject(false);
            this.overflowNodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._subscription = new Subscription.Subscription();
            // subscribe to changes in the selected node
            var /** @type {?} */ selected = hierarchyBar.nodes$.subscribe(function (nodes) { return _this.selectedChange.emit(nodes.length === 0 ? null : nodes[nodes.length - 1]); });
            var /** @type {?} */ changed = hierarchyBar.nodes$.pipe(operators.debounceTime(0)).subscribe(function () { return _this.scrollIntoView(); });
            // store subscriptions
            this._subscription.add(selected);
            this._subscription.add(changed);
        }
        Object.defineProperty(HierarchyBarComponent.prototype, "root", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.setRootNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "selected", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.selectNode(node);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        HierarchyBarComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         */
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
        HierarchyBarComponent.prototype.scrollIntoView =
            function () {
                var _this = this;
                if (!this.nodelist) {
                    return;
                }
                // get the native element
                var nativeElement = this.nodelist.nativeElement;
                // emit whether or not there is overflow
                this.overflow$.next(nativeElement.scrollWidth > nativeElement.offsetWidth);
                // if the hierarchy bar contents do not overflow then do nothing
                if (nativeElement.scrollWidth > nativeElement.offsetWidth) {
                    // determine the amount of overflow
                    var /** @type {?} */ overflowAmount_1 = nativeElement.scrollWidth - nativeElement.offsetWidth;
                    // determine which nodes are not fully visible
                    this.overflowNodes$.next(this.nodes.filter(function (node) { return node.nativeElement.offsetLeft < overflowAmount_1; })
                        .map(function (node, index) { return _this.hierarchyBar.nodes$.value[index]; }));
                    // move the scroll position to always show the last itme
                    this.nodelist.nativeElement.scrollLeft = overflowAmount_1;
                }
            };
        HierarchyBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-hierarchy-bar',
                        template: "<!-- Allow content to be placed on the left of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarLeftAddon]\"></ng-content>\n</aside>\n\n<main #nodelist class=\"hierarchy-bar-nodes\" (uxResize)=\"scrollIntoView()\">\n\n    <div *ngIf=\"overflow$ | async\"\n         #popover=\"ux-popover\"\n         class=\"hierarchy-bar-overflow-indicator\"\n         [style.left.px]=\"nodelist.scrollLeft\"\n         [uxPopover]=\"overflow\"\n         [popoverContext]=\"{ popover: popover }\"\n         placement=\"bottom\"\n         popoverClass=\"hierarchy-bar-popover\">\n        . . .\n    </div>\n\n    <div #nodeElement class=\"hierarchy-bar-node\"\n         *ngFor=\"let node of hierarchyBar.nodes$ | async\">\n\n        <button class=\"hierarchy-bar-node-content\"\n                [attr.aria-label]=\"node.title\"\n                (click)=\"hierarchyBar.selectNode(node)\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n        </button>\n\n        <!-- Show a dropdown arrow if there are children -->\n        <button *ngIf=\"node.children\"\n              #popover=\"ux-popover\"\n              aria-label=\"Show children\"\n              role=\"button\"\n              class=\"hierarchy-bar-node-arrow hpe-icon hpe-next\"\n              [uxPopover]=\"content\"\n              [popoverContext]=\"{ node: node, popover: popover }\"\n              placement=\"bottom\"\n              popoverClass=\"hierarchy-bar-popover\"\n              tabindex=\"0\">\n        </button>\n\n    </div>\n\n</main>\n\n<!-- Allow content to be placed on the right of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarRightAddon]\"></ng-content>\n</aside>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n\n    <!-- Loading Indicator -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li class=\"hierarchy-bar-node-list-item\">\n            <ng-container [ngTemplateOutlet]=\"loadingIndicator || defaultLoadingIndicator\"></ng-container>\n        </li>\n    </ul>\n\n    <!-- List of children -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"!(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li *ngFor=\"let child of (hierarchyBar.getChildren(node) | async).children; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            [focusIf]=\"first\"\n            tabindex=\"0\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Template for the overflow popover list -->\n<ng-template #overflow let-popover=\"popover\">\n\n    <ul class=\"hierarchy-bar-node-list\">\n\n        <li *ngFor=\"let child of overflowNodes$ | async; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            tabindex=\"0\"\n            [focusIf]=\"first\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Loading Indicator Template -->\n<ng-template #defaultLoadingIndicator>\n    <div class=\"hierarchy-bar-node-icon\" alt=\"Hierarchy Bar Loading Indicator\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n    </div>\n\n    <!-- Show the name of the current node -->\n    <span class=\"hierarchy-bar-node-title\">Loading...</span>\n</ng-template>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        viewProviders: [HierarchyBarService]
                    },] },
        ];
        /** @nocollapse */
        HierarchyBarComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService, },
            ];
        };
        HierarchyBarComponent.propDecorators = {
            "root": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "loadingIndicator": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
            "nodelist": [{ type: core.ViewChild, args: ['nodelist',] },],
            "nodes": [{ type: core.ViewChildren, args: ['nodeElement',] },],
        };
        return HierarchyBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideDirective = (function () {
        function ClickOutsideDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.uxClickOutside = new core.EventEmitter();
        }
        /**
         * @param {?} event
         * @return {?}
         */
        ClickOutsideDirective.prototype.click =
            function (event) {
                if (this._elementRef.nativeElement !== event.target && !this._elementRef.nativeElement.contains(event.target)) {
                    this.uxClickOutside.emit(event);
                }
            };
        ClickOutsideDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxClickOutside]'
                    },] },
        ];
        /** @nocollapse */
        ClickOutsideDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ClickOutsideDirective.propDecorators = {
            "uxClickOutside": [{ type: core.Output },],
            "click": [{ type: core.HostListener, args: ['document:click', ['$event'],] },],
        };
        return ClickOutsideDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideModule = (function () {
        function ClickOutsideModule() {
        }
        ClickOutsideModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ClickOutsideDirective],
                        declarations: [ClickOutsideDirective]
                    },] },
        ];
        /** @nocollapse */
        ClickOutsideModule.ctorParameters = function () { return []; };
        return ClickOutsideModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniquePopoverId = 0;
    var PopoverComponent = (function (_super) {
        __extends(PopoverComponent, _super);
        function PopoverComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Define a unique id for each popover
             */
            _this.id = "ux-popover-" + ++uniquePopoverId;
            /**
             * This will emit an event any time the user clicks outside the popover
             */
            _this.clickOutside$ = new Subject.Subject();
            return _this;
        }
        /** This will update the title of the popover and trigger change detection */
        /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
        PopoverComponent.prototype.setTitle =
            function (title) {
                this.title = title;
                this._changeDetectorRef.markForCheck();
            };
        PopoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-popover',
                        template: "<div class=\"popover show\" [ngClass]=\"[placement, customClass]\" [id]=\"id\" [attr.role]=\"role\" (uxClickOutside)=\"clickOutside$.next($event)\">\n    <div class=\"arrow\"></div>\n    <h3 class=\"popover-title\" *ngIf=\"title\">{{ title }}</h3>\n    <div class=\"popover-content\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        PopoverComponent.ctorParameters = function () { return []; };
        return PopoverComponent;
    }(TooltipComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverDirective = (function (_super) {
        __extends(PopoverDirective, _super);
        function PopoverDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * All the user to add a custom class to the popover
             */
            _this.customClass = '';
            /**
             * All the user to add a role to the popover - default is tooltip
             */
            _this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            _this.context = {};
            /**
             * Delay the showing of the popover by a number of miliseconds
             */
            _this.delay = 0;
            /**
             * Specify which events should show the popover
             */
            _this.showTriggers = ['click'];
            /**
             * Specify which events should hide the popover
             */
            _this.hideTriggers = ['click', 'clickoutside', 'escape'];
            /**
             * Keep track of the tooltip visibility and update aria-expanded attribute
             */
            _this.isVisible = false;
            /**
             * Internally store the type of this component - usual for distinctions when extending the tooltip class
             */
            _this._type = 'popover';
            return _this;
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        PopoverDirective.prototype.ngOnInit =
            function () {
                // set up the event triggers
                fromEvent.fromEvent(document, 'keydown').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onKeyDown.bind(this));
                // check if there is an aria-described by attribute
                this._ariaDescribedBy = this._elementRef.nativeElement.hasAttribute('aria-describedby');
                // set up the default event triggers
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        PopoverDirective.prototype.ngOnChanges =
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (this._instance && changes["title"]) {
                    this._instance.setTitle(changes["title"].currentValue);
                }
            };
        /**
         * @param {?} overlayRef
         * @return {?}
         */
        PopoverDirective.prototype.createInstance =
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setTitle(this.title);
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                // subscribe to the outside click event
                instance.clickOutside$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClickOutside.bind(this));
                return instance;
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.createPortal =
            function () {
                return this._portal || new portal.ComponentPortal(PopoverComponent, this._viewContainerRef);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        PopoverDirective.prototype.onKeyDown =
            function (event) {
                // if visible and the escape key is pressed and it is one of the hide triggers
                if (this.isVisible && event.keyCode === keycodes.ESCAPE && this.includes(this.hideTriggers, 'escape')) {
                    this.hide();
                }
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.onClickOutside =
            function () {
                // if visible and it is one of the hide triggers
                if (this.isVisible && this.includes(this.hideTriggers, 'clickoutside')) {
                    this.hide();
                }
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        PopoverDirective.prototype.setAriaDescribedBy =
            function (id) {
                // we only want to set the aria-describedby attr when the content is a string and there was no user defined attribute already
                if (this._ariaDescribedBy === false && typeof this.content === 'string') {
                    _super.prototype.setAriaDescribedBy.call(this, id);
                }
            };
        PopoverDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPopover]',
                        exportAs: 'ux-popover'
                    },] },
        ];
        /** @nocollapse */
        PopoverDirective.ctorParameters = function () { return []; };
        PopoverDirective.propDecorators = {
            "content": [{ type: core.Input, args: ['uxPopover',] },],
            "title": [{ type: core.Input, args: ['popoverTitle',] },],
            "disabled": [{ type: core.Input, args: ['popoverDisabled',] },],
            "customClass": [{ type: core.Input, args: ['popoverClass',] },],
            "role": [{ type: core.Input, args: ['popoverRole',] },],
            "context": [{ type: core.Input, args: ['popoverContext',] },],
            "delay": [{ type: core.Input, args: ['popoverDelay',] },],
            "showTriggers": [{ type: core.Input },],
            "hideTriggers": [{ type: core.Input },],
            "isVisible": [{ type: core.HostBinding, args: ['attr.aria-expanded',] },],
        };
        return PopoverDirective;
    }(TooltipDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverModule = (function () {
        function PopoverModule() {
        }
        PopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule,
                            ClickOutsideModule,
                            TooltipModule
                        ],
                        exports: [PopoverDirective],
                        declarations: [PopoverComponent, PopoverDirective],
                        entryComponents: [PopoverComponent]
                    },] },
        ];
        /** @nocollapse */
        PopoverModule.ctorParameters = function () { return []; };
        return PopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarModule = (function () {
        function HierarchyBarModule() {
        }
        HierarchyBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            FocusIfModule,
                            PopoverModule
                        ],
                        exports: [HierarchyBarComponent],
                        declarations: [HierarchyBarComponent],
                    },] },
        ];
        /** @nocollapse */
        HierarchyBarModule.ctorParameters = function () { return []; };
        return HierarchyBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelService = (function () {
        function SidePanelService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        SidePanelService.prototype.open =
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        SidePanelService.prototype.close =
            function () {
                this.open$.next(false);
            };
        SidePanelService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SidePanelService.ctorParameters = function () { return []; };
        return SidePanelService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelComponent = (function () {
        function SidePanelComponent(service, _elementRef) {
            this.service = service;
            this._elementRef = _elementRef;
            this.inline = false;
            this.attachTo = 'window';
            this.width = '50%';
            this.top = '0';
            this.modal = false;
            this.animate = false;
            this.closeOnExternalClick = false;
            this.openChange = new core.EventEmitter();
        }
        Object.defineProperty(SidePanelComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this.service.open$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return 'static';
                }
                if (this.attachTo === 'container') {
                    return 'absolute';
                }
                return 'fixed';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.width === 'number') {
                    return this.width === 0 ? '0' : this.width + 'px';
                }
                return this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssTop", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.top === 'number') {
                    return this.top === 0 ? '0' : this.top + 'px';
                }
                return this.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "componentWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return this.open ? this.cssWidth : '0';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "hostWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline ? '100%' : this.cssWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this.service.open$.subscribe(function (next) {
                    _this.openChange.emit(next);
                });
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.openPanel =
            function () {
                this.service.open();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.closePanel =
            function () {
                this.service.close();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SidePanelComponent.prototype.clickHandler =
            function (event) {
                if (!this.open || !this.closeOnExternalClick) {
                    return;
                }
                var /** @type {?} */ target = (event.target);
                if (!this._elementRef.nativeElement.contains(target) ||
                    (target && target.classList.contains('modal-backdrop'))) {
                    this.closePanel();
                }
            };
        SidePanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-side-panel',
                        exportAs: 'ux-side-panel',
                        template: "<div *ngIf=\"modal && open\" class=\"modal-backdrop\"\n    [style.position]=\"position\"\n    [style.top]=\"cssTop\"></div>\n\n<div class=\"ux-side-panel-host\"\n    [class.modal-panel]=\"modal\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\">\n    <ng-content></ng-content>\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel'
                        }
                    },] },
        ];
        /** @nocollapse */
        SidePanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService, },
                { type: core.ElementRef, },
            ];
        };
        SidePanelComponent.propDecorators = {
            "open": [{ type: core.Input }, { type: core.HostBinding, args: ['class.open',] },],
            "inline": [{ type: core.Input }, { type: core.HostBinding, args: ['class.inline',] },],
            "attachTo": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "top": [{ type: core.Input },],
            "modal": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-modal',] },],
            "animate": [{ type: core.Input }, { type: core.HostBinding, args: ['class.animate',] },],
            "closeOnExternalClick": [{ type: core.Input },],
            "openChange": [{ type: core.Output },],
            "componentWidth": [{ type: core.HostBinding, args: ['style.width',] },],
            "closePanel": [{ type: core.HostListener, args: ['document:keyup.escape',] },],
            "clickHandler": [{ type: core.HostListener, args: ['document:click', ['$event'],] },],
        };
        return SidePanelComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ItemDisplayPanelContentDirective = (function () {
        function ItemDisplayPanelContentDirective() {
        }
        ItemDisplayPanelContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelContent]'
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelContentDirective.ctorParameters = function () { return []; };
        return ItemDisplayPanelContentDirective;
    }());
    var ItemDisplayPanelFooterDirective = (function () {
        function ItemDisplayPanelFooterDirective() {
        }
        ItemDisplayPanelFooterDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelFooter]'
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelFooterDirective.ctorParameters = function () { return []; };
        return ItemDisplayPanelFooterDirective;
    }());
    var ItemDisplayPanelComponent = (function (_super) {
        __extends(ItemDisplayPanelComponent, _super);
        function ItemDisplayPanelComponent(service, elementRef) {
            var _this = _super.call(this, service, elementRef) || this;
            _this.boxShadow = true;
            _this.closeVisible = true;
            _this.shadow = false;
            _this.visibleChange = new core.EventEmitter();
            _this.animate = false;
            _this.closeOnExternalClick = true;
            return _this;
        }
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "preventClose", {
            get: /**
             * @return {?}
             */ function () {
                return !this.closeOnExternalClick;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.closeOnExternalClick = !value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "title", {
            get: /**
             * @return {?}
             */ function () {
                return this.header;
            },
            set: /**
             * @deprecated
             * Title used for adding tooltips and shouldn't be used as an input
             * instead header will be used. This is here to support backward compatibility only
             * this property should not be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.header = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this.open;
            },
            set: /**
             * @param {?} visible
             * @return {?}
             */ function (visible) {
                this.open = visible;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this._itemDisplayPanelSubscription = this.service.open$.subscribe(function (next) {
                    _this.visibleChange.emit(next);
                });
            };
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.ngOnDestroy =
            function () {
                this._itemDisplayPanelSubscription.unsubscribe();
            };
        ItemDisplayPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-item-display-panel',
                        template: "<div class=\"ux-side-panel-host ux-item-display-panel\"\n    [class.box-shadow]=\"boxShadow\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\">\n\n    <div class=\"ux-side-panel-header\" [class.item-display-panel-shadow]=\"shadow\">\n        <h3>{{ header }}</h3>\n        <button *ngIf=\"closeVisible\" type=\"button\" class=\"btn btn-lg btn-link btn-icon button-secondary\" (click)=\"visible = false\">\n            <i class=\"hpe-icon hpe-close\"></i>\n        </button>\n    </div>\n\n    <div class=\"ux-side-panel-content\">\n        <ng-content select=\"[uxItemDisplayPanelContent]\"></ng-content>\n    </div>\n\n    <div class=\"ux-side-panel-footer\" *ngIf=\"footer\">\n        <ng-content select=\"[uxItemDisplayPanelFooter]\"></ng-content>\n    </div>\n\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel ux-item-display-panel'
                        }
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService, },
                { type: core.ElementRef, },
            ];
        };
        ItemDisplayPanelComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "boxShadow": [{ type: core.Input },],
            "closeVisible": [{ type: core.Input },],
            "preventClose": [{ type: core.Input },],
            "shadow": [{ type: core.Input },],
            "footer": [{ type: core.ContentChild, args: [ItemDisplayPanelFooterDirective,] },],
            "visibleChange": [{ type: core.Output },],
            "title": [{ type: core.Input },],
            "visible": [{ type: core.Input },],
        };
        return ItemDisplayPanelComponent;
    }(SidePanelComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$3 = [
        ItemDisplayPanelComponent,
        ItemDisplayPanelContentDirective,
        ItemDisplayPanelFooterDirective
    ];
    var ItemDisplayPanelModule = (function () {
        function ItemDisplayPanelModule() {
        }
        ItemDisplayPanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$3,
                        declarations: DECLARATIONS$3
                    },] },
        ];
        /** @nocollapse */
        ItemDisplayPanelModule.ctorParameters = function () { return []; };
        return ItemDisplayPanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardStepComponent = (function () {
        function WizardStepComponent() {
            this.valid = true;
            this.visitedChange = new core.EventEmitter();
            this._active = false;
            this._visited = false;
        }
        Object.defineProperty(WizardStepComponent.prototype, "visited", {
            get: /**
             * @return {?}
             */ function () {
                return this._visited;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._visited = value;
                this.visitedChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // store the active state of the step
                this._active = value;
                // if the value is true then the step should also be marked as visited
                if (value === true) {
                    this.visited = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        WizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                    },] },
        ];
        /** @nocollapse */
        WizardStepComponent.ctorParameters = function () { return []; };
        WizardStepComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "valid": [{ type: core.Input },],
            "visitedChange": [{ type: core.Input },],
            "visited": [{ type: core.Input },],
        };
        return WizardStepComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardComponent = (function () {
        function WizardComponent() {
            this._step = 0;
            this.steps = new core.QueryList();
            this.orientation = 'horizontal';
            this.nextText = 'Next';
            this.previousText = 'Previous';
            this.cancelText = 'Cancel';
            this.finishText = 'Finish';
            this.nextTooltip = 'Go to the next step';
            this.previousTooltip = 'Go to the previous step';
            this.cancelTooltip = 'Cancel the wizard';
            this.finishTooltip = 'Finish the wizard';
            this.nextDisabled = false;
            this.previousDisabled = false;
            this.cancelDisabled = false;
            this.finishDisabled = false;
            this.nextVisible = true;
            this.previousVisible = true;
            this.cancelVisible = true;
            this.finishVisible = true;
            this.cancelAlwaysVisible = false;
            this.finishAlwaysVisible = false;
            this.onNext = new core.EventEmitter();
            this.onPrevious = new core.EventEmitter();
            this.onCancel = new core.EventEmitter();
            this.onFinishing = new core.EventEmitter();
            this.onFinish = new core.EventEmitter();
            this.stepChanging = new core.EventEmitter();
            this.stepChange = new core.EventEmitter();
            this.invalidIndicator = false;
        }
        Object.defineProperty(WizardComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // only accept numbers as valid options
                if (typeof value === 'number') {
                    // store the active step
                    this._step = value;
                    // update which steps should be active
                    this.update();
                    // emit the change event
                    this.stepChange.next(this.step);
                    // reset the invalid state
                    this.invalidIndicator = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WizardComponent.prototype.ngAfterViewInit =
            function () {
                // initially set the correct visibility of the steps
                setTimeout(this.update.bind(this));
            };
        /**
         * Navigate to the next step
         */
        /**
         * Navigate to the next step
         * @return {?}
         */
        WizardComponent.prototype.next =
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step + 1));
                // check if current step is invalid
                if (!this.getCurrentStep().valid) {
                    this.invalidIndicator = true;
                    return;
                }
                // check if we are currently on the last step
                if ((this.step + 1) < this.steps.length) {
                    this.step++;
                    // emit the current step
                    this.onNext.next(this.step);
                }
            };
        /**
         * Navigate to the previous step
         */
        /**
         * Navigate to the previous step
         * @return {?}
         */
        WizardComponent.prototype.previous =
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step - 1));
                // check if we are currently on the last step
                if (this.step > 0) {
                    this.step--;
                    // emit the current step
                    this.onPrevious.next(this.step);
                }
            };
        /**
         * Perform actions when the finish button is clicked
         */
        /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
        WizardComponent.prototype.finish =
            function () {
                var _this = this;
                // fires when the finish button is clicked always
                this.onFinishing.next();
                /**
                         * This is required because we need to ensure change detection has run
                         * to determine whether or not we have the latest value for the 'valid' input
                         * on the current step. Unfortunately we can't use ChangeDetectorRef as we are looking to run
                         * on content children, and we cant use ApplicationRef.tick() as this does not work in a hybrid app, eg. our docs
                         */
                return new Promise(function (resolve) {
                    setTimeout(function () {
                        // only fires when the finish button is clicked and the step is valid
                        if (_this.getCurrentStep().valid) {
                            _this.onFinish.next();
                        }
                        resolve();
                    });
                });
            };
        /**
         * Perform actions when the cancel button is clicked
         */
        /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
        WizardComponent.prototype.cancel =
            function () {
                this.onCancel.next();
            };
        /**
         * Update the active state of each step
         */
        /**
         * Update the active state of each step
         * @return {?}
         */
        WizardComponent.prototype.update =
            function () {
                var _this = this;
                // update which steps should be active
                this.steps.forEach(function (step, idx) { return step.active = idx === _this.step; });
            };
        /**
         * Jump to a specific step only if the step has previously been visited
         */
        /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
        WizardComponent.prototype.gotoStep =
            function (step) {
                if (step.visited) {
                    var /** @type {?} */ stepIndex = this.steps.toArray().findIndex(function (stp) { return stp === step; });
                    this.stepChanging.next(new StepChangingEvent(this.step, stepIndex));
                    this.step = stepIndex;
                }
            };
        /**
         * Determine if the current step is the last step
         */
        /**
         * Determine if the current step is the last step
         * @return {?}
         */
        WizardComponent.prototype.isLastStep =
            function () {
                return this.step === (this.steps.length - 1);
            };
        /**
         * Reset the wizard - goes to first step and resets visited state
         */
        /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
        WizardComponent.prototype.reset =
            function () {
                // mark all steps as not visited
                this.steps.forEach(function (step) { return step.visited = false; });
                // go to the first step
                this.step = 0;
            };
        /**
         * Get the step at the current index
         */
        /**
         * Get the step at the current index
         * @return {?}
         */
        WizardComponent.prototype.getCurrentStep =
            function () {
                return this.getStepAtIndex(this.step);
            };
        /**
         * Return a step at a specific index
         */
        /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
        WizardComponent.prototype.getStepAtIndex =
            function (index) {
                return this.steps.toArray()[index];
            };
        WizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard',
                        template: "<div class=\"wizard-body\">\n\n    <div class=\"wizard-steps\">\n\n        <div class=\"wizard-step\" [class.active]=\"stp.active\" [class.visited]=\"stp.visited\" [class.invalid]=\"stp.active && !stp.valid && invalidIndicator\" (click)=\"gotoStep(stp)\" *ngFor=\"let stp of steps\">\n            {{ stp.header }}\n        </div>\n\n    </div>\n\n    <div class=\"wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n</div>\n\n<div class=\"wizard-footer\">\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" [disabled]=\"previousDisabled || step === 0\"\n        (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" [disabled]=\"nextDisabled\"\n        (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n        [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n        [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n</div>",
                        host: {
                            '[class]': 'orientation'
                        }
                    },] },
        ];
        /** @nocollapse */
        WizardComponent.ctorParameters = function () { return []; };
        WizardComponent.propDecorators = {
            "steps": [{ type: core.ContentChildren, args: [WizardStepComponent,] },],
            "orientation": [{ type: core.Input },],
            "nextText": [{ type: core.Input },],
            "previousText": [{ type: core.Input },],
            "cancelText": [{ type: core.Input },],
            "finishText": [{ type: core.Input },],
            "nextTooltip": [{ type: core.Input },],
            "previousTooltip": [{ type: core.Input },],
            "cancelTooltip": [{ type: core.Input },],
            "finishTooltip": [{ type: core.Input },],
            "nextDisabled": [{ type: core.Input },],
            "previousDisabled": [{ type: core.Input },],
            "cancelDisabled": [{ type: core.Input },],
            "finishDisabled": [{ type: core.Input },],
            "nextVisible": [{ type: core.Input },],
            "previousVisible": [{ type: core.Input },],
            "cancelVisible": [{ type: core.Input },],
            "finishVisible": [{ type: core.Input },],
            "cancelAlwaysVisible": [{ type: core.Input },],
            "finishAlwaysVisible": [{ type: core.Input },],
            "onNext": [{ type: core.Output },],
            "onPrevious": [{ type: core.Output },],
            "onCancel": [{ type: core.Output },],
            "onFinishing": [{ type: core.Output },],
            "onFinish": [{ type: core.Output },],
            "stepChanging": [{ type: core.Output },],
            "stepChange": [{ type: core.Output },],
            "step": [{ type: core.Input },],
        };
        return WizardComponent;
    }());
    var StepChangingEvent = (function () {
        function StepChangingEvent(from$$1, to) {
            this.from = from$$1;
            this.to = to;
        }
        return StepChangingEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$4 = [
        WizardComponent,
        WizardStepComponent
    ];
    var WizardModule = (function () {
        function WizardModule() {
        }
        WizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TooltipModule
                        ],
                        exports: DECLARATIONS$4,
                        declarations: DECLARATIONS$4
                    },] },
        ];
        /** @nocollapse */
        WizardModule.ctorParameters = function () { return []; };
        return WizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This service is required to provide a form of communication
     * between the marquee wizard steps and the containing marquee wizard.
     * We cannot inject the Host due to the steps being content children
     * rather than view children.
     */
    var MarqueeWizardService = (function () {
        function MarqueeWizardService() {
            this.valid$ = new Subject.Subject();
        }
        MarqueeWizardService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MarqueeWizardService.ctorParameters = function () { return []; };
        return MarqueeWizardService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardStepComponent = (function (_super) {
        __extends(MarqueeWizardStepComponent, _super);
        function MarqueeWizardStepComponent(_marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this._marqueeWizardService = _marqueeWizardService;
            _this.completed = false;
            _this.completedChange = new core.EventEmitter();
            _this._valid = true;
            return _this;
        }
        Object.defineProperty(MarqueeWizardStepComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                if (this._marqueeWizardService) {
                    this._marqueeWizardService.valid$.next({ step: this, valid: valid });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Update the completed state and emit the latest value
         * @param completed whether or not the step is completed
         */
        /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
        MarqueeWizardStepComponent.prototype.setCompleted =
            function (completed) {
                this.completed = completed;
                this.completedChange.emit(completed);
            };
        MarqueeWizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardStepComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService, },
            ];
        };
        MarqueeWizardStepComponent.propDecorators = {
            "icon": [{ type: core.Input },],
            "completed": [{ type: core.Input },],
            "completedChange": [{ type: core.Output },],
        };
        return MarqueeWizardStepComponent;
    }(WizardStepComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardComponent = (function (_super) {
        __extends(MarqueeWizardComponent, _super);
        function MarqueeWizardComponent(marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this.steps = new core.QueryList();
            marqueeWizardService.valid$.pipe(operators.filter(function (event) { return !event.valid; })).subscribe(_this.validChange.bind(_this));
            return _this;
        }
        Object.defineProperty(MarqueeWizardComponent.prototype, "isTemplate", {
            get: /**
             * @return {?}
             */ function () {
                return this.description && this.description instanceof core.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         */
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
        MarqueeWizardComponent.prototype.next =
            function () {
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                if (step.valid) {
                    _super.prototype.next.call(this);
                    // mark this step as completed
                    step.setCompleted(true);
                }
            };
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         */
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
        MarqueeWizardComponent.prototype.finish =
            function () {
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                // call the original finish function
                return _super.prototype.finish.call(this).then(function () {
                    // if the step is valid indicate that it is now complete
                    if (step.valid) {
                        step.setCompleted(true);
                    }
                });
            };
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         */
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
        MarqueeWizardComponent.prototype.validChange =
            function (state) {
                var /** @type {?} */ steps = this.steps.toArray();
                var /** @type {?} */ current = steps.findIndex(function (step) { return step === state.step; });
                var /** @type {?} */ affected = steps.slice(current);
                affected.forEach(function (step) {
                    // the step should no longer be completed
                    step.completed = false;
                    // if the step is not the current step then also mark it as unvisited
                    if (step !== state.step) {
                        step.visited = false;
                    }
                });
            };
        MarqueeWizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard',
                        template: "<div class=\"marquee-wizard-side-panel\">\n\n    <div class=\"marquee-wizard-description-container\" *ngIf=\"description\">\n        <!-- If a template was provided display it -->\n        <ng-container *ngIf=\"isTemplate\" [ngTemplateOutlet]=\"description\"></ng-container>\n\n        <!-- Otherwise wimply display the string -->\n        <ng-container *ngIf=\"!isTemplate\">\n            <p>{{ description }}</p>\n        </ng-container>\n    </div>\n\n    <ul class=\"marquee-wizard-steps\">\n\n        <li class=\"marquee-wizard-step\" *ngFor=\"let step of steps\" (click)=\"gotoStep(step)\" [class.active]=\"step.active\" [class.visited]=\"step.visited\" [class.invalid]=\"!step.valid\">\n            <i class=\"marquee-wizard-step-icon\" [ngClass]=\"step.icon\"></i>\n            <span class=\"marquee-wizard-step-title\">{{ step.header }}</span>\n            <span class=\"marquee-wizard-step-status hpe-icon hpe-checkmark\" *ngIf=\"step.completed\"></span>\n        </li>\n\n    </ul>\n</div>\n\n<div class=\"marquee-wizard-content-panel\">\n    <div class=\"marquee-wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n    <div class=\"modal-footer\">\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" container=\"body\"\n            [disabled]=\"previousDisabled || step === 0\" (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" container=\"body\"\n            [disabled]=\"nextDisabled\" (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n            container=\"body\" [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n            container=\"body\" [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n    </div>\n</div>",
                        providers: [MarqueeWizardService]
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService, },
            ];
        };
        MarqueeWizardComponent.propDecorators = {
            "description": [{ type: core.Input },],
            "steps": [{ type: core.ContentChildren, args: [MarqueeWizardStepComponent,] },],
        };
        return MarqueeWizardComponent;
    }(WizardComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardModule = (function () {
        function MarqueeWizardModule() {
        }
        MarqueeWizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            WizardModule,
                            TooltipModule
                        ],
                        exports: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ],
                        declarations: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardModule.ctorParameters = function () { return []; };
        return MarqueeWizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioService = (function () {
        function AudioService(_http) {
            this._http = _http;
        }
        /**
         * @param {?} mediaElement
         * @return {?}
         */
        AudioService.prototype.getAudioFileMetadata =
            function (mediaElement) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this._http.request(mediaElement.src, { responseType: http.ResponseContentType.Blob }).subscribe(function (response) {
                        var /** @type {?} */ filename = mediaElement.src.substring(mediaElement.src.lastIndexOf('/') + 1);
                        var /** @type {?} */ extension = mediaElement.src.substring(mediaElement.src.lastIndexOf('.') + 1).toLowerCase();
                        var /** @type {?} */ blob = response.blob();
                        var /** @type {?} */ description;
                        switch (extension) {
                            case 'mp3':
                                description = 'MPEG audio layer 3 file';
                                break;
                            case 'wma':
                                description = 'Windows media audio file';
                                break;
                            case 'wav':
                                description = 'WAVE audio file';
                                break;
                            case 'ogg':
                                description = 'Ogg Vorbis file';
                                break;
                            case 'aac':
                                description = 'Advanced audio coding file';
                                break;
                            case 'midi':
                                description = 'Musical instrument digital interface file';
                                break;
                            default:
                                description = 'Audio file';
                                break;
                        }
                        observer.next({
                            filename: filename,
                            extension: extension,
                            description: description,
                            size: blob.size
                        });
                    });
                });
            };
        /**
         * @param {?} url
         * @return {?}
         */
        AudioService.prototype.getWaveformFromUrl =
            function (url) {
                var _this = this;
                // if audio context is not support return a stream of empty data
                if (!((window)).AudioContext) {
                    return of.of([new Float32Array(0)]);
                }
                this._audioContext = new AudioContext();
                this.createVolumeNode();
                this.createAnalyserNode();
                return Observable.Observable.create(function (observer) {
                    // load the media from the URL provided
                    // load the media from the URL provided
                    _this._http.request(url, { responseType: http.ResponseContentType.ArrayBuffer }).subscribe(function (response) {
                        _this.getAudioBuffer(response.arrayBuffer()).subscribe(function (audioBuffer) {
                            // create the buffer source
                            // create the buffer source
                            _this.createBufferSource(audioBuffer);
                            var /** @type {?} */ dataPoints = [];
                            var /** @type {?} */ channels = _this._audioBuffer.numberOfChannels;
                            // extract the data from each channel
                            for (var /** @type {?} */ channelIdx = 0; channelIdx < channels; channelIdx++) {
                                dataPoints[channelIdx] = _this._audioBuffer.getChannelData(channelIdx);
                            }
                            observer.next(dataPoints);
                            observer.complete();
                            // cleanup after ourselves
                            dataPoints = null;
                        }, function (error) { return observer.error(error); });
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
        AudioService.prototype.getWaveformPoints =
            function (channels, skip) {
                if (channels === void 0) {
                    channels = [];
                }
                if (skip === void 0) {
                    skip = 1000;
                }
                var /** @type {?} */ waveform = [];
                var /** @type {?} */ duration = channels.length > 0 ? channels[0].length : 0;
                var _loop_1 = function (idx) {
                    // get all the channel data for a specific point
                    var /** @type {?} */ points = channels.map(function (channel) { return channel[idx]; });
                    // find the minimum point and maximum points at each position across all channels
                    waveform.push({
                        min: points.reduce(function (previous, current) { return current < previous ? current : previous; }),
                        max: points.reduce(function (previous, current) { return current > previous ? current : previous; })
                    });
                };
                // convert each channel data to a series of waveform points
                for (var /** @type {?} */ idx = 0; idx < duration; idx += skip) {
                    _loop_1(idx);
                }
                return waveform;
            };
        /**
         * @param {?} arrayBuffer
         * @return {?}
         */
        AudioService.prototype.getAudioBuffer =
            function (arrayBuffer) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this.getOfflineAudioContext().decodeAudioData(arrayBuffer, function (audioBuffer) {
                        observer.next(audioBuffer);
                        observer.complete();
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @return {?}
         */
        AudioService.prototype.getOfflineAudioContext =
            function () {
                return new OfflineAudioContext(1, 2, this._audioContext.sampleRate || 44100);
            };
        /**
         * @param {?} audioBuffer
         * @return {?}
         */
        AudioService.prototype.createBufferSource =
            function (audioBuffer) {
                this.disconnectSource();
                this._audioBuffer = audioBuffer;
                this._audioBufferSource = this._audioContext.createBufferSource();
                this._audioBufferSource.buffer = this._audioBuffer;
                this._audioBufferSource.connect(this._analyserNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createVolumeNode =
            function () {
                this._gainNode = this._audioContext.createGain();
                this._gainNode.connect(this._audioContext.destination);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createAnalyserNode =
            function () {
                this._analyserNode = this._audioContext.createAnalyser();
                this._analyserNode.connect(this._gainNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.disconnectSource =
            function () {
                if (this._audioBufferSource) {
                    this._audioBufferSource.disconnect();
                }
            };
        AudioService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        AudioService.ctorParameters = function () {
            return [
                { type: http.Http, },
            ];
        };
        return AudioService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioServiceModule = (function () {
        function AudioServiceModule() {
        }
        AudioServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [http.HttpModule],
                        providers: [AudioService]
                    },] },
        ];
        /** @nocollapse */
        AudioServiceModule.ctorParameters = function () { return []; };
        return AudioServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionService = (function () {
        function FrameExtractionService() {
        }
        /**
         * @param {?} source
         * @return {?}
         */
        FrameExtractionService.prototype.createVideoPlayer =
            function (source) {
                var /** @type {?} */ videoPlayer = document.createElement('video');
                videoPlayer.preload = 'auto';
                videoPlayer.src = source;
                return videoPlayer;
            };
        /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        FrameExtractionService.prototype.createCanvas =
            function (width, height) {
                var /** @type {?} */ canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            };
        /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.goToFrame =
            function (videoPlayer, time) {
                videoPlayer.currentTime = time;
                return fromEvent.fromEvent(videoPlayer, time === 0 ? 'loadeddata' : 'seeked');
            };
        /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
        FrameExtractionService.prototype.getThumbnail =
            function (videoPlayer, canvas, time, width, height) {
                var _this = this;
                if (width === void 0) {
                    width = 160;
                }
                if (height === void 0) {
                    height = 90;
                }
                return Observable.Observable.create(function (observer) {
                    // go to specified frame
                    var /** @type {?} */ subscription = _this.goToFrame(videoPlayer, time).subscribe(function (event) {
                        // create image from current frame
                        canvas.getContext('2d').drawImage(videoPlayer, 0, 0, width, height);
                        observer.next({ image: canvas.toDataURL(), width: width, height: height, time: time });
                        observer.complete();
                        subscription.unsubscribe();
                    });
                });
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnail =
            function (source, width, height, time) {
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                var /** @type {?} */ frameSubscription = this.getThumbnail(videoPlayer, canvas, time, width, height);
                // ensure we release memory after we are finished
                frameSubscription.subscribe(null, null, function () {
                    videoPlayer = null;
                    canvas = null;
                });
                return frameSubscription;
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnails =
            function (source, width, height, start, end, skip) {
                var _this = this;
                if (skip === void 0) {
                    skip = 5;
                }
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                return Observable.Observable.create(function (observer) {
                    fromEvent.fromEvent(videoPlayer, 'loadedmetadata').subscribe(function () {
                        // calculate the frames required
                        var /** @type {?} */ frames = [];
                        for (var /** @type {?} */ idx = start; idx < end; idx += skip) {
                            frames.push(_this.getThumbnail(videoPlayer, canvas, idx, width, height));
                        }
                        concat.concat.apply(void 0, __spread(frames)).subscribe(function (frame) { return observer.next(frame); }, null, function () {
                            videoPlayer = null;
                            canvas = null;
                            observer.complete();
                        });
                    });
                });
            };
        FrameExtractionService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        FrameExtractionService.ctorParameters = function () { return []; };
        return FrameExtractionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionModule = (function () {
        function FrameExtractionModule() {
        }
        FrameExtractionModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [FrameExtractionService],
                    },] },
        ];
        /** @nocollapse */
        FrameExtractionModule.ctorParameters = function () { return []; };
        return FrameExtractionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerService = (function () {
        function MediaPlayerService(_frameExtractionService) {
            var _this = this;
            this._frameExtractionService = _frameExtractionService;
            this.type = 'video';
            this.loaded = false;
            /*
                    Create observables for media player events
                */
            this.playing = new BehaviorSubject.BehaviorSubject(false);
            this.initEvent = new BehaviorSubject.BehaviorSubject(false);
            this.abortEvent = new Subject.Subject();
            this.canPlayEvent = new BehaviorSubject.BehaviorSubject(false);
            this.canPlayThroughEvent = new BehaviorSubject.BehaviorSubject(false);
            this.durationChangeEvent = new Subject.Subject();
            this.endedEvent = new Subject.Subject();
            this.errorEvent = new Subject.Subject();
            this.loadedDataEvent = new Subject.Subject();
            this.loadedMetadataEvent = new Subject.Subject();
            this.loadStartEvent = new Subject.Subject();
            this.pauseEvent = new Subject.Subject();
            this.playEvent = new Subject.Subject();
            this.playingEvent = new Subject.Subject();
            this.rateChangeEvent = new Subject.Subject();
            this.seekedEvent = new Subject.Subject();
            this.seekingEvent = new Subject.Subject();
            this.stalledEvent = new Subject.Subject();
            this.suspendEvent = new Subject.Subject();
            this.timeUpdateEvent = new Subject.Subject();
            this.volumeChangeEvent = new Subject.Subject();
            this.waitingEvent = new Subject.Subject();
            this.mediaClickEvent = new Subject.Subject();
            this.fullscreenEvent = new BehaviorSubject.BehaviorSubject(false);
            this.quietModeEvent = new BehaviorSubject.BehaviorSubject(false);
            this.progressEvent = Observable.Observable.create(function (observer) {
                // repeat until the whole video has fully loaded
                var /** @type {?} */ interval = setInterval(function () {
                    var /** @type {?} */ buffered = (_this._mediaPlayer.buffered);
                    observer.next(buffered);
                    if (buffered.length === 1 && buffered.start(0) === 0 && buffered.end(0) === _this.duration) {
                        observer.complete();
                        clearInterval(interval);
                    }
                }, 1000);
            });
            this._fullscreen = false;
        }
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayer", {
            /*
                Create all the getters and setters the can be used by media player extensions
            */
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this._quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // quiet mode cannot be enabled on audio player
                if (this.type === 'audio') {
                    value = false;
                }
                this._quietMode = value;
                this.quietModeEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetWidth : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetHeight : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "audioTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.audioTracks : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "autoplay", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.autoplay : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.autoplay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "buffered", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.buffered : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "crossOrigin", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.crossOrigin : null;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.crossOrigin = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentSrc", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentSrc : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentTime", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentTime : 0;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.currentTime = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultMuted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultMuted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultMuted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultPlaybackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultPlaybackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultPlaybackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "duration", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.duration : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "ended", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.ended : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "loop", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.loop : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "muted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.muted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.muted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "networkState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer.networkState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "paused", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.paused : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "playbackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.playbackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.playbackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "played", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.played : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "preload", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.preload : 'auto';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.preload = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "readyState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.readyState : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seekable", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seekable : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seeking", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seeking : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "src", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.src : '';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.src = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "textTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.textTracks : new TextTrackList();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "videoTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.videoTracks : new VideoTrackList();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.volume : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.volume = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "fullscreen", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._fullscreen : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._fullscreen = value;
                this.fullscreenEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
        MediaPlayerService.prototype.setMediaPlayer =
            function (hostElement, mediaPlayer) {
                this._hostElement = hostElement;
                this._mediaPlayer = mediaPlayer;
                this.initEvent.next(true);
            };
        /**
         * Toggle playing state
         */
        /**
         * Toggle playing state
         * @return {?}
         */
        MediaPlayerService.prototype.togglePlay =
            function () {
                // prevent any action is not loaded
                if (this.loaded === false) {
                    return;
                }
                if (this.paused) {
                    this.play();
                }
                else {
                    this.pause();
                }
            };
        /**
         * Starts playing the audio/video
         */
        /**
         * Starts playing the audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.play =
            function () {
                this._mediaPlayer.play();
            };
        /**
         * Pauses the currently playing audio/video
         */
        /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.pause =
            function () {
                this._mediaPlayer.pause();
            };
        /**
         * Re-loads the audio/video element
         */
        /**
         * Re-loads the audio/video element
         * @return {?}
         */
        MediaPlayerService.prototype.load =
            function () {
                this._mediaPlayer.load();
            };
        /**
         * Checks if the browser can play the specified audio/video type
         */
        /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
        MediaPlayerService.prototype.canPlayType =
            function (type) {
                return this._mediaPlayer.canPlayType(type);
            };
        /**
         * Adds a new text track to the audio/video
         */
        /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
        MediaPlayerService.prototype.addTextTrack =
            function (kind, label, language) {
                return this._mediaPlayer.addTextTrack(kind, label, language);
            };
        /**
         * Attempt to display media in fullscreen mode
         */
        /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
        MediaPlayerService.prototype.requestFullscreen =
            function () {
                if (this._hostElement.requestFullscreen) {
                    this._hostElement.requestFullscreen();
                }
                else if (this._hostElement.webkitRequestFullscreen) {
                    this._hostElement.webkitRequestFullscreen();
                }
                else if (((this._hostElement)).msRequestFullscreen) {
                    ((this._hostElement)).msRequestFullscreen();
                }
                else if (((this._hostElement)).mozRequestFullScreen) {
                    ((this._hostElement)).mozRequestFullScreen();
                }
            };
        /**
         * Exit full screen mode
         */
        /**
         * Exit full screen mode
         * @return {?}
         */
        MediaPlayerService.prototype.exitFullscreen =
            function () {
                if (((this._hostElement)).exitFullscreen) {
                    document.exitFullscreen();
                }
                else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                else if (((document)).msExitFullscreen) {
                    ((document)).msExitFullscreen();
                }
                else if (((document)).mozCancelFullScreen) {
                    ((document)).mozCancelFullScreen();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerService.prototype.fullscreenChange =
            function (event) {
                this.fullscreen = ((document)).fullscreen || document.webkitIsFullScreen || ((document)).mozFullScreen || ((document)).msFullscreenElement !== null && ((document)).msFullscreenElement !== undefined;
                this.fullscreenEvent.next(this.fullscreen);
            };
        /**
         * Toggle Fullscreen State
         */
        /**
         * Toggle Fullscreen State
         * @return {?}
         */
        MediaPlayerService.prototype.toggleFullscreen =
            function () {
                if (this.fullscreen) {
                    this.exitFullscreen();
                }
                else {
                    this.requestFullscreen();
                }
            };
        /**
         * Extract the frames from the video
         */
        /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
        MediaPlayerService.prototype.getFrames =
            function (width, height, skip) {
                if (this.type === 'video') {
                    return this._frameExtractionService.getFrameThumbnails(this.source, width, height, 0, this.duration, 10);
                }
                return from.from([]);
            };
        MediaPlayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MediaPlayerService.ctorParameters = function () {
            return [
                { type: FrameExtractionService, },
            ];
        };
        return MediaPlayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerComponent = (function () {
        function MediaPlayerComponent(mediaPlayerService, _audioService, _elementRef) {
            var _this = this;
            this.mediaPlayerService = mediaPlayerService;
            this._audioService = _audioService;
            this._elementRef = _elementRef;
            this.hovering = false;
            this._onDestroy = new Subject.Subject();
            // show controls when hovering and in quiet mode
            fromEvent.fromEvent(this._elementRef.nativeElement, 'mousemove').pipe(operators.switchMap(function (event) {
                _this.hovering = true;
                return of.of(event);
            }), operators.debounceTime(2000), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.hovering = false; });
        }
        Object.defineProperty(MediaPlayerComponent.prototype, "source", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.source;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.type;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.type = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.quietMode = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                this.mediaPlayerService.setMediaPlayer(this._elementRef.nativeElement, this._playerRef.nativeElement);
                this.audioMetadata = this._audioService.getAudioFileMetadata(this._playerRef.nativeElement);
                this.mediaPlayerService.playingEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(true); });
                this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(false); });
                this.mediaPlayerService.mediaClickEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.togglePlay(); });
                this.mediaPlayerService.loadedMetadataEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.loaded = true; });
            };
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        MediaPlayerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player',
                        template: "<div class=\"video-player-container\" *ngIf=\"type === 'video'\">\n\n    <video class=\"video-player\"\n        #player\n        [src]=\"source\"\n        (abort)=\"mediaPlayerService.abortEvent.next()\"\n        (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n        (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n        (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n        (ended)=\"mediaPlayerService.endedEvent.next()\"\n        (error)=\"mediaPlayerService.errorEvent.next($event)\"\n        (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n        (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n        (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n        (pause)=\"mediaPlayerService.pauseEvent.next()\"\n        (play)=\"mediaPlayerService.playEvent.next()\"\n        (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n        (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n        (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n        (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n        (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n        (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n        (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n        (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n        (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n        (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n    </video>\n\n    <div class=\"video-overlay\" [class.playing]=\"mediaPlayerService.playing | async\">\n        <svg class=\"play-graphic\" x=\"0px\" y=\"0px\" viewBox=\"0 0 64 64\">\n            <circle class=\"play-circle\" cx=\"32.2\" cy=\"31.8\" r=\"31.8\" />\n            <polygon class=\"play-triangle\" points=\"23,14.1 23,50.8 48.3,32.5\" />\n        </svg>\n    </div>\n\n</div>\n\n\n<div class=\"audio-player\" *ngIf=\"type === 'audio'\">\n\n    <svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n        <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n            <g transform=\"translate(-98.000000, -458.000000)\">\n                <g transform=\"translate(98.000000, 458.000000)\">\n                    <path d=\"M4.5,0.5 L18.0435308,0.5 L23.5,6.22251502 L23.5,23.5 L4.5,23.5 L4.5,0.5 Z\" fill=\"#CCEAE2\"></path>\n                    <path d=\"M4.5,8 L4.5,0.5 L18,0.5 L23.5,6 L23.5,23.5 L18,23.5\" stroke=\"#60798D\" fill=\"#CCEAE2\"></path>\n                    <path d=\"M4,13.5 L0.5,13.5 L0.5,18.5 L4,18.5 L9.5,22.5 L9.5,9.5 L4,13.5 Z\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                    <path d=\"M11.5,12.5137939 C13.7576225,12.5137939 14.5,14.3709236 14.5,16 C14.5,17.6849236 13.7089152,19.5420532 11.5,19.5420532\"\n                        stroke=\"#60798D\"></path>\n                    <path d=\"M11.5,9 C15.8037643,9.04168701 18.5,11.6604805 18.5,16 C18.5,20.3395195 15.8804302,23.0079956 11.5,23\" stroke=\"#60798D\"></path>\n                    <path d=\"M17.5219116,0.761413574 L17.5219116,6 L23,6\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                </g>\n            </g>\n        </g>\n    </svg>\n\n    <p class=\"audio-file-name\">{{ (audioMetadata | async)?.filename }}</p>\n    <p class=\"audio-file-format\">{{ (audioMetadata | async)?.description }}</p>\n    <p class=\"audio-file-size\">{{ (audioMetadata | async)?.size | fileSize }}</p>\n\n    <audio #player\n        [src]=\"source\"\n        (abort)=\"mediaPlayerService.abortEvent.next()\"\n        (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n        (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n        (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n        (ended)=\"mediaPlayerService.endedEvent.next()\"\n        (error)=\"mediaPlayerService.errorEvent.next($event)\"\n        (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n        (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n        (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n        (pause)=\"mediaPlayerService.pauseEvent.next()\"\n        (play)=\"mediaPlayerService.playEvent.next()\"\n        (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n        (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n        (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n        (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n        (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n        (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n        (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n        (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n        (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n        (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n    </audio>\n</div>\n\n<div class=\"control-bar\">\n    <ux-media-player-timeline></ux-media-player-timeline>\n    <ux-media-player-controls></ux-media-player-controls>\n</div>",
                        providers: [MediaPlayerService],
                        host: {
                            'tabindex': '0',
                            '(keydown.Space)': 'mediaPlayerService.togglePlay()',
                            '[class.standard]': '!mediaPlayerService.fullscreen',
                            '[class.fullscreen]': 'mediaPlayerService.fullscreen',
                            '[class.quiet]': 'quietMode && type === "video" || mediaPlayerService.fullscreen',
                            '[class.hover]': 'hovering',
                            '[class.video]': 'type === "video"',
                            '[class.audio]': 'type === "audio"',
                            '(mouseenter)': 'hovering = true',
                            '(mouseleave)': 'hovering = false',
                            '(document:webkitfullscreenchange)': 'mediaPlayerService.fullscreenChange($event)',
                            '(document:mozfullscreenchange)': 'mediaPlayerService.fullscreenChange($event)',
                            '(document:MSFullscreenChange)': 'mediaPlayerService.fullscreenChange($event)'
                        }
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerComponent.ctorParameters = function () {
            return [
                { type: MediaPlayerService, },
                { type: AudioService, },
                { type: core.ElementRef, },
            ];
        };
        MediaPlayerComponent.propDecorators = {
            "_playerRef": [{ type: core.ViewChild, args: ['player',] },],
            "source": [{ type: core.Input },],
            "type": [{ type: core.Input },],
            "quietMode": [{ type: core.Input },],
        };
        return MediaPlayerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerBaseExtensionDirective = (function () {
        function MediaPlayerBaseExtensionDirective(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
        }
        MediaPlayerBaseExtensionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mediaPlayerBaseExtension]'
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerBaseExtensionDirective.ctorParameters = function () {
            return [
                { type: MediaPlayerService, },
            ];
        };
        return MediaPlayerBaseExtensionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerTimelineExtensionComponent = (function (_super) {
        __extends(MediaPlayerTimelineExtensionComponent, _super);
        function MediaPlayerTimelineExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.current = 0;
            _this.position = 0;
            _this.duration = 0;
            _this.buffered = [];
            _this.mouseDown = false;
            _this.quietMode = false;
            _this.fullscreen = false;
            _this.scrub = { visible: false, position: 0, time: 0 };
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                // watch for changes to the current time
                this.mediaPlayerService.durationChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (duration) { return _this.duration = duration; });
                this.mediaPlayerService.quietModeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (quietMode) { return _this.quietMode = quietMode; });
                this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) {
                    _this.fullscreen = fullscreen;
                    _this.scrub.position = 0;
                });
                this.mediaPlayerService.timeUpdateEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (current) {
                    _this.current = current;
                    _this.position = (_this.current / _this.duration) * 100;
                });
                this.mediaPlayerService.progressEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (buffered) {
                    _this.buffered = [];
                    for (var /** @type {?} */ idx = 0; idx < buffered.length; idx++) {
                        _this.buffered.push({ start: (buffered.start(idx) / _this.duration) * 100, end: (buffered.end(idx) / _this.duration) * 100 });
                    }
                });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                var /** @type {?} */ mousedown$ = fromEvent.fromEvent(this.thumb.nativeElement, 'mousedown');
                var /** @type {?} */ mousemove$ = fromEvent.fromEvent(document, 'mousemove');
                var /** @type {?} */ mouseup$ = fromEvent.fromEvent(document, 'mouseup');
                mousedown$.pipe(operators.switchMap(function () { return mousemove$.pipe(operators.takeUntil(mouseup$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.scrub.visible = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.updateScrub =
            function (event) {
                var /** @type {?} */ target = (event.target);
                if (target.classList.contains('media-progress-bar-thumb')) {
                    return;
                }
                var /** @type {?} */ timeline = (this.timelineRef.nativeElement);
                var /** @type {?} */ bounds = timeline.getBoundingClientRect();
                this.scrub.position = event.offsetX;
                this.scrub.time = (event.offsetX / bounds.width) * this.mediaPlayerService.duration;
                if (this.mouseDown) {
                    this.mediaPlayerService.pause();
                    this.mediaPlayerService.currentTime = this.scrub.time;
                }
            };
        MediaPlayerTimelineExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-timeline',
                        template: "<p class=\"current-time\">{{ current | duration }}</p>\n\n<div #timeline class=\"timeline-bar\" (mouseenter)=\"scrub.visible = true; pop.show()\" (mouseleave)=\"scrub.visible = false; pop.hide()\"\n    (mousemove)=\"updateScrub($event)\" (mouseup)=\"updateScrub($event)\" (mousedown)=\"mouseDown = true; $event.preventDefault()\">\n\n    <div class=\"buffered-bar\" *ngFor=\"let buffer of buffered\" [style.left.%]=\"buffer.start\" [style.width.%]=\"buffer.end - buffer.start\"></div>\n\n    <div class=\"media-progress-bar\" [style.width.%]=\"position\">\n        <div #progressThumb class=\"media-progress-bar-thumb\" (mouseenter)=\"scrub.visible = false; pop.hide(); $event.stopPropagation()\"\n            (mouseleave)=\"scrub.visible = true; pop.show(); $event.stopPropagation()\"></div>\n    </div>\n\n    <div class=\"scrub-handle\"\n         [class.scrub-handle-hidden]=\"!scrub.visible\"\n         [style.left.px]=\"scrub.position\"\n         [uxTooltip]=\"popTemplate\"\n         placement=\"top\"\n         [showTriggers]=\"[]\"\n         [hideTriggers]=\"[]\"\n         #pop=\"ux-tooltip\"\n         [tooltipDelay]=\"100\"\n         [tooltipDisabled]=\"duration === 0\"></div>\n</div>\n\n<p class=\"duration-time\">{{ duration | duration }}</p>\n\n<ng-template #popTemplate>\n    <span>{{ scrub.time | duration }}</span>\n</ng-template>",
                        host: {
                            '(document:mouseup)': 'mouseDown = false',
                            '[class.quiet]': 'quietMode || fullscreen'
                        }
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerTimelineExtensionComponent.ctorParameters = function () { return []; };
        MediaPlayerTimelineExtensionComponent.propDecorators = {
            "thumb": [{ type: core.ViewChild, args: ['progressThumb',] },],
            "timelineRef": [{ type: core.ViewChild, args: ['timeline',] },],
        };
        return MediaPlayerTimelineExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerControlsExtensionComponent = (function (_super) {
        __extends(MediaPlayerControlsExtensionComponent, _super);
        function MediaPlayerControlsExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.fullscreen = false;
            _this.volumeActive = false;
            _this.volumeDragging = false;
            _this._volume = 50;
            _this._previousVolume = 50;
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        Object.defineProperty(MediaPlayerControlsExtensionComponent.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._volume;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === 0 && this._volume !== 0) {
                    this._previousVolume = this._volume;
                }
                this._volume = Math.min(Math.max(value, 0), 100);
                this.mediaPlayerService.volume = this._volume / 100;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this.mediaPlayerService.playEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.playing = true; });
                this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.playing = false; });
                this.mediaPlayerService.quietModeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (quietMode) { return _this.quietMode = quietMode; });
                this.mediaPlayerService.volumeChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (volume) { return _this.volume = volume * 100; });
                this.mediaPlayerService.initEvent.pipe(operators.debounceTime(1), operators.filter(function (init) { return init === true; }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volume = _this.mediaPlayerService.volume * 100; });
                this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) { return _this.fullscreen = fullscreen; });
                var /** @type {?} */ mouseenter$ = fromEvent.fromEvent(this.volumeIcon.nativeElement, 'mouseenter');
                var /** @type {?} */ mouseenterContainer$ = fromEvent.fromEvent(this.volumeContainer.nativeElement, 'mouseenter');
                var /** @type {?} */ mouseleaveContainer$ = fromEvent.fromEvent(this.volumeContainer.nativeElement, 'mouseleave');
                mouseenter$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = true; });
                mouseleaveContainer$.pipe(operators.switchMap(function () { return timer.timer(1500).pipe(operators.takeUntil(mouseenterContainer$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.toggleMute =
            function () {
                if (this.volume === 0) {
                    this.volume = this._previousVolume;
                }
                else {
                    this.volume = 0;
                }
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.togglePlay =
            function () {
                if (this.playing) {
                    this.mediaPlayerService.pause();
                }
                else {
                    this.mediaPlayerService.play();
                }
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.setFullscreen =
            function () {
                this.mediaPlayerService.toggleFullscreen();
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToStart =
            function () {
                this.mediaPlayerService.currentTime = 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToEnd =
            function () {
                this.mediaPlayerService.currentTime = this.mediaPlayerService.duration;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.dragStart =
            function (event) {
                event.preventDefault();
                this.volumeDragging = true;
                var /** @type {?} */ thumb = (event.target);
                thumb.focus();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.dragMove =
            function (event) {
                if (!this.volumeDragging) {
                    return;
                }
                event.preventDefault();
                var /** @type {?} */ slider = (this.volumeSlider.nativeElement);
                var /** @type {?} */ bounds = slider.getBoundingClientRect();
                var /** @type {?} */ x = Math.min(bounds.width, Math.max(0, event.pageX - bounds.left));
                // convert to a percentage
                this.volume = (x / bounds.width) * 100;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.dragEnd =
            function () {
                this.volumeDragging = false;
            };
        MediaPlayerControlsExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-controls',
                        template: "<div class=\"volume-container\">\n\n    <div class=\"volume-slider-container\" #volumeContainer [class.active]=\"volumeActive\">\n        <div class=\"volume-slider-icon\" #volumeIcon>\n            <span class=\"hpe-icon\" [class.hpe-volume-mute]=\"volume === 0\" [class.hpe-volume-low]=\"volume > 0 && volume <= 70\" [class.hpe-volume]=\"volume > 70\" [uxTooltip]=\"muteTooltip\" (click)=\"toggleMute()\"></span>\n        </div>\n        \n        <div class=\"volume-slider-node\">\n            <div class=\"volume-slider\" #volumeSlider>\n                <div class=\"volume-track-lower\" [style.width.%]=\"volume\"></div>\n                <div class=\"volume-slider-thumb\" (mousedown)=\"dragStart($event)\" [style.left.%]=\"volume\" tabindex=\"0\" (keydown.ArrowRight)=\"volume = volume + 10\" (keydown.ArrowLeft)=\"volume = volume - 10\"></div>\n            </div>\n        </div>\n    </div>\n</div>\n\n<div class=\"spacer\"></div>\n\n<svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" class=\"control-button\" (click)=\"goToStart()\">\n    <rect x=\"0\" y=\"0\" width=\"7.5\" height=\"64\" />\n    <polygon points=\"51.5,64 51.5,0 7.4,32 \" />\n</svg>\n\n<svg viewBox=\"0 0 45 64\" width=\"20\" height=\"29\" class=\"control-button\" *ngIf=\"!playing\" (click)=\"togglePlay()\">\n    <polygon points=\"0.4,0 0.4,64 44.6,32\" />\n</svg>\n\n<svg viewBox=\"0 0 43 56.9\" class=\"control-button\" width=\"20\" height=\"29\" *ngIf=\"playing\" (click)=\"togglePlay()\">\n    <rect y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n    <rect x=\"27.3\" y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n</svg>\n\n<svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" class=\"control-button\" (click)=\"goToEnd()\">\n    <rect x=\"44.1\" y=\"0\" width=\"7.5\" height=\"64\" />\n    <polygon points=\"0,64 0,0 44.1,32 \" />\n</svg>\n\n<div class=\"spacer\"></div>\n\n<span class=\"hpe-icon\" *ngIf=\"mediaPlayerService.type !== 'audio'\" [class.hpe-expand]=\"!mediaPlayerService.fullscreen\" [class.hpe-contract]=\"mediaPlayerService.fullscreen\"\n    (click)=\"setFullscreen()\"></span>\n\n<ng-template #muteTooltip>{{ volume === 0 ? 'Unmute' : 'Mute' }}</ng-template>",
                        host: {
                            '[class.quiet]': 'quietMode || fullscreen'
                        }
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerControlsExtensionComponent.ctorParameters = function () { return []; };
        MediaPlayerControlsExtensionComponent.propDecorators = {
            "volumeIcon": [{ type: core.ViewChild, args: ['volumeIcon',] },],
            "volumeSlider": [{ type: core.ViewChild, args: ['volumeSlider',] },],
            "volumeContainer": [{ type: core.ViewChild, args: ['volumeContainer',] },],
            "dragMove": [{ type: core.HostListener, args: ['document:mousemove', ['$event'],] },],
            "dragEnd": [{ type: core.HostListener, args: ['document:mouseup',] },],
        };
        return MediaPlayerControlsExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipe = (function () {
        function DurationPipe() {
        }
        /**
         * @param {?} seconds
         * @return {?}
         */
        DurationPipe.prototype.transform =
            function (seconds) {
                var /** @type {?} */ minutes = Math.floor(seconds / 60);
                var /** @type {?} */ hours = Math.floor(minutes / 60);
                var /** @type {?} */ days = Math.floor(hours / 24);
                hours = hours - (days * 24);
                minutes = minutes - (days * 24 * 60) - (hours * 60);
                seconds = Math.floor(seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60));
                if (hours > 0) {
                    return this.pad(hours) + ":" + this.pad(minutes) + ":" + this.pad(seconds);
                }
                else {
                    return this.pad(minutes) + ":" + this.pad(seconds);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        DurationPipe.prototype.pad =
            function (value) {
                if (value < 10) {
                    return "0" + value;
                }
                return value.toString();
            };
        DurationPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'duration'
                    },] },
        ];
        /** @nocollapse */
        DurationPipe.ctorParameters = function () { return []; };
        return DurationPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipeModule = (function () {
        function DurationPipeModule() {
        }
        DurationPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DurationPipe],
                        declarations: [DurationPipe]
                    },] },
        ];
        /** @nocollapse */
        DurationPipeModule.ctorParameters = function () { return []; };
        return DurationPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipe = (function () {
        function FileSizePipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        FileSizePipe.prototype.transform =
            function (value) {
                // allow for async values
                if (!value) {
                    return value;
                }
                var /** @type {?} */ units = ['B', 'KB', 'MB', 'GB', 'TB'];
                // calculate the which unit bracket the values should be a part of
                var /** @type {?} */ idx = Math.floor(Math.log(value) / Math.log(1024));
                var /** @type {?} */ formattedValue = value / Math.pow(1024, idx);
                return formattedValue.toFixed(2) + " " + units[idx];
            };
        FileSizePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'fileSize'
                    },] },
        ];
        /** @nocollapse */
        FileSizePipe.ctorParameters = function () { return []; };
        return FileSizePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipeModule = (function () {
        function FileSizePipeModule() {
        }
        FileSizePipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FileSizePipe],
                        declarations: [FileSizePipe]
                    },] },
        ];
        /** @nocollapse */
        FileSizePipeModule.ctorParameters = function () { return []; };
        return FileSizePipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$5 = [
        MediaPlayerComponent,
        MediaPlayerTimelineExtensionComponent,
        MediaPlayerBaseExtensionDirective,
        MediaPlayerControlsExtensionComponent
    ];
    var MediaPlayerModule = (function () {
        function MediaPlayerModule() {
        }
        MediaPlayerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            FrameExtractionModule,
                            TooltipModule,
                            AudioServiceModule,
                            DurationPipeModule,
                            FileSizePipeModule
                        ],
                        exports: DECLARATIONS$5,
                        declarations: DECLARATIONS$5,
                        providers: [MediaPlayerService]
                    },] },
        ];
        /** @nocollapse */
        MediaPlayerModule.ctorParameters = function () { return []; };
        return MediaPlayerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationComponent = (function () {
        function NavigationComponent() {
        }
        NavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-navigation',
                        template: "<nav class=\"tree\" role=\"navigation\">\n    <ol class=\"nav\">\n        <ng-content></ng-content>\n    </ol>\n</nav>\n"
                    },] },
        ];
        /** @nocollapse */
        NavigationComponent.ctorParameters = function () { return []; };
        return NavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationItemComponent = (function () {
        function NavigationItemComponent(_elementRef, _renderer, _parent, _router, _activatedRoute) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._parent = _parent;
            this._router = _router;
            this._activatedRoute = _activatedRoute;
            this.expanded = false;
            this.level = 1;
            this.indentWithoutArrow = true;
            this.level = _parent ? _parent.level + 1 : 1;
            this._navigationEnd = _router.events.pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }))
                .subscribe(function () { return _this.expanded = _this.hasActiveLink(_this.link); });
        }
        Object.defineProperty(NavigationItemComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                if (this.link) {
                    return this._router.isActive(this.link, true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationItemComponent.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                var _this = this;
                return this._children.filter(function (item) { return item !== _this; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterViewInit =
            function () {
                // Add classes to parent for styling
                var /** @type {?} */ parentListElement = this._elementRef.nativeElement.parentElement;
                if (parentListElement) {
                    var /** @type {?} */ levelClass = this.getLevelClass();
                    if (levelClass.length > 0) {
                        this._renderer.addClass(parentListElement, 'nav');
                        this._renderer.addClass(parentListElement, levelClass);
                    }
                }
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // Set 'indentWithoutArrow'
                this.setIndentWithoutArrow();
                // Update 'indentWithoutArrow' in response to changes to children
                this._childrenChanges = this._children.changes.subscribe(function () { return _this.setIndentWithoutArrow(); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngOnDestroy =
            function () {
                this._navigationEnd.unsubscribe();
                this._childrenChanges.unsubscribe();
            };
        /**
         * @param {?} link
         * @return {?}
         */
        NavigationItemComponent.prototype.hasActiveLink =
            function (link) {
                var /** @type {?} */ tree = this._router.createUrlTree([link], {
                    relativeTo: this._activatedRoute,
                    queryParams: this._activatedRoute.snapshot.queryParams,
                    fragment: this._activatedRoute.snapshot.fragment
                });
                if (link && this._router.isActive(tree, true)) {
                    return true;
                }
                // If this component has children, check if any of them, or their descendants, are active.
                return this.children.some(function (item) { return item.hasActiveLink(item.link); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.getLevelClass =
            function () {
                switch (this.level) {
                    case 2:
                        return 'nav-second-level';
                    case 3:
                        return 'nav-third-level';
                    case 4:
                        return 'nav-fourth-level';
                    case 5:
                        return 'nav-fifth-level';
                }
                return '';
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.setIndentWithoutArrow =
            function () {
                if (this.children.length > 0) {
                    // If this element has children it will be indented and will have an arrow
                    this.indentWithoutArrow = false;
                }
                else if (this._parent) {
                    // If this element has a parent, indent it if any of its siblings have children
                    this.indentWithoutArrow = !this._parent.children.every(function (item) { return item.children.length === 0; });
                }
                else {
                    // Top-level elements should be indented
                    this.indentWithoutArrow = true;
                }
            };
        NavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: '[ux-navigation-item]',
                        template: "<a *ngIf=\"link\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\" [routerLink]=\"link\">\n    <span>{{header}}</span>\n</a>\n<a *ngIf=\"!link\" (click)=\"expanded = !expanded\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\">\n    <span>{{header}}</span>\n</a>\n<ng-content></ng-content>\n",
                    },] },
        ];
        /** @nocollapse */
        NavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
                { type: NavigationItemComponent, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
                { type: router.Router, },
                { type: router.ActivatedRoute, },
            ];
        };
        NavigationItemComponent.propDecorators = {
            "header": [{ type: core.Input },],
            "icon": [{ type: core.Input },],
            "link": [{ type: core.Input },],
            "expanded": [{ type: core.Input }, { type: core.HostBinding, args: ['class.selected',] },],
            "active": [{ type: core.HostBinding, args: ['class.active',] },],
            "_children": [{ type: core.ContentChildren, args: [NavigationItemComponent, { descendants: true },] },],
        };
        return NavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationModule = (function () {
        function NavigationModule() {
        }
        NavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [
                            NavigationComponent,
                            NavigationItemComponent
                        ],
                        declarations: [
                            NavigationComponent,
                            NavigationItemComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        NavigationModule.ctorParameters = function () { return []; };
        return NavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorService = (function () {
        function ColorService() {
            this._colorSet = colorSets.keppel;
            if (this._colorSet.colorClassSet) {
                this.setColors();
            }
            else {
                for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                    this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                }
            }
        }
        /**
         * @return {?}
         */
        ColorService.prototype.setColors =
            function () {
                this._html = '';
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._html += '<div class="' + this._colorSet.colorClassSet[key] + '-color"></div>';
                }
                this._element = document.createElement('div');
                this._element.className = 'color-chart';
                this._element.innerHTML = this._html;
                document.body.appendChild(this._element);
                this._colors = {};
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._colors[key] = this.getColorValue(this._colorSet.colorClassSet[key]);
                }
                this._element.parentNode.removeChild(this._element);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValueByHex =
            function (color) {
                var /** @type {?} */ hex = color.replace('#', '');
                var /** @type {?} */ r = parseInt(hex.substring(0, 2), 16).toString();
                var /** @type {?} */ g = parseInt(hex.substring(2, 4), 16).toString();
                var /** @type {?} */ b = parseInt(hex.substring(4, 6), 16).toString();
                return new ThemeColor(r, g, b, '1');
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValue =
            function (color) {
                var /** @type {?} */ target = this._element.querySelector('.' + this._colorSet.colorClassSet[color] + '-color');
                if (!target) {
                    throw new Error('Invalid color');
                }
                var /** @type {?} */ colorValue = window.getComputedStyle(target).backgroundColor;
                var /** @type {?} */ rgba = colorValue.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
                return new ThemeColor(rgba[1], rgba[2], rgba[3], rgba[4]);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColor =
            function (color) {
                var /** @type {?} */ themeColor = this._colors[this.resolveColorName(color)];
                if (!themeColor) {
                    throw new Error('Color not found: ' + color);
                }
                return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
            };
        /**
         * @return {?}
         */
        ColorService.prototype.getColorSet =
            function () {
                return this._colorSet;
            };
        /**
         * @param {?} colorSet
         * @return {?}
         */
        ColorService.prototype.setColorSet =
            function (colorSet) {
                this._colorSet = colorSet;
                this._colors = {};
                if (this._colorSet.colorClassSet) {
                    this.setColors();
                }
                else {
                    for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                        this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                    }
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ColorService.prototype.resolve =
            function (value) {
                if (!value) {
                    return;
                }
                var /** @type {?} */ colorName = this.resolveColorName(value);
                for (var /** @type {?} */ color in this._colors) {
                    if (colorName === color.toLowerCase()) {
                        return this.getColor(colorName).toRgba();
                    }
                }
                return value;
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        ColorService.prototype.resolveColorName =
            function (value) {
                if (value === void 0) {
                    value = '';
                }
                return value.replace(/\s+/g, '-').toLowerCase();
            };
        ColorService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ColorService.ctorParameters = function () { return []; };
        return ColorService;
    }());
    var ThemeColor = (function () {
        function ThemeColor(r, g, b, a) {
            this._r = r;
            this._g = g;
            this._b = b;
            this._a = a === undefined ? '1' : a;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ThemeColor.parse =
            function (value) {
                var /** @type {?} */ r, /** @type {?} */ g, /** @type {?} */ b, /** @type {?} */ a = '1';
                var /** @type {?} */ rgbaPattern = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
                var /** @type {?} */ shortHexPattern = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                var /** @type {?} */ longHexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/;
                var /** @type {?} */ rgbaMatch = value.match(rgbaPattern);
                var /** @type {?} */ shortHexMatch = value.match(shortHexPattern);
                var /** @type {?} */ longHexMatch = value.match(longHexPattern);
                if (rgbaMatch) {
                    r = rgbaMatch[1];
                    g = rgbaMatch[2];
                    b = rgbaMatch[3];
                    a = rgbaMatch[4] ? rgbaMatch[4] : '1';
                }
                else if (longHexMatch) {
                    r = parseInt(longHexMatch[1], 16).toString();
                    g = parseInt(longHexMatch[2], 16).toString();
                    b = parseInt(longHexMatch[3], 16).toString();
                }
                else if (shortHexMatch) {
                    r = parseInt(shortHexMatch[1] + shortHexMatch[1], 16).toString();
                    g = parseInt(shortHexMatch[2] + shortHexMatch[2], 16).toString();
                    b = parseInt(shortHexMatch[3] + shortHexMatch[3], 16).toString();
                }
                else {
                    throw new Error("Cannot parse color - " + value + " is not a valid color.");
                }
                return new ThemeColor(r, g, b, a);
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toHex =
            function () {
                var /** @type {?} */ red = parseInt(this._r).toString(16);
                var /** @type {?} */ green = parseInt(this._g).toString(16);
                var /** @type {?} */ blue = parseInt(this._b).toString(16);
                if (red.length < 2) {
                    red = '0' + red;
                }
                if (green.length < 2) {
                    green = '0' + green;
                }
                if (blue.length < 2) {
                    blue = '0' + blue;
                }
                return '#' + red + green + blue;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgb =
            function () {
                return 'rgb(' + this._r + ', ' + this._g + ', ' + this._b + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgba =
            function () {
                return 'rgba(' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getRed =
            function () {
                return this._r;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getGreen =
            function () {
                return this._g;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getBlue =
            function () {
                return this._b;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getAlpha =
            function () {
                return this._a;
            };
        /**
         * @param {?} red
         * @return {?}
         */
        ThemeColor.prototype.setRed =
            function (red) {
                this._r = red;
                return this;
            };
        /**
         * @param {?} green
         * @return {?}
         */
        ThemeColor.prototype.setGreen =
            function (green) {
                this._g = green;
                return this;
            };
        /**
         * @param {?} blue
         * @return {?}
         */
        ThemeColor.prototype.setBlue =
            function (blue) {
                this._b = blue;
                return this;
            };
        /**
         * @param {?} alpha
         * @return {?}
         */
        ThemeColor.prototype.setAlpha =
            function (alpha) {
                this._a = alpha.toString();
                return this;
            };
        return ThemeColor;
    }());
    var /** @type {?} */ colorSets = {
        keppel: {
            colorClassSet: {
                'primary': 'primary',
                'accent': 'accent',
                'secondary': 'secondary',
                'alternate1': 'alternate1',
                'alternate2': 'alternate2',
                'alternate3': 'alternate3',
                'vibrant1': 'vibrant1',
                'vibrant2': 'vibrant2',
                'grey1': 'grey1',
                'grey2': 'grey2',
                'grey3': 'grey3',
                'grey4': 'grey4',
                'grey5': 'grey5',
                'grey6': 'grey6',
                'grey7': 'grey7',
                'grey8': 'grey8',
                'chart1': 'chart1',
                'chart2': 'chart2',
                'chart3': 'chart3',
                'chart4': 'chart4',
                'chart5': 'chart5',
                'chart6': 'chart6',
                'ok': 'ok',
                'warning': 'warning',
                'critical': 'critical',
                'partition1': 'partition1',
                'partition9': 'partition9',
                'partition10': 'partition10',
                'partition11': 'partition11',
                'partition12': 'partition12',
                'partition13': 'partition13',
                'partition14': 'partition14',
                'social-chart-node': 'social-chart-node',
                'social-chart-edge': 'social-chart-edge'
            }
        },
        microFocus: {
            'colorValueSet': {
                'cerulean': '#1668c1',
                'aqua': '#29ceff',
                'aquamarine': '#2fd6c3',
                'fuchsia': '#c6179d',
                'indigo': '#7425ad',
                'dark-blue': '#231ca5',
                'white': '#ffffff',
                'slightly-gray': '#f5f7f8',
                'bright-gray': '#f1f2f3',
                'gray': '#dcdedf',
                'silver': '#bdbec0',
                'dim-gray': '#656668',
                'dark-gray': '#323435',
                'black': '#000000',
                'crimson-negative': '#e5004c',
                'apricot': '#f48b34',
                'yellow': '#fcdb1f',
                'green-positive': '#1aac60',
                'ultramarine': '#3939c6',
                'skyblue': '#00abf3',
                'pale-aqua': '#43e4ff',
                'pale-green': '#1ffbba',
                'lime': '#75da4d',
                'orange': '#ffce00',
                'magenta': '#eb23c2',
                'pale-purple': '#ba47e2',
                'dark-ultramarine': '#271782',
                'steelblue': '#014272',
                'arctic-blue': '#0b8eac',
                'emerald': '#00a989',
                'olive': '#5bba36',
                'goldenrod': '#ffb000',
                'purple': '#9b1e83',
                'pale-eggplant': '#5216ac',
                'red': '#ff454f',
                'pale-amber': '#ffb24d',
                'pale-lemon': '#fde159',
                'pale-emerald': '#33c180',
                'plum': '#b21646',
                'copper': '#e57828',
                'amber': '#ffc002',
                'leaf-green': '#118c4f',
                'forest-green': '#00645a',
                'primary': '#0073e7',
                'accent': '#7425ad',
                'secondary': '#ffffff',
                'alternate1': '#29ceff',
                'alternate2': '#2fd6c3',
                'alternate3': '#c6179d',
                'vibrant1': '#43e4ff',
                'vibrant2': '#ffce00',
                'grey1': '#000000',
                'grey2': '#323435',
                'grey3': '#656668',
                'grey4': '#bdbec0',
                'grey5': '#dcdedf',
                'grey6': '#f1f2f3',
                'grey7': '#f5f7f8',
                'grey8': '#ffffff',
                'chart1': '#3939c6',
                'chart2': '#00abf3',
                'chart3': '#75da4d',
                'chart4': '#ffce00',
                'chart5': '#eb23c2',
                'chart6': '#ba47e2',
                'ok': '#1aac60',
                'warning': '#f48b34',
                'critical': 'e5004c',
                'partition1': '#7425ad',
                'partition9': '#5216ac',
                'partition10': '#5bba36',
                'partition11': '#014272',
                'partition12': '#ffb000',
                'partition13': '#bdbec0',
                'partition14': '#271782',
                'social-chart-node': '#ff00ff',
                'social-chart-edge': '#ff00ff'
            }
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorServiceModule = (function () {
        function ColorServiceModule() {
        }
        ColorServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [ColorService],
                    },] },
        ];
        /** @nocollapse */
        ColorServiceModule.ctorParameters = function () { return []; };
        return ColorServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationService = (function () {
        function NotificationService(_colorService) {
            this._colorService = _colorService;
            // provide default options
            this.options = {
                duration: 4,
                height: 100,
                spacing: 10,
                backgroundColor: this._colorService.getColor('accent').toHex(),
                iconColor: this._colorService.getColor('accent').toHex()
            };
            this.direction = 'above';
            this.notifications$ = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} templateRef
         * @param {?=} options
         * @param {?=} data
         * @return {?}
         */
        NotificationService.prototype.show =
            function (templateRef, options, data) {
                var _this = this;
                if (options === void 0) {
                    options = this.options;
                }
                if (data === void 0) {
                    data = {};
                }
                options = __assign({}, this.options, options);
                var /** @type {?} */ notificationRef = {
                    templateRef: templateRef,
                    duration: options.duration,
                    date: new Date(),
                    visible: true,
                    height: options.height,
                    spacing: options.spacing,
                    backgroundColor: options.backgroundColor,
                    iconColor: options.iconColor,
                    data: data
                };
                var /** @type {?} */ notifications = this.notifications$.getValue();
                if (this.direction === 'above') {
                    notifications.unshift(notificationRef);
                }
                else {
                    notifications.push(notificationRef);
                }
                this.notifications$.next(notifications);
                // remove notification after delay
                if (options.duration !== 0) {
                    setTimeout(function () { return _this.dismiss(notificationRef); }, options.duration * 1000);
                }
                return notificationRef;
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.getHistory =
            function () {
                return this.notifications$.getValue();
            };
        /**
         * @param {?} notificationRef
         * @return {?}
         */
        NotificationService.prototype.dismiss =
            function (notificationRef) {
                notificationRef.visible = false;
                this.notifications$.next(this.notifications$.getValue());
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.dismissAll =
            function () {
                this.notifications$.getValue().forEach(function (notificationRef) { return notificationRef.visible = false; });
                this.notifications$.next(this.notifications$.getValue());
            };
        NotificationService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        NotificationService.ctorParameters = function () {
            return [
                { type: ColorService, },
            ];
        };
        return NotificationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationListComponent = (function () {
        function NotificationListComponent(_notificationService) {
            this._notificationService = _notificationService;
            this.position = 'top-right';
            this.notifications$ = this._notificationService.notifications$.pipe(map.map(function (notificationRefs) { return notificationRefs.filter(function (notificationRef) { return notificationRef.visible; }); }));
        }
        Object.defineProperty(NotificationListComponent.prototype, "direction", {
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this._notificationService.direction = direction;
            },
            enumerable: true,
            configurable: true
        });
        NotificationListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-notification-list',
                        template: "<div class=\"notification\" *ngFor=\"let notificationRef of notifications$ | async; let idx = index\"\n    [style.top.px]=\"(notificationRef.height + notificationRef.spacing) * idx\"\n    [style.height.px]=\"notificationRef.height\"\n    [style.background-color]=\"notificationRef.backgroundColor\"\n    [@notificationState]>\n    <ng-container *ngTemplateOutlet=\"notificationRef.templateRef; context: { $implicit: notificationRef, data: notificationRef.data }\"></ng-container>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('notificationState', [
                                animations.state('in', animations.style({ transform: 'translateY(0)', opacity: 0.9 })),
                                animations.transition(':enter', [
                                    animations.style({ transform: 'translateY(-50px)', opacity: 0 }),
                                    animations.animate(500)
                                ]),
                                animations.transition(':leave', [
                                    animations.animate(500, animations.style({ transform: 'translateY(50px)', opacity: 0 }))
                                ])
                            ])
                        ]
                    },] },
        ];
        /** @nocollapse */
        NotificationListComponent.ctorParameters = function () {
            return [
                { type: NotificationService, },
            ];
        };
        NotificationListComponent.propDecorators = {
            "direction": [{ type: core.Input },],
            "position": [{ type: core.Input }, { type: core.HostBinding, args: ['class',] },],
        };
        return NotificationListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationModule = (function () {
        function NotificationModule() {
        }
        NotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule
                        ],
                        exports: [
                            NotificationListComponent
                        ],
                        declarations: [
                            NotificationListComponent
                        ],
                        providers: [
                            NotificationService
                        ]
                    },] },
        ];
        /** @nocollapse */
        NotificationModule.ctorParameters = function () { return []; };
        return NotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ NUMBER_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return NumberPickerComponent; }),
        multi: true
    };
    var NumberPickerComponent = (function () {
        function NumberPickerComponent() {
            this._min = -Infinity;
            this._max = Infinity;
            this._step = 1;
            this._disabled = false;
            this._value = 0;
            this._propagateChange = function (_) { };
            this.valid = true;
            this.valueChange = new core.EventEmitter();
        }
        Object.defineProperty(NumberPickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.valueChange.emit(value);
                this._propagateChange(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "min", {
            get: /**
             * @return {?}
             */ function () {
                return this._min;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._min = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "max", {
            get: /**
             * @return {?}
             */ function () {
                return this._max;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._max = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._step = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = typeof value === 'string' && (value === '' || value === 'true' || value === 'disabled') || value === true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.increment =
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.max(Math.min(this.value + this.step, this.max), this.min);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.decrement =
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.min(Math.max(this.value - this.step, this.min), this.max);
                }
            };
        /**
         * @return {?}
         */
        NumberPickerComponent.prototype.isValid =
            function () {
                if (this.value < this.min || this.value > this.max) {
                    return false;
                }
                return this.valid;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.onScroll =
            function (event) {
                var /** @type {?} */ scrollValue = event.deltaY || event.wheelDelta;
                if (scrollValue < 0) {
                    this.increment(event);
                }
                else {
                    this.decrement(event);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NumberPickerComponent.prototype.writeValue =
            function (value) {
                if (value !== undefined) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnChange =
            function (fn) {
                this._propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnTouched =
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NumberPickerComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        NumberPickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-number-picker',
                        template: "<input type=\"number\"\n       role=\"spinbutton\"\n       class=\"form-control number-picker-input\"\n       [(ngModel)]=\"value\"\n       [min]=\"min\"\n       [max]=\"max\"\n       (keydown.ArrowDown)=\"decrement($event)\"\n       (keydown.ArrowUp)=\"increment($event)\"\n       (wheel)=\"onScroll($event)\"\n       step=\"any\"\n       [disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\">\n\n<div class=\"number-picker-controls\">\n\n    <div class=\"number-picker-control-up\"\n         (click)=\"increment($event)\"\n         [class.disabled]=\"disabled || value >= max\">\n\n        <span class=\"hpe-icon hpe-up\"></span>\n    </div>\n\n    <div class=\"number-picker-control-down\"\n         (click)=\"decrement($event)\"\n         [class.disabled]=\"disabled || value <= min\">\n\n        <span class=\"hpe-icon hpe-down\"></span>\n    </div>\n\n</div>",
                        providers: [NUMBER_PICKER_VALUE_ACCESSOR],
                        host: {
                            '[class.has-error]': '!isValid()'
                        }
                    },] },
        ];
        /** @nocollapse */
        NumberPickerComponent.ctorParameters = function () { return []; };
        NumberPickerComponent.propDecorators = {
            "valid": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input, args: ['value',] },],
            "min": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "step": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
        };
        return NumberPickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NumberPickerModule = (function () {
        function NumberPickerModule() {
        }
        NumberPickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [NumberPickerComponent],
                        declarations: [NumberPickerComponent]
                    },] },
        ];
        /** @nocollapse */
        NumberPickerModule.ctorParameters = function () { return []; };
        return NumberPickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationService = (function () {
        function MenuNavigationService() {
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
        }
        MenuNavigationService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MenuNavigationService.ctorParameters = function () { return []; };
        return MenuNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationItemDirective = (function () {
        function MenuNavigationItemDirective(service, _elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.activated = new core.EventEmitter();
            this._subscription = service.active$.subscribe(function (next) {
                if (next === _this) {
                    _this.setActive();
                }
            });
        }
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.setActive =
            function () {
                this._elementRef.nativeElement.focus();
                this.activated.emit();
            };
        MenuNavigationItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationItem]'
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationItemDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService, },
                { type: core.ElementRef, },
            ];
        };
        MenuNavigationItemDirective.propDecorators = {
            "activated": [{ type: core.Output },],
        };
        return MenuNavigationItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationDirective = (function () {
        function MenuNavigationDirective(_service, _elementRef, document) {
            this._service = _service;
            this._elementRef = _elementRef;
            this.toggleButtonPosition = 'top';
            this.navigatedOut = new core.EventEmitter();
            this._subscription = new Subscription.Subscription();
            this._document = document;
        }
        Object.defineProperty(MenuNavigationDirective.prototype, "activeIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemsOrdered.indexOf(this._service.active$.value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnInit =
            function () {
                if (this.toggleButton) {
                    this._subscription.add(this.toggleButton.keyEnter.subscribe(this.focusFirst.bind(this)));
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                this._subscription.add(this.items.changes.subscribe(function () {
                    _this._itemsOrdered = _this.items.toArray();
                }));
                this._itemsOrdered = this.items.toArray();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.focusFirst =
            function () {
                this.moveFirst();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.keydownHandler =
            function (event) {
                // Only handle events when focus in within the list of menu items
                if (!this._elementRef.nativeElement.contains(this._document.activeElement)) {
                    return;
                }
                var /** @type {?} */ handled = false;
                switch (event.key) {
                    case 'ArrowUp':
                    case 'Up':
                        this.movePrevious(event);
                        handled = true;
                        break;
                    case 'ArrowDown':
                    case 'Down':
                        this.moveNext(event);
                        handled = true;
                        break;
                    case 'ArrowLeft':
                    case 'Left':
                        if (this.toggleButtonPosition === 'left') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case 'ArrowRight':
                    case 'Right':
                        if (this.toggleButtonPosition === 'right') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case 'Home':
                        this.moveFirst();
                        handled = true;
                        break;
                    case 'End':
                        this.moveLast();
                        handled = true;
                        break;
                    case 'Escape':
                        this.navigatedOut.emit(event);
                        handled = true;
                        break;
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveNext =
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex + 1;
                if (nextIndex < this._itemsOrdered.length) {
                    // Activate the next menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'bottom') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.movePrevious =
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex - 1;
                if (nextIndex >= 0) {
                    // Activate the previous menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'top') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveFirst =
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[0]);
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveLast =
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[this._itemsOrdered.length - 1]);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveToToggleButton =
            function (event) {
                if (this.toggleButton) {
                    this.toggleButton.focus();
                    this.toggleButton.menuOpen = false;
                }
                this.navigatedOut.emit(event);
            };
        MenuNavigationDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigation]',
                        exportAs: 'uxMenuNavigation',
                        providers: [MenuNavigationService]
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService, },
                { type: core.ElementRef, },
                { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
            ];
        };
        MenuNavigationDirective.propDecorators = {
            "toggleButton": [{ type: core.Input },],
            "toggleButtonPosition": [{ type: core.Input },],
            "navigatedOut": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [MenuNavigationItemDirective, { descendants: true },] },],
            "keydownHandler": [{ type: core.HostListener, args: ['document:keydown', ['$event'],] },],
        };
        return MenuNavigationDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationToggleDirective = (function () {
        function MenuNavigationToggleDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.menuPosition = 'bottom';
            this.menuOpenChange = new core.EventEmitter();
            this.keyEnter = new core.EventEmitter();
        }
        Object.defineProperty(MenuNavigationToggleDirective.prototype, "menuOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._menuOpen = value;
                this.menuOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.focus =
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.keydownHandler =
            function (event) {
                var _this = this;
                if (this.isKeyMatch(event.key)) {
                    // Open the menu
                    this.menuOpen = true;
                    // Allow the menu to init, then send the event to give it focus
                    setTimeout(function () {
                        _this.keyEnter.emit();
                    });
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} key
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.isKeyMatch =
            function (key) {
                switch (key) {
                    case 'Enter':
                    case ' ':
                        return true;
                    case 'ArrowUp':
                    case 'Up':
                        return this.menuPosition === 'top';
                    case 'ArrowDown':
                    case 'Down':
                        return this.menuPosition === 'bottom';
                    case 'ArrowLeft':
                    case 'Left':
                        return this.menuPosition === 'left';
                    case 'ArrowRight':
                    case 'Right':
                        return this.menuPosition === 'right';
                }
                return false;
            };
        MenuNavigationToggleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationToggle]',
                        exportAs: 'uxMenuNavigationToggle'
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationToggleDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        MenuNavigationToggleDirective.propDecorators = {
            "menuOpen": [{ type: core.Input },],
            "menuPosition": [{ type: core.Input },],
            "menuOpenChange": [{ type: core.Output },],
            "keydownHandler": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
        };
        return MenuNavigationToggleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS = [
        MenuNavigationDirective,
        MenuNavigationItemDirective,
        MenuNavigationToggleDirective
    ];
    var MenuNavigationModule = (function () {
        function MenuNavigationModule() {
        }
        MenuNavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: EXPORTS,
                        declarations: EXPORTS,
                    },] },
        ];
        /** @nocollapse */
        MenuNavigationModule.ctorParameters = function () { return []; };
        return MenuNavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderCustomMenuDirective = (function () {
        function PageHeaderCustomMenuDirective() {
        }
        PageHeaderCustomMenuDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderCustomMenu]'
                    },] },
        ];
        /** @nocollapse */
        PageHeaderCustomMenuDirective.ctorParameters = function () { return []; };
        return PageHeaderCustomMenuDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderService = (function () {
        function PageHeaderService() {
            var _this = this;
            this.items$ = new BehaviorSubject.BehaviorSubject([]);
            this.selected$ = new BehaviorSubject.BehaviorSubject(null);
            this.selectedRoot$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondary$ = new BehaviorSubject.BehaviorSubject(false);
            this.activeIconMenu$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondaryNavigationAutoselect = false;
            this._subscription = this.selected$.pipe(operators.map(function (selected) { return _this.getRoot(selected); })).subscribe(function (root) { return _this.selectedRoot$.next(root); });
        }
        /**
         * @return {?}
         */
        PageHeaderService.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.select =
            function (item) {
                if (this.secondaryNavigationAutoselect && item && item.children && item.children.length > 0) {
                    // Select the first child in secondaryNavigationAutoselect mode
                    this.selected$.next(item.children[0]);
                }
                else {
                    // if we are in secondary navigation mode and we click a parent - dont deselect the child
                    if (this.secondary$.getValue() === true && this.isParentOf(this.selected$.getValue(), item)) {
                        return;
                    }
                    // Otherwise select the given item
                    this.selected$.next(item);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.deselect =
            function (item) {
                var _this = this;
                // deselect the current item
                item.selected = false;
                // iterate any children and deselect them
                if (item.children) {
                    item.children.forEach(function (_item) { return _this.deselect(_item); });
                }
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.deselectAll =
            function () {
                var _this = this;
                this.items$.getValue().forEach(function (item) { return _this.deselect(item); });
            };
        /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
        PageHeaderService.prototype.updateItem =
            function (item, selected) {
                // Item is selected if it is the selected item, or one of the selected item's ancestors.
                item.selected = (item === selected) || this.isParentOf(selected, item);
                if (item === selected) {
                    // call the select function if present
                    if (item.select) {
                        item.select.call(item, item);
                    }
                }
            };
        /**
         * @param {?=} items
         * @return {?}
         */
        PageHeaderService.prototype.setItems =
            function (items) {
                var _this = this;
                if (items === void 0) {
                    items = [];
                }
                // identify all parent elements
                items.forEach(function (item) { return _this.setParent(item); });
                this.items$.next(items);
                // Set up the initally selected item
                var /** @type {?} */ initialSelectedItem = items.find(function (item) { return item.selected === true; });
                this.select(initialSelectedItem);
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        PageHeaderService.prototype.setSecondaryNavigation =
            function (enabled) {
                this.secondary$.next(enabled);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.getRoot =
            function (item) {
                return item && item.parent ? this.getRoot(item.parent) : item;
            };
        /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
        PageHeaderService.prototype.setParent =
            function (item, parent) {
                var _this = this;
                // set the parent field
                item.parent = parent;
                // call this function recursively on all children
                if (item.children) {
                    item.children.forEach(function (child) { return _this.setParent(child, item); });
                }
            };
        /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
        PageHeaderService.prototype.isParentOf =
            function (node, parent) {
                // if there are no parents return false
                if (!node || !node.parent) {
                    return false;
                }
                // if the parent is the match we are looking for return true
                if (node.parent === parent) {
                    return true;
                }
                // if there are potentially grandparents then check them too
                return this.isParentOf(node.parent, parent);
            };
        PageHeaderService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PageHeaderService.ctorParameters = function () { return []; };
        return PageHeaderService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderIconMenuComponent = (function () {
        function PageHeaderIconMenuComponent(_service) {
            var _this = this;
            this._service = _service;
            this._subscription = _service.activeIconMenu$.subscribe(function (next) {
                // Close all but the most recently opened menu
                if (next !== _this.menu) {
                    _this._isOpen = false;
                }
            });
        }
        Object.defineProperty(PageHeaderIconMenuComponent.prototype, "isOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._isOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._isOpen = value;
                if (value) {
                    this._service.activeIconMenu$.next(this.menu);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.select =
            function (item) {
                if (item.select) {
                    item.select.call(item, item);
                }
            };
        /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.keydownHandler =
            function (item, event) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        this.isOpen = false;
                        this.menuNavigationToggle.focus();
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderIconMenuComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-icon-menu',
                        template: "<div class=\"page-header-icon-menu\"\n    dropdown\n    placement=\"bottom right\"\n    [(isOpen)]=\"isOpen\">\n\n    <a role=\"button\"\n        class=\"page-header-icon-menu-button\"\n        [attr.aria-label]=\"menu.label\"\n        aria-haspopup=\"true\"\n        tabindex=\"0\"\n        (click)=\"select(menu)\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <i class=\"hpe-icon\" [ngClass]=\"menu.icon\"></i>\n        <span class=\"label label-primary\" *ngIf=\"menu?.badge\" aria-hidden=\"true\">{{ menu.badge }}</span>\n\n    </a>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li *ngFor=\"let dropdown of menu?.dropdown\"\n            role=\"none\"\n            [class.dropdown-header]=\"dropdown.header\"\n            [class.dropdown-divider]=\"dropdown.divider\">\n\n            <span class=\"font-bold\" *ngIf=\"dropdown.header\">{{ dropdown.title }}</span>\n\n            <a *ngIf=\"!dropdown.header\"\n                role=\"menuitem\"\n                class=\"dropdown-item\"\n                tabindex=\"-1\"\n                (click)=\"select(dropdown)\"\n                (keydown)=\"keydownHandler(dropdown, $event)\"\n                uxMenuNavigationItem>\n\n\n                <span class=\"dropdown-item-title\">\n                    <i class=\"hpe-icon hpe-fw\" [ngClass]=\"dropdown.icon\"></i>\n                    {{ dropdown.title }}\n                </span>\n                <span *ngIf=\"dropdown.subtitle\" class=\"dropdown-item-subtitle\">{{ dropdown.subtitle }}</span>\n\n            </a>\n        </li>\n\n    </ul>\n</div>"
                    },] },
        ];
        /** @nocollapse */
        PageHeaderIconMenuComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService, },
            ];
        };
        PageHeaderIconMenuComponent.propDecorators = {
            "menu": [{ type: core.Input },],
            "menuNavigationToggle": [{ type: core.ViewChild, args: ['menuNavigationToggle',] },],
        };
        return PageHeaderIconMenuComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationDropdownItemComponent = (function () {
        function PageHeaderNavigationDropdownItemComponent(_pageHeaderService) {
            var _this = this;
            this._pageHeaderService = _pageHeaderService;
            this.dropdownOpen = false;
            this._hover$ = new Subject.Subject();
            // subscribe to stream with a debounce (a small debounce is all that is required)
            this._subscription = this._hover$.pipe(operators.debounceTime(1)).subscribe(function (visible) { return _this.dropdownOpen = visible; });
            // Close submenus when selected item changes
            this._subscription.add(_pageHeaderService.selected$.subscribe(function () {
                _this.dropdownOpen = false;
            }));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.select =
            function (item) {
                // clicking on an item with children then return
                if (item.children) {
                    return;
                }
                // emit the selected item in an event
                this._pageHeaderService.select(item);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.focus =
            function () {
                this.button.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverStart =
            function () {
                this._hover$.next(true);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverLeave =
            function () {
                this._hover$.next(false);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.close =
            function () {
                this.dropdownOpen = false;
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.keydownHandler =
            function (event, item) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderNavigationDropdownItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-dropdown-item',
                        exportAs: 'ux-page-header-horizontal-navigation-dropdown-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0\"\n    dropdown\n    #subMenu=\"bs-dropdown\"\n    [isOpen]=\"dropdownOpen\"\n    container=\"body\"\n    placement=\"right\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdownOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        #button\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdownOpen\"\n        menuPosition=\"right\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n        <span class=\"dropdown-item-icon hpe-icon hpe-next\"></span>\n\n    </a>\n\n    <ul *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-submenu\"\n        (mouseenter)=\"hoverStart()\"\n        (mouseleave)=\"hoverLeave()\"\n        uxMenuNavigation\n        #menuNavigation=\"uxMenuNavigation\"\n        [toggleButton]=\"menuNavigationToggle\"\n        toggleButtonPosition=\"left\">\n\n        <li *ngFor=\"let subItem of item.children\" role=\"none\">\n\n            <a role=\"menuitem\"\n                class=\"dropdown-item\"\n                [class.selected]=\"subItem.selected\"\n                [attr.aria-selected]=\"subItem.selected\"\n                tabindex=\"-1\"\n                (click)=\"select(subItem)\"\n                (keydown)=\"keydownHandler($event, subItem)\"\n                uxMenuNavigationItem>\n\n                <span class=\"dropdown-item-title\">{{ subItem.title }}</span>\n\n            </a>\n\n        </li>\n    </ul>\n\n</div>\n\n<div *ngIf=\"!item.children || item.children.length === 0\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        #button\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        (click)=\"select(item)\"\n        (keydown)=\"keydownHandler($event, item)\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n\n    </a>\n\n</div>"
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationDropdownItemComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationDropdownItemComponent.propDecorators = {
            "item": [{ type: core.Input },],
            "button": [{ type: core.ViewChild, args: ['button',] },],
        };
        return PageHeaderNavigationDropdownItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationItemComponent = (function () {
        function PageHeaderNavigationItemComponent(elementRef, _pageHeaderService) {
            this.elementRef = elementRef;
            this._pageHeaderService = _pageHeaderService;
            this.secondary$ = this._pageHeaderService.secondary$;
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this._pageHeaderService.selected$.subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                    if (next && _this.isOpen) {
                        _this.isOpen = false;
                        // If menu was closed, keep focus on the toggle button
                        // If menu was closed, keep focus on the toggle button
                        _this.button.focus();
                    }
                });
                if (this.menu) {
                    this._subscription.add(this.menu.onHidden.subscribe(function () { return _this.dropdowns.forEach(function (dropdown$$1) { return dropdown$$1.close(); }); }));
                }
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.select =
            function () {
                // if the item has children then do nothing at this stage
                if (this.item.children && this._pageHeaderService.secondary$.getValue() === false) {
                    return;
                }
                // otherwise select the current item
                this._pageHeaderService.select(this.item);
            };
        PageHeaderNavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0 && !(secondary$ | async)\"\n    dropdown\n    #menu=\"bs-dropdown\"\n    [(isOpen)]=\"isOpen\"\n    container=\"body\"\n    placement=\"bottom left\">\n\n    <button role=\"menuitem\"\n        class=\"horizontal-navigation-button\"\n        [class.selected]=\"item.selected\"\n        [class.open]=\"isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"isOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #button=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n        <span class=\"navigation-item-label\">{{ item?.title }}</span>\n        <span class=\"hpe-icon hpe-down\"></span>\n\n    </button>\n\n    <div *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-menu\"\n        uxMenuNavigation\n        [toggleButton]=\"button\"\n        toggleButtonPosition=\"top\">\n\n        <div *ngFor=\"let item of item?.children\" uxMenuNavigationItem (activated)=\"dropdownItem.focus()\">\n            <ux-page-header-horizontal-navigation-dropdown-item\n                #dropdownItem=\"ux-page-header-horizontal-navigation-dropdown-item\"\n                [item]=\"item\">\n            </ux-page-header-horizontal-navigation-dropdown-item>\n        </div>\n\n    </div>\n\n</div>\n\n<button *ngIf=\"!item.children || item.children.length === 0 || (secondary$ | async)\"\n    role=\"menuitem\"\n    class=\"horizontal-navigation-button\"\n    [class.selected]=\"item.selected\"\n    [attr.aria-selected]=\"item.selected\"\n    (click)=\"select()\">\n\n    <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n    <span class=\"navigation-item-label\">{{ item?.title }}</span>\n\n</button>"
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationItemComponent.propDecorators = {
            "button": [{ type: core.ViewChild, args: ['button',] },],
            "menu": [{ type: core.ViewChild, args: ['menu',] },],
            "dropdowns": [{ type: core.ViewChildren, args: [PageHeaderNavigationDropdownItemComponent,] },],
            "item": [{ type: core.Input },],
        };
        return PageHeaderNavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationSecondaryItemDirective = (function () {
        function PageHeaderNavigationSecondaryItemDirective(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(operators.delay(0), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                });
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        PageHeaderNavigationSecondaryItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderNavigationSecondaryItem]'
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationSecondaryItemDirective.ctorParameters = function () {
            return [
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationSecondaryItemDirective.propDecorators = {
            "item": [{ type: core.Input, args: ['uxPageHeaderNavigationSecondaryItem',] },],
        };
        return PageHeaderNavigationSecondaryItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationComponent = (function () {
        function PageHeaderNavigationComponent(elementRef, resizeService, _pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this.items$ = this._pageHeaderService.items$;
            this.indicatorVisible = false;
            this.indicatorX = 0;
            this.indicatorWidth = 0;
            this._subscription = new Subscription.Subscription();
            this._subscription.add(resizeService.addResizeListener(elementRef.nativeElement).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.selected$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.secondary$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngAfterViewInit =
            function () {
                this.updateSelectedIndicator();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.updateSelectedIndicator =
            function () {
                var _this = this;
                setTimeout(function () {
                    // find the selected item
                    var /** @type {?} */ selected = _this.menuItems.find(function (item) { return item.item.selected; });
                    // determine whether or not to show the indicator
                    // determine whether or not to show the indicator
                    _this.indicatorVisible = !!selected;
                    // set the width of the indicator to match the width of the navigation item
                    if (selected) {
                        var /** @type {?} */ styles = getComputedStyle(selected.elementRef.nativeElement);
                        _this.indicatorX = selected.elementRef.nativeElement.offsetLeft;
                        _this.indicatorWidth = parseInt(styles.getPropertyValue('width'));
                    }
                });
            };
        PageHeaderNavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation',
                        template: "<ux-page-header-horizontal-navigation-item\n    *ngFor=\"let item of items$ | async\"\n    [item]=\"item\">\n</ux-page-header-horizontal-navigation-item>\n\n<div class=\"selected-indicator\"\n    [style.opacity]=\"indicatorVisible ? 1 : 0\"\n    [style.margin-left.px]=\"indicatorX\"\n    [style.width.px]=\"indicatorWidth\">\n</div>",
                        host: {
                            'role': 'menubar'
                        }
                    },] },
        ];
        /** @nocollapse */
        PageHeaderNavigationComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
                { type: PageHeaderService, },
            ];
        };
        PageHeaderNavigationComponent.propDecorators = {
            "menuItems": [{ type: core.ViewChildren, args: [PageHeaderNavigationItemComponent,] },],
        };
        return PageHeaderNavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderComponent = (function () {
        function PageHeaderComponent(_colorService, _pageHeaderService) {
            this._colorService = _colorService;
            this._pageHeaderService = _pageHeaderService;
            this.alignment = 'center';
            this.condensed = false;
            this.backVisible = true;
            this.secondaryNavigationAlignment = 'center';
            this.backClick = new core.EventEmitter();
            this.selected$ = this._pageHeaderService.selected$;
            this.selectedRoot$ = this._pageHeaderService.selectedRoot$;
            this._crumbs = [];
        }
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigationAutoselect", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondaryNavigationAutoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._pageHeaderService.secondaryNavigationAutoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "items", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._pageHeaderService.setItems(items);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigation", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondary$.getValue();
            },
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._pageHeaderService.setSecondaryNavigation(enabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "crumbs", {
            get: /**
             * @return {?}
             */ function () {
                return this.condensed ? __spread(this._crumbs, [{ title: this.header }]) : this._crumbs;
            },
            set: /**
             * @param {?} crumbs
             * @return {?}
             */ function (crumbs) {
                this._crumbs = crumbs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyBackground", {
            get: /**
             * @return {?}
             */ function () {
                return this._familyBackground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._familyBackground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyForeground", {
            get: /**
             * @return {?}
             */ function () {
                return this._familyForeground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._familyForeground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.goBack =
            function () {
                this.backClick.emit();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderComponent.prototype.select =
            function (item) {
                this._pageHeaderService.select(item);
            };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header',
                        exportAs: 'ux-page-header',
                        template: "<div class=\"ux-page-header\" [class.page-header-condensed]=\"condensed\" role=\"banner\">\n\n    <!-- Display Upper Section when not condensed -->\n    <div class=\"page-header-actions\" *ngIf=\"!condensed\">\n\n        <div class=\"page-header-logo-container\" role=\"presentation\" [hidden]=\"!logo\">\n            <img [attr.src]=\"logo\" class=\"page-header-logo\">\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n    </div>\n\n    <!-- Display Lower Section When Not Condensed -->\n    <div class=\"page-header-details\" *ngIf=\"!condensed\">\n\n        <div class=\"page-header-state-container\" role=\"navigation\">\n\n            <button *ngIf=\"backVisible === true\" class=\"page-header-back-button\" (click)=\"goBack()\" aria-label=\"Go Back\">\n                <span class=\"hpe-icon hpe-previous text-primary\"></span>\n            </button>\n\n            <div class=\"page-header-title-container\">\n\n                <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n\n                <h1 class=\"page-header-title\" [style.backgroundColor]=\"familyBackground\" [style.color]=\"familyForeground\">{{ header }}</h1>\n            </div>\n\n        </div>\n\n    </div>\n\n    <!-- Display This Section Optimized for Condensed Mode -->\n    <div class=\"page-header-condensed-content\" *ngIf=\"condensed\">\n\n        <div class=\"page-header-breadcrumbs\" role=\"navigation\">\n            <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n\n    </div>\n\n</div>\n\n<div class=\"page-header-secondary\" [ngClass]=\"secondaryNavigationAlignment\" role=\"navigation\" *ngIf=\"secondaryNavigation && (selectedRoot$ | async)\">\n    <ul class=\"nav nav-tabs\" role=\"tablist\" aria-label=\"Secondary Navigation\" *ngIf=\"(selectedRoot$ | async)?.children; let children\">\n        <li *ngFor=\"let child of children\"\n            [class.active]=\"child.selected\"\n            role=\"none\"\n            [uxPageHeaderNavigationSecondaryItem]=\"child\">\n\n            <a role=\"tab\"\n                [attr.aria-selected]=\"child.selected\"\n                tabindex=\"0\"\n                (click)=\"select(child)\"\n                (keydown.enter)=\"select(child)\">{{ child.title }}</a>\n\n        </li>\n    </ul>\n</div>",
                        providers: [PageHeaderService]
                    },] },
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: ColorService, },
                { type: PageHeaderService, },
            ];
        };
        PageHeaderComponent.propDecorators = {
            "logo": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "alignment": [{ type: core.Input },],
            "condensed": [{ type: core.Input },],
            "iconMenus": [{ type: core.Input },],
            "backVisible": [{ type: core.Input },],
            "secondaryNavigationAlignment": [{ type: core.Input },],
            "secondaryNavigationAutoselect": [{ type: core.Input },],
            "items": [{ type: core.Input },],
            "secondaryNavigation": [{ type: core.Input },],
            "crumbs": [{ type: core.Input },],
            "familyBackground": [{ type: core.Input },],
            "familyForeground": [{ type: core.Input },],
            "backClick": [{ type: core.Output },],
            "customMenus": [{ type: core.ContentChildren, args: [PageHeaderCustomMenuDirective, { read: core.TemplateRef },] },],
        };
        return PageHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderModule = (function () {
        function PageHeaderModule() {
        }
        PageHeaderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            BreadcrumbsModule,
                            ColorServiceModule,
                            ResizeModule,
                            MenuNavigationModule,
                            dropdown.BsDropdownModule.forRoot()
                        ],
                        exports: [
                            PageHeaderComponent,
                            PageHeaderCustomMenuDirective
                        ],
                        declarations: [
                            PageHeaderComponent,
                            PageHeaderIconMenuComponent,
                            PageHeaderCustomMenuDirective,
                            PageHeaderNavigationComponent,
                            PageHeaderNavigationItemComponent,
                            PageHeaderNavigationDropdownItemComponent,
                            PageHeaderNavigationSecondaryItemDirective
                        ]
                    },] },
        ];
        /** @nocollapse */
        PageHeaderModule.ctorParameters = function () { return []; };
        return PageHeaderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarComponent = (function () {
        function ProgressBarComponent() {
            this.value = 0;
            this.max = 100;
            this.indeterminate = false;
        }
        ProgressBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-progress-bar',
                        template: "<div *ngIf=\"!indeterminate\" class=\"progressbar-track\" [style.width.%]=\"(value / max) * 100\" [style.backgroundColor]=\"barColor\">\n    <ng-content></ng-content>\n</div>\n<div *ngIf=\"indeterminate\" class=\"progressbar-track indeterminate\" [style.backgroundColor]=\"barColor\">\n    <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        ProgressBarComponent.ctorParameters = function () { return []; };
        ProgressBarComponent.propDecorators = {
            "value": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "indeterminate": [{ type: core.Input },],
            "trackColor": [{ type: core.Input },],
            "barColor": [{ type: core.Input },],
        };
        return ProgressBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarModule = (function () {
        function ProgressBarModule() {
        }
        ProgressBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [ProgressBarComponent],
                        declarations: [ProgressBarComponent]
                    },] },
        ];
        /** @nocollapse */
        ProgressBarModule.ctorParameters = function () { return []; };
        return ProgressBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ RADIOBUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueRadioId = 0;
    var RadioButtonComponent = (function () {
        function RadioButtonComponent() {
            this._radioButtonId = "ux-radio-button-" + ++uniqueRadioId;
            this.id = this._radioButtonId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.simplified = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.ariaDescribedby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(RadioButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._radioButtonId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.toggle =
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                // toggle the checked state
                this.value = this.option;
                // call callback
                this.onChangeCallback(this.value);
            };
        // Functions required to update ng-model
        /**
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue =
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        RadioButtonComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        RadioButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-radio-button',
                        template: "<label [attr.for]=\"inputId\" class=\"ux-radio-button\"\n       [class.ux-radio-button-checked]=\"value === option\"\n       [class.ux-radio-button-simplified]=\"simplified\"\n       [class.ux-radio-button-disabled]=\"disabled\"\n       [class.ux-radio-button-focused]=\"focused\">\n\n    <div class=\"ux-radio-button-container\">\n        <input class=\"ux-radio-button-input\"\n            type=\"radio\"\n            [id]=\"inputId\"\n            [checked]=\"value === option\"\n            [disabled]=\"disabled\"\n            [tabindex]=\"tabindex || value === option ? 0 : -1\"\n            [attr.name]=\"name\"\n            [required]=\"required\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [attr.aria-checked]=\"value === option\"\n            (focus)=\"focused = true\"\n            (blur)=\"focused = false\"\n            (change)=\"toggle()\"\n            (click)=\"$event.stopPropagation()\">\n    </div>\n\n    <span class=\"ux-radio-button-label\">\n        <ng-content></ng-content>\n    </span>\n\n</label>",
                        providers: [RADIOBUTTON_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonComponent.ctorParameters = function () { return []; };
        RadioButtonComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "name": [{ type: core.Input },],
            "required": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "clickable": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "simplified": [{ type: core.Input },],
            "option": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
            "ariaLabelledby": [{ type: core.Input, args: ['aria-labelledby',] },],
            "ariaDescribedby": [{ type: core.Input, args: ['aria-describedby',] },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input },],
        };
        return RadioButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RadioButtonModule = (function () {
        function RadioButtonModule() {
        }
        RadioButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [RadioButtonComponent],
                        declarations: [RadioButtonComponent]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonModule.ctorParameters = function () { return []; };
        return RadioButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderService = (function () {
        function SearchBuilderService() {
            this.query = {};
            this.queryChange = new Subject.Subject();
            this.validationChange = new BehaviorSubject.BehaviorSubject(true);
            this._componentId = 0;
            this._components = [];
            this._validation = {};
        }
        /**
         * Add a component to the internal list of components
         */
        /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponent =
            function (component) {
                // ensure there are no components with a matching name
                if (this._components.find(function (cmp) { return cmp.name === component.name; })) {
                    throw new Error("Search builder components must have a unique name. The name " + component.name + " has already been used.");
                }
                // if unique then add the component to the list
                this._components.push(component);
            };
        /**
         * Bulk registration of components
         * (Just a helper method)
         */
        /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponents =
            function (components) {
                var _this = this;
                components.forEach(function (component) { return _this.registerComponent(component); });
            };
        /**
         * Get a registered component class
         */
        /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
        SearchBuilderService.prototype.getComponent =
            function (name) {
                // find the component
                var /** @type {?} */ component = this._components.find(function (cmp) { return cmp.name === name; });
                // if there is no match throw an exception
                if (!component) {
                    throw new Error("No search build component with the name " + name + " exists");
                }
                // ensure config is defined - at least to an empty object
                component.config = component.config || {};
                return component;
            };
        /**
         * Update the internal search query state
         * note that the query will be immutable
         */
        /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
        SearchBuilderService.prototype.setQuery =
            function (query) {
                this.query = Object.assign({}, query);
            };
        /**
         * Return the current query state
         */
        /**
         * Return the current query state
         * @return {?}
         */
        SearchBuilderService.prototype.getQuery =
            function () {
                return this.query;
            };
        /**
         * Trigger the observable to indicate the query has been updated
         */
        /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
        SearchBuilderService.prototype.queryHasChanged =
            function () {
                this.queryChange.next(this.query);
            };
        /**
         * Store the validation state of the query
         */
        /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
        SearchBuilderService.prototype.setValid =
            function (id, valid) {
                var _this = this;
                // store the state for this specific component
                this._validation[id] = valid;
                // evaluate the entire validation state
                this.validationChange.next(!Object.keys(this._validation).some(function (key) { return !_this._validation[key]; }));
            };
        /**
         * Generate a unique id for each component
         */
        /**
         * Generate a unique id for each component
         * @return {?}
         */
        SearchBuilderService.prototype.generateComponentId =
            function () {
                return this._componentId++;
            };
        SearchBuilderService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SearchBuilderService.ctorParameters = function () { return []; };
        return SearchBuilderService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupService = (function () {
        function SearchBuilderGroupService(_searchBuilderService) {
            this._searchBuilderService = _searchBuilderService;
        }
        /**
         * Initialise the group by defining an id
         */
        /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
        SearchBuilderGroupService.prototype.init =
            function (id) {
                var _this = this;
                // store the name of the group
                this._id = id;
                // create the entry in the query object if it doesn't exist
                if (!this._searchBuilderService.query[this._id]) {
                    // create the section
                    this._searchBuilderService.query[this._id] = [];
                    // emit the changes after the initial setup
                    setTimeout(function () { return _this._searchBuilderService.queryHasChanged(); });
                }
            };
        /**
         * Remove a field from the search builder query
         */
        /**
         * Remove a field from the search builder query
         * @param {?} field
         * @return {?}
         */
        SearchBuilderGroupService.prototype.remove =
            function (field) {
                // get the query for this group
                var /** @type {?} */ query = this.getQuery();
                // remove the field from the array
                query.splice(query.indexOf(field), 1);
            };
        /**
         * Get the query for this specific search group
         */
        /**
         * Get the query for this specific search group
         * @return {?}
         */
        SearchBuilderGroupService.prototype.getQuery =
            function () {
                return this._searchBuilderService.query[this._id] ? this._searchBuilderService.query[this._id] : [];
            };
        SearchBuilderGroupService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SearchBuilderGroupService.ctorParameters = function () {
            return [
                { type: SearchBuilderService, },
            ];
        };
        return SearchBuilderGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupComponent = (function () {
        function SearchBuilderGroupComponent(searchBuilderGroupService, _searchBuilderService) {
            this.searchBuilderGroupService = searchBuilderGroupService;
            this._searchBuilderService = _searchBuilderService;
            this.operator = 'and';
            this.addText = 'Add a field';
            this.showPlaceholder = false;
            this.add = new core.EventEmitter();
            this.remove = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnInit =
            function () {
                // ensure we have a name otherwise throw an error
                if (!this.id) {
                    throw new Error('Search builder group must have a name attribute.');
                }
                // otherwise register the group
                this.searchBuilderGroupService.init(this.id);
            };
        /**
         * @param {?} field
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.removeField =
            function (field) {
                this.searchBuilderGroupService.remove(field);
                this.remove.emit(field);
            };
        SearchBuilderGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder-group',
                        template: "<h4 class=\"search-group-title\">{{ header }}</h4>\n\n<main class=\"search-group-content\">\n\n  <section class=\"search-group-operator search-group-operator-{{ operator }}\" [class.hidden-operator]=\"searchBuilderGroupService.getQuery().length < 2\">{{ operator }}</section>\n\n  <section class=\"search-group-items\">\n\n    <div class=\"search-group-item-container\" *ngFor=\"let field of searchBuilderGroupService.getQuery()\">\n\n      <div class=\"search-group-item\">\n        <ng-container *uxSearchBuilderOutlet=\"field.type; context: field\"></ng-container>\n      </div>\n\n      <div class=\"search-group-item-remove\" (click)=\"removeField(field)\">\n        <span class=\"hpe-icon hpe-close\"></span>\n      </div>\n    </div>\n\n    <!-- Placeholder Item -->\n    <ng-container *ngIf=\"showPlaceholder\">\n\n      <!-- The Default Placeholder -->\n      <div class=\"search-group-item-container placeholder-item\" *ngIf=\"!placeholder\">\n        \n        <div class=\"search-group-item\">\n          <label class=\"form-label\">New field</label>\n          <div class=\"form-control\"></div>\n        </div>\n  \n      </div>\n\n      <!-- Allow a custom placeholder -->\n    <ng-container *ngTemplateOutlet=\"placeholder\"></ng-container>\n\n    </ng-container>\n\n  </section>\n\n  <section class=\"search-builder-group-add-field\" (click)=\"add.emit($event)\">\n\n    <button type=\"button\" class=\"btn btn-icon btn-circular button-accent\" aria-label=\"Add Field\">\n      <span class=\"hpe-icon hpe-add\" aria-hidden=\"true\"></span>\n    </button>\n\n    <span class=\"search-builder-group-add-field-label\">{{ addText }}</span>\n\n  </section>\n\n</main>\n\n<hr class=\"search-builder-group-divider\">\n",
                        providers: [SearchBuilderGroupService]
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderGroupComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderGroupService, },
                { type: SearchBuilderService, },
            ];
        };
        SearchBuilderGroupComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "header": [{ type: core.Input },],
            "operator": [{ type: core.Input },],
            "addText": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "showPlaceholder": [{ type: core.Input },],
            "add": [{ type: core.Output },],
            "remove": [{ type: core.Output },],
        };
        return SearchBuilderGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderOutletDirective = (function () {
        function SearchBuilderOutletDirective(_viewContainerRef, _componentFactoryResolver, _searchBuilderService) {
            this._viewContainerRef = _viewContainerRef;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._searchBuilderService = _searchBuilderService;
        }
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnInit =
            function () {
                // get the class from the type
                var /** @type {?} */ componentDefinition = this._searchBuilderService.getComponent(this.uxSearchBuilderOutlet);
                // create the component factory
                var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentDefinition.component);
                // create the component instance
                this._componentRef = this._viewContainerRef.createComponent(componentFactory);
                // combine the predefined config with any dynmaic config
                var /** @type {?} */ config = Object.assign({}, componentDefinition.config, this.uxSearchBuilderOutletContext.config || {});
                // set the context and config property on the component instance
                this._componentRef.instance.context = this.uxSearchBuilderOutletContext;
                this._componentRef.instance.config = config;
            };
        SearchBuilderOutletDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSearchBuilderOutlet]'
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderOutletDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef, },
                { type: core.ComponentFactoryResolver, },
                { type: SearchBuilderService, },
            ];
        };
        SearchBuilderOutletDirective.propDecorators = {
            "uxSearchBuilderOutlet": [{ type: core.Input },],
            "uxSearchBuilderOutletContext": [{ type: core.Input },],
        };
        return SearchBuilderOutletDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BaseSearchComponent = (function () {
        function BaseSearchComponent(_searchBuilderService, _searchBuilderGroupService) {
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderGroupService = _searchBuilderGroupService;
            this._id = this._searchBuilderService.generateComponentId();
            this._valid = true;
        }
        Object.defineProperty(BaseSearchComponent.prototype, "value", {
            /**
             * Get the current value of the component
             */
            get: /**
             * Get the current value of the component
             * @return {?}
             */ function () {
                return this.context.value;
            },
            /**
             * Set the current value of the component
             */
            set: /**
             * Set the current value of the component
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.context.value = value;
                this._searchBuilderService.queryHasChanged();
                // if value has been set perform validation
                this.validate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                this._searchBuilderService.setValid(this._id, valid);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Make sure we clean up after ourselves
         */
        /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
        BaseSearchComponent.prototype.ngOnDestroy =
            function () {
                this.valid = true;
            };
        /**
         * Perform any required validation on the value
         */
        /**
         * Perform any required validation on the value
         * @return {?}
         */
        BaseSearchComponent.prototype.validate =
            function () {
                // if a custom validation function has been provided then use it
                this.valid = this.config.validation ? this.config.validation(this, this.value) : true;
            };
        BaseSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-base-search',
                        template: ''
                    },] },
        ];
        /** @nocollapse */
        BaseSearchComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService, },
                { type: SearchBuilderGroupService, },
            ];
        };
        return BaseSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchTextComponent = (function (_super) {
        __extends(SearchTextComponent, _super);
        function SearchTextComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'text';
            return _this;
        }
        Object.defineProperty(SearchTextComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchTextComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter text';
            },
            enumerable: true,
            configurable: true
        });
        SearchTextComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-text',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n<input [placeholder]=\"placeholder\" [(ngModel)]=\"value\" class=\"form-control\">"
                    },] },
        ];
        /** @nocollapse */
        SearchTextComponent.ctorParameters = function () { return []; };
        return SearchTextComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateComponent = (function (_super) {
        __extends(SearchDateComponent, _super);
        function SearchDateComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date';
            return _this;
        }
        Object.defineProperty(SearchDateComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter date';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SearchDateComponent.prototype.ngOnInit =
            function () {
                // by default set to the current date if not specified
                if (!this.value) {
                    this.value = new Date();
                }
            };
        SearchDateComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"input-group date m-nil\">\n    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"popover.show()\">\n        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n    </span>\n    <input type=\"text\" #popover=\"ux-popover\" [ngModel]=\"value | date:'dd MMMM yyyy'\" [uxPopover]=\"popoverTemplate\"\n        placement=\"bottom\" popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"placeholder\">\n</div>\n\n<ng-template #popoverTemplate>\n    <ux-date-time-picker [(date)]=\"value\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    },] },
        ];
        /** @nocollapse */
        SearchDateComponent.ctorParameters = function () { return []; };
        return SearchDateComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateRangeComponent = (function (_super) {
        __extends(SearchDateRangeComponent, _super);
        function SearchDateRangeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date-range';
            return _this;
        }
        Object.defineProperty(SearchDateRangeComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "from", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.from) {
                    this.from = new Date();
                }
                // ensure that the from value is a date object
                if (this.value.from instanceof Date === false) {
                    this.value.from = new Date(this.value.from);
                }
                return this.value.from;
            },
            set: /**
             * @param {?} fromValue
             * @return {?}
             */ function (fromValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the from value is a date
                if (fromValue instanceof Date === false) {
                    fromValue = new Date(fromValue);
                }
                // set the latest value
                value.from = fromValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "to", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.to) {
                    this.to = new Date();
                }
                // ensure that the to value is a date object
                if (this.value.to instanceof Date === false) {
                    this.value.to = new Date(this.value.to);
                }
                return this.value.to;
            },
            set: /**
             * @param {?} toValue
             * @return {?}
             */ function (toValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the to value is a date
                if (toValue instanceof Date === false) {
                    toValue = new Date(toValue);
                }
                // set the latest value
                value.to = toValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromLabel || 'From';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toLabel || 'To';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Override the default validation
         */
        /**
         * Override the default validation
         * @return {?}
         */
        SearchDateRangeComponent.prototype.validate =
            function () {
                // check if there is a config validation function
                if (this.config.validation) {
                    return _super.prototype.validate.call(this);
                }
                // create copies of the dates so we can modify time value (to ignore it)
                var /** @type {?} */ from$$1 = new Date(this.value.from);
                var /** @type {?} */ to = new Date(this.value.to);
                // set the time to the same so we dont compare it
                from$$1.setHours(0, 0, 0, 0);
                to.setHours(0, 0, 0, 0);
                // valid if the from date is less than or equal to the to date
                this.valid = from$$1 <= to;
            };
        SearchDateRangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date-range',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"row\">\n    <div class=\"col-sm-12\">\n        <div class=\"form-inline\" [class.has-error]=\"!valid\">\n\n            <div class=\"form-group p-r-md\">\n                <label class=\"form-label m-r-xs\">{{ fromLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon p-r-xs\" tabindex=\"1\" (click)=\"fromPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #fromPopover=\"ux-popover\" [ngModel]=\"from | date:'dd MMMM yyyy'\" [uxPopover]=\"fromPopoverTemplate\" placement=\"bottom\"\n                        popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"fromPlaceholder\">\n                </div>\n            </div>\n\n            <div class=\"form-group p-r-xs\">\n                <label class=\"form-label m-r-xs\">{{ toLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"toPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #toPopover=\"ux-popover\" [ngModel]=\"to | date:'dd MMMM yyyy'\" [uxPopover]=\"toPopoverTemplate\" placement=\"bottom\"\n                        popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"toPlaceholder\">\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n\n<ng-template #fromPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"from\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>\n\n<ng-template #toPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"to\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    },] },
        ];
        /** @nocollapse */
        SearchDateRangeComponent.ctorParameters = function () { return []; };
        return SearchDateRangeComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchSelectComponent = (function (_super) {
        __extends(SearchSelectComponent, _super);
        function SearchSelectComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'select';
            return _this;
        }
        Object.defineProperty(SearchSelectComponent.prototype, "label", {
            /**
             * Provide defaults for undefined properties
             */
            get: /**
             * Provide defaults for undefined properties
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.options || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "multiple", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.multiple || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Select item';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "dropDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.dropDirection || 'down';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "allowNull", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.allowNull || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.disabled || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "maxHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.maxHeight || '250px';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "pageSize", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.pageSize || 20;
            },
            enumerable: true,
            configurable: true
        });
        SearchSelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-select',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<ux-select [(value)]=\"value\" \n           [options]=\"options\" \n           [multiple]=\"multiple\" \n           [placeholder]=\"placeholder\" \n           [dropDirection]=\"dropDirection\"\n           [pageSize]=\"pageSize\"\n           [allowNull]=\"allowNull\"\n           [disabled]=\"disabled\"\n           [maxHeight]=\"maxHeight\"\n           [key]=\"config.key\"\n           [display]=\"config.display\"\n           [loadingTemplate]=\"config.loadingTemplate\"\n           [optionTemplate]=\"config.optionTemplate\"\n           [noOptionsTemplate]=\"config.noOptionsTemplate\">\n</ux-select>"
                    },] },
        ];
        /** @nocollapse */
        SearchSelectComponent.ctorParameters = function () { return []; };
        return SearchSelectComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderComponent = (function () {
        /**
         * Register the default search builder components
         */
        function SearchBuilderComponent(_searchBuilderService) {
            var _this = this;
            this._searchBuilderService = _searchBuilderService;
            this.queryChange = new core.EventEmitter();
            this.valid = new core.EventEmitter(true);
            // watch for any query changes
            this._querySubscription = _searchBuilderService.queryChange.subscribe(function (query) { return _this.queryChange.emit(query); });
            // watch for any changes to the validation
            this._validSubscription = _searchBuilderService.validationChange.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.valid.emit(valid); });
        }
        Object.defineProperty(SearchBuilderComponent.prototype, "components", {
            set: /**
             * @param {?} components
             * @return {?}
             */ function (components) {
                this._searchBuilderService.registerComponents(components);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBuilderComponent.prototype, "query", {
            get: /**
             * @return {?}
             */ function () {
                return this._searchBuilderService.getQuery();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._searchBuilderService.setQuery(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Remove any subscriptions and cleanup
         */
        /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
        SearchBuilderComponent.prototype.ngOnDestroy =
            function () {
                this._querySubscription.unsubscribe();
                this._validSubscription.unsubscribe();
            };
        SearchBuilderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder',
                        template: "<ng-content></ng-content>",
                        providers: [SearchBuilderService]
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService, },
            ];
        };
        SearchBuilderComponent.propDecorators = {
            "components": [{ type: core.Input },],
            "query": [{ type: core.Input },],
            "queryChange": [{ type: core.Output },],
            "valid": [{ type: core.Output },],
        };
        return SearchBuilderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadOptionEvent = (function () {
        function TypeaheadOptionEvent(option) {
            this.option = option;
        }
        return TypeaheadOptionEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadKeyService = (function () {
        function TypeaheadKeyService() {
        }
        /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
        TypeaheadKeyService.prototype.handleKey =
            function (event, typeahead$$1) {
                if (typeahead$$1) {
                    switch (event.key) {
                        case 'ArrowUp':
                        case 'Up':
                            if (!typeahead$$1.open) {
                                typeahead$$1.open = true;
                            }
                            else {
                                typeahead$$1.moveHighlight(-1);
                            }
                            event.preventDefault();
                            break;
                        case 'ArrowDown':
                        case 'Down':
                            if (!typeahead$$1.open) {
                                typeahead$$1.open = true;
                            }
                            else {
                                typeahead$$1.moveHighlight(1);
                            }
                            event.preventDefault();
                            break;
                        case 'Escape':
                        case 'Esc':
                            typeahead$$1.open = false;
                            break;
                    }
                }
            };
        TypeaheadKeyService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TypeaheadKeyService.ctorParameters = function () { return []; };
        return TypeaheadKeyService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadService = (function () {
        function TypeaheadService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlightedElement$ = new BehaviorSubject.BehaviorSubject(null);
        }
        TypeaheadService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TypeaheadService.ctorParameters = function () { return []; };
        return TypeaheadService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId = 0;
    var TypeaheadComponent = (function () {
        function TypeaheadComponent(typeaheadElement, _cdRef, _service) {
            var _this = this;
            this.typeaheadElement = typeaheadElement;
            this._cdRef = _cdRef;
            this._service = _service;
            this.id = "ux-typeahead-" + ++uniqueId;
            this.openChange = new core.EventEmitter();
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiselectable = false;
            this.openOnFilterChange = true;
            this.pageSize = 20;
            this.selectFirst = true;
            this.optionSelected = new core.EventEmitter();
            this.highlightedChange = new core.EventEmitter();
            this.highlightedElementChange = new core.EventEmitter();
            this.visibleOptions$ = new BehaviorSubject.BehaviorSubject([]);
            this.loading = false;
            this.clicking = false;
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
            this.highlightedKey = null;
            this._open = false;
            this._subscription = new Subscription.Subscription();
            this.optionApi = {
                getKey: this.getKey.bind(this),
                getDisplay: this.getDisplay.bind(this),
                getDisplayHtml: this.getDisplayHtml.bind(this)
            };
            this.loadOptionsCallback = function (pageNum, pageSize, filter) {
                if (typeof _this.options === 'function') {
                    // Invoke the callback which may return an array or a promise.
                    var /** @type {?} */ arrayOrPromise = _this.options(pageNum, pageSize, filter);
                    // Map the results to an array of TypeaheadVisibleOption.
                    return Promise.resolve(arrayOrPromise).then(function (newOptions) {
                        if (!Array.isArray(newOptions)) {
                            return newOptions;
                        }
                        return newOptions.map(function (option) {
                            return {
                                value: option,
                                key: _this.getKey(option)
                            };
                        });
                    });
                }
                return null;
            };
            this._subscription.add(this._service.open$.pipe(operators.distinctUntilChanged()).subscribe(function (next) {
                _this.openChange.emit(next);
                if (next) {
                    _this.initOptions();
                }
            }));
            this._subscription.add(this.highlighted$.subscribe(function (next) {
                _this.highlightedKey = next ? next.key : null;
                _this.highlightedChange.emit(next ? next.value : null);
            }));
            this._subscription.add(combineLatest.combineLatest(this._service.open$, this._service.highlightedElement$, this.visibleOptions$)
                .subscribe(function (_a) {
                var _b = __read(_a, 3), open = _b[0], highlightedElement = _b[1], visibleOptions = _b[2];
                _this.highlightedElementChange.emit(open && visibleOptions.length > 0 ? highlightedElement : null);
            }));
        }
        Object.defineProperty(TypeaheadComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._service.open$.getValue();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "highlighted", {
            get: /**
             * @return {?}
             */ function () {
                var /** @type {?} */ value = this.highlighted$.getValue();
                return value ? value.value : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.ngAfterViewInit =
            function () {
                // Attach default loading template
                if (!this.loadingTemplate) {
                    this.loadingTemplate = this._defaultLoadingTemplate;
                }
                // Attach default option template
                if (!this.optionTemplate) {
                    this.optionTemplate = this._defaultOptionTemplate;
                }
                // Attach default "no results" template
                if (!this.noOptionsTemplate) {
                    this.noOptionsTemplate = this._defaultNoOptionsTemplate;
                }
                this._cdRef.detectChanges();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnChanges =
            function (changes) {
                // Open the dropdown if the filter value updates
                if (changes["filter"]) {
                    if (this.openOnFilterChange && changes["filter"].currentValue && changes["filter"].currentValue.length > 0) {
                        this.open = true;
                    }
                }
                // Re-filter visibleOptions
                this.updateOptions();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mousedownHandler =
            function () {
                this.clicking = true;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mouseupHandler =
            function () {
                this.clicking = false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TypeaheadComponent.prototype.optionMousedownHandler =
            function (event) {
                // Workaround to prevent focus changing when an option is clicked
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.optionClickHandler =
            function (event, option) {
                this.select(option);
            };
        /**
         * Returns the unique key value of the given option.
         */
        /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getKey =
            function (option) {
                if (typeof this.key === 'function') {
                    return this.key(option);
                }
                if (typeof this.key === 'string' && option && option.hasOwnProperty(this.key)) {
                    return option[(this.key)];
                }
                return this.getDisplay(option);
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplay =
            function (option) {
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param option
         */
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplayHtml =
            function (option) {
                var /** @type {?} */ displayText = this.getDisplay(option).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                var /** @type {?} */ displayHtml = displayText;
                if (this.filter) {
                    var /** @type {?} */ length_1 = this.filter.length;
                    var /** @type {?} */ matchIndex = displayText.toLowerCase().indexOf(this.filter.toLowerCase());
                    if (matchIndex >= 0) {
                        var /** @type {?} */ highlight = "<span class=\"ux-filter-match\">" + displayText.substr(matchIndex, length_1) + "</span>";
                        displayHtml = displayText.substr(0, matchIndex) + highlight + displayText.substr(matchIndex + length_1);
                    }
                }
                return displayHtml;
            };
        /**
         * Returns true if the infinite scroll component should load
         */
        /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
        TypeaheadComponent.prototype.isInfiniteScroll =
            function () {
                return typeof this.options === 'function';
            };
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         */
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.select =
            function (option) {
                if (!this.isDisabled(option)) {
                    this.optionSelected.emit(new TypeaheadOptionEvent(option.value));
                    this.highlighted$.next(null);
                    this.open = false;
                }
            };
        /**
         * Returns true if the given option is part of the disabledOptions array.
         */
        /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.isDisabled =
            function (option) {
                var _this = this;
                if (this.disabledOptions) {
                    var /** @type {?} */ result = this.disabledOptions.find(function (selectedOption) {
                        return _this.getKey(selectedOption) === option.key;
                    });
                    return result !== undefined;
                }
                return false;
            };
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         */
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.highlight =
            function (option) {
                if (!this.isDisabled(option)) {
                    this.highlighted$.next(option);
                }
            };
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TypeaheadComponent.prototype.moveHighlight =
            function (d) {
                var /** @type {?} */ visibleOptions = this.visibleOptions$.getValue();
                var /** @type {?} */ highlightIndex = this.indexOfVisibleOption(this.highlighted);
                var /** @type {?} */ newIndex = highlightIndex;
                var /** @type {?} */ disabled = true;
                var /** @type {?} */ inBounds = true;
                do {
                    newIndex = newIndex + d;
                    inBounds = (newIndex >= 0 && newIndex < visibleOptions.length);
                    disabled = inBounds && this.isDisabled(visibleOptions[newIndex]);
                } while (inBounds && disabled);
                if (!disabled && inBounds) {
                    this.highlighted$.next(visibleOptions[newIndex]);
                }
                return this.highlighted;
            };
        /**
         * Set up the options before the dropdown is displayed.
         */
        /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
        TypeaheadComponent.prototype.initOptions =
            function () {
                // Clear previous highlight
                this.highlighted$.next(null);
                if (this.selectFirst) {
                    // This will highlight the first non-disabled option.
                    this.moveHighlight(1);
                }
            };
        /**
         * Update the visibleOptions array with the current filter.
         */
        /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
        TypeaheadComponent.prototype.updateOptions =
            function () {
                var _this = this;
                if (typeof this.options === 'object') {
                    var /** @type {?} */ normalisedInput_1 = (this.filter || '').toLowerCase();
                    var /** @type {?} */ visibleOptions = this.options
                        .filter(function (option) {
                        return _this.getDisplay(option).toLowerCase().indexOf(normalisedInput_1) >= 0;
                    })
                        .map(function (value) {
                        return {
                            value: value,
                            key: _this.getKey(value)
                        };
                    });
                    this.visibleOptions$.next(visibleOptions);
                }
                this.initOptions();
            };
        /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.indexOfVisibleOption =
            function (option) {
                if (option) {
                    var /** @type {?} */ optionKey_1 = this.getKey(option);
                    return this.visibleOptions$.getValue().findIndex(function (el) {
                        return el.key === optionKey_1;
                    });
                }
                return -1;
            };
        TypeaheadComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-typeahead',
                        template: "<div class=\"ux-typeahead-options\"\n    [uxInfiniteScroll]=\"loadOptionsCallback\"\n    [collection]=\"visibleOptions$ | async\"\n    (collectionChange)=\"visibleOptions$.next($event)\"\n    [enabled]=\"isInfiniteScroll()\"\n    [filter]=\"filter\"\n    [loadOnScroll]=\"true\"\n    [pageSize]=\"pageSize\"\n    [scrollElement]=\"typeaheadElement\"\n    (loading)=\"loading = true\"\n    (loaded)=\"loading = false\">\n\n    <ol *ngIf=\"(visibleOptions$ | async).length > 0\">\n        <li *ngFor=\"let option of (visibleOptions$ | async); let i = index\"\n            [attr.id]=\"id + '-option-' + i\"\n            [class.disabled]=\"isDisabled(option)\"\n            [class.highlighted]=\"highlightedKey === option.key\"\n            [attr.aria-selected]=\"multiselectable ? isDisabled(option) : null\"\n            [uxTypeaheadHighlight]=\"highlightedKey === option.key\"\n            [uxScrollIntoViewIf]=\"highlightedKey === option.key\"\n            [scrollParent]=\"typeaheadElement.nativeElement\"\n            (mousedown)=\"optionMousedownHandler($event)\"\n            (click)=\"optionClickHandler($event, option)\"\n            (mouseover)=\"highlight(option)\">\n\n            <ng-container [ngTemplateOutlet]=\"optionTemplate\"\n                [ngTemplateOutletContext]=\"{option: option.value, api: optionApi}\">\n            </ng-container>\n\n        </li>\n    </ol>\n\n    <div *uxInfiniteScrollLoading>\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate\">\n        </ng-container>\n    </div>\n\n</div>\n<div *ngIf=\"(visibleOptions$ | async).length === 0 && !loading\">\n    <ng-container [ngTemplateOutlet]=\"noOptionsTemplate\">\n    </ng-container>\n</div>\n\n<ng-template #defaultLoadingTemplate>\n    <div class=\"ux-typeahead-loading\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n        <div>Loading...</div>\n    </div>\n</ng-template>\n\n<ng-template #defaultOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span class=\"ux-typeahead-option\" [innerHtml]=\"api.getDisplayHtml(option)\"></span>\n</ng-template>\n\n<ng-template #defaultNoOptionsTemplate>\n    <span class=\"ux-typeahead-no-options\">No results</span>\n</ng-template>",
                        providers: [TypeaheadService],
                        host: {
                            'role': 'listbox',
                            '[class.open]': 'open',
                            '[class.drop-up]': 'dropDirection === "up"',
                            '[style.maxHeight]': 'maxHeight'
                        }
                    },] },
        ];
        /** @nocollapse */
        TypeaheadComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.ChangeDetectorRef, },
                { type: TypeaheadService, },
            ];
        };
        TypeaheadComponent.propDecorators = {
            "id": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] },],
            "options": [{ type: core.Input },],
            "filter": [{ type: core.Input },],
            "open": [{ type: core.Input, args: ['open',] },],
            "openChange": [{ type: core.Output },],
            "display": [{ type: core.Input },],
            "key": [{ type: core.Input },],
            "disabledOptions": [{ type: core.Input },],
            "dropDirection": [{ type: core.Input },],
            "maxHeight": [{ type: core.Input },],
            "multiselectable": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-multiselectable',] },],
            "openOnFilterChange": [{ type: core.Input },],
            "pageSize": [{ type: core.Input },],
            "selectFirst": [{ type: core.Input },],
            "loadingTemplate": [{ type: core.Input },],
            "optionTemplate": [{ type: core.Input },],
            "noOptionsTemplate": [{ type: core.Input },],
            "optionSelected": [{ type: core.Output },],
            "highlightedChange": [{ type: core.Output },],
            "highlightedElementChange": [{ type: core.Output },],
            "_defaultLoadingTemplate": [{ type: core.ViewChild, args: ['defaultLoadingTemplate',] },],
            "_defaultOptionTemplate": [{ type: core.ViewChild, args: ['defaultOptionTemplate',] },],
            "_defaultNoOptionsTemplate": [{ type: core.ViewChild, args: ['defaultNoOptionsTemplate',] },],
            "mousedownHandler": [{ type: core.HostListener, args: ['mousedown',] },],
            "mouseupHandler": [{ type: core.HostListener, args: ['mouseup',] },],
        };
        return TypeaheadComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadButtonDirective = (function () {
        function InfiniteScrollLoadButtonDirective(_element, _template, _viewContainer, _renderer) {
            this._element = _element;
            this._template = _template;
            this._viewContainer = _viewContainer;
            this._renderer = _renderer;
            this._visible = false;
            this._load = new Subject.Subject();
            this.load = (this._load.asObservable());
        }
        Object.defineProperty(InfiniteScrollLoadButtonDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._template);
                        // Template content follows the elementRef, which is a comment.
                        var /** @type {?} */ clickTarget = this.getNextElementSibling(this._template.elementRef.nativeElement);
                        this._renderer.listen(clickTarget, 'click', this.onClick.bind(this));
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.onClick =
            function (event) {
                this._load.next(event);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.getNextElementSibling =
            function (element) {
                var /** @type {?} */ next = element;
                while (next = next.nextSibling) {
                    if (next.nodeType === 1) {
                        return next;
                    }
                }
                return null;
            };
        InfiniteScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoadButton]'
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollLoadButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.TemplateRef, },
                { type: core.ViewContainerRef, },
                { type: core.Renderer2, },
            ];
        };
        InfiniteScrollLoadButtonDirective.propDecorators = {
            "visible": [{ type: core.Input, args: ['uxInfiniteScrollLoadButton',] },],
            "load": [{ type: core.Output },],
        };
        return InfiniteScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadingDirective = (function () {
        function InfiniteScrollLoadingDirective(_templateRef, _viewContainer) {
            this._templateRef = _templateRef;
            this._viewContainer = _viewContainer;
            this._visible = false;
        }
        Object.defineProperty(InfiniteScrollLoadingDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._templateRef);
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        InfiniteScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoading]'
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollLoadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef, },
                { type: core.ViewContainerRef, },
            ];
        };
        InfiniteScrollLoadingDirective.propDecorators = {
            "visible": [{ type: core.Input, args: ['uxInfiniteScrollLoading',] },],
        };
        return InfiniteScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollDirective = (function () {
        function InfiniteScrollDirective(_element) {
            this._element = _element;
            this._collection = [];
            this.enabled = true;
            this.loadOnInit = true;
            this.loadOnScroll = true;
            this.pageSize = 20;
            this.collectionChange = new core.EventEmitter();
            this.loadingEvent = new core.EventEmitter();
            this.loadedEvent = new core.EventEmitter();
            this.loadErrorEvent = new core.EventEmitter();
            this._nextPageNum = 0;
            this._updateRequests = new Subject.Subject();
            this._isLoading = new BehaviorSubject.BehaviorSubject(false);
            this._isExhausted = new BehaviorSubject.BehaviorSubject(false);
            this._loadButtonEnabled = new BehaviorSubject.BehaviorSubject(false);
            this._subscriptions = [];
            this._loadButtonSubscriptions = [];
            this._onDestroy = new Subject.Subject();
            this._canLoadManually = this._isLoading.pipe(operators.combineLatest(this._isExhausted, this._loadButtonEnabled, function (isLoading, isExhausted, loadButtonEnabled) {
                return !isLoading && !isExhausted && loadButtonEnabled;
            }));
        }
        Object.defineProperty(InfiniteScrollDirective.prototype, "collection", {
            get: /**
             * @return {?}
             */ function () {
                return this._collection;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.collectionChange.emit(value);
                this._collection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollDirective.prototype, "scrollElement", {
            set: /**
             * @param {?} element
             * @return {?}
             */ function (element) {
                this._scrollElement = element instanceof core.ElementRef ? element : new core.ElementRef(element);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnInit =
            function () {
                if (!this._scrollElement) {
                    this._scrollElement = this._element;
                }
                this._loadButtonEnabled.next(!this.loadOnScroll);
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // There are two kinds of update requests: check and load.
                // Check requests are throttled and will only cause an update if more data is required
                // to fill the scrolling view, and it isn't already loading some.
                // Load requests are not throttled and always request a page of data.
                this._updateRequests.pipe(operators.filter(function (request) { return request.check; }), operators.auditTime(200), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                this._updateRequests.pipe(operators.filter(function (request) { return !request.check; }), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                if (this.enabled) {
                    // Subscribe to scroll events and DOM changes.
                    this.attachEventHandlers();
                }
                // Connect the Load More button visible state.
                this._canLoadManually.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (canLoad) {
                    _this._loadButtonQuery.forEach(function (loadButton) {
                        loadButton.visible = canLoad;
                    });
                });
                // Connect the loading indicator visible state.
                this._isLoading.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isLoading) {
                    _this._loadingIndicatorQuery.forEach(function (loading) {
                        loading.visible = isLoading;
                    });
                });
                // Link the Load More button click event to trigger an update.
                this.attachLoadButtonEvents();
                this._loadButtonQuery.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.attachLoadButtonEvents();
                });
                // Initial update.
                if (this.loadOnInit) {
                    this.loadNextPage();
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnChanges =
            function (changes) {
                var /** @type {?} */ check = true;
                if (changes["enabled"] && changes["enabled"].currentValue !== changes["enabled"].previousValue) {
                    if (changes["enabled"].currentValue) {
                        this.attachEventHandlers();
                        this.reset();
                        check = false;
                    }
                    else {
                        this.detachEventHandlers();
                    }
                }
                if (this.enabled) {
                    if (changes["filter"] && changes["filter"].currentValue !== changes["filter"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    if (changes["loadOnScroll"]) {
                        this._loadButtonEnabled.next(!changes["loadOnScroll"].currentValue);
                    }
                    if (changes["pageSize"] && changes["pageSize"].currentValue !== changes["pageSize"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    this._updateRequests.next({
                        check: check,
                        pageNumber: this._nextPageNum,
                        pageSize: this.pageSize,
                        filter: this.filter
                    });
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnDestroy =
            function () {
                this.detachEventHandlers();
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Request an additional page of data.
         */
        /**
         * Request an additional page of data.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.loadNextPage =
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         */
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.check =
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: true,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Clear the collection. Future requests will load from page 0.
         */
        /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reset =
            function () {
                if (!this.enabled) {
                    return;
                }
                // Reset the page counter.
                this._nextPageNum = 0;
                this._pages = [];
                // Clear the collection (without changing the reference).
                if (this.collection) {
                    this.collection.length = 0;
                }
                // Reset the exhausted flag, allowing the Load More button to appear.
                this._isExhausted.next(false);
                // Cancel any pending requests
                if (this._subscriptions) {
                    this._subscriptions.forEach(function (request) { return request.unsubscribe(); });
                }
            };
        /**
         * Reload the data without clearing the view.
         */
        /**
         * Reload the data without clearing the view.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reload =
            function () {
                var _this = this;
                this._pages.forEach(function (page, i) { return _this.reloadPage(i); });
            };
        /**
         * Reload the data in a specific page without clearing the view.
         * @param pageNum Page number
         */
        /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reloadPage =
            function (pageNum) {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: pageNum,
                    pageSize: this.pageSize,
                    filter: this.filter,
                    reload: true
                });
            };
        /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachEventHandlers =
            function () {
                // if the scrollElement is documentElement we must watch for a scroll event on the document
                var /** @type {?} */ target = this._scrollElement.nativeElement instanceof HTMLHtmlElement ? document : this._scrollElement.nativeElement;
                // Subscribe to the scroll event on the target element.
                this._scrollEventSub = fromEvent.fromEvent(target, 'scroll').subscribe(this.check.bind(this));
                // Subscribe to child DOM changes. The main effect of this is to check whether even more data is
                // required after the initial load.
                this._domObserver = new MutationObserver(this.check.bind(this));
                this._domObserver.observe(this._scrollElement.nativeElement, {
                    childList: true,
                    subtree: true
                });
            };
        /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.detachEventHandlers =
            function () {
                if (this._scrollEventSub) {
                    this._scrollEventSub.unsubscribe();
                    this._scrollEventSub = null;
                }
                if (this._domObserver) {
                    this._domObserver.disconnect();
                    this._domObserver = null;
                }
            };
        /**
         * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
         * for any in the query.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachLoadButtonEvents =
            function () {
                var _this = this;
                this._loadButtonSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._loadButtonSubscriptions = this._loadButtonQuery.map(function (loadButton) { return loadButton.load.subscribe(_this.loadNextPage.bind(_this)); });
            };
        /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.doRequest =
            function (request) {
                var _this = this;
                // Load a new page if the scroll position is beyond the threshhold and if the client code did not
                // cancel.
                if (this.needsData(request) && this.beginLoading(request)) {
                    // Invoke the callback load function, which returns a promose or plain data.
                    var /** @type {?} */ loadResult = this.load(request.pageNumber, request.pageSize, request.filter);
                    var /** @type {?} */ observable = Array.isArray(loadResult) ? of.of(loadResult) : from.from(loadResult);
                    var /** @type {?} */ subscription_1 = observable.pipe(operators.first()).subscribe(function (items) {
                        // Make sure that the parameters have not changed since the load started;
                        // otherwise discard the results.
                        if (request.filter === _this.filter && request.pageSize === _this.pageSize) {
                            if (items && items.length) {
                                _this.setPageItems(request.pageNumber, items);
                            }
                            // Emit the loaded event
                            // Emit the loaded event
                            _this.endLoading(request, items);
                        }
                    }, function (reason) {
                        // Emit the loadError event
                        // Emit the loadError event
                        _this.endLoadingWithError(request, reason);
                    }, function () {
                        // remove this request from the list
                        // remove this request from the list
                        _this._subscriptions = _this._subscriptions.filter(function (s) { return s !== subscription_1; });
                    });
                    // add the subscription to the list of requests
                    this._subscriptions.push(subscription_1);
                }
            };
        /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.needsData =
            function (request) {
                if (!this.enabled) {
                    return false;
                }
                // Always load for a load request
                if (!request.check) {
                    return true;
                }
                // Ignore a check request when the end of data has been detected, or if data is currently loading.
                if (this._isExhausted.getValue() || this._isLoading.getValue()) {
                    return false;
                }
                // Load if the remaining scroll area is <= the element height.
                if (this._scrollElement && this.loadOnScroll) {
                    var /** @type {?} */ element = (this._scrollElement.nativeElement);
                    var /** @type {?} */ remainingScroll = element.scrollHeight -
                        (element.scrollTop + element.clientHeight);
                    return remainingScroll <= element.clientHeight;
                }
                return false;
            };
        /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.beginLoading =
            function (request) {
                var /** @type {?} */ event = new InfiniteScrollLoadingEvent(request.pageNumber, request.pageSize, request.filter);
                this.loadingEvent.emit(event);
                this._isLoading.next(!event.defaultPrevented());
                return !event.defaultPrevented();
            };
        /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
        InfiniteScrollDirective.prototype.setPageItems =
            function (pageNum, items) {
                this._pages[pageNum] = items;
                this.collection = this._pages.reduce(function (previous, current) { return previous.concat(current); }, []);
            };
        /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoading =
            function (request, data) {
                this._isLoading.next(false);
                var /** @type {?} */ isExhausted = !!(data && data.length < this.pageSize);
                this._isExhausted.next(isExhausted);
                this.loadedEvent.emit(new InfiniteScrollLoadedEvent(request.pageNumber, request.pageSize, request.filter, data, isExhausted));
                if (!request.reload) {
                    this._nextPageNum += 1;
                }
            };
        /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoadingWithError =
            function (request, error) {
                this._isLoading.next(false);
                this.loadErrorEvent.emit(new InfiniteScrollLoadErrorEvent(request.pageNumber, request.pageSize, request.filter, error));
            };
        InfiniteScrollDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScroll]',
                        exportAs: 'uxInfiniteScroll'
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        InfiniteScrollDirective.propDecorators = {
            "load": [{ type: core.Input, args: ['uxInfiniteScroll',] },],
            "_collection": [{ type: core.Input, args: ['collection',] },],
            "scrollElement": [{ type: core.Input },],
            "enabled": [{ type: core.Input },],
            "filter": [{ type: core.Input },],
            "loadOnInit": [{ type: core.Input },],
            "loadOnScroll": [{ type: core.Input },],
            "pageSize": [{ type: core.Input },],
            "collectionChange": [{ type: core.Output },],
            "loadingEvent": [{ type: core.Output, args: ['loading',] },],
            "loadedEvent": [{ type: core.Output, args: ['loaded',] },],
            "loadErrorEvent": [{ type: core.Output, args: ['loadError',] },],
            "_loadButtonQuery": [{ type: core.ContentChildren, args: [InfiniteScrollLoadButtonDirective,] },],
            "_loadingIndicatorQuery": [{ type: core.ContentChildren, args: [InfiniteScrollLoadingDirective,] },],
        };
        return InfiniteScrollDirective;
    }());
    /**
     * Event raised before the `loading` function is called.
     */
    var /**
     * Event raised before the `loading` function is called.
     */ InfiniteScrollLoadingEvent = (function () {
        function InfiniteScrollLoadingEvent(pageNumber, pageSize, filter) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this._defaultPrevented = false;
        }
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         */
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.preventDefault =
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.defaultPrevented =
            function () {
                return this._defaultPrevented;
            };
        return InfiniteScrollLoadingEvent;
    }());
    /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */
    var /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */ InfiniteScrollLoadedEvent = (function () {
        function InfiniteScrollLoadedEvent(pageNumber, pageSize, filter, data, exhausted) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.data = data;
            this.exhausted = exhausted;
        }
        return InfiniteScrollLoadedEvent;
    }());
    /**
     * Event raised if the loading function returns a rejected promise.
     */
    var /**
     * Event raised if the loading function returns a rejected promise.
     */ InfiniteScrollLoadErrorEvent = (function () {
        function InfiniteScrollLoadErrorEvent(pageNumber, pageSize, filter, error) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.error = error;
        }
        return InfiniteScrollLoadErrorEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollModule = (function () {
        function InfiniteScrollModule() {
        }
        InfiniteScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        declarations: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollModule.ctorParameters = function () { return []; };
        return InfiniteScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewService = (function () {
        function ScrollIntoViewService() {
        }
        /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
        ScrollIntoViewService.prototype.scrollIntoView =
            function (elem, scrollParent) {
                var /** @type {?} */ offsetTop = (elem.getBoundingClientRect().top + scrollParent.scrollTop) - scrollParent.getBoundingClientRect().top;
                if (offsetTop < scrollParent.scrollTop) {
                    scrollParent.scrollTop = offsetTop;
                }
                else {
                    var /** @type {?} */ offsetBottom = offsetTop + elem.offsetHeight;
                    if (offsetBottom > (scrollParent.scrollTop + scrollParent.clientHeight)) {
                        scrollParent.scrollTop = offsetBottom - scrollParent.clientHeight;
                    }
                }
            };
        ScrollIntoViewService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ScrollIntoViewService.ctorParameters = function () { return []; };
        return ScrollIntoViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewIfDirective = (function () {
        function ScrollIntoViewIfDirective(_element, _scrollIntoViewService) {
            this._element = _element;
            this._scrollIntoViewService = _scrollIntoViewService;
            this.condition = false;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewIfDirective.prototype.ngOnChanges =
            function () {
                var _this = this;
                if (this.condition) {
                    setTimeout(function () { return _this._scrollIntoViewService.scrollIntoView(_this._element.nativeElement, _this.scrollParent); });
                }
            };
        ScrollIntoViewIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoViewIf]',
                        providers: [ScrollIntoViewService]
                    },] },
        ];
        /** @nocollapse */
        ScrollIntoViewIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ScrollIntoViewService, },
            ];
        };
        ScrollIntoViewIfDirective.propDecorators = {
            "condition": [{ type: core.Input, args: ['uxScrollIntoViewIf',] },],
            "scrollParent": [{ type: core.Input },],
        };
        return ScrollIntoViewIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewDirective = (function () {
        function ScrollIntoViewDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow a condition around whether or not this should scroll into view
             */
            this.uxScrollIntoView = true;
            /**
             * Allow user to provide the browser supported options
             */
            this.scrollIntoViewOptions = true;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewDirective.prototype.ngAfterViewInit =
            function () {
                if (this.uxScrollIntoView) {
                    this._elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
                }
            };
        ScrollIntoViewDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoView]'
                    },] },
        ];
        /** @nocollapse */
        ScrollIntoViewDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ScrollIntoViewDirective.propDecorators = {
            "uxScrollIntoView": [{ type: core.Input },],
            "scrollIntoViewOptions": [{ type: core.Input },],
        };
        return ScrollIntoViewDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollModule = (function () {
        function ScrollModule() {
        }
        ScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ScrollIntoViewIfDirective, ScrollIntoViewDirective],
                        declarations: [ScrollIntoViewIfDirective, ScrollIntoViewDirective]
                    },] },
        ];
        /** @nocollapse */
        ScrollModule.ctorParameters = function () { return []; };
        return ScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadHighlightDirective = (function () {
        function TypeaheadHighlightDirective(_service, _elementRef) {
            this._service = _service;
            this._elementRef = _elementRef;
        }
        Object.defineProperty(TypeaheadHighlightDirective.prototype, "highlight", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._service.highlightedElement$.next(this._elementRef.nativeElement);
                }
            },
            enumerable: true,
            configurable: true
        });
        TypeaheadHighlightDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTypeaheadHighlight]'
                    },] },
        ];
        /** @nocollapse */
        TypeaheadHighlightDirective.ctorParameters = function () {
            return [
                { type: TypeaheadService, },
                { type: core.ElementRef, },
            ];
        };
        TypeaheadHighlightDirective.propDecorators = {
            "highlight": [{ type: core.Input, args: ['uxTypeaheadHighlight',] },],
        };
        return TypeaheadHighlightDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadModule = (function () {
        function TypeaheadModule() {
        }
        TypeaheadModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            InfiniteScrollModule,
                            ScrollModule
                        ],
                        exports: [TypeaheadComponent],
                        declarations: [TypeaheadComponent, TypeaheadHighlightDirective],
                        providers: [TypeaheadKeyService],
                    },] },
        ];
        /** @nocollapse */
        TypeaheadModule.ctorParameters = function () { return []; };
        return TypeaheadModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$1 = 0;
    var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SelectComponent; }),
        multi: true
    };
    var SelectComponent = (function () {
        function SelectComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-select-" + ++uniqueId$1;
            this.allowNull = false;
            this.disabled = false;
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiple = false;
            this.pageSize = 20;
            this.valueChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.dropdownOpenChange = new core.EventEmitter();
            this.propagateChange = function (_) { };
            this._input$ = new BehaviorSubject.BehaviorSubject('');
            this._dropdownOpen = false;
            this._subscription = new Subscription.Subscription();
        }
        Object.defineProperty(SelectComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.valueChange.emit(value);
                this.propagateChange(value);
                // if we are not allow multiple selection update the input value (supporting ngModel)
                if (!this.multiple && value !== null) {
                    this.input = this.getDisplay(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input$.next(value);
                this.inputChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "dropdownOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._dropdownOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._dropdownOpen = value;
                this.dropdownOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnInit =
            function () {
                var _this = this;
                // Changes to the input field
                var /** @type {?} */ onInput = this._input$.pipe(operators.filter(function (value) { return _this.allowNull; }), operators.filter(function (value) { return !_this.multiple && value !== _this.getDisplay(_this.value); })).subscribe(function (value) { return _this.value = null; });
                // Set up filter from input
                this.filter$ = this._input$.pipe(operators.map(function (input) { return !_this.multiple && input === _this.getDisplay(_this.value) ? '' : input; }), operators.debounceTime(200));
                // Open the dropdown when filter is nonempty.
                var /** @type {?} */ onFilter = this.filter$.pipe(operators.filter(function (value) { return value && value.length > 0; })).subscribe(function () { return _this.dropdownOpen = true; });
                // store the subscriptions
                this._subscription.add(onInput);
                this._subscription.add(onFilter);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SelectComponent.prototype.ngOnChanges =
            function (changes) {
                if (changes["multiple"] && !changes["multiple"].firstChange && changes["multiple"].currentValue !== changes["multiple"].previousValue) {
                    this.input = '';
                }
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SelectComponent.prototype.writeValue =
            function (obj) {
                if (obj !== undefined && obj !== this._value) {
                    this.value = obj;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnChange =
            function (fn) {
                this.propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnTouched =
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SelectComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputClickHandler =
            function (event) {
                this.selectInputText();
                this.dropdownOpen = true;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputBlurHandler =
            function (event) {
                var _this = this;
                // If a click on the typeahead is in progress, just refocus the input.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.singleTypeahead && this.singleTypeahead.clicking) {
                    this.singleInput.nativeElement.focus();
                    return;
                }
                // Close dropdown and reset text input if focus is lost
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.dropdownOpen = false;
                        if (!_this.multiple) {
                            _this.input = _this.getDisplay(_this.value);
                        }
                    }
                }, 200);
            };
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         */
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputKeyHandler =
            function (event) {
                // Standard keys for typeahead (up/down/esc)
                this._typeaheadKeyService.handleKey(event, this.singleTypeahead);
                switch (event.key) {
                    case 'Enter':
                        if (this._dropdownOpen) {
                            // Set the highlighted option as the value and close
                            this.value = this.singleTypeahead.highlighted;
                            this.dropdownOpen = false;
                        }
                        // Update the input field. If dropdown isn't open then reset it to the previous value.
                        this.input = this.getDisplay(this.value);
                        event.preventDefault();
                        break;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.singleOptionSelected =
            function (event) {
                if (event.option) {
                    this.value = event.option;
                    this.dropdownOpen = false;
                }
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        SelectComponent.prototype.getDisplay =
            function (option) {
                if (option === null || option === undefined) {
                    return '';
                }
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.selectInputText =
            function () {
                this.singleInput.nativeElement.select();
            };
        SelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select',
                        template: "<ux-tag-input *ngIf=\"multiple\"\n    [id]=\"id + '-input'\"\n    [(tags)]=\"value\"\n    [(input)]=\"input\"\n    [addOnPaste]=\"false\"\n    [disabled]=\"disabled\"\n    [display]=\"display\"\n    [freeInput]=\"false\"\n    [placeholder]=\"placeholder\"\n    [showTypeaheadOnClick]=\"true\">\n\n    <ux-typeahead #multipleTypeahead\n        [id]=\"id + '-typeahead'\"\n        [options]=\"options\"\n        [filter]=\"filter$ | async\"\n        [(open)]=\"dropdownOpen\"\n        [display]=\"display\"\n        [key]=\"key\"\n        [disabledOptions]=\"value\"\n        [dropDirection]=\"dropDirection\"\n        [maxHeight]=\"maxHeight\"\n        [multiselectable]=\"true\"\n        [pageSize]=\"pageSize\"\n        [selectFirst]=\"true\"\n        [loadingTemplate]=\"loadingTemplate\"\n        [optionTemplate]=\"optionTemplate\"\n        [noOptionsTemplate]=\"noOptionsTemplate\">\n    </ux-typeahead>\n\n</ux-tag-input>\n\n<div *ngIf=\"!multiple\"\n    class=\"inner-addon right-addon\"\n    [class.disabled]=\"disabled\"\n    role=\"combobox\"\n    [attr.aria-expanded]=\"dropdownOpen\"\n    aria-haspopup=\"listbox\">\n\n    <i class=\"hpe-icon\"\n        [class.hpe-down]=\"dropDirection === 'down'\"\n        [class.hpe-up]=\"dropDirection === 'up'\"></i>\n\n    <input #singleInput type=\"text\" [attr.id]=\"id + '-input'\" class=\"form-control\"\n        [attr.aria-activedescendant]=\"highlightedElement?.id\"\n        aria-autocomplete=\"list\"\n        [attr.aria-controls]=\"singleTypeahead.id\"\n        aria-multiline=\"false\"\n        [(ngModel)]=\"input\"\n        [placeholder]=\"placeholder\"\n        [disabled]=\"disabled\"\n        (click)=\"inputClickHandler($event)\"\n        (blur)=\"inputBlurHandler($event)\"\n        (keydown)=\"inputKeyHandler($event)\">\n\n    <ux-typeahead #singleTypeahead\n        [id]=\"id + '-typeahead'\"\n        [options]=\"options\"\n        [filter]=\"filter$ | async\"\n        [(open)]=\"dropdownOpen\"\n        [display]=\"display\"\n        [key]=\"key\"\n        [dropDirection]=\"dropDirection\"\n        [maxHeight]=\"maxHeight\"\n        [multiselectable]=\"false\"\n        [openOnFilterChange]=\"false\"\n        [pageSize]=\"pageSize\"\n        [selectFirst]=\"true\"\n        [loadingTemplate]=\"loadingTemplate\"\n        [optionTemplate]=\"optionTemplate\"\n        [noOptionsTemplate]=\"noOptionsTemplate\"\n        (optionSelected)=\"singleOptionSelected($event)\"\n        (highlightedElementChange)=\"highlightedElement = $event\">\n    </ux-typeahead>\n\n</div>\n",
                        providers: [SELECT_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        SelectComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
                { type: TypeaheadKeyService, },
            ];
        };
        SelectComponent.propDecorators = {
            "id": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] },],
            "value": [{ type: core.Input },],
            "input": [{ type: core.Input },],
            "dropdownOpen": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "display": [{ type: core.Input },],
            "key": [{ type: core.Input },],
            "allowNull": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "dropDirection": [{ type: core.Input },],
            "maxHeight": [{ type: core.Input },],
            "multiple": [{ type: core.Input },],
            "pageSize": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "loadingTemplate": [{ type: core.Input },],
            "noOptionsTemplate": [{ type: core.Input },],
            "optionTemplate": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "inputChange": [{ type: core.Output },],
            "dropdownOpenChange": [{ type: core.Output },],
            "singleInput": [{ type: core.ViewChild, args: ['singleInput',] },],
            "multipleTypeahead": [{ type: core.ViewChild, args: ['multipleTypeahead',] },],
            "singleTypeahead": [{ type: core.ViewChild, args: ['singleTypeahead',] },],
        };
        return SelectComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputEvent = (function () {
        function TagInputEvent(tag) {
            this.tag = tag;
            this._defaultPrevented = false;
        }
        /**
         * @return {?}
         */
        TagInputEvent.prototype.preventDefault =
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        TagInputEvent.prototype.defaultPrevented =
            function () {
                return this._defaultPrevented;
            };
        return TagInputEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$2 = 0;
    var /** @type {?} */ TAGINPUT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var /** @type {?} */ TAGINPUT_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var TagInputComponent = (function () {
        function TagInputComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-tag-input-" + ++uniqueId$2;
            this.tagsChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.addOnPaste = true;
            this.disabled = false;
            this.enforceTagLimits = false;
            this.freeInput = true;
            this.maxTags = Number.MAX_VALUE;
            this.minTags = 0;
            this.placeholder = '';
            this.showTypeaheadOnClick = false;
            this.tagDelimiters = '';
            this.tagClass = function () { return undefined; };
            this.validationErrors = {};
            this.tagAdding = new core.EventEmitter();
            this.tagAdded = new core.EventEmitter();
            this.tagInvalidated = new core.EventEmitter();
            this.tagRemoving = new core.EventEmitter();
            this.tagRemoved = new core.EventEmitter();
            this.tagClick = new core.EventEmitter();
            this.selectedIndex = -1;
            this.tagApi = {
                getTagDisplay: this.getTagDisplay.bind(this),
                removeTagAt: this.removeTagAt.bind(this),
                canRemoveTagAt: this.canRemoveTagAt.bind(this)
            };
            this.valid = true;
            this.inputValid = true;
            this._input = '';
            this._tags = [];
            this._onChangeHandler = function () { };
            this._onTouchedHandler = function () { };
        }
        Object.defineProperty(TagInputComponent.prototype, "tags", {
            get: /**
             * @return {?}
             */ function () {
                if (!this._tags) {
                    this._tags = [];
                }
                return this._tags;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._tags = value;
                this._onChangeHandler(this._tags);
                this.tagsChange.emit(this._tags);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TagInputComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input = value;
                this.inputChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnInit =
            function () {
                if (!this.tagTemplate) {
                    this.tagTemplate = this._defaultTagTemplate;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // Watch for optional child typeahead control
                this.connectTypeahead(this.typeaheadQuery.first);
                this.typeaheadQuery.changes.subscribe(function (query) {
                    _this.connectTypeahead(query.first);
                });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        TagInputComponent.prototype.ngOnChanges =
            function (changes) {
                if (changes["disabled"]) {
                    if (changes["disabled"].currentValue) {
                        // Clear selection and close dropdown
                        this.selectedIndex = -1;
                        if (this.typeahead) {
                            this.typeahead.open = false;
                        }
                    }
                }
                // Update validation status
                this.validate();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TagInputComponent.prototype.writeValue =
            function (value) {
                if (value) {
                    this.tags = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnChange =
            function (fn) {
                this._onChangeHandler = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnTouched =
            function (fn) {
                this._onTouchedHandler = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TagInputComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnDestroy =
            function () {
                if (this._typeaheadSubscription) {
                    this._typeaheadSubscription.unsubscribe();
                }
            };
        /**
         * Validate the value of the control (tags property).
         */
        /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
        TagInputComponent.prototype.validate =
            function () {
                this.valid = true;
                var /** @type {?} */ tagRangeError = null;
                if (this.tags && (this.tags.length < this.minTags || this.tags.length > this.maxTags)) {
                    tagRangeError = {
                        given: this.tags.length,
                        min: this.minTags,
                        max: this.maxTags
                    };
                    this.valid = false;
                }
                this.validationErrors['tagRangeError'] = tagRangeError;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.keyHandler =
            function (event) {
                if (this.disabled) {
                    return;
                }
                // Get the input field cursor location
                var /** @type {?} */ inputCursorPos = this.tagInput.nativeElement.selectionStart;
                // Determine if the input field has any text selected
                var /** @type {?} */ hasSelection = this.tagInput.nativeElement.selectionStart !== this.tagInput.nativeElement.selectionEnd;
                // Determine if a tag has focus
                var /** @type {?} */ tagSelected = this.isValidTagIndex(this.selectedIndex);
                var /** @type {?} */ inputLength = this.input ? this.input.length : 0;
                // Check whether the arrow keys can move the selection. Otherwise the input field takes the event.
                var /** @type {?} */ canNavigateLeft = tagSelected || (inputCursorPos <= 0 && !hasSelection);
                var /** @type {?} */ canNavigateRight = tagSelected || (inputCursorPos >= inputLength && !hasSelection);
                // Forward key events to the typeahead component.
                this._typeaheadKeyService.handleKey(event, this.typeahead);
                switch (event.key) {
                    case 'Enter':
                        // Check if a typeahead option is highlighted
                        if (this.typeahead && this.typeahead.open && this.typeahead.highlighted) {
                            // Add the typeahead option as a tag, clear the input, and close the dropdown
                            this.commitTypeahead(this.typeahead.highlighted);
                            this.typeahead.open = false;
                        }
                        else {
                            // Validate and add the input text as a tag, if possible
                            this.commitInput();
                        }
                        event.preventDefault();
                        break;
                    case 'Backspace':
                        if (canNavigateLeft) {
                            this.backspace();
                            event.stopPropagation();
                            event.preventDefault();
                        }
                        break;
                    case 'Delete':
                    case 'Del':
                        if (tagSelected) {
                            this.removeTagAt(this.selectedIndex);
                        }
                        break;
                    case 'ArrowLeft':
                    case 'Left':
                        if (canNavigateLeft) {
                            this.moveSelection(-1);
                            event.preventDefault();
                        }
                        break;
                    case 'ArrowRight':
                    case 'Right':
                        if (canNavigateRight) {
                            this.moveSelection(1);
                            event.preventDefault();
                        }
                        break;
                }
                // Check for keys in the tagDelimiters
                if (this.tagDelimiters && this.tagDelimiters.indexOf(this.getKeyChar(event)) >= 0) {
                    // Commit previous text
                    this.commitInput();
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.focusOutHandler =
            function (event) {
                var _this = this;
                // If a click on the typeahead is in progress, don't do anything.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.typeahead && this.typeahead.clicking) {
                    return;
                }
                // Close the dropdown on blur
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.selectedIndex = -1;
                        if (_this.typeahead) {
                            _this.typeahead.open = false;
                        }
                    }
                }, 200);
            };
        /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.tagClickHandler =
            function (event, tag, index) {
                if (this.disabled) {
                    return;
                }
                // Send tagClick event
                var /** @type {?} */ tagClickEvent = new TagInputEvent(tag);
                this.tagClick.emit(tagClickEvent);
                // Prevent focus if preventDefault() was called
                if (tagClickEvent.defaultPrevented()) {
                    event.preventDefault();
                    return;
                }
                // Select the tag (for IE that doesn't propagate focus)
                this.selectTagAt(index);
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputClickHandler =
            function () {
                if (this.disabled) {
                    return;
                }
                if (this.typeahead && this.showTypeaheadOnClick) {
                    this.typeahead.open = true;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputFocusHandler =
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectInput();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.inputPasteHandler =
            function (event) {
                if (this.disabled) {
                    return;
                }
                if (this.addOnPaste) {
                    // Get text from the clipboard
                    var /** @type {?} */ input = null;
                    if (event.clipboardData) {
                        input = event.clipboardData.getData('text/plain');
                    }
                    else if (((window)).clipboardData) {
                        // Internet Explorer only
                        input = ((window)).clipboardData.getData('Text');
                    }
                    // Commit the clipboard text directly
                    if (this.commit(input)) {
                        this.selectInput();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.typeaheadOptionSelectedHandler =
            function (event) {
                if (this.disabled) {
                    return;
                }
                // When the typeahead sends the optionSelected event, commit the object directly
                this.commitTypeahead(event.option);
            };
        /**
         * Commit the current input value and clear the input field if successful.
         */
        /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
        TagInputComponent.prototype.commitInput =
            function () {
                if (this.commit(this.input)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given tag object and clear the input if successful.
         */
        /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.commitTypeahead =
            function (tag) {
                if (this.addTag(tag)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         */
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.commit =
            function (input) {
                if (input && this.freeInput) {
                    // Split the tags by the tagDelimiters if configured
                    var /** @type {?} */ newTags = this.splitTagInput(input);
                    // Check tag validation for all of the individual values
                    var /** @type {?} */ allValid = true;
                    try {
                        for (var newTags_1 = __values(newTags), newTags_1_1 = newTags_1.next(); !newTags_1_1.done; newTags_1_1 = newTags_1.next()) {
                            var newTag = newTags_1_1.value;
                            var /** @type {?} */ valid = this.validateTag(newTag);
                            if (!valid) {
                                allValid = false;
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (newTags_1_1 && !newTags_1_1.done && (_a = newTags_1.return))
                                _a.call(newTags_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    // Add the tags if all are valid
                    if (allValid) {
                        try {
                            for (var newTags_2 = __values(newTags), newTags_2_1 = newTags_2.next(); !newTags_2_1.done; newTags_2_1 = newTags_2.next()) {
                                var newTag = newTags_2_1.value;
                                this.addTag(this.createTag(newTag));
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (newTags_2_1 && !newTags_2_1.done && (_b = newTags_2.return))
                                    _b.call(newTags_2);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                        return true;
                    }
                }
                return false;
                var e_1, _a, e_2, _b;
            };
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         */
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
        TagInputComponent.prototype.backspace =
            function () {
                if (this.disabled) {
                    return;
                }
                if (!this.isValidTagIndex(this.selectedIndex)) {
                    this.selectTagAt(this.tags.length - 1);
                }
                else {
                    this.removeTagAt(this.selectedIndex);
                }
            };
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param d Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} d Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TagInputComponent.prototype.moveSelection =
            function (d) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidSelectIndex(this.selectedIndex)) {
                    this.selectedIndex += d;
                    // Do wrapping of selection when out of bounds
                    if (this.selectedIndex < 0) {
                        this.selectedIndex = this.tags.length;
                    }
                    else if (this.selectedIndex > this.tags.length) {
                        this.selectedIndex = 0;
                    }
                }
            };
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         */
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.getTagDisplay =
            function (tag) {
                if (typeof this.display === 'function') {
                    return this.display(tag);
                }
                if (typeof this.display === 'string') {
                    return tag[(this.display)];
                }
                return tag;
            };
        /**
         * Returns true if the given index is selected (tag index or input field).
         */
        /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isSelected =
            function (index) {
                return index === this.selectedIndex;
            };
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         */
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.selectTagAt =
            function (tagIndex) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidTagIndex(tagIndex)) {
                    this.selectedIndex = tagIndex;
                }
            };
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         */
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
        TagInputComponent.prototype.selectInput =
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectedIndex = this.tags.length;
            };
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         */
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.removeTagAt =
            function (tagIndex) {
                if (this.disabled || !this.canRemoveTagAt(tagIndex)) {
                    return;
                }
                // Check that the tagIndex is in range
                if (this.isValidTagIndex(tagIndex)) {
                    var /** @type {?} */ tag = this.tags[tagIndex];
                    var /** @type {?} */ tagRemovingEvent = new TagInputEvent(tag);
                    this.tagRemoving.emit(tagRemovingEvent);
                    if (!tagRemovingEvent.defaultPrevented()) {
                        // Select input first to avoid issues with dropping focus
                        this.selectInput();
                        // Remove the tag
                        this.tags.splice(tagIndex, 1);
                        // Set focus again since indices have changed
                        this.selectInput();
                        this.tagRemoved.emit(new TagInputEvent(tag));
                        this.validate();
                    }
                }
            };
        /**
         * Returns true if the tag at the given index can be removed.
         */
        /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.canRemoveTagAt =
            function (tagIndex) {
                return this.tags.length > this.minTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if the input field should be available.
         */
        /**
         * Returns true if the input field should be available.
         * @return {?}
         */
        TagInputComponent.prototype.isInputVisible =
            function () {
                return this.tags.length < this.maxTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if any part of the control has focus.
         */
        /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
        TagInputComponent.prototype.hasFocus =
            function () {
                return this.isValidSelectIndex(this.selectedIndex);
            };
        /**
         * @param {?} typeahead
         * @return {?}
         */
        TagInputComponent.prototype.connectTypeahead =
            function (typeahead$$1) {
                var _this = this;
                if (this._typeaheadSubscription) {
                    this._typeaheadSubscription.unsubscribe();
                    this._typeaheadSubscription = null;
                }
                this.typeahead = typeahead$$1;
                if (this.typeahead) {
                    // Set up event handler for selected options
                    this._typeaheadSubscription = this.typeahead.optionSelected.subscribe(this.typeaheadOptionSelectedHandler.bind(this));
                    // Set up event handler for the highlighted element
                    // Added a delay to move it out of the current change detection cycle
                    this._typeaheadSubscription.add(this.typeahead.highlightedElementChange.pipe(delay.delay(0)).subscribe(function (element) {
                        _this.highlightedElement = element;
                    }));
                }
            };
        /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.validateTag =
            function (tagValue) {
                var /** @type {?} */ inputPattern = null;
                this.inputValid = true;
                if (this.tagPattern && !this.tagPattern.test(tagValue)) {
                    inputPattern = {
                        given: tagValue,
                        pattern: this.tagPattern
                    };
                    this.inputValid = false;
                }
                this.validationErrors['inputPattern'] = inputPattern;
                return this.inputValid;
            };
        /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.createTag =
            function (tagValue) {
                var /** @type {?} */ tag = null;
                if (this.createTagHandler && typeof this.createTagHandler === 'function') {
                    tag = this.createTagHandler(tagValue);
                }
                else if (typeof this.display === 'string') {
                    tag = {};
                    tag[(this.display)] = tagValue;
                }
                else {
                    tag = tagValue;
                }
                return tag;
            };
        /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.addTag =
            function (tag) {
                if (tag) {
                    // Verify that the new tag can be displayed
                    var /** @type {?} */ displayValue = this.getTagDisplay(tag);
                    if (displayValue && typeof displayValue === 'string' && displayValue.length > 0) {
                        var /** @type {?} */ tagAddingEvent = new TagInputEvent(tag);
                        this.tagAdding.emit(tagAddingEvent);
                        if (!tagAddingEvent.defaultPrevented()) {
                            this.tags = this.tags || [];
                            this.tags.push(tag);
                            this.tagAdded.emit(new TagInputEvent(tag));
                            this.validate();
                            return true;
                        }
                    }
                }
                return false;
            };
        /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.isValidTagIndex =
            function (tagIndex) {
                return tagIndex >= 0 && tagIndex < this.tags.length;
            };
        /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isValidSelectIndex =
            function (index) {
                return index >= 0 && index <= this.tags.length;
            };
        /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.getKeyChar =
            function (event) {
                switch (event.key) {
                    case 'Spacebar':
                        return ' ';
                }
                return event.key;
            };
        /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.splitTagInput =
            function (input) {
                var /** @type {?} */ tagValues = [input];
                if (this.tagDelimiters && typeof this.tagDelimiters === 'string') {
                    var /** @type {?} */ escapedDelimiters = this.tagDelimiters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    var /** @type {?} */ delimiterRegex = new RegExp("[" + escapedDelimiters + "]", 'g');
                    tagValues = input.split(delimiterRegex).filter(function (s) { return s.length > 0; });
                }
                return tagValues;
            };
        TagInputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tag-input',
                        template: "<ol [attr.role]=\"typeahead ? 'combobox' : 'none'\" [attr.aria-haspopup]=\"typeahead ? 'listbox' : null\">\n    <li *ngFor=\"let tag of tags; let i = index\" class=\"ux-tag\"\n        [class.disabled]=\"disabled\"\n        [ngClass]=\"tagClass(tag, i, isSelected(i))\"\n        [attr.tabindex]=\"disabled ? null : 0\"\n        [focusIf]=\"isSelected(i)\"\n        (click)=\"tagClickHandler($event, tag, i)\"\n        (focus)=\"selectTagAt(i)\">\n\n        <ng-container [ngTemplateOutlet]=\"tagTemplate\"\n            [ngTemplateOutletContext]=\"{tag: tag, index: i, disabled: disabled, api: tagApi}\">\n        </ng-container>\n\n    </li>\n    <li *ngIf=\"isInputVisible()\" class=\"ux-tag-input\" role=\"none\">\n        <input #tagInput type=\"text\" [attr.id]=\"id\" class=\"ux-tag-input\"\n            [(ngModel)]=\"input\"\n            [class.invalid]=\"!inputValid\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            [attr.aria-autocomplete]=\"typeahead ? 'list' : 'none'\"\n            [attr.aria-controls]=\"typeahead?.id\"\n            aria-multiline=\"false\"\n            [placeholder]=\"disabled ? '' : (placeholder || '')\"\n            [disabled]=\"disabled\"\n            [focusIf]=\"isSelected(tags.length)\"\n            (click)=\"inputClickHandler()\"\n            (focus)=\"inputFocusHandler()\"\n            (paste)=\"inputPasteHandler($event)\">\n    </li>\n</ol>\n\n<ng-content #typeahead></ng-content>\n\n<ng-template #defaultTagTemplate let-tag=\"tag\" let-index=\"index\" let-disabled=\"disabled\" let-api=\"api\">\n    <span class=\"ux-tag-text\">{{api.getTagDisplay(tag)}}</span>\n    <button *ngIf=\"api.canRemoveTagAt(index)\"\n        type=\"button\"\n        class=\"ux-tag-remove\"\n        aria-label=\"Remove Item\"\n        [disabled]=\"disabled\"\n        (click)=\"api.removeTagAt(index); $event.stopPropagation();\">\n        <span class=\"hpe-icon hpe-close\"></span>\n    </button>\n</ng-template>",
                        providers: [TAGINPUT_VALUE_ACCESSOR, TAGINPUT_VALIDATOR],
                        host: {
                            '[class.disabled]': 'disabled',
                            '[class.focus]': 'hasFocus()',
                            '[class.invalid]': '!valid || !inputValid'
                        }
                    },] },
        ];
        /** @nocollapse */
        TagInputComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
                { type: TypeaheadKeyService, },
            ];
        };
        TagInputComponent.propDecorators = {
            "id": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] },],
            "tags": [{ type: core.Input, args: ['tags',] },],
            "tagsChange": [{ type: core.Output },],
            "input": [{ type: core.Input, args: ['input',] },],
            "inputChange": [{ type: core.Output },],
            "display": [{ type: core.Input },],
            "addOnPaste": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "enforceTagLimits": [{ type: core.Input },],
            "freeInput": [{ type: core.Input },],
            "maxTags": [{ type: core.Input },],
            "minTags": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "showTypeaheadOnClick": [{ type: core.Input },],
            "tagDelimiters": [{ type: core.Input },],
            "tagPattern": [{ type: core.Input },],
            "tagTemplate": [{ type: core.Input },],
            "tagClass": [{ type: core.Input },],
            "validationErrors": [{ type: core.Input },],
            "createTagHandler": [{ type: core.Input, args: ['createTag',] },],
            "tagAdding": [{ type: core.Output },],
            "tagAdded": [{ type: core.Output },],
            "tagInvalidated": [{ type: core.Output },],
            "tagRemoving": [{ type: core.Output },],
            "tagRemoved": [{ type: core.Output },],
            "tagClick": [{ type: core.Output },],
            "typeaheadQuery": [{ type: core.ContentChildren, args: [TypeaheadComponent,] },],
            "tagInput": [{ type: core.ViewChild, args: ['tagInput',] },],
            "_defaultTagTemplate": [{ type: core.ViewChild, args: ['defaultTagTemplate',] },],
            "keyHandler": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
            "focusOutHandler": [{ type: core.HostListener, args: ['focusout', ['$event'],] },],
        };
        return TagInputComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputModule = (function () {
        function TagInputModule() {
        }
        TagInputModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            FocusIfModule,
                            TypeaheadModule
                        ],
                        exports: [TagInputComponent],
                        declarations: [TagInputComponent],
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        TagInputModule.ctorParameters = function () { return []; };
        return TagInputModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectModule = (function () {
        function SelectModule() {
        }
        SelectModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            InfiniteScrollModule,
                            TagInputModule,
                            TypeaheadModule
                        ],
                        exports: [SelectComponent],
                        declarations: [SelectComponent]
                    },] },
        ];
        /** @nocollapse */
        SelectModule.ctorParameters = function () { return []; };
        return SelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderModule = (function () {
        function SearchBuilderModule() {
        }
        SearchBuilderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            DateTimePickerModule,
                            PopoverModule,
                            SelectModule
                        ],
                        exports: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            BaseSearchComponent
                        ],
                        declarations: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchBuilderOutletDirective,
                            SearchSelectComponent,
                            BaseSearchComponent
                        ],
                        entryComponents: [
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchSelectComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        SearchBuilderModule.ctorParameters = function () { return []; };
        return SearchBuilderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelCloseDirective = (function () {
        function SidePanelCloseDirective(_service) {
            this._service = _service;
        }
        /**
         * @return {?}
         */
        SidePanelCloseDirective.prototype.clickHandler =
            function () {
                this._service.close();
            };
        SidePanelCloseDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSidePanelClose]'
                    },] },
        ];
        /** @nocollapse */
        SidePanelCloseDirective.ctorParameters = function () {
            return [
                { type: SidePanelService, },
            ];
        };
        SidePanelCloseDirective.propDecorators = {
            "clickHandler": [{ type: core.HostListener, args: ['click',] },],
        };
        return SidePanelCloseDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS$1 = [
        SidePanelComponent,
        SidePanelCloseDirective
    ];
    var SidePanelModule = (function () {
        function SidePanelModule() {
        }
        SidePanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: EXPORTS$1,
                        declarations: EXPORTS$1
                    },] },
        ];
        /** @nocollapse */
        SidePanelModule.ctorParameters = function () { return []; };
        return SidePanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderComponent = (function () {
        function SliderComponent(colorService, _changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.value = 0;
            this.valueChange = new core.EventEmitter();
            // expose enums to Angular view
            this.sliderType = SliderType;
            this.sliderStyle = SliderStyle;
            this.sliderSize = SliderSize;
            this.sliderSnap = SliderSnap;
            this.sliderThumb = SliderThumb;
            this.sliderTickType = SliderTickType;
            this.sliderThumbEvent = SliderThumbEvent;
            this.sliderCalloutTrigger = SliderCalloutTrigger;
            this.tracks = {
                lower: {
                    size: 0,
                    color: ''
                },
                middle: {
                    size: 0,
                    color: ''
                },
                upper: {
                    size: 0,
                    color: ''
                }
            };
            this.tooltips = {
                lower: {
                    visible: false,
                    position: 0,
                    label: ''
                },
                upper: {
                    visible: false,
                    position: 0,
                    label: ''
                }
            };
            this.thumbs = {
                lower: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 100,
                    value: /** @type {?} */ (null)
                },
                upper: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 101,
                    value: /** @type {?} */ (null)
                }
            };
            // store all the ticks to display
            this.ticks = [];
            // setup default options
            this.defaultOptions = {
                type: SliderType.Value,
                handles: {
                    style: SliderStyle.Button,
                    callout: {
                        trigger: SliderCalloutTrigger.None,
                        background: colorService.getColor('grey2').toHex(),
                        color: '#fff',
                        formatter: function (value) { return value; }
                    },
                    keyboard: {
                        major: 5,
                        minor: 1
                    },
                    aria: {
                        thumb: 'Slider value',
                        lowerThumb: 'Slider lower value',
                        upperThumb: 'Slider upper value'
                    }
                },
                track: {
                    height: SliderSize.Wide,
                    min: 0,
                    max: 100,
                    ticks: {
                        snap: SliderSnap.None,
                        major: {
                            show: true,
                            steps: 10,
                            labels: true,
                            formatter: function (value) { return value; }
                        },
                        minor: {
                            show: true,
                            steps: 5,
                            labels: false,
                            formatter: function (value) { return value; }
                        }
                    },
                    colors: {
                        lower: colorService.getColor('grey6').toHex(),
                        range: colorService.getColor('accent').setAlpha(0.75).toRgba(),
                        higher: colorService.getColor('grey6').toHex()
                    }
                }
            };
        }
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnInit =
            function () {
                this.updateOptions();
                this.updateValues();
                this.setThumbState(SliderThumb.Lower, false, false);
                this.setThumbState(SliderThumb.Upper, false, false);
                // emit the initial value
                this.valueChange.next(this.clone(this.value));
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngDoCheck =
            function () {
                if (this.detectValueChange(this.value, this._value)) {
                    this.updateValues();
                    this._value = this.clone(this.value);
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                // persistent tooltips will need positioned correctly at this stage
                setTimeout(function () {
                    _this.updateTooltipPosition(SliderThumb.Lower);
                    _this.updateTooltipPosition(SliderThumb.Upper);
                    // mark as dirty
                    // mark as dirty
                    _this._changeDetectorRef.markForCheck();
                });
            };
        /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToNearestTick =
            function (thumb, snapTarget, forwards) {
                // get the value for the thumb
                var value = this.getThumbState(thumb).value;
                // get the closest ticks - remove any tick if we are currently on it
                var /** @type {?} */ closest = this.getTickDistances(value, thumb, snapTarget)
                    .filter(function (tick) { return tick.value !== value; })
                    .find(function (tick) { return forwards ? tick.value > value : tick.value < value; });
                // If we have no ticks then move by a predefined amount
                if (closest) {
                    return this.setThumbValue(thumb, this.validateValue(thumb, closest.value));
                }
                var /** @type {?} */ step = snapTarget === SliderSnap.Major ? this.options.handles.keyboard.major : this.options.handles.keyboard.minor;
                this.setThumbValue(thumb, this.validateValue(thumb, value + (forwards ? step : -step)));
            };
        /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToEnd =
            function (thumb, forwards) {
                this.setThumbValue(thumb, this.validateValue(thumb, forwards ? this.options.track.max : this.options.track.min));
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbValue =
            function (thumb) {
                return this.getThumbState(thumb).value;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getFormattedValue =
            function (thumb) {
                return this.options.handles.callout.formatter(this.getThumbState(thumb).value);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbState =
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.thumbs.lower : this.thumbs.upper;
            };
        /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
        SliderComponent.prototype.setThumbState =
            function (thumb, hover, drag) {
                if (thumb === SliderThumb.Lower) {
                    this.thumbs.lower.hover = hover;
                    this.thumbs.lower.drag = drag;
                }
                else {
                    this.thumbs.upper.hover = hover;
                    this.thumbs.upper.drag = drag;
                }
                // update the visibility of the tooltips
                this.updateTooltips(thumb);
            };
        /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.thumbEvent =
            function (thumb, event) {
                // get the current thumb state
                var /** @type {?} */ state = this.getThumbState(thumb);
                // update based upon event
                switch (event) {
                    case SliderThumbEvent.DragStart:
                        state.drag = true;
                        break;
                    case SliderThumbEvent.DragEnd:
                        state.drag = false;
                        break;
                    case SliderThumbEvent.MouseOver:
                        state.hover = true;
                        break;
                    case SliderThumbEvent.MouseLeave:
                        state.hover = false;
                        break;
                    case SliderThumbEvent.None:
                        state.drag = false;
                        state.hover = false;
                        break;
                }
                // update the thumb state
                this.setThumbState(thumb, state.hover, state.drag);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getAriaValueText =
            function (thumb) {
                // get the current thumb value
                var /** @type {?} */ value = this.getThumbValue(thumb);
                // get all the ticks
                var /** @type {?} */ tick = this.ticks.find(function (_tick) { return _tick.value === value; });
                if (tick && tick.label) {
                    return tick.label;
                }
                // otherwise simply display the formatted value
                return this.getFormattedValue(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltips =
            function (thumb) {
                var /** @type {?} */ visible = false;
                var /** @type {?} */ state = this.getThumbState(thumb);
                switch (this.options.handles.callout.trigger) {
                    case SliderCalloutTrigger.Persistent:
                        visible = true;
                        break;
                    case SliderCalloutTrigger.Drag:
                        visible = state.drag;
                        break;
                    case SliderCalloutTrigger.Hover:
                        visible = state.hover || state.drag;
                        break;
                    case SliderCalloutTrigger.Dynamic:
                        visible = true;
                        break;
                }
                // update the state for the corresponding thumb
                this.getTooltip(thumb).visible = visible;
                // update the tooltip text
                this.updateTooltipText(thumb);
                // update the tooltip positions
                this.updateTooltipPosition(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipText =
            function (thumb) {
                // get the thumb value
                var /** @type {?} */ state = this.getThumbState(thumb);
                var /** @type {?} */ tooltip$$1 = this.getTooltip(thumb);
                // store the formatted label
                tooltip$$1.label = this.getFormattedValue(thumb).toString();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltipElement =
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.lowerTooltip : this.upperTooltip;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltip =
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.tooltips.lower : this.tooltips.upper;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipPosition =
            function (thumb) {
                var /** @type {?} */ tooltip$$1 = this.getTooltip(thumb);
                // if tooltip is not visible then stop here
                if (tooltip$$1.visible === false) {
                    return;
                }
                var /** @type {?} */ tooltipElement = this.getTooltipElement(thumb);
                // get the element widths
                var /** @type {?} */ thumbWidth;
                if (this.options.handles.style === SliderStyle.Button) {
                    thumbWidth = this.options.track.height === SliderSize.Narrow ? 16 : 24;
                }
                else {
                    thumbWidth = 2;
                }
                var /** @type {?} */ tooltipWidth = tooltipElement.nativeElement.offsetWidth;
                // calculate the tooltips new position
                var /** @type {?} */ tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);
                // update tooltip position
                tooltip$$1.position = -tooltipPosition;
                if (this.options.type === SliderType.Range && this.options.handles.callout.trigger === SliderCalloutTrigger.Dynamic) {
                    this.preventTooltipOverlap(tooltip$$1);
                }
            };
        /**
         * @param {?} tooltip
         * @return {?}
         */
        SliderComponent.prototype.preventTooltipOverlap =
            function (tooltip$$1) {
                var /** @type {?} */ trackWidth = this.track.nativeElement.offsetWidth;
                var /** @type {?} */ lower = (trackWidth / 100) * this.thumbs.lower.position;
                var /** @type {?} */ upper = (trackWidth / 100) * this.thumbs.upper.position;
                var /** @type {?} */ lowerWidth = this.lowerTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ upperWidth = this.upperTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ diff = (lower + lowerWidth) - (upper - upperWidth);
                // if the tooltips are closer than 16px then adjust so the dont move any close
                if (diff > 0) {
                    if (tooltip$$1 === this.tooltips.lower && this.thumbs.lower.drag === false) {
                        tooltip$$1.position -= (diff / 2);
                    }
                    else if (tooltip$$1 === this.tooltips.upper && this.thumbs.upper.drag === false) {
                        tooltip$$1.position += (diff / 2);
                    }
                }
            };
        /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
        SliderComponent.prototype.clamp =
            function (value, min, max) {
                return Math.min(Math.max(value, min), max);
            };
        /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateThumbPosition =
            function (event, thumb) {
                // get event position - either mouse or touch
                var /** @type {?} */ eventPosition = event instanceof MouseEvent ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;
                // if event position is null do nothing
                if (eventPosition === null) {
                    return;
                }
                // get mouse position
                var /** @type {?} */ mouseX = window.pageXOffset + eventPosition;
                // get track size and position
                var /** @type {?} */ trackBounds = this.track.nativeElement.getBoundingClientRect();
                // restrict the value within the range size
                var /** @type {?} */ position = this.clamp(mouseX - trackBounds.left, 0, trackBounds.width);
                // get fraction representation of location within the track
                var /** @type {?} */ fraction = (position / trackBounds.width);
                // convert to value within the range
                var /** @type {?} */ value = ((this.options.track.max - this.options.track.min) * fraction) + this.options.track.min;
                // ensure value is valid
                value = this.validateValue(thumb, value);
                // snap to a tick if required
                value = this.snapToTick(value, thumb);
                // update the value accordingly
                this.setThumbValue(thumb, value);
                this.updateOrder(thumb);
                this.updateValues();
                // update tooltip text & position
                this.updateTooltipText(thumb);
                // update the position of all visible tooltips
                this.updateTooltipPosition(SliderThumb.Lower);
                this.updateTooltipPosition(SliderThumb.Upper);
                // mark as dirty for change detection
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateOrder =
            function (thumb) {
                var /** @type {?} */ lower = thumb === SliderThumb.Lower ? 101 : 100;
                var /** @type {?} */ upper = thumb === SliderThumb.Lower ? 100 : 101;
                // The most recently used thumb should be above
                this.thumbs.lower.order = lower;
                this.thumbs.upper.order = upper;
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
        SliderComponent.prototype.getTickDistances =
            function (value, thumb, snapTarget) {
                // if snap target is none then return original value
                if (snapTarget === SliderSnap.None) {
                    return [];
                }
                // get filtered ticks
                var /** @type {?} */ ticks;
                switch (snapTarget) {
                    case SliderSnap.Minor:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Minor; });
                        break;
                    case SliderSnap.Major:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Major; });
                        break;
                    default:
                        ticks = this.ticks.slice(0);
                }
                // get the track limit
                var /** @type {?} */ lowerLimit = this.options.track.min;
                var /** @type {?} */ upperLimit = this.options.track.max;
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Lower) {
                    upperLimit = this.thumbs.upper.value;
                }
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Upper) {
                    lowerLimit = this.thumbs.lower.value;
                }
                // Find the closest tick to the current position
                var /** @type {?} */ range = ticks.filter(function (tick) { return tick.value >= lowerLimit && tick.value <= upperLimit; });
                // If there are no close ticks in the valid range then dont snap
                if (range.length === 0) {
                    return [];
                }
                return range.sort(function (tickOne, tickTwo) {
                    var /** @type {?} */ tickOneDelta = Math.max(tickOne.value, value) - Math.min(tickOne.value, value);
                    var /** @type {?} */ tickTwoDelta = Math.max(tickTwo.value, value) - Math.min(tickTwo.value, value);
                    return tickOneDelta - tickTwoDelta;
                });
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.snapToTick =
            function (value, thumb) {
                var /** @type {?} */ tickDistances = this.getTickDistances(value, thumb, this.options.track.ticks.snap);
                // if there are no ticks return the current value
                if (tickDistances.length === 0) {
                    return value;
                }
                // get the closest tick
                return tickDistances[0].value;
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.validateValue =
            function (thumb, value) {
                // if slider is not a range value is always valid providing it is within the chart min and max values
                if (this.options.type === SliderType.Value) {
                    return Math.max(Math.min(value, this.options.track.max), this.options.track.min);
                }
                // check if value is with chart ranges
                if (value > this.options.track.max) {
                    return thumb === SliderThumb.Lower ? Math.min(this.options.track.max, this.thumbs.upper.value) : this.options.track.max;
                }
                if (value < this.options.track.min) {
                    return thumb === SliderThumb.Upper ? Math.max(this.options.track.min, this.thumbs.lower.value) : this.options.track.min;
                }
                // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
                if (thumb === SliderThumb.Lower) {
                    if (this.thumbs.upper.value === null) {
                        return value;
                    }
                    return value <= this.thumbs.upper.value ? value : this.thumbs.upper.value;
                }
                if (thumb === SliderThumb.Upper) {
                    if (this.thumbs.lower.value === null) {
                        return value;
                    }
                    return value >= this.thumbs.lower.value ? value : this.thumbs.lower.value;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateOptions =
            function () {
                // add in the default options that user hasn't specified
                this.options = this.deepMerge(this.options || {}, this.defaultOptions);
                this.updateTrackColors();
                this.updateTicks();
                this.updateValues();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateValues =
            function () {
                if (this.value === undefined || this.value === null) {
                    this.value = 0;
                }
                var /** @type {?} */ lowerValue = typeof this.value === 'number' ? this.value : this.value.low;
                var /** @type {?} */ upperValue = typeof this.value === 'number' ? this.value : this.value.high;
                // validate values
                lowerValue = this.validateValue(SliderThumb.Lower, Number(lowerValue.toFixed(4)));
                upperValue = this.validateValue(SliderThumb.Upper, Number(upperValue.toFixed(4)));
                // calculate the positions as percentages
                var /** @type {?} */ lowerPosition = (((lowerValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                var /** @type {?} */ upperPosition = (((upperValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                // update thumb positions
                this.thumbs.lower.position = lowerPosition;
                this.thumbs.upper.position = upperPosition;
                // calculate the track sizes
                this.tracks.lower.size = lowerPosition;
                this.tracks.middle.size = upperPosition - lowerPosition;
                this.tracks.upper.size = this.options.type === SliderType.Value ? 100 - lowerPosition : 100 - upperPosition;
                // update the value input
                this.setValue(lowerValue, upperValue);
            };
        /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
        SliderComponent.prototype.setValue =
            function (low, high) {
                this.thumbs.lower.value = low;
                this.thumbs.upper.value = high;
                var /** @type {?} */ previousValue = this.clone(this._value);
                this.value = this.options.type === SliderType.Value ? low : { low: low, high: high };
                // call the event emitter if changes occured
                if (this.detectValueChange(this.value, previousValue)) {
                    this.valueChange.emit(this.clone(this.value));
                    this.updateTooltipText(SliderThumb.Lower);
                    this.updateTooltipText(SliderThumb.Upper);
                }
                else {
                    this.valueChange.emit(this.clone(this.value));
                }
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.setThumbValue =
            function (thumb, value) {
                // update the thumb value
                this.getThumbState(thumb).value = value;
                // forward these changes to the value
                this.setValue(this.thumbs.lower.value, this.thumbs.upper.value);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTicks =
            function () {
                // get tick options
                var /** @type {?} */ majorOptions = this.options.track.ticks.major;
                var /** @type {?} */ minorOptions = this.options.track.ticks.minor;
                // check if we should show ticks
                if (majorOptions.show === false && minorOptions.show === false) {
                    this.ticks = [];
                }
                // create ticks for both major and minor - only get the ones to be shown
                var /** @type {?} */ majorTicks = this.getTicks(majorOptions, SliderTickType.Major).filter(function (tick) { return tick.showTicks; });
                var /** @type {?} */ minorTicks = this.getTicks(minorOptions, SliderTickType.Minor).filter(function (tick) { return tick.showTicks; });
                // remove any minor ticks that are on a major interval
                this.ticks = this.unionTicks(majorTicks, minorTicks);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTrackColors =
            function () {
                // get colors for each part of the track
                var _a = this.options.track.colors, lower = _a.lower, range = _a.range, higher = _a.higher;
                // update the controller value
                this.tracks.lower.color = typeof lower === 'string' ? lower : "linear-gradient(to right, " + lower.join(', ') + ")";
                this.tracks.middle.color = typeof range === 'string' ? range : "linear-gradient(to right, " + range.join(', ') + ")";
                this.tracks.upper.color = typeof higher === 'string' ? higher : "linear-gradient(to right, " + higher.join(', ') + ")";
            };
        /**
         * @param {?} steps
         * @return {?}
         */
        SliderComponent.prototype.getSteps =
            function (steps) {
                // if they are already an array just return it
                if (steps instanceof Array) {
                    return steps;
                }
                var /** @type {?} */ output = [];
                // otherwise calculate the steps
                for (var /** @type {?} */ idx = this.options.track.min; idx <= this.options.track.max; idx += steps) {
                    output.push(idx);
                }
                return output;
            };
        /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
        SliderComponent.prototype.getTicks =
            function (options, type) {
                // create an array to store the ticks and step points
                var /** @type {?} */ steps = this.getSteps(options.steps);
                // get some chart options
                var /** @type {?} */ min = this.options.track.min;
                var /** @type {?} */ max = this.options.track.max;
                // convert each step to a slider tick and remove invalid ticks
                return steps.map(function (step) {
                    return {
                        showTicks: options.show,
                        showLabels: options.labels,
                        type: type,
                        position: ((step - min) / (max - min)) * 100,
                        value: step,
                        label: options.formatter(step)
                    };
                }).filter(function (tick) { return tick.position >= 0 && tick.position <= 100; });
            };
        /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
        SliderComponent.prototype.unionTicks =
            function (majorTicks, minorTicks) {
                // get all ticks combined removing any minor ticks with the same value as major ticks
                return majorTicks.concat(minorTicks)
                    .filter(function (tick, index, array) { return tick.type === SliderTickType.Major || !array.find(function (tk) { return tk.type === SliderTickType.Major && tk.position === tick.position; }); })
                    .sort(function (t1, t2) { return t1.value - t2.value; });
            };
        /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
        SliderComponent.prototype.deepMerge =
            function (destination, source) {
                // loop though all of the properties in the source object
                for (var /** @type {?} */ prop in source) {
                    // check if the destination object has the property
                    if (!destination.hasOwnProperty(prop)) {
                        // copy the property across
                        destination[prop] = source[prop];
                        continue;
                    }
                    // if the property exists and is not an object then skip
                    if (typeof destination[prop] !== 'object') {
                        continue;
                    }
                    // check if property is an array
                    if (destination[prop] instanceof Array) {
                        continue;
                    }
                    // if it is an object then perform a recursive check
                    destination[prop] = this.deepMerge(destination[prop], source[prop]);
                }
                return destination;
            };
        /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
        SliderComponent.prototype.detectValueChange =
            function (value1, value2) {
                // compare two slider values
                if (this.isSliderValue(value1) && this.isSliderValue(value2)) {
                    // references to the objects in the correct types
                    var /** @type {?} */ obj1 = (value1);
                    var /** @type {?} */ obj2 = (value2);
                    return obj1.low !== obj2.low || obj1.high !== obj2.high;
                }
                // if not a slider value - should be number of nullable type - compare normally
                return value1 !== value2;
            };
        /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
        SliderComponent.prototype.isSliderValue =
            function (value) {
                // check if is an object
                if (typeof value !== 'object') {
                    return false;
                }
                // next check if it contains the necessary properties
                return 'low' in value && 'high' in value;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.clone =
            function (value) {
                // if it is not an object simply return the value
                if (typeof value !== 'object') {
                    return value;
                }
                // create a new object from the existing one
                var /** @type {?} */ instance = __assign({}, value);
                // delete remove the value from the old object
                value = undefined;
                // return the new instance of the object
                return instance;
            };
        SliderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-slider',
                        template: "<div class=\"track\" #track [class.narrow]=\"options.track.height === sliderSize.Narrow\" [class.wide]=\"options.track.height === sliderSize.Wide\" [class.range]=\"options.type === sliderType.Range\">\n\n    <!-- Section Beneath Lower Thumb -->\n    <div class=\"track-section track-lower\" [style.flex-grow]=\"tracks.lower.size\" [style.background]=\"tracks.lower.color\"></div>\n\n    <!-- Lower Thumb Button / Line -->\n    <div class=\"thumb lower\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #lowerthumb\n        [attr.aria-label]=\"options.type === sliderType.Range ? options.handles.aria.lowerThumb : options.handles.aria.thumb\"\n        [attr.aria-valuemin]=\"options?.track?.min\"\n        [attr.aria-valuemax]=\"options.type === sliderType.Range ? getThumbValue(sliderThumb.Upper) : options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Lower)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Lower)\"\n        [style.left.%]=\"thumbs.lower.position\"\n        [class.active]=\"thumbs.lower.drag\"\n        [style.z-index]=\"thumbs.lower.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (dragstart)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragStart); lowerthumb.focus()\"\n        (drag)=\"updateThumbPosition($event, sliderThumb.Lower)\"\n        (dragend)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Lower, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Lower, true); $event.preventDefault()\">\n\n        <!-- Lower Thumb Callout -->\n        <div class=\"tooltip top tooltip-lower\" #lowerTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.lower.drag === false\"\n            [style.opacity]=\"tooltips.lower.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.lower.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.lower.label }}\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Section of Track Between Lower and Upper Thumbs -->\n    <div class=\"track-section track-range\" *ngIf=\"options.type === sliderType.Range\" [style.flex-grow]=\"tracks.middle.size\" [style.background]=\"tracks.middle.color\">\n    </div>\n\n    <!-- Upper Thumb Button / Line -->\n    <div class=\"thumb upper\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #upperthumb\n        [attr.aria-label]=\"options.handles.aria.upperThumb\"\n        [attr.aria-valuemin]=\"getThumbValue(sliderThumb.Lower) || options?.track?.min\"\n        [attr.aria-valuemax]=\"options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Upper)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Upper)\"\n        [hidden]=\"options.type !== sliderType.Range\"\n        [class.active]=\"thumbs.upper.drag\"\n        [style.left.%]=\"thumbs.upper.position\"\n        [style.z-index]=\"thumbs.upper.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (dragstart)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragStart); upperthumb.focus()\"\n        (drag)=\"updateThumbPosition($event, sliderThumb.Upper)\"\n        (dragend)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Upper, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Upper, true); $event.preventDefault()\">\n\n        <!-- Upper Thumb Callout -->\n        <div class=\"tooltip top tooltip-upper\" #upperTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.upper.drag === false\"\n            [style.opacity]=\"tooltips.upper.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.upper.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                *ngIf=\"options.type === sliderType.Range\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.upper.label }}\n            </div>\n        </div>\n    </div>\n\n    <!-- Section of Track Abover Upper Thumb -->\n    <div class=\"track-section track-higher\" [style.flex-grow]=\"tracks.upper.size\" [style.background]=\"tracks.upper.color\"></div>\n\n</div>\n\n<!-- Chart Ticks and Tick Labels -->\n<div class=\"tick-container\"\n    role=\"presentation\"\n    *ngIf=\"(options.track.ticks.major.show || options.track.ticks.minor.show) && options.handles.callout.trigger !== sliderCalloutTrigger.Dynamic\"\n    [class.show-labels]=\"options.track.ticks.major.labels || options.track.ticks.minor.labels\">\n\n    <div class=\"tick\"\n        *ngFor=\"let tick of ticks\"\n        [class.major]=\"tick.type === sliderTickType.Major\"\n        [class.minor]=\"tick.type === sliderTickType.Minor\"\n        [style.left.%]=\"tick.position\"\n        [hidden]=\"!tick.showTicks\">\n\n        <div class=\"tick-indicator\"></div>\n        <div class=\"tick-label\" aria-hidden=\"true\" [hidden]=\"!tick.showLabels\">{{ tick.label }}</div>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        SliderComponent.ctorParameters = function () {
            return [
                { type: ColorService, },
                { type: core.ChangeDetectorRef, },
            ];
        };
        SliderComponent.propDecorators = {
            "value": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "valueChange": [{ type: core.Output },],
            "lowerTooltip": [{ type: core.ViewChild, args: ['lowerTooltip',] },],
            "upperTooltip": [{ type: core.ViewChild, args: ['upperTooltip',] },],
            "track": [{ type: core.ViewChild, args: ['track',] },],
        };
        return SliderComponent;
    }());
    /** @enum {number} */
    var SliderType = {
        Value: 0,
        Range: 1,
    };
    SliderType[SliderType.Value] = "Value";
    SliderType[SliderType.Range] = "Range";
    /** @enum {number} */
    var SliderStyle = {
        Button: 0,
        Line: 1,
    };
    SliderStyle[SliderStyle.Button] = "Button";
    SliderStyle[SliderStyle.Line] = "Line";
    /** @enum {number} */
    var SliderSize = {
        Narrow: 0,
        Wide: 1,
    };
    SliderSize[SliderSize.Narrow] = "Narrow";
    SliderSize[SliderSize.Wide] = "Wide";
    /** @enum {number} */
    var SliderCalloutTrigger = {
        None: 0,
        Hover: 1,
        Drag: 2,
        Persistent: 3,
        Dynamic: 4,
    };
    SliderCalloutTrigger[SliderCalloutTrigger.None] = "None";
    SliderCalloutTrigger[SliderCalloutTrigger.Hover] = "Hover";
    SliderCalloutTrigger[SliderCalloutTrigger.Drag] = "Drag";
    SliderCalloutTrigger[SliderCalloutTrigger.Persistent] = "Persistent";
    SliderCalloutTrigger[SliderCalloutTrigger.Dynamic] = "Dynamic";
    /** @enum {number} */
    var SliderSnap = {
        None: 0,
        Minor: 1,
        Major: 2,
        All: 3,
    };
    SliderSnap[SliderSnap.None] = "None";
    SliderSnap[SliderSnap.Minor] = "Minor";
    SliderSnap[SliderSnap.Major] = "Major";
    SliderSnap[SliderSnap.All] = "All";
    /** @enum {number} */
    var SliderTickType = {
        Minor: 0,
        Major: 1,
    };
    SliderTickType[SliderTickType.Minor] = "Minor";
    SliderTickType[SliderTickType.Major] = "Major";
    /** @enum {number} */
    var SliderThumbEvent = {
        None: 0,
        MouseOver: 1,
        MouseLeave: 2,
        DragStart: 3,
        DragEnd: 4,
    };
    SliderThumbEvent[SliderThumbEvent.None] = "None";
    SliderThumbEvent[SliderThumbEvent.MouseOver] = "MouseOver";
    SliderThumbEvent[SliderThumbEvent.MouseLeave] = "MouseLeave";
    SliderThumbEvent[SliderThumbEvent.DragStart] = "DragStart";
    SliderThumbEvent[SliderThumbEvent.DragEnd] = "DragEnd";
    /** @enum {number} */
    var SliderThumb = {
        Lower: 0,
        Upper: 1,
    };
    SliderThumb[SliderThumb.Lower] = "Lower";
    SliderThumb[SliderThumb.Upper] = "Upper";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderModule = (function () {
        function SliderModule() {
        }
        SliderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            DragModule
                        ],
                        exports: [SliderComponent],
                        declarations: [SliderComponent]
                    },] },
        ];
        /** @nocollapse */
        SliderModule.ctorParameters = function () { return []; };
        return SliderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkComponent = (function () {
        function SparkComponent(_colorService) {
            this._colorService = _colorService;
            this.values = [];
            this.barHeight = 10;
            this._theme = 'primary';
            this._barColor = [];
        }
        Object.defineProperty(SparkComponent.prototype, "theme", {
            get: /**
             * @return {?}
             */ function () {
                return this._theme;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._theme = this._colorService.resolveColorName(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "trackColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._trackColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._trackColor = this._colorService.resolve(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "barColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._barColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (Array.isArray(value)) {
                    this._barColor = value.map(function (color) { return _this._colorService.resolve(color); });
                }
                else {
                    this._barColor = [this._colorService.resolve(value)];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.values;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // ensure 'value' is an array at this point
                var /** @type {?} */ values = Array.isArray(value) ? value : [value];
                // get the total value of all lines
                var /** @type {?} */ total = Math.max(values.reduce(function (previous, current) { return previous + current; }, 0), 100);
                // figure out the percentages for each spark line
                this.values = values.map(function (val) { return (val / total) * 100; });
            },
            enumerable: true,
            configurable: true
        });
        SparkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spark',
                        template: "<!-- Inline Spark Chart -->\n<div *ngIf=\"inlineLabel\" class=\"ux-spark-inline-label-container\">\n\n    <div class=\"ux-spark-inline-label-left\" [innerHtml]=\"inlineLabel\"></div>\n\n    <div class=\"ux-spark-line\">\n\n        <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n            <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n            <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n        </div>\n\n        <div class=\"ux-spark ux-inline ux-spark-theme-{{theme}}\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\" [uxTooltip]=\"tooltip\">\n            <div class=\"ux-spark-bar\" *ngFor=\"let line of values; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n        </div>\n\n        <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n            <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n            <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n        </div>\n\n    </div>\n</div>\n\n<!-- End Inline Spark Chart -->\n\n\n<!-- Non Inline Spark Chart -->\n<div *ngIf=\"!inlineLabel\">\n\n    <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n        <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n        <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n    </div>\n\n    <div class=\"ux-spark ux-spark-theme-{{theme}}\" [class.ux-spark-multi-value]=\"values.length > 1\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\"\n        [uxTooltip]=\"tooltip\">\n        <div class=\"ux-spark-bar\" *ngFor=\"let line of value; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n    </div>\n\n    <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n        <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n        <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n    </div>\n</div>\n\n<!-- End Non Inline Spark Chart -->",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        SparkComponent.ctorParameters = function () {
            return [
                { type: ColorService, },
            ];
        };
        SparkComponent.propDecorators = {
            "barHeight": [{ type: core.Input },],
            "inlineLabel": [{ type: core.Input },],
            "topLeftLabel": [{ type: core.Input },],
            "topRightLabel": [{ type: core.Input },],
            "bottomLeftLabel": [{ type: core.Input },],
            "bottomRightLabel": [{ type: core.Input },],
            "tooltip": [{ type: core.Input },],
            "theme": [{ type: core.Input },],
            "trackColor": [{ type: core.Input },],
            "barColor": [{ type: core.Input },],
            "value": [{ type: core.Input },],
        };
        return SparkComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkModule = (function () {
        function SparkModule() {
        }
        SparkModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            TooltipModule
                        ],
                        exports: [SparkComponent],
                        declarations: [SparkComponent]
                    },] },
        ];
        /** @nocollapse */
        SparkModule.ctorParameters = function () { return []; };
        return SparkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetService = (function () {
        function TabsetService() {
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.focused$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
        }
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.add =
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
                // check if this is the only tab. If so select this by default
                if (!this.active$.value) {
                    this.select(tab);
                }
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.remove =
            function (tab) {
                // remove the tab
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.select =
            function (tab) {
                if (!tab.disabled) {
                    this.active$.next(tab);
                    this.highlighted$.next(tab);
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        TabsetService.prototype.selectAtIndex =
            function (index) {
                // if there are no tabs then do nothing
                if (this.tabs$.value.length === 0) {
                    return;
                }
                // check if the index is within the bounds
                if (index < 0) {
                    return this.selectAtIndex(this.tabs$.value.length - 1);
                }
                else if (index >= this.tabs$.value.length) {
                    return this.selectAtIndex(0);
                }
                var /** @type {?} */ target = this.tabs$.value[index];
                if (target) {
                    this.select(target);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectNextTab =
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs after the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(index + 1);
                try {
                    // check if any of the tabs are not disabled
                    for (var tabs_1 = __values(tabs), tabs_1_1 = tabs_1.next(); !tabs_1_1.done; tabs_1_1 = tabs_1.next()) {
                        var tab = tabs_1_1.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (tabs_1_1 && !tabs_1_1.done && (_a = tabs_1.return))
                            _a.call(tabs_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // if we reach here then no tab could be selected - select the first tab
                this.selectFirstTab();
                var e_1, _a;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectPreviousTab =
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs before the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(0, index);
                try {
                    // check if any of the tabs are not disabled
                    for (var _a = __values(tabs.reverse()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var tab = _b.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                // if we reach here then no previous tab could be selected - select the last tab
                this.selectLastTab();
                var e_2, _c;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectFirstTab =
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex(tabIndex);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectLastTab =
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.slice().reverse().findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex((this.tabs$.value.length - 1) - tabIndex);
                }
            };
        TabsetService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TabsetService.ctorParameters = function () { return []; };
        return TabsetService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetComponent = (function () {
        function TabsetComponent(tabset) {
            this.tabset = tabset;
            this.minimal = true;
            this.stacked = 'none';
        }
        /**
         * Allow manual tab selected
         */
        /**
         * Allow manual tab selected
         * @param {?} tab
         * @return {?}
         */
        TabsetComponent.prototype.select =
            function (tab) {
                this.tabset.select(tab);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectPreviousTab =
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowLeft = event.key === 'ArrowLeft' || event.keyCode === 37;
                var /** @type {?} */ arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
                // only perform action if the arrow key matches the orientation
                if (arrowLeft && this.stacked !== 'none' || arrowUp && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectPreviousTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectNextTab =
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowRight = event.key === 'ArrowRight' || event.keyCode === 39;
                var /** @type {?} */ arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
                // only perform action if the arrow key matches the orientation
                if (arrowRight && this.stacked !== 'none' || arrowDown && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectNextTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        TabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tabset',
                        template: "<!-- Nav tabs -->\n<ul role=\"tablist\"\n    class=\"nav nav-tabs\"\n    [class.minimal-tab]=\"minimal\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-orientation]=\"stacked === 'none' ? 'horizontal' : 'vertical'\">\n\n\t<li role=\"presentation\" \n        class=\"nav-item\"\n        *ngFor=\"let tab of tabset.tabs$ | async; let index = index\"\n        [class.active]=\"tab.active$ | async\"\n        [class.disabled]=\"tab.disabled\"\n        [ngClass]=\"tab.customClass\">\n\n        <a class=\"nav-link\"\n            [id]=\"tab.id\"\n            role=\"tab\"\n            [uxTabFocus]=\"tab\"\n            [tabindex]=\"(tab.active$ | async) ? 0 : -1\"\n            [class.highlighted]=\"(tabset.focused$ | async) && (tabset.highlighted$ | async) === tab\"            \n            (mousedown)=\"tabset.select(tab)\"\n            (focus)=\"tabset.focused$.next(true)\"\n            (blur)=\"tabset.focused$.next(false)\"\n            (mousedown)=\"tabset.focused$.next(true)\"\n            (keydown.ArrowUp)=\"selectPreviousTab($event)\"\n            (keydown.ArrowLeft)=\"selectPreviousTab($event)\"\n            (keydown.ArrowRight)=\"selectNextTab($event)\"\n            (keydown.ArrowDown)=\"selectNextTab($event)\"\n            (keydown.Home)=\"tabset.selectFirstTab(); $event.preventDefault()\"\n            (keydown.End)=\"tabset.selectLastTab(); $event.preventDefault()\"\n            [attr.aria-controls]=\"tab.id\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            [attr.aria-disabled]=\"tab.disabled\">\n\n            <span *ngIf=\"!tab.headingRef\">{{ tab.heading }}</span>\n\n            <ng-container *ngIf=\"tab.headingRef\" [ngTemplateOutlet]=\"tab.headingRef\"></ng-container>\n        </a>\n\n\t</li>\n\n</ul>\n\n<!-- Tab panes -->\n<div class=\"tab-content\">\n\t<ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TabsetService],
                        host: {
                            '[class.tabs-left]': 'stacked === "left"',
                            '[class.tabs-right]': 'stacked === "right"',
                        }
                    },] },
        ];
        /** @nocollapse */
        TabsetComponent.ctorParameters = function () {
            return [
                { type: TabsetService, },
            ];
        };
        TabsetComponent.propDecorators = {
            "minimal": [{ type: core.Input },],
            "stacked": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
        };
        return TabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTabId = 0;
    var TabComponent = (function () {
        function TabComponent(_tabset) {
            var _this = this;
            this._tabset = _tabset;
            this.id = "ux-tab-" + ++uniqueTabId;
            this.disabled = false;
            this.select = new core.EventEmitter();
            this.deselect = new core.EventEmitter();
            this.active$ = this._tabset.active$.pipe(operators.map(function (active) { return active === _this; }));
            _tabset.add(this);
            this._subscription = this.active$.subscribe(function (active) { return active ? _this.select.emit() : _this.deselect.emit(); });
        }
        Object.defineProperty(TabComponent.prototype, "active", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._tabset.select(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabComponent.prototype.ngOnDestroy =
            function () {
                this._tabset.remove(this);
                this._subscription.unsubscribe();
            };
        TabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tab',
                        template: "<div role=\"tabpanel\"\n     class=\"tab-pane\"\n     [class.active]=\"active$ | async\"\n     [id]=\"id + '-panel'\"\n     [attr.aria-labelledby]=\"id\"\n     [attr.aria-hidden]=\"!(active$ | async)\">\n  <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        TabComponent.ctorParameters = function () {
            return [
                { type: TabsetService, },
            ];
        };
        TabComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "heading": [{ type: core.Input },],
            "customClass": [{ type: core.Input },],
            "select": [{ type: core.Output },],
            "deselect": [{ type: core.Output },],
            "active": [{ type: core.Input },],
        };
        return TabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabHeadingDirective = (function () {
        function TabHeadingDirective(templateRef, tab) {
            tab.headingRef = templateRef;
        }
        TabHeadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabHeading]'
                    },] },
        ];
        /** @nocollapse */
        TabHeadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef, },
                { type: TabComponent, },
            ];
        };
        return TabHeadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabFocusDirective = (function () {
        function TabFocusDirective(_tabset, _elementRef) {
            this._tabset = _tabset;
            this._elementRef = _elementRef;
        }
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                this._subscription = this._tabset.highlighted$.pipe(operators.filter(function () { return _this._tabset.focused$.value === true; }), operators.filter(function () { return _this._tabset.highlighted$.value === _this.uxTabFocus; })).subscribe(function () { return _this._elementRef.nativeElement.focus(); });
            };
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        TabFocusDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabFocus]'
                    },] },
        ];
        /** @nocollapse */
        TabFocusDirective.ctorParameters = function () {
            return [
                { type: TabsetService, },
                { type: core.ElementRef, },
            ];
        };
        TabFocusDirective.propDecorators = {
            "uxTabFocus": [{ type: core.Input },],
        };
        return TabFocusDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetModule = (function () {
        function TabsetModule() {
        }
        TabsetModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [TabsetComponent, TabComponent, TabHeadingDirective],
                        declarations: [TabsetComponent, TabComponent, TabHeadingDirective, TabFocusDirective],
                    },] },
        ];
        /** @nocollapse */
        TabsetModule.ctorParameters = function () { return []; };
        return TabsetModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineComponent = (function () {
        function TimelineComponent() {
        }
        TimelineComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline',
                        template: "<div class=\"timeline\">\n    <ng-content></ng-content>\n</div>\n"
                    },] },
        ];
        /** @nocollapse */
        TimelineComponent.ctorParameters = function () { return []; };
        return TimelineComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineEventComponent = (function () {
        function TimelineEventComponent() {
        }
        TimelineEventComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline-event',
                        template: "<div class=\"timeline-badge\" [ngClass]=\"badgeColor\">\n    <span>{{badgeTitle}}</span>\n</div>\n<div class=\"timeline-panel\">\n    <ng-content></ng-content>\n</div>\n"
                    },] },
        ];
        /** @nocollapse */
        TimelineEventComponent.ctorParameters = function () { return []; };
        TimelineEventComponent.propDecorators = {
            "badgeColor": [{ type: core.Input },],
            "badgeTitle": [{ type: core.Input },],
        };
        return TimelineEventComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineModule = (function () {
        function TimelineModule() {
        }
        TimelineModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            TimelineComponent,
                            TimelineEventComponent
                        ],
                        declarations: [
                            TimelineComponent,
                            TimelineEventComponent
                        ]
                    },] },
        ];
        /** @nocollapse */
        TimelineModule.ctorParameters = function () { return []; };
        return TimelineModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TOGGLESWITCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ToggleSwitchComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueToggleSwitchId = 0;
    var ToggleSwitchComponent = (function () {
        function ToggleSwitchComponent() {
            this._toggleSwitchId = "ux-toggleswitch-" + ++uniqueToggleSwitchId;
            this.id = this._toggleSwitchId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(ToggleSwitchComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // Update value output
                this.valueChange.emit(value);
                // Notify ngModel
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToggleSwitchComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._toggleSwitchId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToggleSwitchComponent.prototype.toggle =
            function () {
                if (!this.disabled && this.clickable) {
                    this.value = !this.value;
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ToggleSwitchComponent.prototype.writeValue =
            function (value) {
                this.value = !!value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnChange =
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnTouched =
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        ToggleSwitchComponent.prototype.setDisabledState =
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        ToggleSwitchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toggleswitch',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-toggleswitch\"\n       [class.ux-toggleswitch-checked]=\"value\"\n       [class.ux-toggleswitch-disabled]=\"disabled\"\n       [class.ux-toggleswitch-focused]=\"focused\">\n\n    <input class=\"ux-toggleswitch-input\"\n           type=\"checkbox\"\n           role=\"switch\"\n           [id]=\"inputId\"\n           [checked]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"value\"\n           (focus)=\"focused = true\"\n           (blur)=\"focused = false\"\n           (change)=\"toggle()\"\n           (click)=\"$event.stopPropagation()\">\n\n    <div class=\"ux-toggleswitch-container\">\n        <div class=\"ux-toggleswitch-bg\"></div>\n        <div class=\"ux-toggleswitch-nub\"></div>\n    </div>\n\n    <span class=\"ux-toggleswitch-label\">\n        <ng-content></ng-content>\n    </span>\n</label>",
                        providers: [TOGGLESWITCH_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        ToggleSwitchComponent.ctorParameters = function () { return []; };
        ToggleSwitchComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "name": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "clickable": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input, args: ['aria-label',] },],
            "ariaLabelledby": [{ type: core.Input, args: ['aria-labelledby',] },],
            "valueChange": [{ type: core.Output },],
            "value": [{ type: core.Input },],
        };
        return ToggleSwitchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToggleSwitchModule = (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [ToggleSwitchComponent],
                        declarations: [ToggleSwitchComponent]
                    },] },
        ];
        /** @nocollapse */
        ToggleSwitchModule.ctorParameters = function () { return []; };
        return ToggleSwitchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchButtonDirective = (function () {
        function ToolbarSearchButtonDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.clicked = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchButtonDirective.prototype, "width", {
            get: /**
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.offsetWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchButtonDirective.prototype.clickHandler =
            function () {
                this.clicked.emit();
            };
        ToolbarSearchButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchButton]'
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        ToolbarSearchButtonDirective.propDecorators = {
            "clicked": [{ type: core.Output },],
            "clickHandler": [{ type: core.HostListener, args: ['click',] },],
        };
        return ToolbarSearchButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ KEYS = {
        ENTER: 13,
        ESCAPE: 27
    };
    var ToolbarSearchFieldDirective = (function () {
        function ToolbarSearchFieldDirective(_elementRef, _ngModel) {
            this._elementRef = _elementRef;
            this._ngModel = _ngModel;
            this.cancel = new core.EventEmitter();
            this.submit = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchFieldDirective.prototype, "text", {
            get: /**
             * @return {?}
             */ function () {
                // Use ngModel if specified on the host; otherwise read the DOM
                if (this._ngModel) {
                    return this._ngModel.value;
                }
                return this._elementRef.nativeElement.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.focus =
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.focus();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.blur =
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.blur();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.clear =
            function () {
                // Use ngModel if specified on the host; otherwise use the DOM
                if (this._ngModel) {
                    this._ngModel.reset();
                }
                else {
                    this._elementRef.nativeElement.value = '';
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.keydownHandler =
            function (event) {
                var _this = this;
                setTimeout(function () {
                    if (event.keyCode === KEYS.ENTER) {
                        _this.submit.emit(_this.text);
                    }
                    else if (event.keyCode === KEYS.ESCAPE) {
                        _this._elementRef.nativeElement.blur();
                        _this.cancel.emit();
                    }
                });
            };
        ToolbarSearchFieldDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchField]'
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchFieldDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: forms.NgModel, decorators: [{ type: core.Optional },] },
            ];
        };
        ToolbarSearchFieldDirective.propDecorators = {
            "cancel": [{ type: core.Output },],
            "submit": [{ type: core.Output },],
            "keydownHandler": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
        };
        return ToolbarSearchFieldDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchComponent = (function () {
        function ToolbarSearchComponent(_elementRef, _colorService, _document) {
            this._elementRef = _elementRef;
            this._colorService = _colorService;
            this._document = _document;
            this.direction = 'right';
            this.inverse = false;
            this.expandedChange = new core.EventEmitter();
            this.search = new core.EventEmitter();
            this._expanded = false;
            this.position = 'relative';
            this.backgroundColor = 'transparent';
        }
        Object.defineProperty(ToolbarSearchComponent.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._expanded = value;
                this.expandedChange.emit(value);
                if (value) {
                    // Set focus on the input when expanded
                    this.field.focus();
                }
                else {
                    // Clear text when contracted
                    this.field.clear();
                    // Remove focus (works around an IE issue where the caret remains visible)
                    this.field.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "background", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.backgroundColor = this._colorService.resolve(value) || 'transparent';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "expandedAnimation", {
            get: /**
             * @return {?}
             */ function () {
                return {
                    value: this.expanded ? 'expanded' : 'collapsed',
                    params: {
                        initialWidth: this.button.width + 'px'
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // Subscribe to the submit event on the input field, triggering the search event
                this.field.submit.subscribe(function (text) { return _this.search.emit(text); });
                // Subscribe to cancel events coming from the input field
                this.field.cancel.subscribe(function () { return _this.expanded = false; });
                // Subscribe to the button click event
                this.button.clicked.subscribe(function () {
                    if (_this.expanded && _this.field.text) {
                        _this.search.emit(_this.field.text);
                    }
                    else {
                        _this.expanded = !_this.expanded;
                    }
                });
                // Create placeholder element to avoid changing layout when switching to position: absolute
                this.createPlaceholder();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationStart =
            function (event) {
                if (event.toState === 'expanded') {
                    this.position = 'absolute';
                    this.enablePlaceholder(true);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationDone =
            function (event) {
                if (event.toState === 'collapsed') {
                    this.position = 'relative';
                    this.enablePlaceholder(false);
                }
            };
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.createPlaceholder =
            function () {
                // Get width and height of the component
                var /** @type {?} */ styles = getComputedStyle(this._elementRef.nativeElement);
                // Create invisible div with the same dimensions
                this._placeholder = this._document.createElement('div');
                this._placeholder.style.display = 'none';
                this._placeholder.style.width = this.button.width + 'px';
                this._placeholder.style.height = styles.height;
                this._placeholder.style.visibility = 'hidden';
                // Add as a sibling
                this._elementRef.nativeElement.parentNode.insertBefore(this._placeholder, this._elementRef.nativeElement);
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        ToolbarSearchComponent.prototype.enablePlaceholder =
            function (enabled) {
                this._placeholder.style.display = (enabled ? 'inline-block' : 'none');
            };
        ToolbarSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toolbar-search',
                        template: "<ng-content></ng-content>",
                        animations: [
                            animations.trigger('expanded', [
                                animations.state('collapsed', animations.style({
                                    width: '{{initialWidth}}'
                                }), {
                                    params: { initialWidth: '30px' }
                                }),
                                animations.state('expanded', animations.style({
                                    width: '100%'
                                })),
                                animations.transition('collapsed <=> expanded', [animations.animate('0.3s ease-out')])
                            ])
                        ]
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ColorService, },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
            ];
        };
        ToolbarSearchComponent.propDecorators = {
            "expanded": [{ type: core.HostBinding, args: ['class.expanded',] }, { type: core.Input },],
            "direction": [{ type: core.Input }, { type: core.HostBinding, args: ['class',] },],
            "inverse": [{ type: core.Input }, { type: core.HostBinding, args: ['class.inverse',] },],
            "background": [{ type: core.Input },],
            "expandedChange": [{ type: core.Output },],
            "search": [{ type: core.Output },],
            "expandedAnimation": [{ type: core.HostBinding, args: ['@expanded',] },],
            "position": [{ type: core.HostBinding, args: ['style.position',] },],
            "backgroundColor": [{ type: core.HostBinding, args: ['style.background-color',] },],
            "field": [{ type: core.ContentChild, args: [ToolbarSearchFieldDirective,] },],
            "button": [{ type: core.ContentChild, args: [ToolbarSearchButtonDirective,] },],
            "animationStart": [{ type: core.HostListener, args: ['@expanded.start', ['$event'],] },],
            "animationDone": [{ type: core.HostListener, args: ['@expanded.done', ['$event'],] },],
        };
        return ToolbarSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$6 = [
        ToolbarSearchComponent,
        ToolbarSearchFieldDirective,
        ToolbarSearchButtonDirective
    ];
    var ToolbarSearchModule = (function () {
        function ToolbarSearchModule() {
        }
        ToolbarSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$6,
                        declarations: DECLARATIONS$6,
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        ToolbarSearchModule.ctorParameters = function () { return []; };
        return ToolbarSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadingDirective = (function () {
        function VirtualScrollLoadingDirective() {
        }
        VirtualScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoading]'
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollLoadingDirective.ctorParameters = function () { return []; };
        return VirtualScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadButtonDirective = (function () {
        function VirtualScrollLoadButtonDirective() {
        }
        VirtualScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoadButton]'
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollLoadButtonDirective.ctorParameters = function () { return []; };
        return VirtualScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollCellDirective = (function () {
        function VirtualScrollCellDirective() {
        }
        VirtualScrollCellDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollCell]'
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollCellDirective.ctorParameters = function () { return []; };
        return VirtualScrollCellDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollComponent = (function () {
        function VirtualScrollComponent(_elementRef, resizeService) {
            var _this = this;
            this._elementRef = _elementRef;
            this.collection = Observable.Observable.create();
            this.loadOnScroll = true;
            this.loading = new core.EventEmitter();
            this.cells = new BehaviorSubject.BehaviorSubject([]);
            this.scrollTop = 0;
            this.isLoading = false;
            this.pageNumber = 0;
            this.data = [];
            this.loadingComplete = false;
            // watch for any future changes to size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) { return _this._height = event.height; });
        }
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnInit =
            function () {
                if (!this.cellHeight) {
                    throw new Error('Virtual Scroll Component requires "cellHeight" property to be defined.');
                }
                // subscribe to the collection
                this.setupObservable();
                // load the first page of data
                this.loadNextPage();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngAfterContentInit =
            function () {
                // re-render cells now that we can display any loading indicator or loading button
                this.renderCells();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnChanges =
            function (changes) {
                if (changes["collection"] && changes["collection"].currentValue !== changes["collection"].previousValue && !changes["collection"].isFirstChange()) {
                    this.setupObservable();
                    this.reset();
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnDestroy =
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.setupObservable =
            function () {
                var _this = this;
                // if there is a current subscription, unsubscribe
                if (this._subscription && this._subscription.unsubscribe) {
                    this._subscription.unsubscribe();
                }
                this._subscription = this.collection.subscribe(function (collection) {
                    (_a = _this.data).push.apply(_a, __spread(collection));
                    _this.renderCells();
                    _this.isLoading = false;
                    var _a;
                }, null, function () {
                    _this.loadingComplete = true;
                });
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.renderCells =
            function () {
                this.cells.next(this.getVisibleCells());
                if (this.loadOnScroll && !this.isLoading && !this.loadingComplete) {
                    var /** @type {?} */ remainingScroll = this._elementRef.nativeElement.scrollHeight - (this._elementRef.nativeElement.scrollTop + this._elementRef.nativeElement.clientHeight);
                    // if the current cells take up less than the height of the component then load the next page
                    if (remainingScroll <= this._elementRef.nativeElement.clientHeight) {
                        this.loadNextPage();
                    }
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getVisibleCells =
            function () {
                // store the initial element height
                if (!this._height) {
                    this._height = this._elementRef.nativeElement.offsetHeight;
                }
                // perform some calculations
                var /** @type {?} */ scrollTop = this._elementRef.nativeElement.scrollTop;
                var /** @type {?} */ startCell = Math.floor(scrollTop / this.cellHeight);
                var /** @type {?} */ endCell = Math.ceil(this._height / this.cellHeight) + 1;
                // update the scroll position
                this.scrollTop = scrollTop - (scrollTop % this.cellHeight);
                // return a sublist of items visible on the screen
                return this.data.slice(startCell, startCell + endCell);
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getTotalHeight =
            function () {
                return this.cellHeight * this.data.length;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.loadNextPage =
            function () {
                this.isLoading = true;
                this.loading.next(this.pageNumber);
                this.pageNumber++;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.reset =
            function () {
                // reset all values
                this.scrollTop = 0;
                this.data = [];
                this._height = undefined;
                this.pageNumber = 0;
                this.loadingComplete = false;
                // set scroll position
                this._elementRef.nativeElement.scrollTop = 0;
                // clear the current cells
                this.renderCells();
                // reload first page
                this.loadNextPage();
            };
        VirtualScrollComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-virtual-scroll',
                        template: "<div class=\"virtual-scroll-content-height\" [style.height.px]=\"getTotalHeight()\"></div>\n<div class=\"virtual-scroll-content\" [style.transform]=\"'translateY(' + scrollTop + 'px)'\">\n\n    <!-- Virtually Render Cells -->\n    <ng-container *ngFor=\"let cell of cells | async\">\n        <ng-container *ngTemplateOutlet=\"cellTemplate; context: { cell: cell }\"></ng-container>\n    </ng-container>\n\n    <!-- Loading Indicator -->\n    <ng-container *ngIf=\"loadingIndicatorTemplate && isLoading\" [ngTemplateOutlet]=\"loadingIndicatorTemplate\"></ng-container>\n\n    <!-- Loading Button -->\n    <div class=\"virtual-scroll-load-button\" *ngIf=\"loadButtonTemplate && !loadOnScroll && !loadingComplete && !isLoading\" (click)=\"loadNextPage()\">\n        <ng-container *ngTemplateOutlet=\"loadButtonTemplate\"></ng-container>\n    </div>\n    \n</div>"
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
            ];
        };
        VirtualScrollComponent.propDecorators = {
            "collection": [{ type: core.Input },],
            "cellHeight": [{ type: core.Input },],
            "loadOnScroll": [{ type: core.Input },],
            "loading": [{ type: core.Output },],
            "cellTemplate": [{ type: core.ContentChild, args: [VirtualScrollCellDirective, { read: core.TemplateRef },] },],
            "loadingIndicatorTemplate": [{ type: core.ContentChild, args: [VirtualScrollLoadingDirective, { read: core.TemplateRef },] },],
            "loadButtonTemplate": [{ type: core.ContentChild, args: [VirtualScrollLoadButtonDirective, { read: core.TemplateRef },] },],
            "renderCells": [{ type: core.HostListener, args: ['scroll',] },],
        };
        return VirtualScrollComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$7 = [
        VirtualScrollComponent,
        VirtualScrollLoadingDirective,
        VirtualScrollLoadButtonDirective,
        VirtualScrollCellDirective
    ];
    var VirtualScrollModule = (function () {
        function VirtualScrollModule() {
        }
        VirtualScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        exports: DECLARATIONS$7,
                        declarations: DECLARATIONS$7
                    },] },
        ];
        /** @nocollapse */
        VirtualScrollModule.ctorParameters = function () { return []; };
        return VirtualScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowDirective = (function () {
        function AutoGrowDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            // ensure this is a textarea or else throw error
            if (_elementRef.nativeElement.tagName.toLowerCase() !== 'textarea') {
                throw new Error('uxAutoGrow directive can only be used on <textarea> elements.');
            }
        }
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.ngAfterViewInit =
            function () {
                this.update();
            };
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.update =
            function () {
                // perform sizing
                this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'hidden');
                this._renderer.setStyle(this._elementRef.nativeElement, 'height', 'auto');
                // get the new total height and element height
                var scrollHeight = this._elementRef.nativeElement.scrollHeight;
                var maxHeight = getComputedStyle(this._elementRef.nativeElement).maxHeight;
                // determine what the maximum allowed height is
                var /** @type {?} */ maximum = !isNaN(parseFloat(maxHeight)) ? parseFloat(maxHeight) : Infinity;
                // if there is a max height specifed we want to show the scrollbars
                if (maximum < scrollHeight) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'auto');
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', maximum + 'px');
                }
                else {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', scrollHeight + 'px');
                }
            };
        AutoGrowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxAutoGrow]'
                    },] },
        ];
        /** @nocollapse */
        AutoGrowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
            ];
        };
        AutoGrowDirective.propDecorators = {
            "update": [{ type: core.HostListener, args: ['input',] },],
        };
        return AutoGrowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowModule = (function () {
        function AutoGrowModule() {
        }
        AutoGrowModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [AutoGrowDirective],
                        declarations: [AutoGrowDirective]
                    },] },
        ];
        /** @nocollapse */
        AutoGrowModule.ctorParameters = function () { return []; };
        return AutoGrowModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableDirective = (function () {
        function FixedHeaderTableDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.tablePaging = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.ngOnInit =
            function () {
                // add class to the table
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-fixed-header-table');
                // locate the important elements
                this._tableHead = this._elementRef.nativeElement.querySelector('thead');
                this._tableBody = this._elementRef.nativeElement.querySelector('tbody');
                // bind to scroll events on the table body
                this._renderer.listen(this._tableBody, 'scroll', this.onScroll.bind(this));
                // resize the table header to account for scrollbar
                this.setLayout();
                // trigger the loading of the first page
                this.tablePaging.emit();
            };
        /**
         * Get the table element
         * Primarily used by column width directive
         */
        /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.getTable =
            function () {
                return this._elementRef.nativeElement;
            };
        /**
         * Handle scroll events
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.onScroll =
            function () {
                // determine if we are scrolled to the bottom and if so load the next page
                if (this._tableBody.scrollTop === (this._tableBody.scrollHeight - this._tableBody.offsetHeight)) {
                    this.tablePaging.emit();
                }
            };
        /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.setLayout =
            function () {
                // calculate the size of the scrollbar
                var /** @type {?} */ scrollbar = this._tableBody.offsetWidth - this._tableBody.clientWidth;
                // add padding to the header to account for this
                this._renderer.setStyle(this._tableHead, 'padding-right', scrollbar + 'px');
                // set the desired height of the table body
                this._renderer.setStyle(this._tableBody, 'height', typeof this.tableHeight === 'number' ? this.tableHeight + "px" : this.tableHeight);
            };
        FixedHeaderTableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFixedHeaderTable]'
                    },] },
        ];
        /** @nocollapse */
        FixedHeaderTableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
            ];
        };
        FixedHeaderTableDirective.propDecorators = {
            "tableHeight": [{ type: core.Input },],
            "tablePaging": [{ type: core.Output },],
        };
        return FixedHeaderTableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableModule = (function () {
        function FixedHeaderTableModule() {
        }
        FixedHeaderTableModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FixedHeaderTableDirective],
                        declarations: [FixedHeaderTableDirective]
                    },] },
        ];
        /** @nocollapse */
        FixedHeaderTableModule.ctorParameters = function () { return []; };
        return FixedHeaderTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelDirective = (function () {
        function FloatLabelDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.mode = 'focus';
            this.raised = false;
            this._focused = false;
            this._eventHandles = [];
        }
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnInit =
            function () {
                this._eventHandles.push(this._renderer.listen(this.input, 'focus', this.inputFocus.bind(this)), this._renderer.listen(this.input, 'blur', this.inputBlur.bind(this)), this._renderer.listen(this.input, 'input', this.inputChange.bind(this)));
                // Check initial input value
                this.raised = this.hasText();
                // Ensure that the `for` attribute is set
                if (!this._elementRef.nativeElement.getAttribute('for') && this.input.getAttribute('id')) {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'for', this.input.getAttribute('id'));
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnChanges =
            function () {
                if (!(this.mode === 'focus' && this._focused)) {
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnDestroy =
            function () {
                // Unsubscribe event handles
                this._eventHandles.forEach(function (eventHandle) { return eventHandle(); });
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.hasText =
            function () {
                if (this.value === undefined) {
                    return !!this.input.value;
                }
                return !!this.value;
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputFocus =
            function () {
                if (this.mode === 'focus') {
                    this._focused = true;
                    this.raised = true;
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputBlur =
            function () {
                if (this.mode === 'focus') {
                    this._focused = false;
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputChange =
            function () {
                if (this.mode === 'input') {
                    this.raised = this.hasText();
                }
            };
        FloatLabelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFloatLabel]',
                        host: {
                            'class': 'ux-float-label'
                        }
                    },] },
        ];
        /** @nocollapse */
        FloatLabelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Renderer2, },
            ];
        };
        FloatLabelDirective.propDecorators = {
            "input": [{ type: core.Input, args: ['uxFloatLabel',] },],
            "value": [{ type: core.Input },],
            "mode": [{ type: core.Input },],
            "raised": [{ type: core.HostBinding, args: ['class.ux-float-label-raised',] },],
        };
        return FloatLabelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelModule = (function () {
        function FloatLabelModule() {
        }
        FloatLabelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [FloatLabelDirective],
                        declarations: [FloatLabelDirective],
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        FloatLabelModule.ctorParameters = function () { return []; };
        return FloatLabelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterService = (function () {
        function HelpCenterService() {
            this.items = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.registerItem =
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // add the new item to the list
                items.push(item);
                // update the observable
                this.items.next(items);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.unregisterItem =
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // remove the item being unregistered
                items = items.filter(function (itm) { return itm !== item; });
                // update the observable
                this.items.next(items);
            };
        HelpCenterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        HelpCenterService.ctorParameters = function () { return []; };
        return HelpCenterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterItemDirective = (function () {
        function HelpCenterItemDirective(_helpCenterService) {
            this._helpCenterService = _helpCenterService;
        }
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnInit =
            function () {
                // register the item in the service
                this._helpCenterService.registerItem(this.uxHelpCenterItem);
            };
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnDestroy =
            function () {
                // remove this item when it is destroyed
                this._helpCenterService.unregisterItem(this.uxHelpCenterItem);
            };
        HelpCenterItemDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[uxHelpCenterItem]' },] },
        ];
        /** @nocollapse */
        HelpCenterItemDirective.ctorParameters = function () {
            return [
                { type: HelpCenterService, },
            ];
        };
        HelpCenterItemDirective.propDecorators = {
            "uxHelpCenterItem": [{ type: core.Input },],
        };
        return HelpCenterItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterModule = (function () {
        function HelpCenterModule() {
        }
        HelpCenterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [HelpCenterItemDirective],
                        declarations: [HelpCenterItemDirective],
                        providers: [HelpCenterService],
                    },] },
        ];
        /** @nocollapse */
        HelpCenterModule.ctorParameters = function () { return []; };
        return HelpCenterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionService = (function () {
        function HoverActionService() {
            this.active = new BehaviorSubject.BehaviorSubject(false);
            this._focused = false;
            this._hovered = false;
            this._actions = [];
        }
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.register =
            function (action) {
                this._actions.push(action);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.unregister =
            function (action) {
                this._actions = this._actions.filter(function (actn) { return actn !== action; });
            };
        /**
         * @param {?} container
         * @return {?}
         */
        HoverActionService.prototype.setContainer =
            function (container) {
                this._container = container;
            };
        /**
         * @param {?} focus
         * @return {?}
         */
        HoverActionService.prototype.setFocusState =
            function (focus) {
                this._focused = focus;
                this.updateVisibility();
            };
        /**
         * @param {?} hover
         * @return {?}
         */
        HoverActionService.prototype.setHoverState =
            function (hover) {
                this._hovered = hover;
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.next =
            function () {
                // if container has focus then focus the first hover action
                if (this.containerHasFocus()) {
                    this.focusActionAtIndex(0);
                    return this.updateVisibility();
                }
                // if a hover action has focus then focus the next action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() + 1;
                    this.focusActionAtIndex(index);
                    this.updateVisibility();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.previous =
            function () {
                // if a hover action has focus then focus the previous action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() - 1;
                    if (index >= 0) {
                        this.focusActionAtIndex(index);
                    }
                    else {
                        this._container.focus();
                    }
                }
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.updateVisibility =
            function () {
                this.active.next(this._focused || this._hovered || this.actionHasFocus());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        HoverActionService.prototype.focusActionAtIndex =
            function (index) {
                if (index >= 0 && index < this._actions.length) {
                    this._actions[index].focus();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedActionIndex =
            function () {
                var _this = this;
                return this._actions.findIndex(function (action) { return action === _this.getFocusedAction(); });
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.containerHasFocus =
            function () {
                return this._focused;
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.actionHasFocus =
            function () {
                return !!this.getFocusedAction();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedAction =
            function () {
                return this._actions.find(function (action) { return action.focused; });
            };
        HoverActionService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        HoverActionService.ctorParameters = function () { return []; };
        return HoverActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionContainerDirective = (function () {
        function HoverActionContainerDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            // register the container element with the service
            this._hoverActionService.setContainer(this);
            // apply a class based on the active state of the container and it's actions
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.ngOnDestroy =
            function () {
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.focus =
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onFocus =
            function () {
                this._hoverActionService.setFocusState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onBlur =
            function () {
                this._hoverActionService.setFocusState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onHover =
            function () {
                this._hoverActionService.setHoverState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onLeave =
            function () {
                this._hoverActionService.setHoverState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.next =
            function () {
                this._hoverActionService.next();
            };
        HoverActionContainerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverActionContainer]',
                        providers: [HoverActionService],
                        host: {
                            '[class.hover-action-container-active]': 'active',
                            '[tabindex]': 'tabindex'
                        }
                    },] },
        ];
        /** @nocollapse */
        HoverActionContainerDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: HoverActionService, },
            ];
        };
        HoverActionContainerDirective.propDecorators = {
            "tabindex": [{ type: core.Input },],
            "focus": [{ type: core.HostListener, args: ['click',] },],
            "onFocus": [{ type: core.HostListener, args: ['focus',] },],
            "onBlur": [{ type: core.HostListener, args: ['blur',] },],
            "onHover": [{ type: core.HostListener, args: ['mouseenter',] },],
            "onLeave": [{ type: core.HostListener, args: ['mouseleave',] },],
            "next": [{ type: core.HostListener, args: ['keydown.arrowright',] },],
        };
        return HoverActionContainerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionDirective = (function () {
        function HoverActionDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 1;
            this.active = false;
            this.focused = false;
            // register the action
            this._hoverActionService.register(this);
            // watch for changes to the activeness of the container
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.ngOnDestroy =
            function () {
                this._hoverActionService.unregister(this);
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.focus =
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onFocus =
            function () {
                this.focused = true;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onBlur =
            function () {
                this.focused = false;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.previous =
            function (event) {
                event.stopPropagation();
                this._hoverActionService.previous();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.next =
            function (event) {
                event.stopPropagation();
                this._hoverActionService.next();
            };
        HoverActionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverAction]',
                        host: {
                            '[class.hover-action-active]': 'active',
                            '[class.hover-action-focused]': 'focused',
                            '[tabindex]': 'tabindex'
                        }
                    },] },
        ];
        /** @nocollapse */
        HoverActionDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: HoverActionService, },
            ];
        };
        HoverActionDirective.propDecorators = {
            "tabindex": [{ type: core.Input },],
            "onFocus": [{ type: core.HostListener, args: ['focus',] },],
            "onBlur": [{ type: core.HostListener, args: ['blur',] },],
            "previous": [{ type: core.HostListener, args: ['keydown.arrowleft', ['$event'],] },],
            "next": [{ type: core.HostListener, args: ['keydown.arrowright', ['$event'],] },],
        };
        return HoverActionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$8 = [
        HoverActionDirective,
        HoverActionContainerDirective
    ];
    var HoverActionModule = (function () {
        function HoverActionModule() {
        }
        HoverActionModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: DECLARATIONS$8,
                        declarations: DECLARATIONS$8
                    },] },
        ];
        /** @nocollapse */
        HoverActionModule.ctorParameters = function () { return []; };
        return HoverActionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherItemDirective = (function () {
        function LayoutSwitcherItemDirective(_templateRef, _viewContainerRef) {
            this._templateRef = _templateRef;
            this._viewContainerRef = _viewContainerRef;
        }
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getLayout =
            function () {
                return this._templateRef;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getConfig =
            function () {
                return this._config;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.activate =
            function () {
                this._embeddedView = this._viewContainerRef.createEmbeddedView(this._templateRef);
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.deactivate =
            function () {
                var /** @type {?} */ index = this._viewContainerRef.indexOf(this._embeddedView);
                this._viewContainerRef.remove(index);
                this._embeddedView = null;
            };
        LayoutSwitcherItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcherItem]'
                    },] },
        ];
        /** @nocollapse */
        LayoutSwitcherItemDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef, },
                { type: core.ViewContainerRef, },
            ];
        };
        LayoutSwitcherItemDirective.propDecorators = {
            "_config": [{ type: core.Input, args: ['uxLayoutSwitcherItem',] },],
        };
        return LayoutSwitcherItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherDirective = (function () {
        function LayoutSwitcherDirective(_elementRef, resizeService, _viewContainerRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            // watch for changes to the container size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) {
                _this._width = event.width;
                // render the appropriate layout
                // render the appropriate layout
                _this.updateActiveLayout();
            });
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngOnChanges =
            function (changes) {
                // if the active group has changed then render the appropriate layout
                if (changes["group"].currentValue !== changes["group"].previousValue) {
                    this.updateActiveLayout();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.getActiveLayout =
            function () {
                var _this = this;
                // if there are currently no layouts then do nothing
                if (!this._layouts) {
                    return null;
                }
                // otherwise find layouts that match the active group and that meet the constraints
                return this._layouts.filter(function (layout) { return _this.group === layout.getConfig().group; }).find(function (layout) {
                    var /** @type {?} */ minWidth = layout.getConfig().minWidth || 0;
                    var /** @type {?} */ maxWidth = layout.getConfig().maxWidth || Infinity;
                    return _this._width >= minWidth && _this._width < maxWidth;
                });
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.updateActiveLayout =
            function () {
                // get the layout that should be shown
                var /** @type {?} */ layout = this.getActiveLayout();
                // check if we are currently showing the layout
                if (this._activeLayout === layout) {
                    return;
                }
                // remove the current layout
                if (this._activeLayout) {
                    this._activeLayout.deactivate();
                }
                // store the new active layout
                this._activeLayout = layout;
                // if there is an active layout then activate
                if (this._activeLayout) {
                    this._activeLayout.activate();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngAfterContentInit =
            function () {
                // store the initial current element width
                this._width = this._elementRef.nativeElement.offsetWidth;
                // render the appropriate layout - need a delay as Angular doesn't like changes like this in these lifecycle hooks
                requestAnimationFrame(this.updateActiveLayout.bind(this));
            };
        LayoutSwitcherDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcher]'
                    },] },
        ];
        /** @nocollapse */
        LayoutSwitcherDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: ResizeService, },
                { type: core.ViewContainerRef, },
            ];
        };
        LayoutSwitcherDirective.propDecorators = {
            "group": [{ type: core.Input },],
            "_layouts": [{ type: core.ContentChildren, args: [LayoutSwitcherItemDirective,] },],
        };
        return LayoutSwitcherDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$9 = [
        LayoutSwitcherDirective,
        LayoutSwitcherItemDirective
    ];
    var LayoutSwitcherModule = (function () {
        function LayoutSwitcherModule() {
        }
        LayoutSwitcherModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            ResizeModule
                        ],
                        exports: DECLARATIONS$9,
                        declarations: DECLARATIONS$9,
                        providers: [],
                    },] },
        ];
        /** @nocollapse */
        LayoutSwitcherModule.ctorParameters = function () { return []; };
        return LayoutSwitcherModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OverflowDirective = (function () {
        function OverflowDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow overflow to be within a range before emitting
             */
            this.tolerance = 0;
            /**
             * Emit when there is a change to the overflow state - horizontal or vertical
             */
            this.uxOverflowObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the horizontal axis
             */
            this.uxOverflowHorizontalObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the vertical axis
             */
            this.uxOverflowVerticalObserver = new core.EventEmitter();
            /**
             * Store the overflow state on both axis
             */
            this._state = { horizontalOverflow: false, verticalOverflow: false };
            /**
             * Unsubscribe from all the observables
             */
            this._onDestroy = new rxjs.Subject();
        }
        /** Set up the trigger if specified */
        /**
         * Set up the trigger if specified
         * @return {?}
         */
        OverflowDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                if (this.trigger) {
                    this.trigger.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.checkForOverflow(); });
                }
            };
        /** Perform an intial check for overflow */
        /**
         * Perform an intial check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.ngAfterViewInit =
            function () {
                var _this = this;
                requestAnimationFrame(function () { return _this.checkForOverflow(); });
            };
        /** Unsubscribe from the trigger */
        /**
         * Unsubscribe from the trigger
         * @return {?}
         */
        OverflowDirective.prototype.ngOnDestroy =
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Programmatically trigger check for overflow */
        /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.checkForOverflow =
            function () {
                var _a = this._elementRef.nativeElement, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scrollWidth = _a.scrollWidth, scrollHeight = _a.scrollHeight;
                var /** @type {?} */ horizontalOverflow = (scrollWidth - offsetWidth) > this.tolerance;
                var /** @type {?} */ verticalOverflow = (scrollHeight - offsetHeight) > this.tolerance;
                if (horizontalOverflow !== this._state.horizontalOverflow) {
                    this.uxOverflowHorizontalObserver.emit(horizontalOverflow);
                }
                if (verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowVerticalObserver.emit(verticalOverflow);
                }
                if (horizontalOverflow !== this._state.horizontalOverflow || verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowObserver.emit((horizontalOverflow || verticalOverflow));
                }
                // store the state
                this._state = { horizontalOverflow: horizontalOverflow, verticalOverflow: verticalOverflow };
            };
        OverflowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxOverflowObserver], [uxOverflowHorizontalObserver], [uxOverflowVerticalObserver]',
                        exportAs: 'ux-overflow-observer'
                    },] },
        ];
        /** @nocollapse */
        OverflowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        OverflowDirective.propDecorators = {
            "trigger": [{ type: core.Input },],
            "tolerance": [{ type: core.Input },],
            "uxOverflowObserver": [{ type: core.Output },],
            "uxOverflowHorizontalObserver": [{ type: core.Output },],
            "uxOverflowVerticalObserver": [{ type: core.Output },],
        };
        return OverflowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ObserversModule = (function () {
        function ObserversModule() {
        }
        ObserversModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [OverflowDirective],
                        declarations: [OverflowDirective]
                    },] },
        ];
        /** @nocollapse */
        ObserversModule.ctorParameters = function () { return []; };
        return ObserversModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var KeyCode = {
        UpArrow: 38,
        DownArrow: 40,
        Spacebar: 32,
    };
    KeyCode[KeyCode.UpArrow] = "UpArrow";
    KeyCode[KeyCode.DownArrow] = "DownArrow";
    KeyCode[KeyCode.Spacebar] = "Spacebar";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionStrategy = (function () {
        function SelectionStrategy(selectionService) {
            this.selectionService = selectionService;
        }
        /**
         * @param {?} selectionService
         * @return {?}
         */
        SelectionStrategy.prototype.setSelectionService =
            function (selectionService) {
                this.selectionService = selectionService;
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.mousedown =
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.click =
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.keydown =
            function (event, data) { };
        /**
         * Select the item - default behavior
         */
        /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.select =
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).select.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Toggle the item's selected state - default behavior
         */
        /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.toggle =
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).toggle.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Deselect the item - default behavior
         */
        /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.deselect =
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).deselect.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Select all items - default behavior
         */
        /**
         * Select all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.selectAll =
            function () {
                this.select.apply(this, __spread(this.selectionService.dataset));
            };
        /**
         * Deselect all items - default behavior
         */
        /**
         * Deselect all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.deselectAll =
            function () {
                this.deselect.apply(this, __spread(this.selectionService.dataset));
            };
        /**
         * @return {?}
         */
        SelectionStrategy.prototype.destroy =
            function () { };
        return SelectionStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowSelectionStrategy = (function (_super) {
        __extends(RowSelectionStrategy, _super);
        function RowSelectionStrategy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._selection = { start: null, end: null };
            return _this;
        }
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         */
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
        RowSelectionStrategy.prototype.mousedown =
            function (event) {
                event.preventDefault();
            };
        /**
         * When a row is clicked we want to handle selection
         */
        /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.click =
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if the shift key is pressed we want to perform a multiple selection
                if (shiftKey) {
                    return this.multipleSelect(data);
                }
                // if the control key is pressed we want to perform an additive toggle selection
                if (ctrlKey) {
                    return this.toggle(data);
                }
                // perform a single selection where all other rows are deselected
                this.singleSelect(data);
            };
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         */
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.keydown =
            function (event, data) {
                switch (event.keyCode) {
                    case KeyCode.UpArrow:
                    case KeyCode.DownArrow:
                        event.preventDefault();
                        this.navigate(event, data);
                        break;
                    case KeyCode.Spacebar:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data, true);
                        break;
                }
            };
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         */
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @param {?=} activate
         * @return {?}
         */
        RowSelectionStrategy.prototype.toggle =
            function (data, activate) {
                if (activate === void 0) {
                    activate = false;
                }
                _super.prototype.toggle.call(this, data);
                // store or clear the selection
                this.selectionService.isSelected(data) ? this.setSelectionStart(data) : this.clearSelection();
                // if we want to keep the item activated then activate
                if (activate) {
                    this.selectionService.activate(data);
                }
            };
        /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.singleSelect =
            function (data) {
                // deselect all other rows if neither modifier key is pressed
                this.deselectAll();
                // select the current row
                this.select(data);
                // store the current item as the selection start
                this.setSelectionStart(data);
            };
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         */
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.multipleSelect =
            function (data) {
                // if no selection currently exists then perform initial selection
                if (!this._selection.start) {
                    // select the row
                    this.select(data);
                    // store the starting point
                    return this.setSelectionStart(data);
                }
                // if a multiple selection already took place - clear the previous selection
                if (this._selection.start && this._selection.end) {
                    this.deselect.apply(this, __spread(this.getSelectedItems()));
                }
                // set the new selection end point
                this.setSelectionEnd(data);
                // select all the items in the range
                this.select.apply(this, __spread(this.getSelectedItems()));
            };
        /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionStart =
            function (data) {
                this._selection.start = data;
                this._selection.end = null;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionEnd =
            function (data) {
                this._selection.end = data;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Clear both start and end selection points
         */
        /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
        RowSelectionStrategy.prototype.clearSelection =
            function (deactivate) {
                if (deactivate === void 0) {
                    deactivate = true;
                }
                // reset the selected item
                this._selection = { start: null, end: null };
                // remove the current active item
                if (deactivate) {
                    this.selectionService.deactivate();
                }
            };
        /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
        RowSelectionStrategy.prototype.getSelectedItems =
            function () {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                var /** @type {?} */ startIdx = dataset.indexOf(this._selection.start);
                var /** @type {?} */ endIdx = dataset.indexOf(this._selection.end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.navigate =
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                // activate the sibling - if the up arrow is pressed then navigate to the previous sibling
                var /** @type {?} */ sibling = this.selectionService.activateSibling(event.keyCode === KeyCode.UpArrow);
                // if the shift key is pressed then we also want to toggle the state if the item
                if (shiftKey && sibling) {
                    // if there is no current selection start then select the current row
                    if (!this._selection.start) {
                        this.multipleSelect(data);
                    }
                    this.multipleSelect(sibling);
                }
            };
        return RowSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowAltSelectionStrategy = (function (_super) {
        __extends(RowAltSelectionStrategy, _super);
        function RowAltSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.keydown =
            function (event, data) {
                switch (event.keyCode) {
                    case KeyCode.UpArrow:
                    case KeyCode.DownArrow:
                        event.preventDefault();
                        this.handleCursorKey(event, data);
                        break;
                    case KeyCode.Spacebar:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data);
                        break;
                }
            };
        /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.handleCursorKey =
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                if (ctrlKey) {
                    this.selectionService.activateSibling(event.keyCode === KeyCode.UpArrow);
                }
                else {
                    var /** @type {?} */ sibling = this.selectionService.getSibling(event.keyCode === KeyCode.UpArrow);
                    this.multipleSelect(sibling ? sibling : data);
                }
            };
        return RowAltSelectionStrategy;
    }(RowSelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SimpleSelectionStrategy = (function (_super) {
        __extends(SimpleSelectionStrategy, _super);
        function SimpleSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * When the item is clicked simply toggle the current selected state
         */
        /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.click =
            function (event, data) {
                this.toggle(data);
            };
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         */
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.keydown =
            function (event, data) {
                switch (event.keyCode) {
                    case KeyCode.UpArrow:
                        event.preventDefault();
                        return this.selectionService.activateSibling(true);
                    case KeyCode.DownArrow:
                        event.preventDefault();
                        return this.selectionService.activateSibling(false);
                    case KeyCode.Spacebar:
                        event.preventDefault();
                        return this.toggle(data);
                }
            };
        /**
         * Override the standard toggle function to always activate the item
         */
        /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.toggle =
            function (data) {
                _super.prototype.toggle.call(this, data);
                this.selectionService.activate(data);
            };
        return SimpleSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionService = (function () {
        function SelectionService() {
            this._selection = new Set();
            this.dataset = [];
            this.enabled = true;
            this.clickEnabled = true;
            this.keyboardEnabled = true;
            this.strategy = new SimpleSelectionStrategy(this);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.focusTarget$ = new BehaviorSubject.BehaviorSubject(null);
            this.selection$ = new BehaviorSubject.BehaviorSubject([]);
            this._strategyToDestroy = this.strategy;
        }
        /**
         * @return {?}
         */
        SelectionService.prototype.ngOnDestroy =
            function () {
                if (this._strategyToDestroy) {
                    this._strategyToDestroy.destroy();
                }
            };
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         */
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.select =
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // add each selection to the set
                selections.forEach(function (selection) { return _this._selection.add(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Remove an item from the list of selected items
         */
        /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.deselect =
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // remove each item from the set
                selections.forEach(function (selection) { return _this._selection.delete(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Toggle the selected state of any specified items
         */
        /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.toggle =
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                selections.forEach(function (selection) { return _this.isSelected(selection) ? _this.deselect(selection) : _this.select(selection); });
            };
        /**
         * Determine whether or not a specific item is currently selected
         */
        /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.isSelected =
            function (data) {
                return this._selection.has(data);
            };
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         */
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.selected$ =
            function (data) {
                var _this = this;
                return this.selection$.pipe(operators.map(function () { return _this.isSelected(data); }), operators.distinctUntilChanged());
            };
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         */
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
        SelectionService.prototype.setMode =
            function (mode) {
                if (this._strategyToDestroy) {
                    // Destroy previous strategy if it was created internally
                    this._strategyToDestroy.destroy();
                    this._strategyToDestroy = null;
                }
                if (mode instanceof SelectionStrategy) {
                    // Custom strategy - pass in the service instance
                    this.strategy = mode;
                    this.strategy.setSelectionService(this);
                }
                else {
                    switch (mode.toLowerCase().trim()) {
                        case 'simple':
                            this.strategy = this._strategyToDestroy = new SimpleSelectionStrategy(this);
                            break;
                        case 'row':
                            this.strategy = this._strategyToDestroy = new RowSelectionStrategy(this);
                            break;
                        case 'row-alt':
                            this.strategy = this._strategyToDestroy = new RowAltSelectionStrategy(this);
                            break;
                        default:
                            throw new Error("The selection mode '" + mode + "' does not exist. Valid modes are 'simple', 'row', or 'row-alt'.");
                    }
                }
            };
        /**
         * Set the current active item
         */
        /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.activate =
            function (data) {
                this.active$.next(data);
            };
        /**
         * Deactive all items
         */
        /**
         * Deactive all items
         * @return {?}
         */
        SelectionService.prototype.deactivate =
            function () {
                this.active$.next(null);
            };
        /**
         * Return the next or previous sibling of the current active item.
         * @param previous If true, the previous sibling will be returned.
         */
        /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
        SelectionService.prototype.getSibling =
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                // get the currently active item
                var /** @type {?} */ current = this.active$.getValue();
                // check if there is a current active item
                if (!current) {
                    return;
                }
                // get the index of the current item
                var /** @type {?} */ idx = this.dataset.indexOf(current);
                var /** @type {?} */ target = this.dataset[previous ? idx - 1 : idx + 1];
                return target;
            };
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         */
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
        SelectionService.prototype.activateSibling =
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                var /** @type {?} */ target = this.getSibling(previous);
                // check if the target exists
                if (target) {
                    this.activate(target);
                }
                return target;
            };
        /**
         * @param {?} disabled
         * @return {?}
         */
        SelectionService.prototype.setDisabled =
            function (disabled) {
                // store the current disabled state
                this.enabled = !disabled;
                // clear any stateful data
                this.active$.next(null);
                this._selection.clear();
                // emit the selection change information
                this.selectionHasMutated();
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.selectionHasMutated =
            function () {
                this.selection$.next(Array.from(this._selection));
            };
        SelectionService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        SelectionService.ctorParameters = function () { return []; };
        return SelectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionItemDirective = (function () {
        function SelectionItemDirective(_selectionService, _elementRef) {
            this._selectionService = _selectionService;
            this._elementRef = _elementRef;
            this.tabindex = null;
            this.selectedChange = new core.EventEmitter();
            this.active = false;
            this._selected = false;
            this._managedTabIndex = -1;
            this._subscriptions = new Subscription.Subscription();
        }
        Object.defineProperty(SelectionItemDirective.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            set: /**
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                selected ? this.select() : this.deselect();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "attrTabIndex", {
            get: /**
             * @return {?}
             */ function () {
                return (this.tabindex !== null) ? this.tabindex : this._managedTabIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnInit =
            function () {
                var _this = this;
                // if there is no associated data then throw an error
                if (!this.uxSelectionItem) {
                    throw new Error('The uxSelectionItem directive must have data associated with it.');
                }
                // subscribe to selection changes on this item
                this._subscriptions.add(this._selectionService.selected$(this.uxSelectionItem).subscribe(function (selected) {
                    // store the selected state
                    // store the selected state
                    _this._selected = selected;
                    // emit the selected state
                    // emit the selected state
                    _this.selectedChange.emit(selected);
                }));
                // subscribe to changes to the active state
                this._subscriptions.add(this._selectionService.active$.pipe(operators.map(function (active) { return active === _this.uxSelectionItem; })).subscribe(function (active) {
                    // store the focus state
                    // store the focus state
                    _this.active = active;
                    // if it is active then focus the element
                    if (active === true) {
                        _this._selectionService.focusTarget$.next(_this.uxSelectionItem);
                        _this._elementRef.nativeElement.focus();
                    }
                }));
                // Subscribe to changes to the focus target
                // This is mostly the same as active$, except that it has an initial value of the first item in the collection.
                this._subscriptions.add(this._selectionService.focusTarget$.subscribe(function (focusTarget) {
                    _this._managedTabIndex = (focusTarget === _this.uxSelectionItem) ? 0 : -1;
                }));
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnDestroy =
            function () {
                this._subscriptions.unsubscribe();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.click =
            function (event) {
                if (this._selectionService.enabled && this._selectionService.clickEnabled) {
                    this._selectionService.strategy.click(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.mousedown =
            function (event) {
                if (this._selectionService.enabled && this._selectionService.clickEnabled) {
                    this._selectionService.strategy.mousedown(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.keydown =
            function (event) {
                if (this._selectionService.enabled && this._selectionService.keyboardEnabled) {
                    this._selectionService.strategy.keydown(event, this.uxSelectionItem);
                }
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.focus =
            function () {
                // If tabbed to from outside the component, activate.
                if (this._selectionService.active$.getValue() !== this.uxSelectionItem) {
                    this._selectionService.activate(this.uxSelectionItem);
                }
            };
        /**
         * Select this item using the current strategy
         */
        /**
         * Select this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.select =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.select(this.uxSelectionItem);
                }
            };
        /**
         * Deselect this item using the current strategy
         */
        /**
         * Deselect this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.deselect =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.deselect(this.uxSelectionItem);
                }
            };
        SelectionItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelectionItem]',
                        exportAs: 'ux-selection-item'
                    },] },
        ];
        /** @nocollapse */
        SelectionItemDirective.ctorParameters = function () {
            return [
                { type: SelectionService, },
                { type: core.ElementRef, },
            ];
        };
        SelectionItemDirective.propDecorators = {
            "uxSelectionItem": [{ type: core.Input },],
            "selected": [{ type: core.Input }, { type: core.HostBinding, args: ['class.ux-selection-selected',] },],
            "tabindex": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
            "active": [{ type: core.HostBinding, args: ['class.ux-selection-focused',] },],
            "attrTabIndex": [{ type: core.HostBinding, args: ['attr.tabindex',] },],
            "click": [{ type: core.HostListener, args: ['click', ['$event'],] },],
            "mousedown": [{ type: core.HostListener, args: ['mousedown', ['$event'],] },],
            "keydown": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
            "focus": [{ type: core.HostListener, args: ['focus',] },],
        };
        return SelectionItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionDirective = (function () {
        function SelectionDirective(_selectionService, _cdRef) {
            var _this = this;
            this._selectionService = _selectionService;
            this._cdRef = _cdRef;
            this.tabindex = null;
            this.uxSelectionChange = new core.EventEmitter();
            this._subscriptions = new Subscription.Subscription();
            this._subscriptions.add(_selectionService.selection$.subscribe(function (items) { return _this.uxSelectionChange.emit(items); }));
        }
        Object.defineProperty(SelectionDirective.prototype, "uxSelection", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                (_a = this._selectionService).select.apply(_a, __spread(items));
                var _a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "disabled", {
            set: /**
             * @param {?} disabled
             * @return {?}
             */ function (disabled) {
                this._selectionService.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "mode", {
            set: /**
             * @param {?} mode
             * @return {?}
             */ function (mode) {
                this._selectionService.setMode(mode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "clickSelection", {
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._selectionService.clickEnabled = enabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "keyboardSelection", {
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._selectionService.keyboardEnabled = enabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngAfterContentInit =
            function () {
                var _this = this;
                // provide the initial list of selection items
                this.update();
                // if the list changes then inform the service
                this._subscriptions.add(this.items.changes.subscribe(function () { return _this.update(); }));
                // The above could trigger a change in the computed tabindex for selection items
                this._cdRef.detectChanges();
            };
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngOnDestroy =
            function () {
                this._subscriptions.unsubscribe();
            };
        /**
         * Update the dataset to reflect the latest selection items
         */
        /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
        SelectionDirective.prototype.update =
            function () {
                this._selectionService.dataset = this.items.map(function (item) { return item.uxSelectionItem; });
                // Make sure that a tab target has been defined so that the component can be tabbed to.
                if (this._selectionService.focusTarget$.getValue() === null && this._selectionService.dataset.length > 0) {
                    this._selectionService.focusTarget$.next(this._selectionService.dataset[0]);
                }
            };
        /**
         * Select all the items in the list
         */
        /**
         * Select all the items in the list
         * @return {?}
         */
        SelectionDirective.prototype.selectAll =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.selectAll();
                }
            };
        /**
         * Deselect all currently selected items
         */
        /**
         * Deselect all currently selected items
         * @return {?}
         */
        SelectionDirective.prototype.deselectAll =
            function () {
                if (this._selectionService.enabled) {
                    this._selectionService.strategy.deselectAll();
                }
            };
        SelectionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelection]',
                        exportAs: 'ux-selection',
                        providers: [SelectionService]
                    },] },
        ];
        /** @nocollapse */
        SelectionDirective.ctorParameters = function () {
            return [
                { type: SelectionService, },
                { type: core.ChangeDetectorRef, },
            ];
        };
        SelectionDirective.propDecorators = {
            "uxSelection": [{ type: core.Input },],
            "disabled": [{ type: core.Input },],
            "mode": [{ type: core.Input },],
            "clickSelection": [{ type: core.Input },],
            "keyboardSelection": [{ type: core.Input },],
            "tabindex": [{ type: core.Input }, { type: core.HostBinding, args: ['attr.tabindex',] },],
            "uxSelectionChange": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [SelectionItemDirective,] },],
        };
        return SelectionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionModule = (function () {
        function SelectionModule() {
        }
        SelectionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [SelectionDirective, SelectionItemDirective],
                        exports: [SelectionDirective, SelectionItemDirective]
                    },] },
        ];
        /** @nocollapse */
        SelectionModule.ctorParameters = function () { return []; };
        return SelectionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ContactsNg1Component = (function (_super) {
        __extends(ContactsNg1Component, _super);
        function ContactsNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'contactGroup', elementRef, injector) || this;
            _this.overflowClick = new core.EventEmitter();
            return _this;
        }
        ContactsNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'contact-group'
                    },] },
        ];
        /** @nocollapse */
        ContactsNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        ContactsNg1Component.propDecorators = {
            "contacts": [{ type: core.Input },],
            "organization": [{ type: core.Input },],
            "size": [{ type: core.Input },],
            "colors": [{ type: core.Input },],
            "maxContacts": [{ type: core.Input },],
            "overflowClick": [{ type: core.Output },],
        };
        return ContactsNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ExpandInputNg1Component = (function (_super) {
        __extends(ExpandInputNg1Component, _super);
        function ExpandInputNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'expandInput', elementRef, injector) || this;
            _this.focus = new core.EventEmitter();
            return _this;
        }
        ExpandInputNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'expand-input'
                    },] },
        ];
        /** @nocollapse */
        ExpandInputNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        ExpandInputNg1Component.propDecorators = {
            "elname": [{ type: core.Input },],
            "placeHolder": [{ type: core.Input },],
            "className": [{ type: core.Input },],
            "clearTextIcon": [{ type: core.Input },],
            "closeSearch": [{ type: core.Input },],
            "expandAlways": [{ type: core.Input },],
            "onEnter": [{ type: core.Input },],
            "focus": [{ type: core.Output },],
        };
        return ExpandInputNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonNg1Component = (function (_super) {
        __extends(FloatingActionButtonNg1Component, _super);
        function FloatingActionButtonNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'floatingActionButton', elementRef, injector) || this;
            _this.items = [];
            return _this;
        }
        FloatingActionButtonNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'floating-action-button'
                    },] },
        ];
        /** @nocollapse */
        FloatingActionButtonNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        FloatingActionButtonNg1Component.propDecorators = {
            "items": [{ type: core.Input },],
            "primary": [{ type: core.Input },],
            "direction": [{ type: core.Input },],
            "fabTooltip": [{ type: core.Input },],
            "fabTooltipPlacement": [{ type: core.Input },],
        };
        return FloatingActionButtonNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlotNg1Component = (function (_super) {
        __extends(FlotNg1Component, _super);
        function FlotNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxFlotNg1', elementRef, injector) || this;
            _this.onPlotClick = new core.EventEmitter();
            _this.onPlotHover = new core.EventEmitter();
            return _this;
        }
        FlotNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'flot'
                    },] },
        ];
        /** @nocollapse */
        FlotNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        FlotNg1Component.propDecorators = {
            "dataset": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "callback": [{ type: core.Input },],
            "donutLabels": [{ type: core.Input },],
            "onPlotClick": [{ type: core.Output },],
            "onPlotHover": [{ type: core.Output },],
        };
        return FlotNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GridNg1Component = (function (_super) {
        __extends(GridNg1Component, _super);
        function GridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'grid', elementRef, injector) || this;
            _this.source = [];
            _this.columns = [];
            return _this;
        }
        GridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'grid'
                    },] },
        ];
        /** @nocollapse */
        GridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        GridNg1Component.propDecorators = {
            "source": [{ type: core.Input },],
            "columns": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "events": [{ type: core.Input },],
            "plugins": [{ type: core.Input },],
        };
        return GridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarNg1Component = (function (_super) {
        __extends(HierarchyBarNg1Component, _super);
        function HierarchyBarNg1Component(elementRef, injector) {
            return _super.call(this, 'hierarchyBar', elementRef, injector) || this;
        }
        HierarchyBarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'hierarchy-bar'
                    },] },
        ];
        /** @nocollapse */
        HierarchyBarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        HierarchyBarNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "selectNode": [{ type: core.Input },],
            "containerClass": [{ type: core.Input },],
        };
        return HierarchyBarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardNg1Component = (function (_super) {
        __extends(MarqueeWizardNg1Component, _super);
        function MarqueeWizardNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'marqueeWizard', elementRef, injector) || this;
            _this.wizardStepsChange = new core.EventEmitter();
            return _this;
        }
        MarqueeWizardNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'marquee-wizard'
                    },] },
        ];
        /** @nocollapse */
        MarqueeWizardNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        MarqueeWizardNg1Component.propDecorators = {
            "wizardIcon": [{ type: core.Input },],
            "wizardSteps": [{ type: core.Input },],
            "buttonOptions": [{ type: core.Input },],
            "onChanging": [{ type: core.Input },],
            "onFinished": [{ type: core.Input },],
            "onFinishing": [{ type: core.Input },],
            "onCanceled": [{ type: core.Input },],
            "isVisited": [{ type: core.Input },],
            "sideInfo": [{ type: core.Input },],
            "wizardStepsChange": [{ type: core.Output },],
        };
        return MarqueeWizardNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NestedDonutNg1Component = (function (_super) {
        __extends(NestedDonutNg1Component, _super);
        function NestedDonutNg1Component(elementRef, injector) {
            return _super.call(this, 'uxNestedDonutNg1', elementRef, injector) || this;
        }
        NestedDonutNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'nested-donut'
                    },] },
        ];
        /** @nocollapse */
        NestedDonutNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        NestedDonutNg1Component.propDecorators = {
            "dataset": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return NestedDonutNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OrganizationChartNg1Component = (function (_super) {
        __extends(OrganizationChartNg1Component, _super);
        function OrganizationChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxOrganizationChartNg1', elementRef, injector) || this;
            _this.dataChange = new core.EventEmitter();
            _this.optionsChange = new core.EventEmitter();
            return _this;
        }
        OrganizationChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'organization-chart'
                    },] },
        ];
        /** @nocollapse */
        OrganizationChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        OrganizationChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "dataChange": [{ type: core.Output },],
            "optionsChange": [{ type: core.Output },],
        };
        return OrganizationChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PartitionMapNg1Component = (function (_super) {
        __extends(PartitionMapNg1Component, _super);
        function PartitionMapNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPartitionMapNg1', elementRef, injector) || this;
        }
        PartitionMapNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'partition-map'
                    },] },
        ];
        /** @nocollapse */
        PartitionMapNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PartitionMapNg1Component.propDecorators = {
            "chartData": [{ type: core.Input },],
            "chartOptions": [{ type: core.Input },],
            "chartLoading": [{ type: core.Input },],
        };
        return PartitionMapNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityBarChartNg1Component = (function (_super) {
        __extends(PeityBarChartNg1Component, _super);
        function PeityBarChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityBarChartNg1', elementRef, injector) || this;
        }
        PeityBarChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'bar-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityBarChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityBarChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return PeityBarChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityLineChartNg1Component = (function (_super) {
        __extends(PeityLineChartNg1Component, _super);
        function PeityLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityLineChartNg1', elementRef, injector) || this;
        }
        PeityLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'line-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityLineChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return PeityLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityPieChartNg1Component = (function (_super) {
        __extends(PeityPieChartNg1Component, _super);
        function PeityPieChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityPieChartNg1', elementRef, injector) || this;
        }
        PeityPieChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'pie-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityPieChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityPieChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
        };
        return PeityPieChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityUpdatingLineChartNg1Component = (function (_super) {
        __extends(PeityUpdatingLineChartNg1Component, _super);
        function PeityUpdatingLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityUpdatingLineChartNg1', elementRef, injector) || this;
        }
        PeityUpdatingLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'updating-line-chart'
                    },] },
        ];
        /** @nocollapse */
        PeityUpdatingLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        PeityUpdatingLineChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "method": [{ type: core.Input },],
            "updateinterval": [{ type: core.Input },],
        };
        return PeityUpdatingLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SankeyNg1Component = (function (_super) {
        __extends(SankeyNg1Component, _super);
        function SankeyNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSankeyNg1', elementRef, injector) || this;
        }
        SankeyNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sankey'
                    },] },
        ];
        /** @nocollapse */
        SankeyNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SankeyNg1Component.propDecorators = {
            "chartSize": [{ type: core.Input },],
            "chartData": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "click": [{ type: core.Input },],
        };
        return SankeyNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchToolbarNg1Component = (function (_super) {
        __extends(SearchToolbarNg1Component, _super);
        function SearchToolbarNg1Component(elementRef, injector) {
            return _super.call(this, 'searchToolbar', elementRef, injector) || this;
        }
        SearchToolbarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'search-toolbar'
                    },] },
        ];
        /** @nocollapse */
        SearchToolbarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SearchToolbarNg1Component.propDecorators = {
            "searchTypeahead": [{ type: core.Input },],
            "placeHolder": [{ type: core.Input },],
            "closeSearch": [{ type: core.Input },],
            "onSearch": [{ type: core.Input },],
            "onFocus": [{ type: core.Input },],
        };
        return SearchToolbarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectTableNg1Component = (function (_super) {
        __extends(SelectTableNg1Component, _super);
        function SelectTableNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'selectTable', elementRef, injector) || this;
            _this.selectedChange = new core.EventEmitter();
            return _this;
        }
        SelectTableNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'select-table'
                    },] },
        ];
        /** @nocollapse */
        SelectTableNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SelectTableNg1Component.propDecorators = {
            "values": [{ type: core.Input },],
            "multipleSelect": [{ type: core.Input },],
            "selectKey": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "searchText": [{ type: core.Input },],
            "tableHeight": [{ type: core.Input },],
            "selectHiddenItems": [{ type: core.Input },],
            "selectedChange": [{ type: core.Output },],
        };
        return SelectTableNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SLIDER_CHART_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SliderChartNg1Component; }),
        multi: true
    };
    var SliderChartNg1Component = (function (_super) {
        __extends(SliderChartNg1Component, _super);
        function SliderChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'sliderChart', elementRef, injector) || this;
            _this.ngModelChange = new core.EventEmitter();
            return _this;
        }
        /**
         * @param {?} obj
         * @return {?}
         */
        SliderChartNg1Component.prototype.writeValue =
            function (obj) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnChange =
            function (fn) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnTouched =
            function (fn) { };
        SliderChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'slider-chart',
                        providers: [SLIDER_CHART_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        SliderChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SliderChartNg1Component.propDecorators = {
            "sliderOptions": [{ type: core.Input },],
            "ngModel": [{ type: core.Input },],
            "chartOptions": [{ type: core.Input },],
            "chartData": [{ type: core.Input },],
            "ngModelChange": [{ type: core.Output },],
        };
        return SliderChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SocialChartNg1Component = (function (_super) {
        __extends(SocialChartNg1Component, _super);
        function SocialChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSocialChartNg1', elementRef, injector) || this;
        }
        SocialChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'social-chart'
                    },] },
        ];
        /** @nocollapse */
        SocialChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SocialChartNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "height": [{ type: core.Input },],
            "api": [{ type: core.Input },],
            "communities": [{ type: core.Input },],
            "detailStyle": [{ type: core.Input },],
            "popoverStyle": [{ type: core.Input },],
            "nodeDetail": [{ type: core.Input },],
            "edgeDetail": [{ type: core.Input },],
            "nodePopover": [{ type: core.Input },],
            "edgePopover": [{ type: core.Input },],
            "forceAtlasDuration": [{ type: core.Input },],
            "nodeSizeAttribute": [{ type: core.Input },],
            "startMaximized": [{ type: core.Input },],
            "startMaximised": [{ type: core.Input },],
            "showMaximizeControl": [{ type: core.Input },],
            "showMaximiseControl": [{ type: core.Input },],
            "socialChartContainer": [{ type: core.Input },],
            "fullscreenButtonPosition": [{ type: core.Input },],
            "localStrings": [{ type: core.Input },],
            "chartTitle": [{ type: core.Input },],
            "titleDisplayTime": [{ type: core.Input },],
            "edgeWeightInfluence": [{ type: core.Input },],
            "minLabels": [{ type: core.Input },],
        };
        return SocialChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SortDirectionToggleNg1Component = (function (_super) {
        __extends(SortDirectionToggleNg1Component, _super);
        function SortDirectionToggleNg1Component(elementRef, injector) {
            return _super.call(this, 'sortDirectionToggle', elementRef, injector) || this;
        }
        SortDirectionToggleNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sort-direction-toggle'
                    },] },
        ];
        /** @nocollapse */
        SortDirectionToggleNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        SortDirectionToggleNg1Component.propDecorators = {
            "label": [{ type: core.Input },],
            "sorters": [{ type: core.Input },],
            "descend": [{ type: core.Input },],
        };
        return SortDirectionToggleNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridNg1Component = (function (_super) {
        __extends(TreeGridNg1Component, _super);
        function TreeGridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'treegrid', elementRef, injector) || this;
            _this.optionsChange = new core.EventEmitter();
            _this.selectedChange = new core.EventEmitter();
            _this.currentRowChange = new core.EventEmitter();
            _this.treeDataChange = new core.EventEmitter();
            return _this;
        }
        TreeGridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'treegrid'
                    },] },
        ];
        /** @nocollapse */
        TreeGridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        TreeGridNg1Component.propDecorators = {
            "data": [{ type: core.Input },],
            "columns": [{ type: core.Input },],
            "treeData": [{ type: core.Input },],
            "selected": [{ type: core.Input },],
            "currentRow": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "optionsChange": [{ type: core.Output },],
            "selectedChange": [{ type: core.Output },],
            "currentRowChange": [{ type: core.Output },],
            "treeDataChange": [{ type: core.Output },],
        };
        return TreeGridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ThumbnailNg1Component = (function (_super) {
        __extends(ThumbnailNg1Component, _super);
        function ThumbnailNg1Component(elementRef, injector) {
            return _super.call(this, 'thumbnail', elementRef, injector) || this;
        }
        ThumbnailNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'thumbnail'
                    },] },
        ];
        /** @nocollapse */
        ThumbnailNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.Injector, },
            ];
        };
        ThumbnailNg1Component.propDecorators = {
            "url": [{ type: core.Input },],
            "show": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "height": [{ type: core.Input },],
        };
        return ThumbnailNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationMenuService = (function () {
        function NavigationMenuService(_navigationMenuService) {
            this._navigationMenuService = _navigationMenuService;
        }
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.show =
            function () {
                this._navigationMenuService.show();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.hide =
            function () {
                this._navigationMenuService.hide();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.visible =
            function () {
                return this._navigationMenuService.visible();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.collapseAtWidth =
            function () {
                return this._navigationMenuService.collapseAtWidth();
            };
        /**
         * @param {?} width
         * @return {?}
         */
        NavigationMenuService.prototype.setCollapseAtWidth =
            function (width) {
                this._navigationMenuService.setCollapseAtWidth(width);
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.setDefaultCollapseAtWidth =
            function () {
                this._navigationMenuService.setDefaultCollapseAtWidth();
            };
        NavigationMenuService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        NavigationMenuService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$navigationMenu',] },] },
            ];
        };
        return NavigationMenuService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function navigationMenuServiceFactory(injector) {
        return injector.get('$navigationMenu');
    }
    var /** @type {?} */ navigationMenuServiceProvider = {
        provide: '$navigationMenu',
        useFactory: navigationMenuServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PdfService = (function () {
        function PdfService(_pdfService) {
            this._pdfService = _pdfService;
        }
        /**
         * @param {?} columns
         * @param {?} rows
         * @param {?=} options
         * @return {?}
         */
        PdfService.prototype.createTable =
            function (columns, rows, options) {
                if (options === void 0) {
                    options = {};
                }
                return this._pdfService.createTable(columns, rows, options);
            };
        PdfService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PdfService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$pdf',] },] },
            ];
        };
        return PdfService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function pdfServiceFactory(injector) {
        return injector.get('$pdf');
    }
    var /** @type {?} */ pdfServiceProvider = {
        provide: '$pdf',
        useFactory: pdfServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeAgoService = (function () {
        function TimeAgoService(_timeAgoService) {
            this._timeAgoService = _timeAgoService;
        }
        /**
         * @param {?} strings
         * @return {?}
         */
        TimeAgoService.prototype.setStrings =
            function (strings) {
                this._timeAgoService.setStrings(strings);
            };
        /**
         * @param {?} past
         * @param {?} present
         * @return {?}
         */
        TimeAgoService.prototype.timeSince =
            function (past, present) {
                return this._timeAgoService.timeSince(past, present);
            };
        /**
         * @param {?} moment
         * @return {?}
         */
        TimeAgoService.prototype.timeSinceNow =
            function (moment) {
                return this._timeAgoService.timeSinceNow(moment);
            };
        TimeAgoService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TimeAgoService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['timeAgoService',] },] },
            ];
        };
        return TimeAgoService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function timeAgoServiceFactory(injector) {
        return injector.get('timeAgoService');
    }
    var /** @type {?} */ timeAgoServiceProvider = {
        provide: 'timeAgoService',
        useFactory: timeAgoServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ declarations = [
        ContactsNg1Component,
        ExpandInputNg1Component,
        FloatingActionButtonNg1Component,
        FlotNg1Component,
        GridNg1Component,
        HierarchyBarNg1Component,
        MarqueeWizardNg1Component,
        NestedDonutNg1Component,
        OrganizationChartNg1Component,
        PartitionMapNg1Component,
        PeityBarChartNg1Component,
        PeityLineChartNg1Component,
        PeityPieChartNg1Component,
        PeityUpdatingLineChartNg1Component,
        SankeyNg1Component,
        SearchToolbarNg1Component,
        SelectTableNg1Component,
        SliderChartNg1Component,
        SocialChartNg1Component,
        SortDirectionToggleNg1Component,
        TreeGridNg1Component,
        ThumbnailNg1Component,
    ];
    var HybridModule = (function () {
        function HybridModule() {
        }
        HybridModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: declarations,
                        declarations: declarations,
                        providers: [
                            navigationMenuServiceProvider,
                            pdfServiceProvider,
                            timeAgoServiceProvider,
                            TimeAgoService,
                            PdfService,
                            NavigationMenuService,
                        ],
                    },] },
        ];
        /** @nocollapse */
        HybridModule.ctorParameters = function () { return []; };
        return HybridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterPipe = (function () {
        function StringFilterPipe() {
        }
        /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
        StringFilterPipe.prototype.transform =
            function (items, value) {
                if (!items) {
                    return [];
                }
                return items.filter(function (it) { return it.toLowerCase().indexOf(value.toLowerCase()) >= 0; });
            };
        StringFilterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'stringFilter'
                    },] },
            { type: core.Injectable },
        ];
        /** @nocollapse */
        StringFilterPipe.ctorParameters = function () { return []; };
        return StringFilterPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterModule = (function () {
        function StringFilterModule() {
        }
        StringFilterModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [StringFilterPipe],
                        declarations: [StringFilterPipe]
                    },] },
        ];
        /** @nocollapse */
        StringFilterModule.ctorParameters = function () { return []; };
        return StringFilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CookieAdapter = (function () {
        function CookieAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.getItem =
            function (key) {
                if (document.cookie) {
                    // get all the cookies for this site
                    var /** @type {?} */ cookies = document.cookie.split(';');
                    // process the cookies into a from we can easily manage
                    var /** @type {?} */ match = cookies
                        .map(function (cookie) { return ({ key: cookie.split('=')[0].trim(), value: cookie.split('=')[1].trim() }); })
                        .find(function (cookie) { return cookie.key === key; });
                    return match ? match.value : null;
                }
                return null;
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        CookieAdapter.prototype.setItem =
            function (key, value) {
                document.cookie = key + "=" + value + "; path=/";
            };
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.removeItem =
            function (key) {
                document.cookie.split(';').forEach(function (cookie) {
                    var /** @type {?} */ eqPos = cookie.indexOf('=');
                    var /** @type {?} */ name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie;
                    if (name === key) {
                        document.cookie = cookie.trim().replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                    }
                });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.clear =
            function () {
                var _this = this;
                // call remove item on each cookie
                document.cookie.split(';').map(function (cookie) { return cookie.split('=')[0].trim(); })
                    .forEach(function (cookie) { return _this.removeItem(cookie); });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.getSupported =
            function () {
                // cookies are supported in all browsers
                return this;
            };
        return CookieAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LocalStorageAdapter = (function () {
        function LocalStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.getItem =
            function (key) {
                return localStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        LocalStorageAdapter.prototype.setItem =
            function (key, value) {
                localStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.removeItem =
            function (key) {
                localStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.clear =
            function () {
                localStorage.clear();
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.getSupported =
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!localStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    localStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    localStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return LocalStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SessionStorageAdapter = (function () {
        function SessionStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.getItem =
            function (key) {
                return sessionStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        SessionStorageAdapter.prototype.setItem =
            function (key, value) {
                sessionStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.removeItem =
            function (key) {
                sessionStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.clear =
            function () {
                sessionStorage.clear();
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.getSupported =
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!sessionStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    sessionStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    sessionStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return SessionStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataService = (function () {
        function PersistentDataService() {
        }
        /**
         * Save the item in some form of persistent storage
         */
        /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.setItem =
            function (key, value, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).setItem(key, value);
            };
        /**
         * Get a stored value from persistent storage
         */
        /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.getItem =
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                return this.getAdapter(type).getItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.removeItem =
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).removeItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.clear =
            function (type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).clear();
            };
        /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
        PersistentDataService.prototype.getAdapter =
            function (type) {
                switch (type) {
                    case PersistentDataStorageType.Cookie:
                        return new CookieAdapter();
                    case PersistentDataStorageType.LocalStorage:
                        var /** @type {?} */ localStorageAdapter = new LocalStorageAdapter();
                        return localStorageAdapter.getSupported();
                    case PersistentDataStorageType.SessionStorage:
                        var /** @type {?} */ sessionStorageAdapter = new SessionStorageAdapter();
                        return sessionStorageAdapter.getSupported();
                }
            };
        PersistentDataService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PersistentDataService.ctorParameters = function () { return []; };
        return PersistentDataService;
    }());
    /** @enum {number} */
    var PersistentDataStorageType = {
        LocalStorage: 0,
        Cookie: 1,
        SessionStorage: 2,
    };
    PersistentDataStorageType[PersistentDataStorageType.LocalStorage] = "LocalStorage";
    PersistentDataStorageType[PersistentDataStorageType.Cookie] = "Cookie";
    PersistentDataStorageType[PersistentDataStorageType.SessionStorage] = "SessionStorage";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataModule = (function () {
        function PersistentDataModule() {
        }
        PersistentDataModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [PersistentDataService],
                    },] },
        ];
        /** @nocollapse */
        PersistentDataModule.ctorParameters = function () { return []; };
        return PersistentDataModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ StorageAdapter = (function () {
        function StorageAdapter() {
        }
        return StorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.BreadcrumbsComponent = BreadcrumbsComponent;
    exports.BreadcrumbsModule = BreadcrumbsModule;
    exports.CardTabsModule = CardTabsModule;
    exports.CardTabsService = CardTabsService;
    exports.CardTabsetComponent = CardTabsetComponent;
    exports.CardTabComponent = CardTabComponent;
    exports.CardTabContentDirective = CardTabContentDirective;
    exports.CheckboxModule = CheckboxModule;
    exports.CHECKBOX_VALUE_ACCESSOR = CHECKBOX_VALUE_ACCESSOR;
    exports.CheckboxComponent = CheckboxComponent;
    exports.ColumnSortingModule = ColumnSortingModule;
    exports.ColumnSortingComponent = ColumnSortingComponent;
    exports.ColumnSortingState = ColumnSortingState;
    exports.ColumnSortingDirective = ColumnSortingDirective;
    exports.ConduitSubject = ConduitSubject;
    exports.ConduitZoneComponent = ConduitZoneComponent;
    exports.ConduitZone = ConduitZone;
    exports.ConduitComponent = ConduitComponent;
    exports.CONDUITS = CONDUITS;
    exports.Conduit = Conduit;
    exports.defaultConduitProps = defaultConduitProps;
    exports.DashboardModule = DashboardModule;
    exports.DashboardComponent = DashboardComponent;
    exports.DashboardService = DashboardService;
    exports.defaultOptions = defaultOptions;
    exports.ActionDirection = ActionDirection;
    exports.Rounding = Rounding;
    exports.DashboardDragHandleDirective = DashboardDragHandleDirective;
    exports.DashboardWidgetComponent = DashboardWidgetComponent;
    exports.DateTimePickerModule = DateTimePickerModule;
    exports.DateTimePickerComponent = DateTimePickerComponent;
    exports.DateTimePickerService = DateTimePickerService;
    exports.DatePickerMode = DatePickerMode;
    exports.ModeDirection = ModeDirection;
    exports.DatePickerHeaderEvent = DatePickerHeaderEvent;
    exports.DateTimePickerConfig = DateTimePickerConfig;
    exports.EboxModule = EboxModule;
    exports.EboxComponent = EboxComponent;
    exports.EboxHeaderDirective = EboxHeaderDirective;
    exports.EboxContentDirective = EboxContentDirective;
    exports.FacetsModule = FacetsModule;
    exports.FacetContainerComponent = FacetContainerComponent;
    exports.FacetSelect = FacetSelect;
    exports.FacetDeselect = FacetDeselect;
    exports.FacetDeselectAll = FacetDeselectAll;
    exports.FacetHeaderComponent = FacetHeaderComponent;
    exports.FacetBaseComponent = FacetBaseComponent;
    exports.FacetCheckListComponent = FacetCheckListComponent;
    exports.FacetTypeaheadListComponent = FacetTypeaheadListComponent;
    exports.FacetTypeaheadHighlight = FacetTypeaheadHighlight;
    exports.Facet = Facet;
    exports.FilterModule = FilterModule;
    exports.FilterContainerComponent = FilterContainerComponent;
    exports.FilterAddEvent = FilterAddEvent;
    exports.FilterRemoveEvent = FilterRemoveEvent;
    exports.FilterRemoveAllEvent = FilterRemoveAllEvent;
    exports.FilterBaseComponent = FilterBaseComponent;
    exports.FilterDropdownComponent = FilterDropdownComponent;
    exports.FilterDynamicComponent = FilterDynamicComponent;
    exports.FlippableCardModule = FlippableCardModule;
    exports.FlippableCardComponent = FlippableCardComponent;
    exports.FlippableCardFrontDirective = FlippableCardFrontDirective;
    exports.FlippableCardBackDirective = FlippableCardBackDirective;
    exports.FloatingActionButtonsModule = FloatingActionButtonsModule;
    exports.FloatingActionButtonsComponent = FloatingActionButtonsComponent;
    exports.FloatingActionButtonComponent = FloatingActionButtonComponent;
    exports.HierarchyBarModule = HierarchyBarModule;
    exports.HierarchyBarService = HierarchyBarService;
    exports.HierarchyBarComponent = HierarchyBarComponent;
    exports.ItemDisplayPanelModule = ItemDisplayPanelModule;
    exports.ItemDisplayPanelContentDirective = ItemDisplayPanelContentDirective;
    exports.ItemDisplayPanelFooterDirective = ItemDisplayPanelFooterDirective;
    exports.ItemDisplayPanelComponent = ItemDisplayPanelComponent;
    exports.MarqueeWizardStepComponent = MarqueeWizardStepComponent;
    exports.MarqueeWizardComponent = MarqueeWizardComponent;
    exports.MarqueeWizardModule = MarqueeWizardModule;
    exports.MediaPlayerModule = MediaPlayerModule;
    exports.MediaPlayerComponent = MediaPlayerComponent;
    exports.MediaPlayerBaseExtensionDirective = MediaPlayerBaseExtensionDirective;
    exports.MediaPlayerControlsExtensionComponent = MediaPlayerControlsExtensionComponent;
    exports.MediaPlayerTimelineExtensionComponent = MediaPlayerTimelineExtensionComponent;
    exports.NavigationModule = NavigationModule;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationItemComponent = NavigationItemComponent;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NumberPickerModule = NumberPickerModule;
    exports.NUMBER_PICKER_VALUE_ACCESSOR = NUMBER_PICKER_VALUE_ACCESSOR;
    exports.NumberPickerComponent = NumberPickerComponent;
    exports.PageHeaderModule = PageHeaderModule;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageHeaderNavigationComponent = PageHeaderNavigationComponent;
    exports.PageHeaderIconMenuComponent = PageHeaderIconMenuComponent;
    exports.PageHeaderCustomMenuDirective = PageHeaderCustomMenuDirective;
    exports.PopoverModule = PopoverModule;
    exports.PopoverComponent = PopoverComponent;
    exports.PopoverDirective = PopoverDirective;
    exports.ProgressBarModule = ProgressBarModule;
    exports.ProgressBarComponent = ProgressBarComponent;
    exports.RadioButtonModule = RadioButtonModule;
    exports.RADIOBUTTON_VALUE_ACCESSOR = RADIOBUTTON_VALUE_ACCESSOR;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.SearchBuilderGroupComponent = SearchBuilderGroupComponent;
    exports.SearchBuilderGroupService = SearchBuilderGroupService;
    exports.SearchBuilderOutletDirective = SearchBuilderOutletDirective;
    exports.BaseSearchComponent = BaseSearchComponent;
    exports.SearchTextComponent = SearchTextComponent;
    exports.SearchDateComponent = SearchDateComponent;
    exports.SearchDateRangeComponent = SearchDateRangeComponent;
    exports.SearchSelectComponent = SearchSelectComponent;
    exports.SearchBuilderComponent = SearchBuilderComponent;
    exports.SearchBuilderService = SearchBuilderService;
    exports.SearchBuilderModule = SearchBuilderModule;
    exports.SELECT_VALUE_ACCESSOR = SELECT_VALUE_ACCESSOR;
    exports.SelectComponent = SelectComponent;
    exports.SelectModule = SelectModule;
    exports.SidePanelComponent = SidePanelComponent;
    exports.SidePanelCloseDirective = SidePanelCloseDirective;
    exports.SidePanelModule = SidePanelModule;
    exports.SliderModule = SliderModule;
    exports.SliderComponent = SliderComponent;
    exports.SliderType = SliderType;
    exports.SliderStyle = SliderStyle;
    exports.SliderSize = SliderSize;
    exports.SliderCalloutTrigger = SliderCalloutTrigger;
    exports.SliderSnap = SliderSnap;
    exports.SliderTickType = SliderTickType;
    exports.SliderThumbEvent = SliderThumbEvent;
    exports.SliderThumb = SliderThumb;
    exports.SparkModule = SparkModule;
    exports.SparkComponent = SparkComponent;
    exports.SpinButtonModule = SpinButtonModule;
    exports.SPIN_BUTTON_VALUE_ACCESSOR = SPIN_BUTTON_VALUE_ACCESSOR;
    exports.SpinButtonComponent = SpinButtonComponent;
    exports.TabsetModule = TabsetModule;
    exports.TabsetComponent = TabsetComponent;
    exports.TabsetService = TabsetService;
    exports.TabComponent = TabComponent;
    exports.TabHeadingDirective = TabHeadingDirective;
    exports.TabFocusDirective = TabFocusDirective;
    exports.TagInputEvent = TagInputEvent;
    exports.TagInputComponent = TagInputComponent;
    exports.TagInputModule = TagInputModule;
    exports.TimePickerModule = TimePickerModule;
    exports.TIME_PICKER_VALUE_ACCESSOR = TIME_PICKER_VALUE_ACCESSOR;
    exports.TimePickerComponent = TimePickerComponent;
    exports.TimeFormatPipe = TimeFormatPipe;
    exports.TimelineModule = TimelineModule;
    exports.TimelineComponent = TimelineComponent;
    exports.TimelineEventComponent = TimelineEventComponent;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.ToolbarSearchModule = ToolbarSearchModule;
    exports.ToolbarSearchComponent = ToolbarSearchComponent;
    exports.ToolbarSearchFieldDirective = ToolbarSearchFieldDirective;
    exports.ToolbarSearchButtonDirective = ToolbarSearchButtonDirective;
    exports.TooltipModule = TooltipModule;
    exports.TooltipComponent = TooltipComponent;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipService = TooltipService;
    exports.TypeaheadOptionEvent = TypeaheadOptionEvent;
    exports.TypeaheadKeyService = TypeaheadKeyService;
    exports.TypeaheadComponent = TypeaheadComponent;
    exports.TypeaheadModule = TypeaheadModule;
    exports.VirtualScrollModule = VirtualScrollModule;
    exports.VirtualScrollComponent = VirtualScrollComponent;
    exports.VirtualScrollLoadingDirective = VirtualScrollLoadingDirective;
    exports.VirtualScrollLoadButtonDirective = VirtualScrollLoadButtonDirective;
    exports.VirtualScrollCellDirective = VirtualScrollCellDirective;
    exports.WizardModule = WizardModule;
    exports.WizardComponent = WizardComponent;
    exports.StepChangingEvent = StepChangingEvent;
    exports.WizardStepComponent = WizardStepComponent;
    exports.AutoGrowModule = AutoGrowModule;
    exports.AutoGrowDirective = AutoGrowDirective;
    exports.ClickOutsideModule = ClickOutsideModule;
    exports.ClickOutsideDirective = ClickOutsideDirective;
    exports.DragModule = DragModule;
    exports.DragDirective = DragDirective;
    exports.FixedHeaderTableModule = FixedHeaderTableModule;
    exports.FixedHeaderTableDirective = FixedHeaderTableDirective;
    exports.FloatLabelDirective = FloatLabelDirective;
    exports.FloatLabelModule = FloatLabelModule;
    exports.FocusIfDirective = FocusIfDirective;
    exports.FocusIfModule = FocusIfModule;
    exports.HelpCenterModule = HelpCenterModule;
    exports.HelpCenterService = HelpCenterService;
    exports.HelpCenterItemDirective = HelpCenterItemDirective;
    exports.HoverActionModule = HoverActionModule;
    exports.HoverActionContainerDirective = HoverActionContainerDirective;
    exports.HoverActionDirective = HoverActionDirective;
    exports.InfiniteScrollDirective = InfiniteScrollDirective;
    exports.InfiniteScrollLoadingEvent = InfiniteScrollLoadingEvent;
    exports.InfiniteScrollLoadedEvent = InfiniteScrollLoadedEvent;
    exports.InfiniteScrollLoadErrorEvent = InfiniteScrollLoadErrorEvent;
    exports.InfiniteScrollLoadButtonDirective = InfiniteScrollLoadButtonDirective;
    exports.InfiniteScrollLoadingDirective = InfiniteScrollLoadingDirective;
    exports.InfiniteScrollModule = InfiniteScrollModule;
    exports.LayoutSwitcherModule = LayoutSwitcherModule;
    exports.LayoutSwitcherDirective = LayoutSwitcherDirective;
    exports.LayoutSwitcherItemDirective = LayoutSwitcherItemDirective;
    exports.MenuNavigationItemDirective = MenuNavigationItemDirective;
    exports.MenuNavigationDirective = MenuNavigationDirective;
    exports.MenuNavigationModule = MenuNavigationModule;
    exports.ObserversModule = ObserversModule;
    exports.OverflowDirective = OverflowDirective;
    exports.ReorderableModule = ReorderableModule;
    exports.ReorderableDirective = ReorderableDirective;
    exports.ReorderableHandleDirective = ReorderableHandleDirective;
    exports.ReorderableModelDirective = ReorderableModelDirective;
    exports.ReorderableService = ReorderableService;
    exports.ReorderableGroup = ReorderableGroup;
    exports.ResizeService = ResizeService;
    exports.ResizeDirective = ResizeDirective;
    exports.ResizeModule = ResizeModule;
    exports.ScrollIntoViewIfModule = ScrollModule;
    exports.ScrollIntoViewIfDirective = ScrollIntoViewIfDirective;
    exports.ScrollIntoViewDirective = ScrollIntoViewDirective;
    exports.ScrollIntoViewService = ScrollIntoViewService;
    exports.ScrollModule = ScrollModule;
    exports.SelectionItemDirective = SelectionItemDirective;
    exports.SelectionDirective = SelectionDirective;
    exports.SelectionModule = SelectionModule;
    exports.SelectionService = SelectionService;
    exports.SelectionStrategy = SelectionStrategy;
    exports.ContactsNg1Component = ContactsNg1Component;
    exports.ExpandInputNg1Component = ExpandInputNg1Component;
    exports.FloatingActionButtonNg1Component = FloatingActionButtonNg1Component;
    exports.FlotNg1Component = FlotNg1Component;
    exports.GridNg1Component = GridNg1Component;
    exports.HierarchyBarNg1Component = HierarchyBarNg1Component;
    exports.MarqueeWizardNg1Component = MarqueeWizardNg1Component;
    exports.NestedDonutNg1Component = NestedDonutNg1Component;
    exports.OrganizationChartNg1Component = OrganizationChartNg1Component;
    exports.PartitionMapNg1Component = PartitionMapNg1Component;
    exports.PeityBarChartNg1Component = PeityBarChartNg1Component;
    exports.PeityLineChartNg1Component = PeityLineChartNg1Component;
    exports.PeityPieChartNg1Component = PeityPieChartNg1Component;
    exports.PeityUpdatingLineChartNg1Component = PeityUpdatingLineChartNg1Component;
    exports.SankeyNg1Component = SankeyNg1Component;
    exports.SearchToolbarNg1Component = SearchToolbarNg1Component;
    exports.SelectTableNg1Component = SelectTableNg1Component;
    exports.SLIDER_CHART_VALUE_ACCESSOR = SLIDER_CHART_VALUE_ACCESSOR;
    exports.SliderChartNg1Component = SliderChartNg1Component;
    exports.SocialChartNg1Component = SocialChartNg1Component;
    exports.SortDirectionToggleNg1Component = SortDirectionToggleNg1Component;
    exports.TreeGridNg1Component = TreeGridNg1Component;
    exports.ThumbnailNg1Component = ThumbnailNg1Component;
    exports.NavigationMenuService = NavigationMenuService;
    exports.navigationMenuServiceFactory = navigationMenuServiceFactory;
    exports.navigationMenuServiceProvider = navigationMenuServiceProvider;
    exports.PdfService = PdfService;
    exports.pdfServiceFactory = pdfServiceFactory;
    exports.pdfServiceProvider = pdfServiceProvider;
    exports.TimeAgoService = TimeAgoService;
    exports.timeAgoServiceFactory = timeAgoServiceFactory;
    exports.timeAgoServiceProvider = timeAgoServiceProvider;
    exports.HybridModule = HybridModule;
    exports.DurationPipeModule = DurationPipeModule;
    exports.DurationPipe = DurationPipe;
    exports.FileSizePipeModule = FileSizePipeModule;
    exports.FileSizePipe = FileSizePipe;
    exports.StringFilterPipe = StringFilterPipe;
    exports.StringFilterModule = StringFilterModule;
    exports.AudioServiceModule = AudioServiceModule;
    exports.AudioService = AudioService;
    exports.ColorServiceModule = ColorServiceModule;
    exports.ColorService = ColorService;
    exports.ThemeColor = ThemeColor;
    exports.colorSets = colorSets;
    exports.FrameExtractionModule = FrameExtractionModule;
    exports.FrameExtractionService = FrameExtractionService;
    exports.PersistentDataModule = PersistentDataModule;
    exports.PersistentDataService = PersistentDataService;
    exports.PersistentDataStorageType = PersistentDataStorageType;
    exports.StorageAdapter = StorageAdapter;
    exports.CookieAdapter = CookieAdapter;
    exports.LocalStorageAdapter = LocalStorageAdapter;
    exports.SessionStorageAdapter = SessionStorageAdapter;
    exports.d = DayViewComponent;
    exports.e = DayViewService;
    exports.c = HeaderComponent;
    exports.f = MonthViewComponent;
    exports.g = MonthViewService;
    exports.j = TimeViewComponent;
    exports.h = YearViewComponent;
    exports.i = YearViewService;
    exports.k = FloatingActionButtonsService;
    exports.m = MarqueeWizardService;
    exports.n = MediaPlayerService;
    exports.s = PageHeaderNavigationDropdownItemComponent;
    exports.r = PageHeaderNavigationItemComponent;
    exports.t = PageHeaderNavigationSecondaryItemDirective;
    exports.q = PageHeaderService;
    exports.l = SidePanelService;
    exports.v = TypeaheadHighlightDirective;
    exports.u = TypeaheadService;
    exports.w = HoverActionService;
    exports.p = MenuNavigationToggleDirective;
    exports.o = MenuNavigationService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXgtYXNwZWN0cy11eC1hc3BlY3RzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlc2l6ZS9yZXNpemUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlc2l6ZS9yZXNpemUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jYXJkLXRhYnMvY2FyZC10YWIvY2FyZC10YWItY29udGVudC5kaXJlY3RpdmUudHMiLG51bGwsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYnMuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jYXJkLXRhYnMvY2FyZC10YWJzZXQvY2FyZC10YWJzZXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY2FyZC10YWJzL2NhcmQtdGFicy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQtc3ViamVjdC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC11dGlscy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC16b25lLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LXpvbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC5kZWNvcmF0b3IudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9kcmFnL2RyYWcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2RyYWctaGFuZGxlL2RyYWctaGFuZGxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2RyYWcvZHJhZy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RpbWUtcGlja2VyL3RpbWUtZm9ybWF0LnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIudXRpbHMudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIuY29uZmlnLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXktdmlldy9kYXktdmlldy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXktdmlldy9kYXktdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2hlYWRlci9oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9tb250aC12aWV3L21vbnRoLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvbW9udGgtdmlldy9tb250aC12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvdGltZS12aWV3L3RpbWUtdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL3llYXItdmlldy95ZWFyLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIveWVhci12aWV3L3llYXItdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mb2N1cy1pZi9mb2N1cy1pZi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mb2N1cy1pZi9mb2N1cy1pZi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZWJveC9lYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Vib3gvZWJveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtZXZlbnRzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2Jhc2UvZmFjZXQtaGVhZGVyL2ZhY2V0LWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtY2hlY2stbGlzdC9mYWNldC1jaGVjay1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZhY2V0cy9mYWNldC10eXBlYWhlYWQtbGlzdC9mYWNldC10eXBlYWhlYWQtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLWhhbmRsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS1tb2RlbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9kcmFndWxhLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvcmVvcmRlcmFibGUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZhY2V0cy9mYWNldHMubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL21vZGVscy9mYWNldC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1iYXNlL2ZpbHRlci1iYXNlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLWRyb3Bkb3duL2ZpbHRlci1kcm9wZG93bi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1keW5hbWljL2ZpbHRlci1keW5hbWljLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZsaXBwYWJsZS1jYXJkL2ZsaXBwYWJsZS1jYXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZsaXBwYWJsZS1jYXJkL2ZsaXBwYWJsZS1jYXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvY2xpY2stb3V0c2lkZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlL2NsaWNrLW91dHNpZGUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcG9wb3Zlci9wb3BvdmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BvcG92ZXIvcG9wb3Zlci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wb3BvdmVyL3BvcG92ZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2l0ZW0tZGlzcGxheS1wYW5lbC9pdGVtLWRpc3BsYXktcGFuZWwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaXRlbS1kaXNwbGF5LXBhbmVsL2l0ZW0tZGlzcGxheS1wYW5lbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy93aXphcmQvd2l6YXJkLXN0ZXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvd2l6YXJkL3dpemFyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy93aXphcmQvd2l6YXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC1zdGVwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9hdWRpby9hdWRpby5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL2F1ZGlvL2F1ZGlvLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy9iYXNlLWV4dGVuc2lvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy90aW1lbGluZS90aW1lbGluZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy9jb250cm9scy9jb250cm9scy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZHVyYXRpb24vZHVyYXRpb24ucGlwZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9kdXJhdGlvbi9kdXJhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZmlsZS1zaXplL2ZpbGUtc2l6ZS5waXBlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL2ZpbGUtc2l6ZS9maWxlLXNpemUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWl0ZW0vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25hdmlnYXRpb24vbmF2aWdhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvY29sb3IvY29sb3Iuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9jb2xvci9jb2xvci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9udW1iZXItcGlja2VyL251bWJlci1waWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbnVtYmVyLXBpY2tlci9udW1iZXItcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24tdG9nZ2xlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL2ljb24tbWVudS9pY29uLW1lbnUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL25hdmlnYXRpb24vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9uYXZpZ2F0aW9uL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0vbmF2aWdhdGlvbi1zZWNvbmRhcnktaXRlbS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcHJvZ3Jlc3MtYmFyL3Byb2dyZXNzLWJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3JhZGlvYnV0dG9uL3JhZGlvYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3JhZGlvYnV0dG9uL3JhZGlvYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItZ3JvdXAvc2VhcmNoLWJ1aWxkZXItZ3JvdXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItb3V0bGV0L3NlYXJjaC1idWlsZGVyLW91dGxldC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9iYXNlLXNlYXJjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy90ZXh0L3RleHQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWNvbXBvbmVudHMvZGF0ZS9kYXRlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL2RhdGUtcmFuZ2UvZGF0ZS1yYW5nZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLWtleS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2Nyb2xsL3Njcm9sbC1pbnRvLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LWlmLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC1oaWdobGlnaHQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhZy1pbnB1dC90YWctaW5wdXQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWctaW5wdXQvdGFnLWlucHV0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhZy1pbnB1dC90YWctaW5wdXQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zaWRlLXBhbmVsL3NpZGUtcGFuZWwtY2xvc2UuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zcGFyay9zcGFyay5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zcGFyay9zcGFyay5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJzZXQvdGFic2V0LnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJzZXQvdGFic2V0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWIvdGFiLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWIvdGFiLWhlYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWItZm9jdXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYnNldC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lbGluZS90aW1lbGluZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lbGluZS90aW1lbGluZS1ldmVudC90aW1lbGluZS1ldmVudC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lbGluZS90aW1lbGluZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b2dnbGVzd2l0Y2gvdG9nZ2xlc3dpdGNoLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RvZ2dsZXN3aXRjaC90b2dnbGVzd2l0Y2gubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbGJhci1zZWFyY2gvdG9vbGJhci1zZWFyY2gtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLWZpZWxkLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3ZpcnR1YWwtc2Nyb2xsL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3ZpcnR1YWwtc2Nyb2xsL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtY2VsbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC92aXJ0dWFsLXNjcm9sbC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC92aXJ0dWFsLXNjcm9sbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9hdXRvLWdyb3cvYXV0by1ncm93LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2F1dG8tZ3Jvdy9hdXRvLWdyb3cubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvZml4ZWQtaGVhZGVyLXRhYmxlL2ZpeGVkLWhlYWRlci10YWJsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9maXhlZC1oZWFkZXItdGFibGUvZml4ZWQtaGVhZGVyLXRhYmxlLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2Zsb2F0LWxhYmVsL2Zsb2F0LWxhYmVsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2Zsb2F0LWxhYmVsL2Zsb2F0LWxhYmVsLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hlbHAtY2VudGVyL2hlbHAtY2VudGVyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hlbHAtY2VudGVyL2hlbHAtY2VudGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24tY29udGFpbmVyLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvaG92ZXItYWN0aW9uL2hvdmVyLWFjdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9sYXlvdXQtc3dpdGNoZXIvbGF5b3V0LXN3aXRjaGVyLWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9sYXlvdXQtc3dpdGNoZXIvbGF5b3V0LXN3aXRjaGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL29ic2VydmVycy9vdmVyZmxvdy9vdmVyZmxvdy1vYnNlcnZlci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9vYnNlcnZlcnMvb2JzZXJ2ZXJzLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NlbGVjdGlvbi5zdHJhdGVneS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3Jvdy1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9yb3ctYWx0LXNlbGVjdGlvbi5zdHJhdGVneS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NpbXBsZS1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9jb250YWN0cy9jb250YWN0cy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvZXhwYW5kLWlucHV0L2V4cGFuZC1pbnB1dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9mbG90L2Zsb3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvbmVzdGVkLWRvbnV0L25lc3RlZC1kb251dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvb3JnYW5pemF0aW9uLWNoYXJ0L29yZ2FuaXphdGlvbi1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGFydGl0aW9uLW1hcC9wYXJ0aXRpb24tbWFwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1iYXItY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LWxpbmUtY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LXBpZS1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktdXBkYXRpbmctbGluZS1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2Fua2V5LWNoYXJ0L3NhbmtleS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2VhcmNoLXRvb2xiYXIvc2VhcmNoLXRvb2xiYXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NlbGVjdC10YWJsZS9zZWxlY3QtdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NsaWRlci1jaGFydC9zbGlkZXItY2hhcnQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NvY2lhbC1jaGFydC9zb2NpYWwtY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS9zb3J0LWRpcmVjdGlvbi10b2dnbGUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3RyZWUtZ3JpZC90cmVlLWdyaWQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3RodW1ibmFpbC90aHVtYm5haWwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9zZXJ2aWNlcy9uYXZpZ2F0aW9uLW1lbnUvbmF2aWdhdGlvbi1tZW51LnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL3NlcnZpY2VzL3BkZi9wZGYuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvc2VydmljZXMvdGltZS1hZ28vdGltZS1hZ28uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvaHlicmlkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9zdHJpbmctZmlsdGVyL3N0cmluZy1maWx0ZXIucGlwZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9zdHJpbmctZmlsdGVyL3N0cmluZy1maWx0ZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9hZGFwdGVycy9jb29raWUtYWRhcHRlci50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvYWRhcHRlcnMvbG9jYWwtc3RvcmFnZS1hZGFwdGVyLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9hZGFwdGVycy9zZXNzaW9uLXN0b3JhZ2UtYWRhcHRlci50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvcGVyc2lzdGVudC1kYXRhLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL3BlcnNpc3RlbnQtZGF0YS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL2FkYXB0ZXJzL3N0b3JhZ2UtYWRhcHRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtYnJlYWRjcnVtYnMnLFxuICAgIHRlbXBsYXRlOiBgPG5hdiBhcmlhLWxhYmVsPVwiQnJlYWRjcnVtYlwiPlxuICAgIDxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIj5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjcnVtYiBvZiBjcnVtYnNcIj5cblxuICAgICAgICAgICAgPCEtLSBJZiB0aGVyZSBpcyBhIHJvdXRlciBsaW5rIHRoZW4gdXNlIGEgdGFnIC0tPlxuICAgICAgICAgICAgPGEgKm5nSWY9XCJjcnVtYi5yb3V0ZXJMaW5rIHx8IGNydW1iLm9uQ2xpY2tcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgW3JvdXRlckxpbmtdPVwiY3J1bWIucm91dGVyTGlua1wiXG4gICAgICAgICAgICAgICAgW2ZyYWdtZW50XT1cImNydW1iLmZyYWdtZW50XCJcbiAgICAgICAgICAgICAgICBbcXVlcnlQYXJhbXNdPVwiY3J1bWIucXVlcnlQYXJhbXNcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJjbGlja0NydW1iKCRldmVudCwgY3J1bWIpXCI+XG4gICAgICAgICAgICAgICAge3sgY3J1bWIudGl0bGUgfX1cbiAgICAgICAgICAgIDwvYT5cblxuICAgICAgICAgICAgPCEtLSBJZiB0aGVyZSBpcyBub3Qgcm91dGVyIGxpbmsgdGhlbiBkaXNwbGF5IHRleHQgaW4gYSBzcGFuIC0tPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCIhY3J1bWIucm91dGVyTGluayAmJiAhY3J1bWIub25DbGlja1wiPnt7IGNydW1iLnRpdGxlIH19PC9zcGFuPlxuICAgICAgICA8L2xpPlxuICAgIDwvb2w+XG48L25hdj5gXG59KVxuXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYnNDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgY3J1bWJzOiBCcmVhZGNydW1iW107XG5cbiAgICBjbGlja0NydW1iKGV2ZW50OiBNb3VzZUV2ZW50LCBjcnVtYjogQnJlYWRjcnVtYikge1xuICAgICAgICBpZiAoY3J1bWIub25DbGljaykge1xuICAgICAgICAgICAgY3J1bWIub25DbGljay5jYWxsKG51bGwsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCcmVhZGNydW1iIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHJvdXRlckxpbms/OiBzdHJpbmc7XG4gICAgZnJhZ21lbnQ/OiBzdHJpbmc7XG4gICAgcXVlcnlQYXJhbXM/OiBhbnk7XG4gICAgb25DbGljaz86IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZDtcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCcmVhZGNydW1ic0NvbXBvbmVudCB9IGZyb20gJy4vYnJlYWRjcnVtYnMuY29tcG9uZW50JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLCBcbiAgICAgICAgUm91dGVyTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbQnJlYWRjcnVtYnNDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0JyZWFkY3J1bWJzQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBCcmVhZGNydW1ic01vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSwgT25EZXN0cm95LCBSZW5kZXJlcjIsIFJlbmRlcmVyRmFjdG9yeTIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZXNpemVTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjI7XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXJGYWN0b3J5OiBSZW5kZXJlckZhY3RvcnkyLCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgYWRkUmVzaXplTGlzdGVuZXIobmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQpOiBCZWhhdmlvclN1YmplY3Q8UmVzaXplRGltZW5zaW9ucz4ge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGJlaGF2aW9yIHN1YmplY3Qgc3ViamVjdFxuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxSZXNpemVEaW1lbnNpb25zPih7IHdpZHRoOiBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoLCBoZWlnaHQ6IG5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IH0pO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgc3R5bGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgY29uc3QgZGlzcGxheU1vZGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5Jyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBpZnJhbWUgZWxlbWVudFxuICAgICAgICBjb25zdCBpZnJhbWU6IEhUTUxJRnJhbWVFbGVtZW50ID0gdGhpcy5fcmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cbiAgICAgICAgLy8gc3R5bGUgdGhlIGlmcmFtZSB0byBiZSBpbnZpc2libGUgYnV0IGZpbGwgY29udGFpbmluZyBlbGVtZW50XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAndG9wJywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAncmlnaHQnLCAnMCcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdib3R0b20nLCAnMCcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdsZWZ0JywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnei1pbmRleCcsICctMScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnYm9yZGVyJywgJ25vbmUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnbWFyZ2luJywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdvdmVyZmxvdycsICdoaWRkZW4nKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGlmcmFtZSBpZ25vcmVzIGFueSB0YWJiaW5nXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShpZnJhbWUsICd0YWJpbmRleCcsICctMScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoaWZyYW1lLCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cyBuZWVkIGNoYW5nZWQgdG8gcmVsYXRpdmUgZm9yIHRoaXMgbWV0aG9kIHRvIHdvcmtcbiAgICAgICAgaWYgKGRpc3BsYXlNb2RlICE9PSAncmVsYXRpdmUnICYmIGRpc3BsYXlNb2RlICE9PSAnYWJzb2x1dGUnICYmIGRpc3BsYXlNb2RlICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShuYXRpdmVFbGVtZW50LCAncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgaWZyYW1lIHRvIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgICAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZChuYXRpdmVFbGVtZW50LCBpZnJhbWUpO1xuXG4gICAgICAgIHRoaXMud2FpdFVudGlsUmVhZHkoaWZyYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZnJhbWVEb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50IHx8IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50IGFzIERvY3VtZW50O1xuXG4gICAgICAgICAgICBjb25zdCBhdHRhY2hMaXN0ZW5lciA9ICgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIHdhdGNoIGZvciBhbnkgZnV0dXJlIHJlc2l6ZXMgLSBydW4gaW5zaWRlIG5nem9uZSBhcyBhbiBpZnJhbWUgZXZlbnQgbGlzdGVuZXIgaXMgbm90IHBhdGNoZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKGZyb21FdmVudChpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScpLnN1YnNjcmliZSgoZXZlbnQ6IFJlc2l6ZURpbWVuc2lvbnMpID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gc3ViamVjdC5uZXh0KHsgd2lkdGg6IG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgsIGhlaWdodDogbmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgfSkpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaWZyYW1lRG9jLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGlmcmFtZSB0byBsb2FkXG4gICAgICAgICAgICAgICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiBhdHRhY2hMaXN0ZW5lcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHdhaXRVbnRpbFJlYWR5KGlmcmFtZTogSFRNTElGcmFtZUVsZW1lbnQsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGlmIChpZnJhbWUuY29udGVudERvY3VtZW50IHx8IGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLndhaXRVbnRpbFJlYWR5KGlmcmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNpemVEaW1lbnNpb25zIHtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBSZXNpemVEaW1lbnNpb25zLCBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4UmVzaXplXScsXG4gICAgcHJvdmlkZXJzOiBbUmVzaXplU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgUmVzaXplRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgdGhyb3R0bGU6IG51bWJlciA9IDA7XG4gICAgQE91dHB1dCgpIHV4UmVzaXplOiBFdmVudEVtaXR0ZXI8UmVzaXplRGltZW5zaW9ucz4gPSBuZXcgRXZlbnRFbWl0dGVyPFJlc2l6ZURpbWVuc2lvbnM+KCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3Jlc2l6ZVNlcnZpY2U6IFJlc2l6ZVNlcnZpY2UsIHByaXZhdGUgX25nWm9uZTogTmdab25lKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9yZXNpemVTZXJ2aWNlLmFkZFJlc2l6ZUxpc3RlbmVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudClcbiAgICAgICAgICAgIC5waXBlKGRlYm91bmNlVGltZSh0aGlzLnRocm90dGxlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50OiBSZXNpemVEaW1lbnNpb25zKSA9PiB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMudXhSZXNpemUuZW1pdChldmVudCkpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFJlc2l6ZURpcmVjdGl2ZSB9IGZyb20gJy4vcmVzaXplLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemUuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW1Jlc2l6ZURpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbUmVzaXplRGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtSZXNpemVTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBSZXNpemVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3V4Q2FyZFRhYkNvbnRlbnRdJ1xufSlcbmV4cG9ydCBjbGFzcyBDYXJkVGFiQ29udGVudERpcmVjdGl2ZSB7IH1cbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFiL2NhcmQtdGFiLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDYXJkVGFic1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHRhYiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PENhcmRUYWJDb21wb25lbnQ+KG51bGwpO1xuICB0YWJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Q2FyZFRhYkNvbXBvbmVudFtdPihbXSk7XG4gIHBvc2l0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPigndG9wJyk7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAvLyB3aGVuIGEgdGFiIGlzIGFkZGVkIG9yIHJlbW92ZWQgZW5zdXJlIHdlIGFsd2F5cyBzZWxlY3Qgb25lIGlmIGFueSBhcmUgYXZhaWxhYmxlXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy50YWJzJC5waXBlKFxuICAgICAgZmlsdGVyKHRhYnMgPT4gIXRoaXMudGFiJC52YWx1ZSB8fCAhdGFicy5maW5kKHRhYiA9PiB0YWIgPT09IHRoaXMudGFiJC52YWx1ZSkpLFxuICAgICkuc3Vic2NyaWJlKHRhYnMgPT4gdGhpcy50YWIkLm5leHQodGFicy5sZW5ndGggPiAwID8gdGFic1swXSA6IG51bGwpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRhYiB0byB0aGUgbGlzdCBvZiB0YWJzXG4gICAqL1xuICBhZGRUYWIodGFiOiBDYXJkVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy50YWJzJC5uZXh0KFsuLi50aGlzLnRhYnMkLnZhbHVlLCB0YWJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWIgZnJvbSB0aGUgbGlzdFxuICAgKi9cbiAgcmVtb3ZlVGFiKHRhYjogQ2FyZFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgIHRoaXMudGFicyQubmV4dCh0aGlzLnRhYnMkLnZhbHVlLmZpbHRlcihfdGFiID0+IF90YWIgIT09IHRhYikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgdGFiXG4gICAqL1xuICBzZWxlY3QodGFiOiBDYXJkVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy50YWIkLm5leHQodGFiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YWIgY29udGVudFxuICAgKi9cbiAgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24kLm5leHQocG9zaXRpb24pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FyZFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi4vY2FyZC10YWJzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmUgfSBmcm9tICcuL2NhcmQtdGFiLWNvbnRlbnQuZGlyZWN0aXZlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtY2FyZC10YWInLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50ICpuZ0lmPVwiYWN0aXZlJCB8IGFzeW5jXCI+PC9uZy1jb250ZW50PmAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIENhcmRUYWJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIGFjdGl2ZSQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLl90YWJTZXJ2aWNlLnRhYiQucGlwZShtYXAodGFiID0+IHRhYiA9PT0gdGhpcykpO1xuICBAQ29udGVudENoaWxkKENhcmRUYWJDb250ZW50RGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGNvbnRlbnQ6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfdGFiU2VydmljZTogQ2FyZFRhYnNTZXJ2aWNlKSB7XG4gICAgdGhpcy5fdGFiU2VydmljZS5hZGRUYWIodGhpcyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl90YWJTZXJ2aWNlLnJlbW92ZVRhYih0aGlzKTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbnB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVEaW1lbnNpb25zIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUnO1xuaW1wb3J0IHsgQ2FyZFRhYkNvbXBvbmVudCB9IGZyb20gJy4uL2NhcmQtdGFiL2NhcmQtdGFiLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDYXJkVGFic1NlcnZpY2UgfSBmcm9tICcuLi9jYXJkLXRhYnMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LWNhcmQtdGFic2V0JyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiY2FyZC10YWItY29udGVudFwiIHJvbGU9XCJ0YWJwYW5lbFwiICpuZ0lmPVwiKHRhYlNlcnZpY2UudGFiJCB8IGFzeW5jKVwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiY2FyZC10YWJzXCIgI3RhYnM+XG5cbiAgICA8YnV0dG9uIGNsYXNzPVwiY2FyZC10YWJzLXBhZ2luZy1idG4gY2FyZC10YWJzLXBhZ2luZy1idG4tcHJldmlvdXNcIiBhcmlhLWxhYmVsPVwiUHJldmlvdXMgVGFic1wiIChjbGljayk9XCJwcmV2aW91cygpXCIgKm5nSWY9XCJvZmZzZXQgPCBib3VuZHMubG93ZXJcIj5cbiAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtcHJldmlvdXNcIj48L2k+XG4gICAgPC9idXR0b24+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC10YWJzLWxpc3RcIiByb2xlPVwidGFibGlzdFwiICN0YWJsaXN0ICh1eFJlc2l6ZSk9XCJyZXNpemUoJGV2ZW50KVwiIFtzdHlsZS50cmFuc2Zvcm1dPVwiJ3RyYW5zbGF0ZVgoJyArIG9mZnNldCArICdweCknXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtdGFiXCJcbiAgICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCIgI2NhcmRcbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCB0YWIgb2YgdGFiU2VydmljZS50YWJzJCB8IGFzeW5jXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInRhYlNlcnZpY2UucG9zaXRpb24kIHwgYXN5bmNcIlxuICAgICAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJ0YWIuYWN0aXZlJCB8IGFzeW5jXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwidGFiLmFjdGl2ZSQgfCBhc3luY1wiXG4gICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0KHRhYiwgY2FyZClcIlxuICAgICAgICAgICAgKGZvY3VzKT1cInRhYnMuc2Nyb2xsTGVmdCA9IDBcIlxuICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwic2VsZWN0KHRhYiwgY2FyZClcIj5cblxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWIuY29udGVudFwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPGJ1dHRvbiBjbGFzcz1cImNhcmQtdGFicy1wYWdpbmctYnRuIGNhcmQtdGFicy1wYWdpbmctYnRuLW5leHRcIiBhcmlhLWxhYmVsPVwiTmV4dCBUYWJzXCIgKGNsaWNrKT1cIm5leHQoKVwiICpuZ0lmPVwib2Zmc2V0ID4gYm91bmRzLnVwcGVyXCI+XG4gICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb24gaHBlLW5leHRcIj48L2k+XG4gICAgPC9idXR0b24+XG48L2Rpdj5gLFxuICBwcm92aWRlcnM6IFtDYXJkVGFic1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIENhcmRUYWJzZXRDb21wb25lbnQge1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICBASW5wdXQoKSBzZXQgcG9zaXRpb24oZGlyZWN0aW9uOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRhYlNlcnZpY2Uuc2V0UG9zaXRpb24oZGlyZWN0aW9uKTtcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnRhYlNlcnZpY2UucG9zaXRpb24kLmdldFZhbHVlKCk7XG4gIH1cblxuICBAVmlld0NoaWxkKCd0YWJsaXN0JykgdGFibGlzdDogRWxlbWVudFJlZjtcblxuICBvZmZzZXQ6IG51bWJlciA9IDA7XG4gIGJvdW5kczogQ2FyZFRhYnNCb3VuZHMgPSB7IGxvd2VyOiAwLCB1cHBlcjogMCB9O1xuXG4gIHByaXZhdGUgX3dpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgX2lubmVyV2lkdGg6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFiU2VydmljZTogQ2FyZFRhYnNTZXJ2aWNlKSB7fVxuXG4gIHNlbGVjdCh0YWI6IENhcmRUYWJDb21wb25lbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgLy8gc2VsZWN0IHRoZSB0YWJcbiAgICB0aGlzLnRhYlNlcnZpY2Uuc2VsZWN0KHRhYik7XG5cbiAgICAvLyBlbnN1cmUgdGhlIHRhYiBpcyBtb3ZlZCBpbnRvIHZpZXcgaWYgcmVxdWlyZWRcbiAgICB0aGlzLm1vdmVJbnRvVmlldyhlbGVtZW50KTtcbiAgfVxuXG4gIHJlc2l6ZShkaW1lbnNpb25zOiBSZXNpemVEaW1lbnNpb25zKTogdm9pZCB7XG4gICAgdGhpcy5fd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgIHRoaXMuX2lubmVyV2lkdGggPSB0aGlzLnRhYmxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aDtcblxuICAgIHRoaXMuYm91bmRzLmxvd2VyID0gMDtcbiAgICB0aGlzLmJvdW5kcy51cHBlciA9IC0odGhpcy5faW5uZXJXaWR0aCAtIHRoaXMuX3dpZHRoKTtcbiAgfVxuXG4gIHByZXZpb3VzKCk6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0ICs9IHRoaXMuX3dpZHRoO1xuXG4gICAgLy8gZW5zdXJlIGl0IHJlbWFpbnMgd2l0aGluIHRoZSBhbGxvd2VkIGJvdW5kc1xuICAgIHRoaXMub2Zmc2V0ID0gTWF0aC5taW4odGhpcy5vZmZzZXQsIHRoaXMuYm91bmRzLmxvd2VyKTtcbiAgfVxuXG4gIG5leHQoKTogdm9pZCB7XG4gICAgdGhpcy5vZmZzZXQgLT0gdGhpcy5fd2lkdGg7XG5cbiAgICAvLyBlbnN1cmUgaXQgcmVtYWlucyB3aXRoaW4gdGhlIGFsbG93ZWQgYm91bmRzXG4gICAgdGhpcy5vZmZzZXQgPSBNYXRoLm1heCh0aGlzLm9mZnNldCwgdGhpcy5ib3VuZHMudXBwZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBtb3ZlSW50b1ZpZXcoZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcblxuICAgIC8vIGlmIHdlIGRvbnQgaGF2ZSB0aGUgZGltZW5zaW9ucyB3ZSBjYW50IGNoZWNrXG4gICAgaWYgKCF0aGlzLl93aWR0aCB8fCAhdGhpcy5faW5uZXJXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgY3VycmVudCBlbGVtZW50IGJvdW5kc1xuICAgIGNvbnN0IHsgb2Zmc2V0TGVmdCwgb2Zmc2V0V2lkdGggfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgeyBtYXJnaW5MZWZ0LCBtYXJnaW5SaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdmlzaWJsZSBhcmVhXG4gICAgY29uc3Qgdmlld3BvcnRTdGFydCA9IE1hdGguYWJzKHRoaXMub2Zmc2V0KTtcbiAgICBjb25zdCB2aWV3cG9ydEVuZCA9IHZpZXdwb3J0U3RhcnQgKyB0aGlzLl93aWR0aDtcbiAgICBjb25zdCBjYXJkV2lkdGggPSBwYXJzZUZsb2F0KG1hcmdpbkxlZnQpICsgb2Zmc2V0V2lkdGggKyBwYXJzZUZsb2F0KG1hcmdpblJpZ2h0KTtcblxuICAgIC8vIGlmIHdlIG5lZWQgdG8gbW92ZSB0byB0aGUgbGVmdCAtIGZpZ3VyZSBvdXQgaG93IG11Y2hcbiAgICBpZiAob2Zmc2V0TGVmdCA8IHZpZXdwb3J0U3RhcnQpIHtcbiAgICAgIHRoaXMub2Zmc2V0IC09IChvZmZzZXRMZWZ0IC0gcGFyc2VGbG9hdChtYXJnaW5MZWZ0KSkgLSB2aWV3cG9ydFN0YXJ0O1xuICAgIH1cbiAgICBcbiAgICAvLyBpZiB3ZSBuZWVkIHRvIG1vdmUgdG8gdGhlIHJpZ2h0IC0gZmlndXJlIG91dCBob3cgbXVjaFxuICAgIGlmICgob2Zmc2V0TGVmdCArIGNhcmRXaWR0aCkgPiB2aWV3cG9ydEVuZCkge1xuICAgICAgdGhpcy5vZmZzZXQgLT0gKG9mZnNldExlZnQgKyBjYXJkV2lkdGgpIC0gdmlld3BvcnRFbmQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FyZFRhYnNCb3VuZHMge1xuICBsb3dlcjogbnVtYmVyO1xuICB1cHBlcjogbnVtYmVyO1xufVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBDYXJkVGFiQ29udGVudERpcmVjdGl2ZSB9IGZyb20gJy4vY2FyZC10YWIvY2FyZC10YWItY29udGVudC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2FyZFRhYkNvbXBvbmVudCB9IGZyb20gJy4vY2FyZC10YWIvY2FyZC10YWIuY29tcG9uZW50JztcbmltcG9ydCB7IENhcmRUYWJzZXRDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFic2V0L2NhcmQtdGFic2V0LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgUmVzaXplTW9kdWxlXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW0NhcmRUYWJzZXRDb21wb25lbnQsIENhcmRUYWJDb21wb25lbnQsIENhcmRUYWJDb250ZW50RGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW0NhcmRUYWJzZXRDb21wb25lbnQsIENhcmRUYWJDb21wb25lbnQsIENhcmRUYWJDb250ZW50RGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkVGFic01vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxubGV0IHVuaXF1ZUNoZWNrYm94SWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWNoZWNrYm94JyxcbiAgICB0ZW1wbGF0ZTogYDxsYWJlbCBbYXR0ci5mb3JdPVwiaW5wdXRJZFwiXG4gICAgICAgY2xhc3M9XCJ1eC1jaGVja2JveFwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LWNoZWNrZWRdPVwidmFsdWUgPT09IHRydWVcIlxuICAgICAgIFtjbGFzcy51eC1jaGVja2JveC1pbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIlxuICAgICAgIFtjbGFzcy51eC1jaGVja2JveC1zaW1wbGlmaWVkXT1cInNpbXBsaWZpZWRcIlxuICAgICAgIFtjbGFzcy51eC1jaGVja2JveC1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LWZvY3VzZWRdPVwiZm9jdXNlZFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LWNoZWNrYm94LWNvbnRhaW5lclwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgIGNsYXNzPVwidXgtY2hlY2tib3gtaW5wdXRcIlxuICAgICAgICAgICAgICAgW2lkXT1cImlucHV0SWRcIlxuICAgICAgICAgICAgICAgW3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgIFtjaGVja2VkXT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgIFthdHRyLnZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYmluZGV4XCJcbiAgICAgICAgICAgICAgIFtpbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJhcmlhTGFiZWxcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcbiAgICAgICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJhcmlhQ2hlY2tlZFwiXG4gICAgICAgICAgICAgICAoZm9jdXMpPVwiZm9jdXNlZCA9IHRydWVcIlxuICAgICAgICAgICAgICAgKGJsdXIpPVwiZm9jdXNlZCA9IGZhbHNlXCJcbiAgICAgICAgICAgICAgIChjaGFuZ2UpPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGUoKVwiPlxuICAgIDwvZGl2PlxuXG4gICAgPHNwYW4gY2xhc3M9XCJ1eC1jaGVja2JveC1sYWJlbFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9zcGFuPlxuPC9sYWJlbD5cbmAsXG4gICAgcHJvdmlkZXJzOiBbQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIENoZWNrYm94Q29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfY2hlY2tib3hJZDogc3RyaW5nID0gYHV4LWNoZWNrYm94LSR7Kyt1bmlxdWVDaGVja2JveElkfWA7XG5cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nID0gdGhpcy5fY2hlY2tib3hJZDtcbiAgICBASW5wdXQoKSBuYW1lOiBzdHJpbmcgfCBudWxsO1xuICAgIEBJbnB1dCgpIHJlcXVpcmVkOiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIGNsaWNrYWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2ltcGxpZmllZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGluZGV0ZXJtaW5hdGVWYWx1ZTogYW55ID0gLTE7XG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWwnKSBhcmlhTGFiZWw6IHN0cmluZyA9ICcnO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JykgYXJpYUxhYmVsbGVkYnk6IHN0cmluZyA9IG51bGw7XG5cbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGl0IGlzIGluIHRoZSBpbmRldGVybWluYXRlIHN0YXRlXG4gICAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZSA9IHRoaXMuX3ZhbHVlID09PSB0aGlzLmluZGV0ZXJtaW5hdGVWYWx1ZTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGNoZWNrZWQgc3RhdGVcbiAgICAgICAgdGhpcy5hcmlhQ2hlY2tlZCA9IHRoaXMuaW5kZXRlcm1pbmF0ZSA/ICdtaXhlZCcgOiB0aGlzLl92YWx1ZTtcblxuICAgICAgICAvLyBpbnZva2UgY2hhbmdlIGV2ZW50XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLl92YWx1ZSk7XG5cbiAgICAgICAgLy8gY2FsbCBjYWxsYmFja1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZ2V0IGlucHV0SWQoKTogc3RyaW5nIHsgXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkIHx8IHRoaXMuX2NoZWNrYm94SWR9LWlucHV0YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWx1ZTogYW55ID0gZmFsc2U7XG5cbiAgICBpbmRldGVybWluYXRlOiBib29sZWFuID0gZmFsc2U7XG4gICAgYXJpYUNoZWNrZWQ6IGJvb2xlYW4gfCBzdHJpbmc7XG4gICAgZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHRvZ2dsZSgpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB0aGlzLmluZGV0ZXJtaW5hdGVWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2dnbGUgdGhlIGNoZWNrZWQgc3RhdGVcbiAgICAgICAgdGhpcy52YWx1ZSA9ICF0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9ucyByZXF1aXJlZCB0byB1cGRhdGUgbmdNb2RlbFxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENoZWNrYm94Q29tcG9uZW50IH0gZnJvbSAnLi9jaGVja2JveC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtGb3Jtc01vZHVsZV0sXG4gICAgZXhwb3J0czogW0NoZWNrYm94Q29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtDaGVja2JveENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlLCBDb2x1bW5Tb3J0aW5nT3JkZXIgfSBmcm9tICcuL2NvbHVtbi1zb3J0aW5nLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWNvbHVtbi1zb3J0aW5nJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1jb2x1bW4tc29ydGluZ1wiPlxuICAgIDxpIGNsYXNzPVwidXgtY29sdW1uLXNvcnRpbmctaWNvbiBocGUtaWNvblwiIFxuICAgICAgICBbY2xhc3MuaHBlLWFzY2VuZF09XCJzdGF0ZSA9PT0gY29sdW1uU29ydGluZ1N0YXRlLkFzY2VuZGluZ1wiIFxuICAgICAgICBbY2xhc3MuaHBlLWRlc2NlbmRdPVwic3RhdGUgPT09IGNvbHVtblNvcnRpbmdTdGF0ZS5EZXNjZW5kaW5nXCIgXG4gICAgICAgIFtjbGFzcy5jb2x1bW4tc29ydGluZy1pY29uLWhpZGRlbl09XCJzdGF0ZSA9PT0gY29sdW1uU29ydGluZ1N0YXRlLk5vU29ydFwiPjwvaT5cbiAgICA8cCBjbGFzcz1cInV4LWNvbHVtbi1zb3J0aW5nLW51bWJlclwiPnt7IG9yZGVyTnVtYmVyIH19PC9wPlxuPC9kaXY+YCxcbiAgICBleHBvcnRBczogJ3V4LWNvbHVtbi1zb3J0aW5nJ1xufSlcbmV4cG9ydCBjbGFzcyBDb2x1bW5Tb3J0aW5nQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIHN0YXRlOiBDb2x1bW5Tb3J0aW5nU3RhdGU7XG4gICAgQElucHV0KCkga2V5OiBzdHJpbmc7XG4gICAgQElucHV0KCkgb3JkZXJOdW1iZXI6IG51bWJlcjtcbiAgICBAT3V0cHV0KCkgc3RhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxDb2x1bW5Tb3J0aW5nU3RhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxDb2x1bW5Tb3J0aW5nU3RhdGU+KCk7XG5cbiAgICBwcml2YXRlIF9wYXJlbnQ6IENvbHVtblNvcnRpbmdEaXJlY3RpdmU7XG4gICAgY29sdW1uU29ydGluZ1N0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlO1xuXG4gICAgaW5pdFBhcmVudChwYXJlbnQ6IENvbHVtblNvcnRpbmdEaXJlY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBhbnkgZXZlbnRzXG4gICAgICAgIHRoaXMuX3BhcmVudC5ldmVudHMuc3Vic2NyaWJlKGV2ZW50ID0+IHtcblxuICAgICAgICAgICAgbGV0IGlkeCA9IGV2ZW50LmZpbmRJbmRleChjb2x1bW4gPT4gY29sdW1uLmtleSA9PT0gdGhpcy5rZXkpO1xuXG4gICAgICAgICAgICBpZiAoaWR4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZS5Ob1NvcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9ubHkgc3RvcmUgdGhlIG51bWJlciBpZiB3ZSBoYXZlIDIgb3IgbW9yZSBjb2x1bW5zIGJlaW5nIHNvcnRlZFxuICAgICAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyTnVtYmVyID0gaWR4ID09PSAtMSA/IG51bGwgOiBpZHggKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZS5lbWl0KHRoaXMuc3RhdGUpO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNoYW5nZVN0YXRlKCk6IENvbHVtblNvcnRpbmdPcmRlcltdIHtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29sdW1uU29ydGluZ1N0YXRlLkFzY2VuZGluZykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZS5EZXNjZW5kaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENvbHVtblNvcnRpbmdTdGF0ZS5EZXNjZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlLk5vU29ydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGUuQXNjZW5kaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5mb3JtIHBhcmVudFxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LnRvZ2dsZUNvbHVtbih0aGlzLmtleSwgdGhpcy5zdGF0ZSk7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIENvbHVtblNvcnRpbmdTdGF0ZSB7XG4gICAgQXNjZW5kaW5nLFxuICAgIERlc2NlbmRpbmcsXG4gICAgTm9Tb3J0XG59IiwiaW1wb3J0IHsgQ29sdW1uU29ydGluZ0NvbXBvbmVudCwgQ29sdW1uU29ydGluZ1N0YXRlIH0gZnJvbSAnLi9jb2x1bW4tc29ydGluZy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0LCBRdWVyeUxpc3QsIENvbnRlbnRDaGlsZHJlbiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eENvbHVtblNvcnRpbmddJ1xufSlcbmV4cG9ydCBjbGFzcyBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgpIHNpbmdsZVNvcnQ6IGJvb2xlYW47XG4gICAgQENvbnRlbnRDaGlsZHJlbihDb2x1bW5Tb3J0aW5nQ29tcG9uZW50KSBjb21wb25lbnRzOiBRdWVyeUxpc3Q8Q29sdW1uU29ydGluZ0NvbXBvbmVudD47XG5cbiAgICBldmVudHM6IFN1YmplY3Q8Q29sdW1uU29ydGluZ09yZGVyW10+ID0gbmV3IFN1YmplY3Q8Q29sdW1uU29ydGluZ09yZGVyW10+KCk7XG4gICAgb3JkZXI6IENvbHVtblNvcnRpbmdPcmRlcltdID0gW107XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuaW5pdFBhcmVudCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlQ29sdW1uKGtleTogc3RyaW5nLCBzdGF0ZTogQ29sdW1uU29ydGluZ1N0YXRlKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlU29ydCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBDb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmRlciA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyID0gW3trZXk6IGtleSwgc3RhdGU6IHN0YXRlfV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZW9yZGVyIGNvbHVtbnMgaGVyZVxuICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMub3JkZXIuZmluZEluZGV4KGNvbHVtbiA9PiBjb2x1bW4ua2V5ID09PSBrZXkpO1xuXG4gICAgICAgICAgICAvLyBpZiB3YXNudCBwcmV2aW91c2x5IHNlbGVjdGVkIGFkZCB0byBsaXN0XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXIucHVzaCh7IGtleToga2V5LCBzdGF0ZTogc3RhdGV9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IENvbHVtblNvcnRpbmdTdGF0ZS5Bc2NlbmRpbmcgfHwgc3RhdGUgPT09IENvbHVtblNvcnRpbmdTdGF0ZS5EZXNjZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmRlci5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyLnB1c2goeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXIuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ldmVudHMubmV4dCh0aGlzLm9yZGVyKTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgb3JkZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yZGVyO1xuXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtblNvcnRpbmdPcmRlciB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgc3RhdGU6IENvbHVtblNvcnRpbmdTdGF0ZTsgXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sdW1uU29ydGluZ0NvbXBvbmVudCB9IGZyb20gJy4vY29sdW1uLXNvcnRpbmcuY29tcG9uZW50JztcblxuaW1wb3J0IHsgQ29sdW1uU29ydGluZ0RpcmVjdGl2ZSB9IGZyb20gJy4vY29sdW1uLXNvcnRpbmcuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbQ29sdW1uU29ydGluZ0NvbXBvbmVudCwgQ29sdW1uU29ydGluZ0RpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbQ29sdW1uU29ydGluZ0NvbXBvbmVudCwgQ29sdW1uU29ydGluZ0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgQ29sdW1uU29ydGluZ01vZHVsZSB7IH0iLCJpbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IENvbmR1aXRab25lIH0gZnJvbSAnLi9jb25kdWl0LXpvbmUuc2VydmljZSc7XG5pbXBvcnQgeyBDb25kdWl0RXZlbnQgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1ldmVudCc7XG5pbXBvcnQgeyBDb25kdWl0TWV0YWRhdGEgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1tZXRhZGF0YSc7XG5cbmV4cG9ydCBjbGFzcyBDb25kdWl0U3ViamVjdCB7XG5cbiAgICBwcml2YXRlIF9zdWJqZWN0OiBTdWJqZWN0PGFueT47XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEsIHByaXZhdGUgX3pvbmU6IENvbmR1aXRab25lLCBwdWJsaWMgem9uZUlkOiBzdHJpbmcpIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgdGFyZ2V0IHN1YmplY3Qgb2JqZWN0XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBjb25kdWl0LnN1YmplY3Q7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBjb25kdWl0cyB0aGF0IGhhdmUgc3VwcGxpZWQgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIHRoZSBzb3VyY2Ugc3ViamVjdFxuICAgICAgICB0aGlzLl9zdWJqZWN0LnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoY29uZHVpdC5jaGFuZ2VEZXRlY3Rpb24pLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5vbk91dHB1dC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIHpvbmUgZXZlbnRzIGFuZCByb290IHpvbmUgZXZlbnRzXG4gICAgICAgIF96b25lLmdldEV2ZW50cygpLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50LmNvbmR1aXQuaWQgPT09IGNvbmR1aXQuaWQpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25JbnB1dC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2sgYWxsIGFsbG93IGlucHV0cyB0byBzZWUgaWYgdGhlcmUgaXMgYSB2YWx1ZSB3ZSBzaG91bGQgaW5pdGlhbGx5IHNldCB0aGUgY29uZHVpdCB0byAqL1xuICAgIGdldEluaXRpYWxWYWx1ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB3ZSBkbyBub3QgYWNjZXB0IGlucHV0cyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gYWxsIHN1YmplY3RzIHRoYXQgYXJlIDEpIE5vdCBpdHNlbGYgMikgSW4gYSB6b25lIHRoYXQgaXMgbGlzdGVkIGluIGFjY2VwdHNJbnB1dCAzKSBIYXZlIGEgY3VycmVudFZhbHVlIHNldFxuICAgICAgICBjb25zdCBzdWJqZWN0cyA9IHRoaXMuX3pvbmUuZ2V0U3ViamVjdHMoKS5maWx0ZXIoc3ViamVjdCA9PiB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgaXRzZWxmIG9yIGlmIGl0IGhhcyBub3QgdmFsdWUgdG8gZ2l2ZSB1cyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmIChzdWJqZWN0ID09PSB0aGlzIHx8IHN1YmplY3QuY29uZHVpdC5pZCAhPT0gdGhpcy5jb25kdWl0LmlkIHx8ICFzdWJqZWN0LmNvbmR1aXQuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhY2NlcHRzSW5wdXQgaXMgdHJ1ZSB0aGVuIHdlIHJldHVybiBldmVyeSB0aW1lXG4gICAgICAgICAgICBpZiAodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0LmluZGV4T2Yoc3ViamVjdC56b25lSWQpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hdGNoZXMgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmIChzdWJqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBzb3J0IGJ5IHRoZSBsYXN0IG1vZGlmaWVkIGZpZWxkXG4gICAgICAgIHN1YmplY3RzLnNvcnQoKHN1YmplY3RPbmUsIHN1YmplY3RUd28pID0+IHN1YmplY3RPbmUuY29uZHVpdC5sYXN0TW9kaWZpZWQuZ2V0VGltZSgpIDwgc3ViamVjdFR3by5jb25kdWl0Lmxhc3RNb2RpZmllZC5nZXRUaW1lKCkgPyAxIDogLTEpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgbW9zdCByZWNlbnQgdmFsdWVcbiAgICAgICAgdGhpcy5fc3ViamVjdC5uZXh0KHN1YmplY3RzWzBdLmNvbmR1aXQuY3VycmVudFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogVGhpcyB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIGEgY29uZHVpdHMgdmFsdWUgaGFzIGNoYW5nZWQgKi9cbiAgICBvbklucHV0KGV2ZW50OiBDb25kdWl0RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgd2UgZG9udCBhY2NlcHQgaW5wdXQgb3Igd2UgZW1pdHRlZCB0aGlzIHZhbHVlIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCA9PT0gZmFsc2UgfHwgZXZlbnQuY29uZHVpdCA9PT0gdGhpcy5jb25kdWl0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgY29uZHVpdCBwcm9kdWNlcyBvdXRwdXQgLSBpZiBub3Qgd2Ugb25seSBkbyBzb21ldGhpbmcgaWYgd2UgYXJlIGluIHRoZSBzYW1lIHpvbmVcbiAgICAgICAgaWYgKGV2ZW50LmNvbmR1aXQucHJvZHVjZXNPdXRwdXQgPT09IGZhbHNlICYmIGV2ZW50LnpvbmVJZCAhPT0gdGhpcy56b25lSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG9ubHkgYWNjZXB0IGlucHV0cyBmcm9tIHNwZWNpZmljIHpvbmVzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZXZlbnQgY2FtZSBmcm9tIGFuIGFjY2VwdGFibGUgem9uZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0LmZpbmQoem9uZSA9PiB6b25lID09PSBldmVudC56b25lSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcmVxdWlyZWQgdHJhbnNmb3JtIHRoZSB2YWx1ZVxuICAgICAgICBjb25zdCBvdXRwdXRWYWx1ZSA9IHRoaXMuY29uZHVpdC5tYXAgPyB0aGlzLmNvbmR1aXQubWFwKGV2ZW50LnZhbHVlKSA6IGV2ZW50LnZhbHVlO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3ViamVjdFxuICAgICAgICB0aGlzLl9zdWJqZWN0Lm5leHQob3V0cHV0VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKiBUaGlzIHdpbGwgYmUgZmlyZWQgd2hlbiB0aGlzIGNvbmR1aXQgZW1pdHMgYSBuZXcgdmFsdWUgKi9cbiAgICBvbk91dHB1dCh2YWx1ZTogYW55KTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGFuZCB3aGVuIGl0IHdhcyBtb2RpZmllZCAtIGNhbiBiZSB1c2VkIGZvciBhbnkgbmV3IGNvbmR1aXRzIHRvIGxvb2t1cCBhIHZhbHVlXG4gICAgICAgIHRoaXMuY29uZHVpdC5jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25kdWl0Lmxhc3RNb2RpZmllZCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBzaG91bGQgcHJvZHVjZSBvdXRwdXRcbiAgICAgICAgaWYgKHRoaXMuY29uZHVpdC5wcm9kdWNlc091dHB1dCkge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5lbWl0KHsgY29uZHVpdDogdGhpcy5jb25kdWl0LCB6b25lSWQ6IHRoaXMuem9uZUlkLCB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBVbnN1YnNjcmliZSBvbmNlIHRoaXMgc3ViamVjdCBpcyBkZXN0cm95ZWQgKi9cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG59XG4iLCIvKiogVGhpcyB1dGlsaXR5IGlzIHRvIGVuc3VyZSBhIGFsbCBmdW5jdGlvbnMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgYXJlIGNhbGxlZCBpbiBhbGwgc3VwZXIgY2xhc3NlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVN1cGVyRnVuY3Rpb24odGFyZ2V0OiBvYmplY3QsIGZ1bmN0aW9uTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gZ2V0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGZ1bmN0aW9uXG4gICAgY29uc3QgZnVuY3Rpb25MaXN0OiBGdW5jdGlvbltdID0gW107XG5cbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBwcm90b3R5cGUgd2UgYXJlIGNoZWNraW5nXG4gICAgbGV0IHByb3RvdHlwZTogYW55ID0gdGFyZ2V0O1xuXG4gICAgLy8gbG9vayB0aHJvdWdoIGV2ZXJ5IGJhc2UgY2xhc3MgYW5kIGNoZWNrIGl0XG4gICAgZG8ge1xuICAgICAgICBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5KGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTGlzdC5wdXNoKHByb3RvdHlwZVtmdW5jdGlvbk5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvdHlwZSA9IHByb3RvdHlwZS5fX3Byb3RvX187XG4gICAgfSB3aGlsZSAocHJvdG90eXBlLl9fcHJvdG9fXyk7XG5cbiAgICAvLyBhdWdtZW50IHRoZSB0b3AgbGV2ZWwgZnVuY3Rpb24gdG8gY2FsbCBhbGwgdGhlIGZ1bmN0aW9uc1xuICAgIHRhcmdldFtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIGZ1bmN0aW9uTGlzdC5mb3JFYWNoKGZ1bmMgPT4gZnVuYy5jYWxsKHRhcmdldCwgLi4uYXJncykpO1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQ29uZHVpdFN1YmplY3QgfSBmcm9tICcuL2NvbmR1aXQtc3ViamVjdCc7XG5pbXBvcnQgeyBDb25kdWl0RXZlbnQgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1ldmVudCc7XG5pbXBvcnQgeyBDb25kdWl0TWV0YWRhdGEgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1tZXRhZGF0YSc7XG5pbXBvcnQgeyBDb25kdWl0UHJvcGVydGllcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LXByb3BlcnRpZXMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29uZHVpdFpvbmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIENyZWF0ZSBhIGdsb2JhbCBzdWJqZWN0IHN0b3JlICovXG4gICAgc3RhdGljIHN1YmplY3RzOiBDb25kdWl0U3ViamVjdFtdID0gW107XG5cbiAgICAvKiogRXhwb3NlIGFuIGV2ZW50IHN0cmVhbSBvZiBuZXcgdmFsdWVzICovXG4gICAgc3RhdGljIGV2ZW50cyA9IG5ldyBTdWJqZWN0PENvbmR1aXRFdmVudD4oKTtcblxuICAgIC8qKiBTdG9yZSB0aGUgem9uZSBuYW1lICovXG4gICAgcHJpdmF0ZSBfem9uZUlkOiBzdHJpbmc7XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCBhbGwgY29uZHVpdCBzdWJqZWN0cyB0aGF0IGFyZSBwYXJ0IG9mIHRoaXMgem9uZVxuICAgICAgICBDb25kdWl0Wm9uZS5zdWJqZWN0cy5maWx0ZXIoX3N1YmplY3QgPT4gX3N1YmplY3Quem9uZUlkID09PSB0aGlzLl96b25lSWQpXG4gICAgICAgICAgICAuZm9yRWFjaChfc3ViamVjdCA9PiB0aGlzLnVucmVnaXN0ZXJDb25kdWl0KF9zdWJqZWN0LmNvbmR1aXQpKTtcbiAgICB9XG5cbiAgICAvKiogU3RvcmUgcmVmZXJlbmNlIHRvIHRoZSByZXBvc2l0b3J5IGFuZCBiZWdpbiB3YXRjaGluZyBmb3IgYW5kIGVtaXR0aW5nIGNoYW5nZXMgKi9cbiAgICByZWdpc3RlckNvbmR1aXQoY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhKTogdm9pZCB7XG4gICAgICAgIENvbmR1aXRab25lLnN1YmplY3RzLnB1c2gobmV3IENvbmR1aXRTdWJqZWN0KGNvbmR1aXQsIHRoaXMsIHRoaXMuX3pvbmVJZCkpO1xuICAgIH1cblxuICAgIC8qKiBEZXN0cm95IGEgY29uZHVpdCAqL1xuICAgIHVucmVnaXN0ZXJDb25kdWl0KGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSk6IHZvaWQge1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5nZXRDb25kdWl0U3ViamVjdChjb25kdWl0LnN1YmplY3QpO1xuXG4gICAgICAgIGlmIChzdWJqZWN0KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHN1YmplY3QgZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjb25kdWl0IHN1YmplY3RzXG4gICAgICAgICAgICBDb25kdWl0Wm9uZS5zdWJqZWN0cyA9IENvbmR1aXRab25lLnN1YmplY3RzLmZpbHRlcihfc3ViamVjdCA9PiBfc3ViamVjdCAhPT0gc3ViamVjdCk7XG5cbiAgICAgICAgICAgIC8vIHBlcmZvcm0gYWxsIHVuc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgc3ViamVjdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUHJvdmlkZSB0aGUgem9uZSB3aXRoIGFuIElEICovXG4gICAgc2V0Wm9uZUlkKHpvbmVJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmVJZCA9IHpvbmVJZDtcbiAgICB9XG5cbiAgICAvKiogRW1pdCBhIHZhbHVlIHRvIGFsbCB6b25lcyBmb3IgY2hlY2tpbmcgKi9cbiAgICBlbWl0KGV2ZW50OiBDb25kdWl0RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgQ29uZHVpdFpvbmUuZXZlbnRzLm5leHQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKiBSZXRyaWV2ZSBhIGNvbmR1aXQgc3Vic2plY3Qgb2JqZWN0IGZyb20gdGhlIHJ4anMgc3ViamVjdCAqL1xuICAgIGdldENvbmR1aXRTdWJqZWN0KHN1YmplY3Q6IFN1YmplY3Q8YW55Pik6IENvbmR1aXRTdWJqZWN0IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBDb25kdWl0Wm9uZS5zdWJqZWN0cy5maW5kKF9zdWJqZWN0ID0+IF9zdWJqZWN0LmNvbmR1aXQuc3ViamVjdCA9PT0gc3ViamVjdCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCBhbGwgc3ViamVjdHMgZnJvbSBhbGwgem9uZXMgKi9cbiAgICBnZXRTdWJqZWN0cygpOiBDb25kdWl0U3ViamVjdFtdIHtcbiAgICAgICAgcmV0dXJuIENvbmR1aXRab25lLnN1YmplY3RzO1xuICAgIH1cblxuICAgIC8qKiBBbHRlciB0aGUgcHJvcGVydGllcyBvZiBhIGNvbmR1aXQgZHluYW1pY2FsbHkgKi9cbiAgICBzZXRDb25kdWl0UHJvcGVydGllcyhzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IFBhcnRpYWw8Q29uZHVpdFByb3BlcnRpZXM+KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgY29uZHVpdCB3aXRoIHRoZSBtYXRjaGluZyBzdWJqZWN0XG4gICAgICAgIGNvbnN0IGNvbmR1aXRTdWJqZWN0ID0gdGhpcy5nZXRTdWJqZWN0cygpLmZpbmQoX2NvbmR1aXQgPT4gX2NvbmR1aXQuY29uZHVpdC5zdWJqZWN0ID09PSBzdWJqZWN0KTtcblxuICAgICAgICAvLyBpZiBhIG1hdGNoIHdhcyBmb3VuZCB1cGRhdGUgdGhlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKGNvbmR1aXRTdWJqZWN0KSB7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBlYWNoIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25kdWl0U3ViamVjdC5jb25kdWl0W3Byb3BdID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbmR1aXQgYXQgcnVudGltZSAqL1xuICAgIGNyZWF0ZUNvbmR1aXQoc3ViamVjdDogU3ViamVjdDxhbnk+LCBwcm9wZXJ0aWVzOiBDb25kdWl0UHJvcGVydGllcyk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBjb25kdWl0IHdpdGggdGhlIHpvbmVcbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbmR1aXQoeyAuLi5wcm9wZXJ0aWVzLCBzdWJqZWN0IH0pO1xuICAgIH1cblxuICAgIC8qKiBSZWdpc3RlciBhbGwgY29uZHVpdHMgaW4gYSBjb21wb25lbnQgKi9cbiAgICByZWdpc3RlckNvbmR1aXRzKGNvbXBvbmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudC5fY29uZHVpdHMpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuX2NvbmR1aXRzLmZvckVhY2goKGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSkgPT4gdGhpcy5yZWdpc3RlckNvbmR1aXQoeyAuLi5jb25kdWl0LCBzdWJqZWN0OiBjb21wb25lbnRbY29uZHVpdC5wcm9wZXJ0eUtleV0gfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJlZ2lzdGVyIGFsbCBjb25kdWl0cyBpbiBhIGNvbXBvbmVudCAqL1xuICAgIHVucmVnaXN0ZXJDb25kdWl0cyhjb21wb25lbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnQuX2NvbmR1aXRzKSkge1xuICAgICAgICAgICAgY29tcG9uZW50Ll9jb25kdWl0cy5mb3JFYWNoKChjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEpID0+IHRoaXMudW5yZWdpc3RlckNvbmR1aXQoY29uZHVpdCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiB0aGUgZ2xvYmFsIGV2ZW50IHN0cmVhbSAqL1xuICAgIGdldEV2ZW50cygpOiBTdWJqZWN0PENvbmR1aXRFdmVudD4ge1xuICAgICAgICByZXR1cm4gQ29uZHVpdFpvbmUuZXZlbnRzO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE9uRGVzdHJveSwgT25Jbml0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBpbnZva2VTdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi9jb25kdWl0LXV0aWxzJztcbmltcG9ydCB7IENvbmR1aXRab25lIH0gZnJvbSAnLi9jb25kdWl0LXpvbmUuc2VydmljZSc7XG5pbXBvcnQgeyBDb25kdWl0UHJvcGVydGllcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LXByb3BlcnRpZXMnO1xuXG5leHBvcnQgY2xhc3MgQ29uZHVpdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByb3RlY3RlZCBfem9uZTogQ29uZHVpdFpvbmUpIHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBlbnN1cmUgdGhlc2UgZnVuY3Rpb25zIGdldCBjYWxsZWQgZXZlbiBpZiBhIGNsYXNzIG92ZXJyaWRlcyB0aGVtXG4gICAgICAgIGludm9rZVN1cGVyRnVuY3Rpb24odGhpcywgJ25nT25Jbml0Jyk7XG4gICAgICAgIGludm9rZVN1cGVyRnVuY3Rpb24odGhpcywgJ25nT25EZXN0cm95Jyk7XG4gICAgfVxuXG4gICAgLyoqIFdlIG5lZWQgdG8gcmVnaXN0ZXIgdGhlIGNvbmR1aXRzIHdpdGggdGhlIHpvbmUgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxpc2VkICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBjb25kdWl0IGluIHRoZSB6b25lIGFuZCBlbnN1cmUgaXQgZ2V0cyB0aGUgY29ycmVjdCBpbnN0YW5jZSBvZiB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMuX3pvbmUucmVnaXN0ZXJDb25kdWl0cyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKiogV2UgbmVlZCB0byB1bnJlZ2lzdGVyIHRoZSBjb25kdWl0cyB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUudW5yZWdpc3RlckNvbmR1aXRzKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKiBBbHRlciB0aGUgcHJvcGVydGllcyBvZiBhIGNvbmR1aXQgZHluYW1pY2FsbHkgKi9cbiAgICBzZXRDb25kdWl0UHJvcGVydGllcyhzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IFBhcnRpYWw8Q29uZHVpdFByb3BlcnRpZXM+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUuc2V0Q29uZHVpdFByb3BlcnRpZXMoc3ViamVjdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29uZHVpdCBhdCBydW50aW1lICovXG4gICAgY3JlYXRlQ29uZHVpdChzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IENvbmR1aXRQcm9wZXJ0aWVzKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUuY3JlYXRlQ29uZHVpdChzdWJqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29uZHVpdENvbXBvbmVudCB9IGZyb20gJy4vY29uZHVpdC5jb21wb25lbnQnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29uZHVpdFpvbmVDb21wb25lbnQgZXh0ZW5kcyBDb25kdWl0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBhYnN0cmFjdCB6b25lSWQ6IHN0cmluZztcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl96b25lLnNldFpvbmVJZCh0aGlzLnpvbmVJZCk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBDb25kdWl0UHJvcGVydGllcyB7XG4gICAgaWQ6IG51bWJlciB8IHN0cmluZztcbiAgICBhY2NlcHRzSW5wdXQ/OiBib29sZWFuIHwgc3RyaW5nW107XG4gICAgcHJvZHVjZXNPdXRwdXQ/OiBib29sZWFuO1xuICAgIGNoYW5nZURldGVjdGlvbj86ICh4OiBhbnksIHk6IGFueSkgPT4gYm9vbGVhbjtcbiAgICBtYXA/OiBhbnk7XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29uZHVpdFByb3BzOiBQYXJ0aWFsPENvbmR1aXRQcm9wZXJ0aWVzPiA9IHtcbiAgICBhY2NlcHRzSW5wdXQ6IHRydWUsXG4gICAgcHJvZHVjZXNPdXRwdXQ6IHRydWUsXG59O1xuIiwiaW1wb3J0IHsgQ29uZHVpdE1ldGFkYXRhIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtbWV0YWRhdGEnO1xuaW1wb3J0IHsgQ29uZHVpdFByb3BlcnRpZXMsIGRlZmF1bHRDb25kdWl0UHJvcHMgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1wcm9wZXJ0aWVzJztcblxuLyoqIEV4cG9zZSB0aGUgcHJvcGVydHkgdGhhdCBjb25kdWl0cyB3aWxsIGJlIHN0b3JlZCBpbiAqL1xuZXhwb3J0IGNvbnN0IENPTkRVSVRTID0gJ19jb25kdWl0cyc7XG5cbi8qKiBDcmVhdGUgdGhlIGNvbmR1aXQgcHJvcGVydHkgZGVjb3JhdG9yICovXG5leHBvcnQgZnVuY3Rpb24gQ29uZHVpdChwcm9wZXJ0aWVzOiBDb25kdWl0UHJvcGVydGllcyB8IEZ1bmN0aW9uKTogUHJvcGVydHlEZWNvcmF0b3Ige1xuICAgIHJldHVybiAodGFyZ2V0OiBPYmplY3QsIHByb3BlcnR5S2V5OiBzdHJpbmcpID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmNhbGwobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGRvZXMgbm90IGFscmVhZHkgaGF2ZSBhIGNvbmR1aXQgbGlzdCB0aGVuIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoQ09ORFVJVFMpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBDT05EVUlUUywgeyB2YWx1ZTogW10gfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIGNvbmR1aXQgdG8gdGhlIGxpc3QgZW5zdXJpbmcgYWxsIHJlcXVpcmVkIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkXG4gICAgICAgIHRhcmdldFtDT05EVUlUU10ucHVzaCh7IC4uLmRlZmF1bHRDb25kdWl0UHJvcHMsIC4uLnByb3BlcnRpZXMsIHRhcmdldCwgcHJvcGVydHlLZXkgfSBhcyBDb25kdWl0TWV0YWRhdGEpO1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRlbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IERhc2hib2FyZE9wdGlvbnMgfSBmcm9tICcuL2Rhc2hib2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50IH0gZnJvbSAnLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkU2VydmljZSB7XG5cbiAgICBwcml2YXRlIF93aWRnZXRPcmlnaW46IHsgY29sdW1uPzogbnVtYmVyLCByb3c/OiBudW1iZXIsIGNvbHVtblNwYW4/OiBudW1iZXIsIHJvd1NwYW4/OiBudW1iZXIgfTtcbiAgICBwcml2YXRlIF9hY3Rpb25XaWRnZXQ6IERhc2hib2FyZEFjdGlvbjtcbiAgICBwcml2YXRlIF9yb3dIZWlnaHQ6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBfY2FjaGU6IERhc2hib2FyZENhY2hlW107XG4gICAgcHJpdmF0ZSBfbW91c2VFdmVudDogTW91c2VFdmVudDtcblxuICAgIHdpZGdldHMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXT4oW10pO1xuICAgIG9wdGlvbnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXNoYm9hcmRPcHRpb25zPihkZWZhdWx0T3B0aW9ucyk7XG4gICAgZGltZW5zaW9ucyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZERpbWVuc2lvbnM+KHt9KTtcbiAgICBoZWlnaHQkOiBPYnNlcnZhYmxlPG51bWJlcj4gPSB0aGlzLmRpbWVuc2lvbnMkLnBpcGUoZGVsYXkoMCksIG1hcCgoZGltZW5zaW9uczogRGFzaGJvYXJkRGltZW5zaW9ucykgPT4gZGltZW5zaW9ucy5oZWlnaHQpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICBwbGFjZWhvbGRlciQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZFBsYWNlaG9sZGVyPih7IHZpc2libGU6IGZhbHNlLCB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgIGxheW91dCQgPSBuZXcgU3ViamVjdDxEYXNoYm9hcmRMYXlvdXREYXRhW10+KCk7XG4gICAgc3RhY2tlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCB3aWRnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCBzdGFja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja2VkJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCBkaW1lbnNpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGdldCBjb2x1bW5XaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9ucy53aWR0aCAvIHRoaXMub3B0aW9ucy5jb2x1bW5zO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxheW91dCQuc3Vic2NyaWJlKHRoaXMuc2V0TGF5b3V0RGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGFja2VkJC5waXBlKGZpbHRlcihzdGFja2VkID0+IHN0YWNrZWQgPT09IHRydWUpKS5zdWJzY3JpYmUodGhpcy51cGRhdGVXaGVuU3RhY2tlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzJC5waXBlKGRlbGF5KDApKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZW5kZXJEYXNoYm9hcmQoKSk7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyQucGlwZShkZWxheSgwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVuZGVyRGFzaGJvYXJkKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHdpZGdldCB0byB0aGUgZGFzaGJvYXJkXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IGNvbXBvbmVudCB0byBhZGQgdG8gdGhlIGRhc2hib2FyZFxuICAgICAqL1xuICAgIGFkZFdpZGdldCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLndpZGdldHMkLm5leHQoWy4uLnRoaXMud2lkZ2V0cyQuZ2V0VmFsdWUoKSwgd2lkZ2V0XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgd2lkZ2V0IGZyb20gdGhlIGRhc2hib2FyZFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmVXaWRnZXQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy53aWRnZXRzJC5uZXh0KHRoaXMud2lkZ2V0cyQuZ2V0VmFsdWUoKS5maWx0ZXIoX3dpZGdldCA9PiBfd2lkZ2V0ICE9PSB3aWRnZXQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB0aGF0IHRoZSBkYXNoYm9hcmQgZWxlbWVudCBoYXMgYmVlbiByZXNpemVkXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgZGFzaGJvYXJkIGVsZW1lbnQgaW4gcHhcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGRhc2hib2FyZCBlbGVtZW50IGluIHB4XG4gICAgICovXG4gICAgc2V0RGltZW5zaW9ucyh3aWR0aDogbnVtYmVyID0gdGhpcy5kaW1lbnNpb25zLndpZHRoLCBoZWlnaHQ6IG51bWJlciA9IHRoaXMuZGltZW5zaW9ucy5oZWlnaHQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGltZW5zaW9ucy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5kaW1lbnNpb25zLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMkLm5leHQoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHJlcXVpcmVkIGxheW91dCBkYXRhLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZXhwb3J0aW5nL3NhdmluZyBhIGxheW91dFxuICAgICAqL1xuICAgIGdldExheW91dERhdGEoKTogRGFzaGJvYXJkTGF5b3V0RGF0YVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5tYXAod2lkZ2V0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGlkOiB3aWRnZXQuaWQsIGNvbDogd2lkZ2V0LmdldENvbHVtbigpLCByb3c6IHdpZGdldC5nZXRSb3coKSwgY29sU3Bhbjogd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgcm93U3Bhbjogd2lkZ2V0LmdldFJvd1NwYW4oKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB3aWRnZXRzIHByb2dyYW1hdGljYWxseVxuICAgICAqL1xuICAgIHNldExheW91dERhdGEod2lkZ2V0czogRGFzaGJvYXJkTGF5b3V0RGF0YVtdKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggd2lkZ2V0IGRhdGEgYW5kIGZpbmQgYSBtYXRjaFxuICAgICAgICB3aWRnZXRzLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbWF0Y2hpbmcgd2lkZ2V0XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLndpZGdldHMuZmluZChfd2lkZ2V0ID0+IF93aWRnZXQuaWQgPT09IHdpZGdldC5pZCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0Q29sdW1uKHdpZGdldC5jb2wpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRSb3cod2lkZ2V0LnJvdyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldENvbHVtblNwYW4od2lkZ2V0LmNvbFNwYW4pO1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRSb3dTcGFuKHdpZGdldC5yb3dTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwb3NpdGlvbnMgYW5kIHNpemVzIG9mIHRoZSB3aWRnZXRzXG4gICAgICovXG4gICAgcmVuZGVyRGFzaGJvYXJkKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuX3Jvd0hlaWdodCA9IHRoaXMub3B0aW9ucy5yb3dIZWlnaHQgfHwgdGhpcy5jb2x1bW5XaWR0aDtcblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGNvbHVtbiB3aWR0aCBpcyBub3QgYmVsb3cgdGhlIG1pbiB3aWR0aHNcbiAgICAgICAgdGhpcy5zdGFja2VkJC5uZXh0KHRoaXMuY29sdW1uV2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcm93IGhlaWdodCBpcyBub3QgYmVsb3cgdGhlIG1pbiB3aWR0aHNcbiAgICAgICAgaWYgKHRoaXMuX3Jvd0hlaWdodCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1pbldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRMYXlvdXQoKTtcblxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFjaCB3aWRnZXQgYW5kIHNldCB0aGUgc2l6ZSAtIGV4Y2VwdCB0aGUgb25lIGJlaW5nIHJlc2l6ZWRcbiAgICAgICAgdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gIXRoaXMuX2FjdGlvbldpZGdldCB8fCB3aWRnZXQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQpXG4gICAgICAgICAgICAuZm9yRWFjaCh3aWRnZXQgPT4gd2lkZ2V0LnJlbmRlcigpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hlcmUgd2lkZ2V0cyBzaG91bGQgYmUgcG9zaXRpb25lZCBiYXNlZCBvbiB0aGVpciBwb3NpdGlvbnMsIHdpZHRoIGFuZCB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyXG4gICAgICovXG4gICAgc2V0RGFzaGJvYXJkTGF5b3V0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgYW55IHdpZGdldHMgdGhhdCBkbyBub3QgY3VycmVudGx5IGhhdmUgYSBwb3NpdGlvbiBzZXRcbiAgICAgICAgdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gd2lkZ2V0LmdldENvbHVtbigpID09PSB1bmRlZmluZWQgfHwgd2lkZ2V0LmdldFJvdygpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAuZm9yRWFjaCh3aWRnZXQgPT4gdGhpcy5zZXRXaWRnZXRQb3NpdGlvbih3aWRnZXQpKTtcblxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVdoZW5TdGFja2VkKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHdpZGdldCBzZXQgaXQncyBzdGFja2VkIHN0YXRlIGFuZFxuICAgICAgICB0aGlzLmdldFdpZGdldHNCeU9yZGVyKCkuZm9yRWFjaCgod2lkZ2V0LCBpZHgpID0+IHtcbiAgICAgICAgICAgIHdpZGdldC5zZXRDb2x1bW4oMCk7XG4gICAgICAgICAgICB3aWRnZXQuc2V0Um93KGlkeCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZ2V0V2lkZ2V0c0J5T3JkZXIoKTogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLnNvcnQoKHcxLCB3MikgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB3MVBvc2l0aW9uID0gdzEuZ2V0Q29sdW1uKCkgKiB3MS5nZXRSb3coKTtcbiAgICAgICAgICAgIGNvbnN0IHcyUG9zaXRpb24gPSB3Mi5nZXRDb2x1bW4oKSAqIHcyLmdldFJvdygpO1xuXG4gICAgICAgICAgICBpZiAodzFQb3NpdGlvbiA8IHcyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3MVBvc2l0aW9uID4gdzJQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHBvc2l0aW9uIHRoYXQgYSB3aWRnZXQgY2FuIGZpdCBpbiB0aGUgZGFzaGJvYXJkXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRvIHRyeSBhbmQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzZXRXaWRnZXRQb3NpdGlvbih3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgYSBwb3NpdGlvbiBmb3IgdGhlIHdpZGdldFxuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHJlcGVhdCB1bnRpbCBhIHNwYWNlIGlzIGZvdW5kXG4gICAgICAgIHdoaWxlICghc3VjY2Vzcykge1xuXG4gICAgICAgICAgICAvLyBnZXQgYSBwb3NpdGlvbiB0byB0cnlcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBvc2l0aW9uICUgdGhpcy5vcHRpb25zLmNvbHVtbnM7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gdGhpcy5vcHRpb25zLmNvbHVtbnMpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UG9zaXRpb25BdmFpbGFibGUoY29sdW1uLCByb3csIHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIHdpZGdldC5nZXRSb3dTcGFuKCkpKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHdpZGdldC5zZXRSb3cocm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW4gPT09IDAgJiYgd2lkZ2V0LmNvbFNwYW4gPiB0aGlzLm9wdGlvbnMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGFzaGJvYXJkIHdpZGdldHMgaGF2ZSBhIGNvbFNwYW4gZ3JlYXRlciB0aGFuIHRoZSBtYXggbnVtYmVyIG9mIGRhc2hib2FyZCBjb2x1bW5zIScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBwb3NpdGlvbiBpbiB0aGUgZGFzaGJvYXJkIGlzIHZhY2FudCBvciBub3RcbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbkF2YWlsYWJsZShjb2x1bW46IG51bWJlciwgcm93OiBudW1iZXIsIGNvbHVtblNwYW46IG51bWJlciwgcm93U3BhbjogbnVtYmVyLCBpZ25vcmVXaWRnZXQ/OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBnZXQgYSBsaXN0IG9mIGdyaWQgc3BhY2VzIHRoYXQgYXJlIHBvcHVsYXRlZFxuICAgICAgICBjb25zdCBzcGFjZXMgPSB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGJsb2NrIHdvdWxkIHN0aWxsIGJlIGluIGJvdW5kc1xuICAgICAgICBpZiAoY29sdW1uICsgY29sdW1uU3BhbiA+IHRoaXMub3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBlYWNoIHJlcXVpcmVkIHBvc2l0aW9uXG4gICAgICAgIGZvciAobGV0IHggPSBjb2x1bW47IHggPCBjb2x1bW4gKyBjb2x1bW5TcGFuOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSByb3c7IHkgPCByb3cgKyByb3dTcGFuOyB5KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VzLmZpbmQoYmxvY2sgPT4gYmxvY2suY29sdW1uID09PSB4ICYmIGJsb2NrLnJvdyA9PT0geSAmJiBibG9jay53aWRnZXQgIT09IGlnbm9yZVdpZGdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldE9jY3VwaWVkU3BhY2VzKCk6IERhc2hib2FyZFNwYWNlW10ge1xuXG4gICAgICAgIC8vIGZpbmQgYWxsIHNwYWNlcyB0aGF0IGFyZSBjdXJyZW50bHkgb2NjdXBpZWRcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5maWx0ZXIod2lkZ2V0ID0+IHdpZGdldC5nZXRDb2x1bW4oKSAhPT0gdW5kZWZpbmVkICYmIHdpZGdldC5nZXRSb3coKSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgLnJlZHVjZSgodmFsdWUsIHdpZGdldCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoQmxvY2sod2lkZ2V0LCAoY29sdW1uLCByb3cpID0+IHZhbHVlLnB1c2goeyB3aWRnZXQ6IHdpZGdldCwgY29sdW1uOiBjb2x1bW4sIHJvdzogcm93IH0pKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZWdpbiByZXNpemluZyBhIHdpZGdldFxuICAgICAqIEBwYXJhbSBhY3Rpb24gVGhlIHRoZSB3aWRnZXQgdG8gcmVzaXplXG4gICAgICovXG4gICAgb25SZXNpemVTdGFydChhY3Rpb246IERhc2hib2FyZEFjdGlvbik6IHZvaWQge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBtb3VzZSBldmVudFxuICAgICAgICB0aGlzLl9tb3VzZUV2ZW50ID0gYWN0aW9uLmV2ZW50O1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQgPSBhY3Rpb247XG5cbiAgICAgICAgLy8gYnJpbmcgdGhlIHdpZGdldCB0byB0aGUgZm9udFxuICAgICAgICB0aGlzLmJyaW5nVG9Gcm9udChhY3Rpb24ud2lkZ2V0KTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZURyYWcoYWN0aW9uOiBEYXNoYm9hcmRBY3Rpb24pOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBtb3VzZVBvc1ggPSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VYIC0gcGFnZVhPZmZzZXQ7XG4gICAgICAgIGNvbnN0IG1vdXNlUG9zWSA9IHRoaXMuX21vdXNlRXZlbnQucGFnZVkgLSBwYWdlWU9mZnNldDtcblxuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgbm8gbW92ZW1lbnQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmIChhY3Rpb24uZXZlbnQueCA9PT0gbW91c2VQb3NYICYmIGFjdGlvbi5ldmVudC55ID09PSBtb3VzZVBvc1kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RvcmVkIG1vdXNlIGV2ZW50XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBhY3Rpb24uZXZlbnQ7XG5cbiAgICAgICAgLy8gZ2V0IGhhbmRsZSBmb3IgZGlyZWN0aW9uXG4gICAgICAgIGNvbnN0IHsgaGFuZGxlIH0gPSBhY3Rpb247XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGhhbmRsZVxuICAgICAgICBjb25zdCBib3VuZHMgPSBoYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjZW50ZXIgb2YgdGhlIGhhbmRsZVxuICAgICAgICBjb25zdCBjZW50ZXJYID0gYm91bmRzLmxlZnQgKyAoYm91bmRzLndpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBib3VuZHMudG9wICsgKGJvdW5kcy5oZWlnaHQgLyAyKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgICAgICAgY29uc3QgbW91c2VYID0gbW91c2VQb3NYIC0gY2VudGVyWDtcbiAgICAgICAgY29uc3QgbW91c2VZID0gbW91c2VQb3NZIC0gY2VudGVyWTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbmV3IHByb3Bvc2VkIGRpbWVuc2lvbnMgZm9yIHRoZSB3aWRnZXRcbiAgICAgICAgY29uc3QgZGltZW5zaW9uczogRGFzaGJvYXJkV2lkZ2V0RGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHg6IGFjdGlvbi53aWRnZXQueCxcbiAgICAgICAgICAgIHk6IGFjdGlvbi53aWRnZXQueSxcbiAgICAgICAgICAgIHdpZHRoOiBhY3Rpb24ud2lkZ2V0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBhY3Rpb24ud2lkZ2V0LmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHVwZGF0ZSB3aWRnZXQgYmFzZWQgb24gdGhlIGhhbmRsZSBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLmRpcmVjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggLT0gbW91c2VYO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5XaWR0aCAtIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlRvcDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0IC09IG1vdXNlWTtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy55IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0IHJlc2l6aW5nIG9uIG11bHRpcGxlIGF4aXMgc2ltdWx0YW5lb3VzbHlcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQ6XG5cbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggLT0gbW91c2VYO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5XaWR0aCAtIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy55ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAtPSBtb3VzZVk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy5oZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQ6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy55ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAtPSBtb3VzZVk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy5oZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tTGVmdDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy54ICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoIC09IG1vdXNlWDtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluV2lkdGggLSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tUmlnaHQ6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudFdpZHRoID0gYWN0aW9uLndpZGdldC54ICsgYWN0aW9uLndpZGdldC53aWR0aDtcbiAgICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IGFjdGlvbi53aWRnZXQueSArIGFjdGlvbi53aWRnZXQuaGVpZ2h0O1xuXG4gICAgICAgIC8vIGVuc3VyZSB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZGFzaGJvYXJkIGJvdW5kc1xuICAgICAgICBpZiAoZGltZW5zaW9ucy54IDwgMCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy54ID0gMDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggPSBjdXJyZW50V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGltZW5zaW9ucy55IDwgMCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy55ID0gMDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ID0gY3VycmVudEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZGltZW5zaW9ucy54ICsgZGltZW5zaW9ucy53aWR0aCkgPiB0aGlzLmRpbWVuc2lvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggPSB0aGlzLmRpbWVuc2lvbnMud2lkdGggLSBkaW1lbnNpb25zLng7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcHJvcG9zZWQgd2lkdGggaXMgc21hbGxlciB0aGFuIGFsbG93ZWQgdGhlbiByZXNldCB3aWR0aCB0byBtaW5pbXVtIGFuZCBpZ25vcmUgeCBjaGFuZ2VzXG4gICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnggPSBhY3Rpb24ud2lkZ2V0Lng7XG4gICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoID0gdGhpcy5vcHRpb25zLm1pbldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHByb3Bvc2VkIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gYWxsb3dlZCB0aGVuIHJlc2V0IGhlaWdodCB0byBtaW5pbXVtIGFuZCBpZ25vcmUgeSBjaGFuZ2VzXG4gICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMueSA9IGFjdGlvbi53aWRnZXQueTtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgd2lkZ2V0IGFjdHVhbCB2YWx1ZXNcbiAgICAgICAgYWN0aW9uLndpZGdldC5zZXRCb3VuZHMoZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyB1cGRhdGUgcGxhY2Vob2xkZXIgcG9zaXRpb24gYW5kIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHModHJ1ZSwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBzaG93IHRoZSB3aWRnZXQgcG9zaXRpb25zIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9ucyBhbmQgc2l6ZXMgd2VyZSB0byBwZXJzaXN0XG4gICAgICAgIHRoaXMudXBkYXRlV2lkZ2V0UG9zaXRpb25zKGFjdGlvbi53aWRnZXQpO1xuICAgIH1cblxuICAgIG9uUmVzaXplRW5kKCk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjb21taXQgcmVzaXplIGNoYW5nZXNcbiAgICAgICAgdGhpcy5jb21taXRXaWRnZXRDaGFuZ2VzKCk7XG5cbiAgICAgICAgLy8gaGlkZSBwbGFjZWhvbGRlclxuICAgICAgICBwbGFjZWhvbGRlci52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyJC5uZXh0KHBsYWNlaG9sZGVyKTtcblxuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3VzZUV2ZW50ID0gbnVsbDtcblxuICAgICAgICAvLyBlbnN1cmUgYW55IHZhY2FudCB1cHBlciBzcGFjZXMgYXJlIGZpbGxlZCB3aGVyZSByZXF1aXJlZFxuICAgICAgICB0aGlzLnNoaWZ0V2lkZ2V0c1VwKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGRhc2hib2FyZCBoZWlnaHRcbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRIZWlnaHQoKTtcblxuICAgICAgICAvLyBlbWl0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBsYXlvdXRcbiAgICAgICAgdGhpcy5sYXlvdXQkLm5leHQodGhpcy5nZXRMYXlvdXREYXRhKCkpO1xuICAgIH1cblxuICAgIG9uRHJhZ1N0YXJ0KGFjdGlvbjogRGFzaGJvYXJkQWN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25SZXNpemVTdGFydChhY3Rpb24pO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBzdGFydGluZyBwbGFjZWhvbGRlciBwb3NpdGlvblxuICAgICAgICB0aGlzLnNldFdpZGdldE9yaWdpbigpO1xuXG4gICAgICAgIHRoaXMuY2FjaGVXaWRnZXRzKCk7XG4gICAgfVxuXG4gICAgb25EcmFnRW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uUmVzaXplRW5kKCk7XG5cbiAgICAgICAgdGhpcy5fd2lkZ2V0T3JpZ2luID0ge307XG4gICAgfVxuXG4gICAgb25EcmFnKGFjdGlvbjogRGFzaGJvYXJkQWN0aW9uKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIG1vdmVtZW50IHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAoYWN0aW9uLmV2ZW50LnBhZ2VYID09PSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VYICYmIGFjdGlvbi5ldmVudC5wYWdlWSA9PT0gdGhpcy5fbW91c2VFdmVudC5wYWdlWSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IG1vdXNlWCA9IGFjdGlvbi5ldmVudC5wYWdlWCAtIHRoaXMuX21vdXNlRXZlbnQucGFnZVg7XG4gICAgICAgIGNvbnN0IG1vdXNlWSA9IGFjdGlvbi5ldmVudC5wYWdlWSAtIHRoaXMuX21vdXNlRXZlbnQucGFnZVk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGxhdGVzdCBldmVudFxuICAgICAgICB0aGlzLl9tb3VzZUV2ZW50ID0gYWN0aW9uLmV2ZW50O1xuXG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnM6IERhc2hib2FyZFdpZGdldERpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICB4OiBhY3Rpb24ud2lkZ2V0LnggKyBtb3VzZVgsXG4gICAgICAgICAgICB5OiBhY3Rpb24ud2lkZ2V0LnkgKyBtb3VzZVksXG4gICAgICAgICAgICB3aWR0aDogYWN0aW9uLndpZGdldC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYWN0aW9uLndpZGdldC5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc3RvcmVXaWRnZXRzKHRydWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB3aWRnZXQgcG9zaXRpb25cbiAgICAgICAgYWN0aW9uLndpZGdldC5zZXRCb3VuZHMoZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyB1cGRhdGUgcGxhY2Vob2xkZXIgcG9zaXRpb24gYW5kIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHModHJ1ZSwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBzaG93IHRoZSB3aWRnZXQgcG9zaXRpb25zIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9ucyBhbmQgc2l6ZXMgd2VyZSB0byBwZXJzaXN0XG4gICAgICAgIHRoaXMuc2hpZnRXaWRnZXRzKCk7XG5cbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRIZWlnaHQoKTtcbiAgICB9XG5cbiAgICBnZXRSb3dIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd0hlaWdodDtcbiAgICB9XG5cbiAgICBjYWNoZVdpZGdldHMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy53aWRnZXRzLm1hcCh3aWRnZXQgPT4gKHsgaWQ6IHdpZGdldC5pZCwgY29sdW1uOiB3aWRnZXQuZ2V0Q29sdW1uKCksIHJvdzogd2lkZ2V0LmdldFJvdygpIH0pKTtcbiAgICB9XG5cbiAgICByZXN0b3JlV2lkZ2V0cyhpZ25vcmVBY3Rpb25XaWRnZXQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9jYWNoZS5maWx0ZXIod2lkZ2V0ID0+ICFpZ25vcmVBY3Rpb25XaWRnZXQgfHwgd2lkZ2V0LmlkICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmlkKS5mb3JFYWNoKHdpZGdldCA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy53aWRnZXRzLmZpbmQod2d0ID0+IHdndC5pZCA9PT0gd2lkZ2V0LmlkKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2guc2V0Q29sdW1uKHdpZGdldC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIG1hdGNoLnNldFJvdyh3aWRnZXQucm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkcmFnZ2luZyBhbnkgd2lkZ2V0cyB0aGF0IG5lZWQgdG8gYmUgbW92ZWQgc2hvdWxkIGJlIG1vdmVkIHRvIGFuIGFwcHJvcHJpYXRlIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2hpZnRXaWRnZXRzKCk6IHZvaWQge1xuXG4gICAgICAgIGxldCB3aWRnZXRzVG9Nb3ZlOiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IHdpZGdldHMgdW5kZXIgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHBsYWNlaG9sZGVyLnJvdzsgcm93IDwgcGxhY2Vob2xkZXIucm93ICsgcGxhY2Vob2xkZXIucm93U3Bhbjsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiA9IHBsYWNlaG9sZGVyLmNvbHVtbjsgY29sdW1uIDwgcGxhY2Vob2xkZXIuY29sdW1uICsgcGxhY2Vob2xkZXIuY29sdW1uU3BhbjsgY29sdW1uKyspIHtcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHJlZmVyZW5jZSB0byBhbnkgd2lkZ2V0cyB0aGF0IG5lZWQgbW92ZWRcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKClcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihzcGFjZSA9PiBzcGFjZS5jb2x1bW4gPT09IGNvbHVtbiAmJiBzcGFjZS5yb3cgPT09IHJvdyAmJiBzcGFjZS53aWRnZXQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKHNwYWNlID0+IHdpZGdldHNUb01vdmUucHVzaChzcGFjZS53aWRnZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgZHVwbGljYXRlc1xuICAgICAgICB3aWRnZXRzVG9Nb3ZlID0gd2lkZ2V0c1RvTW92ZS5maWx0ZXIoKHdpZGdldCwgaWR4LCBhcnJheSkgPT4gYXJyYXkuaW5kZXhPZih3aWRnZXQpID09PSBpZHgpO1xuXG4gICAgICAgIC8vIGlmIG5vIHdpZGdldHMgbmVlZCBtb3ZlZCB0aGVuIHdlIGNhbiBzdG9wIGhlcmVcbiAgICAgICAgaWYgKHdpZGdldHNUb01vdmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYSBkdXBsaWNhdGUgd2UgY2FuIHVzZSB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGhhdmUgYmVlbiBtb3ZlZFxuICAgICAgICBjb25zdCB1bm1vdmVkV2lkZ2V0cyA9IHdpZGdldHNUb01vdmUuc2xpY2UoKTtcblxuICAgICAgICAvLyBhdHRlbXB0IHRvIG1vdmUgYW55IHdpZGdldHMgdG8gdGhlIHByZXZpb3VzIHdpZGdldCBwb3NpdGlvblxuICAgICAgICB3aWRnZXRzVG9Nb3ZlLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgLy8gZ2V0IGEgZ3JpZCBvZmYgYWxsIG9jY3VwaWVkIHNwYWNlcyAtIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHBsYWNlaG9sZGVyIGFuZCBpZ25vcmluZyB3aWRnZXRzIHRoYXQgbmVlZCBtb3ZlZFxuICAgICAgICAgICAgY29uc3QgZ3JpZCA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKS5maWx0ZXIoc3BhY2UgPT4gIXVubW92ZWRXaWRnZXRzLmZpbmQod2d0ID0+IHdndCA9PT0gc3BhY2Uud2lkZ2V0KSk7XG5cbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgZWFjaCBmcmVlIGJsb2NrXG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSB0aGlzLl93aWRnZXRPcmlnaW4ucm93OyByb3cgPCB0aGlzLl93aWRnZXRPcmlnaW4ucm93ICsgdGhpcy5fd2lkZ2V0T3JpZ2luLnJvd1NwYW47IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uID0gdGhpcy5fd2lkZ2V0T3JpZ2luLmNvbHVtbjsgY29sdW1uIDwgdGhpcy5fd2lkZ2V0T3JpZ2luLmNvbHVtbiArIHRoaXMuX3dpZGdldE9yaWdpbi5jb2x1bW5TcGFuOyBjb2x1bW4rKykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgYmxvY2sgY2FuIGZpdCBpbiB0aGlzIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXF1aXJlZFNwYWNlcyA9IHRoaXMuZ2V0UmVxdWlyZWRTcGFjZXNGcm9tUG9pbnQod2lkZ2V0LCBjb2x1bW4sIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2lkZ2V0IHdvdWxkIGZpdCBpbiBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBsZXQgYXZhaWxhYmxlID0gcmVxdWlyZWRTcGFjZXMuZXZlcnkoc3BhY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFncmlkLmZpbmQoZ3JpZFNwYWNlID0+IGdyaWRTcGFjZS5jb2x1bW4gPT09IHNwYWNlLmNvbHVtbiAmJiBncmlkU3BhY2Uucm93ID09PSBzcGFjZS5yb3cpICYmIHNwYWNlLmNvbHVtbiA8IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnNldFJvdyhyb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3ZlZFdpZGdldHMuc3BsaWNlKHVubW92ZWRXaWRnZXRzLmZpbmRJbmRleCh3Z3QgPT4gd2d0ID09PSB3aWRnZXQpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgZ2V0IHRvIGhlcmUgdGhlbiB3ZSBjYW4ndCBzaW1wbHkgc3dhcCB0aGUgcG9zaXRpb25zIC0gbmV4dCB0cnkgbW92aW5nIHJpZ2h0XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5XaWRnZXRNb3ZlUmlnaHQod2lkZ2V0LCB0cnVlKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHNoaWZ0IGNoZWNrIGlmIHBsYWNlaG9sZGVyIHBvc2l0aW9uIGlzIHN0aWxsIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24oQWN0aW9uRGlyZWN0aW9uLlJpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5leHQgdHJ5IG1vdmluZyBsZWZ0XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5XaWRnZXRNb3ZlTGVmdCh3aWRnZXQsIHRydWUpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2hpZnQgY2hlY2sgaWYgcGxhY2Vob2xkZXIgcG9zaXRpb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihBY3Rpb25EaXJlY3Rpb24uTGVmdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGRpc3RhbmNlIHRoYXQgdGhlIHdpZGdldCBuZWVkcyB0byBiZSBtb3ZlZCBkb3duXG4gICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSAodGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRSb3coKSAtIHdpZGdldC5nZXRSb3coKSkgKyB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvd1NwYW4oKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCBtb3ZlIHRoZSB3aWRnZXQgZG93bndhcmRzXG4gICAgICAgICAgICB0aGlzLm1vdmVXaWRnZXREb3duKHdpZGdldCwgZGlzdGFuY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZnRlciBzaGlmdHMgaGF2ZSB0YWtlbiBwbGFjZSB3ZSBzaG91bGQgdmVyaWZ5IHRoZSBwbGFjZSBob2xkZXIgcG9zaXRpb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgKiBAcGFyYW0gc2hpZnREaXJlY3Rpb24gLSB0aGUgcG9zaXRpb24gd2lkZ2V0cyB3ZXJlIHNoaWZ0ZWRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24oc2hpZnREaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbikge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcGxhY2Vob2xkZXIgaXMgb3ZlciBhIHdpZGdldFxuICAgICAgICBpZiAodGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihwbGFjZWhvbGRlci5jb2x1bW4sIHBsYWNlaG9sZGVyLnJvdywgdHJ1ZSkubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBwbGFjZWhvbGRlciB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgICAgICBzd2l0Y2ggKHNoaWZ0RGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyQm91bmRzKHBsYWNlaG9sZGVyLnZpc2libGUsIHBsYWNlaG9sZGVyLnggKyB0aGlzLmdldENvbHVtbldpZHRoKCksIHBsYWNlaG9sZGVyLnksIHBsYWNlaG9sZGVyLndpZHRoLCBwbGFjZWhvbGRlci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyQm91bmRzKHBsYWNlaG9sZGVyLnZpc2libGUsIHBsYWNlaG9sZGVyLnggLSB0aGlzLmdldENvbHVtbldpZHRoKCksIHBsYWNlaG9sZGVyLnksIHBsYWNlaG9sZGVyLndpZHRoLCBwbGFjZWhvbGRlci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFsaWRhdGUgdGhpcyBuZXcgcG9zaXRpb24gYWdhaW5cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQbGFjZWhvbGRlclBvc2l0aW9uKHNoaWZ0RGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIHdpZGdldCBjYW4gYmUgbW92ZWQgbGVmdCAtIG9yIGlmIGl0IGNhbiBtb3ZlIHRoZSB3aWRnZXRzIHRvIHRoZSByaWdodCB0byBtYWtlIHNwYWNlIGZvciB0aGUgd2lkZ2V0XG4gICAgICovXG4gICAgY2FuV2lkZ2V0TW92ZUxlZnQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIHBlcmZvcm1Nb3ZlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgd2lkZ2V0IGlzIHRoZSBhY3Rpb24gd2lkZ2V0IG9yIG9jY3VwaWVzIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAgICAgaWYgKHdpZGdldCA9PT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldCB8fCB3aWRnZXQuZ2V0Q29sdW1uKCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIHBvc2l0aW9ucyByZXF1aXJlZFxuICAgICAgICBjb25zdCB0YXJnZXRTcGFjZXMgPSB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKCkuZmlsdGVyKHNwYWNlID0+IHNwYWNlLndpZGdldCA9PT0gd2lkZ2V0KS5tYXAoc3BhY2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29sdW1uOiBzcGFjZS5jb2x1bW4gLSB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCByb3c6IHNwYWNlLnJvdywgd2lkZ2V0OiBzcGFjZS53aWRnZXQgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHdpZGdldCBpbiB0aGUgcmVxdWlyZWQgcG9zaXRpb25zIGFuZCBpZiBzbywgY2FuIHRoZXkgbW92ZSByaWdodD9cbiAgICAgICAgY29uc3QgbW92ZWFibGUgPSB0YXJnZXRTcGFjZXMuZXZlcnkoc3BhY2UgPT4gdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihzcGFjZS5jb2x1bW4sIHNwYWNlLnJvdykuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHNwYWNlLndpZGdldCkuZXZlcnkod2d0ID0+IHRoaXMuY2FuV2lkZ2V0TW92ZUxlZnQod2d0KSkpO1xuXG4gICAgICAgIGlmIChwZXJmb3JtTW92ZSAmJiBtb3ZlYWJsZSkge1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGFsbCB3aWRnZXRzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgdGFyZ2V0U3BhY2VzLmZvckVhY2goc3BhY2UgPT4gdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihzcGFjZS5jb2x1bW4sIHNwYWNlLnJvdykuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHNwYWNlLndpZGdldCkuZm9yRWFjaCh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlTGVmdCh3Z3QsIHRydWUpKSk7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgY3VycmVudCB3aWRnZXQgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKHdpZGdldC5nZXRDb2x1bW4oKSAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIHdpZGdldCBjYW4gYmUgbW92ZWQgcmlnaHQgLSBvciBpZiBpdCBjYW4gbW92ZSB0aGUgd2lkZ2V0cyB0byB0aGUgcmlnaHQgdG8gbWFrZSBzcGFjZSBmb3IgdGhlIHdpZGdldFxuICAgICAqL1xuICAgIGNhbldpZGdldE1vdmVSaWdodCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgcGVyZm9ybU1vdmU6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB3aWRnZXQgaXMgdGhlIGRyYWdnaW5nIHdpZGdldCBvciB0aGUgd2lkZ2V0IG9jY3VwaWVzIHRoZSBmaW5hbCBjb2x1bW5cbiAgICAgICAgaWYgKHdpZGdldCA9PT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldCB8fCB3aWRnZXQuZ2V0Q29sdW1uKCkgKyB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpID09PSB0aGlzLm9wdGlvbnMuY29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcG9zaXRpb25zIHJlcXVpcmVkXG4gICAgICAgIGNvbnN0IHRhcmdldFNwYWNlcyA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKS5maWx0ZXIoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0ID09PSB3aWRnZXQpLm1hcChzcGFjZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2x1bW46IHNwYWNlLmNvbHVtbiArIHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIHJvdzogc3BhY2Uucm93LCB3aWRnZXQ6IHNwYWNlLndpZGdldCB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgd2lkZ2V0IGluIHRoZSByZXF1aXJlZCBwb3NpdGlvbnMgYW5kIGlmIHNvLCBjYW4gdGhleSBtb3ZlIHJpZ2h0P1xuICAgICAgICBjb25zdCBtb3ZlYWJsZSA9IHRhcmdldFNwYWNlcy5ldmVyeShzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5ldmVyeSh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlUmlnaHQod2d0KSkpO1xuXG4gICAgICAgIGlmIChwZXJmb3JtTW92ZSAmJiBtb3ZlYWJsZSkge1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGFsbCB3aWRnZXRzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgdGFyZ2V0U3BhY2VzLmZvckVhY2goc3BhY2UgPT4gdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihzcGFjZS5jb2x1bW4sIHNwYWNlLnJvdykuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHNwYWNlLndpZGdldCkuZm9yRWFjaCh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlUmlnaHQod2d0LCB0cnVlKSkpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGN1cnJlbnQgd2lkZ2V0IHRvIHRoZSByaWdodFxuICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbih3aWRnZXQuZ2V0Q29sdW1uKCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlYWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSB0aGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgd2lkZ2V0IGJlaW5nIGRyYWdnZWRcbiAgICAgKi9cbiAgICBzZXRXaWRnZXRPcmlnaW4oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3dpZGdldE9yaWdpbiA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRDb2x1bW4oKSxcbiAgICAgICAgICAgIHJvdzogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRSb3coKSxcbiAgICAgICAgICAgIGNvbHVtblNwYW46IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Q29sdW1uU3BhbigpLFxuICAgICAgICAgICAgcm93U3BhbjogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRSb3dTcGFuKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYWxsIHRoZSByZXF1aXJlZCBwb3NpdGlvbnMgaXMgYSB3aWRnZXQgd2FzIHRvIGJlIHBvc2l0aW9uZWQgYXQgYSBwYXJ0aWN1bGFyIHBvaW50XG4gICAgICovXG4gICAgZ2V0UmVxdWlyZWRTcGFjZXNGcm9tUG9pbnQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlcik6IERhc2hib2FyZFNwYWNlW10ge1xuICAgICAgICBjb25zdCBzcGFjZXM6IERhc2hib2FyZFNwYWNlW10gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCB5ID0gcm93OyB5IDwgcm93ICsgd2lkZ2V0LmdldFJvd1NwYW4oKTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gY29sdW1uOyB4IDwgY29sdW1uICsgd2lkZ2V0LmdldENvbHVtblNwYW4oKTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgc3BhY2VzLnB1c2goeyBjb2x1bW46IHgsIHJvdzogeSwgd2lkZ2V0OiB3aWRnZXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHdpZGdldHMgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGFjZWhvbGRlciAtIHRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIGNvbmZpcm1lZFxuICAgICAqL1xuICAgIHVwZGF0ZVdpZGdldFBvc2l0aW9ucyh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCkge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayBhbGwgc3BhY2VzIHRoZSBwbGFjZWhvbGRlciB3aWxsIG9jY3VweSBhbmQgbW92ZSBhbnkgd2lkZ2V0IGN1cnJlbnRseSBpbiB0aGVtIGRvd25cbiAgICAgICAgZm9yIChsZXQgY29sdW1uID0gcGxhY2Vob2xkZXIuY29sdW1uOyBjb2x1bW4gPCBwbGFjZWhvbGRlci5jb2x1bW4gKyBwbGFjZWhvbGRlci5jb2x1bW5TcGFuOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gcGxhY2Vob2xkZXIucm93OyByb3cgPCBwbGFjZWhvbGRlci5yb3cgKyBwbGFjZWhvbGRlci5yb3dTcGFuOyByb3crKykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihjb2x1bW4sIHJvdywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSB3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKHdndCA9PiB0aGlzLm1vdmVXaWRnZXREb3duKHdndCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGRhc2hib2FyZFxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIHRoZSB0b3AgaGFuZGxlIHRoZW4gZmlsbCBzcGFjZXNcbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3AgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRXaWRnZXRzVXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIHdpZGdldCBpcyBvY2N1cHlpbmcgYSBzcGVjaWZpYyByb3cgYW5kIGNvbHVtblxuICAgICAqIEBwYXJhbSBjb2x1bW4gVGhlIGNvbHVtbnMgdG8gY2hlY2sgaWYgb2NjdXBpZWRcbiAgICAgKiBAcGFyYW0gcm93IFRoZSByb3cgdG8gY2hlY2sgaWYgb2NjdXBpZWRcbiAgICAgKiBAcGFyYW0gaWdub3JlUmVzaXppbmcgV2hldGhlciBvciBub3QgdG8gaWdub3JlIHRoZSB3aWRnZXQgY3VycmVudGx5IGJlaW5nIHJlc2l6ZWRcbiAgICAgKi9cbiAgICBnZXRXaWRnZXRzQXRQb3NpdGlvbihjb2x1bW46IG51bWJlciwgcm93OiBudW1iZXIsIGlnbm9yZVJlc2l6aW5nOiBib29sZWFuID0gZmFsc2UpOiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKClcbiAgICAgICAgICAgIC5maWx0ZXIoc3BhY2UgPT4gc3BhY2UuY29sdW1uID09PSBjb2x1bW4gJiYgc3BhY2Uucm93ID09PSByb3cpXG4gICAgICAgICAgICAuZmlsdGVyKHNwYWNlID0+IHNwYWNlLndpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldCB8fCAhaWdub3JlUmVzaXppbmcpXG4gICAgICAgICAgICAubWFwKHNwYWNlID0+IHNwYWNlLndpZGdldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwbGFjZWhvbGRlciB2aXNpYmlsaXR5LCBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAqL1xuICAgIHNldFBsYWNlaG9sZGVyQm91bmRzKHZpc2libGU6IGJvb2xlYW4sIHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICBjb25zdCByb3VuZGluZyA9IHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gPT09IEFjdGlvbkRpcmVjdGlvbi5MZWZ0IHx8XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uID09PSBBY3Rpb25EaXJlY3Rpb24uVG9wID8gUm91bmRpbmcuUm91bmREb3duQmVsb3dIYWxmIDogUm91bmRpbmcuUm91bmRVcE92ZXJIYWxmO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLnZpc2libGUgPSB2aXNpYmxlO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtbiA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJDb2x1bW4oeCwgd2lkdGgpO1xuICAgICAgICBwbGFjZWhvbGRlci5yb3cgPSB0aGlzLmdldFBsYWNlaG9sZGVyUm93KHksIGhlaWdodCk7XG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtblNwYW4gPSB0aGlzLmdldFBsYWNlaG9sZGVyQ29sdW1uU3Bhbih3aWR0aCk7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvd1NwYW4gPSB0aGlzLmdldFBsYWNlaG9sZGVyUm93U3BhbihoZWlnaHQpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93c1xuICAgICAgICBjb25zdCByb3dDb3VudCA9IHRoaXMud2lkZ2V0cy5maWx0ZXIod2lkZ2V0ID0+IHdpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXZpb3VzLCB3aWRnZXQpID0+IE1hdGgubWF4KHdpZGdldC5nZXRSb3coKSArIHdpZGdldC5nZXRSb3dTcGFuKCksIHByZXZpb3VzKSwgMCk7XG5cbiAgICAgICAgLy8gY29uc3RyYWluIG1heGltdW0gcGxhY2Vob2xkZXIgcm93XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvdyA9IE1hdGgubWluKHBsYWNlaG9sZGVyLnJvdywgcm93Q291bnQpO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLnggPSAocGxhY2Vob2xkZXIuY29sdW1uICogdGhpcy5nZXRDb2x1bW5XaWR0aCgpKSArIHRoaXMub3B0aW9ucy5wYWRkaW5nO1xuICAgICAgICBwbGFjZWhvbGRlci55ID0gKHBsYWNlaG9sZGVyLnJvdyAqIHRoaXMuX3Jvd0hlaWdodCkgKyB0aGlzLm9wdGlvbnMucGFkZGluZztcbiAgICAgICAgcGxhY2Vob2xkZXIud2lkdGggPSAocGxhY2Vob2xkZXIuY29sdW1uU3BhbiAqIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSkgLSAodGhpcy5vcHRpb25zLnBhZGRpbmcgKiAyKTtcbiAgICAgICAgcGxhY2Vob2xkZXIuaGVpZ2h0ID0gKHBsYWNlaG9sZGVyLnJvd1NwYW4gKiB0aGlzLl9yb3dIZWlnaHQpIC0gKHRoaXMub3B0aW9ucy5wYWRkaW5nICogMik7XG5cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZXMgb2YgdGhlIHdpZGdldCB0byBtYXRjaCB0aGUgdmFsdWVzIG9mIHRoZSBwbGFjZWhvbGRlciAtIGhvd2V2ZXIgZG8gbm90IHJlbmRlciB0aGUgY2hhbmdlc1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldENvbHVtbihwbGFjZWhvbGRlci5jb2x1bW4sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRSb3cocGxhY2Vob2xkZXIucm93LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Q29sdW1uU3BhbihwbGFjZWhvbGRlci5jb2x1bW5TcGFuLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Um93U3BhbihwbGFjZWhvbGRlci5yb3dTcGFuLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyJC5uZXh0KHBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBsYWNlaG9sZGVyIGNvbHVtbiBwb3NpdGlvblxuICAgICAqL1xuICAgIGdldFBsYWNlaG9sZGVyQ29sdW1uKHg6IG51bWJlciwgd2lkdGg6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5nZXRDb2x1bW5Gcm9tUHgoeCwgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiA9PT0gQWN0aW9uRGlyZWN0aW9uLk1vdmUgPyBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGYgOiBSb3VuZGluZy5Sb3VuZERvd24pO1xuICAgICAgICBjb25zdCBjb2x1bW5TcGFuID0gTWF0aC5mbG9vcih3aWR0aCAvIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSk7XG4gICAgICAgIGNvbnN0IHVwcGVyTGltaXQgPSB0aGlzLmdldENvbHVtbkNvdW50KCkgLSBjb2x1bW5TcGFuO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIGxlZnQgdGhlbiBqdXN0IHJldHVybiB0aGUgY29sdW1uXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oY29sdW1uLCB1cHBlckxpbWl0KSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYW55IG92ZXJmbG93XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gd2lkdGggJSB0aGlzLmdldENvbHVtbldpZHRoKCk7XG5cbiAgICAgICAgcmV0dXJuICh4IDw9IDAgfHwgb3ZlcmZsb3cgPT09IDAgfHwgY29sdW1uU3BhbiA9PT0gMCB8fCBvdmVyZmxvdyA+ICh0aGlzLmdldENvbHVtbldpZHRoKCkgLyAyKSkgP1xuICAgICAgICAgICAgTWF0aC5tYXgoTWF0aC5taW4oY29sdW1uLCB1cHBlckxpbWl0KSwgMCkgOlxuICAgICAgICAgICAgTWF0aC5tYXgoTWF0aC5taW4oY29sdW1uICsgMSwgdXBwZXJMaW1pdCksIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29sdW1uIHNwYW4gb2YgdGhlIHBsYWNlaG9sZGVyXG4gICAgICovXG4gICAgZ2V0UGxhY2Vob2xkZXJDb2x1bW5TcGFuKHdpZHRoOiBudW1iZXIpOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IGNvbHVtblNwYW4gPSB0aGlzLmdldENvbHVtbkZyb21QeCh3aWR0aCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgcmlnaHQgb3IgbGVmdCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBjb2x1bW4gc3BhblxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlJpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21SaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkxlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNvbHVtblNwYW4sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGNvbHVtbiBzcGFuIGFuZCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB3aWR0aCAlIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKTtcblxuICAgICAgICByZXR1cm4gKGNvbHVtblNwYW4gPiAwICYmIG92ZXJmbG93ID4gKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSAvIDIpKSA/IE1hdGgubWF4KGNvbHVtblNwYW4gKyAxLCAxKSA6IE1hdGgubWF4KGNvbHVtblNwYW4sIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IHBvc2l0aW9uIG9mIHRoZSBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGdldFBsYWNlaG9sZGVyUm93KHk6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93RnJvbVB4KHksIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gPT09IEFjdGlvbkRpcmVjdGlvbi5Nb3ZlID8gUm91bmRpbmcuUm91bmRVcE92ZXJIYWxmIDogUm91bmRpbmcuUm91bmREb3duKTtcbiAgICAgICAgY29uc3Qgcm93U3BhbiA9IE1hdGguY2VpbChoZWlnaHQgLyB0aGlzLl9yb3dIZWlnaHQpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIHVwIHRoZW4ganVzdCByZXR1cm4gdGhlIHJvd1xuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvdywgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYW55IG92ZXJmbG93XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGhlaWdodCA8IHRoaXMuX3Jvd0hlaWdodCA/IDAgOiBoZWlnaHQgJSB0aGlzLl9yb3dIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuICh5IDw9IDAgfHwgcm93U3BhbiA9PT0gMCB8fCBvdmVyZmxvdyA9PT0gMCB8fCBvdmVyZmxvdyA+ICh0aGlzLl9yb3dIZWlnaHQgLyAyKSkgPyBNYXRoLm1heChyb3csIDApIDogTWF0aC5tYXgocm93ICsgMSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb3cgc3BhbiBvZiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgKi9cbiAgICBnZXRQbGFjZWhvbGRlclJvd1NwYW4oaGVpZ2h0OiBudW1iZXIpOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IHJvd1NwYW4gPSB0aGlzLmdldFJvd0Zyb21QeChoZWlnaHQpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIHVwIG9yIGRvd24gdGhlbiBqdXN0IHJldHVybiB0aGUgY29sdW1uIHNwYW5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3AgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b20gJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChyb3dTcGFuLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBjb2x1bW4gc3BhbiBhbmQgYW55IG92ZXJmbG93XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gaGVpZ2h0ICUgdGhpcy5fcm93SGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiAob3ZlcmZsb3cgPiAodGhpcy5fcm93SGVpZ2h0IC8gMikpID8gTWF0aC5tYXgocm93U3BhbiArIDEsIDEpIDogTWF0aC5tYXgocm93U3BhbiwgMSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1uRnJvbVB4KHg6IG51bWJlciwgcm91bmRpbmc6IFJvdW5kaW5nID0gUm91bmRpbmcuUm91bmREb3duKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCBjb2x1bW4gPSBNYXRoLmZsb29yKHggLyBNYXRoLmZsb29yKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSkpO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9ICh4ICUgTWF0aC5mbG9vcih0aGlzLmdldENvbHVtbldpZHRoKCkpKTtcbiAgICAgICAgY29uc3QgaGFsZiA9IHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSAvIDI7XG5cbiAgICAgICAgc3dpdGNoIChyb3VuZGluZykge1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uO1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bkJlbG93SGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPCBoYWxmID8gY29sdW1uIDogY29sdW1uICsgMTtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93ID4gaGFsZiA/IGNvbHVtbiArIDEgOiBjb2x1bW47XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmRVcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiAwID8gY29sdW1uICsgMSA6IGNvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ2V0Um93RnJvbVB4KHk6IG51bWJlciwgcm91bmRpbmc6IFJvdW5kaW5nID0gUm91bmRpbmcuUm91bmREb3duKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKHkgLyBNYXRoLmZsb29yKHRoaXMuX3Jvd0hlaWdodCkpO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9ICh5ICUgTWF0aC5mbG9vcih0aGlzLl9yb3dIZWlnaHQpKTtcbiAgICAgICAgY29uc3QgaGFsZiA9IHRoaXMuX3Jvd0hlaWdodCAvIDI7XG5cbiAgICAgICAgc3dpdGNoIChyb3VuZGluZykge1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kRG93bkJlbG93SGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPCBoYWxmID8gcm93IDogcm93ICsgMTtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93ID4gaGFsZiA/IHJvdyArIDEgOiByb3c7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmRVcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiAwID8gcm93ICsgMSA6IHJvdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbW1pdFdpZGdldENoYW5nZXMoKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBhbGwgdGhlIHZhbHVlcyB3ZSBuZWVkXG4gICAgICAgIGlmIChwbGFjZWhvbGRlci5jb2x1bW4gPT09IHVuZGVmaW5lZCB8fCBwbGFjZWhvbGRlci5yb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uU3BhbiA9PT0gdW5kZWZpbmVkIHx8IHBsYWNlaG9sZGVyLnJvd1NwYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRDb2x1bW4ocGxhY2Vob2xkZXIuY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Um93KHBsYWNlaG9sZGVyLnJvdyk7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldENvbHVtblNwYW4ocGxhY2Vob2xkZXIuY29sdW1uU3Bhbik7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldFJvd1NwYW4ocGxhY2Vob2xkZXIucm93U3Bhbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCBhbGwgcGxhY2Vob2xkZXIgdmFsdWVzXG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGxhY2Vob2xkZXIucm93ID0gdW5kZWZpbmVkO1xuICAgICAgICBwbGFjZWhvbGRlci5jb2x1bW5TcGFuID0gdW5kZWZpbmVkO1xuICAgICAgICBwbGFjZWhvbGRlci5yb3dTcGFuID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIG5ldyBwbGFjZWhvbGRlciB2YWx1ZXNcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciQubmV4dChwbGFjZWhvbGRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbHVtbiB3aWR0aFxuICAgICAqL1xuICAgIGdldENvbHVtbldpZHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuY29sdW1uV2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgcG9wdWxhdGVkIHdpdGggd2lkZ2V0c1xuICAgICAqL1xuICAgIGdldFJvd0NvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMucmVkdWNlKChwcmV2aW91cywgd2lkZ2V0KSA9PiBNYXRoLm1heCh3aWRnZXQuZ2V0Um93KCkgKyB3aWRnZXQuZ2V0Um93U3BhbigpLCBwcmV2aW91cyksIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBkYXNoYm9hcmQgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBzZXREYXNoYm9hcmRIZWlnaHQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc2l6ZSB0aGUgZGFzaGJvYXJkIGNvbnRhaW5lciB0byBlbnN1cmUgYWxsIHJvd3MgZml0XG4gICAgICAgIGxldCByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICAvLyBpZiB3ZSBzaG91bGQgc2hvdyBhbiBlbXB0eSByb3cgaW5jcmVtZW50IHRoZSByb3cgY291bnQgYnkgMVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVtcHR5Um93KSB7XG4gICAgICAgICAgICByb3dDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHVuZGVmaW5lZCwgcm93Q291bnQgKiB0aGlzLl9yb3dIZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yZGVycyB0aGUgei1pbmRleCBvZiBhbGwgd2lkZ2V0cyB0byBtb3ZlIHRoZSBhY3RpdmUgb25lIHRvIHRoZSBmcm9udFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0aGF0IHNob3VsZCBiZSBicm91Z2h0IHRvIHRoZSBmcm9udFxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChfd2lkZ2V0ID0+IF93aWRnZXQgPT09IHdpZGdldCA/IF93aWRnZXQuYnJpbmdUb0Zyb250KCkgOiBfd2lkZ2V0LnNlbmRUb0JhY2soKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIHdpZGdldCBkb3duIC0gaWYgd2lkZ2V0cyBhcmUgaW4gdGhlIHBvc2l0aW9uIGJlbG93LCB0aGVuIG1vdmUgdGhlbSBkb3duIGZ1cnRoZXJcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gbW92ZSBkb3dud2FyZHNcbiAgICAgKi9cbiAgICBtb3ZlV2lkZ2V0RG93bih3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgZGlzdGFuY2U6IG51bWJlciA9IDEpOiB2b2lkIHtcblxuICAgICAgICAvLyBtb3ZlIHRoZSB3aWRnZXQgZG93biBvbmUgcG9zaXRpb25cbiAgICAgICAgd2lkZ2V0LnNldFJvdyh3aWRnZXQuZ2V0Um93KCkgKyBkaXN0YW5jZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgZXZlcnkgc3BhY2UgdGhlIHdpZGdldCBvY2N1cGllcyBmb3IgY29sbGlzaW9uc1xuICAgICAgICB0aGlzLmZvckVhY2hCbG9jayh3aWRnZXQsIChjb2x1bW4sIHJvdykgPT5cbiAgICAgICAgICAgIHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oY29sdW1uLCByb3csIHRydWUpXG4gICAgICAgICAgICAgICAgLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSB3aWRnZXQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2god2d0ID0+IHRoaXMubW92ZVdpZGdldERvd24od2d0LCBkaXN0YW5jZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaWRnZXRzIHNob3VsZCBub3QgYmUgYWxsb3dlZCB0byBoYXZlIGEgdmFjYW50IHNwYWNlIGFib3ZlIHRoZW0gLSBpZiB0aGVyZSBpcyBvbmUgdGhleSBzaG91bGQgbW92ZSB1cHdhcmRzIHRvIGZpbGwgaXRcbiAgICAgKi9cbiAgICBzaGlmdFdpZGdldHNVcCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIG9yIG5vdCBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIC0gaWYgc28gd2UgbmVlZCB0byByZXBlYXQgdW50aWwgc3RhYmxlXG4gICAgICAgIGxldCBzdGFibGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgZWFjaCB3aWRnZXQgYW5kXG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHdpZGdldCA9PiB7XG5cbiAgICAgICAgICAgIC8vIGlmIHdpZGdldCBpcyBhbHJlYWR5IG9uIHRoZSB0b3Agcm93IHRoZW4gZG8gbm90aGluZ1xuICAgICAgICAgICAgaWYgKHdpZGdldC5nZXRSb3coKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZyBhbmQgdGhpcyBpcyB0aGUgZHJhZ2dpbmcgd2lkZ2V0IHRoZW4gc2tpcFxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldCAmJiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0ID09PSB3aWRnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdldFBvc2l0aW9uQXZhaWxhYmxlKHdpZGdldC5nZXRDb2x1bW4oKSwgd2lkZ2V0LmdldFJvdygpIC0gMSwgd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgMSkpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Um93KHdpZGdldC5nZXRSb3coKSAtIDEpO1xuICAgICAgICAgICAgICAgIHN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBjaGFuZ2VzIG9jY3VycmVkIHRoZW4gd2Ugc2hvdWxkIHJlcGVhdCB0aGUgcHJvY2Vzc1xuICAgICAgICBpZiAoIXN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zaGlmdFdpZGdldHNVcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIGVhY2ggc3BhY2UgYSB3aWRnZXQgb2NjdXBpZWRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gZGV0ZXJtaW5lIHNwYWNlc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIHNwYWNlLCBzaG91bGQgZXhwZWN0IGEgY29sdW1uIGFuZCByb3cgYXJndW1lbnQgd2l0aHQgaGUgY29udGV4dCBiZWluZyB0aGUgd2lkZ2V0XG4gICAgICovXG4gICAgZm9yRWFjaEJsb2NrKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBjYWxsYmFjazogKGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBmb3IgKGxldCByb3cgPSB3aWRnZXQuZ2V0Um93KCk7IHJvdyA8IHdpZGdldC5nZXRSb3coKSArIHdpZGdldC5nZXRSb3dTcGFuKCk7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSB3aWRnZXQuZ2V0Q29sdW1uKCk7IGNvbHVtbiA8IHdpZGdldC5nZXRDb2x1bW4oKSArIHdpZGdldC5nZXRDb2x1bW5TcGFuKCk7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh3aWRnZXQsIGNvbHVtbiwgcm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrZWQgPyAxIDogdGhpcy5vcHRpb25zLmNvbHVtbnM7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdE9wdGlvbnM6IERhc2hib2FyZE9wdGlvbnMgPSB7IGNvbHVtbnM6IDUsIHBhZGRpbmc6IDUsIG1pbldpZHRoOiAxMDAsIG1pbkhlaWdodDogMTAwLCBlbXB0eVJvdzogdHJ1ZSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZERpbWVuc2lvbnMge1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGhlaWdodD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRXaWRnZXREaW1lbnNpb25zIHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkQWN0aW9uIHtcbiAgICB3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudDtcbiAgICBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbjtcbiAgICBldmVudDogTW91c2VFdmVudDtcbiAgICBoYW5kbGU/OiBIVE1MRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRTcGFjZSB7XG4gICAgd2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQ7XG4gICAgY29sdW1uOiBudW1iZXI7XG4gICAgcm93OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkUGxhY2Vob2xkZXIge1xuICAgIHZpc2libGU6IGJvb2xlYW47XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xuICAgIGNvbHVtbj86IG51bWJlcjtcbiAgICByb3c/OiBudW1iZXI7XG4gICAgY29sdW1uU3Bhbj86IG51bWJlcjtcbiAgICByb3dTcGFuPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZENhY2hlIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGNvbHVtbjogbnVtYmVyO1xuICAgIHJvdzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZExheW91dERhdGEge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgY29sOiBudW1iZXI7XG4gICAgcm93OiBudW1iZXI7XG4gICAgY29sU3BhbjogbnVtYmVyO1xuICAgIHJvd1NwYW46IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gQWN0aW9uRGlyZWN0aW9uIHtcbiAgICBUb3AgPSAwLFxuICAgIFRvcFJpZ2h0ID0gMSxcbiAgICBSaWdodCA9IDIsXG4gICAgQm90dG9tUmlnaHQgPSAzLFxuICAgIEJvdHRvbSA9IDQsXG4gICAgQm90dG9tTGVmdCA9IDUsXG4gICAgTGVmdCA9IDYsXG4gICAgVG9wTGVmdCA9IDcsXG4gICAgTW92ZSA9IDhcbn1cblxuZXhwb3J0IGVudW0gUm91bmRpbmcge1xuICAgIFJvdW5kRG93bixcbiAgICBSb3VuZERvd25CZWxvd0hhbGYsXG4gICAgUm91bmRVcCxcbiAgICBSb3VuZFVwT3ZlckhhbGZcbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplRGltZW5zaW9ucyB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5zZXJ2aWNlJztcbmltcG9ydCB7IERhc2hib2FyZExheW91dERhdGEsIERhc2hib2FyZFNlcnZpY2UsIGRlZmF1bHRPcHRpb25zIH0gZnJvbSAnLi9kYXNoYm9hcmQuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGFzaGJvYXJkJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgI2Rhc2hib2FyZCBjbGFzcz1cImRhc2hib2FyZC1jb250YWluZXJcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImRhc2hib2FyZFNlcnZpY2UuaGVpZ2h0JCB8IGFzeW5jXCI+XG4gICAgPGRpdiAodXhSZXNpemUpPVwib25SZXNpemUoJGV2ZW50KVwiIFt0aHJvdHRsZV09XCIxNlwiIGNsYXNzPVwiZGFzaGJvYXJkXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwicG9zaXRpb24taW5kaWNhdG9yXCIgKm5nSWY9XCIoZGFzaGJvYXJkU2VydmljZS5wbGFjZWhvbGRlciQgfCBhc3luYykudmlzaWJsZVwiIFxuICAgICAgICBbc3R5bGUubGVmdC5weF09XCIoZGFzaGJvYXJkU2VydmljZS5wbGFjZWhvbGRlciQgfCBhc3luYykueFwiIFxuICAgICAgICBbc3R5bGUudG9wLnB4XT1cIihkYXNoYm9hcmRTZXJ2aWNlLnBsYWNlaG9sZGVyJCB8IGFzeW5jKS55XCIgXG4gICAgICAgIFtzdHlsZS53aWR0aC5weF09XCIoZGFzaGJvYXJkU2VydmljZS5wbGFjZWhvbGRlciQgfCBhc3luYykud2lkdGhcIlxuICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT1cIihkYXNoYm9hcmRTZXJ2aWNlLnBsYWNlaG9sZGVyJCB8IGFzeW5jKS5oZWlnaHRcIj48L2Rpdj5cbjwvZGl2PmAsXG4gICAgcHJvdmlkZXJzOiBbRGFzaGJvYXJkU2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBASW5wdXQoKSBzZXQgbGF5b3V0KGxheW91dDogRGFzaGJvYXJkTGF5b3V0RGF0YVtdKSB7XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5sYXlvdXQkLm5leHQobGF5b3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBJbnB1dCgpIHNldCBvcHRpb25zKG9wdGlvbnM6IERhc2hib2FyZE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9wdGlvbnMkLm5leHQoeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgbGF5b3V0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXNoYm9hcmRMYXlvdXREYXRhW10+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdkYXNoYm9hcmQnKSBkYXNoYm9hcmRFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhc2hib2FyZFNlcnZpY2U6IERhc2hib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgZGFzaGJvYXJkU2VydmljZS5sYXlvdXQkLnN1YnNjcmliZShsYXlvdXQgPT4gdGhpcy5sYXlvdXRDaGFuZ2UuZW1pdChsYXlvdXQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGluaXRpYWwgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnNldERpbWVuc2lvbnModGhpcy5kYXNoYm9hcmRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgsIHRoaXMuZGFzaGJvYXJkRWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCk7XG4gICAgfVxuXG4gICAgb25SZXNpemUoZXZlbnQ6IFJlc2l6ZURpbWVuc2lvbnMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnNldERpbWVuc2lvbnMoZXZlbnQud2lkdGgsIGV2ZW50LmhlaWdodCk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZE9wdGlvbnMge1xuICAgIGNvbHVtbnM/OiBudW1iZXI7XG4gICAgcGFkZGluZz86IG51bWJlcjtcbiAgICBtaW5XaWR0aD86IG51bWJlcjtcbiAgICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gICAgcm93SGVpZ2h0PzogbnVtYmVyO1xuICAgIGVtcHR5Um93PzogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSwgSG9zdEJpbmRpbmcsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhc2hib2FyZFNlcnZpY2UsIEFjdGlvbkRpcmVjdGlvbiB9IGZyb20gJy4uL2Rhc2hib2FyZC5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXNoYm9hcmQtd2lkZ2V0JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3aWRnZXQtY29udGVudCB3aWRnZXQtY29sLXNwYW4te3sgZ2V0Q29sdW1uU3BhbigpIH19IHdpZGdldC1yb3ctc3Bhbi17eyBnZXRSb3dTcGFuKCkgfX1cIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cblxuPGRpdiB1eERyYWcgI2hhbmRsZVRvcCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS10b3BcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVUb3AsICRldmVudCwgMClcIlxuICAgIChkcmFnKT1cImRyYWcoaGFuZGxlVG9wLCAkZXZlbnQsIDApXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS50b3AucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVUb3BSaWdodCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS10b3AtcmlnaHRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVUb3BSaWdodCwgJGV2ZW50LCAxKVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVUb3BSaWdodCwgJGV2ZW50LCAxKVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUudG9wLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbc3R5bGUucmlnaHQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSAmJiAhKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlUmlnaHQgY2xhc3M9XCJyZXNpemVyLWhhbmRsZSBoYW5kbGUtcmlnaHRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVSaWdodCwgJGV2ZW50LCAyKVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVSaWdodCwgJGV2ZW50LCAyKVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUucmlnaHQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSB8fCAoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVCb3R0b21SaWdodCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS1ib3R0b20tcmlnaHRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVCb3R0b21SaWdodCwgJGV2ZW50LCAzKVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVCb3R0b21SaWdodCwgJGV2ZW50LCAzKVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUuYm90dG9tLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbc3R5bGUucmlnaHQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSAmJiAhKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlQm90dG9tIGNsYXNzPVwicmVzaXplci1oYW5kbGUgaGFuZGxlLWJvdHRvbVwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZUJvdHRvbSwgJGV2ZW50LCA0KVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVCb3R0b20sICRldmVudCwgNClcIlxuICAgIChkcmFnZW5kKT1cImRyYWdlbmQoKVwiXG4gICAgW3N0eWxlLmJvdHRvbS5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlXCI+XG48L2Rpdj5cblxuPGRpdiB1eERyYWcgI2hhbmRsZUJvdHRvbUxlZnQgY2xhc3M9XCJyZXNpemVyLWhhbmRsZSBoYW5kbGUtYm90dG9tLWxlZnRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVCb3R0b21MZWZ0LCAkZXZlbnQsIDUpXCJcbiAgICAoZHJhZyk9XCJkcmFnKGhhbmRsZUJvdHRvbUxlZnQsICRldmVudCwgNSlcIlxuICAgIChkcmFnZW5kKT1cImRyYWdlbmQoKVwiXG4gICAgW3N0eWxlLmJvdHRvbS5weF09XCJwYWRkaW5nXCIgXG4gICAgW3N0eWxlLmxlZnQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSAmJiAhKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlTGVmdCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS1sZWZ0XCIgXG4gICAgKGRyYWdzdGFydCk9XCJkcmFnc3RhcnQoaGFuZGxlTGVmdCwgJGV2ZW50LCA2KVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVMZWZ0LCAkZXZlbnQsIDYpXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS5sZWZ0LnB4XT1cInBhZGRpbmdcIiBcbiAgICBbaGlkZGVuXT1cIiFyZXNpemFibGUgfHwgKGRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCQgfCBhc3luYylcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlVG9wTGVmdCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS10b3AtbGVmdFwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZVRvcExlZnQsICRldmVudCwgNylcIlxuICAgIChkcmFnKT1cImRyYWcoaGFuZGxlVG9wTGVmdCwgJGV2ZW50LCA3KVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUudG9wLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbc3R5bGUubGVmdC5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlICYmICEoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNvbDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIHJvdzogbnVtYmVyO1xuICAgIEBJbnB1dCgpIGNvbFNwYW46IG51bWJlciA9IDE7XG4gICAgQElucHV0KCkgcm93U3BhbjogbnVtYmVyID0gMTtcbiAgICBASW5wdXQoKSByZXNpemFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBIb3N0QmluZGluZygnc3R5bGUubGVmdC5weCcpIHg6IG51bWJlciA9IDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS50b3AucHgnKSB5OiBudW1iZXIgPSAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUud2lkdGgucHgnKSB3aWR0aDogbnVtYmVyID0gMTAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuaGVpZ2h0LnB4JykgaGVpZ2h0OiBudW1iZXIgPSAxMDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5wYWRkaW5nLnB4JykgcGFkZGluZzogbnVtYmVyID0gMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnotaW5kZXgnKSB6SW5kZXg6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIF9jb2x1bW46IFN0YWNrYWJsZVZhbHVlID0geyByZWd1bGFyOiB1bmRlZmluZWQsIHN0YWNrZWQ6IHVuZGVmaW5lZCB9O1xuICAgIHByaXZhdGUgX3JvdzogU3RhY2thYmxlVmFsdWUgPSB7IHJlZ3VsYXI6IHVuZGVmaW5lZCwgc3RhY2tlZDogdW5kZWZpbmVkIH07XG4gICAgcHJpdmF0ZSBfY29sdW1uU3BhbjogU3RhY2thYmxlVmFsdWUgPSB7IHJlZ3VsYXI6IDEsIHN0YWNrZWQ6IDEgfTtcbiAgICBwcml2YXRlIF9yb3dTcGFuOiBTdGFja2FibGVWYWx1ZSA9IHsgcmVndWxhcjogMSwgc3RhY2tlZDogMSB9O1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhc2hib2FyZFNlcnZpY2U6IERhc2hib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gZGFzaGJvYXJkU2VydmljZS5vcHRpb25zJC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGUoKSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5fY29sdW1uU3Bhbi5yZWd1bGFyID0gdGhpcy5jb2xTcGFuO1xuICAgICAgICB0aGlzLl9yb3dTcGFuLnJlZ3VsYXIgPSB0aGlzLnJvd1NwYW47XG5cbiAgICAgICAgaWYgKCF0aGlzLmlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rhc2hib2FyZCBXaWRnZXQgaXMgbWlzc2luZyBhbiBJRC4nKTtcblxuICAgICAgICAgICAgLy8gc2V0IHJhbmRvbSBpZCAtIGtlZXBzIHRoaW5ncyB3b3JraW5nIGJ1dCBwcmV2ZW50cyBleHBvcnRpbmcgb2YgcG9zaXRpb25zXG4gICAgICAgICAgICB0aGlzLmlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICAvLyBhZGQgdGhlIHdpZGdldCB0byB0aGUgZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5hZGRXaWRnZXQodGhpcyk7XG5cbiAgICAgICAgLy8gYXBwbHkgdGhlIGN1cnJlbnQgb3B0aW9uc1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGNvbXBvbmVudCBpcyByZW1vdmVkLCB0aGVuIHVucmVnaXN0ZXIgaXQgZnJvbSB0aGUgc2VydmljZVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnJlbW92ZVdpZGdldCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgY3VycmVudCBkYXNoYm9hcmQgb3B0aW9uc1xuICAgICAqL1xuICAgIHVwZGF0ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgb3B0aW9ucyBhdCB0aGUgdGltZSBcbiAgICAgICAgY29uc3QgeyBwYWRkaW5nLCBjb2x1bW5zIH0gPSB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub3B0aW9ucztcblxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICB0aGlzLl9jb2x1bW5TcGFuLnN0YWNrZWQgPSBjb2x1bW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYWN0dWFsIHBvc2l0aW9uIGFuZCBzaXplIHZhbHVlc1xuICAgICAqL1xuICAgIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy54ID0gdGhpcy5nZXRDb2x1bW4oKSAqIHRoaXMuZGFzaGJvYXJkU2VydmljZS5nZXRDb2x1bW5XaWR0aCgpO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLmdldFJvdygpICogdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmdldFJvd0hlaWdodCgpO1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5nZXRDb2x1bW5TcGFuKCkgKiB0aGlzLmRhc2hib2FyZFNlcnZpY2UuZ2V0Q29sdW1uV2lkdGgoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmdldFJvd1NwYW4oKSAqIHRoaXMuZGFzaGJvYXJkU2VydmljZS5nZXRSb3dIZWlnaHQoKTtcbiAgICB9XG5cbiAgICBnZXRDb2x1bW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2thYmxlVmFsdWUodGhpcy5fY29sdW1uKTtcbiAgICB9XG5cbiAgICBnZXRSb3coKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93KTtcbiAgICB9XG5cbiAgICBzZXRDb2x1bW4oY29sdW1uOiBudW1iZXIsIHJlbmRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW4sIGNvbHVtbik7XG5cbiAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJvdyhyb3c6IG51bWJlciwgcmVuZGVyOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFN0YWNrYWJsZVZhbHVlKHRoaXMuX3Jvdywgcm93KTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1uU3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW5TcGFuKTtcbiAgICB9XG5cbiAgICBnZXRSb3dTcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrYWJsZVZhbHVlKHRoaXMuX3Jvd1NwYW4pO1xuICAgIH1cblxuICAgIHNldENvbHVtblNwYW4oY29sdW1uU3BhbjogbnVtYmVyLCByZW5kZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhY2thYmxlVmFsdWUodGhpcy5fY29sdW1uU3BhbiwgY29sdW1uU3Bhbik7XG5cbiAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJvd1NwYW4ocm93U3BhbjogbnVtYmVyLCByZW5kZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93U3Bhbiwgcm93U3Bhbik7XG5cbiAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJyaW5nVG9Gcm9udCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy56SW5kZXggPSAxO1xuICAgIH1cblxuICAgIHNlbmRUb0JhY2soKTogdm9pZCB7XG4gICAgICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBzZXRCb3VuZHMoeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgZHJhZ3N0YXJ0KGhhbmRsZTogSFRNTEVsZW1lbnQsIGV2ZW50OiBNb3VzZUV2ZW50LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub25SZXNpemVTdGFydCh7IHdpZGdldDogdGhpcywgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGV2ZW50OiBldmVudCwgaGFuZGxlOiBoYW5kbGUgfSk7XG4gICAgfVxuXG4gICAgZHJhZyhoYW5kbGU6IEhUTUxFbGVtZW50LCBldmVudDogTW91c2VFdmVudCwgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9uUmVzaXplRHJhZyh7IHdpZGdldDogdGhpcywgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGV2ZW50OiBldmVudCwgaGFuZGxlOiBoYW5kbGUgfSk7XG4gICAgfVxuXG4gICAgZHJhZ2VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9uUmVzaXplRW5kKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGF1dG9tYXRpYyBzZXR0aW5nIG9mIHN0YWNrYWJsZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBUaGUgY3VycmVudCBTdGFja2FibGVWYWx1ZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBpbiB0aGUgYXBwcm9wcmlhdGUgZmllbGRcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFN0YWNrYWJsZVZhbHVlKHByb3BlcnR5OiBTdGFja2FibGVWYWx1ZSwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCkge1xuICAgICAgICAgICAgcHJvcGVydHkuc3RhY2tlZCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydHkucmVndWxhciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZSBmcm9tIGEgc3RhY2thYmxlIHZhbHVlXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBTdGFja2FibGUgdmFsdWUgb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTdGFja2FibGVWYWx1ZShwcm9wZXJ0eTogU3RhY2thYmxlVmFsdWUpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnN0YWNrZWQgPyBwcm9wZXJ0eS5zdGFja2VkIDogcHJvcGVydHkucmVndWxhcjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2thYmxlVmFsdWUge1xuICAgIHJlZ3VsYXI6IG51bWJlcjtcbiAgICBzdGFja2VkOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4RHJhZ10nXG59KVxuZXhwb3J0IGNsYXNzIERyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIERldGVtaW5lIGlmIHdlIHNob3VsZCBzaG93IGEgY2xvbmUgd2hlbiBkcmFnZ2luZyAqL1xuICAgIEBJbnB1dCgpIGNsb25lOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIGRyYWdnaW5nIHN0YXJ0cyAqL1xuICAgIEBPdXRwdXQoKSBkcmFnc3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyB3aGlsZSBkcmFnZ2luZyAqL1xuICAgIEBPdXRwdXQoKSBkcmFnID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqIEVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgZHJhZ2dpbmcgZmluaXNoZXMgKi9cbiAgICBAT3V0cHV0KCkgZHJhZ2VuZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBTdG9yZSB0aGUgZWxlbWVudCB3ZSBoYXZlIGNsb25lZCAqL1xuICAgIHByaXZhdGUgX2Nsb25lOiBFbGVtZW50O1xuXG4gICAgLyoqIFN0b3JlIHRoZSBtb3VzZSBvZmZzZXQgZm9yIHRoZSBjbG9uZWQgZWxlbWVudCBwb3NpdGlvbiAqL1xuICAgIHByaXZhdGUgX29mZnNldDogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9O1xuXG4gICAgLyoqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIGZyb20gdGhlIG1vdXNlIGRvd24gZXZlbnQgKi9cbiAgICBwcml2YXRlIF9tb3VzZWRvd24kID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicpO1xuXG4gICAgLyoqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIGZyb20gdGhlIG1vdXNlIG1vdmUgZXZlbnQgKi9cbiAgICBwcml2YXRlIF9tb3VzZW1vdmUkID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KGRvY3VtZW50LCAnbW91c2Vtb3ZlJyk7XG5cbiAgICAvKiogQ3JlYXRlIGFuIG9ic2VydmFibGUgZnJvbSB0aGUgbW91c2UgdXAgZXZlbnQgKi9cbiAgICBwcml2YXRlIF9tb3VzZXVwJCA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pihkb2N1bWVudCwgJ21vdXNldXAnKTtcblxuICAgIC8qKiBVc2UgYW4gb2JzZXJ2YWJsZSB0byB1bnN1YnNjcmliZSBmcm9tIGFsbCBzdWJzY3JpcHRpb25zICovXG4gICAgcHJvdGVjdGVkIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICAgICAgdGhpcy5fbW91c2Vkb3duJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5kcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgZXZlbnRzIGFuZCBjcmVhdGUgY2xvbmUgd2hlbiBkcmFnIHN0YXJ0cyAqL1xuICAgIGRyYWdTdGFydChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNsb25lKSB7XG4gICAgICAgICAgICAvLyBjbG9uZSB0aGUgbm9kZVxuICAgICAgICAgICAgdGhpcy5jbG9uZU5vZGUoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYSBjbGFzcyB0byB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWRyYWctZHJhZ2dpbmcnKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5kcmFnc3RhcnQuZW1pdChldmVudCkpO1xuXG4gICAgICAgIHRoaXMuX21vdXNlbW92ZSQucGlwZSh0YWtlVW50aWwodGhpcy5fbW91c2V1cCQpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5kcmFnTW92ZS5iaW5kKHRoaXMpLCBudWxsLCB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgZXZlbnQgYW5kIHVwZGF0ZSBjbG9uZSBwb3NpdGlvbiB3aGVuIGRyYWdnaW5nIG1vdmVzICovXG4gICAgZHJhZ01vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAodGhpcy5fY2xvbmUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZVBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLmRyYWcuZW1pdChldmVudCkpO1xuICAgIH1cblxuICAgIC8qKiBFbWl0IGV2ZW50IGFuZCBkZXN0cm95IGNsb25lIHdoZW4gZHJhZ2dpbmcgZW5kcyAqL1xuICAgIGRyYWdFbmQoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIGNsb25lLCByZW1vdmUgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Nsb25lKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDaGlsZChkb2N1bWVudC5ib2R5LCB0aGlzLl9jbG9uZSk7XG4gICAgICAgICAgICB0aGlzLl9jbG9uZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIGRyYWdnaW5nIGNsYXNzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWRyYWctZHJhZ2dpbmcnKTtcblxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuZHJhZ2VuZC5lbWl0KCkpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW4gZXhhY3QgY2xvbmUgb2YgYW4gZWxlbWVudCAqL1xuICAgIGNsb25lTm9kZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGR1cGxpY2F0ZSB0aGUgbm9kZVxuICAgICAgICB0aGlzLl9jbG9uZSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0geyB4OiBldmVudC5jbGllbnRYIC0gbGVmdCwgeTogZXZlbnQuY2xpZW50WSAtIHRvcCB9O1xuXG4gICAgICAgIC8vIGlubGluZSBhbGwgc3R5bGVzIHNvIGl0IGxvb2tzIGlkZW50aWNhbCByZWdhcmRsZXNzIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgRE9NXG4gICAgICAgIHRoaXMuaW5saW5lU3R5bGVzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fY2xvbmUpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBjYW4gZWFzaWx5IHBvc2l0aW9uIHRoZSBub2RlIGFuIGl0IGlzIGFib3ZlIGFsbCBvdGhlciBlbGVtZW50c1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fY2xvbmUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2Nsb25lLCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICd6LWluZGV4JywgJzk5OTk5Jyk7XG5cbiAgICAgICAgLy8gYXBwbHkgYSBjbGFzcyB0byBhbGxvdyBjdXN0b20gc3R5bGluZ1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9jbG9uZSwgJ3V4LWRyYWctZHJhZ2dpbmctY2xvbmUnKTtcblxuICAgICAgICAvLyBpbnNlcnQgdGhlIGNsb25lZCBlbGVtZW50XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmJvZHksIHRoaXMuX2Nsb25lKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGNsb25lZCBlbGVtZW50IGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVOb2RlUG9zaXRpb24oZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKiBQb3NpdGlvbiB0aGUgY2xvbmUgcmVsYXRpdmUgdG8gdGhlIG1vdXNlICovXG4gICAgdXBkYXRlTm9kZVBvc2l0aW9uKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2Nsb25lLCAnbGVmdCcsIChldmVudC5wYWdlWCAtIHRoaXMuX29mZnNldC54KSArICdweCcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9jbG9uZSwgJ3RvcCcsIChldmVudC5wYWdlWSAtIHRoaXMuX29mZnNldC55KSArICdweCcpO1xuICAgIH1cblxuICAgIC8qKiBJbmxpbmUgYWxsIHN0eWxlcyB0byBlbnN1cmUgc3R5bGluZyBpcyBjb25zaXN0ZW50IHJlZ2FyZGxlc3Mgb2YgaXRzIHBvc2l0aW9uIGluIHRoZSBkb20gKi9cbiAgICBpbmxpbmVTdHlsZXMoc291cmNlOiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gZ2V0IGFsbCB0aGUgY29tcHV0ZWQgc3R5bGVzIGZyb20gdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc291cmNlKTtcblxuICAgICAgICAvLyBpbmxpbmUgZXZlcnkgc3BlY2lmaWVkIHN0eWxlXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHN0eWxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlcy5pdGVtKGlkeCk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGFyZ2V0LCBzdHlsZXNbaWR4XSwgc3R5bGVzW3N0eWxlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgd2UgZG9udCBjYXB0dXJlIGFueSBtb3ZlIGV2ZW50c1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0YXJnZXQsICdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cbiAgICAgICAgLy8gZG8gdGhlIHNhbWUgZm9yIGFsbCB0aGUgY2hpbGQgZWxlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lU3R5bGVzKHNvdXJjZS5jaGlsZHJlbltpZHhdLCB0YXJnZXQuY2hpbGRyZW5baWR4XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVW5zdWJzY3JpYmUgZnJvbSBhbGwgc3Vic2NyaXB0aW9ucyAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBOZ1pvbmUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRHJhZ0RpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy9kcmFnLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBBY3Rpb25EaXJlY3Rpb24sIERhc2hib2FyZFNlcnZpY2UgfSBmcm9tICcuLi9kYXNoYm9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgfSBmcm9tICcuLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eERhc2hib2FyZFdpZGdldERyYWdIYW5kbGVdLCBbdXgtZGFzaGJvYXJkLXdpZGdldC1kcmFnLWhhbmRsZV0nXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZERyYWdIYW5kbGVEaXJlY3RpdmUgZXh0ZW5kcyBEcmFnRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBkYXNoYm9hcmRTZXJ2aWNlOiBEYXNoYm9hcmRTZXJ2aWNlLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBuZ1pvbmU6IE5nWm9uZSwgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgICAgICBzdXBlcihlbGVtZW50UmVmLCBuZ1pvbmUsIHJlbmRlcmVyKTtcblxuICAgICAgICB0aGlzLmRyYWdzdGFydC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IGRhc2hib2FyZFNlcnZpY2Uub25EcmFnU3RhcnQoeyB3aWRnZXQ6IHdpZGdldCwgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24uTW92ZSwgZXZlbnQ6IGV2ZW50IH0pKTtcblxuICAgICAgICB0aGlzLmRyYWcucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiBkYXNoYm9hcmRTZXJ2aWNlLm9uRHJhZyh7IHdpZGdldDogd2lkZ2V0LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbi5Nb3ZlLCBldmVudDogZXZlbnQgfSkpO1xuXG4gICAgICAgIHRoaXMuZHJhZ2VuZC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiBkYXNoYm9hcmRTZXJ2aWNlLm9uRHJhZ0VuZCgpKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHJhZ0RpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZy5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtEcmFnRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtEcmFnRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBEcmFnTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBEYXNoYm9hcmRDb21wb25lbnQgfSBmcm9tICcuL2Rhc2hib2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50IH0gZnJvbSAnLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkU2VydmljZSB9IGZyb20gJy4vZGFzaGJvYXJkLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGFzaGJvYXJkRHJhZ0hhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZy1oYW5kbGUvZHJhZy1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlM6IGFueVtdID0gW1xuICAgIERhc2hib2FyZENvbXBvbmVudCxcbiAgICBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsXG4gICAgRGFzaGJvYXJkRHJhZ0hhbmRsZURpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUmVzaXplTW9kdWxlLFxuICAgICAgICBEcmFnTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgcHJvdmlkZXJzOiBbRGFzaGJvYXJkU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0VuY2Fwc3VsYXRpb24sIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFNQSU5fQlVUVE9OX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU3BpbkJ1dHRvbkNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc3Bpbi1idXR0b24nLFxuICAgIHRlbXBsYXRlOiBgPGJ1dHRvbiBjbGFzcz1cInNwaW4tYnV0dG9uXCJcbiAgICAgICAgKm5nSWY9XCJzcGlubmVyc1wiXG4gICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImluY3JlbWVudEFyaWFMYWJlbFwiXG4gICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAoY2xpY2spPVwidHJpZ2dlckluY3JlbWVudCgpXCI+XG5cbiAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtdXBcIj48L3NwYW4+XG48L2J1dHRvbj5cblxuPGlucHV0IFt0eXBlXT1cInR5cGVcIlxuICAgICAgIHJvbGU9XCJzcGluYnV0dG9uXCJcbiAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgW21heF09XCJtYXhcIlxuICAgICAgIFt0YWJpbmRleF09XCIwXCJcbiAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICBbcmVhZE9ubHldPVwicmVhZE9ubHlcIlxuICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJpbnB1dEFyaWFMYWJlbFwiXG4gICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJtaW5cIlxuICAgICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwidmFsdWVcIlxuICAgICAgIFthdHRyLmFyaWEtdmFsdWVtYXhdPVwibWF4XCJcbiAgICAgICBbYXR0ci5hcmlhLXJlYWRvbmx5XT1cInJlYWRPbmx5XCJcbiAgICAgICBbbmdNb2RlbF09XCJ2YWx1ZVwiXG4gICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwidmFsdWVDaGFuZ2UuZW1pdCgkZXZlbnQpXCJcbiAgICAgICAod2hlZWwpPVwic2Nyb2xsKCRldmVudClcIlxuICAgICAgIChrZXlkb3duLmFycm93dXApPVwiYXJyb3drZXlzID8gdHJpZ2dlckluY3JlbWVudCgpIDogbnVsbDsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgIChrZXlkb3duLmFycm93ZG93bik9XCJhcnJvd2tleXMgPyB0cmlnZ2VyRGVjcmVtZW50KCkgOiBudWxsOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG48YnV0dG9uIGNsYXNzPVwic3Bpbi1idXR0b25cIlxuICAgICAgICAqbmdJZj1cInNwaW5uZXJzXCJcbiAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiZGVjcmVtZW50QXJpYUxhYmVsXCJcbiAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIChjbGljayk9XCJ0cmlnZ2VyRGVjcmVtZW50KClcIj5cblxuICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1kb3duXCI+PC9zcGFuPlxuPC9idXR0b24+YCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1NQSU5fQlVUVE9OX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBTcGluQnV0dG9uQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgQElucHV0KCkgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KCkgdHlwZTogc3RyaW5nID0gJ3RleHQnO1xuICAgIEBJbnB1dCgpIG1pbjogbnVtYmVyO1xuICAgIEBJbnB1dCgpIG1heDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIHBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnJztcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNwaW5uZXJzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSByZWFkT25seTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2Nyb2xsaW5nOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBhcnJvd2tleXM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KCkgaW5jcmVtZW50QXJpYUxhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaW5wdXRBcmlhTGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSBkZWNyZW1lbnRBcmlhTGFiZWw6IHN0cmluZztcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgQE91dHB1dCgpIGluY3JlbWVudCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgZGVjcmVtZW50ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnk7XG5cbiAgICBzY3JvbGwoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVsdGFZID4gMCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRGVjcmVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJJbmNyZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdHJpZ2dlckluY3JlbWVudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmlnZ2VyRGVjcmVtZW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50LmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTcGluQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9zcGluLWJ1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1NwaW5CdXR0b25Db21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NwaW5CdXR0b25Db21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFNwaW5CdXR0b25Nb2R1bGUgeyB9IiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gIG5hbWU6ICd0aW1lRm9ybWF0J1xufSlcbmV4cG9ydCBjbGFzcyBUaW1lRm9ybWF0UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gIHRyYW5zZm9ybSh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gdmFsdWUgPCAxMCA/ICcwJyArIHZhbHVlIDogdmFsdWU7XG4gIH1cblxufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgY29uc3QgVElNRV9QSUNLRVJfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUaW1lUGlja2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10aW1lLXBpY2tlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidGltZS1waWNrZXJcIiBhcmlhLWxhYmVsPVwiVGltZSBwaWNrZXJcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1jb2x1bW5cIiBbY2xhc3MuaGFzLWVycm9yXT1cIiEodmFsaWQkIHwgYXN5bmMpXCIgKm5nSWY9XCJzaG93SG91cnNcIj5cblxuICAgICAgICA8dXgtc3Bpbi1idXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgY2xhc3M9XCJ0aW1lLXNwaW5uZXJcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJISFwiXG4gICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgW21heF09XCJzaG93TWVyaWRpYW4gPyAxMiA6IDIzXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJob3VyJCB8IGFzeW5jIHwgdGltZUZvcm1hdFwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaG91ckNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIFtzcGlubmVyc109XCJzaG93U3Bpbm5lcnNcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkT25seV09XCJyZWFkT25seVwiXG4gICAgICAgICAgICBpbnB1dEFyaWFMYWJlbD1cImhvdXJcIlxuICAgICAgICAgICAgaW5jcmVtZW50QXJpYUxhYmVsPVwiSW5jcmVtZW50IHRoZSBob3VyXCJcbiAgICAgICAgICAgIGRlY3JlbWVudEFyaWFMYWJlbD1cIkRlY3JlbWVudCB0aGUgaG91clwiXG4gICAgICAgICAgICAoaW5jcmVtZW50KT1cImluY3JlbWVudEhvdXIoKVwiXG4gICAgICAgICAgICAoZGVjcmVtZW50KT1cImRlY3JlbWVudEhvdXIoKVwiPlxuICAgICAgICA8L3V4LXNwaW4tYnV0dG9uPlxuXG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidGltZS1waWNrZXItc2VwYXJhdG9yXCIgKm5nSWY9XCJzaG93TWludXRlc1wiPjo8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1jb2x1bW5cIiBbY2xhc3MuaGFzLWVycm9yXT1cIiEodmFsaWQkIHwgYXN5bmMpXCIgKm5nSWY9XCJzaG93TWludXRlc1wiPlxuXG4gICAgICAgIDx1eC1zcGluLWJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICBjbGFzcz1cInRpbWUtc3Bpbm5lclwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIk1NXCJcbiAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICBbbWF4XT1cIjU5XCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJtaW51dGUkIHwgYXN5bmMgfCB0aW1lRm9ybWF0XCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJtaW51dGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbc3Bpbm5lcnNdPVwic2hvd1NwaW5uZXJzXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbcmVhZE9ubHldPVwicmVhZE9ubHlcIlxuICAgICAgICAgICAgaW5wdXRBcmlhTGFiZWw9XCJtaW51dGVcIlxuICAgICAgICAgICAgaW5jcmVtZW50QXJpYUxhYmVsPVwiSW5jcmVtZW50IHRoZSBtaW51dGVcIlxuICAgICAgICAgICAgZGVjcmVtZW50QXJpYUxhYmVsPVwiRGVjcmVtZW50IHRoZSBtaW51dGVcIlxuICAgICAgICAgICAgKGluY3JlbWVudCk9XCJpbmNyZW1lbnRNaW51dGUoKVwiXG4gICAgICAgICAgICAoZGVjcmVtZW50KT1cImRlY3JlbWVudE1pbnV0ZSgpXCI+XG4gICAgICAgIDwvdXgtc3Bpbi1idXR0b24+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1zZXBhcmF0b3JcIiAqbmdJZj1cInNob3dTZWNvbmRzXCI+OjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtcGlja2VyLWNvbHVtblwiIFtjbGFzcy5oYXMtZXJyb3JdPVwiISh2YWxpZCQgfCBhc3luYylcIiAqbmdJZj1cInNob3dTZWNvbmRzXCI+XG5cbiAgICAgICAgPHV4LXNwaW4tYnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgIGNsYXNzPVwidGltZS1zcGlubmVyXCJcbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJTU1wiXG4gICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgW21heF09XCI1OVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwic2Vjb25kJCB8IGFzeW5jIHwgdGltZUZvcm1hdFwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwic2Vjb25kQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW3NwaW5uZXJzXT1cInNob3dTcGlubmVyc1wiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRPbmx5XT1cInJlYWRPbmx5XCJcbiAgICAgICAgICAgIGlucHV0QXJpYUxhYmVsPVwic2Vjb25kc1wiXG4gICAgICAgICAgICBpbmNyZW1lbnRBcmlhTGFiZWw9XCJJbmNyZW1lbnQgdGhlIHNlY29uZFwiXG4gICAgICAgICAgICBkZWNyZW1lbnRBcmlhTGFiZWw9XCJEZWNyZW1lbnQgdGhlIHNlY29uZFwiXG4gICAgICAgICAgICAoaW5jcmVtZW50KT1cImluY3JlbWVudFNlY29uZCgpXCJcbiAgICAgICAgICAgIChkZWNyZW1lbnQpPVwiZGVjcmVtZW50U2Vjb25kKClcIj5cbiAgICAgICAgPC91eC1zcGluLWJ1dHRvbj5cblxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1tZXJpZGlhblwiICpuZ0lmPVwic2hvd01lcmlkaWFuXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCIgcm9sZT1cInJhZGlvZ3JvdXBcIj5cblxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ1dHRvbi10b2dnbGUtYWNjZW50XCJcbiAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgbWVyaWRpYW4gb2YgbWVyaWRpYW5zXCJcbiAgICAgICAgICAgICAgICByb2xlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0TWVyaWRpYW4obWVyaWRpYW4pXCJcbiAgICAgICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cIm1lcmlkaWFuID09PSAobWVyaWRpYW4kIHwgYXN5bmMpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm1lcmlkaWFuXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWNoZWNrZWRdPVwibWVyaWRpYW4gPT09IChtZXJpZGlhbiQgfCBhc3luYylcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICAgICAgICAgICB7eyBtZXJpZGlhbiB9fVxuICAgICAgICA8L2J1dHRvbj5cblxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1RJTUVfUElDS0VSX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdhcmlhLWxhYmVsJzogJ1RpbWUgUGlja2VyJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVGltZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgYXJyb3drZXlzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBtb3VzZXdoZWVsOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHJlYWRPbmx5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBzaG93TWVyaWRpYW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzaG93SG91cnM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNob3dNaW51dGVzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzaG93U2Vjb25kczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNob3dTcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBASW5wdXQoKSBob3VyU3RlcDogbnVtYmVyID0gMTtcbiAgICBASW5wdXQoKSBtaW51dGVTdGVwOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIHNlY29uZFN0ZXA6IG51bWJlciA9IDE7XG5cbiAgICBASW5wdXQoKSBtaW46IERhdGU7XG4gICAgQElucHV0KCkgbWF4OiBEYXRlO1xuICAgIEBJbnB1dCgpIG1lcmlkaWFuczogc3RyaW5nW10gPSBbJ0FNJywgJ1BNJ107XG5cbiAgICBASW5wdXQoKSBzZXQgdmFsdWUodmFsdWU6IERhdGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSQubmV4dChuZXcgRGF0ZSh2YWx1ZSkpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSQudmFsdWUpO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLnZhbHVlJC52YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlJC52YWx1ZSk7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuICAgIEBPdXRwdXQoKSBpc1ZhbGlkID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IERhdGUpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB2YWx1ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuXG4gICAgLy8gY3JlYXRlIG9ic2VydmFibGVzIHRoYXQgYXJlIGRlcml2ZWQgZnJvbSB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgaG91ciQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMudmFsdWUkLnBpcGUobWFwKGRhdGUgPT4gZGF0ZS5nZXRIb3VycygpKSwgbWFwKGhvdXIgPT4gdGhpcy5zaG93TWVyaWRpYW4gPyB0aGlzLmdldE1lcmlkaWFuVGltZShob3VyKSA6IGhvdXIpKTtcbiAgICBtaW51dGUkOiBPYnNlcnZhYmxlPG51bWJlcj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IGRhdGUuZ2V0TWludXRlcygpKSk7XG4gICAgc2Vjb25kJDogT2JzZXJ2YWJsZTxudW1iZXI+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldFNlY29uZHMoKSkpO1xuICAgIG1lcmlkaWFuJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IHRoaXMubWVyaWRpYW5zWzBdIDogdGhpcy5tZXJpZGlhbnNbMV0pKTtcbiAgICB2YWxpZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IHRoaXMuY2hlY2tWYWxpZGl0eShkYXRlKSkpO1xuXG4gICAgcHJpdmF0ZSBfbWVyaWRpYW46IHN0cmluZyA9IHRoaXMubWVyaWRpYW5zWzBdO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMudmFsaWQkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHZhbGlkID0+IHRoaXMuaXNWYWxpZC5lbWl0KHZhbGlkKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IERhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IChfOiBEYXRlKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgZ2V0TWVyaWRpYW5UaW1lKGhvdXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBob3VyID4gMTIgPyBob3VyIC0gMTIgOiBob3VyO1xuICAgIH1cblxuICAgIHNldEhvdXIoaG91cjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBkYXRlLnNldEhvdXJzKGhvdXIgPyBob3VyIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgc2V0TWludXRlKG1pbnV0ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBkYXRlLnNldE1pbnV0ZXMobWludXRlID8gbWludXRlIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgc2V0U2Vjb25kcyhzZWNvbmRzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcyhzZWNvbmRzID8gc2Vjb25kcyA6IDApO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSBkYXRlO1xuICAgIH1cblxuICAgIGluY3JlbWVudEhvdXIoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0SG91cih0aGlzLnZhbHVlLmdldEhvdXJzKCkgKyB0aGlzLmhvdXJTdGVwKTtcbiAgICB9XG5cbiAgICBkZWNyZW1lbnRIb3VyKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEhvdXIodGhpcy52YWx1ZS5nZXRIb3VycygpIC0gdGhpcy5ob3VyU3RlcCk7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50TWludXRlKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE1pbnV0ZSh0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKSArIHRoaXMubWludXRlU3RlcCk7XG4gICAgfVxuXG4gICAgZGVjcmVtZW50TWludXRlKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE1pbnV0ZSh0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKSAtIHRoaXMubWludXRlU3RlcCk7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50U2Vjb25kKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFNlY29uZHModGhpcy52YWx1ZS5nZXRTZWNvbmRzKCkgKyB0aGlzLnNlY29uZFN0ZXApO1xuICAgIH1cblxuICAgIGRlY3JlbWVudFNlY29uZChhcnJvd2tleTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGFycm93a2V5ICYmICF0aGlzLmFycm93a2V5cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTZWNvbmRzKHRoaXMudmFsdWUuZ2V0U2Vjb25kcygpIC0gdGhpcy5zZWNvbmRTdGVwKTtcbiAgICB9XG5cbiAgICBzZWxlY3RNZXJpZGlhbihtZXJpZGlhbjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lcmlkaWFuID0gbWVyaWRpYW47XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgY29uc3QgaG91ciA9IHRoaXMudmFsdWUuZ2V0SG91cnMoKTtcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHNlbGVjdGVkIEFNXG4gICAgICAgIGlmIChtZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIb3VyKGhvdXIgLSAxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHNlbGVjdGVkIFBNXG4gICAgICAgIGlmIChtZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMV0pIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhvdXIoaG91ciArIDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrVmFsaWRpdHkoZGF0ZTogRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1pbiAmJiBkYXRlLmdldFRpbWUoKSA8PSB0aGlzLm1pbi5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXggJiYgZGF0ZS5nZXRUaW1lKCkgPj0gdGhpcy5tYXguZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cblxuICAgIGhvdXJDaGFuZ2UodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlclxuICAgICAgICBsZXQgaG91ciA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRIb3VyID0gdGhpcy52YWx1ZS5nZXRIb3VycygpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoaG91ciA9PT0gY3VycmVudEhvdXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgaG91cnMgaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc05hTihob3VyKSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob3VyID4gKHRoaXMuc2hvd01lcmlkaWFuID8gMTIgOiAyMykpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gdGhpcy5zaG93TWVyaWRpYW4gPyAxMiA6IDIzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaG91ciA9IGlzTmFOKGhvdXIpID8gY3VycmVudEhvdXIgOiBob3VyO1xuXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgaW52YWxpZCB0aGVuIHJlc3RvcmUgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLl9tZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciAtPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc2VsZWN0ZWQgUE1cbiAgICAgICAgaWYgKHRoaXMuX21lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1sxXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEhvdXIoaG91cik7XG4gICAgfVxuXG4gICAgbWludXRlQ2hhbmdlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXJcbiAgICAgICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRNaW51dGUgPSB0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKG1pbnV0ZSA9PT0gY3VycmVudE1pbnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBob3VycyBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzTmFOKG1pbnV0ZSkpIHtcbiAgICAgICAgICAgIGlmIChtaW51dGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWludXRlID0gNTk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW51dGUgPiA1OSkge1xuICAgICAgICAgICAgICAgIG1pbnV0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQgdGhlbiByZXN0b3JlIGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICB0aGlzLnNldE1pbnV0ZShpc05hTihtaW51dGUpID8gY3VycmVudE1pbnV0ZSA6IG1pbnV0ZSk7XG4gICAgfVxuXG4gICAgc2Vjb25kQ2hhbmdlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyXG4gICAgICAgIGxldCBzZWNvbmQgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgIGxldCBjdXJyZW50U2Vjb25kID0gdGhpcy52YWx1ZS5nZXRTZWNvbmRzKCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChzZWNvbmQgPT09IGN1cnJlbnRTZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgaG91cnMgaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc05hTihzZWNvbmQpKSB7XG4gICAgICAgICAgICBpZiAoc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgIHNlY29uZCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWNvbmQgPiA1OSkge1xuICAgICAgICAgICAgICAgIHNlY29uZCA9IDU5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIG51bWJlciBpcyBpbnZhbGlkIHRoZW4gcmVzdG9yZSBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRTZWNvbmRzKGlzTmFOKHNlY29uZCkgPyBjdXJyZW50U2Vjb25kIDogc2Vjb25kKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFNwaW5CdXR0b25Nb2R1bGUgfSBmcm9tICcuLi9zcGluLWJ1dHRvbi9pbmRleCc7XG5pbXBvcnQgeyBUaW1lRm9ybWF0UGlwZSB9IGZyb20gJy4vdGltZS1mb3JtYXQucGlwZSc7XG5pbXBvcnQgeyBUaW1lUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi90aW1lLXBpY2tlci5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgU3BpbkJ1dHRvbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1RpbWVQaWNrZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1RpbWVQaWNrZXJDb21wb25lbnQsIFRpbWVGb3JtYXRQaXBlXSxcbn0pXG5leHBvcnQgY2xhc3MgVGltZVBpY2tlck1vZHVsZSB7IH0iLCJpbXBvcnQgeyBEYXRlVGltZVBpY2tlclRpbWV6b25lIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSBkaW1lbnNpb24gYXJyYXkgdG8gYSBkb3VibGUgZGltZW5zaW9uIGFycmF5XG4gKiBAcGFyYW0gaXRlbXMgdGhlIHNpbmdsZSBkaW1lbnNpb24gYXJyYXkgdG8gY29udmVydFxuICogQHBhcmFtIGNvbHVtbnMgdGhlIG51bWJlciBvZiBpdGVtcyBlYWNoIGFycmF5IHNob3VsZCBoYXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmlkaWZ5PFQ+KGl0ZW1zOiBUW10sIGNvbHVtbnM6IG51bWJlcik6IFRbXVtdIHtcblxuICAgIC8vIGNyZWF0ZSBhIGNvcHkgb2YgYXJyYXkgc28gbm90IHRvIGVmZmVjdCB0aGUgb3JpZ2luYWxcbiAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDApO1xuXG4gICAgY29uc3QgZ3JpZDogVFtdW10gPSBbXTtcblxuICAgIHdoaWxlIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgZ3JpZC5wdXNoKGl0ZW1zLnNwbGljZSgwLCBjb2x1bW5zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyaWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIG51bWJlcnMgYmV0d2VlbiB0d28gbGltaXRzXG4gKiBAcGFyYW0gc3RhcnQgdGhlIGxvd2VyIGxpbWl0XG4gKiBAcGFyYW0gZW5kIHRoZSB1cHBlciBsaW1pdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbGlzdDogbnVtYmVyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGlkeCA9IHN0YXJ0OyBpZHggPD0gZW5kOyBpZHgrKykge1xuICAgICAgICBsaXN0LnB1c2goaWR4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgZGF0ZXMgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0gc3RhcnQgdGhlIGRhdGUgdG8gc3RhcnQgdGhlIGFycmF5XG4gKiBAcGFyYW0gZW5kIHRoZSBkYXRlIHRvIGVuZCB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVSYW5nZShzdGFydDogRGF0ZSwgZW5kOiBEYXRlKTogRGF0ZVtdIHtcblxuICAgIGxldCBkYXRlczogRGF0ZVtdID0gW107XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIHRoZSBkYXlzIGJldHdlZW4gdGhlIGRhdGUgcmFuZ2VcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBkYXRlIHRvIHRoZSBhcnJheVxuICAgICAgICBkYXRlcy5wdXNoKG5ldyBEYXRlKHN0YXJ0KSk7XG5cbiAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCBkYXlcbiAgICAgICAgc3RhcnQuc2V0RGF0ZShzdGFydC5nZXREYXRlKCkgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZXM7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gZGF0ZXMgdG8gc2VlIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIGRheVxuICogQHBhcmFtIGRheTEgdGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIGRheTIgdGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVEYXlzKGRheTE6IERhdGUsIGRheTI6IERhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZGF5MS5nZXREYXRlKCkgPT09IGRheTIuZ2V0RGF0ZSgpICYmXG4gICAgICAgIGRheTEuZ2V0TW9udGgoKSA9PT0gZGF5Mi5nZXRNb250aCgpICYmXG4gICAgICAgIGRheTEuZ2V0RnVsbFllYXIoKSA9PT0gZGF5Mi5nZXRGdWxsWWVhcigpO1xufVxuXG4vKipcbiAqIERhdGUgY29tcGFyaXNvbiBmb3IgdXNlIHByaW1hcmlseSB3aXRoIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlQ29tcGFyYXRvcihkYXRlT25lOiBEYXRlLCBkYXRlVHdvOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRhdGVPbmUuZ2V0VGltZSgpID09PSBkYXRlVHdvLmdldFRpbWUoKTtcbn1cblxuLyoqXG4gKiBUaW1lem9uZSBjb21wYXJpc29uIGZvciB1c2UgcHJpbWFyaWx5IHdpdGggZGlzdGluY3RVbnRpbENoYW5nZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWV6b25lQ29tcGFyYXRvcih6b25lT25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lLCB6b25lVHdvOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHpvbmVPbmUubmFtZSA9PT0gem9uZVR3by5uYW1lICYmIHpvbmVPbmUub2Zmc2V0ID09PSB6b25lVHdvLm9mZnNldDtcbn1cblxuLyoqXG4gKiBFeHBvcnQgYW4gYXJyYXkgb2YgYWxsIHRoZSBhdmFpbGFibGUgbW9udGhzXG4gKi9cbmV4cG9ydCBjb25zdCBtb250aHMgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IG1vbnRocy5tYXAobW9udGggPT4gbW9udGguc3Vic3RyaW5nKDAsIDMpKTtcblxuLyoqXG4gKiBFeHBvcnQgYW4gYXJyYXkgb2YgYWxsIHRoZSBhdmFpbGFibGUgZGF5cyBvZiB0aGUgd2Vla1xuICovXG5leHBvcnQgY29uc3Qgd2Vla2RheXMgPSBbJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknLCAnU3VuZGF5J107XG5leHBvcnQgY29uc3Qgd2Vla2RheXNTaG9ydCA9IHdlZWtkYXlzLm1hcCh3ZWVrZGF5ID0+IHdlZWtkYXkuc3Vic3RyaW5nKDAsIDMpKTsiLCIvKipcbiAqIEFkZCBhIGNvbmZpZyBzZXJ2aWNlIHRvIGFsbG93IGFuIGFwcGxpY2F0aW9uXG4gKiB0byBjdXN0b21pemUgdGhlIGRhdGUgdGltZSBwaWNrZXIgZGVmYXVsdCBzZXR0aW5nc1xuICogYWNyb3NzIHRoZSBlbnRpcmUgYXBwbGljYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB3ZWVrZGF5c1Nob3J0IH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyVGltZXpvbmUgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlckNvbmZpZyB7XG5cbiAgICBzaG93RGF0ZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1RpbWU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dUaW1lem9uZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1NlY29uZHM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG93TWVyaWRpYW46IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dTcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG4gICAgd2Vla2RheXM6IHN0cmluZ1tdID0gd2Vla2RheXNTaG9ydDtcbiAgICBub3dCdG5UZXh0OiBzdHJpbmcgPSAnVG9kYXknO1xuXG4gICAgdGltZXpvbmVzOiBEYXRlVGltZVBpY2tlclRpbWV6b25lW10gPSBbXG4gICAgICAgIHsgbmFtZTogJ0dNVC0xMScsIG9mZnNldDogNjYwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC0xMCcsIG9mZnNldDogNjAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC05Jywgb2Zmc2V0OiA1NDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTgnLCBvZmZzZXQ6IDQ4MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtNycsIG9mZnNldDogNDIwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC02Jywgb2Zmc2V0OiAzNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTUnLCBvZmZzZXQ6IDMwMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtNCcsIG9mZnNldDogMjQwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC0zJywgb2Zmc2V0OiAxODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTInLCBvZmZzZXQ6IDEyMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtMScsIG9mZnNldDogNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UJywgb2Zmc2V0OiAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVCsxJywgb2Zmc2V0OiAtNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzInLCBvZmZzZXQ6IC0xMjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzMnLCBvZmZzZXQ6IC0xODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzQnLCBvZmZzZXQ6IC0yNDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzUnLCBvZmZzZXQ6IC0zMDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzYnLCBvZmZzZXQ6IC0zNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzcnLCBvZmZzZXQ6IC00MjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzgnLCBvZmZzZXQ6IC00ODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzknLCBvZmZzZXQ6IC01NDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzEwJywgb2Zmc2V0OiAtNjAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVCsxMScsIG9mZnNldDogLTY2MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrMTInLCBvZmZzZXQ6IC03MjAgfVxuICAgIF07XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyQ29uZmlnIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLmNvbmZpZyc7XG5pbXBvcnQgeyBkYXRlQ29tcGFyYXRvciB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlclNlcnZpY2Uge1xuXG4gICAgbW9kZSQ6IEJlaGF2aW9yU3ViamVjdDxEYXRlUGlja2VyTW9kZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGVQaWNrZXJNb2RlPihEYXRlUGlja2VyTW9kZS5EYXkpO1xuICAgIGRhdGUkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuICAgIHRpbWV6b25lJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4odGhpcy5nZXRDdXJyZW50VGltZXpvbmUoKSk7XG4gICAgc2VsZWN0ZWQkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuXG4gICAgLy8gdGhlIG1vbnRoIGFuZCB5ZWFyIHRvIGRpc3BsYXkgaW4gdGhlIHZpZXdwb3J0XG4gICAgbW9udGgkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldE1vbnRoKCkpO1xuICAgIHllYXIkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpO1xuXG4gICAgc2hvd0RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd0RhdGUpO1xuICAgIHNob3dUaW1lJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dUaW1lKTtcbiAgICBzaG93VGltZXpvbmUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd1RpbWV6b25lKTtcbiAgICBzaG93U2Vjb25kcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZy5zaG93U2Vjb25kcyk7XG4gICAgc2hvd01lcmlkaWFuJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dNZXJpZGlhbik7XG4gICAgc2hvd1NwaW5uZXJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dTcGlubmVycyk7XG4gICAgd2Vla2RheXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmdbXT4odGhpcy5fY29uZmlnLndlZWtkYXlzKTtcbiAgICBub3dCdG5UZXh0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPih0aGlzLl9jb25maWcubm93QnRuVGV4dCk7XG4gICAgdGltZXpvbmVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdPih0aGlzLl9jb25maWcudGltZXpvbmVzKTtcblxuICAgIGhlYWRlciQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4obnVsbCk7XG4gICAgaGVhZGVyRXZlbnQkID0gbmV3IFN1YmplY3Q8RGF0ZVBpY2tlckhlYWRlckV2ZW50PigpO1xuICAgIG1vZGVEaXJlY3Rpb246IE1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLk5vbmU7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbmZpZzogRGF0ZVRpbWVQaWNrZXJDb25maWcpIHtcblxuICAgICAgICAvLyB3aGVuIHRoZSBhY3RpdmUgZGF0ZSBjaGFuZ2VzIHNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGVcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5zZWxlY3RlZCQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZChkYXRlQ29tcGFyYXRvcikpLnN1YnNjcmliZShkYXRlID0+IHtcblxuICAgICAgICAgICAgLy8gdGhlIG1vbnRoIGFuZCB5ZWFyIGRpc3BsYXllZCBpbiB0aGUgdmlld3BvcnQgc2hvdWxkIHJlZmxlY3QgdGhlIG5ld2x5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0TW9udGgoZGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnRZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIG5ldyBkYXRlIHRvIHRoZSBjb21wb25lbnQgaG9zdFxuICAgICAgICAgICAgdGhpcy5kYXRlJC5uZXh0KGRhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRNb250aChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChtb250aCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQoMTEpO1xuICAgICAgICAgICAgdGhpcy55ZWFyJC5uZXh0KHRoaXMueWVhciQudmFsdWUgLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb250aCA+IDExKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoJC5uZXh0KDApO1xuICAgICAgICAgICAgdGhpcy55ZWFyJC5uZXh0KHRoaXMueWVhciQudmFsdWUgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQobW9udGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRZZWFyKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnllYXIkLm5leHQoeWVhcik7XG4gICAgfVxuXG4gICAgc2V0RGF0ZShkYXk6IG51bWJlciwgbW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnNlbGVjdGVkJC52YWx1ZSk7XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKGRheSk7XG4gICAgICAgIGRhdGUuc2V0TW9udGgobW9udGgpO1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQoZGF0ZSk7XG4gICAgfVxuXG4gICAgc2V0RGF0ZVRvTm93KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KG5ldyBEYXRlKCkpO1xuICAgIH1cblxuICAgIHNldFZpZXdwb3J0TW9kZShtb2RlOiBEYXRlUGlja2VyTW9kZSk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGUkLm5leHQobW9kZSk7XG4gICAgfVxuXG4gICAgZ29Ub0NoaWxkTW9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb2RlRGlyZWN0aW9uID0gTW9kZURpcmVjdGlvbi5EZXNjZW5kO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlJC52YWx1ZSkge1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRNb2RlKERhdGVQaWNrZXJNb2RlLk1vbnRoKTtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuRGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9QYXJlbnRNb2RlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLkFzY2VuZDtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSQudmFsdWUpIHtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRNb2RlKERhdGVQaWNrZXJNb2RlLk1vbnRoKTtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuWWVhcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvTmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oZWFkZXJFdmVudCQubmV4dChEYXRlUGlja2VySGVhZGVyRXZlbnQuTmV4dCk7XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZpb3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYWRlckV2ZW50JC5uZXh0KERhdGVQaWNrZXJIZWFkZXJFdmVudC5QcmV2aW91cyk7XG4gICAgfVxuXG4gICAgc2V0SGVhZGVyKGhlYWRlcjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGVhZGVyJC5uZXh0KGhlYWRlcik7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFRpbWV6b25lKCk6IERhdGVUaW1lUGlja2VyVGltZXpvbmUge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcudGltZXpvbmVzLmZpbmQodGltZXpvbmUgPT4gdGltZXpvbmUub2Zmc2V0ID09PSBvZmZzZXQpO1xuICAgIH1cblxuICAgIHNldFRpbWV6b25lKHRpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKTogdm9pZCB7XG4gICAgICAgIHRoaXMudGltZXpvbmUkLm5leHQodGltZXpvbmUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gRGF0ZVBpY2tlck1vZGUge1xuICAgIERheSxcbiAgICBNb250aCxcbiAgICBZZWFyXG59XG5cbmV4cG9ydCBlbnVtIE1vZGVEaXJlY3Rpb24ge1xuICAgIE5vbmUsXG4gICAgQXNjZW5kLFxuICAgIERlc2NlbmRcbn1cblxuZXhwb3J0IGVudW0gRGF0ZVBpY2tlckhlYWRlckV2ZW50IHtcbiAgICBQcmV2aW91cyxcbiAgICBOZXh0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG9mZnNldDogbnVtYmVyO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERhdGVQaWNrZXJNb2RlLCBEYXRlVGltZVBpY2tlclNlcnZpY2UsIERhdGVUaW1lUGlja2VyVGltZXpvbmUgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBkYXRlQ29tcGFyYXRvciwgdGltZXpvbmVDb21wYXJhdG9yIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlcicsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImNhbGVuZGFyLWNvbnRhaW5lclwiPlxuXG4gIDx1eC1kYXRlLXRpbWUtcGlja2VyLWhlYWRlcj48L3V4LWRhdGUtdGltZS1waWNrZXItaGVhZGVyPlxuXG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dEYXRlJCB8IGFzeW5jXCIgW25nU3dpdGNoXT1cImRhdGVwaWNrZXIubW9kZSQgfCBhc3luY1wiPlxuXG4gICAgICA8IS0tIERpc3BsYXkgZGF5cyBpbiB0aGUgY3VycmVudCBtb250aCAtLT5cbiAgICAgIDx1eC1kYXRlLXRpbWUtcGlja2VyLWRheS12aWV3ICpuZ1N3aXRjaENhc2U9XCJEYXRlUGlja2VyTW9kZS5EYXlcIj48L3V4LWRhdGUtdGltZS1waWNrZXItZGF5LXZpZXc+XG5cbiAgICAgIDwhLS0gRGlzcGxheSB0aGUgbW9udGhzIGluIHRoZSBjdXJyZW50IHllYXIgLS0+XG4gICAgICA8dXgtZGF0ZS10aW1lLXBpY2tlci1tb250aC12aWV3ICpuZ1N3aXRjaENhc2U9XCJEYXRlUGlja2VyTW9kZS5Nb250aFwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlci1tb250aC12aWV3PlxuXG4gICAgICA8IS0tIERpc3BsYXkgYSBkZWNhZGUgLS0+XG4gICAgICA8dXgtZGF0ZS10aW1lLXBpY2tlci15ZWFyLXZpZXcgKm5nU3dpdGNoQ2FzZT1cIkRhdGVQaWNrZXJNb2RlLlllYXJcIj48L3V4LWRhdGUtdGltZS1waWNrZXIteWVhci12aWV3PlxuXG4gIDwvbmctY29udGFpbmVyPlxuXG4gIDwhLS0gRGlzcGxheSBhIFRpbWUgUGlja2VyIC0tPlxuICA8dXgtZGF0ZS10aW1lLXBpY2tlci10aW1lLXZpZXcgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dUaW1lJCB8IGFzeW5jXCI+PC91eC1kYXRlLXRpbWUtcGlja2VyLXRpbWUtdmlldz5cblxuPC9kaXY+XG5cbjxidXR0b24gY2xhc3M9XCJub3ctYnV0dG9uXCIgYXJpYS1sYWJlbD1cIlNldCBkYXRlIHRvIG5vd1wiIChjbGljayk9XCJzZXRUb05vdygpXCI+e3sgZGF0ZXBpY2tlci5ub3dCdG5UZXh0JCB8IGFzeW5jIH19PC9idXR0b24+YCxcbiAgcHJvdmlkZXJzOiBbRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgX3RpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lO1xuXG4gIEBJbnB1dCgpIHNldCBzaG93RGF0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93RGF0ZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2hvd1RpbWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1RpbWUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dUaW1lem9uZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93VGltZXpvbmUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dTZWNvbmRzKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnNob3dTZWNvbmRzJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93TWVyaWRpYW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd01lcmlkaWFuJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93U3Bpbm5lcnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1NwaW5uZXJzJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCB3ZWVrZGF5cyh2YWx1ZTogc3RyaW5nW10pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIud2Vla2RheXMkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IG5vd0J0blRleHQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5ub3dCdG5UZXh0JC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCB0aW1lem9uZXModmFsdWU6IERhdGVUaW1lUGlja2VyVGltZXpvbmVbXSkge1xuICAgIHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLm5leHQodmFsdWUpO1xuICB9XG5cblxuICBAT3V0cHV0KCkgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuICBAT3V0cHV0KCkgdGltZXpvbmVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRlVGltZVBpY2tlclRpbWV6b25lPiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4oKTtcblxuICBASW5wdXQoKVxuICBzZXQgZGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGlmICghZGF0ZUNvbXBhcmF0b3IodmFsdWUsIHRoaXMuZGF0ZXBpY2tlci5zZWxlY3RlZCQudmFsdWUpKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXIuc2VsZWN0ZWQkLm5leHQobmV3IERhdGUodmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgdGltZXpvbmUodmFsdWU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgLy8gZXhwb3NlIGVudW0gdG8gdmlld1xuICBEYXRlUGlja2VyTW9kZSA9IERhdGVQaWNrZXJNb2RlO1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgY29uc3QgdmFsdWVDaGFuZ2UgPSBkYXRlcGlja2VyLnNlbGVjdGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKGRhdGVDb21wYXJhdG9yKSlcbiAgICAgIC5zdWJzY3JpYmUoZGF0ZSA9PiB0aGlzLmRhdGVDaGFuZ2UuZW1pdChkYXRlKSk7XG5cbiAgICBjb25zdCB0aW1lem9uZUNoYW5nZSA9IGRhdGVwaWNrZXIudGltZXpvbmUkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQodGltZXpvbmVDb21wYXJhdG9yKSlcbiAgICAgIC5zdWJzY3JpYmUoKHRpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKSA9PiB0aGlzLnRpbWV6b25lQ2hhbmdlLmVtaXQodGltZXpvbmUpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZGF0ZSB0byB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lXG4gICAqL1xuICBzZXRUb05vdygpOiB2b2lkIHtcblxuICAgIC8vIHNldCB0aGUgZGF0ZSB0byB0aGUgY3VycmVudCBtb21lbnRcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2V0RGF0ZVRvTm93KCk7XG4gIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UsIE1vZGVEaXJlY3Rpb24gfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgY29tcGFyZURheXMsIGRhdGVSYW5nZSwgZ3JpZGlmeSwgbW9udGhzIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXlWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF5Vmlld0l0ZW1bXVtdPihbW11dKTtcbiAgICBmb2N1c2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Rm9jdXNlZERheUl0ZW0+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gY29tYmluZUxhdGVzdChfZGF0ZXBpY2tlci5tb250aCQsIF9kYXRlcGlja2VyLnllYXIkKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoW21vbnRoLCB5ZWFyXSkgPT4gdGhpcy5jcmVhdGVEYXlHcmlkKG1vbnRoLCB5ZWFyKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEZvY3VzKGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkJC5uZXh0KHsgZGF5OiBkYXksIG1vbnRoOiBtb250aCwgeWVhcjogeWVhciB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGRhdGUgcGlja2VyIHRvIHNob3cgdGhlIHJlcXVpcmVkIG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHllYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlRGF5R3JpZChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlclxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldEhlYWRlcihtb250aHNbbW9udGhdICsgJyAnICsgeWVhcik7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kYXJpZXNcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgMCk7XG5cbiAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gc2hvdyBmcm9tIHRoZSBzdW5kYXkgLSB0aGlzIG1heSBpbmNsdWRlIHNob3dpbmcgc29tZSBkYXRlcyBmcm9tIHRoZSBwcmV2aW91cyBtb250aFxuICAgICAgICBzdGFydC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSAtIHN0YXJ0LmdldERheSgpKTtcblxuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHJhbmdlIGVuZHMgb24gYSBzYXR1cmRheVxuICAgICAgICBlbmQuc2V0RGF0ZShlbmQuZ2V0RGF0ZSgpICsgKDYgLSBlbmQuZ2V0RGF5KCkpKTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgb2YgYWxsIHRoZSBkYXlzIHRvIGRpc3BsYXlcbiAgICAgICAgY29uc3QgZGF0ZXM6IERheVZpZXdJdGVtW10gPSBkYXRlUmFuZ2Uoc3RhcnQsIGVuZCkubWFwKGRhdGUgPT4gKHtcbiAgICAgICAgICAgIGRheTogZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIGlzVG9kYXk6IHRoaXMuaXNUb2RheShkYXRlKSxcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQWN0aXZlKGRhdGUpLFxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IGRhdGUuZ2V0TW9udGgoKSA9PT0gbW9udGhcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHR1cm4gdGhlIGRhdGVzIGludG8gYSBncmlkXG4gICAgICAgIGNvbnN0IGl0ZW1zOiBEYXlWaWV3SXRlbVtdW10gPSBncmlkaWZ5KGRhdGVzLCA3KTtcblxuICAgICAgICB0aGlzLmdyaWQkLm5leHQoaXRlbXMpO1xuXG4gICAgICAgIC8vIGlmIG5vIGl0ZW0gaGFzIHlldCBiZWVuIGZvY3VzZWQgdGhlbiBmb2N1cyB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICBpZiAoKHRoaXMuX2RhdGVwaWNrZXIubW9kZURpcmVjdGlvbiA9PT0gTW9kZURpcmVjdGlvbi5Ob25lIHx8IHRoaXMuX2RhdGVwaWNrZXIubW9kZURpcmVjdGlvbiA9PT0gTW9kZURpcmVjdGlvbi5EZXNjZW5kKSAmJiB0aGlzLmZvY3VzZWQkLnZhbHVlID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWxlY3RlZCBpdGVtIGlzIHZpc2libGVcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRGF5ID0gZGF0ZXMuZmluZChkYXkgPT4gZGF5LmlzQ3VycmVudE1vbnRoICYmIGRheS5pc0FjdGl2ZSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZERheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoc2VsZWN0ZWREYXkuZGF5LCBzZWxlY3RlZERheS5tb250aCwgc2VsZWN0ZWREYXkueWVhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0ZXMuZmluZChkYXRlID0+IGRhdGUuZGF5ID09PSAxKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBmb2N1cyB0aGUgZGF0ZVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoZmlyc3QuZGF5LCBmaXJzdC5tb250aCwgZmlyc3QueWVhcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBkYXRlIGlzIHRvZGF5XG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGNoZWNrXG4gICAqL1xuICAgIHByaXZhdGUgaXNUb2RheShkYXRlOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBjb21wYXJlRGF5cyhuZXcgRGF0ZSgpLCBkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgc3BlY2lmaWMgZGF0ZSBpcyB0aGUgc2VsZWN0ZWQgb25lXG4gICAgICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY2hlY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzQWN0aXZlKGRhdGU6IERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVEYXlzKHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLCBkYXRlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5Vmlld0l0ZW0ge1xuICAgIGRheTogbnVtYmVyO1xuICAgIG1vbnRoOiBudW1iZXI7XG4gICAgeWVhcjogbnVtYmVyO1xuICAgIGRhdGU6IERhdGU7XG4gICAgaXNUb2RheTogYm9vbGVhbjtcbiAgICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgICBpc0N1cnJlbnRNb250aDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb2N1c2VkRGF5SXRlbSB7XG4gICAgZGF5OiBudW1iZXI7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBEYXRlUGlja2VySGVhZGVyRXZlbnQsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBEYXlWaWV3SXRlbSwgRGF5Vmlld1NlcnZpY2UgfSBmcm9tICcuL2RheS12aWV3LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLWRheS12aWV3JyxcbiAgdGVtcGxhdGU6IGA8dGFibGUgY2xhc3M9XCJjYWxlbmRhclwiPlxuICAgIDx0aGVhZD5cbiAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRoICpuZ0Zvcj1cImxldCBkYXkgb2YgZGF0ZVBpY2tlci53ZWVrZGF5cyQgfCBhc3luY1wiIGNsYXNzPVwid2Vla2RheVwiIFthdHRyLmFyaWEtbGFiZWxdPVwiZGF5XCI+e3sgZGF5IH19PC90aD5cbiAgICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuXG4gICAgPHRib2R5IHJvbGU9XCJncmlkXCI+XG4gICAgICAgIDx0ciByb2xlPVwicm93XCIgKm5nRm9yPVwibGV0IHJvdyBvZiBkYXlTZXJ2aWNlLmdyaWQkIHwgYXN5bmM7IHRyYWNrQnk6IHRyYWNrV2Vla0J5Rm5cIj5cblxuICAgICAgICAgICAgPHRkICpuZ0Zvcj1cImxldCBpdGVtIG9mIHJvdzsgdHJhY2tCeTogdHJhY2tEYXlCeUZuXCIgY2xhc3M9XCJkYXRlLWNlbGxcIiByb2xlPVwiZ3JpZGNlbGxcIj5cblxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkYXRlLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZm9jdXNJZl09XCIoZGF5U2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8uZGF5ID09PSBpdGVtLmRheSAmJiAoZGF5U2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8ubW9udGggPT09IGl0ZW0ubW9udGggJiYgKGRheVNlcnZpY2UuZm9jdXNlZCQgfCBhc3luYyk/LnllYXIgPT09IGl0ZW0ueWVhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIml0ZW0uZGF0ZSB8IGRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLmlzQWN0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtaGlkZGVuXT1cIiFpdGVtLmlzQ3VycmVudE1vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5jdXJyZW50XT1cIml0ZW0uaXNUb2RheVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cIml0ZW0uaXNBY3RpdmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnByZXZpZXddPVwiIWl0ZW0uaXNDdXJyZW50TW9udGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3RhYmluZGV4XT1cImdldFRhYmJhYmxlKGl0ZW0pID8gMCA6IC0xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3QoaXRlbS5kYXRlKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXlkb3duLkFycm93TGVmdCk9XCJmb2N1c0RhdGUoaXRlbSwgLTEpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5BcnJvd1JpZ2h0KT1cImZvY3VzRGF0ZShpdGVtLCAxKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGtleWRvd24uQXJyb3dVcCk9XCJmb2N1c0RhdGUoaXRlbSwgLTcpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5BcnJvd0Rvd24pPVwiZm9jdXNEYXRlKGl0ZW0sIDcpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG4gICAgICAgICAgICAgICAgICAgIHt7IGl0ZW0uZGF0ZS5nZXREYXRlKCkgfX1cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC90cj5cbiAgICA8L3Rib2R5PlxuPC90YWJsZT5gLFxuICBwcm92aWRlcnM6IFtEYXlWaWV3U2VydmljZV0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIERheVZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRlUGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UsIHB1YmxpYyBkYXlTZXJ2aWNlOiBEYXlWaWV3U2VydmljZSkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IGRhdGVQaWNrZXIuaGVhZGVyRXZlbnQkXG4gICAgICAuc3Vic2NyaWJlKGV2ZW50ID0+IGV2ZW50ID09PSBEYXRlUGlja2VySGVhZGVyRXZlbnQuTmV4dCA/IHRoaXMubmV4dCgpIDogdGhpcy5wcmV2aW91cygpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBwYWdlIG9mIGRhdGVzXG4gICAqL1xuICBwcmV2aW91cygpOiB2b2lkIHtcbiAgICB0aGlzLmRhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aCh0aGlzLmRhdGVQaWNrZXIubW9udGgkLnZhbHVlIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIG5leHQgcGFnZSBvZiBkYXRlc1xuICAgKi9cbiAgbmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLmRhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aCh0aGlzLmRhdGVQaWNrZXIubW9udGgkLnZhbHVlICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgcGFydGljdWxhciBkYXRlXG4gICAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIHNlbGVjdFxuICAgKi9cbiAgc2VsZWN0KGRhdGU6IERhdGUpOiB2b2lkIHtcbiAgICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZGF0ZSBvYmplY3RcbiAgICB0aGlzLmRhdGVQaWNrZXIuc2V0RGF0ZShkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldEZ1bGxZZWFyKCkpO1xuXG4gICAgLy8gZm9jdXMgdGhlIG5ld2x5IHNlbGVjdGVkIGRhdGVcbiAgICB0aGlzLmRheVNlcnZpY2Uuc2V0Rm9jdXMoZGF0ZS5nZXREYXRlKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgfVxuXG4gIHRyYWNrV2Vla0J5Rm4oaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgdHJhY2tEYXlCeUZuKGluZGV4OiBudW1iZXIsIGl0ZW06IERheVZpZXdJdGVtKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7IGl0ZW0uZGF5IH0gJHsgaXRlbS5tb250aCB9ICR7IGl0ZW0ueWVhciB9YDtcbiAgfVxuXG4gIGZvY3VzRGF0ZShpdGVtOiBEYXlWaWV3SXRlbSwgZGF5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSB0aGUgZGF0ZSBvZiB0aGUgZGF5XG4gICAgY29uc3QgdGFyZ2V0ID0gbmV3IERhdGUoaXRlbS5kYXRlLnNldERhdGUoaXRlbS5kYXRlLmdldERhdGUoKSArIGRheU9mZnNldCkpO1xuXG4gICAgLy8gaWRlbnRpZnkgd2hpY2ggZGF0ZSBzaG91bGQgYmUgZm9jdXNlZFxuICAgIHRoaXMuZGF5U2VydmljZS5zZXRGb2N1cyh0YXJnZXQuZ2V0RGF0ZSgpLCB0YXJnZXQuZ2V0TW9udGgoKSwgdGFyZ2V0LmdldEZ1bGxZZWFyKCkpO1xuICB9XG5cbiAgZ2V0VGFiYmFibGUoaXRlbTogRGF5Vmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5kYXlTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLmRheVNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIGZvY3VzZWQgbW9udGggY2hlY2sgaWYgdGhpcyBpcyBpdFxuICAgIGlmIChmb2N1c2VkKSB7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBmb2N1c2VkIGRheSBpcyB2aXNpYmxlXG4gICAgICBjb25zdCBpc0ZvY3VzZWREYXlWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0uZGF5ID09PSBmb2N1c2VkLmRheSAmJiBfaXRlbS5tb250aCA9PT0gZm9jdXNlZC5tb250aCAmJiBfaXRlbS55ZWFyID09PSBmb2N1c2VkLnllYXIpKTtcblxuICAgICAgaWYgKGlzRm9jdXNlZERheVZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZvY3VzZWQuZGF5ID09PSBpdGVtLmRheSAmJiBmb2N1c2VkLm1vbnRoID09PSBpdGVtLm1vbnRoICYmIGZvY3VzZWQueWVhciA9PT0gaXRlbS55ZWFyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSBkYXkgdGhlbiBjaGVjayBpZiB0aGVyZSBpcyBhIHNlbGVjdGVkIGRheVxuICAgIGNvbnN0IGlzU2VsZWN0ZWREYXlWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoZGF5ID0+IGRheS5pc0FjdGl2ZSkpO1xuXG4gICAgaWYgKGlzU2VsZWN0ZWREYXlWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlzQWN0aXZlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBkYXkgdGFiYmFibGVcbiAgICByZXR1cm4gaXRlbS5kYXkgPT09IDE7XG4gIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGF0ZVBpY2tlck1vZGUsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiBgPGhlYWRlciBjbGFzcz1cImhlYWRlclwiPlxuXG4gIDxidXR0b24gY2xhc3M9XCJoZWFkZXItbmF2aWdhdGlvblwiXG4gICAgICAgICAgKGNsaWNrKT1cInByZXZpb3VzKCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJwcmV2aW91c0FyaWEkIHwgYXN5bmNcIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiPlxuXG4gICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtcHJldmlvdXNcIj48L2k+XG4gIDwvYnV0dG9uPlxuXG4gIDxidXR0b24gY2xhc3M9XCJoZWFkZXItdGl0bGVcIlxuICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaGVhZGVyQXJpYSQgfCBhc3luY1wiXG4gICAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJjYW5Bc2NlbmQkIHwgYXN5bmNcIlxuICAgICAgICAgIChjbGljayk9XCJhc2NlbmQoKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICBbdGFiaW5kZXhdPVwiKGNhbkFzY2VuZCQgfCBhc3luYykgPyAwIDogLTFcIj5cbiAgICAgICB7eyBkYXRlcGlja2VyLmhlYWRlciQgfCBhc3luYyB9fVxuICA8L2J1dHRvbj5cblxuICA8YnV0dG9uIGNsYXNzPVwiaGVhZGVyLW5hdmlnYXRpb25cIlxuICAgICAgICAgIChjbGljayk9XCJuZXh0KCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJuZXh0QXJpYSQgfCBhc3luY1wiXG4gICAgICAgICAgdGFiaW5kZXg9XCIwXCI+XG5cbiAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1uZXh0XCI+PC9pPlxuICA8L2J1dHRvbj5cbjwvaGVhZGVyPmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgSGVhZGVyQ29tcG9uZW50IHtcblxuICAgIGNhbkFzY2VuZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiBtb2RlICE9PSBEYXRlUGlja2VyTW9kZS5ZZWFyKSk7XG4gICAgXG4gICAgbW9kZSQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0RheSc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiAnTW9udGgnO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5ZZWFyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnWWVhcic7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBoZWFkZXJBcmlhJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5kYXRlcGlja2VyLm1vZGUkLnBpcGUobWFwKG1vZGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuRGF5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnU3dpdGNoIHRvIHNob3cgbW9udGhzIGluIHRoZSB5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTd2l0Y2ggdG8gc2hvdyB5ZWFycyBpbiB0aGUgZGVjYWRlJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBwcmV2aW91c0FyaWEkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdQcmV2aW91cyBtb250aCc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiAnUHJldmlvdXMgeWVhcic7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdQcmV2aW91cyBkZWNhZGUnO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgbmV4dEFyaWEkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZXh0IG1vbnRoJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZXh0IHllYXInO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5ZZWFyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnTmV4dCBkZWNhZGUnO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGVwaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSkgeyB9XG5cbiAgICBwcmV2aW91cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLmdvVG9QcmV2aW91cygpO1xuICAgIH1cblxuICAgIGFzY2VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLmdvVG9QYXJlbnRNb2RlKCk7XG4gICAgfVxuXG4gICAgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLmdvVG9OZXh0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBNb2RlRGlyZWN0aW9uIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IGdyaWRpZnksIG1vbnRoc1Nob3J0LCByYW5nZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIudXRpbHMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTW9udGhWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TW9udGhWaWV3SXRlbVtdW10+KFtbXV0pO1xuICAgIGZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxGb2N1c2VkTW9udGhJdGVtPihudWxsKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9kYXRlcGlja2VyLnllYXIkLnN1YnNjcmliZSh5ZWFyID0+IHRoaXMuY3JlYXRlTW9udGhHcmlkKHllYXIpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMobW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCQubmV4dCh7IG1vbnRoOiBtb250aCwgeWVhcjogeWVhciB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZpZXdwb3J0IHRvIGVuc3VyZSBmb2N1c2VkIG1vbnRoIGlzIHZpc2libGVcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRWaWV3cG9ydFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVNb250aEdyaWQoeWVhcjogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWFkZXJcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRIZWFkZXIoeWVhci50b1N0cmluZygpKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgeWVhciBhbmQgbW9udGhcbiAgICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBtb250aFxuICAgICAgICBjb25zdCBhY3RpdmVNb250aCA9IHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVllYXIgPSB0aGlzLl9kYXRlcGlja2VyLnNlbGVjdGVkJC52YWx1ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIDR4MyBncmlkIG9mIG1vbnRoIG51bWJlcnNcbiAgICAgICAgY29uc3QgbW9udGhzOiBNb250aFZpZXdJdGVtW10gPSByYW5nZSgwLCAxMSkubWFwKG1vbnRoID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbW9udGhzU2hvcnRbbW9udGhdLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgICAgICAgIGlzQ3VycmVudE1vbnRoOiB5ZWFyID09PSBjdXJyZW50WWVhciAmJiBtb250aCA9PT0gY3VycmVudE1vbnRoLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlTW9udGg6IHllYXIgPT09IGFjdGl2ZVllYXIgJiYgbW9udGggPT09IGFjdGl2ZU1vbnRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBtYXAgdGhlc2UgdG8gdGhlIGFwcHJvcHJpYXRlIGZvcm1hdFxuICAgICAgICBjb25zdCBpdGVtczogTW9udGhWaWV3SXRlbVtdW10gPSBncmlkaWZ5KG1vbnRocywgNCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBncmlkXG4gICAgICAgIHRoaXMuZ3JpZCQubmV4dChpdGVtcyk7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZm9jdXNlZCBtb250aCBzZWxlY3QgdGhlIGZpcnN0IG9uZVxuICAgICAgICBpZiAodGhpcy5fZGF0ZXBpY2tlci5tb2RlRGlyZWN0aW9uID09PSBNb2RlRGlyZWN0aW9uLkRlc2NlbmQgJiYgdGhpcy5mb2N1c2VkJC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgc2VsZWN0ZWQgbW9udGggaXMgaW4gdmlld1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRNb250aCA9IG1vbnRocy5maW5kKG1vbnRoID0+IG1vbnRoLmlzQWN0aXZlTW9udGgpO1xuXG4gICAgICAgICAgICB0aGlzLnNldEZvY3VzKHNlbGVjdGVkTW9udGggPyBzZWxlY3RlZE1vbnRoLm1vbnRoIDogMCwgeWVhcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9udGhWaWV3SXRlbSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG1vbnRoOiBudW1iZXI7XG4gICAgeWVhcjogbnVtYmVyO1xuICAgIGlzQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICAgIGlzQWN0aXZlTW9udGg6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9jdXNlZE1vbnRoSXRlbSB7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBEYXRlUGlja2VySGVhZGVyRXZlbnQsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBNb250aFZpZXdJdGVtLCBNb250aFZpZXdTZXJ2aWNlIH0gZnJvbSAnLi9tb250aC12aWV3LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWRhdGUtdGltZS1waWNrZXItbW9udGgtdmlldycsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXJcIiByb2xlPVwiZ3JpZFwiPlxuICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItcm93XCIgKm5nRm9yPVwibGV0IHJvdyBvZiBtb250aFNlcnZpY2UuZ3JpZCQgfCBhc3luYzsgdHJhY2tCeTogdHJhY2tSb3dCeUZuXCIgcm9sZT1cInJvd1wiPlxuXG4gICAgPGJ1dHRvbiByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgY2xhc3M9XCJjYWxlbmRhci1pdGVtXCJcbiAgICAgICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIHJvdzsgdHJhY2tCeTogdHJhY2tNb250aEJ5Rm5cIlxuICAgICAgICAgW2ZvY3VzSWZdPVwiKG1vbnRoU2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8ubW9udGggPT09IGl0ZW0ubW9udGggJiYgKG1vbnRoU2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8ueWVhciA9PT0gaXRlbS55ZWFyXCJcbiAgICAgICAgIFt0YWJpbmRleF09XCJnZXRUYWJiYWJsZShpdGVtKSA/IDAgOiAtMVwiXG4gICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIml0ZW0ubmFtZSArICcgJyArIGl0ZW0ueWVhclwiXG4gICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cIml0ZW0uaXNBY3RpdmVNb250aFwiXG4gICAgICAgICBbY2xhc3MuYWN0aXZlXT1cIml0ZW0uaXNBY3RpdmVNb250aFwiXG4gICAgICAgICBbY2xhc3MuY3VycmVudF09XCJpdGVtLmlzQ3VycmVudE1vbnRoXCJcbiAgICAgICAgIChjbGljayk9XCJzZWxlY3QoaXRlbS5tb250aCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAoa2V5ZG93bi5BcnJvd0xlZnQpPVwiZm9jdXNNb250aChpdGVtLCAtMSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwiZm9jdXNNb250aChpdGVtLCAxKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dVcCk9XCJmb2N1c01vbnRoKGl0ZW0sIC00KTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dEb3duKT1cImZvY3VzTW9udGgoaXRlbSwgNCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG4gICAgICAgICB7eyBpdGVtLm5hbWUgfX1cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgcHJvdmlkZXJzOiBbTW9udGhWaWV3U2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTW9udGhWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZVBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBwdWJsaWMgbW9udGhTZXJ2aWNlOiBNb250aFZpZXdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9kYXRlUGlja2VyLmhlYWRlckV2ZW50JFxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiBldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLm5leHQoKSA6IHRoaXMucHJldmlvdXMoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdvIHRvIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHRoaXMuX2RhdGVQaWNrZXIueWVhciQudmFsdWUgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHbyB0byB0aGUgbmV4dCB5ZWFyXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydFllYXIodGhpcy5fZGF0ZVBpY2tlci55ZWFyJC52YWx1ZSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIG1vbnRoIGluIHRoZSBjYWxlbmRhclxuICAgICAqIEBwYXJhbSBtb250aCB0aGUgaW5kZXggb2YgdGhlIG1vbnRoIHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgZGF5IHBpY2tlclxuICAgICAgICB0aGlzLl9kYXRlUGlja2VyLmdvVG9DaGlsZE1vZGUoKTtcbiAgICB9XG5cbiAgICBmb2N1c01vbnRoKGl0ZW06IE1vbnRoVmlld0l0ZW0sIG1vbnRoT2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRhcmdldE1vbnRoID0gaXRlbS5tb250aCArIG1vbnRoT2Zmc2V0O1xuICAgICAgICBsZXQgdGFyZ2V0WWVhciA9IGl0ZW0ueWVhcjtcblxuICAgICAgICBpZiAodGFyZ2V0TW9udGggPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRNb250aCArPSAxMjtcbiAgICAgICAgICAgIHRhcmdldFllYXIgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRNb250aCA+PSAxMikge1xuICAgICAgICAgICAgdGFyZ2V0TW9udGggLT0gMTI7XG4gICAgICAgICAgICB0YXJnZXRZZWFyICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vbnRoU2VydmljZS5zZXRGb2N1cyh0YXJnZXRNb250aCwgdGFyZ2V0WWVhcik7XG4gICAgfVxuXG4gICAgdHJhY2tSb3dCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgdHJhY2tNb250aEJ5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogTW9udGhWaWV3SXRlbSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtpdGVtLm1vbnRofSAke2l0ZW0ueWVhcn1gO1xuICAgIH1cblxuICAgIGdldFRhYmJhYmxlKGl0ZW06IE1vbnRoVmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMubW9udGhTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5tb250aFNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBmb2N1c2VkIG1vbnRoIGNoZWNrIGlmIHRoaXMgaXMgaXRcbiAgICAgICAgaWYgKGZvY3VzZWQpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZvY3VzZWQgbW9udGggaXMgdmlzaWJsZVxuICAgICAgICAgICAgY29uc3QgaXNGb2N1c2VkTW9udGhWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0ubW9udGggPT09IGZvY3VzZWQubW9udGggJiYgX2l0ZW0ueWVhciA9PT0gZm9jdXNlZC55ZWFyKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpc0ZvY3VzZWRNb250aFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXNlZC5tb250aCA9PT0gaXRlbS5tb250aCAmJiBmb2N1c2VkLnllYXIgPT09IGl0ZW0ueWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSBtb250aCB0aGVuIGNoZWNrIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgbW9udGhcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKG1vbnRoID0+IG1vbnRoLmlzQWN0aXZlTW9udGgpKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaXNBY3RpdmVNb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBtb250aCB0YWJiYWJsZVxuICAgICAgICByZXR1cm4gaXRlbS5tb250aCA9PT0gMDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLXRpbWUtdmlldycsXG4gICAgdGVtcGxhdGU6IGA8dXgtdGltZS1waWNrZXIgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dUaW1lJCB8IGFzeW5jXCJcbiAgICBbdmFsdWVdPVwiZGF0ZXBpY2tlci5zZWxlY3RlZCQgfCBhc3luY1wiXG4gICAgKHZhbHVlQ2hhbmdlKT1cImRhdGVwaWNrZXIuc2VsZWN0ZWQkLm5leHQoJGV2ZW50KVwiXG4gICAgW3Nob3dTZWNvbmRzXT1cImRhdGVwaWNrZXIuc2hvd1NlY29uZHMkIHwgYXN5bmNcIlxuICAgIFtzaG93TWVyaWRpYW5dPVwiZGF0ZXBpY2tlci5zaG93TWVyaWRpYW4kIHwgYXN5bmNcIlxuICAgIFtzaG93U3Bpbm5lcnNdPVwiZGF0ZXBpY2tlci5zaG93U3Bpbm5lcnMkIHwgYXN5bmNcIj5cbjwvdXgtdGltZS1waWNrZXI+XG5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJkYXRlcGlja2VyLnNob3dUaW1lem9uZSQgfCBhc3luY1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtem9uZS1waWNrZXJcIiAqbmdJZj1cImRhdGVwaWNrZXIuc2hvd1NwaW5uZXJzJCB8IGFzeW5jXCI+XG5cbiAgICAgICAgPHV4LXNwaW4tYnV0dG9uXG4gICAgICAgICAgICBjbGFzcz1cInRpbWUtem9uZS1zcGlubmVyXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCIoZGF0ZXBpY2tlci50aW1lem9uZSQgfCBhc3luYykubmFtZVwiXG4gICAgICAgICAgICBbcmVhZE9ubHldPVwidHJ1ZVwiXG4gICAgICAgICAgICAoaW5jcmVtZW50KT1cImluY3JlbWVudFRpbWV6b25lKClcIlxuICAgICAgICAgICAgKGRlY3JlbWVudCk9XCJkZWNyZW1lbnRUaW1lem9uZSgpXCJcbiAgICAgICAgICAgIGlucHV0QXJpYUxhYmVsPVwiVGltZSBab25lXCJcbiAgICAgICAgICAgIGluY3JlbWVudEFyaWFMYWJlbD1cIlN3aXRjaCB0byB0aGUgbmV4dCB0aW1lIHpvbmVcIlxuICAgICAgICAgICAgZGVjcmVtZW50QXJpYUxhYmVsPVwiU3dpdGNoIHRvIHRoZSBwcmV2aW91cyB0aW1lIHpvbmVcIj5cbiAgICAgICAgPC91eC1zcGluLWJ1dHRvbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXpvbmUtcGlja2VyXCIgKm5nSWY9XCIhKGRhdGVwaWNrZXIuc2hvd1NwaW5uZXJzJCB8IGFzeW5jKVwiPlxuXG4gICAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2wgdGltZS16b25lLXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICBbbmdNb2RlbF09XCIoZGF0ZXBpY2tlci50aW1lem9uZSQgfCBhc3luYykubmFtZVwiXG4gICAgICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwic2VsZWN0VGltZXpvbmUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlRpbWV6b25lXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cIihkYXRlcGlja2VyLnRpbWV6b25lJCB8IGFzeW5jKS5uYW1lXCI+XG5cbiAgICAgICAgICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IHpvbmUgb2YgZGF0ZXBpY2tlci50aW1lem9uZXMkIHwgYXN5bmNcIlxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRdPVwiem9uZS5uYW1lID09PSAoZGF0ZXBpY2tlci50aW1lem9uZSQgfCBhc3luYykubmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ6b25lLm5hbWVcIj5cbiAgICAgICAgICAgICAgICB7eyB6b25lPy5uYW1lIH19XG4gICAgICAgICAgICA8L29wdGlvbj5cblxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cblxuPC9uZy1jb250YWluZXI+XG5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFRpbWVWaWV3Q29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHsgfVxuXG4gICAgc2VsZWN0VGltZXpvbmUobmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lcyA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLnZhbHVlO1xuICAgICAgICBcbiAgICAgICAgLy8gZmluZCBtYXRjaGluZyB0aW1lem9uZVxuICAgICAgICBjb25zdCB0aW1lem9uZSA9IHRpbWV6b25lcy5maW5kKF90aW1lem9uZSA9PiBfdGltZXpvbmUubmFtZSA9PT0gbmFtZSk7XG5cbiAgICAgICAgaWYgKHRpbWV6b25lKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVwaWNrZXIuc2V0VGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5jcmVtZW50VGltZXpvbmUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lID0gdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lJC52YWx1ZTtcbiAgICAgICAgY29uc3QgdGltZXpvbmVzID0gdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lcyQudmFsdWU7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFpvbmUgPSB0aW1lem9uZXMuZmluZEluZGV4KHpvbmUgPT4gem9uZS5uYW1lID09PSB0aW1lem9uZS5uYW1lICYmIHpvbmUub2Zmc2V0ID09PSB0aW1lem9uZS5vZmZzZXQpO1xuXG4gICAgICAgIC8vIHRyeSB0byBnZXQgdGhlIHByZXZpb3VzIHpvbmVcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLnNldFRpbWV6b25lKHRpbWV6b25lc1tjdXJyZW50Wm9uZSArIDFdID8gdGltZXpvbmVzW2N1cnJlbnRab25lICsgMV0gOiB0aW1lem9uZXNbY3VycmVudFpvbmVdKTtcbiAgICB9XG5cbiAgICBkZWNyZW1lbnRUaW1lem9uZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLnZhbHVlO1xuICAgICAgICBjb25zdCB0aW1lem9uZXMgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmVzJC52YWx1ZTtcblxuICAgICAgICBjb25zdCBjdXJyZW50Wm9uZSA9IHRpbWV6b25lcy5maW5kSW5kZXgoem9uZSA9PiB6b25lLm5hbWUgPT09IHRpbWV6b25lLm5hbWUgJiYgem9uZS5vZmZzZXQgPT09IHRpbWV6b25lLm9mZnNldCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcHJldmlvdXMgem9uZVxuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuc2V0VGltZXpvbmUodGltZXpvbmVzW2N1cnJlbnRab25lIC0gMV0gPyB0aW1lem9uZXNbY3VycmVudFpvbmUgLSAxXSA6IHRpbWV6b25lc1tjdXJyZW50Wm9uZV0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IERhdGVQaWNrZXJIZWFkZXJFdmVudCwgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IGdyaWRpZnksIHJhbmdlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBZZWFyVmlld1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgZ3JpZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFllYXJWaWV3SXRlbVtdW10+KFtbXV0pO1xuICAgIGZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfeWVhcjogbnVtYmVyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgIGNvbnN0IHllYXIgPSBfZGF0ZXBpY2tlci55ZWFyJC5zdWJzY3JpYmUoX3llYXIgPT4gdGhpcy5jcmVhdGVZZWFyR3JpZChfeWVhcikpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2RhdGVwaWNrZXIuaGVhZGVyRXZlbnQkXG4gICAgICAgICAgICAuc3Vic2NyaWJlKF9ldmVudCA9PiBfZXZlbnQgPT09IERhdGVQaWNrZXJIZWFkZXJFdmVudC5OZXh0ID8gdGhpcy5nb1RvTmV4dERlY2FkZSgpIDogdGhpcy5nb1RvUHJldmlvdXNEZWNhZGUoKSk7XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh5ZWFyKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChldmVudCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEZvY3VzKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQkLm5leHQoeWVhcik7XG4gICAgICAgIHRoaXMuY3JlYXRlWWVhckdyaWQoeWVhcik7XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZpb3VzRGVjYWRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNyZWF0ZVllYXJHcmlkKHRoaXMuX3llYXIgLSAxMCk7XG4gICAgfVxuXG4gICAgZ29Ub05leHREZWNhZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3JlYXRlWWVhckdyaWQodGhpcy5feWVhciArIDEwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVllYXJHcmlkKHllYXI6IG51bWJlciA9IHRoaXMuX3llYXIpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLl95ZWFyID0geWVhcjtcblxuICAgICAgICAvLyBnZXQgdGhlIHllYXJzIHRvIGRpc3BsYXlcbiAgICAgICAgY29uc3QgZGVjYWRlID0gdGhpcy5nZXREZWNhZGUoeWVhcik7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgLy8gcHJvZHVjZSBpdGVtcyBpbiB0aGUgY29ycmVjdCBmb3JtYXRcbiAgICAgICAgY29uc3QgaXRlbXM6IFllYXJWaWV3SXRlbVtdID0gZGVjYWRlLnJhbmdlLm1hcChfeWVhciA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHllYXI6IF95ZWFyLFxuICAgICAgICAgICAgICAgIGlzQ3VycmVudFllYXI6IF95ZWFyID09PSBjdXJyZW50WWVhcixcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZVllYXI6IF95ZWFyID09PSB0aGlzLl9kYXRlcGlja2VyLnllYXIkLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlciB0ZXh0XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0SGVhZGVyKGRlY2FkZS5zdGFydCArICcgLSAnICsgZGVjYWRlLmVuZCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBncmlkXG4gICAgICAgIHRoaXMuZ3JpZCQubmV4dChncmlkaWZ5KGl0ZW1zLCA0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB5ZWFycyBpbiB0aGUgY3VycmVudCBkZWNhZGUgdG8gZGlzcGxheVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RGVjYWRlKHllYXI6IG51bWJlcik6IFllYXJSYW5nZSB7XG5cbiAgICAgICAgLy8gZmlndXJlIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgICAgICBjb25zdCBzdGFydCA9ICh5ZWFyIC0gKHllYXIgJSAxMCkpO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIDk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBudW1iZXJzIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHJhbmdlOiByYW5nZShzdGFydCwgZW5kKSB9O1xuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFllYXJSYW5nZSB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbiAgICByYW5nZTogbnVtYmVyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgWWVhclZpZXdJdGVtIHtcbiAgICB5ZWFyOiBudW1iZXI7XG4gICAgaXNDdXJyZW50WWVhcjogYm9vbGVhbjtcbiAgICBpc0FjdGl2ZVllYXI6IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IFllYXJWaWV3SXRlbSwgWWVhclZpZXdTZXJ2aWNlIH0gZnJvbSAnLi95ZWFyLXZpZXcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LWRhdGUtdGltZS1waWNrZXIteWVhci12aWV3JyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXJcIiByb2xlPVwiZ3JpZFwiPlxuICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItcm93XCIgcm9sZT1cInJvd1wiICpuZ0Zvcj1cImxldCByb3cgb2YgeWVhclNlcnZpY2UuZ3JpZCQgfCBhc3luYzsgdHJhY2tCeTogdHJhY2tSb3dCeUZuXCI+XG5cbiAgICA8YnV0dG9uICpuZ0Zvcj1cImxldCBpdGVtIG9mIHJvdzsgdHJhY2tCeTogdHJhY2tZZWFyQnlGblwiXG4gICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgY2xhc3M9XCJjYWxlbmRhci1pdGVtXCJcbiAgICAgICAgIFtmb2N1c0lmXT1cIih5ZWFyU2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKSA9PT0gaXRlbS55ZWFyXCJcbiAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaXRlbS55ZWFyXCJcbiAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiaXRlbS5pc0FjdGl2ZVllYXJcIlxuICAgICAgICAgW2NsYXNzLmN1cnJlbnRdPVwiaXRlbS5pc0N1cnJlbnRZZWFyXCJcbiAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwiaXRlbS5pc0FjdGl2ZVllYXJcIlxuICAgICAgICAgKGNsaWNrKT1cInNlbGVjdChpdGVtLnllYXIpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cImZvY3VzWWVhcihpdGVtLCAtMSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwiZm9jdXNZZWFyKGl0ZW0sIDEpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cImZvY3VzWWVhcihpdGVtLCAtNCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJmb2N1c1llYXIoaXRlbSwgNCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIFt0YWJpbmRleF09XCJnZXRUYWJiYWJsZShpdGVtKSA/IDAgOiAtMVwiPlxuICAgICAgICAge3sgaXRlbS55ZWFyIH19XG4gICAgPC9idXR0b24+XG4gIDwvZGl2PlxuPC9kaXY+XG5gLFxuICBwcm92aWRlcnM6IFtZZWFyVmlld1NlcnZpY2VdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBZZWFyVmlld0NvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZVBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBwdWJsaWMgeWVhclNlcnZpY2U6IFllYXJWaWV3U2VydmljZSkge31cblxuICBzZWxlY3QoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydFllYXIoeWVhcik7XG5cbiAgICAvLyBzaG93IHRoZSBtb250aCBwaWNrZXJcbiAgICB0aGlzLl9kYXRlUGlja2VyLmdvVG9DaGlsZE1vZGUoKTtcbiAgfVxuXG4gIGZvY3VzWWVhcihpdGVtOiBZZWFyVmlld0l0ZW0sIHllYXJPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMueWVhclNlcnZpY2Uuc2V0Rm9jdXMoaXRlbS55ZWFyICsgeWVhck9mZnNldCk7XG4gIH1cblxuICB0cmFja1Jvd0J5Rm4oaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgdHJhY2tZZWFyQnlGbihpbmRleDogbnVtYmVyLCBpdGVtOiBZZWFyVmlld0l0ZW0pOiBudW1iZXIge1xuICAgIHJldHVybiBpdGVtLnllYXI7XG4gIH1cblxuICBnZXRUYWJiYWJsZShpdGVtOiBZZWFyVmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICBjb25zdCBmb2N1c2VkID0gdGhpcy55ZWFyU2VydmljZS5mb2N1c2VkJC52YWx1ZTtcbiAgICBjb25zdCBncmlkID0gdGhpcy55ZWFyU2VydmljZS5ncmlkJC52YWx1ZTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGEgZm9jdXNlZCB5ZWFyIGNoZWNrIGlmIHRoaXMgaXMgaXRcbiAgICBpZiAoZm9jdXNlZCkge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmb2N1c2VkIHllYXIgaXMgdmlzaWJsZVxuICAgICAgICBjb25zdCBpc0ZvY3VzZWRZZWFyVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKF9pdGVtID0+IF9pdGVtLnllYXIgPT09IGZvY3VzZWQpKTtcblxuICAgICAgICBpZiAoaXNGb2N1c2VkWWVhclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmb2N1c2VkID09PSBpdGVtLnllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBmb2N1c2FibGUgeWVhciB0aGVuIGNoZWNrIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgeWVhclxuICAgIGNvbnN0IGlzU2VsZWN0ZWRZZWFyVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKHllYXIgPT4geWVhci5pc0FjdGl2ZVllYXIpKTtcblxuICAgIGlmIChpc1NlbGVjdGVkWWVhclZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaXNBY3RpdmVZZWFyO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBtb250aCB0YWJiYWJsZVxuICAgIHJldHVybiBncmlkWzBdWzBdLnllYXIgPT09IGl0ZW0ueWVhcjtcbn1cblxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tmb2N1c0lmXSdcbn0pXG5leHBvcnQgY2xhc3MgRm9jdXNJZkRpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoKSBmb2N1c0lmRGVsYXk6IG51bWJlciA9IDA7XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmb2N1c0lmKGZvY3VzOiBib29sZWFuKSB7XG5cbiAgICAgICAgLy8gaWYgYSB0aW1lb3V0IGlzIHBlbmRpbmcgdGhlbiBjYW5jZWwgaXRcbiAgICAgICAgaWYgKCFmb2N1cyAmJiB0aGlzLl90aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2N1cyAmJiB0aGlzLl90aW1lb3V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcy5mb2N1c0lmRGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdGltZW91dDogbnVtYmVyID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c0lmRGlyZWN0aXZlIH0gZnJvbSAnLi9mb2N1cy1pZi5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZvY3VzSWZEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZvY3VzSWZEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIEZvY3VzSWZNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3BpbkJ1dHRvbk1vZHVsZSB9IGZyb20gJy4uL3NwaW4tYnV0dG9uL2luZGV4JztcbmltcG9ydCB7IFRpbWVQaWNrZXJNb2R1bGUgfSBmcm9tICcuLi90aW1lLXBpY2tlci9pbmRleCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJDb25maWcgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuY29uZmlnJztcbmltcG9ydCB7IERheVZpZXdDb21wb25lbnQgfSBmcm9tICcuL2RheS12aWV3L2RheS12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2hlYWRlci9oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IE1vbnRoVmlld0NvbXBvbmVudCB9IGZyb20gJy4vbW9udGgtdmlldy9tb250aC12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaW1lVmlld0NvbXBvbmVudCB9IGZyb20gJy4vdGltZS12aWV3L3RpbWUtdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgWWVhclZpZXdDb21wb25lbnQgfSBmcm9tICcuL3llYXItdmlldy95ZWFyLXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFRpbWVQaWNrZXJNb2R1bGUsXG4gICAgICAgIFNwaW5CdXR0b25Nb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtEYXRlVGltZVBpY2tlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQsIEhlYWRlckNvbXBvbmVudCwgRGF5Vmlld0NvbXBvbmVudCwgTW9udGhWaWV3Q29tcG9uZW50LCBZZWFyVmlld0NvbXBvbmVudCwgVGltZVZpZXdDb21wb25lbnRdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBEYXRlVGltZVBpY2tlckNvbmZpZ1xuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVQaWNrZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1lYm94JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1lYm94LWhlYWRlclwiPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cInV4LWVib3gtaGVhZGVyXCI+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJ1eC1lYm94LWNvbnRlbnRcIj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJ1eC1lYm94LWNvbnRlbnRcIj48L25nLWNvbnRlbnQ+XG48L2Rpdj5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIEVib3hDb21wb25lbnQgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZWJveC1oZWFkZXInXG59KVxuZXhwb3J0IGNsYXNzIEVib3hIZWFkZXJEaXJlY3RpdmUgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZWJveC1jb250ZW50J1xufSlcbmV4cG9ydCBjbGFzcyBFYm94Q29udGVudERpcmVjdGl2ZSB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEVib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlIH0gZnJvbSAnLi9lYm94LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0Vib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtFYm94Q29tcG9uZW50LCBFYm94Q29udGVudERpcmVjdGl2ZSwgRWJveEhlYWRlckRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRWJveE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi9tb2RlbHMvZmFjZXQnO1xuXG5leHBvcnQgY2xhc3MgRmFjZXRTZWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWNldDogRmFjZXQpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBGYWNldERlc2VsZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFjZXQ6IEZhY2V0KSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRmFjZXREZXNlbGVjdEFsbCB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxufVxuXG5leHBvcnQgdHlwZSBGYWNldEV2ZW50ID0gRmFjZXRTZWxlY3QgfCBGYWNldERlc2VsZWN0IHwgRmFjZXREZXNlbGVjdEFsbDsiLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmFjZXRFdmVudCwgRmFjZXRTZWxlY3QsIEZhY2V0RGVzZWxlY3QsIEZhY2V0RGVzZWxlY3RBbGwgfSBmcm9tICcuL2ZhY2V0LWV2ZW50cyc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4vbW9kZWxzL2ZhY2V0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiBgPCEtLSBEaXNwbGF5IEFueSBTZWxlY3RlZCBGYWNldHMgLS0+XG48ZGl2IGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLWNvbnRhaW5lclwiPlxuXG4gICAgPCEtLSBEaXNwbGF5IFRpdGxlIGFuIENsZWFyIEJ1dHRvbiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLWhlYWRlci1jb250YWluZXJcIj5cblxuICAgICAgICA8IS0tIFNob3cgVGhlIFNlbGVjdGVkIFRleHQgLS0+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLWhlYWRlci1sYWJlbFwiPnt7IGhlYWRlciB9fTwvc3Bhbj5cblxuICAgICAgICA8IS0tIEFkZCBhIENsZWFyIEJ1dHRvbiAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZhY2V0cy1zZWxlY3RlZC1jbGVhci1idXR0b25cIiB0YWJpbmRleD1cIjBcIiBbdXhUb29sdGlwXT1cImNsZWFyVG9vbHRpcFwiIHBsYWNlbWVudD1cImxlZnRcIiAoY2xpY2spPVwiZGVzZWxlY3RBbGxGYWNldHMoKVwiXG4gICAgICAgICAgICAoa2V5dXAuZW50ZXIpPVwiZGVzZWxlY3RBbGxGYWNldHMoKVwiICpuZ0lmPVwiZmFjZXRzLmxlbmd0aCA+IDBcIj5cblxuICAgICAgICAgICAgPHN2ZyBjbGFzcz1cImZhY2V0cy1zZWxlY3RlZC1jbGVhci1ncmFwaGljXCIgdmlld0JveD1cIjAgMCAxOSAxMlwiIHNoYXBlLXJlbmRlcmluZz1cImdlb21ldHJpY1ByZWNpc2lvblwiPlxuICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwibGlnaHQtZ3JleVwiIHg9XCIwXCIgeT1cIjJcIiB3aWR0aD1cIjdcIiBoZWlnaHQ9XCIyXCI+PC9yZWN0PlxuICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiZGFyay1ncmV5XCIgeD1cIjBcIiB5PVwiNVwiIHdpZHRoPVwiOVwiIGhlaWdodD1cIjJcIj48L3JlY3Q+XG4gICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJsaWdodC1ncmV5XCIgeD1cIjBcIiB5PVwiOFwiIHdpZHRoPVwiN1wiIGhlaWdodD1cIjJcIj48L3JlY3Q+XG4gICAgICAgICAgICAgICAgPHBhdGggY2xhc3M9XCJkYXJrLWdyZXlcIiBkPVwiTTksMSBoMSBsOSw5IHYxIGgtMSBsLTksLTkgdi0xIFpcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgPHBhdGggY2xhc3M9XCJkYXJrLWdyZXlcIiBkPVwiTTksMTEgdi0xIGw5LC05IGgxIHYxIGwtOSw5IGgtMSBaXCI+PC9wYXRoPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIERpc3BsYXkgVGFncyBGb3IgU2VsZWN0ZWQgSXRlbXMgLS0+XG4gICAgPGRpdiBjbGFzcz1cImZhY2V0cy1zZWxlY3RlZC1saXN0XCIgdXhSZW9yZGVyYWJsZSBbcmVvcmRlcmluZ0Rpc2FibGVkXT1cIiFmYWNldHNSZW9yZGVyYWJsZVwiIFsocmVvcmRlcmFibGVNb2RlbCldPVwiZmFjZXRzXCIgKHJlb3JkZXJhYmxlTW9kZWxDaGFuZ2UpPVwiZmFjZXRzQ2hhbmdlLmVtaXQoZmFjZXRzKVwiPlxuXG4gICAgICAgIDwhLS0gU2hvdyBTZWxlY3RlZCBUYWdzIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmFjZXQtc2VsZWN0ZWQtdGFnXCIgdGFiaW5kZXg9XCIwXCIgKm5nRm9yPVwibGV0IGZhY2V0IG9mIGZhY2V0c1wiIChtb3VzZWRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIiAoY2xpY2spPVwiZGVzZWxlY3RGYWNldChmYWNldClcIiAoa2V5dXAuZW50ZXIpPVwiZGVzZWxlY3RGYWNldChmYWNldClcIlxuICAgICAgICAgICAgIFt1eFJlb3JkZXJhYmxlTW9kZWxdPVwiZmFjZXRcIj5cblxuICAgICAgICAgICAgPCEtLSBEaXNwbGF5IExhYmVsIC0tPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYWNldC1zZWxlY3RlZC10YWctbGFiZWxcIiB1eFJlb3JkZXJhYmxlSGFuZGxlPnt7IGZhY2V0LnRpdGxlIH19PC9zcGFuPlxuXG4gICAgICAgICAgICA8IS0tIERpc3BsYXkgUmVtb3ZlIEljb24gLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1jbG9zZVwiPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gU2hvdyBNZXNzYWdlIEhlcmUgaWYgTm8gRmFjZXRzIFNlbGVjdGVkIC0tPlxuICAgIDxwIGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLW5vbmUtbGFiZWxcIiAqbmdJZj1cImVtcHR5VGV4dCAmJiBmYWNldHMubGVuZ3RoID09PSAwXCI+e3sgZW1wdHlUZXh0IH19PC9wPlxuXG48L2Rpdj5cblxuPCEtLSBBbnkgRmFjZXQgRWxlbWVudHMgU2hvdWxkIGJlIEFkZGVkIEhlcmUgQnkgVXNlciAtLT5cbjxkaXYgY2xhc3M9XCJmYWNldHMtcmVnaW9uXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldENvbnRhaW5lckNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZyA9ICdTZWxlY3RlZDonO1xuICAgIEBJbnB1dCgpIGNsZWFyVG9vbHRpcDogc3RyaW5nID0gJ0NsZWFyIEFsbCc7XG4gICAgQElucHV0KCkgZW1wdHlUZXh0OiBzdHJpbmcgPSAnTm8gSXRlbXMnO1xuICAgIEBJbnB1dCgpIGZhY2V0czogRmFjZXRbXSA9IFtdO1xuICAgIEBJbnB1dCgpIGZhY2V0c1Jlb3JkZXJhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgZmFjZXRzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmFjZXRbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZhY2V0W10+KCk7XG4gICAgQE91dHB1dCgpIGV2ZW50czogRXZlbnRFbWl0dGVyPEZhY2V0RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldEV2ZW50PigpO1xuXG4gICAgc2VsZWN0RmFjZXQoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG4gICAgICAgIC8vIHB1c2ggdGhlIGZhY2V0IG9uIHRvIHRoZSBsaXN0XG4gICAgICAgIHRoaXMuZmFjZXRzLnB1c2goZmFjZXQpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdHdvIHdheSBiaW5kaW5nXG4gICAgICAgIHRoaXMuZmFjZXRzQ2hhbmdlLmVtaXQodGhpcy5mYWNldHMpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0U2VsZWN0KGZhY2V0KSk7XG4gICAgfVxuXG4gICAgZGVzZWxlY3RGYWNldChmYWNldDogRmFjZXQpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBpbiB0aGUgc2VsZWN0ZWQgYXJyYXlcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuZmFjZXRzLmZpbmRJbmRleChzZWxlY3RlZEZhY2V0ID0+IGZhY2V0ID09PSBzZWxlY3RlZEZhY2V0KTtcblxuICAgICAgICAvLyBpZiBtYXRjaCB0aGVyZSB3YXMgbm8gbWF0Y2ggdGhlbiBmaW5pc2hcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbGFzdCBpdGVtXG4gICAgICAgIHRoaXMuZmFjZXRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdHdvIHdheSBiaW5kaW5nXG4gICAgICAgIHRoaXMuZmFjZXRzQ2hhbmdlLmVtaXQodGhpcy5mYWNldHMpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0RGVzZWxlY3QoZmFjZXQpKTtcbiAgICB9XG5cbiAgICBkZXNlbGVjdEFsbEZhY2V0cygpOiB2b2lkIHtcblxuICAgICAgICAvLyBlbXB0eSB0aGUgc2VsZWN0ZWQgYXJyYXlcbiAgICAgICAgdGhpcy5mYWNldHMgPSBbXTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHR3byB3YXkgYmluZGluZ1xuICAgICAgICB0aGlzLmZhY2V0c0NoYW5nZS5lbWl0KHRoaXMuZmFjZXRzKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldERlc2VsZWN0QWxsKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJpZ2dlckV2ZW50KGV2ZW50OiBGYWNldEV2ZW50KSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLm5leHQoZXZlbnQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdCwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBGYWNldENvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXREZXNlbGVjdCwgRmFjZXREZXNlbGVjdEFsbCwgRmFjZXRFdmVudCwgRmFjZXRTZWxlY3QgfSBmcm9tICcuLi8uLi9mYWNldC1ldmVudHMnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWJhc2UnLFxuICAgIHRlbXBsYXRlOiAnJyxcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgc2VsZWN0ZWQ6IEZhY2V0W10gPSBbXTtcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGYWNldFtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXRbXT4oKTtcbiAgICBAT3V0cHV0KCkgZXZlbnRzOiBTdWJqZWN0PEZhY2V0RXZlbnQ+ID0gbmV3IFN1YmplY3Q8RmFjZXRFdmVudD4oKTtcblxuICAgIHByb3RlY3RlZCBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKCBASG9zdCgpIHByaXZhdGUgZmFjZXRDb250YWluZXI6IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50LCBwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICBpZiAoZmFjZXRDb250YWluZXIpIHtcblxuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGFueSBkZXNlbGVjdCBldmVudHMgZnJvbSB0aGUgZmFjZXQgY29udGFpbmVyXG4gICAgICAgICAgICBmYWNldENvbnRhaW5lci5ldmVudHMucGlwZShcbiAgICAgICAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBGYWNldERlc2VsZWN0KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIoKGV2ZW50OiBGYWNldERlc2VsZWN0KSA9PiAhIXRoaXMuc2VsZWN0ZWQuZmluZChmYWNldCA9PiBmYWNldCA9PT0gZXZlbnQuZmFjZXQpKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoKGV2ZW50OiBGYWNldERlc2VsZWN0KSA9PiB0aGlzLmRlc2VsZWN0RmFjZXQoZXZlbnQuZmFjZXQpKTtcblxuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGFueSBkZXNlbGVjdCBhbGwgZXZlbnRzIGZyb20gZmFjZXQgY29udGFpbmVyXG4gICAgICAgICAgICBmYWNldENvbnRhaW5lci5ldmVudHMucGlwZShcbiAgICAgICAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBGYWNldERlc2VsZWN0QWxsKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoXyA9PiB0aGlzLmRlc2VsZWN0QWxsKCkpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgc2hvdWxkIGJlIGFueSBmYWNldHMgaW5pdGlhbGx5IHNlbGVjdGVkXG4gICAgICAgIGlmICh0aGlzLmZhY2V0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLmZvckVhY2goZmFjZXQgPT4gdGhpcy5mYWNldENvbnRhaW5lci5zZWxlY3RGYWNldChmYWNldCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdEZhY2V0KGZhY2V0OiBGYWNldCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZSBmYWNldCBpcyBkaXNhYmxlZCBpdCBzaG91bGQgbm90IGJlIHNlbGVjdGVkXG4gICAgICAgIGlmIChmYWNldC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBmYWNldCB0byB0aGUgbGlzdCBvZiBzZWxlY3RlZCBmYWNldHNcbiAgICAgICAgdGhpcy5zZWxlY3RlZC5wdXNoKGZhY2V0KTtcblxuICAgICAgICAvLyBzZW5kIHRoZSBuZXcgdmFsdWUgdG8gdGhlIGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuXG4gICAgICAgIC8vIGZpcmUgdGhlIGV2ZW50IHRvIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldFNlbGVjdChmYWNldCkpO1xuXG4gICAgICAgIC8vIHRlbGwgdGhlIGZhY2V0IGNvbnRhaW5lciBhYm91dCB0aGUgc2VsZWN0ZWQgZmFjZXRcbiAgICAgICAgaWYgKHRoaXMuZmFjZXRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjZXRDb250YWluZXIuc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3RGYWNldChmYWNldDogRmFjZXQpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIGZhY2V0IHRvIHJlbW92ZVxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnNlbGVjdGVkLmZpbmRJbmRleChzZWxlY3RlZEZhY2V0ID0+IHNlbGVjdGVkRmFjZXQgPT09IGZhY2V0KTtcblxuICAgICAgICAvLyBvbmx5IGNvbnRpbnVlIGlmIGZhY2V0IGlzIGZvdW5kXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBmYWNldCBmcm9tIHRoZSBzZWxlY3RlZCBsaXN0XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZXMgdG8gc2VsZWN0ZWQgZXZlbnQgZW1pdHRlclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHRoZSBldmVudCB0byB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0RGVzZWxlY3QoZmFjZXQpKTtcblxuICAgICAgICAgICAgLy8gZGVzZWxlY3QgdGhlIGZhY2V0IGluIHRoZSBmYWNldCBjb250YWluZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmZhY2V0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWNldENvbnRhaW5lci5kZXNlbGVjdEZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgc2VsZWN0ZWQgZmFjZXRzXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBbXTtcblxuICAgICAgICAvLyBmaXJlIHRoZSBldmVudCB0byB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXREZXNlbGVjdEFsbCgpKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBjaGFuZ2VzIHRvIHRoZSBzZWxlY3RlZCBldmVudCBlbWl0dGVyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICB0b2dnbGVGYWNldFNlbGVjdGlvbihmYWNldDogRmFjZXQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGUgZmFjZXQgaXMgc2VsZWN0ZWQgdGhlbiBkZXNlbGVjdCAtIG90aGVyd2lzZSBzZWxlY3QgaXRcbiAgICAgICAgaWYgKHRoaXMuaXNGYWNldFNlbGVjdGVkKGZhY2V0KSkge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEZhY2V0KGZhY2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpc0ZhY2V0U2VsZWN0ZWQoZmFjZXQ6IEZhY2V0KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIGRldGVybWluZSBpZiBhIGZhY2V0IGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgICAgICByZXR1cm4gISF0aGlzLnNlbGVjdGVkLmZpbmQoc2VsZWN0ZWRGYWNldCA9PiBzZWxlY3RlZEZhY2V0ID09PSBmYWNldCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRXZlbnQoZXZlbnQ6IEZhY2V0RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dChldmVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxzcGFuIGNsYXNzPVwiZmFjZXQtaGVhZGVyLXRpdGxlXCI+e3sgaGVhZGVyIH19PC9zcGFuPlxuPHNwYW4gY2xhc3M9XCJocGUtaWNvblwiIFtjbGFzcy5ocGUtZG93bl09XCJleHBhbmRlZFwiIFtjbGFzcy5ocGUtcHJldmlvdXNdPVwiIWV4cGFuZGVkXCIgKm5nSWY9XCJjYW5FeHBhbmRcIj48L3NwYW4+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAgICAgJyhjbGljayknOiAndG9nZ2xlRXhwYW5kKCknLFxuICAgICAgICAnKGtleXVwLmVudGVyKSc6ICd0b2dnbGVFeHBhbmQoKSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0SGVhZGVyQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNhbkV4cGFuZDogYm9vbGVhbiA9IHRydWU7ICAgIFxuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBAT3V0cHV0KCkgZXhwYW5kZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIHRvZ2dsZUV4cGFuZCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBub3QgZXhwYW5kYWJsZSB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuY2FuRXhwYW5kKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmFjZXRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi4vbW9kZWxzL2ZhY2V0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1jaGVjay1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDx1eC1mYWNldC1oZWFkZXIgW2hlYWRlcl09XCJoZWFkZXJcIiBbKGV4cGFuZGVkKV09XCJleHBhbmRlZFwiPjwvdXgtZmFjZXQtaGVhZGVyPlxuXG48IS0tIENyZWF0ZSBhIGNvbnRhaW5lciB3aGljaCB3aWxsIHNob3cgd2hlbiBzZWN0aW9uIGlzIGV4cGFuZGVkIC0tPlxuPGRpdiBjbGFzcz1cImZhY2V0LWNoZWNrLWxpc3QtY29udGFpbmVyXCIgW2NsYXNzLmZhY2V0LWNoZWNrLWxpc3Qtc2Nyb2xsYmFyXT1cInNjcm9sbGJhclwiICpuZ0lmPVwiZXhwYW5kZWRcIj5cblxuICAgIDwhLS0gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcG9zc2libGUgZmFjZXQgLS0+XG4gICAgPGRpdiBjbGFzcz1cImZhY2V0LWNoZWNrLWxpc3QtaXRlbVwiICpuZ0Zvcj1cImxldCBmYWNldCBvZiBmYWNldHNcIiBbY2xhc3MuZmFjZXQtYWN0aXZlXT1cImlzRmFjZXRTZWxlY3RlZChmYWNldClcIiB0YWJpbmRleD1cIjBcIlxuICAgICAgICAoY2xpY2spPVwidG9nZ2xlRmFjZXRTZWxlY3Rpb24oZmFjZXQpXCIgKGtleXVwLmVudGVyKT1cInRvZ2dsZUZhY2V0U2VsZWN0aW9uKGZhY2V0KVwiIFtjbGFzcy5kaXNhYmxlZF09XCJmYWNldC5kaXNhYmxlZFwiPlxuXG4gICAgICAgIDwhLS0gU2hvdyBjaGVjayBpY29uIHRvIGluZGljYXRlIHRoZSBzdGF0ZSAtLT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJmYWNldC1jaGVjay1saXN0LWl0ZW0tY2hlY2tcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWFjdGl2ZVwiPjwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDwhLS0gRGlzcGxheSB0aGUgdGl0bGUgLS0+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtY2hlY2stbGlzdC1pdGVtLXRpdGxlXCI+e3sgZmFjZXQudGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgPCEtLSBEaXNwbGF5IHRoZSBjb3VudCBpZiBzcGVjaWZpZWQgLS0+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtY2hlY2stbGlzdC1pdGVtLWNvdW50XCIgKm5nSWY9XCJmYWNldC5jb3VudCAhPT0gdW5kZWZpbmVkXCI+KHt7IGZhY2V0LmNvdW50IH19KTwvc3Bhbj5cbiAgICA8L2Rpdj5cbjwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRDaGVja0xpc3RDb21wb25lbnQgZXh0ZW5kcyBGYWNldEJhc2VDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZmFjZXRzOiBGYWNldFtdID0gW107XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2Nyb2xsYmFyOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbiA9IHRydWU7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUeXBlYWhlYWRNYXRjaCB9IGZyb20gJ25neC1ib290c3RyYXAvdHlwZWFoZWFkJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEZhY2V0QmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2UvZmFjZXQtYmFzZS9mYWNldC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uL21vZGVscy9mYWNldCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtdHlwZWFoZWFkLWxpc3QnLFxuICAgIHRlbXBsYXRlOiBgPHV4LWZhY2V0LWhlYWRlciBbaGVhZGVyXT1cImhlYWRlclwiIFsoZXhwYW5kZWQpXT1cImV4cGFuZGVkXCI+PC91eC1mYWNldC1oZWFkZXI+XG5cbjxkaXYgY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtbGlzdC1jb250YWluZXJcIiAqbmdJZj1cImV4cGFuZGVkXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtc2VsZWN0ZWQtY29udGFpbmVyXCIgKm5nSWY9XCJzdWdnZXN0aW9ucz8ubGVuZ3RoID4gMFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtbGlzdC1zZWxlY3RlZC1vcHRpb25cIiB0YWJpbmRleD1cIjBcIiAqbmdGb3I9XCJsZXQgZmFjZXQgb2Ygc3VnZ2VzdGlvbnNcIiAoY2xpY2spPVwidG9nZ2xlRmFjZXRTZWxlY3Rpb24oZmFjZXQpXCJcbiAgICAgICAgICAgIChrZXl1cC5lbnRlcik9XCJ0b2dnbGVGYWNldFNlbGVjdGlvbihmYWNldClcIj5cblxuICAgICAgICAgICAgPHV4LWNoZWNrYm94IFtjbGlja2FibGVdPVwiZmFsc2VcIiBbdmFsdWVdPVwiaXNGYWNldFNlbGVjdGVkKGZhY2V0KVwiIFtzaW1wbGlmaWVkXT1cInNpbXBsaWZpZWRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LXNlbGVjdGVkLW9wdGlvbi10aXRsZVwiPnt7IGZhY2V0LnRpdGxlIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtc2VsZWN0ZWQtb3B0aW9uLWNvdW50XCI+KHt7IGZhY2V0LmNvdW50IH19KTwvc3Bhbj5cbiAgICAgICAgICAgIDwvdXgtY2hlY2tib3g+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtbGlzdC1jb250cm9sXCI+XG5cbiAgICAgICAgPCEtLSBDcmVhdGUgVHlwZWFoZWFkIENvbnRyb2wgLS0+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgW3BsYWNlaG9sZGVyXT1cInR5cGVhaGVhZENvbmZpZz8ucGxhY2Vob2xkZXJcIiBbdHlwZWFoZWFkXT1cInR5cGVhaGVhZE9wdGlvbnNcIiBbKG5nTW9kZWwpXT1cInNlYXJjaFF1ZXJ5XCJcbiAgICAgICAgICAgIFt0eXBlYWhlYWRNaW5MZW5ndGhdPVwidHlwZWFoZWFkQ29uZmlnPy5taW5DaGFyYWN0ZXJzXCIgW3R5cGVhaGVhZE9wdGlvbnNMaW1pdF09XCJ0eXBlYWhlYWRDb25maWc/Lm1heFJlc3VsdHNcIiBbdHlwZWFoZWFkV2FpdE1zXT1cInR5cGVhaGVhZENvbmZpZz8uZGVsYXlcIlxuICAgICAgICAgICAgKHR5cGVhaGVhZE9uU2VsZWN0KT1cInNlbGVjdE9wdGlvbigkZXZlbnQpXCIgW3R5cGVhaGVhZEl0ZW1UZW1wbGF0ZV09XCJmYWNldE9wdGlvblRlbXBsYXRlXCIgKGtleXVwLkFycm93VXApPVwic2Nyb2xsVG9Gb2N1c2VkKClcIiAoa2V5dXAuQXJyb3dEb3duKT1cInNjcm9sbFRvRm9jdXNlZCgpXCI+XG5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjZmFjZXRPcHRpb25UZW1wbGF0ZSBsZXQtbW9kZWw9XCJpdGVtXCIgbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAgICA8cCBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LW9wdGlvblwiPjxzcGFuIFtpbm5lckhUTUxdPVwibW9kZWwudGl0bGUgfCBmYWNldFR5cGVhaGVhZEhpZ2hsaWdodDogc2VhcmNoUXVlcnlcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtb3B0aW9uLWNvdW50XCJcbiAgICAgICAgICAgICpuZ0lmPVwibW9kZWwuY291bnRcIj4oe3sgbW9kZWwuY291bnQgfX0pPC9zcGFuPjwvcD5cbjwvbmctdGVtcGxhdGU+YFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldFR5cGVhaGVhZExpc3RDb21wb25lbnQgZXh0ZW5kcyBGYWNldEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgQElucHV0KCkgZmFjZXRzOiBGYWNldFtdIHwgT2JzZXJ2YWJsZTxGYWNldFtdPjtcbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgdHlwZWFoZWFkQ29uZmlnOiBGYWNldFR5cGVhaGVhZExpc3RDb25maWcgPSB7fTtcbiAgICBASW5wdXQoKSBzdWdnZXN0aW9uczogRmFjZXRbXSA9IFtdO1xuICAgIEBJbnB1dCgpIHNpbXBsaWZpZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgdHlwZWFoZWFkT3B0aW9uczogT2JzZXJ2YWJsZTxGYWNldFtdPjtcbiAgICBzZWFyY2hRdWVyeTogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSBfbmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBfZGVmYXVsdFR5cGVhaGVhZENvbmZpZzogRmFjZXRUeXBlYWhlYWRMaXN0Q29uZmlnID0ge1xuICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgIG1heFJlc3VsdHM6IDUwLFxuICAgICAgICBtaW5DaGFyYWN0ZXJzOiAxXG4gICAgfTtcblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIC8vIHdyYXAgdGhlIG9ic2VydmFibGUgYW5kIGZpbHRlciBvdXQgYW55IGFscmVhZHkgc2VsZWN0ZWQgaXRlbXMgb3IgYW55IGRpc2FibGVkIGl0ZW1zXG4gICAgICAgIGlmICh0aGlzLmZhY2V0cyBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGFuIG9ic2VydmFibGUgb2YgZGF0YVxuICAgICAgICAgICAgdGhpcy50eXBlYWhlYWRPcHRpb25zID0gZnJvbSh0aGlzLmZhY2V0cykucGlwZShtYXAoKGZhY2V0czogRmFjZXRbXSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGRpc2FibGVkIGZhY2V0cywgc2VsZWN0ZWQgZmFjZXRzIGFuZCBmYWNldHMgdGhhdCBkb250IG1hdGNoIHNlYXJjaCB0ZXJtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY2V0cy5maWx0ZXIoZmFjZXQgPT4gIWZhY2V0LmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZhY2V0ID0+ICF0aGlzLnNlbGVjdGVkLmZpbmQoc2VsZWN0ZWRGYWNldCA9PiBzZWxlY3RlZEZhY2V0ID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmFjZXQgPT4gZmFjZXQudGl0bGUudG9VcHBlckNhc2UoKS5pbmNsdWRlcyh0aGlzLnNlYXJjaFF1ZXJ5LnRvVXBwZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgYW4gYXJyYXkgb2YgZGF0YVxuICAgICAgICAgICAgdGhpcy50eXBlYWhlYWRPcHRpb25zID0gb2YodGhpcy5mYWNldHMpLnBpcGUobWFwKChmYWNldHM6IEZhY2V0W10pID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBkaXNhYmxlZCBmYWNldHMsIHNlbGVjdGVkIGZhY2V0cyBhbmQgZmFjZXRzIHRoYXQgZG9udCBtYXRjaCBzZWFyY2ggdGVybVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWNldHMuZmlsdGVyKGZhY2V0ID0+ICFmYWNldC5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmYWNldCA9PiAhdGhpcy5zZWxlY3RlZC5maW5kKHNlbGVjdGVkRmFjZXQgPT4gc2VsZWN0ZWRGYWNldCA9PT0gZmFjZXQpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZhY2V0ID0+IGZhY2V0LnRpdGxlLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXModGhpcy5zZWFyY2hRdWVyeS50b1VwcGVyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGZvciB0eXBlYWhlYWQgY29uZmlnXG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5fZGVmYXVsdFR5cGVhaGVhZENvbmZpZykge1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwcm9wIGhhcyBiZWVuIGRlZmluZWQgaW4gdGhlIHVzZXJzIHR5cGVhaGVhZCBjb25maWcgLSBpZiBub3Qgc2V0IGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZENvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVhaGVhZENvbmZpZ1twcm9wXSA9IHRoaXMuX2RlZmF1bHRUeXBlYWhlYWRDb25maWdbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RPcHRpb24odHlwZWFoZWFkT3B0aW9uOiBUeXBlYWhlYWRNYXRjaCkge1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBpdGVtIGlzIG5vdCBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuZmluZChmYWNldCA9PiBmYWNldCA9PT0gdHlwZWFoZWFkT3B0aW9uLml0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWxlY3QgdGhlIGZhY2V0XG4gICAgICAgIHRoaXMuc2VsZWN0RmFjZXQodHlwZWFoZWFkT3B0aW9uLml0ZW0pO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSB0eXBlYWhlYWRcbiAgICAgICAgdGhpcy5zZWFyY2hRdWVyeSA9ICcnO1xuICAgIH1cblxuICAgIHNjcm9sbFRvRm9jdXNlZCgpOiB2b2lkIHtcblxuICAgICAgICBsZXQgZHJvcGRvd24gPSB0aGlzLl9uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kcm9wZG93bi1tZW51Jyk7XG5cbiAgICAgICAgLy8gZGVsYXkgdG8gYWxsb3cgdGhlIHR5cGVhaGVhZCB1aSB0byB1cGRhdGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWxlbWVudCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgIGxldCBhY3RpdmVFbGVtZW50ID0gZHJvcGRvd24ucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLW1lbnUgPiBsaS5hY3RpdmUnKTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGVsZW1lbnQgaXMgbm90IGluIHZpZXdcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudEJvdW5kcyA9IGFjdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGRyb3Bkb3duQm91bmRzID0gZHJvcGRvd24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEJvdW5kcy50b3AgPCBkcm9wZG93bkJvdW5kcy50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uc2Nyb2xsVG9wICs9IGVsZW1lbnRCb3VuZHMudG9wIC0gZHJvcGRvd25Cb3VuZHMudG9wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Qm91bmRzLmJvdHRvbSA+IGRyb3Bkb3duQm91bmRzLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zY3JvbGxUb3AgKz0gZWxlbWVudEJvdW5kcy5ib3R0b20gLSBkcm9wZG93bkJvdW5kcy5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGYWNldFR5cGVhaGVhZExpc3RDb25maWcge1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIG1pbkNoYXJhY3RlcnM/OiBudW1iZXI7XG4gICAgbWF4UmVzdWx0cz86IG51bWJlcjtcbiAgICBkZWxheT86IG51bWJlcjtcbn1cblxuQFBpcGUoe1xuICAgIG5hbWU6ICdmYWNldFR5cGVhaGVhZEhpZ2hsaWdodCdcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRUeXBlYWhlYWRIaWdobGlnaHQgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgc2VhcmNoUXVlcnk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZWdleCA9IG5ldyBSZWdFeHAoc2VhcmNoUXVlcnksICdpJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlZ2V4LCBgPGIgY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtaGlnaGxpZ2h0ZWRcIj4keyB2YWx1ZS5tYXRjaChyZWdleCkgfTwvYj5gKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIFRlbXBsYXRlUmVmLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuY2hvclBsYWNlbWVudCB9IGZyb20gJy4vdG9vbHRpcC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbmxldCB1bmlxdWVUb29sdGlwSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC10b29sdGlwJyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidG9vbHRpcCBpblwiIFtpZF09XCJpZFwiIFthdHRyLnJvbGVdPVwicm9sZVwiIFtuZ0NsYXNzXT1cIltwbGFjZW1lbnQsIGN1c3RvbUNsYXNzXVwiPlxuICAgIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIiAoY2RrT2JzZXJ2ZUNvbnRlbnQpPVwicmVwb3NpdGlvbigpXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZVJlZlwiPnt7IGNvbnRlbnQgfX08L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImlzVGVtcGxhdGVSZWZcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb250ZW50XCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cImNvbnRleHRcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvZGl2PmAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFRvb2x0aXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIC8qKiBEZWZpbmUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdG9vbHRpcCAqL1xuICBpZDogc3RyaW5nID0gYHV4LXRvb2x0aXAtJHsrK3VuaXF1ZVRvb2x0aXBJZH1gO1xuXG4gIC8qKiBEZWZpbmUgdGhlIHRvb2x0aXAgcm9sZSAqL1xuICByb2xlOiBzdHJpbmcgPSAndG9vbHRpcCc7XG5cbiAgLyoqIFRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwLCBlaXRoZXIgYSBzdHJpbmcgb3IgYSBUZW1wbGF0ZVJlZiBmb3IgZnVydGhlciBjdXN0b21pemF0aW9uICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIEFsbG93IHRoZSB1c2VyIHRvIHN1cHBseSBhIGNvbnRleHQgZm9yIHRoZSB0b29sdGlwIFRlbXBsYXRlUmVmICovXG4gIGNvbnRleHQ6IGFueTtcblxuICAvKiogVGhlIHBvc2l0aW9uIHRoZSB0b29sdGlwIHNob3VsZCBkaXNwbGF5IHJlbGF0aXZlIHRvIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgKi9cbiAgcGxhY2VtZW50OiBBbmNob3JQbGFjZW1lbnQ7XG5cbiAgLyoqIEFsbG93IGEgY3VzdG9tIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSB0b29sdGlwIHRvIGFsbG93IGN1c3RvbSBzdHlsaW5nICovXG4gIGN1c3RvbUNsYXNzOiBzdHJpbmcgPSAnJztcblxuICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBjb250ZW50IGlzIGEgc3RyaW5nIG9yIGEgVGVtcGxhdGVSZWYgKi9cbiAgaXNUZW1wbGF0ZVJlZjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBFbWl0IHdoZW4gdGhlIHRvb2x0aXAgbmVlZCB0byB1cGRhdGUgaXQncyBwb3NpdGlvbiAqL1xuICByZXBvc2l0aW9uJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHt9XG5cbiAgLyoqIENsZWFudXAgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXBvc2l0aW9uJC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqIEluZm9ybSB0aGUgcGFyZW50IGRpcmVjdGl2ZSB0aGF0IGl0IG5lZWRzIHRvIHJlY2FsdWxhdGUgdGhlIHBvc2l0aW9uICovXG4gIHJlcG9zaXRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5yZXBvc2l0aW9uJC5uZXh0KCk7XG4gIH1cblxuICAvKiogVGhpcyB3aWxsIHVwZGF0ZSB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uICovXG4gIHNldENvbnRlbnQoY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pik6IHZvaWQge1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5pc1RlbXBsYXRlUmVmID0gY29udGVudCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHRvb2x0aXAgcGxhY2VtZW50IGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gKi9cbiAgc2V0UGxhY2VtZW50KHBsYWNlbWVudDogQW5jaG9yUGxhY2VtZW50KSB7XG5cbiAgICBpZiAoIXBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFRoaXMgd2lsbCBzZXQgYSBjdXN0b20gY2xhc3Mgb24gdGhlIHRvb2x0aXAgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRDbGFzcyhjdXN0b21DbGFzczogc3RyaW5nKTogdm9pZCB7XG5cbiAgICBpZiAoIWN1c3RvbUNsYXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXN0b21DbGFzcyA9IGN1c3RvbUNsYXNzO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFVwZGF0ZXMgdGhlIGNvbnRleHQgdXNlZCBieSB0aGUgVGVtcGxhdGVSZWYgKi9cbiAgc2V0Q29udGV4dChjb250ZXh0OiBhbnkpOiB2b2lkIHtcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogU3BlY2lmeSB0aGUgdG9vbHRpcCByb2xlIGF0dHJpYnV0ZSAqL1xuICBzZXRSb2xlKHJvbGU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgaWYgKCFyb2xlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRvb2x0aXBDb21wb25lbnQgfSBmcm9tICcuL3Rvb2x0aXAuY29tcG9uZW50JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVG9vbHRpcFNlcnZpY2Uge1xuICAgIHNob3duJCA9IG5ldyBTdWJqZWN0PFRvb2x0aXBDb21wb25lbnQ+KCk7XG59IiwiaW1wb3J0IHsgT3JpZ2luQ29ubmVjdGlvblBvc2l0aW9uLCBPdmVybGF5LCBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uLCBPdmVybGF5UmVmLCBTY3JvbGxEaXNwYXRjaGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tcG9uZW50UG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFJlbmRlcmVyMiwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRvb2x0aXBDb21wb25lbnQgfSBmcm9tICcuL3Rvb2x0aXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBTZXJ2aWNlIH0gZnJvbSAnLi90b29sdGlwLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRvb2x0aXBdJyxcbiAgICBleHBvcnRBczogJ3V4LXRvb2x0aXAnXG59KVxuZXhwb3J0IGNsYXNzIFRvb2x0aXBEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIC8qKiBDb250YWlucyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBvciBhIFRlbXBsYXRlUmVmIGZvciBtb3JlIGRldGFpbGVkIGNvbnRlbnQgKi9cbiAgICBASW5wdXQoJ3V4VG9vbHRpcCcpIGNvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKiogQWxsb3cgdGhlIHRvb2x0aXAgdG8gYmUgY29uZGl0aW9uYWxseSBkaXNhYmxlZCAqL1xuICAgIEBJbnB1dCgndG9vbHRpcERpc2FibGVkJykgZGlzYWJsZWQ6IGJvb2xlYW47XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIGN1c3RvbSBjbGFzcyB0byB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgndG9vbHRpcENsYXNzJykgY3VzdG9tQ2xhc3M6IHN0cmluZyA9ICcnO1xuXG4gICAgLyoqIEFsbCB0aGUgdXNlciB0byBhZGQgYSByb2xlIHRvIHRoZSB0b29sdGlwIC0gZGVmYXVsdCBpcyB0b29sdGlwICovXG4gICAgQElucHV0KCd0b29sdGlwUm9sZScpIHJvbGU6IHN0cmluZyA9ICd0b29sdGlwJztcblxuICAgIC8qKiBQcm92aWRlIHRoZSBUZW1wbGF0ZVJlZiBhIGNvbnRleHQgb2JqZWN0ICovXG4gICAgQElucHV0KCd0b29sdGlwQ29udGV4dCcpIGNvbnRleHQ6IGFueSA9IHt9O1xuXG4gICAgLyoqIERlbGF5IHRoZSBzaG93aW5nIG9mIHRoZSB0b29sdGlwIGJ5IGEgbnVtYmVyIG9mIG1pbGlzZWNvbmRzICovXG4gICAgQElucHV0KCd0b29sdGlwRGVsYXknKSBkZWxheTogbnVtYmVyID0gMDtcblxuICAgIC8qKiBQcm9ncmFtbWF0aWNhbGx5IHNob3cgYW5kIGhpZGUgdGhlIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoKSBpc09wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBDdXN0b21pemUgaG93IHRoZSB0b29sdGlwIHNob3VsZCBiZSBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50ICovXG4gICAgQElucHV0KCkgcGxhY2VtZW50OiBBbmNob3JQbGFjZW1lbnQgPSAndG9wJztcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgc2hvdyB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgpIHNob3dUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXTtcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgaGlkZSB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgpIGhpZGVUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ21vdXNlbGVhdmUnLCAnYmx1ciddO1xuXG4gICAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHRvb2x0aXAgaXMgc2hvd24gKi9cbiAgICBAT3V0cHV0KCkgc2hvd24gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdHMgYSBldmVudCB3aGVuIHRoZSB0b29sdGlwIGlzIGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKSBoaWRkZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogQWxsb3cgdHdvIHdheSBiaW5kaW5nIHRvIHRyYWNrIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB0b29sdGlwICovXG4gICAgQE91dHB1dCgpIGlzT3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBLZWVwIHRyYWNrIG9mIHRoZSB0b29sdGlwIHZpc2liaWxpdHkgKi9cbiAgICBpc1Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgQ0RLIHBvcnRhbCBjb250YWluaW5nIHRoZSBvdmVybGF5ICovXG4gICAgcHJvdGVjdGVkIF9wb3J0YWw6IENvbXBvbmVudFBvcnRhbDxUb29sdGlwQ29tcG9uZW50PjtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSB0aGUgdG9vbHRpcCB3aWxsIGJlIGluc2VydGVkIGludG8gKi9cbiAgICBwcm90ZWN0ZWQgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSB0b29sdGlwIGNvbXBvbmVudCB3aGVuIGNyZWF0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX2luc3RhbmNlOiBUb29sdGlwQ29tcG9uZW50O1xuXG4gICAgLyoqIFRoaXMgd2lsbCBlbWl0IHdoZW4gdGhlIGRpcmVjdGl2ZSBpcyBkZXN0cm95ZWQgYWxsb3dpbmcgdXMgdG8gdW5zdWJzY3JpYmUgYWxsIHN1YnNjcmlwdGlvbnMgYXV0b21hdGljYWxseSAqL1xuICAgIHByb3RlY3RlZCBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBTdG9yZSB0aGUgdGltZW91dCBpbnRlcnZhbCBmb3IgY2FuY2VsYXRpb24gKi9cbiAgICBwcml2YXRlIF9zaG93VGltZW91dElkOiBudW1iZXI7XG5cbiAgICAvKiogSW50ZXJuYWxseSBzdG9yZSB0aGUgdHlwZSBvZiB0aGlzIGNvbXBvbmVudCAtIHVzdWFsIGZvciBkaXN0aW5jdGlvbnMgd2hlbiBleHRlbmRpbmcgdGhpcyBjbGFzcyAqL1xuICAgIHByb3RlY3RlZCBfdHlwZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByb3RlY3RlZCBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJvdGVjdGVkIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgICAgIHByb3RlY3RlZCBfc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcixcbiAgICAgICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBwcml2YXRlIF90b29sdGlwU2VydmljZTogVG9vbHRpcFNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgLyoqIFNldCB1cCB0aGUgdHJpZ2dlcnMgYW5kIGJpbmQgdG8gdGhlIHNob3cvaGlkZSBldmVudHMgdG8ga2VlcCB2aXNpYmlsaXR5IGluIHN5bmMgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzZXQgdXAgc2hvdyBhbmQgaGlkZSBldmVudCB0cmlnZ2Vyc1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2xpY2snKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VlbnRlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uTW91c2VFbnRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlbGVhdmUnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdibHVyJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25CbHVyLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIHdoZW4gYW55IG90aGVyIHRvb2x0aXBzIG9wZW4gaGlkZSB0aGlzIG9uZVxuICAgICAgICB0aGlzLl90b29sdGlwU2VydmljZS5zaG93biQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl90eXBlID09PSAndG9vbHRpcCcpLFxuICAgICAgICAgICAgZmlsdGVyKHRvb2x0aXAgPT4gdG9vbHRpcCAhPT0gdGhpcy5faW5zdGFuY2UpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgKS5zdWJzY3JpYmUodGhpcy5oaWRlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b29sdGlwIHNob3VsZCBiZSBpbml0aWFsbHkgdmlzaWJsZSB0aGVuIG9wZW4gaXRcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gc2VuZCBpbnB1dCBjaGFuZ2VzIHRvIHRoZSB0b29sdGlwIGNvbXBvbmVudFxuICAgICAqIFdlIGNhbid0IHVzZSBzZXR0ZXJzIGFzIHRoZXkgbWF5IHRyaWdnZXIgYmVmb3JlIHRvb2x0aXAgaW5pdGlhbGlzZWQgYW5kIGNhbid0IHJlc2VuZCBvbmNlIGluaXRpYWxpc2VkXG4gICAgICoqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcblxuICAgICAgICAvLyB3ZSBjYW4gaWdub3JlIHRoZSBmaXJzdCBjaGFuZ2UgYXMgaXQncyBoYW5kbGVkIGluIG5nT25Jbml0XG4gICAgICAgIGlmIChjaGFuZ2VzLmlzT3BlbiAmJiAhY2hhbmdlcy5pc09wZW4uZmlyc3RDaGFuZ2UgJiYgY2hhbmdlcy5pc09wZW4uY3VycmVudFZhbHVlICE9PSB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgY2hhbmdlcy5pc09wZW4uY3VycmVudFZhbHVlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgdGhlIG92ZXJsYXkgcmVmIHNvIGEgbmV3IGNvcnJlY3RseSBwb3NpdGlvbmVkIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZCBuZXh0IHRpbWVcbiAgICAgICAgaWYgKGNoYW5nZXMucGxhY2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lPdmVybGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldFBsYWNlbWVudChjaGFuZ2VzLnBsYWNlbWVudC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMuY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0Q29udGVudChjaGFuZ2VzLmNvbnRlbnQuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLmN1c3RvbUNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDbGFzcyhjaGFuZ2VzLmN1c3RvbUNsYXNzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDb250ZXh0KGNoYW5nZXMuY29udGV4dC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMucm9sZSkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0Q29udGV4dChjaGFuZ2VzLnJvbGUuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBFbnN1cmUgd2UgY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZW5zdXJlIHdlIGNsb3NlIHRoZSB0b29sdGlwIHdoZW4gdGhlIGhvc3QgaXMgZGVzdHJveWVkXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhpcyBldmVudCB0byBhdXRvbWF0aWNhbGx5IHVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIE1ha2UgdGhlIHRvb2x0aXAgb3BlbiAqL1xuICAgIHNob3coKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvb2x0aXAgaXMgZGlzYWJsZWQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMuaXNWaXNpYmxlIHx8IHRoaXMuX3Nob3dUaW1lb3V0SWQgfHwgIXRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVsYXkgdGhlIHNob3cgYnkgdGhlIGRlbGF5IGFtb3VudFxuICAgICAgICB0aGlzLl9zaG93VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHRvb2x0aXAgYW5kIGdldCB0aGUgb3ZlcmxheSByZWZcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBwb3J0YWwgdG8gY3JlYXRlIHRoZSB0b29sdGlwIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5fcG9ydGFsID0gdGhpcy5jcmVhdGVQb3J0YWwoKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gdGhpcy5jcmVhdGVJbnN0YW5jZShvdmVybGF5UmVmKTtcblxuICAgICAgICAgICAgLy8gd2F0Y2ggZm9yIGFueSBjaGFuZ2VzIHRvIHRoZSBjb250ZW50XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5yZXBvc2l0aW9uJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5yZXBvc2l0aW9uLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgdmlzaWJsZSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIG92ZXJsYXkgaGFzIHRoZSBjb3JyZWN0IGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgICAgIHRoaXMucmVwb3NpdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBzaG93IGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5zaG93bi5lbWl0KCk7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbkNoYW5nZS5uZXh0KHRydWUpO1xuXG4gICAgICAgICAgICAvLyBjbGVhciB0aGUgaW50ZXJ2YWwgaWRcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBzaG93IGV2ZW50IHRvIGNsb3NlIGFueSBvdGhlciB0b29sdGlwc1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFNlcnZpY2Uuc2hvd24kLm5leHQodGhpcy5faW5zdGFuY2UpO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgY2hhbmdlIGRldGVjdGlvbiBpcyBydW5cbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSwgdGhpcy5kZWxheSk7XG5cbiAgICB9XG5cbiAgICAvKiogSWYgYSB0b29sdGlwIGV4aXN0cyBhbmQgaXMgdmlzaWJsZSwgaGlkZSBpdCAqL1xuICAgIGhpZGUoKSB7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHdhaXRpbmcgdG8gc2hvdyBhIHRvb2x0aXAgdGhlbiBjYW5jZWwgdGhlIHBlbmRpbmcgdGltZW91dFxuICAgICAgICBpZiAodGhpcy5fc2hvd1RpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZiAmJiB0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEFyaWFEZXNjcmliZWRCeShudWxsKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSB2aXNpYmxlIHN0YXRlXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgaGlkZSBldmVudHNcbiAgICAgICAgdGhpcy5oaWRkZW4uZW1pdCgpO1xuICAgICAgICB0aGlzLmlzT3BlbkNoYW5nZS5uZXh0KGZhbHNlKTtcblxuICAgICAgICAvLyBlbnN1cmUgY2hhbmdlIGRldGVjdGlvbiBpcyBydW5cbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXAgKi9cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICAvKiogUmVjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyICovXG4gICAgcmVwb3NpdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW4gaW5zdGFuY2UgZnJvbSB0aGUgb3ZlcmxheSByZWYgLSBhbGxvd3Mgb3ZlcnJpZGluZyBhbmQgYWRkaXRpb25hbCBsb2dpYyBoZXJlICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluc3RhbmNlKG92ZXJsYXlSZWY6IE92ZXJsYXlSZWYpOiBUb29sdGlwQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBvdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9wb3J0YWwpLmluc3RhbmNlIGFzIFRvb2x0aXBDb21wb25lbnQ7XG5cbiAgICAgICAgLy8gc3VwcGx5IHRoZSB0b29sdGlwIHdpdGggdGhlIGNvcnJlY3QgcHJvcGVydGllc1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldFBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldENsYXNzKHRoaXMuY3VzdG9tQ2xhc3MpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIGluc3RhbmNlLnNldFJvbGUodGhpcy5yb2xlKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuc2V0QXJpYURlc2NyaWJlZEJ5KGluc3RhbmNlLmlkKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSB0aGUgY29tcG9uZW50IHBvcnRhbCAtIGFsbG93cyBvdmVycmlkaW5nIHRvIGFsbG93IG90aGVyIHBvcnRhbHMgZWcuIHBvcG92ZXJzICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVBvcnRhbCgpOiBDb21wb25lbnRQb3J0YWw8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0YWwgfHwgbmV3IENvbXBvbmVudFBvcnRhbChUb29sdGlwQ29tcG9uZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIHRoZSBvdmVybGF5IGFuZCBzZXQgdXAgdGhlIHNjcm9sbCBoYW5kbGluZyBiZWhhdmlvciAqL1xuICAgIHByaXZhdGUgY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgdGhlbiBqdXN0IHJldHVybiB0aGUgZXhpc3RpbmcgaW5zdGFuY2VcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uZmlndXJlIHRoZSB0b29sdGlwXG4gICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudFJlZiwgdGhpcy5nZXRPcmlnaW4oKSwgdGhpcy5nZXRPdmVybGF5UG9zaXRpb24oKSk7XG5cbiAgICAgICAgLy8gY29ycmVjdGx5IGhhbmRsZSBzY3JvbGxpbmdcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9ycyA9IHRoaXMuX3Njcm9sbERpc3BhdGNoZXJcbiAgICAgICAgICAgIC5nZXRBbmNlc3RvclNjcm9sbENvbnRhaW5lcnModGhpcy5fZWxlbWVudFJlZik7XG5cbiAgICAgICAgc3RyYXRlZ3kud2l0aFNjcm9sbGFibGVDb250YWluZXJzKHNjcm9sbGFibGVBbmNlc3RvcnMpO1xuXG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZSh7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiBzdHJhdGVneSxcbiAgICAgICAgICAgIHBhbmVsQ2xhc3M6ICd1eC1vdmVybGF5LXBhbmUnLFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKHsgc2Nyb2xsVGhyb3R0bGU6IDAgfSksXG4gICAgICAgICAgICBoYXNCYWNrZHJvcDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gICAgfVxuXG4gICAgLyoqIFJlY3JlYXRlIHRoZSBvdmVybGF5IHJlZiB1c2luZyB0aGUgdXBkYXRlZCBvcmlnaW4gYW5kIG92ZXJsYXkgcG9zaXRpb25zICovXG4gICAgcHJpdmF0ZSBkZXN0cm95T3ZlcmxheSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBkZXN0cm95IHRoZSBleGlzdGluZyBvdmVybGF5XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmICYmIHRoaXMuX292ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBvcmlnaW4gcG9zaXRpb24gYmFzZWQgb24gdGhlIHNwZWNpZmllZCB0b29sdGlwIHBsYWNlbWVudCAqL1xuICAgIHByaXZhdGUgZ2V0T3JpZ2luKCk6IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiB7XG5cbiAgICAgICAgLy8gZW5zdXJlIHBsYWNlbWVudCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMucGxhY2VtZW50ID0gdGhpcy5wbGFjZW1lbnQgfHwgJ3RvcCc7XG5cbiAgICAgICAgaWYgKHRoaXMucGxhY2VtZW50ID09ICd0b3AnIHx8IHRoaXMucGxhY2VtZW50ID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogdGhpcy5wbGFjZW1lbnQgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2FsY3VsYXRlIHRoZSBvdmVybGF5IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgdG9vbHRpcCBwbGFjZW1lbnQgKi9cbiAgICBwcml2YXRlIGdldE92ZXJsYXlQb3NpdGlvbigpOiBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uIHtcblxuICAgICAgICAvLyBlbnN1cmUgcGxhY2VtZW50IGlzIGRlZmluZWRcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSB0aGlzLnBsYWNlbWVudCB8fCAndG9wJztcblxuICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICdib3R0b20nIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICd0b3AnIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxhY2VtZW50ID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSB1dGlsaXR5IG1ldGhvZCAtIGJlY2F1c2UgSUUgZG9lc24ndCBzdXBwb3J0IGFycmF5LmluY2x1ZGVzXG4gICAgICogQW5kIGl0IGlzbid0IGluY2x1ZGVkIGluIHRoZSBjb3JlLWpzL2VzNiBwb2x5ZmlsbHMgd2hpY2ggYXJlIHRoZVxuICAgICAqIG9ubHkgb25lcyByZXF1aXJlZCBieSBBbmd1bGFyIGFuZCBndWFyYW50ZWVkIHRvIGJlIHRoZXJlXG4gICAgICoqL1xuICAgIHByb3RlY3RlZCBpbmNsdWRlczxUPihhcnJheTogQXJyYXk8VD4sIHZhbHVlOiBUKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5KSAmJiAhIWFycmF5LmZpbmQoaXRlbSA9PiBpdGVtID09PSB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgY2xpY2sgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25DbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIGl0cyBub3QgdmlzaWJsZSBhbmQgY2xpY2sgaXMgYSBzaG93IHRyaWdnZXIgb3BlbiBpdFxuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlICYmIHRoaXMuaW5jbHVkZXModGhpcy5zaG93VHJpZ2dlcnMsICdjbGljaycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdHMgdmlzaWJsZSBhbmQgY2xpY2sgaXMgYSBoaWRlIHRyaWdnZXIgY2xvc2UgaXRcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIHRoaXMuaW5jbHVkZXModGhpcy5oaWRlVHJpZ2dlcnMsICdjbGljaycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIG1vdXNlIGVudGVyIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uTW91c2VFbnRlcihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYW4gc2hvdyBvbmx5IHRyaWdnZXIgLSBpZiBhbHJlYWR5IG9wZW4gb3IgaXQgaXNuJ3QgYSB0cmlnZ2VyIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmluY2x1ZGVzKHRoaXMuc2hvd1RyaWdnZXJzLCAnbW91c2VlbnRlcicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugb3BlbiB0aGUgdG9vbHRpcFxuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBtb3VzZSBsZWF2ZSBldmVudCAtIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseSAqL1xuICAgIHByb3RlY3RlZCBvbk1vdXNlTGVhdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGFuIGhpZGUgb25seSB0cmlnZ2VyIC0gaWYgbm90IG9wZW4gb3IgaXQgaXNuJ3QgYSB0cmlnZ2VyIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSB8fCAhdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ21vdXNlbGVhdmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNsb3NlIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIGZvY3VzIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uRm9jdXMoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhbiBzaG93IG9ubHkgdHJpZ2dlciAtIGlmIGFscmVhZHkgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgfHwgIXRoaXMuaW5jbHVkZXModGhpcy5zaG93VHJpZ2dlcnMsICdmb2N1cycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugb3BlbiB0aGUgdG9vbHRpcFxuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBibHVyIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uQmx1cihldmVudDogRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGFuIGhpZGUgb25seSB0cmlnZ2VyIC0gaWYgbm90IG9wZW4gb3IgaXQgaXNuJ3QgYSB0cmlnZ2VyIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSB8fCAhdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ2JsdXInKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNsb3NlIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmUgaWYgdGhlIHRyaWdnZXIgZWxlbWVudCBpcyBmb2N1c2VkICovXG4gICAgcHJpdmF0ZSBpc0ZvY3VzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgdXBkYXRlIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5ICovXG4gICAgcHJvdGVjdGVkIHNldEFyaWFEZXNjcmliZWRCeShpZDogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYXJpYS1kZXNjcmliZWRieScsIGlkKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgdHlwZSBBbmNob3JQbGFjZW1lbnQgPSAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JzsiLCJpbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi90b29sdGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUb29sdGlwRGlyZWN0aXZlIH0gZnJvbSAnLi90b29sdGlwLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBPYnNlcnZlcnNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb2JzZXJ2ZXJzJztcbmltcG9ydCB7IFRvb2x0aXBTZXJ2aWNlIH0gZnJvbSAnLi90b29sdGlwLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgT2JzZXJ2ZXJzTW9kdWxlXG4gIF0sXG4gIGV4cG9ydHM6IFtUb29sdGlwRGlyZWN0aXZlXSxcbiAgZGVjbGFyYXRpb25zOiBbVG9vbHRpcENvbXBvbmVudCwgVG9vbHRpcERpcmVjdGl2ZV0sXG4gIHByb3ZpZGVyczogW1Rvb2x0aXBTZXJ2aWNlXSxcbiAgZW50cnlDb21wb25lbnRzOiBbVG9vbHRpcENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFJlb3JkZXJhYmxlSGFuZGxlXSdcbn0pXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4UmVvcmRlcmFibGVNb2RlbF0nXG59KVxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUge1xuXG4gICAgLy8gYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSBhIG1vZGVsIGZvciB0aGUgaXRlbSAtIGFsbG93cyB1c2Ugd2l0aCBuZ0ZvclxuICAgIEBJbnB1dCgpIHV4UmVvcmRlcmFibGVNb2RlbDogYW55O1xuXG4gICAgLy8gdGhpcyBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB3aGljaCBpbnN0YW5jZSBvZiB0aGUgZGlyZWN0aXZlIHJlbGF0ZXMgdG8gd2hpY2ggZWxlbWVudFxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cbn1cbiIsIi8vIFdPUktBUk9VTkQ6IEFuZ3VsYXIgQ2xpIDYgaGFzIHJlbW92ZWQgdGhlIGdsb2JhbHMgcGF0Y2gsIGRyYWd1bGFyIHJlcXVpcmVzIHRoaXMgdG8gd2UgY2FuIHBhdGNoIGl0IGhlcmVcbig8YW55PndpbmRvdykuZ2xvYmFsID0gKDxhbnk+d2luZG93KS5nbG9iYWwgfHwge307XG5cbi8vIFdPUktBUk9VTkQ6IG5nLXBhY2thZ3IgaXNzdWUgLSBodHRwczovL2dpdGh1Yi5jb20vZGhlcmdlcy9uZy1wYWNrYWdyL2lzc3Vlcy8xNjNcbmltcG9ydCAqIGFzIGRyYWd1bGFOYW1lc3BhY2UgZnJvbSAnZHJhZ3VsYSc7XG5pbXBvcnQgeyBEcmFrZSB9IGZyb20gJ2RyYWd1bGEnO1xuXG5leHBvcnQgY29uc3QgZHJhZ3VsYTogKGNvbnRhaW5lcnM/OiBhbnksIG9wdGlvbnM/OiBhbnkpID0+IERyYWtlID0gKGRyYWd1bGFOYW1lc3BhY2UgYXMgYW55KS5kZWZhdWx0IHx8IGRyYWd1bGFOYW1lc3BhY2U7IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEcmFrZSwgRHJhZ3VsYU9wdGlvbnMgfSBmcm9tICdkcmFndWxhJztcbmltcG9ydCB7IGRyYWd1bGEgfSBmcm9tICcuL2RyYWd1bGEnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX2dyb3VwczogeyBbazogc3RyaW5nXTogUmVvcmRlcmFibGVHcm91cCB9ID0ge307XG4gICAgcHJpdmF0ZSBfdW5pcXVlR3JvdXBJZCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdW5pcXVlIHN0cmluZyB3aGljaCBjYW4gYmUgdXNlZCBhcyBhIGdyb3VwIG5hbWUgaWYgb25lIHdhcyBub3QgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBnZXRVbmlxdWVHcm91cE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdfdXhSZW9yZGVyYWJsZV8nICsgdGhpcy5fdW5pcXVlR3JvdXBJZCsrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGNvbnRhaW5lciB0byB0aGUgbmFtZWQgZ3JvdXAuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoZ3JvdXBOYW1lOiBzdHJpbmcsIGNvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXIpOiBSZW9yZGVyYWJsZUdyb3VwIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwc1tncm91cE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXSA9IG5ldyBSZW9yZGVyYWJsZUdyb3VwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXS5yZWdpc3Rlcihjb250YWluZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250YWluZXIgZnJvbSB0aGUgbmFtZWQgZ3JvdXAuIElmIGl0IHdhcyB0aGUgbGFzdCBjb250YWluZXIgaW4gdGhlIGdyb3VwLCBkZXN0cm95cyB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgdW5yZWdpc3Rlcihncm91cE5hbWU6IHN0cmluZywgY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcik6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV07XG5cbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBncm91cC51bnJlZ2lzdGVyKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChncm91cC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBncm91cC5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBkcmFndWxhIGluc3RhbmNlIHdpdGggdGhlIGN1cnJlbnQgY29uZmlnIGFuZCBhdHRhY2hlcyB0aGUgZXZlbnRzLCBpZiBub3QgYWxyZWFkeSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUoZ3JvdXBOYW1lOiBzdHJpbmcpOiBSZW9yZGVyYWJsZUdyb3VwIHtcblxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xuXG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyb3VwIG9iamVjdCBmb3IgdGhlIGdpdmVuIG5hbWUuXG4gICAgICovXG4gICAgZ2V0R3JvdXAoZ3JvdXA6IHN0cmluZyk6IFJlb3JkZXJhYmxlR3JvdXAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzW2dyb3VwXTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVDb250YWluZXIge1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgZ2V0TW9kZWxGcm9tRWxlbWVudDogKGVsZW1lbnQ6IEVsZW1lbnQpID0+IGFueTtcbiAgICBjYW5Nb3ZlOiAoZWxlbWVudDogRWxlbWVudCwgY29udGFpbmVyOiBFbGVtZW50LCBoYW5kbGU6IEVsZW1lbnQpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVEcmFnRXZlbnQge1xuICAgIG1vZGVsOiBhbnk7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICBzb3VyY2U6IEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVEcmFnRW5kRXZlbnQge1xuICAgIG1vZGVsOiBhbnk7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZURyb3BFdmVudCB7XG4gICAgbW9kZWw6IGFueTtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIHRhcmdldDogRWxlbWVudDtcbiAgICBzb3VyY2U6IEVsZW1lbnQ7XG4gICAgc2libGluZzogRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZUNhbmNlbEV2ZW50IHtcbiAgICBtb2RlbDogYW55O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVDbG9uZWRFdmVudCB7XG4gICAgY2xvbmU6IEVsZW1lbnQ7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICB0eXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgZHJhZy1hbmQtZHJvcCBjb250YWluZXJzICh1eFJlb3JkZXJhYmxlKSB0aGF0IGl0ZW1zIGNhbiBiZSBkcmFnZ2VkIGJldHdlZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZUdyb3VwIHtcblxuICAgIGRyYWcgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJhYmxlRHJhZ0V2ZW50PigpO1xuICAgIGRyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJhYmxlRHJhZ0VuZEV2ZW50PigpO1xuICAgIGRyb3AgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJhYmxlRHJvcEV2ZW50PigpO1xuICAgIGNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVDYW5jZWxFdmVudD4oKTtcbiAgICBjbG9uZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJhYmxlQ2xvbmVkRXZlbnQ+KCk7XG5cbiAgICBwcml2YXRlIF9pbnN0YW5jZTogRHJha2U7XG4gICAgcHJpdmF0ZSBfY29udGFpbmVyczogUmVvcmRlcmFibGVDb250YWluZXJbXSA9IFtdO1xuXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBEcmFndWxhT3B0aW9ucyA9IHtcbiAgICAgICAgbW92ZXM6IHRoaXMuY2FuTW92ZS5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gY29udGFpbmVycyByZWdpc3RlcmVkIHdpdGggdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2RlbCBvYmplY3QgKHV4UmVvcmRlcmFibGVNb2RlbCkgZm9yIGFuIGVsZW1lbnRzIGluIG9uZSBvZiB0aGUgY29udGFpbmVycyBpbiB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgZ2V0TW9kZWxGb3JFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiBhbnkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLl9jb250YWluZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IGNvbnRhaW5lci5nZXRNb2RlbEZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgY29udGFpbmVyIHRvIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lcnMucHVzaChjb250YWluZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UuY29udGFpbmVycyA9IHRoaXMuX2NvbnRhaW5lcnMubWFwKChjKSA9PiBjLmVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcubWlycm9yQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcubWlycm9yQ29udGFpbmVyID0gY29udGFpbmVyLmVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250YWluZXIgZnJvbSB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgdW5yZWdpc3Rlcihjb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY29udGFpbmVycy5pbmRleE9mKGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5jb250YWluZXJzID0gdGhpcy5fY29udGFpbmVycy5tYXAoKGMpID0+IGMuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBkcmFndWxhIGluc3RhbmNlIHdpdGggdGhlIGN1cnJlbnQgY29uZmlnIGFuZCBhdHRhY2hlcyB0aGUgZXZlbnRzLCBpZiBub3QgYWxyZWFkeSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGRyYWd1bGEodGhpcy5fY29udGFpbmVycy5tYXAoKGMpID0+IGMuZWxlbWVudCksIHRoaXMuX2NvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2RyYWcnLCAoZWxlbWVudDogRWxlbWVudCwgc291cmNlOiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYWcuZW1pdCh7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxGb3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2RyYWdlbmQnLCAoZWxlbWVudDogRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnRW5kLmVtaXQoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdkcm9wJywgKGVsZW1lbnQ6IEVsZW1lbnQsIHRhcmdldDogRWxlbWVudCwgc291cmNlOiBFbGVtZW50LCBzaWJsaW5nOiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyb3AuZW1pdCh7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxGb3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgc2libGluZzogc2libGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignY2FuY2VsJywgKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdjbG9uZWQnLCAoY2xvbmU6IEVsZW1lbnQsIGVsZW1lbnQ6IEVsZW1lbnQsIHR5cGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9uZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgY2xvbmU6IGNsb25lLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBkcmFndWxhIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGNvbnRhaW5lciBmb3IgdGhlIGNvbnRhaW5lckVsZW1lbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgb2YgY2FuTW92ZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbk1vdmUoZWxlbWVudDogRWxlbWVudCwgY29udGFpbmVyRWxlbWVudDogRWxlbWVudCwgaGFuZGxlOiBFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAobGV0IGNvbnRhaW5lciBvZiB0aGlzLl9jb250YWluZXJzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmVsZW1lbnQuaXNTYW1lTm9kZShjb250YWluZXJFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXIuY2FuTW92ZShlbGVtZW50LCBjb250YWluZXJFbGVtZW50LCBoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBRdWVyeUxpc3QsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLWhhbmRsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUtbW9kZWwuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlQ2FuY2VsRXZlbnQsIFJlb3JkZXJhYmxlQ2xvbmVkRXZlbnQsIFJlb3JkZXJhYmxlQ29udGFpbmVyLCBSZW9yZGVyYWJsZURyYWdFbmRFdmVudCwgUmVvcmRlcmFibGVEcmFnRXZlbnQsIFJlb3JkZXJhYmxlRHJvcEV2ZW50LCBSZW9yZGVyYWJsZVNlcnZpY2UgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFJlb3JkZXJhYmxlXSdcbn0pXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSByZW9yZGVyYWJsZU1vZGVsOiBBcnJheTxhbnk+O1xuICAgIEBJbnB1dCgpIHJlb3JkZXJhYmxlR3JvdXA6IHN0cmluZztcbiAgICBASW5wdXQoKSByZW9yZGVyaW5nRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBAT3V0cHV0KCkgcmVvcmRlcmFibGVNb2RlbENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8QXJyYXk8YW55Pj4oKTtcbiAgICBAT3V0cHV0KCkgcmVvcmRlclN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyRXZlbnQ+KCk7XG4gICAgQE91dHB1dCgpIHJlb3JkZXJDYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJFdmVudD4oKTtcbiAgICBAT3V0cHV0KCkgcmVvcmRlckVuZCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlckV2ZW50PigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSwgeyByZWFkOiBFbGVtZW50UmVmLCBkZXNjZW5kYW50czogdHJ1ZSB9KSBoYW5kbGVzOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG4gICAgQENvbnRlbnRDaGlsZHJlbihSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlKSBtb2RlbHM6IFF1ZXJ5TGlzdDxSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlPjtcblxuICAgIHByaXZhdGUgX2NvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXI7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLnV4LXJlb3JkZXJhYmxlLWNvbnRhaW5lci1tb3ZpbmcnKSBkcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBwcml2YXRlIF9zZXJ2aWNlOiBSZW9yZGVyYWJsZVNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBkcmFndWxhIGFuZCBiaW5kIHRvIGFsbCB0aGUgcmVxdWlyZWQgZXZlbnRzXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gSWYgbm8gZ3JvdXAgbmFtZSB0aGVuIGdlbmVyYXRlIGEgdW5pcXVlIG9uZSBmb3IgdGhpcyBpbnN0YW5jZSBvbmx5XG4gICAgICAgIGlmICghdGhpcy5yZW9yZGVyYWJsZUdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlR3JvdXAgPSB0aGlzLl9zZXJ2aWNlLmdldFVuaXF1ZUdyb3VwTmFtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0ge1xuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgZ2V0TW9kZWxGcm9tRWxlbWVudDogdGhpcy5nZXRNb2RlbEZyb21FbGVtZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBjYW5Nb3ZlOiB0aGlzLmNhbk1vdmUuYmluZCh0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIGZvciBkcmFnIGV2ZW50cyBvbiB0aGlzIGVsZW1lbnRcbiAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLl9zZXJ2aWNlLnJlZ2lzdGVyKHRoaXMucmVvcmRlcmFibGVHcm91cCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuZHJhZy5zdWJzY3JpYmUodGhpcy5vbkRyYWcuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5kcmFnRW5kLnN1YnNjcmliZSh0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmRyb3Auc3Vic2NyaWJlKHRoaXMub25Ecm9wLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuY2FuY2VsLnN1YnNjcmliZSgoZXZlbnQ6IFJlb3JkZXJhYmxlQ2FuY2VsRXZlbnQpID0+IHRoaXMucmVvcmRlckNhbmNlbC5lbWl0KHsgZWxlbWVudDogZXZlbnQuZWxlbWVudCwgbW9kZWw6IGV2ZW50Lm1vZGVsIH0pKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmNsb25lZC5zdWJzY3JpYmUodGhpcy5vbkNsb25lLmJpbmQodGhpcykpKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UuaW5pdGlhbGl6ZSh0aGlzLnJlb3JkZXJhYmxlR3JvdXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gZGVzdHJveSB0aGUgZHJhZ3VsYSBpbnN0YW5jZSBvbiBjb21wb25lbnQgZGVzdHJveVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zZXJ2aWNlLnVucmVnaXN0ZXIodGhpcy5yZW9yZGVyYWJsZUdyb3VwLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgb25EcmFnKGV2ZW50OiBSZW9yZGVyYWJsZURyYWdFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMucmVvcmRlclN0YXJ0LmVtaXQoeyBlbGVtZW50OiBldmVudC5lbGVtZW50LCBtb2RlbDogZXZlbnQubW9kZWwgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBmaXJlZCB3aGVuIGl0ZW1zIGdldCByZW9yZGVyZWQgLSB3ZSBuZWVkIHRvIGVtaXQgdGhlIG5ldyBvcmRlciBvZiB0aGUgbW9kZWxzXG4gICAgICovXG4gICAgb25Ecm9wKGV2ZW50OiBSZW9yZGVyYWJsZURyb3BFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHByb3ZpZGVkIG1vZHVsZSB3ZSBjYW4gc2tpcCB0aGlzXG4gICAgICAgIGlmICghdGhpcy5yZW9yZGVyYWJsZU1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChldmVudC5zb3VyY2UuaXNTYW1lTm9kZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKSB7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIG1vZGVsIGZyb20gdGhlIGxpc3Qgb2YgbW9kZWxzXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucmVvcmRlcmFibGVNb2RlbC5pbmRleE9mKGV2ZW50Lm1vZGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZU1vZGVsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmlzU2FtZU5vZGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSkge1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIHBvc2l0aW9uIG9mIHNpYmxpbmcgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5zaWJsaW5nICYmICFldmVudC5zaWJsaW5nLmNsYXNzTGlzdC5jb250YWlucygnZ3UtbWlycm9yJykgP1xuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbC5pbmRleE9mKHRoaXMuZ2V0TW9kZWxGcm9tRWxlbWVudChldmVudC5zaWJsaW5nKSkgOlxuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbC5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgbW9kZWwgYXQgaXRzIG5ldyBsb2NhdGlvblxuICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZU1vZGVsLnNwbGljZShpbmRleCwgMCwgZXZlbnQubW9kZWwpO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbWl0IGV2ZW50IGlmIGFueSBjaGFuZ2VzIHdlcmUgbWFkZVxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZU1vZGVsQ2hhbmdlLmVtaXQodGhpcy5yZW9yZGVyYWJsZU1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbW9kZWwgYXNzY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIGVsZW1lbnQgaW4gdGhlIGxpc3QuXG4gICAgICogVGhpcyBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIGl0ZW1zIGhhdmUgdGhlIGRyYWdnYWJsZSBtb2RlbCBkaXJlY3RpdmUgYXBwbGllZFxuICAgICAqL1xuICAgIGdldE1vZGVsRnJvbUVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IGFueSB7XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVscy5maW5kKF9tb2RlbCA9PiBfbW9kZWwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50ID09PSBlbGVtZW50KTtcblxuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RlbC51eFJlb3JkZXJhYmxlTW9kZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBmaW5pc2ggZHJhZ2dpbmcgcmVtb3ZlIHRoZSB1dGlsbGl0eSBjbGFzcyBmcm9tIHRoZSBlbGVtZW50IGJlaW5nIG1vdmVkXG4gICAgICovXG4gICAgb25EcmFnRW5kKGV2ZW50OiBSZW9yZGVyYWJsZURyYWdFbmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LmVsZW1lbnQpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKGV2ZW50LmVsZW1lbnQsICd1eC1yZW9yZGVyYWJsZS1tb3ZpbmcnKTtcblxuICAgICAgICAgICAgdGhpcy5yZW9yZGVyRW5kLmVtaXQoe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbW9kZWw6IGV2ZW50Lm1vZGVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgdGhlIGNsb25lZCBlbGVtZW50IGlzIGlkZW50aWNhbFxuICAgICAqIHRvIHRoZSBvcmlnaW5hbCwgcmVnYXJkbGVzcyBvZiBpdCdzIGxvY2F0aW9uIGluIHRoZSBET00gdHJlZVxuICAgICAqL1xuICAgIG9uQ2xvbmUoZXZlbnQ6IFJlb3JkZXJhYmxlQ2xvbmVkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LmVsZW1lbnQpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0VGFibGVDZWxsV2lkdGhzKGV2ZW50LmVsZW1lbnQsIGV2ZW50LmNsb25lKTtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUNhbnZhc2VzKGV2ZW50LmVsZW1lbnQsIGV2ZW50LmNsb25lKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MoZXZlbnQuZWxlbWVudCwgJ3V4LXJlb3JkZXJhYmxlLW1vdmluZycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgZWxlbWVudHMgY29udGFpbiBoYW5kbGVzIHRoZW4gb25seSBkcmFnIHdoZW4gdGhlIGhhbmRsZSBpcyBkcmFnZ2VkXG4gICAgICogb3RoZXJ3aXNlIGRyYWcgd2hlbmV2ZXIgYW4gaW1tZWRpYXRlIGNoaWxkIGlzIHNwZWNpZmllZFxuICAgICAqL1xuICAgIGNhbk1vdmUoZWxlbWVudDogRWxlbWVudCwgY29udGFpbmVyOiBFbGVtZW50LCBoYW5kbGU6IEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMucmVvcmRlcmluZ0Rpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcy5sZW5ndGggPT09IDAgPyB0cnVlIDogISF0aGlzLmhhbmRsZXMuZmluZChfaGFuZGxlID0+IF9oYW5kbGUubmF0aXZlRWxlbWVudCA9PT0gaGFuZGxlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFRhYmxlQ2VsbFdpZHRocyhzb3VyY2U6IEVsZW1lbnQsIHRhcmdldDogRWxlbWVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIG5vdCBhIHRhYmxlIHJvdyB0aGVuIHNraXAgdGhpc1xuICAgICAgICBpZiAoc291cmNlLnRhZ05hbWUgIT09ICdUUicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgYW55IGltbWVkaWF0ZSB0ZCBjaGlsZHJlbiBhbmQgZml4IHRoZWlyIHdpZHRoXG4gICAgICAgIGNvbnN0IHNvdXJjZUNlbGxzID0gQXJyYXkuZnJvbShzb3VyY2UuY2hpbGRyZW4pIGFzIEhUTUxUYWJsZUNlbGxFbGVtZW50W107XG4gICAgICAgIGNvbnN0IHRhcmdldENlbGxzID0gQXJyYXkuZnJvbSh0YXJnZXQuY2hpbGRyZW4pIGFzIEhUTUxUYWJsZUNlbGxFbGVtZW50W107XG5cbiAgICAgICAgLy8gZml4IHRoZSB3aWR0aCBvZiB0aGVzZSBjZWxsc1xuICAgICAgICBzb3VyY2VDZWxscy5mb3JFYWNoKChjZWxsLCBpZHgpID0+IHRhcmdldENlbGxzW2lkeF0uc3R5bGUubWluV2lkdGggPSBnZXRDb21wdXRlZFN0eWxlKGNlbGwpLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2FwdHVyZUNhbnZhc2VzKHNvdXJjZTogRWxlbWVudCwgdGFyZ2V0OiBFbGVtZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCBhbGwgY2hpbGQgY2FudmFzIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IHNvdXJjZUNhbnZhc2VzID0gQXJyYXkuZnJvbShzb3VyY2UucXVlcnlTZWxlY3RvckFsbCgnY2FudmFzJykpO1xuICAgICAgICBjb25zdCB0YXJnZXRDYW52YXNlcyA9IEFycmF5LmZyb20odGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NhbnZhcycpKTtcblxuICAgICAgICAvLyByZXBsaWNhdGUgdGhlIGNhbnZhcyBjb250ZW50XG4gICAgICAgIHRhcmdldENhbnZhc2VzLm1hcChjYW52YXMgPT4gY2FudmFzLmdldENvbnRleHQoJzJkJykpXG4gICAgICAgICAgICAuZm9yRWFjaCgoY29udGV4dCwgaWR4KSA9PiBjb250ZXh0LmRyYXdJbWFnZShzb3VyY2VDYW52YXNlc1tpZHhdLCAwLCAwKSk7XG5cbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyRXZlbnQge1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgbW9kZWw6IGFueTtcbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUtaGFuZGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS1tb2RlbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVTZXJ2aWNlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFJlb3JkZXJhYmxlRGlyZWN0aXZlLFxuICAgICAgICBSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSxcbiAgICAgICAgUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSZW9yZGVyYWJsZURpcmVjdGl2ZSxcbiAgICAgICAgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUsXG4gICAgICAgIFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBSZW9yZGVyYWJsZVNlcnZpY2VcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJ25neC1ib290c3RyYXAvdHlwZWFoZWFkJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGYWNldENvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vZmFjZXQtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldEJhc2VDb21wb25lbnQgfSBmcm9tICcuL2Jhc2UvZmFjZXQtYmFzZS9mYWNldC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldEhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vYmFzZS9mYWNldC1oZWFkZXIvZmFjZXQtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldENoZWNrTGlzdENvbXBvbmVudCB9IGZyb20gJy4vZmFjZXQtY2hlY2stbGlzdC9mYWNldC1jaGVjay1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldFR5cGVhaGVhZExpc3RDb21wb25lbnQsIEZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0IH0gZnJvbSAnLi9mYWNldC10eXBlYWhlYWQtbGlzdC9mYWNldC10eXBlYWhlYWQtbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBDaGVja2JveE1vZHVsZSB9IGZyb20gJy4uL2NoZWNrYm94L2luZGV4JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IFJlb3JkZXJhYmxlTW9kdWxlIH0gZnJvbSAnLi8uLi8uLi9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLm1vZHVsZSc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBGYWNldENvbnRhaW5lckNvbXBvbmVudCxcbiAgICBGYWNldEhlYWRlckNvbXBvbmVudCxcbiAgICBGYWNldEJhc2VDb21wb25lbnQsXG4gICAgRmFjZXRDaGVja0xpc3RDb21wb25lbnQsXG4gICAgRmFjZXRUeXBlYWhlYWRMaXN0Q29tcG9uZW50LFxuICAgIEZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0XG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGUsXG4gICAgICAgIFJlb3JkZXJhYmxlTW9kdWxlLFxuICAgICAgICBUeXBlYWhlYWRNb2R1bGUuZm9yUm9vdCgpXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRzTW9kdWxlIHsgfVxuIiwiZXhwb3J0IGNsYXNzIEZhY2V0IHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIHRpdGxlOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBkYXRhOiBhbnkgPSB7fSxcbiAgICAgICAgcHVibGljIGNvdW50PzogbnVtYmVyLFxuICAgICAgICBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgcHVibGljIGlkPzogc3RyaW5nIHwgbnVtYmVyXG4gICAgKSB7IH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZpbHRlci1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXG48IS0tIEFkZCBhIENsZWFyIEJ1dHRvbiAtLT5cbjxkaXYgY2xhc3M9XCJmaWx0ZXItc2VsZWN0ZWQtY2xlYXItYnV0dG9uXCIgKm5nSWY9XCJmaWx0ZXJzLmxlbmd0aCA+IDBcIiBbdXhUb29sdGlwXT1cImNsZWFyVG9vbHRpcCB8fCAnQ2xlYXIgQWxsJ1wiIChjbGljayk9XCJyZW1vdmVBbGwoKVwiPlxuXG4gICAgPHN2ZyBjbGFzcz1cImZpbHRlci1zZWxlY3RlZC1jbGVhci1ncmFwaGljXCIgd2lkdGg9XCIxOVwiIGhlaWdodD1cIjEyXCIgdmlld0JveD1cIjAgMCAxOSAxMlwiIHNoYXBlLXJlbmRlcmluZz1cImdlb21ldHJpY1ByZWNpc2lvblwiPlxuICAgICAgICA8cmVjdCBjbGFzcz1cImxpZ2h0LWdyZXlcIiB4PVwiMFwiIHk9XCIyXCIgd2lkdGg9XCI3XCIgaGVpZ2h0PVwiMlwiPjwvcmVjdD5cbiAgICAgICAgPHJlY3QgY2xhc3M9XCJkYXJrLWdyZXlcIiB4PVwiMFwiIHk9XCI1XCIgd2lkdGg9XCI5XCIgaGVpZ2h0PVwiMlwiPjwvcmVjdD5cbiAgICAgICAgPHJlY3QgY2xhc3M9XCJsaWdodC1ncmV5XCIgeD1cIjBcIiB5PVwiOFwiIHdpZHRoPVwiN1wiIGhlaWdodD1cIjJcIj48L3JlY3Q+XG4gICAgICAgIDxwYXRoIGNsYXNzPVwiZGFyay1ncmV5XCIgZD1cIk05LDEgaDEgbDksOSB2MSBoLTEgbC05LC05IHYtMSBaXCI+PC9wYXRoPlxuICAgICAgICA8cGF0aCBjbGFzcz1cImRhcmstZ3JleVwiIGQ9XCJNOSwxMSB2LTEgbDksLTkgaDEgdjEgbC05LDkgaC0xIFpcIj48L3BhdGg+XG4gICAgPC9zdmc+XG5cbjwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyQ29udGFpbmVyQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGZpbHRlcnM6IEZpbHRlcltdID0gW107XG4gICAgQElucHV0KCkgY2xlYXJUb29sdGlwOiBzdHJpbmc7XG4gICAgQE91dHB1dCgpIGZpbHRlcnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGaWx0ZXJbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZpbHRlcltdPigpO1xuICAgIEBPdXRwdXQoKSBldmVudHM6IEV2ZW50RW1pdHRlcjxGaWx0ZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPEZpbHRlckV2ZW50PigpO1xuXG5cbiAgICBhZGRGaWx0ZXIoZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dChuZXcgRmlsdGVyQWRkRXZlbnQoZmlsdGVyKSk7XG4gICAgICAgIHRoaXMuZmlsdGVyc0NoYW5nZS5lbWl0KHRoaXMuZmlsdGVycyk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRmlsdGVyKGZpbHRlcjogRmlsdGVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmZpbHRlcnMuZmluZEluZGV4KGZpbHRlcnMgPT4gZmlsdGVycyA9PT0gZmlsdGVyKTtcblxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMubmV4dChuZXcgRmlsdGVyUmVtb3ZlRXZlbnQoZmlsdGVyKSk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNDaGFuZ2UuZW1pdCh0aGlzLmZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KG5ldyBGaWx0ZXJSZW1vdmVBbGxFdmVudCgpKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXIge1xuICAgIGdyb3VwOiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgaW5pdGlhbD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBGaWx0ZXJBZGRFdmVudCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGZpbHRlcjogRmlsdGVyKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRmlsdGVyUmVtb3ZlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEZpbHRlcikge31cbn1cblxuZXhwb3J0IGNsYXNzIEZpbHRlclJlbW92ZUFsbEV2ZW50IHtcbn1cblxuZXhwb3J0IHR5cGUgRmlsdGVyRXZlbnQgPSBGaWx0ZXJBZGRFdmVudCB8IEZpbHRlclJlbW92ZUV2ZW50IHwgRmlsdGVyUmVtb3ZlQWxsRXZlbnQ7IiwiXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3QsIElucHV0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IEZpbHRlciwgRmlsdGVyQ29udGFpbmVyQ29tcG9uZW50LCBGaWx0ZXJSZW1vdmVBbGxFdmVudCB9IGZyb20gJy4uL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1maWx0ZXItYmFzZSdcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBmaWx0ZXJzOiBGaWx0ZXJbXTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoQEhvc3QoKSBwcml2YXRlIGZpbHRlcnNDb250YWluZXI6IEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBmaWx0ZXJzQ29udGFpbmVyLmV2ZW50cy5waXBlKGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEZpbHRlclJlbW92ZUFsbEV2ZW50KSkuc3Vic2NyaWJlKHRoaXMucmVtb3ZlRmlsdGVyLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBhZGRGaWx0ZXIoX2ZpbHRlcjogRmlsdGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghX2ZpbHRlci5pbml0aWFsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNDb250YWluZXIuYWRkRmlsdGVyKF9maWx0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlRmlsdGVyKF9maWx0ZXI6IEZpbHRlcik6IHZvaWQge1xuICAgICAgICBpZiAoIV9maWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsdGVyc0NvbnRhaW5lci5yZW1vdmVGaWx0ZXIoX2ZpbHRlcik7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmlsdGVyQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2ZpbHRlci1iYXNlL2ZpbHRlci1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuLi9maWx0ZXItY29udGFpbmVyLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmlsdGVyLWRyb3Bkb3duJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIiBkcm9wZG93bj5cbiAgICA8YnV0dG9uIGRyb3Bkb3duVG9nZ2xlIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImZpbHRlci1kcm9wZG93biBidG4gZHJvcGRvd24tdG9nZ2xlXCIgW2NsYXNzLmFjdGl2ZV09XCJzZWxlY3RlZCAhPT0gaW5pdGlhbFwiPnt7IHNlbGVjdGVkPy50aXRsZSB9fSBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtZG93blwiPjwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8dWwgKmRyb3Bkb3duTWVudSBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIiByb2xlPVwibWVudVwiPlxuICAgICAgICA8bGkgY2xhc3M9XCJkcm9wZG93bi1saXN0LWl0ZW1cIiAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIGZpbHRlcnNcIiByb2xlPVwibWVudWl0ZW1cIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiIChjbGljayk9XCJzZWxlY3RGaWx0ZXIoZmlsdGVyKVwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb25cIiBbY2xhc3MuaHBlLWNoZWNrbWFya109XCJmaWx0ZXIgPT09IHNlbGVjdGVkXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duLXRpdGxlXCI+e3sgZmlsdGVyLm5hbWUgfX08L3NwYW4+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cbjwvZGl2PmAsXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckRyb3Bkb3duQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyQmFzZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBpbml0aWFsOiBGaWx0ZXI7XG5cbiAgICBzZWxlY3RlZDogRmlsdGVyO1xuXG4gICAgcmVtb3ZlRmlsdGVyKCk6IHZvaWQge1xuICAgICAgICBzdXBlci5yZW1vdmVGaWx0ZXIodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgfVxuXG4gICAgc2VsZWN0RmlsdGVyKGZpbHRlcjogRmlsdGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMuYWRkRmlsdGVyKHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnNEcm9wZG93bkRpcmVjdGl2ZSB9IGZyb20gJ25neC1ib290c3RyYXAvZHJvcGRvd24nO1xuaW1wb3J0IHsgVHlwZWFoZWFkTWF0Y2ggfSBmcm9tICduZ3gtYm9vdHN0cmFwL3R5cGVhaGVhZCc7XG5pbXBvcnQgeyBGaWx0ZXJCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZmlsdGVyLWJhc2UvZmlsdGVyLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1maWx0ZXItZHluYW1pYycsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIHV4LWR5bmFtaWMtZmlsdGVyXCIgZHJvcGRvd24gI2R5bmFtaWNEcm9wZG93bj1cImJzLWRyb3Bkb3duXCI+XG4gICAgPGJ1dHRvbiAoY2xpY2spPVwiZHluYW1pY0Ryb3Bkb3duLnNob3coKVwiIHR5cGU9XCJidXR0b25cIiBbY2xhc3MuYWN0aXZlXT1cInNlbGVjdGVkICE9PSBpbml0aWFsXCIgY2xhc3M9XCJmaWx0ZXItZHJvcGRvd24gYnRuIGRyb3Bkb3duLXRvZ2dsZVwiPnt7IHNlbGVjdGVkPy50aXRsZSB9fSBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtZG93blwiPjwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8dWwgKmRyb3Bkb3duTWVudSBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIiByb2xlPVwibWVudVwiPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiICpuZ0lmPVwic2hvd1R5cGVhaGVhZFwiIHJvbGU9XCJtZW51aXRlbVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCIgKGNsaWNrKT1cInJlbW92ZUZpbHRlcigpOyBkeW5hbWljRHJvcGRvd24uaGlkZSgpO1wiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb25cIiBbY2xhc3MuaHBlLWNoZWNrbWFya109XCJpbml0aWFsID09PSBzZWxlY3RlZFwiPjwvaT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZpbHRlci1kcm9wZG93bi10aXRsZVwiPnt7IGluaXRpYWwubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGkgY2xhc3M9XCJkcm9wZG93bi1saXN0LWl0ZW1cIiAqbmdJZj1cInNlbGVjdGVkICE9PSBpbml0aWFsICYmIHNob3dUeXBlYWhlYWRcIiByb2xlPVwibWVudWl0ZW1cIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb24gaHBlLWNoZWNrbWFya1wiPjwvaT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZpbHRlci1kcm9wZG93bi10aXRsZVwiPnt7IHNlbGVjdGVkLm5hbWUgfX08L3NwYW4+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPGhyPlxuXG4gICAgICAgIDxsaSAqbmdJZj1cInNob3dUeXBlYWhlYWRcIiBjbGFzcz1cInR5cGVhaGVhZC1ib3hcIj5cbiAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cInNlYXJjaFF1ZXJ5XCIgW3R5cGVhaGVhZF09XCJ0eXBlYWhlYWRJdGVtc1wiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgXG4gICAgICAgICAgICAodHlwZWFoZWFkT25TZWxlY3QpPVwic2VsZWN0T3B0aW9uKCRldmVudClcIiBcbiAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJvcHRpb25zPy5wbGFjZWhvbGRlciB8fCBkZWZhdWx0T3B0aW9ucy5wbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbdHlwZWFoZWFkTWluTGVuZ3RoXT1cIm9wdGlvbnM/Lm1pbkNoYXJhY3RlcnMgfHwgZGVmYXVsdE9wdGlvbnMubWluQ2hhcmFjdGVyc1wiXG4gICAgICAgICAgICBbdHlwZWFoZWFkT3B0aW9uc0xpbWl0XT1cIm9wdGlvbnM/Lm1heFJlc3VsdHNcIj5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFzaG93VHlwZWFoZWFkXCI+XG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJkcm9wZG93bi1saXN0LWl0ZW1cIiAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIGZpbHRlcnNcIiByb2xlPVwibWVudWl0ZW1cIj5cbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIiAoY2xpY2spPVwic2VsZWN0RmlsdGVyKGZpbHRlcilcIj5cbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvblwiIFtjbGFzcy5ocGUtY2hlY2ttYXJrXT1cImZpbHRlciA9PT0gc2VsZWN0ZWRcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duLXRpdGxlXCI+e3sgZmlsdGVyLm5hbWUgfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgPC91bD5cbjwvZGl2PmAsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGRvY3VtZW50OmNsaWNrKSc6ICdjbGlja09mZigkZXZlbnQpJyxcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckR5bmFtaWNDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJCYXNlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGZpbHRlcnM6IEZpbHRlcltdO1xuICAgIEBJbnB1dCgpIGluaXRpYWw6IEZpbHRlcjtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZztcblxuICAgIEBWaWV3Q2hpbGQoQnNEcm9wZG93bkRpcmVjdGl2ZSkgZHJvcGRvd246IEJzRHJvcGRvd25EaXJlY3RpdmU7XG5cbiAgICBkZWZhdWx0T3B0aW9uczogRmlsdGVyRHluYW1pY0xpc3RDb25maWcgPSB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICAgICAgbWluQ2hhcmFjdGVyczogM1xuICAgIH07XG4gICAgc2VhcmNoUXVlcnk6IHN0cmluZztcbiAgICBzZWxlY3RlZDogRmlsdGVyO1xuICAgIHNob3dUeXBlYWhlYWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHR5cGVhaGVhZEl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMuaW5pdGlhbCkubWFwKGl0ZW0gPT4gaXRlbS5uYW1lKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuaW5pdGlhbDtcbiAgICAgICAgdGhpcy50eXBlYWhlYWRJdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tYXhJbmRpdmlkdWFsSXRlbXMgJiYgdGhpcy5vcHRpb25zLm1heEluZGl2aWR1YWxJdGVtcyArIDEgPj0gdGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaG93VHlwZWFoZWFkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RPcHRpb24odHlwZWFoZWFkT3B0aW9uOiBUeXBlYWhlYWRNYXRjaCkge1xuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlcigpO1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5maWx0ZXJzLmZpbmRJbmRleChmaWx0ZXIgPT4gZmlsdGVyLm5hbWUgPT09IHR5cGVhaGVhZE9wdGlvbi52YWx1ZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmZpbHRlcnNbaWR4XTtcbiAgICAgICAgdGhpcy5hZGRGaWx0ZXIodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2VhcmNoUXVlcnkgPSAnJztcbiAgICAgICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7XG4gICAgfVxuXG4gICAgY2xpY2tPZmYoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcblxuICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBsZXQgaGlkZURyb3Bkb3duID0gdHJ1ZTtcblxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndXgtZHluYW1pYy1maWx0ZXInKSkge1xuICAgICAgICAgICAgICAgIGhpZGVEcm9wZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoaWRlRHJvcGRvd24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoUXVlcnkgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZW1vdmVGaWx0ZXIoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkICE9PSB0aGlzLmluaXRpYWwpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWFyY2hRdWVyeSA9ICcnO1xuICAgIH1cblxuICAgIHNlbGVjdEZpbHRlcihmaWx0ZXI6IEZpbHRlcikge1xuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmlsdGVyO1xuICAgICAgICB0aGlzLmFkZEZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZyB7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgbWluQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtYXhSZXN1bHRzPzogbnVtYmVyO1xuICAgIG1heEluZGl2aWR1YWxJdGVtcz86IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQnNEcm9wZG93bk1vZHVsZSB9IGZyb20gJ25neC1ib290c3RyYXAvZHJvcGRvd24nO1xuaW1wb3J0IHsgVHlwZWFoZWFkTW9kdWxlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC90eXBlYWhlYWQnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgRmlsdGVyQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyLWJhc2UvZmlsdGVyLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyRHJvcGRvd25Db21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1kcm9wZG93bi9maWx0ZXItZHJvcGRvd24uY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlckR5bmFtaWNDb21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1keW5hbWljL2ZpbHRlci1keW5hbWljLmNvbXBvbmVudCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBGaWx0ZXJCYXNlQ29tcG9uZW50LFxuICAgIEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCxcbiAgICBGaWx0ZXJEcm9wZG93bkNvbXBvbmVudCxcbiAgICBGaWx0ZXJEeW5hbWljQ29tcG9uZW50XG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQnNEcm9wZG93bk1vZHVsZS5mb3JSb290KCksXG4gICAgICAgIFR5cGVhaGVhZE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgIFRvb2x0aXBNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OU1xufSlcbmV4cG9ydCBjbGFzcyBGaWx0ZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbGlwcGFibGUtY2FyZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidXgtZmxpcHBlclwiIFtjbGFzcy51eC1mbGlwLWNhcmRdPVwiZmxpcHBlZFwiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiIFtzdHlsZS5oZWlnaHQucHhdPVwiaGVpZ2h0XCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtZmxpcHBhYmxlLWNhcmQtZnJvbnRcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImhlaWdodFwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJ1eC1mbGlwcGFibGUtY2FyZC1mcm9udFwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1mbGlwcGFibGUtY2FyZC1iYWNrXCIgW3N0eWxlLndpZHRoLnB4XT1cIndpZHRoXCIgW3N0eWxlLmhlaWdodC5weF09XCJoZWlnaHRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwidXgtZmxpcHBhYmxlLWNhcmQtYmFja1wiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbjwvZGl2PmAsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhvcml6b250YWxdJzogJ2RpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCInLFxuICAgICAgICAnW2NsYXNzLnZlcnRpY2FsXSc6ICdkaXJlY3Rpb24gPT09IFwidmVydGljYWxcIidcbiAgICB9LFxuICAgIGV4cG9ydEFzOiAndXgtZmxpcHBhYmxlLWNhcmQnXG59KVxuZXhwb3J0IGNsYXNzIEZsaXBwYWJsZUNhcmRDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuICAgIEBJbnB1dCgpIHRyaWdnZXI6ICdjbGljaycgfCAnaG92ZXInIHwgJ21hbnVhbCcgPSAnaG92ZXInO1xuICAgIEBJbnB1dCgpIHdpZHRoOiBudW1iZXIgPSAyODA7XG4gICAgQElucHV0KCkgaGVpZ2h0OiBudW1iZXIgPSAyMDA7XG4gICAgQElucHV0KCkgZmxpcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBPdXRwdXQoKSBmbGlwcGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBzZXRGbGlwcGVkKHN0YXRlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuZmxpcHBlZCA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZsaXBwZWRDaGFuZ2UuZW1pdCh0aGlzLmZsaXBwZWQpO1xuICAgIH1cblxuICAgIHRvZ2dsZUZsaXBwZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0RmxpcHBlZCghdGhpcy5mbGlwcGVkKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpIGNsaWNrVHJpZ2dlcigpIHtcblxuICAgICAgICAvLyBhZGQgb3IgcmVtb3ZlIHRoZSBjbGFzcyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3QgdGhlIGNhcmQgaGFzIGJlZW4gZmxpcHBlZFxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUZsaXBwZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSBob3ZlckVudGVyKCkge1xuICAgICAgICAvLyBpZiB0aGUgdHJpZ2dlciBpcyBob3ZlciB0aGVuIGJlZ2luIHRvIGZsaXBcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgdGhpcy5zZXRGbGlwcGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpIGhvdmVyRXhpdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgdGhpcy5zZXRGbGlwcGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsaXBwYWJsZS1jYXJkLWZyb250J1xufSlcbmV4cG9ydCBjbGFzcyBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmUgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxpcHBhYmxlLWNhcmQtYmFjaydcbn0pXG5leHBvcnQgY2xhc3MgRmxpcHBhYmxlQ2FyZEJhY2tEaXJlY3RpdmUgeyB9XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGbGlwcGFibGVDYXJkQ29tcG9uZW50LCBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSwgRmxpcHBhYmxlQ2FyZEZyb250RGlyZWN0aXZlIH0gZnJvbSAnLi9mbGlwcGFibGUtY2FyZC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtGbGlwcGFibGVDYXJkQ29tcG9uZW50LCBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSwgRmxpcHBhYmxlQ2FyZEZyb250RGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGbGlwcGFibGVDYXJkQ29tcG9uZW50LCBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSwgRmxpcHBhYmxlQ2FyZEZyb250RGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBGbGlwcGFibGVDYXJkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZSB7XG5cbiAgICBvcGVuJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgb3BlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KCF0aGlzLm9wZW4kLmdldFZhbHVlKCkpO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQoZmFsc2UpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBhbmltYXRlLCBxdWVyeSwgc3RhZ2dlciwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRvb2x0aXBEaXJlY3RpdmUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL3Rvb2x0aXAnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZSB9IGZyb20gJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2ZhYi1wcmltYXJ5XVwiPjwvbmctY29udGVudD5cblxuPGRpdiBjbGFzcz1cImZsb2F0aW5nLWFjdGlvbi1idXR0b24tbGlzdFwiIFtAZmFiQW5pbWF0aW9uXT1cImZhYi5vcGVuJCB8IGFzeW5jXCIgW25nQ2xhc3NdPVwiZGlyZWN0aW9uXCIgKm5nSWY9XCJmYWIub3BlbiQgfCBhc3luY1wiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PmAsXG4gICAgcHJvdmlkZXJzOiBbRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgYW5pbWF0aW9uczogW1xuICAgICAgICB0cmlnZ2VyKCdmYWJBbmltYXRpb24nLCBbXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IHRydWUnLCBbXG4gICAgICAgICAgICAgICAgcXVlcnkoJ3V4LWZsb2F0aW5nLWFjdGlvbi1idXR0b24nLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5KCd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJywgc3RhZ2dlcig1MCwgYW5pbWF0ZSgyNTAsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSkpKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd0cnVlID0+IHZvaWQnLCBbXG4gICAgICAgICAgICAgICAgcXVlcnkoJ3V4LWZsb2F0aW5nLWFjdGlvbi1idXR0b24nLCBzdGFnZ2VyKC01MCwgYW5pbWF0ZSgyNTAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSkpKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEZsb2F0aW5nQWN0aW9uQnV0dG9uc0NvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBkaXJlY3Rpb246IEZsb2F0aW5nQWN0aW9uQnV0dG9uRGlyZWN0aW9uID0gJ3RvcCc7XG4gICAgQENvbnRlbnRDaGlsZHJlbihUb29sdGlwRGlyZWN0aXZlKSB0b29sdGlwczogUXVlcnlMaXN0PFRvb2x0aXBEaXJlY3RpdmU+O1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFiOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5mYWIub3BlbiQucGlwZShmaWx0ZXIob3BlbiA9PiBvcGVuID09PSBmYWxzZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudG9vbHRpcHMuZm9yRWFjaCh0b29sdGlwID0+IHRvb2x0aXAuaGlkZSgpKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRGV0ZWN0IGFueSBjbGlja3MgdG8gdHJpZ2dlciBjbG9zZSBvZiB0aGUgbWVudVxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pIGNsb3NlKHRhcmdldDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5mYWIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgRmxvYXRpbmdBY3Rpb25CdXR0b25EaXJlY3Rpb24gPSAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JzsiLCJpbXBvcnQgeyBBdHRyaWJ1dGUsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZSB9IGZyb20gJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbicsXG4gICAgdGVtcGxhdGU6IGA8YnV0dG9uIGNsYXNzPVwiYnRuIGZsb2F0aW5nLWFjdGlvbi1idXR0b25cIiBcbiAgICAgICAgW2NsYXNzLmJ1dHRvbi1wcmltYXJ5XT1cInByaW1hcnlcIiBcbiAgICAgICAgW2NsYXNzLmJ1dHRvbi1zZWNvbmRhcnldPVwiIXByaW1hcnlcIiBcbiAgICAgICAgKGNsaWNrKT1cInByaW1hcnkgPyBmYWIudG9nZ2xlKCkgOiBmYWIuY2xvc2UoKVwiPlxuXG4gICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBmbG9hdGluZy1hY3Rpb24tYnV0dG9uLWljb25cIiAqbmdJZj1cImljb25cIiBbbmdDbGFzc109XCJpY29uXCI+PC9zcGFuPlxuICAgIDxuZy1jb250ZW50ICpuZ0lmPVwiIWljb25cIj48L25nLWNvbnRlbnQ+XG5cbjwvYnV0dG9uPmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaWNvbjogc3RyaW5nO1xuICAgIEBIb3N0QmluZGluZygpIHRhYmluZGV4ID0gMTtcblxuICAgIHByaW1hcnk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKEBBdHRyaWJ1dGUoJ2ZhYi1wcmltYXJ5JykgcHJpbWFyeTogc3RyaW5nLCBwdWJsaWMgZmFiOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeSA9IHByaW1hcnkgIT09IG51bGw7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQgfSBmcm9tICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uc0NvbXBvbmVudCxcbiAgICAgICAgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQsXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhclNlcnZpY2Uge1xuXG4gICAgbm9kZXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxIaWVyYXJjaHlCYXJOb2RlW10+KFtdKTtcblxuICAgIHByaXZhdGUgX3Jvb3Q6IEhpZXJhcmNoeUJhck5vZGU7XG4gICAgcHJpdmF0ZSBfbm9kZXM6IEhpZXJhcmNoeUJhck5vZGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgaGllcmFyY2h5IHRyZWVcbiAgICAgKi9cbiAgICBzZXRSb290Tm9kZShyb290OiBIaWVyYXJjaHlCYXJOb2RlKSB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcblxuICAgICAgICAvLyBjcmVhdGUgYSBmbGF0IHN0cnVjdHVyZSBvZiBub2Rlc1xuICAgICAgICB0aGlzLl9ub2RlcyA9IHRoaXMuZ2V0Tm9kZUxpc3Qocm9vdCk7XG5cbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgYXJyYXkgLSBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgbm9kZVxuICAgICAgICB0aGlzLm5vZGVzJC5uZXh0KHRoaXMuZ2V0U2VsZWN0ZWRDaGlsZHJlbihyb290KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgbm9kZS4gVGhpcyBjYXVzZXMgYWxsIG5vZGVzIHRvIGJlXG4gICAgICogZGVzZWxlY3RlZCBhbmQgdGhlIHBhdGggdG8gdGhlIHNlbGVjdGVkIG5vZGVcbiAgICAgKiB0byBiZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIHNlbGVjdE5vZGUobm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRlc2VsZWN0IGFsbCBub2Rlc1xuICAgICAgICB0aGlzLmRlc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBjdXJyZW50IG5vZGUgaXMgc2VsZWN0ZWQgYW5kIGl0cyBwYXJlbnRzXG4gICAgICAgIHRoaXMuc2VsZWN0KG5vZGUpO1xuXG4gICAgICAgIC8vIGVtaXQgYSBuZXcgbm9kZSBsaXN0IHRvIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICB0aGlzLm5vZGVzJC5uZXh0KHRoaXMuZ2V0U2VsZWN0ZWRDaGlsZHJlbih0aGlzLl9yb290KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBnZXR0aW5nIGNoaWxkcmVuIHdpdGggc3VwcG9ydCBmb3IgYm90aCBhcnJheXMgYW5kIG9ic2VydmFibGVzXG4gICAgICovXG4gICAgZ2V0Q2hpbGRyZW4obm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IE9ic2VydmFibGU8SGllcmFyY2h5QmFyTm9kZUNoaWxkcmVuPiB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBvZih7IGxvYWRpbmc6IGZhbHNlLCBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbiB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuJDogT2JzZXJ2YWJsZTxIaWVyYXJjaHlCYXJOb2RlW10+ID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAvLyBpZiBpdCBpcyBhbiBvYnNlcnZhYmxlIHRoZW4gaGFuZGxlIGxvYWRpbmdcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8SGllcmFyY2h5QmFyTm9kZUNoaWxkcmVuPikgPT4ge1xuICAgICAgICAgICAgLy8gZW1pdCBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHsgbG9hZGluZzogdHJ1ZSwgY2hpbGRyZW46IFtdIH0pO1xuXG4gICAgICAgICAgICAvLyBub3cgd2FpdCB1bnRpbCB0aGUgY2hpbGRyZW4gb2JzZXJ2YWJsZSBjb21wbGV0ZXNcbiAgICAgICAgICAgIGNoaWxkcmVuJC5waXBlKGZpcnN0KCkpLnN1YnNjcmliZShjaGlsZHJlbiA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBvYnNlcnZhYmxlIHdpdGggYW4gYXJyYXkgZm9yIGZ1dHVyZSBsb2FkaW5nXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVidWlsZCB0aGUgbm9kZSB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb290Tm9kZSh0aGlzLl9yb290KTtcblxuICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhlIGxhdGVzdCB2YWx1ZVxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyBsb2FkaW5nOiBmYWxzZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIG9ic2VydmFibGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgYWxsIHRoZSBwYXJlbnRzIHRvIGVuc3VyZSB0aGV5IGFyZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIHByaXZhdGUgc2VsZWN0KG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiB2b2lkIHtcbiAgICAgICAgbm9kZS5zZWxlY3RlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChub2RlLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYWxsIG5vZGVzXG4gICAgICovXG4gICAgcHJpdmF0ZSBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUuc2VsZWN0ZWQgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdGhlIG5vZGVzIGluIHRoZSB0cmVlIGFzIGEgZmxhdCBhcnJheS5cbiAgICAgKiBJdCBhbHNvIHN0b3JlcyB0aGUgcGFyZW50IG5vZGUgaW4gYSBwYXJlbnQgcHJvcGVydHlcbiAgICAgKiBvbiB0aGUgbm9kZSBmb3IgZWFzeSB0cmF2ZXJzYWwgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXROb2RlTGlzdChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogSGllcmFyY2h5QmFyTm9kZVtdIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4gdGhlbiByZXR1cm4gb25seSBpdHNlbGZcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGRyZW4gaW5zdGFuY2VvZiBPYnNlcnZhYmxlIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHBhcmVudCBwcm9wZXJ0eVxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucGFyZW50ID0gbm9kZSk7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGVcbiAgICAgICAgY29uc3QgZGVzY2VuZGFudHMgPSBub2RlLmNoaWxkcmVuLnJlZHVjZTxIaWVyYXJjaHlCYXJOb2RlW10+KChub2RlcywgY3VycmVudCkgPT4gWy4uLm5vZGVzLCAuLi50aGlzLmdldE5vZGVMaXN0KGN1cnJlbnQpXSwgW10pO1xuXG4gICAgICAgIHJldHVybiBbbm9kZSwgLi4uZGVzY2VuZGFudHNdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHNlbGVjdGVkIG5vZGVzIGZyb20gdGhlIHBhcmVudCBub2RlLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0U2VsZWN0ZWRDaGlsZHJlbihub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogSGllcmFyY2h5QmFyTm9kZVtdIHtcblxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGNoaWxkcmVuIC0gYW5kIGFjY291bnQgZm9yIHdoZW4gdGhlcmUgaXMgbm9uZVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgW107XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IGNoaWxkIGlzIHNlbGVjdGVkXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW4uZmluZChfY2hpbGQgPT4gX2NoaWxkLnNlbGVjdGVkKTtcblxuICAgICAgICAvLyByZXR1cm4gdGhlIHJlbWFpbmluZyBjaGFpbiBvZiBzZWxlY3RlZCBpdGVtc1xuICAgICAgICByZXR1cm4gY2hpbGQgPyBbbm9kZSwgLi4udGhpcy5nZXRTZWxlY3RlZENoaWxkcmVuKGNoaWxkKV0gOiBbbm9kZV07XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpZXJhcmNoeUJhck5vZGUge1xuICAgIGljb24/OiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBzZWxlY3RlZD86IGJvb2xlYW47XG4gICAgcGFyZW50PzogSGllcmFyY2h5QmFyTm9kZTtcbiAgICBjaGlsZHJlbj86IEhpZXJhcmNoeUJhck5vZGVbXSB8IE9ic2VydmFibGU8SGllcmFyY2h5QmFyTm9kZVtdPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaWVyYXJjaHlCYXJOb2RlQ2hpbGRyZW4ge1xuICAgIGxvYWRpbmc6IGJvb2xlYW47XG4gICAgY2hpbGRyZW46IEhpZXJhcmNoeUJhck5vZGVbXTtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkLCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEhpZXJhcmNoeUJhck5vZGUsIEhpZXJhcmNoeUJhclNlcnZpY2UgfSBmcm9tICcuL2hpZXJhcmNoeS1iYXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtaGllcmFyY2h5LWJhcicsXG4gICAgdGVtcGxhdGU6IGA8IS0tIEFsbG93IGNvbnRlbnQgdG8gYmUgcGxhY2VkIG9uIHRoZSBsZWZ0IG9mIHRoZSBpdGVtcyAtLT5cbjxhc2lkZSBjbGFzcz1cImhpZXJhcmNoeS1iYXItYWRkb25zXCI+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW3V4SGllcmFyY2h5QmFyTGVmdEFkZG9uXVwiPjwvbmctY29udGVudD5cbjwvYXNpZGU+XG5cbjxtYWluICNub2RlbGlzdCBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZXNcIiAodXhSZXNpemUpPVwic2Nyb2xsSW50b1ZpZXcoKVwiPlxuXG4gICAgPGRpdiAqbmdJZj1cIm92ZXJmbG93JCB8IGFzeW5jXCJcbiAgICAgICAgICNwb3BvdmVyPVwidXgtcG9wb3ZlclwiXG4gICAgICAgICBjbGFzcz1cImhpZXJhcmNoeS1iYXItb3ZlcmZsb3ctaW5kaWNhdG9yXCJcbiAgICAgICAgIFtzdHlsZS5sZWZ0LnB4XT1cIm5vZGVsaXN0LnNjcm9sbExlZnRcIlxuICAgICAgICAgW3V4UG9wb3Zlcl09XCJvdmVyZmxvd1wiXG4gICAgICAgICBbcG9wb3ZlckNvbnRleHRdPVwieyBwb3BvdmVyOiBwb3BvdmVyIH1cIlxuICAgICAgICAgcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgIHBvcG92ZXJDbGFzcz1cImhpZXJhcmNoeS1iYXItcG9wb3ZlclwiPlxuICAgICAgICAuIC4gLlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiAjbm9kZUVsZW1lbnQgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGVcIlxuICAgICAgICAgKm5nRm9yPVwibGV0IG5vZGUgb2YgaGllcmFyY2h5QmFyLm5vZGVzJCB8IGFzeW5jXCI+XG5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1jb250ZW50XCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm5vZGUudGl0bGVcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJoaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShub2RlKVwiPlxuXG4gICAgICAgICAgICA8IS0tIFNob3cgYW4gaWNvbiBpZiBzcGVjaWZlZCAtLT5cbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtaWNvblwiICpuZ0lmPVwibm9kZS5pY29uXCIgW3NyY109XCJub2RlLmljb25cIiBhbHQ9XCJIaWVyYXJjaHkgQmFyIEljb25cIj5cblxuICAgICAgICAgICAgPCEtLSBTaG93IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG5vZGUgLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS10aXRsZVwiPnt7IG5vZGUudGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgPCEtLSBTaG93IGEgZHJvcGRvd24gYXJyb3cgaWYgdGhlcmUgYXJlIGNoaWxkcmVuIC0tPlxuICAgICAgICA8YnV0dG9uICpuZ0lmPVwibm9kZS5jaGlsZHJlblwiXG4gICAgICAgICAgICAgICNwb3BvdmVyPVwidXgtcG9wb3ZlclwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTaG93IGNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWFycm93IGhwZS1pY29uIGhwZS1uZXh0XCJcbiAgICAgICAgICAgICAgW3V4UG9wb3Zlcl09XCJjb250ZW50XCJcbiAgICAgICAgICAgICAgW3BvcG92ZXJDb250ZXh0XT1cInsgbm9kZTogbm9kZSwgcG9wb3ZlcjogcG9wb3ZlciB9XCJcbiAgICAgICAgICAgICAgcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICAgcG9wb3ZlckNsYXNzPVwiaGllcmFyY2h5LWJhci1wb3BvdmVyXCJcbiAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgIDwvYnV0dG9uPlxuXG4gICAgPC9kaXY+XG5cbjwvbWFpbj5cblxuPCEtLSBBbGxvdyBjb250ZW50IHRvIGJlIHBsYWNlZCBvbiB0aGUgcmlnaHQgb2YgdGhlIGl0ZW1zIC0tPlxuPGFzaWRlIGNsYXNzPVwiaGllcmFyY2h5LWJhci1hZGRvbnNcIj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbdXhIaWVyYXJjaHlCYXJSaWdodEFkZG9uXVwiPjwvbmctY29udGVudD5cbjwvYXNpZGU+XG5cbjwhLS0gVGVtcGxhdGUgZm9yIHRoZSBwb3BvdmVyIGxpc3QgLS0+XG48bmctdGVtcGxhdGUgI2NvbnRlbnQgbGV0LW5vZGU9XCJub2RlXCIgbGV0LXBvcG92ZXI9XCJwb3BvdmVyXCI+XG5cbiAgICA8IS0tIExvYWRpbmcgSW5kaWNhdG9yIC0tPlxuICAgIDx1bCBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1saXN0XCIgKm5nSWY9XCIoaGllcmFyY2h5QmFyLmdldENoaWxkcmVuKG5vZGUpIHwgYXN5bmMpLmxvYWRpbmdcIj5cblxuICAgICAgICA8bGkgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtbGlzdC1pdGVtXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxvYWRpbmdJbmRpY2F0b3IgfHwgZGVmYXVsdExvYWRpbmdJbmRpY2F0b3JcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9saT5cbiAgICA8L3VsPlxuXG4gICAgPCEtLSBMaXN0IG9mIGNoaWxkcmVuIC0tPlxuICAgIDx1bCBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1saXN0XCIgKm5nSWY9XCIhKGhpZXJhcmNoeUJhci5nZXRDaGlsZHJlbihub2RlKSB8IGFzeW5jKS5sb2FkaW5nXCI+XG5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjaGlsZCBvZiAoaGllcmFyY2h5QmFyLmdldENoaWxkcmVuKG5vZGUpIHwgYXN5bmMpLmNoaWxkcmVuOyBsZXQgZmlyc3QgPSBmaXJzdFwiXG4gICAgICAgICAgICBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1saXN0LWl0ZW1cIlxuICAgICAgICAgICAgW2ZvY3VzSWZdPVwiZmlyc3RcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cImhpZXJhcmNoeUJhci5zZWxlY3ROb2RlKGNoaWxkKTsgcG9wb3Zlci5oaWRlKClcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImhpZXJhcmNoeUJhci5zZWxlY3ROb2RlKGNoaWxkKTsgcG9wb3Zlci5oaWRlKClcIj5cblxuICAgICAgICAgICAgPCEtLSBTaG93IGFuIGljb24gaWYgc3BlY2lmZWQgLS0+XG4gICAgICAgICAgICA8aW1nIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWljb25cIiAqbmdJZj1cImNoaWxkLmljb25cIiBbc3JjXT1cImNoaWxkLmljb25cIiBhbHQ9XCJIaWVyYXJjaHkgQmFyIEljb25cIj5cblxuICAgICAgICAgICAgPCEtLSBTaG93IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG5vZGUgLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS10aXRsZVwiPnt7IGNoaWxkLnRpdGxlIH19PC9zcGFuPlxuXG4gICAgICAgIDwvbGk+XG5cbiAgICA8L3VsPlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLSBUZW1wbGF0ZSBmb3IgdGhlIG92ZXJmbG93IHBvcG92ZXIgbGlzdCAtLT5cbjxuZy10ZW1wbGF0ZSAjb3ZlcmZsb3cgbGV0LXBvcG92ZXI9XCJwb3BvdmVyXCI+XG5cbiAgICA8dWwgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtbGlzdFwiPlxuXG4gICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgY2hpbGQgb2Ygb3ZlcmZsb3dOb2RlcyQgfCBhc3luYzsgbGV0IGZpcnN0ID0gZmlyc3RcIlxuICAgICAgICAgICAgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtbGlzdC1pdGVtXCJcbiAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICBbZm9jdXNJZl09XCJmaXJzdFwiXG4gICAgICAgICAgICAoY2xpY2spPVwiaGllcmFyY2h5QmFyLnNlbGVjdE5vZGUoY2hpbGQpOyBwb3BvdmVyLmhpZGUoKVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJoaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShjaGlsZCk7IHBvcG92ZXIuaGlkZSgpXCI+XG5cbiAgICAgICAgICAgIDwhLS0gU2hvdyBhbiBpY29uIGlmIHNwZWNpZmVkIC0tPlxuICAgICAgICAgICAgPGltZyBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1pY29uXCIgKm5nSWY9XCJjaGlsZC5pY29uXCIgW3NyY109XCJjaGlsZC5pY29uXCIgYWx0PVwiSGllcmFyY2h5IEJhciBJY29uXCI+XG5cbiAgICAgICAgICAgIDwhLS0gU2hvdyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBub2RlIC0tPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtdGl0bGVcIj57eyBjaGlsZC50aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICA8L2xpPlxuXG4gICAgPC91bD5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gTG9hZGluZyBJbmRpY2F0b3IgVGVtcGxhdGUgLS0+XG48bmctdGVtcGxhdGUgI2RlZmF1bHRMb2FkaW5nSW5kaWNhdG9yPlxuICAgIDxkaXYgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtaWNvblwiIGFsdD1cIkhpZXJhcmNoeSBCYXIgTG9hZGluZyBJbmRpY2F0b3JcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNwaW5uZXIgc3Bpbm5lci1hY2NlbnQgc3Bpbm5lci1ib3VuY2UtbWlkZGxlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIFNob3cgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbm9kZSAtLT5cbiAgICA8c3BhbiBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS10aXRsZVwiPkxvYWRpbmcuLi48L3NwYW4+XG48L25nLXRlbXBsYXRlPmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgdmlld1Byb3ZpZGVyczogW0hpZXJhcmNoeUJhclNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBzZXQgcm9vdChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2h5QmFyLnNldFJvb3ROb2RlKG5vZGUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIHNldCBzZWxlY3RlZChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2h5QmFyLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgfVxuXG4gICAgQElucHV0KCkgbG9hZGluZ0luZGljYXRvcjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SGllcmFyY2h5QmFyTm9kZT4oKTtcbiAgICBAVmlld0NoaWxkKCdub2RlbGlzdCcpIG5vZGVsaXN0OiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGRyZW4oJ25vZGVFbGVtZW50Jykgbm9kZXM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcblxuICAgIG92ZXJmbG93JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIG92ZXJmbG93Tm9kZXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxIaWVyYXJjaHlCYXJOb2RlW10+KFtdKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBoaWVyYXJjaHlCYXI6IEhpZXJhcmNoeUJhclNlcnZpY2UpIHtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgc2VsZWN0ZWQgbm9kZVxuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IGhpZXJhcmNoeUJhci5ub2RlcyQuc3Vic2NyaWJlKG5vZGVzID0+IHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdChub2Rlcy5sZW5ndGggPT09IDAgPyBudWxsIDogbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0pKTtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IGhpZXJhcmNoeUJhci5ub2RlcyQucGlwZShkZWJvdW5jZVRpbWUoMCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNjcm9sbEludG9WaWV3KCkpO1xuXG4gICAgICAgIC8vIHN0b3JlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoY2hhbmdlZCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlcmUgaXMgb3ZlcmZsb3cgZW5zdXJlIHRoYXQgdGhlIHJpZ2h0bW9zdFxuICAgICAqIG5vZGUgcmVtYWlucyBpbiB2aWV3IGF0IGFsbCB0aW1lcy4gVGhlIG5vZGVzIG5vIGxvbmdlclxuICAgICAqIHZpc2libGUgYmUgYmUgZGlzcGxheWVkIGluIGEgcG9wb3ZlciBhdmFpbGFibGUgb24gdGhlXG4gICAgICogb3ZlcmZsb3cgaW5kaWNhdG9yXG4gICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCF0aGlzLm5vZGVsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIG5hdGl2ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgbmF0aXZlRWxlbWVudCB9ID0gdGhpcy5ub2RlbGlzdDtcblxuICAgICAgICAvLyBlbWl0IHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIG92ZXJmbG93XG4gICAgICAgIHRoaXMub3ZlcmZsb3ckLm5leHQobmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCA+IG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBoaWVyYXJjaHkgYmFyIGNvbnRlbnRzIGRvIG5vdCBvdmVyZmxvdyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKG5hdGl2ZUVsZW1lbnQuc2Nyb2xsV2lkdGggPiBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoKSB7XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgYW1vdW50IG9mIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvd0Ftb3VudCA9IG5hdGl2ZUVsZW1lbnQuc2Nyb2xsV2lkdGggLSBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggbm9kZXMgYXJlIG5vdCBmdWxseSB2aXNpYmxlXG4gICAgICAgICAgICB0aGlzLm92ZXJmbG93Tm9kZXMkLm5leHQoXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLm5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdCA8IG92ZXJmbG93QW1vdW50KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChub2RlLCBpbmRleCkgPT4gdGhpcy5oaWVyYXJjaHlCYXIubm9kZXMkLnZhbHVlW2luZGV4XSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byBhbHdheXMgc2hvdyB0aGUgbGFzdCBpdG1lXG4gICAgICAgICAgICB0aGlzLm5vZGVsaXN0Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdCA9IG92ZXJmbG93QW1vdW50O1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgXG4gICAgc2VsZWN0b3I6ICdbdXhDbGlja091dHNpZGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBDbGlja091dHNpZGVEaXJlY3RpdmUge1xuXG4gICAgQE91dHB1dCgpIHV4Q2xpY2tPdXRzaWRlID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50J10pXG4gICAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy51eENsaWNrT3V0c2lkZS5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xpY2tPdXRzaWRlRGlyZWN0aXZlIH0gZnJvbSAnLi9jbGljay1vdXRzaWRlLmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbQ2xpY2tPdXRzaWRlRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtDbGlja091dHNpZGVEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIENsaWNrT3V0c2lkZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgVG9vbHRpcENvbXBvbmVudCB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5sZXQgdW5pcXVlUG9wb3ZlcklkID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtcG9wb3ZlcicsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBvcG92ZXIgc2hvd1wiIFtuZ0NsYXNzXT1cIltwbGFjZW1lbnQsIGN1c3RvbUNsYXNzXVwiIFtpZF09XCJpZFwiIFthdHRyLnJvbGVdPVwicm9sZVwiICh1eENsaWNrT3V0c2lkZSk9XCJjbGlja091dHNpZGUkLm5leHQoJGV2ZW50KVwiPlxuICAgIDxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PlxuICAgIDxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIiAqbmdJZj1cInRpdGxlXCI+e3sgdGl0bGUgfX08L2gzPlxuICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnRcIiAoY2RrT2JzZXJ2ZUNvbnRlbnQpPVwicmVwb3NpdGlvbigpXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZVJlZlwiPnt7IGNvbnRlbnQgfX08L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImlzVGVtcGxhdGVSZWZcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb250ZW50XCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cImNvbnRleHRcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvZGl2PmAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJDb21wb25lbnQgZXh0ZW5kcyBUb29sdGlwQ29tcG9uZW50IHtcblxuICAvKiogRGVmaW5lIGEgdW5pcXVlIGlkIGZvciBlYWNoIHBvcG92ZXIgKi9cbiAgaWQ6IHN0cmluZyA9IGB1eC1wb3BvdmVyLSR7Kyt1bmlxdWVQb3BvdmVySWR9YDtcblxuICAvKiogSWYgc3BlY2lmaWVkIGFsbG93cyB0aGUgcG9wb3ZlciB0byBzaG93IGEgdGl0bGUgKi9cbiAgdGl0bGU6IHN0cmluZztcblxuICAvKiogVGhpcyB3aWxsIGVtaXQgYW4gZXZlbnQgYW55IHRpbWUgdGhlIHVzZXIgY2xpY2tzIG91dHNpZGUgdGhlIHBvcG92ZXIgKi9cbiAgY2xpY2tPdXRzaWRlJCA9IG5ldyBTdWJqZWN0PE1vdXNlRXZlbnQ+KCk7XG5cbiAgLyoqIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHRpdGxlIG9mIHRoZSBwb3BvdmVyIGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gKi9cbiAgc2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxufSIsImltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBPdmVybGF5UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tcG9uZW50UG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRvb2x0aXBEaXJlY3RpdmUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IFBvcG92ZXJDb21wb25lbnQgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhQb3BvdmVyXScsXG4gICAgZXhwb3J0QXM6ICd1eC1wb3BvdmVyJ1xufSlcbmV4cG9ydCBjbGFzcyBQb3BvdmVyRGlyZWN0aXZlIGV4dGVuZHMgVG9vbHRpcERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIC8qKiBDb250YWlucyB0aGUgY29udGVudCBvZiB0aGUgcG9wb3ZlciBvciBhIFRlbXBsYXRlUmVmIGZvciBtb3JlIGRldGFpbGVkIGNvbnRlbnQgKi9cbiAgICBASW5wdXQoJ3V4UG9wb3ZlcicpIGNvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKiogT3B0aW9uYWxseSBkaXNwbGF5IGEgdGl0bGUgaW4gdGhlIHBvcG92ZXIgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJUaXRsZScpIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKiogQWxsb3cgdGhlIHBvcG92ZXIgdG8gYmUgY29uZGl0aW9uYWxseSBkaXNhYmxlZCAqL1xuICAgIEBJbnB1dCgncG9wb3ZlckRpc2FibGVkJykgZGlzYWJsZWQ6IGJvb2xlYW47XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIGN1c3RvbSBjbGFzcyB0byB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgncG9wb3ZlckNsYXNzJykgY3VzdG9tQ2xhc3M6IHN0cmluZyA9ICcnO1xuXG4gICAgLyoqIEFsbCB0aGUgdXNlciB0byBhZGQgYSByb2xlIHRvIHRoZSBwb3BvdmVyIC0gZGVmYXVsdCBpcyB0b29sdGlwICovXG4gICAgQElucHV0KCdwb3BvdmVyUm9sZScpIHJvbGU6IHN0cmluZyA9ICd0b29sdGlwJztcblxuICAgIC8qKiBQcm92aWRlIHRoZSBUZW1wbGF0ZVJlZiBhIGNvbnRleHQgb2JqZWN0ICovXG4gICAgQElucHV0KCdwb3BvdmVyQ29udGV4dCcpIGNvbnRleHQ6IGFueSA9IHt9O1xuXG4gICAgLyoqIERlbGF5IHRoZSBzaG93aW5nIG9mIHRoZSBwb3BvdmVyIGJ5IGEgbnVtYmVyIG9mIG1pbGlzZWNvbmRzICovXG4gICAgQElucHV0KCdwb3BvdmVyRGVsYXknKSBkZWxheTogbnVtYmVyID0gMDtcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgc2hvdyB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgpIHNob3dUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ2NsaWNrJ107XG5cbiAgICAvKiogU3BlY2lmeSB3aGljaCBldmVudHMgc2hvdWxkIGhpZGUgdGhlIHBvcG92ZXIgKi9cbiAgICBASW5wdXQoKSBoaWRlVHJpZ2dlcnM6IHN0cmluZ1tdID0gWydjbGljaycsICdjbGlja291dHNpZGUnLCAnZXNjYXBlJ107XG5cbiAgICAvKiogS2VlcCB0cmFjayBvZiB0aGUgdG9vbHRpcCB2aXNpYmlsaXR5IGFuZCB1cGRhdGUgYXJpYS1leHBhbmRlZCBhdHRyaWJ1dGUgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1leHBhbmRlZCcpIGlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBDREsgcG9ydGFsIGNvbnRhaW5pbmcgdGhlIG92ZXJsYXkgKi9cbiAgICBwcm90ZWN0ZWQgX3BvcnRhbDogQ29tcG9uZW50UG9ydGFsPFBvcG92ZXJDb21wb25lbnQ+O1xuXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiB0aGUgcG9wb3ZlciBjb21wb25lbnQgd2hlbiBjcmVhdGVkICovXG4gICAgcHJvdGVjdGVkIF9pbnN0YW5jZTogUG9wb3ZlckNvbXBvbmVudDtcblxuICAgIC8qKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gYXJpYS1kZXNjcmliZWRieSBwcm9wZXJ0eSBvcmlnaW5hbGx5IGV4aXN0ZWQgb24gdGhlIGVsZW1lbnQgKi9cbiAgICBwcml2YXRlIF9hcmlhRGVzY3JpYmVkQnk6IGJvb2xlYW47XG5cbiAgICAvKiogSW50ZXJuYWxseSBzdG9yZSB0aGUgdHlwZSBvZiB0aGlzIGNvbXBvbmVudCAtIHVzdWFsIGZvciBkaXN0aW5jdGlvbnMgd2hlbiBleHRlbmRpbmcgdGhlIHRvb2x0aXAgY2xhc3MgKi9cbiAgICBwcm90ZWN0ZWQgX3R5cGU6IHN0cmluZyA9ICdwb3BvdmVyJztcblxuICAgIC8qKiBTZXQgdXAgdGhlIHRyaWdnZXJzIGFuZCBiaW5kIHRvIHRoZSBzaG93L2hpZGUgZXZlbnRzIHRvIGtlZXAgdmlzaWJpbGl0eSBpbiBzeW5jICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBldmVudCB0cmlnZ2Vyc1xuICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFuIGFyaWEtZGVzY3JpYmVkIGJ5IGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLl9hcmlhRGVzY3JpYmVkQnkgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBkZWZhdWx0IGV2ZW50IHRyaWdnZXJzXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBzZW5kIGlucHV0IGNoYW5nZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50XG4gICAgICogV2UgY2FuJ3QgdXNlIHNldHRlcnMgYXMgdGhleSBtYXkgdHJpZ2dlciBiZWZvcmUgcG9wb3ZlciBpbml0aWFsaXNlZCBhbmQgY2FuJ3QgcmVzZW5kIG9uY2UgaW5pdGlhbGlzZWRcbiAgICAgKiovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy50aXRsZSkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0VGl0bGUoY2hhbmdlcy50aXRsZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluc3RhbmNlKG92ZXJsYXlSZWY6IE92ZXJsYXlSZWYpOiBQb3BvdmVyQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBvdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9wb3J0YWwpLmluc3RhbmNlIGFzIFBvcG92ZXJDb21wb25lbnQ7XG5cbiAgICAgICAgLy8gc3VwcGx5IHRoZSB0b29sdGlwIHdpdGggdGhlIGNvcnJlY3QgcHJvcGVydGllc1xuICAgICAgICBpbnN0YW5jZS5zZXRUaXRsZSh0aGlzLnRpdGxlKTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpbnN0YW5jZS5zZXRQbGFjZW1lbnQodGhpcy5wbGFjZW1lbnQpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDbGFzcyh0aGlzLmN1c3RvbUNsYXNzKTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgICBpbnN0YW5jZS5zZXRSb2xlKHRoaXMucm9sZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLnNldEFyaWFEZXNjcmliZWRCeShpbnN0YW5jZS5pZCk7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBvdXRzaWRlIGNsaWNrIGV2ZW50XG4gICAgICAgIGluc3RhbmNlLmNsaWNrT3V0c2lkZSQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25DbGlja091dHNpZGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBjcmVhdGVQb3J0YWwoKTogQ29tcG9uZW50UG9ydGFsPFBvcG92ZXJDb21wb25lbnQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbCB8fCBuZXcgQ29tcG9uZW50UG9ydGFsKFBvcG92ZXJDb21wb25lbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdmlzaWJsZSBhbmQgdGhlIGVzY2FwZSBrZXkgaXMgcHJlc3NlZCBhbmQgaXQgaXMgb25lIG9mIHRoZSBoaWRlIHRyaWdnZXJzXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUgJiYgdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ2VzY2FwZScpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25DbGlja091dHNpZGUoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIHZpc2libGUgYW5kIGl0IGlzIG9uZSBvZiB0aGUgaGlkZSB0cmlnZ2Vyc1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ2NsaWNrb3V0c2lkZScpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQcm9ncmFtbWF0aWNhbGx5IHVwZGF0ZSB0aGUgYXJpYS1kZXNjcmliZWRieSBwcm9wZXJ0eSAqL1xuICAgIHByb3RlY3RlZCBzZXRBcmlhRGVzY3JpYmVkQnkoaWQ6IHN0cmluZyB8IG51bGwpOiB2b2lkIHtcblxuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gc2V0IHRoZSBhcmlhLWRlc2NyaWJlZGJ5IGF0dHIgd2hlbiB0aGUgY29udGVudCBpcyBhIHN0cmluZyBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgZGVmaW5lZCBhdHRyaWJ1dGUgYWxyZWFkeVxuICAgICAgICBpZiAodGhpcy5fYXJpYURlc2NyaWJlZEJ5ID09PSBmYWxzZSAmJiB0eXBlb2YgdGhpcy5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3VwZXIuc2V0QXJpYURlc2NyaWJlZEJ5KGlkKTtcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7IE9ic2VydmVyc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vYnNlcnZlcnMnO1xuaW1wb3J0IHsgT3ZlcmxheU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xpY2tPdXRzaWRlTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlL2luZGV4JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IFBvcG92ZXJDb21wb25lbnQgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFBvcG92ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3BvcG92ZXIuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIE9ic2VydmVyc01vZHVsZSxcbiAgICBDbGlja091dHNpZGVNb2R1bGUsXG4gICAgVG9vbHRpcE1vZHVsZVxuICBdLFxuICBleHBvcnRzOiBbUG9wb3ZlckRpcmVjdGl2ZV0sXG4gIGRlY2xhcmF0aW9uczogW1BvcG92ZXJDb21wb25lbnQsIFBvcG92ZXJEaXJlY3RpdmVdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtQb3BvdmVyQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBQb3BvdmVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c0lmTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb2N1cy1pZi9pbmRleCc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBIaWVyYXJjaHlCYXJDb21wb25lbnQgfSBmcm9tICcuL2hpZXJhcmNoeS1iYXIuY29tcG9uZW50JztcbmltcG9ydCB7IFBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9wb3BvdmVyL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUmVzaXplTW9kdWxlLFxuICAgICAgICBGb2N1c0lmTW9kdWxlLFxuICAgICAgICBQb3BvdmVyTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbSGllcmFyY2h5QmFyQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtIaWVyYXJjaHlCYXJDb21wb25lbnRdLFxufSlcbmV4cG9ydCBjbGFzcyBIaWVyYXJjaHlCYXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxTZXJ2aWNlIHtcblxuICAgIG9wZW4kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG5cbiAgICBvcGVuKCkge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dChmYWxzZSk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgU2lkZVBhbmVsU2VydmljZSB9IGZyb20gJy4vc2lkZS1wYW5lbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zaWRlLXBhbmVsJyxcbiAgICBleHBvcnRBczogJ3V4LXNpZGUtcGFuZWwnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdJZj1cIm1vZGFsICYmIG9wZW5cIiBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wXCJcbiAgICBbc3R5bGUucG9zaXRpb25dPVwicG9zaXRpb25cIlxuICAgIFtzdHlsZS50b3BdPVwiY3NzVG9wXCI+PC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWhvc3RcIlxuICAgIFtjbGFzcy5tb2RhbC1wYW5lbF09XCJtb2RhbFwiXG4gICAgW3N0eWxlLnBvc2l0aW9uXT1cInBvc2l0aW9uXCJcbiAgICBbc3R5bGUud2lkdGhdPVwiaG9zdFdpZHRoXCJcbiAgICBbc3R5bGUudG9wXT1cImNzc1RvcFwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuYCxcbiAgICBwcm92aWRlcnM6IFtTaWRlUGFuZWxTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd1eC1zaWRlLXBhbmVsJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgU2lkZVBhbmVsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLm9wZW4nKVxuICAgIGdldCBvcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLm9wZW4kLnZhbHVlO1xuICAgIH1cblxuICAgIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuc2VydmljZS5vcGVuJC5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaW5saW5lJylcbiAgICBpbmxpbmUgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgYXR0YWNoVG86ICd3aW5kb3cnIHwgJ2NvbnRhaW5lcicgPSAnd2luZG93JztcblxuICAgIEBJbnB1dCgpXG4gICAgd2lkdGg6IHN0cmluZyB8IG51bWJlciA9ICc1MCUnO1xuXG4gICAgQElucHV0KClcbiAgICB0b3A6IHN0cmluZyB8IG51bWJlciA9ICcwJztcblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtbW9kYWwnKVxuICAgIG1vZGFsID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuYW5pbWF0ZScpXG4gICAgYW5pbWF0ZSA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBjbG9zZU9uRXh0ZXJuYWxDbGljayA9IGZhbHNlO1xuXG4gICAgQE91dHB1dCgpXG4gICAgb3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N0YXRpYyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXR0YWNoVG8gPT09ICdjb250YWluZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Fic29sdXRlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2ZpeGVkJztcbiAgICB9XG5cbiAgICBnZXQgY3NzV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IDAgPyAnMCcgOiB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9XG5cbiAgICBnZXQgY3NzVG9wKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50b3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3AgPT09IDAgPyAnMCcgOiB0aGlzLnRvcCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9wO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnc3R5bGUud2lkdGgnKVxuICAgIGdldCBjb21wb25lbnRXaWR0aCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLmNzc1dpZHRoIDogJzAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGdldCBob3N0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubGluZSA/ICcxMDAlJyA6IHRoaXMuY3NzV2lkdGg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIHNlcnZpY2U6IFNpZGVQYW5lbFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWZcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuc2VydmljZS5vcGVuJC5zdWJzY3JpYmUoKG5leHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KG5leHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgb3BlblBhbmVsKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2Uub3BlbigpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmtleXVwLmVzY2FwZScpXG4gICAgY2xvc2VQYW5lbCgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudCddKVxuICAgIGNsaWNrSGFuZGxlcihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMub3BlbiB8fCAhdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkgfHxcbiAgICAgICAgICAgICh0YXJnZXQgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnbW9kYWwtYmFja2Ryb3AnKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgU2lkZVBhbmVsQ29tcG9uZW50IH0gZnJvbSAnLi4vc2lkZS1wYW5lbC9zaWRlLXBhbmVsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTaWRlUGFuZWxTZXJ2aWNlIH0gZnJvbSAnLi4vc2lkZS1wYW5lbC9zaWRlLXBhbmVsLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEl0ZW1EaXNwbGF5UGFuZWxDb250ZW50XSdcbn0pXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbENvbnRlbnREaXJlY3RpdmUgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SXRlbURpc3BsYXlQYW5lbEZvb3Rlcl0nXG59KVxuZXhwb3J0IGNsYXNzIEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmUgeyB9XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtaXRlbS1kaXNwbGF5LXBhbmVsJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWhvc3QgdXgtaXRlbS1kaXNwbGF5LXBhbmVsXCJcbiAgICBbY2xhc3MuYm94LXNoYWRvd109XCJib3hTaGFkb3dcIlxuICAgIFtzdHlsZS5wb3NpdGlvbl09XCJwb3NpdGlvblwiXG4gICAgW3N0eWxlLndpZHRoXT1cImhvc3RXaWR0aFwiXG4gICAgW3N0eWxlLnRvcF09XCJjc3NUb3BcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWhlYWRlclwiIFtjbGFzcy5pdGVtLWRpc3BsYXktcGFuZWwtc2hhZG93XT1cInNoYWRvd1wiPlxuICAgICAgICA8aDM+e3sgaGVhZGVyIH19PC9oMz5cbiAgICAgICAgPGJ1dHRvbiAqbmdJZj1cImNsb3NlVmlzaWJsZVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGcgYnRuLWxpbmsgYnRuLWljb24gYnV0dG9uLXNlY29uZGFyeVwiIChjbGljayk9XCJ2aXNpYmxlID0gZmFsc2VcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb24gaHBlLWNsb3NlXCI+PC9pPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zaWRlLXBhbmVsLWNvbnRlbnRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW3V4SXRlbURpc3BsYXlQYW5lbENvbnRlbnRdXCI+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXNpZGUtcGFuZWwtZm9vdGVyXCIgKm5nSWY9XCJmb290ZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW3V4SXRlbURpc3BsYXlQYW5lbEZvb3Rlcl1cIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuYCxcbiAgICBwcm92aWRlcnM6IFtTaWRlUGFuZWxTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd1eC1zaWRlLXBhbmVsIHV4LWl0ZW0tZGlzcGxheS1wYW5lbCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEl0ZW1EaXNwbGF5UGFuZWxDb21wb25lbnQgZXh0ZW5kcyBTaWRlUGFuZWxDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG5cbiAgICBASW5wdXQoKSBib3hTaGFkb3c6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KCkgY2xvc2VWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGdldCBwcmV2ZW50Q2xvc2UoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljaztcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBwcmV2ZW50Q2xvc2UodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayA9ICF2YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzaGFkb3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBDb250ZW50Q2hpbGQoSXRlbURpc3BsYXlQYW5lbEZvb3RlckRpcmVjdGl2ZSkgZm9vdGVyOiBJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlO1xuXG4gICAgQE91dHB1dCgpIHZpc2libGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVGl0bGUgdXNlZCBmb3IgYWRkaW5nIHRvb2x0aXBzIGFuZCBzaG91bGRuJ3QgYmUgdXNlZCBhcyBhbiBpbnB1dFxuICAgICAqIGluc3RlYWQgaGVhZGVyIHdpbGwgYmUgdXNlZC4gVGhpcyBpcyBoZXJlIHRvIHN1cHBvcnQgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbmx5XG4gICAgICogdGhpcyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgdGl0bGUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLmhlYWRlciA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHZpc2libGUodmlzaWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLm9wZW4gPSB2aXNpYmxlO1xuICAgIH1cblxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2l0ZW1EaXNwbGF5UGFuZWxTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2U6IFNpZGVQYW5lbFNlcnZpY2UsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgc3VwZXIoc2VydmljZSwgZWxlbWVudFJlZik7XG5cbiAgICAgICAgdGhpcy5hbmltYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl9pdGVtRGlzcGxheVBhbmVsU3Vic2NyaXB0aW9uID0gdGhpcy5zZXJ2aWNlLm9wZW4kLnN1YnNjcmliZSgobmV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlLmVtaXQobmV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9pdGVtRGlzcGxheVBhbmVsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCwgSXRlbURpc3BsYXlQYW5lbENvbnRlbnREaXJlY3RpdmUsIEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmUgfSBmcm9tICcuL2l0ZW0tZGlzcGxheS1wYW5lbC5jb21wb25lbnQnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCxcbiAgICBJdGVtRGlzcGxheVBhbmVsQ29udGVudERpcmVjdGl2ZSxcbiAgICBJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbE1vZHVsZSB7fSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXdpemFyZC1zdGVwJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nSWY9XCJhY3RpdmVcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L25nLWNvbnRhaW5lcj5gXG59KVxuZXhwb3J0IGNsYXNzIFdpemFyZFN0ZXBDb21wb25lbnQge1xuICAgIFxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSB2aXNpdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgcHJpdmF0ZSBfYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdmlzaXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KCkgXG4gICAgZ2V0IHZpc2l0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdGVkO1xuICAgIH1cblxuICAgIHNldCB2aXNpdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0ZWQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aXNpdGVkQ2hhbmdlLm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIHNldCBhY3RpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgXG4gICAgICAgIC8vIHN0b3JlIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHN0ZXBcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIHRydWUgdGhlbiB0aGUgc3RlcCBzaG91bGQgYWxzbyBiZSBtYXJrZWQgYXMgdmlzaXRlZFxuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cblxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC13aXphcmQnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cIndpemFyZC1ib2R5XCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwid2l6YXJkLXN0ZXBzXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cIndpemFyZC1zdGVwXCIgW2NsYXNzLmFjdGl2ZV09XCJzdHAuYWN0aXZlXCIgW2NsYXNzLnZpc2l0ZWRdPVwic3RwLnZpc2l0ZWRcIiBbY2xhc3MuaW52YWxpZF09XCJzdHAuYWN0aXZlICYmICFzdHAudmFsaWQgJiYgaW52YWxpZEluZGljYXRvclwiIChjbGljayk9XCJnb3RvU3RlcChzdHApXCIgKm5nRm9yPVwibGV0IHN0cCBvZiBzdGVwc1wiPlxuICAgICAgICAgICAge3sgc3RwLmhlYWRlciB9fVxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIndpemFyZC1jb250ZW50XCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJ3aXphcmQtZm9vdGVyXCI+XG4gICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1zZWNvbmRhcnlcIiAqbmdJZj1cInByZXZpb3VzVmlzaWJsZVwiIFt1eFRvb2x0aXBdPVwicHJldmlvdXNUb29sdGlwXCIgW2Rpc2FibGVkXT1cInByZXZpb3VzRGlzYWJsZWQgfHwgc3RlcCA9PT0gMFwiXG4gICAgICAgIChjbGljayk9XCJwcmV2aW91cygpOyB0aXAuaGlkZSgpXCI+e3sgcHJldmlvdXNUZXh0IH19PC9idXR0b24+XG5cbiAgICA8YnV0dG9uICN0aXA9XCJ1eC10b29sdGlwXCIgY2xhc3M9XCJidG4gYnV0dG9uLXByaW1hcnlcIiAqbmdJZj1cIm5leHRWaXNpYmxlICYmICFpc0xhc3RTdGVwKClcIiBbdXhUb29sdGlwXT1cIm5leHRUb29sdGlwXCIgW2Rpc2FibGVkXT1cIm5leHREaXNhYmxlZFwiXG4gICAgICAgIChjbGljayk9XCJuZXh0KCk7IHRpcC5oaWRlKClcIj57eyBuZXh0VGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1wcmltYXJ5XCIgKm5nSWY9XCJmaW5pc2hWaXNpYmxlICYmIGlzTGFzdFN0ZXAoKSB8fCBmaW5pc2hBbHdheXNWaXNpYmxlXCIgW3V4VG9vbHRpcF09XCJmaW5pc2hUb29sdGlwXCJcbiAgICAgICAgW2Rpc2FibGVkXT1cImZpbmlzaERpc2FibGVkXCIgKGNsaWNrKT1cImZpbmlzaCgpOyB0aXAuaGlkZSgpXCI+e3sgZmluaXNoVGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1zZWNvbmRhcnlcIiAqbmdJZj1cImNhbmNlbFZpc2libGUgJiYgIWlzTGFzdFN0ZXAoKSB8fCBjYW5jZWxBbHdheXNWaXNpYmxlXCIgW3V4VG9vbHRpcF09XCJjYW5jZWxUb29sdGlwXCJcbiAgICAgICAgW2Rpc2FibGVkXT1cImNhbmNlbERpc2FibGVkXCIgKGNsaWNrKT1cImNhbmNlbCgpOyB0aXAuaGlkZSgpXCI+e3sgY2FuY2VsVGV4dCB9fTwvYnV0dG9uPlxuPC9kaXY+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3NdJzogJ29yaWVudGF0aW9uJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBwcml2YXRlIF9zdGVwOiBudW1iZXIgPSAwO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihXaXphcmRTdGVwQ29tcG9uZW50KSBzdGVwcyA9IG5ldyBRdWVyeUxpc3Q8V2l6YXJkU3RlcENvbXBvbmVudD4oKTtcblxuICAgIEBJbnB1dCgpIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuXG4gICAgQElucHV0KCkgbmV4dFRleHQ6IHN0cmluZyA9ICdOZXh0JztcbiAgICBASW5wdXQoKSBwcmV2aW91c1RleHQ6IHN0cmluZyA9ICdQcmV2aW91cyc7XG4gICAgQElucHV0KCkgY2FuY2VsVGV4dDogc3RyaW5nID0gJ0NhbmNlbCc7XG4gICAgQElucHV0KCkgZmluaXNoVGV4dDogc3RyaW5nID0gJ0ZpbmlzaCc7XG5cbiAgICBASW5wdXQoKSBuZXh0VG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBuZXh0IHN0ZXAnO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBwcmV2aW91cyBzdGVwJztcbiAgICBASW5wdXQoKSBjYW5jZWxUb29sdGlwOiBzdHJpbmcgPSAnQ2FuY2VsIHRoZSB3aXphcmQnO1xuICAgIEBJbnB1dCgpIGZpbmlzaFRvb2x0aXA6IHN0cmluZyA9ICdGaW5pc2ggdGhlIHdpemFyZCc7XG5cbiAgICBASW5wdXQoKSBuZXh0RGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBwcmV2aW91c0Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgY2FuY2VsRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBmaW5pc2hEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KCkgbmV4dFZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgY2FuY2VsVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZmluaXNoVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgY2FuY2VsQWx3YXlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGZpbmlzaEFsd2F5c1Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKSBvbk5leHQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgICBAT3V0cHV0KCkgb25QcmV2aW91cyA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICAgIEBPdXRwdXQoKSBvbkNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgb25GaW5pc2hpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIG9uRmluaXNoID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBzdGVwQ2hhbmdpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFN0ZXBDaGFuZ2luZ0V2ZW50PigpO1xuICAgIEBPdXRwdXQoKSBzdGVwQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBpbnZhbGlkSW5kaWNhdG9yOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICB9XG4gICAgc2V0IHN0ZXAodmFsdWU6IG51bWJlcikge1xuXG4gICAgICAgIC8vIG9ubHkgYWNjZXB0IG51bWJlcnMgYXMgdmFsaWQgb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgYWN0aXZlIHN0ZXBcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHdoaWNoIHN0ZXBzIHNob3VsZCBiZSBhY3RpdmVcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgdGhpcy5zdGVwQ2hhbmdlLm5leHQodGhpcy5zdGVwKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludmFsaWQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEluZGljYXRvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGluaXRpYWxseSBzZXQgdGhlIGNvcnJlY3QgdmlzaWJpbGl0eSBvZiB0aGUgc3RlcHNcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byB0aGUgbmV4dCBzdGVwXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLnN0ZXBDaGFuZ2luZy5uZXh0KG5ldyBTdGVwQ2hhbmdpbmdFdmVudCh0aGlzLnN0ZXAsIHRoaXMuc3RlcCArIDEpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHN0ZXAgaXMgaW52YWxpZFxuICAgICAgICBpZiAoIXRoaXMuZ2V0Q3VycmVudFN0ZXAoKS52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkSW5kaWNhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gdGhlIGxhc3Qgc3RlcFxuICAgICAgICBpZiAoKHRoaXMuc3RlcCArIDEpIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcCsrO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgICAgIHRoaXMub25OZXh0Lm5leHQodGhpcy5zdGVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBzdGVwXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5zdGVwQ2hhbmdpbmcubmV4dChuZXcgU3RlcENoYW5naW5nRXZlbnQodGhpcy5zdGVwLCB0aGlzLnN0ZXAgLSAxKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiB0aGUgbGFzdCBzdGVwXG4gICAgICAgIGlmICh0aGlzLnN0ZXAgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAtLTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgY3VycmVudCBzdGVwXG4gICAgICAgICAgICB0aGlzLm9uUHJldmlvdXMubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhY3Rpb25zIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZpbmlzaCgpOiBQcm9taXNlPHZvaWQ+IHtcblxuICAgICAgICAvLyBmaXJlcyB3aGVuIHRoZSBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgYWx3YXlzXG4gICAgICAgIHRoaXMub25GaW5pc2hpbmcubmV4dCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2Ugd2UgbmVlZCB0byBlbnN1cmUgY2hhbmdlIGRldGVjdGlvbiBoYXMgcnVuXG4gICAgICAgICAqIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB3ZSBoYXZlIHRoZSBsYXRlc3QgdmFsdWUgZm9yIHRoZSAndmFsaWQnIGlucHV0XG4gICAgICAgICAqIG9uIHRoZSBjdXJyZW50IHN0ZXAuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QgdXNlIENoYW5nZURldGVjdG9yUmVmIGFzIHdlIGFyZSBsb29raW5nIHRvIHJ1blxuICAgICAgICAgKiBvbiBjb250ZW50IGNoaWxkcmVuLCBhbmQgd2UgY2FudCB1c2UgQXBwbGljYXRpb25SZWYudGljaygpIGFzIHRoaXMgZG9lcyBub3Qgd29yayBpbiBhIGh5YnJpZCBhcHAsIGVnLiBvdXIgZG9jc1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGZpcmVzIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIHN0ZXAgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50U3RlcCgpLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25GaW5pc2gubmV4dCgpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWN0aW9ucyB3aGVuIHRoZSBjYW5jZWwgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBjYW5jZWwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DYW5jZWwubmV4dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYWN0aXZlIHN0YXRlIG9mIGVhY2ggc3RlcFxuICAgICAqL1xuICAgIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gdXBkYXRlIHdoaWNoIHN0ZXBzIHNob3VsZCBiZSBhY3RpdmVcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwLCBpZHgpID0+IHN0ZXAuYWN0aXZlID0gaWR4ID09PSB0aGlzLnN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1bXAgdG8gYSBzcGVjaWZpYyBzdGVwIG9ubHkgaWYgdGhlIHN0ZXAgaGFzIHByZXZpb3VzbHkgYmVlbiB2aXNpdGVkXG4gICAgICovXG4gICAgZ290b1N0ZXAoc3RlcDogV2l6YXJkU3RlcENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoc3RlcC52aXNpdGVkKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJbmRleCA9IHRoaXMuc3RlcHMudG9BcnJheSgpLmZpbmRJbmRleChzdHAgPT4gc3RwID09PSBzdGVwKTtcblxuICAgICAgICAgICAgdGhpcy5zdGVwQ2hhbmdpbmcubmV4dChuZXcgU3RlcENoYW5naW5nRXZlbnQodGhpcy5zdGVwLCBzdGVwSW5kZXgpKTtcblxuICAgICAgICAgICAgdGhpcy5zdGVwID0gc3RlcEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHN0ZXAgaXMgdGhlIGxhc3Qgc3RlcFxuICAgICAqL1xuICAgIGlzTGFzdFN0ZXAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXAgPT09ICh0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB3aXphcmQgLSBnb2VzIHRvIGZpcnN0IHN0ZXAgYW5kIHJlc2V0cyB2aXNpdGVkIHN0YXRlXG4gICAgICovXG4gICAgcmVzZXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gbWFyayBhbGwgc3RlcHMgYXMgbm90IHZpc2l0ZWRcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gc3RlcC52aXNpdGVkID0gZmFsc2UpO1xuXG4gICAgICAgIC8vIGdvIHRvIHRoZSBmaXJzdCBzdGVwXG4gICAgICAgIHRoaXMuc3RlcCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGVwIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICovXG4gICAgZ2V0Q3VycmVudFN0ZXAoKTogV2l6YXJkU3RlcENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXBBdEluZGV4KHRoaXMuc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RlcCBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RlcEF0SW5kZXgoaW5kZXg6IG51bWJlcik6IFdpemFyZFN0ZXBDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy50b0FycmF5KClbaW5kZXhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0ZXBDaGFuZ2luZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZnJvbTogbnVtYmVyLCBwdWJsaWMgdG86IG51bWJlcikgeyB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBXaXphcmRDb21wb25lbnQgfSBmcm9tICcuL3dpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFdpemFyZENvbXBvbmVudCxcbiAgICBXaXphcmRTdGVwQ29tcG9uZW50XG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBpcyByZXF1aXJlZCB0byBwcm92aWRlIGEgZm9ybSBvZiBjb21tdW5pY2F0aW9uXG4gKiBiZXR3ZWVuIHRoZSBtYXJxdWVlIHdpemFyZCBzdGVwcyBhbmQgdGhlIGNvbnRhaW5pbmcgbWFycXVlZSB3aXphcmQuXG4gKiBXZSBjYW5ub3QgaW5qZWN0IHRoZSBIb3N0IGR1ZSB0byB0aGUgc3RlcHMgYmVpbmcgY29udGVudCBjaGlsZHJlbiBcbiAqIHJhdGhlciB0aGFuIHZpZXcgY2hpbGRyZW4uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkU2VydmljZSB7XG4gICAgdmFsaWQkID0gbmV3IFN1YmplY3Q8TWFycXVlZVdpemFyZFZhbGlkRXZlbnQ+KCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFZhbGlkRXZlbnQge1xuICAgIHN0ZXA6IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50O1xuICAgIHZhbGlkOiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTZXJ2aWNlIH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tYXJxdWVlLXdpemFyZC1zdGVwJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nSWY9XCJhY3RpdmVcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L25nLWNvbnRhaW5lcj5gXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50IGV4dGVuZHMgV2l6YXJkU3RlcENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBpY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY29tcGxldGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQE91dHB1dCgpIGNvbXBsZXRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgICBcbiAgICBnZXQgdmFsaWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgICB9XG5cbiAgICBzZXQgdmFsaWQodmFsaWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmFsaWQgPSB2YWxpZDtcblxuICAgICAgICBpZiAodGhpcy5fbWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcnF1ZWVXaXphcmRTZXJ2aWNlLnZhbGlkJC5uZXh0KHsgc3RlcDogdGhpcywgdmFsaWQ6IHZhbGlkIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFycXVlZVdpemFyZFNlcnZpY2U6IE1hcnF1ZWVXaXphcmRTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjb21wbGV0ZWQgc3RhdGUgYW5kIGVtaXQgdGhlIGxhdGVzdCB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb21wbGV0ZWQgd2hldGhlciBvciBub3QgdGhlIHN0ZXAgaXMgY29tcGxldGVkXG4gICAgICovXG4gICAgc2V0Q29tcGxldGVkKGNvbXBsZXRlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGNvbXBsZXRlZDtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWRDaGFuZ2UuZW1pdChjb21wbGV0ZWQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgSW5wdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFdpemFyZENvbXBvbmVudCB9IGZyb20gJy4uL3dpemFyZC9pbmRleCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZFNlcnZpY2UsIE1hcnF1ZWVXaXphcmRWYWxpZEV2ZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tYXJxdWVlLXdpemFyZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwibWFycXVlZS13aXphcmQtc2lkZS1wYW5lbFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLWRlc2NyaXB0aW9uLWNvbnRhaW5lclwiICpuZ0lmPVwiZGVzY3JpcHRpb25cIj5cbiAgICAgICAgPCEtLSBJZiBhIHRlbXBsYXRlIHdhcyBwcm92aWRlZCBkaXNwbGF5IGl0IC0tPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaXNUZW1wbGF0ZVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRlc2NyaXB0aW9uXCI+PC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPCEtLSBPdGhlcndpc2Ugd2ltcGx5IGRpc3BsYXkgdGhlIHN0cmluZyAtLT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlXCI+XG4gICAgICAgICAgICA8cD57eyBkZXNjcmlwdGlvbiB9fTwvcD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8dWwgY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1zdGVwc1wiPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLXN0ZXBcIiAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwc1wiIChjbGljayk9XCJnb3RvU3RlcChzdGVwKVwiIFtjbGFzcy5hY3RpdmVdPVwic3RlcC5hY3RpdmVcIiBbY2xhc3MudmlzaXRlZF09XCJzdGVwLnZpc2l0ZWRcIiBbY2xhc3MuaW52YWxpZF09XCIhc3RlcC52YWxpZFwiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1zdGVwLWljb25cIiBbbmdDbGFzc109XCJzdGVwLmljb25cIj48L2k+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLXN0ZXAtdGl0bGVcIj57eyBzdGVwLmhlYWRlciB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibWFycXVlZS13aXphcmQtc3RlcC1zdGF0dXMgaHBlLWljb24gaHBlLWNoZWNrbWFya1wiICpuZ0lmPVwic3RlcC5jb21wbGV0ZWRcIj48L3NwYW4+XG4gICAgICAgIDwvbGk+XG5cbiAgICA8L3VsPlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1jb250ZW50LXBhbmVsXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLWNvbnRlbnRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuXG4gICAgICAgIDxidXR0b24gI3RpcD1cInV4LXRvb2x0aXBcIiBjbGFzcz1cImJ0biBidXR0b24tc2Vjb25kYXJ5XCIgKm5nSWY9XCJwcmV2aW91c1Zpc2libGVcIiBbdXhUb29sdGlwXT1cInByZXZpb3VzVG9vbHRpcFwiIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cInByZXZpb3VzRGlzYWJsZWQgfHwgc3RlcCA9PT0gMFwiIChjbGljayk9XCJwcmV2aW91cygpOyB0aXAuaGlkZSgpXCI+e3sgcHJldmlvdXNUZXh0IH19PC9idXR0b24+XG5cbiAgICAgICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1wcmltYXJ5XCIgKm5nSWY9XCJuZXh0VmlzaWJsZSAmJiAhaXNMYXN0U3RlcCgpXCIgW3V4VG9vbHRpcF09XCJuZXh0VG9vbHRpcFwiIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cIm5leHREaXNhYmxlZFwiIChjbGljayk9XCJuZXh0KCk7IHRpcC5oaWRlKClcIj57eyBuZXh0VGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgICAgIDxidXR0b24gI3RpcD1cInV4LXRvb2x0aXBcIiBjbGFzcz1cImJ0biBidXR0b24tcHJpbWFyeVwiICpuZ0lmPVwiZmluaXNoVmlzaWJsZSAmJiBpc0xhc3RTdGVwKCkgfHwgZmluaXNoQWx3YXlzVmlzaWJsZVwiIFt1eFRvb2x0aXBdPVwiZmluaXNoVG9vbHRpcFwiXG4gICAgICAgICAgICBjb250YWluZXI9XCJib2R5XCIgW2Rpc2FibGVkXT1cImZpbmlzaERpc2FibGVkXCIgKGNsaWNrKT1cImZpbmlzaCgpOyB0aXAuaGlkZSgpXCI+e3sgZmluaXNoVGV4dCB9fTwvYnV0dG9uPlxuXG4gICAgICAgIDxidXR0b24gI3RpcD1cInV4LXRvb2x0aXBcIiBjbGFzcz1cImJ0biBidXR0b24tc2Vjb25kYXJ5XCIgKm5nSWY9XCJjYW5jZWxWaXNpYmxlICYmICFpc0xhc3RTdGVwKCkgfHwgY2FuY2VsQWx3YXlzVmlzaWJsZVwiIFt1eFRvb2x0aXBdPVwiY2FuY2VsVG9vbHRpcFwiXG4gICAgICAgICAgICBjb250YWluZXI9XCJib2R5XCIgW2Rpc2FibGVkXT1cImNhbmNlbERpc2FibGVkXCIgKGNsaWNrKT1cImNhbmNlbCgpOyB0aXAuaGlkZSgpXCI+e3sgY2FuY2VsVGV4dCB9fTwvYnV0dG9uPlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBwcm92aWRlcnM6IFsgTWFycXVlZVdpemFyZFNlcnZpY2UgXVxufSlcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkQ29tcG9uZW50IGV4dGVuZHMgV2l6YXJkQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGRyZW4oTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQpIHN0ZXBzID0gbmV3IFF1ZXJ5TGlzdDxNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudD4oKTtcblxuICAgIGdldCBpc1RlbXBsYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbiAmJiB0aGlzLmRlc2NyaXB0aW9uIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IobWFycXVlZVdpemFyZFNlcnZpY2U6IE1hcnF1ZWVXaXphcmRTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgbWFycXVlZVdpemFyZFNlcnZpY2UudmFsaWQkLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGV2ZW50OiBNYXJxdWVlV2l6YXJkVmFsaWRFdmVudCkgPT4gIWV2ZW50LnZhbGlkKVxuICAgICAgICApLnN1YnNjcmliZSh0aGlzLnZhbGlkQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBjdXJyZW50IHN0ZXAgaXMgdmFsaWQsIG1hcmsgaXQgYXNcbiAgICAgKiBjb21wbGV0ZSBhbmQgZ28gdG8gdGhlIG5leHQgc3RlcFxuICAgICAqL1xuICAgIG5leHQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKSBhcyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudDtcblxuICAgICAgICBpZiAoc3RlcC52YWxpZCkge1xuICAgICAgICAgICAgc3VwZXIubmV4dCgpO1xuXG4gICAgICAgICAgICAvLyBtYXJrIHRoaXMgc3RlcCBhcyBjb21wbGV0ZWRcbiAgICAgICAgICAgIHN0ZXAuc2V0Q29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdCB0aGUgb25GaW5pc2hpbmcgZXZlbnQgYW5kIGlmIHZhbGlkIHRoZSBvbkZpbmlzaCBldmVudC5cbiAgICAgKiBBbHNvIG1hcmsgdGhlIGZpbmFsIHN0ZXAgYXMgY29tcGxldGVkIGlmIGl0IGlzIHZhbGlkXG4gICAgICovXG4gICAgZmluaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBzdGVwXG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCkgYXMgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQ7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgb3JpZ2luYWwgZmluaXNoIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBzdXBlci5maW5pc2goKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGVwIGlzIHZhbGlkIGluZGljYXRlIHRoYXQgaXQgaXMgbm93IGNvbXBsZXRlXG4gICAgICAgICAgICBpZiAoc3RlcC52YWxpZCkge1xuICAgICAgICAgICAgICAgIHN0ZXAuc2V0Q29tcGxldGVkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBhIHN0ZXAgaW4gdGhlIHdpemFyZCBiZWNvbWVzIGludmFsaWQsIGFsbCBzdGVwcyBzZXF1ZW50aWFsbHkgYWZ0ZXJcbiAgICAgKiBpdCwgc2hvdWxkIGJlY29tZSB1bnZpc2l0ZWQgYW5kIGluY29tcGxldGVcbiAgICAgKi9cbiAgICB2YWxpZENoYW5nZShzdGF0ZTogTWFycXVlZVdpemFyZFZhbGlkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBzdGVwcyA9IHRoaXMuc3RlcHMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gc3RlcHMuZmluZEluZGV4KHN0ZXAgPT4gc3RlcCA9PT0gc3RhdGUuc3RlcCk7XG4gICAgICAgIGNvbnN0IGFmZmVjdGVkID0gc3RlcHMuc2xpY2UoY3VycmVudCk7XG5cbiAgICAgICAgYWZmZWN0ZWQuZm9yRWFjaChzdGVwID0+IHtcblxuICAgICAgICAgICAgLy8gdGhlIHN0ZXAgc2hvdWxkIG5vIGxvbmdlciBiZSBjb21wbGV0ZWRcbiAgICAgICAgICAgIHN0ZXAuY29tcGxldGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGVwIGlzIG5vdCB0aGUgY3VycmVudCBzdGVwIHRoZW4gYWxzbyBtYXJrIGl0IGFzIHVudmlzaXRlZFxuICAgICAgICAgICAgaWYgKHN0ZXAgIT09IHN0YXRlLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBzdGVwLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFdpemFyZE1vZHVsZSB9IGZyb20gJy4uL3dpemFyZC9pbmRleCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgV2l6YXJkTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE1hcnF1ZWVXaXphcmRDb21wb25lbnQsXG4gICAgICAgIE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50XG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgTWFycXVlZVdpemFyZENvbXBvbmVudCxcbiAgICAgICAgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwLCBSZXNwb25zZUNvbnRlbnRUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBdWRpb1NlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBfYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyO1xuICAgIHByaXZhdGUgX2F1ZGlvQnVmZmVyU291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XG4gICAgcHJpdmF0ZSBfYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBfZ2Fpbk5vZGU6IEdhaW5Ob2RlO1xuICAgIHByaXZhdGUgX2FuYWx5c2VyTm9kZTogQW5hbHlzZXJOb2RlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaHR0cDogSHR0cCkgeyB9XG5cbiAgICBnZXRBdWRpb0ZpbGVNZXRhZGF0YShtZWRpYUVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9NZXRhZGF0YT4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAucmVxdWVzdChtZWRpYUVsZW1lbnQuc3JjLCB7IHJlc3BvbnNlVHlwZTogUmVzcG9uc2VDb250ZW50VHlwZS5CbG9iIH0pLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IG1lZGlhRWxlbWVudC5zcmMuc3Vic3RyaW5nKG1lZGlhRWxlbWVudC5zcmMubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1lZGlhRWxlbWVudC5zcmMuc3Vic3RyaW5nKG1lZGlhRWxlbWVudC5zcmMubGFzdEluZGV4T2YoJy4nKSArIDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb247XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnTVBFRyBhdWRpbyBsYXllciAzIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd21hJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ1dpbmRvd3MgbWVkaWEgYXVkaW8gZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YXYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnV0FWRSBhdWRpbyBmaWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdPZ2cgVm9yYmlzIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ0FkdmFuY2VkIGF1ZGlvIGNvZGluZyBmaWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGknOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnTXVzaWNhbCBpbnN0cnVtZW50IGRpZ2l0YWwgaW50ZXJmYWNlIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ0F1ZGlvIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogYmxvYi5zaXplXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0V2F2ZWZvcm1Gcm9tVXJsKHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxGbG9hdDMyQXJyYXlbXT4ge1xuXG4gICAgICAgIC8vIGlmIGF1ZGlvIGNvbnRleHQgaXMgbm90IHN1cHBvcnQgcmV0dXJuIGEgc3RyZWFtIG9mIGVtcHR5IGRhdGFcbiAgICAgICAgaWYgKCEoPGFueT53aW5kb3cpLkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG9mPEZsb2F0MzJBcnJheVtdPihbbmV3IEZsb2F0MzJBcnJheSgwKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZvbHVtZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVBbmFseXNlck5vZGUoKTtcblxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxGbG9hdDMyQXJyYXlbXT4pID0+IHtcblxuICAgICAgICAgICAgLy8gbG9hZCB0aGUgbWVkaWEgZnJvbSB0aGUgVVJMIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLl9odHRwLnJlcXVlc3QodXJsLCB7IHJlc3BvbnNlVHlwZTogUmVzcG9uc2VDb250ZW50VHlwZS5BcnJheUJ1ZmZlciB9KS5zdWJzY3JpYmUocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXVkaW9CdWZmZXIocmVzcG9uc2UuYXJyYXlCdWZmZXIoKSkuc3Vic2NyaWJlKGF1ZGlvQnVmZmVyID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGJ1ZmZlciBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhUG9pbnRzOiBGbG9hdDMyQXJyYXlbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuX2F1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgZGF0YSBmcm9tIGVhY2ggY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFubmVsSWR4ID0gMDsgY2hhbm5lbElkeCA8IGNoYW5uZWxzOyBjaGFubmVsSWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQb2ludHNbY2hhbm5lbElkeF0gPSB0aGlzLl9hdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZGF0YVBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW51cCBhZnRlciBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgZGF0YVBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRXYXZlZm9ybVBvaW50cyhjaGFubmVsczogRmxvYXQzMkFycmF5W10gPSBbXSwgc2tpcDogbnVtYmVyID0gMTAwMCk6IFdhdmVmb3JtUG9pbnRbXSB7XG5cbiAgICAgICAgY29uc3Qgd2F2ZWZvcm06IFdhdmVmb3JtUG9pbnRbXSA9IFtdO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGNoYW5uZWxzLmxlbmd0aCA+IDAgPyBjaGFubmVsc1swXS5sZW5ndGggOiAwO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBjaGFubmVsIGRhdGEgdG8gYSBzZXJpZXMgb2Ygd2F2ZWZvcm0gcG9pbnRzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGR1cmF0aW9uOyBpZHggKz0gc2tpcCkge1xuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIHRoZSBjaGFubmVsIGRhdGEgZm9yIGEgc3BlY2lmaWMgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGNoYW5uZWxzLm1hcChjaGFubmVsID0+IGNoYW5uZWxbaWR4XSk7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gcG9pbnQgYW5kIG1heGltdW0gcG9pbnRzIGF0IGVhY2ggcG9zaXRpb24gYWNyb3NzIGFsbCBjaGFubmVsc1xuICAgICAgICAgICAgd2F2ZWZvcm0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluOiBwb2ludHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gY3VycmVudCA8IHByZXZpb3VzID8gY3VycmVudCA6IHByZXZpb3VzKSxcbiAgICAgICAgICAgICAgICBtYXg6IHBvaW50cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBjdXJyZW50ID4gcHJldmlvdXMgPyBjdXJyZW50IDogcHJldmlvdXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3YXZlZm9ybTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEF1ZGlvQnVmZmVyKGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlcik6IE9ic2VydmFibGU8QXVkaW9CdWZmZXI+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9CdWZmZXI+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldE9mZmxpbmVBdWRpb0NvbnRleHQoKS5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIsIChhdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9mZmxpbmVBdWRpb0NvbnRleHQoKTogT2ZmbGluZUF1ZGlvQ29udGV4dCB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAyLCB0aGlzLl9hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSB8fCA0NDEwMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpO1xuXG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICB0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLl9hdWRpb0J1ZmZlcjtcbiAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl9hbmFseXNlck5vZGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlVm9sdW1lTm9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB0aGlzLl9nYWluTm9kZS5jb25uZWN0KHRoaXMuX2F1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVBbmFseXNlck5vZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FuYWx5c2VyTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICB0aGlzLl9hbmFseXNlck5vZGUuY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkaXNjb25uZWN0U291cmNlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYXZlZm9ybVBvaW50IHtcbiAgICBtaW46IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb01ldGFkYXRhIHtcbiAgICBmaWxlbmFtZTogc3RyaW5nO1xuICAgIGV4dGVuc2lvbjogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc2l6ZTogbnVtYmVyO1xufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG5pbXBvcnQgeyBBdWRpb1NlcnZpY2UgfSBmcm9tICcuL2F1ZGlvLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFsgSHR0cE1vZHVsZSBdLFxuICAgIHByb3ZpZGVyczogW0F1ZGlvU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQXVkaW9TZXJ2aWNlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvY29uY2F0JztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzL09ic2VydmVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZyYW1lRXh0cmFjdGlvblNlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBjcmVhdGVWaWRlb1BsYXllcihzb3VyY2U6IHN0cmluZyk6IEhUTUxWaWRlb0VsZW1lbnQge1xuICAgICAgICBsZXQgdmlkZW9QbGF5ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB2aWRlb1BsYXllci5wcmVsb2FkID0gJ2F1dG8nO1xuICAgICAgICB2aWRlb1BsYXllci5zcmMgPSBzb3VyY2U7XG4gICAgICAgIHJldHVybiB2aWRlb1BsYXllcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZUNhbnZhcyh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICBwcml2YXRlIGdvVG9GcmFtZSh2aWRlb1BsYXllcjogSFRNTFZpZGVvRWxlbWVudCwgdGltZTogbnVtYmVyKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICAgICAgdmlkZW9QbGF5ZXIuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50KHZpZGVvUGxheWVyLCB0aW1lID09PSAwID8gJ2xvYWRlZGRhdGEnIDogJ3NlZWtlZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyOiBIVE1MVmlkZW9FbGVtZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB0aW1lOiBudW1iZXIsIHdpZHRoOiBudW1iZXIgPSAxNjAsIGhlaWdodDogbnVtYmVyID0gOTApOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RXh0cmFjdGVkRnJhbWU+KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIGdvIHRvIHNwZWNpZmllZCBmcmFtZVxuICAgICAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHRoaXMuZ29Ub0ZyYW1lKHZpZGVvUGxheWVyLCB0aW1lKS5zdWJzY3JpYmUoKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaW1hZ2UgZnJvbSBjdXJyZW50IGZyYW1lXG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHZpZGVvUGxheWVyLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHsgaW1hZ2U6IGNhbnZhcy50b0RhdGFVUkwoKSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdGltZTogdGltZSB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEZyYW1lVGh1bWJuYWlsKHNvdXJjZTogc3RyaW5nLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgdGltZTogbnVtYmVyKTogT2JzZXJ2YWJsZTxFeHRyYWN0ZWRGcmFtZT4ge1xuXG4gICAgICAgIC8vIGNyZWF0ZSByZXF1aXJlZCBlbGVtZW50c1xuICAgICAgICBsZXQgdmlkZW9QbGF5ZXIgPSB0aGlzLmNyZWF0ZVZpZGVvUGxheWVyKHNvdXJjZSk7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBsZXQgZnJhbWVTdWJzY3JpcHRpb24gPSB0aGlzLmdldFRodW1ibmFpbCh2aWRlb1BsYXllciwgY2FudmFzLCB0aW1lLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBlbnN1cmUgd2UgcmVsZWFzZSBtZW1vcnkgYWZ0ZXIgd2UgYXJlIGZpbmlzaGVkXG4gICAgICAgIGZyYW1lU3Vic2NyaXB0aW9uLnN1YnNjcmliZShudWxsLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlb1BsYXllciA9IG51bGw7XG4gICAgICAgICAgICBjYW52YXMgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnJhbWVTdWJzY3JpcHRpb247XG4gICAgfVxuXG4gICAgZ2V0RnJhbWVUaHVtYm5haWxzKHNvdXJjZTogc3RyaW5nLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHNraXA6IG51bWJlciA9IDUpOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlcXVpcmVkIGVsZW1lbnRzXG4gICAgICAgIGxldCB2aWRlb1BsYXllciA9IHRoaXMuY3JlYXRlVmlkZW9QbGF5ZXIoc291cmNlKTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEV4dHJhY3RlZEZyYW1lPikgPT4ge1xuXG4gICAgICAgICAgICBmcm9tRXZlbnQodmlkZW9QbGF5ZXIsICdsb2FkZWRtZXRhZGF0YScpLnN1YnNjcmliZSgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGZyYW1lcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGxldCBmcmFtZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IHN0YXJ0OyBpZHggPCBlbmQ7IGlkeCArPSBza2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lcy5wdXNoKHRoaXMuZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyLCBjYW52YXMsIGlkeCwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbmNhdCguLi5mcmFtZXMpLnN1YnNjcmliZSgoZnJhbWU6IEV4dHJhY3RlZEZyYW1lKSA9PiBvYnNlcnZlci5uZXh0KGZyYW1lKSwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb1BsYXllciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHRyYWN0ZWRGcmFtZSB7XG4gICAgaW1hZ2U6IHN0cmluZztcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xuICAgIHRpbWU6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9mcmFtZS1leHRyYWN0aW9uLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIHByb3ZpZGVyczogW0ZyYW1lRXh0cmFjdGlvblNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBGcmFtZUV4dHJhY3Rpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbSc7XG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJ3J4anMvT2JzZXJ2ZXInO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBFeHRyYWN0ZWRGcmFtZSwgRnJhbWVFeHRyYWN0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ZyYW1lLWV4dHJhY3Rpb24vaW5kZXgnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJUeXBlIH0gZnJvbSAnLi9tZWRpYS1wbGF5ZXIuY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyU2VydmljZSB7XG5cbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICB0eXBlOiBNZWRpYVBsYXllclR5cGUgPSAndmlkZW8nO1xuICAgIGxvYWRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLypcbiAgICAgICAgQ3JlYXRlIG9ic2VydmFibGVzIGZvciBtZWRpYSBwbGF5ZXIgZXZlbnRzXG4gICAgKi9cbiAgICBwbGF5aW5nOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBpbml0RXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGFib3J0RXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIGNhblBsYXlFdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgY2FuUGxheVRocm91Z2hFdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgZHVyYXRpb25DaGFuZ2VFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIGVuZGVkRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIGVycm9yRXZlbnQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgICBsb2FkZWREYXRhRXZlbnQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgICBsb2FkZWRNZXRhZGF0YUV2ZW50OiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgbG9hZFN0YXJ0RXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHBhdXNlRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHBsYXlFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcGxheWluZ0V2ZW50OiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICByYXRlQ2hhbmdlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBzZWVrZWRFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHNlZWtpbmdFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHN0YWxsZWRFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgc3VzcGVuZEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICB0aW1lVXBkYXRlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICB2b2x1bWVDaGFuZ2VFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHdhaXRpbmdFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgbWVkaWFDbGlja0V2ZW50OiBTdWJqZWN0PE1vdXNlRXZlbnQ+ID0gbmV3IFN1YmplY3Q8TW91c2VFdmVudD4oKTtcbiAgICBmdWxsc2NyZWVuRXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHF1aWV0TW9kZUV2ZW50OiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBwcm9ncmVzc0V2ZW50OiBPYnNlcnZhYmxlPFRpbWVSYW5nZXM+ID0gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUaW1lUmFuZ2VzPikgPT4ge1xuXG4gICAgICAgIC8vIHJlcGVhdCB1bnRpbCB0aGUgd2hvbGUgdmlkZW8gaGFzIGZ1bGx5IGxvYWRlZFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBidWZmZXJlZCA9IHRoaXMuX21lZGlhUGxheWVyLmJ1ZmZlcmVkIGFzIFRpbWVSYW5nZXM7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGJ1ZmZlcmVkKTtcblxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA9PT0gMSAmJiBidWZmZXJlZC5zdGFydCgwKSA9PT0gMCAmJiBidWZmZXJlZC5lbmQoMCkgPT09IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTtcbiAgICB9KTtcblxuICAgIHByaXZhdGUgX21lZGlhUGxheWVyOiBIVE1MTWVkaWFFbGVtZW50O1xuICAgIHByaXZhdGUgX2hvc3RFbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9mdWxsc2NyZWVuOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfcXVpZXRNb2RlOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZnJhbWVFeHRyYWN0aW9uU2VydmljZTogRnJhbWVFeHRyYWN0aW9uU2VydmljZSkge31cblxuICAgIC8qXG4gICAgICAgIENyZWF0ZSBhbGwgdGhlIGdldHRlcnMgYW5kIHNldHRlcnMgdGhlIGNhbiBiZSB1c2VkIGJ5IG1lZGlhIHBsYXllciBleHRlbnNpb25zXG4gICAgKi9cbiAgICBnZXQgbWVkaWFQbGF5ZXIoKTogSFRNTE1lZGlhRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllcjtcbiAgICB9XG5cbiAgICBnZXQgcXVpZXRNb2RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVpZXRNb2RlO1xuICAgIH1cblxuICAgIHNldCBxdWlldE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcblxuICAgICAgICAvLyBxdWlldCBtb2RlIGNhbm5vdCBiZSBlbmFibGVkIG9uIGF1ZGlvIHBsYXllclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcXVpZXRNb2RlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucXVpZXRNb2RlRXZlbnQubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IG1lZGlhUGxheWVyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIub2Zmc2V0V2lkdGggOiAwO1xuICAgIH1cblxuICAgIGdldCBtZWRpYVBsYXllckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5vZmZzZXRIZWlnaHQgOiAwO1xuICAgIH1cblxuICAgIGdldCBhdWRpb1RyYWNrcygpOiBBdWRpb1RyYWNrTGlzdCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmF1ZGlvVHJhY2tzIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgYXV0b3BsYXkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmF1dG9wbGF5IDogZmFsc2U7XG4gICAgfVxuICAgIHNldCBhdXRvcGxheSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5hdXRvcGxheSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBidWZmZXJlZCgpOiBUaW1lUmFuZ2VzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuYnVmZmVyZWQgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBjcm9zc09yaWdpbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5jcm9zc09yaWdpbiA6IG51bGw7XG4gICAgfVxuICAgIHNldCBjcm9zc09yaWdpbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmNyb3NzT3JpZ2luID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRTcmMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuY3VycmVudFNyYyA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmN1cnJlbnRUaW1lIDogMDtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRUaW1lKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIuY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZGVmYXVsdE11dGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0TXV0ZWQgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRNdXRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0TXV0ZWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZGVmYXVsdFBsYXliYWNrUmF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0UGxheWJhY2tSYXRlIDogMTtcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRQbGF5YmFja1JhdGUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5kZWZhdWx0UGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGR1cmF0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmR1cmF0aW9uIDogMDtcbiAgICB9XG5cbiAgICBnZXQgZW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmVuZGVkIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGxvb3AoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmxvb3AgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGxvb3AodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIubG9vcCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBtdXRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIubXV0ZWQgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IG11dGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLm11dGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IG5ldHdvcmtTdGF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIubmV0d29ya1N0YXRlO1xuICAgIH1cblxuICAgIGdldCBwYXVzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnBhdXNlZCA6IHRydWU7XG4gICAgfVxuXG4gICAgZ2V0IHBsYXliYWNrUmF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5wbGF5YmFja1JhdGUgOiAxO1xuICAgIH1cbiAgICBzZXQgcGxheWJhY2tSYXRlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHBsYXllZCgpOiBUaW1lUmFuZ2VzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIucGxheWVkIDogbmV3IFRpbWVSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBnZXQgcHJlbG9hZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5wcmVsb2FkIDogJ2F1dG8nO1xuICAgIH1cbiAgICBzZXQgcHJlbG9hZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnByZWxvYWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcmVhZHlTdGF0ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5yZWFkeVN0YXRlIDogMDtcbiAgICB9XG5cbiAgICBnZXQgc2Vla2FibGUoKTogVGltZVJhbmdlcyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnNlZWthYmxlIDogbmV3IFRpbWVSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBnZXQgc2Vla2luZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuc2Vla2luZyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBzcmMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuc3JjIDogJyc7XG4gICAgfVxuICAgIHNldCBzcmModmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5zcmMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdGV4dFRyYWNrcygpOiBUZXh0VHJhY2tMaXN0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIudGV4dFRyYWNrcyA6IG5ldyBUZXh0VHJhY2tMaXN0KCk7XG4gICAgfVxuXG4gICAgZ2V0IHZpZGVvVHJhY2tzKCk6IFZpZGVvVHJhY2tMaXN0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIudmlkZW9UcmFja3MgOiBuZXcgVmlkZW9UcmFja0xpc3QoKTtcbiAgICB9XG5cbiAgICBnZXQgdm9sdW1lKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnZvbHVtZSA6IDE7XG4gICAgfVxuICAgIHNldCB2b2x1bWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci52b2x1bWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZnVsbHNjcmVlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fZnVsbHNjcmVlbiA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgZnVsbHNjcmVlbih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9mdWxsc2NyZWVuID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbkV2ZW50Lm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIHNldE1lZGlhUGxheWVyKGhvc3RFbGVtZW50OiBIVE1MRWxlbWVudCwgbWVkaWFQbGF5ZXI6IEhUTUxNZWRpYUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIgPSBtZWRpYVBsYXllcjtcblxuICAgICAgICB0aGlzLmluaXRFdmVudC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBwbGF5aW5nIHN0YXRlXG4gICAgICovXG4gICAgdG9nZ2xlUGxheSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBwcmV2ZW50IGFueSBhY3Rpb24gaXMgbm90IGxvYWRlZFxuICAgICAgICBpZiAodGhpcy5sb2FkZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHBsYXlpbmcgdGhlIGF1ZGlvL3ZpZGVvXG4gICAgICovXG4gICAgcGxheSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucGxheSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgY3VycmVudGx5IHBsYXlpbmcgYXVkaW8vdmlkZW9cbiAgICAgKi9cbiAgICBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZS1sb2FkcyB0aGUgYXVkaW8vdmlkZW8gZWxlbWVudFxuICAgICAqL1xuICAgIGxvYWQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmxvYWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGJyb3dzZXIgY2FuIHBsYXkgdGhlIHNwZWNpZmllZCBhdWRpby92aWRlbyB0eXBlXG4gICAgICovXG4gICAgY2FuUGxheVR5cGUodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyLmNhblBsYXlUeXBlKHR5cGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgdGV4dCB0cmFjayB0byB0aGUgYXVkaW8vdmlkZW9cbiAgICAgKi9cbiAgICBhZGRUZXh0VHJhY2soa2luZDogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCBsYW5ndWFnZTogc3RyaW5nKTogVGV4dFRyYWNrIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZGlzcGxheSBtZWRpYSBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgKi9cbiAgICByZXF1ZXN0RnVsbHNjcmVlbigpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5faG9zdEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RFbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faG9zdEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RFbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+dGhpcy5faG9zdEVsZW1lbnQpLm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+dGhpcy5faG9zdEVsZW1lbnQpLm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4aXQgZnVsbCBzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIGV4aXRGdWxsc2NyZWVuKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+ZG9jdW1lbnQpLm1zRXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PmRvY3VtZW50KS5tc0V4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKDxhbnk+ZG9jdW1lbnQpLm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PmRvY3VtZW50KS5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdWxsc2NyZWVuQ2hhbmdlKGV2ZW50OiBFdmVudCkge1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSAoPGFueT5kb2N1bWVudCkuZnVsbHNjcmVlbiB8fCBkb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW4gfHwgKDxhbnk+ZG9jdW1lbnQpLm1vekZ1bGxTY3JlZW4gfHwgKDxhbnk+ZG9jdW1lbnQpLm1zRnVsbHNjcmVlbkVsZW1lbnQgIT09IG51bGwgJiYgKDxhbnk+ZG9jdW1lbnQpLm1zRnVsbHNjcmVlbkVsZW1lbnQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuRXZlbnQubmV4dCh0aGlzLmZ1bGxzY3JlZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBGdWxsc2NyZWVuIFN0YXRlXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbHNjcmVlbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgZnJhbWVzIGZyb20gdGhlIHZpZGVvXG4gICAgICovXG4gICAgZ2V0RnJhbWVzKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBza2lwOiBudW1iZXIpOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lRXh0cmFjdGlvblNlcnZpY2UuZ2V0RnJhbWVUaHVtYm5haWxzKHRoaXMuc291cmNlLCB3aWR0aCwgaGVpZ2h0LCAwLCB0aGlzLmR1cmF0aW9uLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbShbXSk7XG4gICAgfVxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQXVkaW9NZXRhZGF0YSwgQXVkaW9TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYXVkaW8vaW5kZXgnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9tZWRpYS1wbGF5ZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbWVkaWEtcGxheWVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ2aWRlby1wbGF5ZXItY29udGFpbmVyXCIgKm5nSWY9XCJ0eXBlID09PSAndmlkZW8nXCI+XG5cbiAgICA8dmlkZW8gY2xhc3M9XCJ2aWRlby1wbGF5ZXJcIlxuICAgICAgICAjcGxheWVyXG4gICAgICAgIFtzcmNdPVwic291cmNlXCJcbiAgICAgICAgKGFib3J0KT1cIm1lZGlhUGxheWVyU2VydmljZS5hYm9ydEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChjYW5wbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5jYW5QbGF5RXZlbnQubmV4dCh0cnVlKVwiXG4gICAgICAgIChjYW5wbGF5dGhyb3VnaCk9XCJtZWRpYVBsYXllclNlcnZpY2UuY2FuUGxheVRocm91Z2hFdmVudC5uZXh0KHRydWUpXCJcbiAgICAgICAgKGR1cmF0aW9uY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbkNoYW5nZUV2ZW50Lm5leHQocGxheWVyLmR1cmF0aW9uKVwiXG4gICAgICAgIChlbmRlZCk9XCJtZWRpYVBsYXllclNlcnZpY2UuZW5kZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoZXJyb3IpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmVycm9yRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRlZGRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZERhdGFFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZGVkbWV0YWRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZE1ldGFkYXRhRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRzdGFydCk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZFN0YXJ0RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBhdXNlKT1cIm1lZGlhUGxheWVyU2VydmljZS5wYXVzZUV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChwbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5wbGF5RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBsYXlpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmdFdmVudC5uZXh0KCFwbGF5ZXIucGF1c2VkKVwiXG4gICAgICAgIChyYXRlY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5yYXRlQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIucGxheWJhY2tSYXRlKVwiXG4gICAgICAgIChzZWVrZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnNlZWtlZEV2ZW50Lm5leHQocGxheWVyLmN1cnJlbnRUaW1lKVwiXG4gICAgICAgIChzZWVraW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS5zZWVraW5nRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHN0YWxsZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnN0YWxsZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoc3VzcGVuZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc3VzcGVuZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgICh0aW1ldXBkYXRlKT1cIm1lZGlhUGxheWVyU2VydmljZS50aW1lVXBkYXRlRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHZvbHVtZWNoYW5nZSk9XCJtZWRpYVBsYXllclNlcnZpY2Uudm9sdW1lQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIudm9sdW1lKVwiXG4gICAgICAgICh3YWl0aW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS53YWl0aW5nRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKGNsaWNrKT1cIm1lZGlhUGxheWVyU2VydmljZS5tZWRpYUNsaWNrRXZlbnQubmV4dCgkZXZlbnQpXCI+XG4gICAgPC92aWRlbz5cblxuICAgIDxkaXYgY2xhc3M9XCJ2aWRlby1vdmVybGF5XCIgW2NsYXNzLnBsYXlpbmddPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmcgfCBhc3luY1wiPlxuICAgICAgICA8c3ZnIGNsYXNzPVwicGxheS1ncmFwaGljXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDY0IDY0XCI+XG4gICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwicGxheS1jaXJjbGVcIiBjeD1cIjMyLjJcIiBjeT1cIjMxLjhcIiByPVwiMzEuOFwiIC8+XG4gICAgICAgICAgICA8cG9seWdvbiBjbGFzcz1cInBsYXktdHJpYW5nbGVcIiBwb2ludHM9XCIyMywxNC4xIDIzLDUwLjggNDguMywzMi41XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuXG5cbjxkaXYgY2xhc3M9XCJhdWRpby1wbGF5ZXJcIiAqbmdJZj1cInR5cGUgPT09ICdhdWRpbydcIj5cblxuICAgIDxzdmcgd2lkdGg9XCIyNHB4XCIgaGVpZ2h0PVwiMjRweFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgPGcgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtOTguMDAwMDAwLCAtNDU4LjAwMDAwMClcIj5cbiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoOTguMDAwMDAwLCA0NTguMDAwMDAwKVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQuNSwwLjUgTDE4LjA0MzUzMDgsMC41IEwyMy41LDYuMjIyNTE1MDIgTDIzLjUsMjMuNSBMNC41LDIzLjUgTDQuNSwwLjUgWlwiIGZpbGw9XCIjQ0NFQUUyXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQuNSw4IEw0LjUsMC41IEwxOCwwLjUgTDIzLjUsNiBMMjMuNSwyMy41IEwxOCwyMy41XCIgc3Ryb2tlPVwiIzYwNzk4RFwiIGZpbGw9XCIjQ0NFQUUyXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQsMTMuNSBMMC41LDEzLjUgTDAuNSwxOC41IEw0LDE4LjUgTDkuNSwyMi41IEw5LjUsOS41IEw0LDEzLjUgWlwiIHN0cm9rZT1cIiM2MDc5OERcIiBmaWxsPVwiIzg1RDJCRVwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMS41LDEyLjUxMzc5MzkgQzEzLjc1NzYyMjUsMTIuNTEzNzkzOSAxNC41LDE0LjM3MDkyMzYgMTQuNSwxNiBDMTQuNSwxNy42ODQ5MjM2IDEzLjcwODkxNTIsMTkuNTQyMDUzMiAxMS41LDE5LjU0MjA1MzJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiIzYwNzk4RFwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMS41LDkgQzE1LjgwMzc2NDMsOS4wNDE2ODcwMSAxOC41LDExLjY2MDQ4MDUgMTguNSwxNiBDMTguNSwyMC4zMzk1MTk1IDE1Ljg4MDQzMDIsMjMuMDA3OTk1NiAxMS41LDIzXCIgc3Ryb2tlPVwiIzYwNzk4RFwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xNy41MjE5MTE2LDAuNzYxNDEzNTc0IEwxNy41MjE5MTE2LDYgTDIzLDZcIiBzdHJva2U9XCIjNjA3OThEXCIgZmlsbD1cIiM4NUQyQkVcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICA8L2c+XG4gICAgPC9zdmc+XG5cbiAgICA8cCBjbGFzcz1cImF1ZGlvLWZpbGUtbmFtZVwiPnt7IChhdWRpb01ldGFkYXRhIHwgYXN5bmMpPy5maWxlbmFtZSB9fTwvcD5cbiAgICA8cCBjbGFzcz1cImF1ZGlvLWZpbGUtZm9ybWF0XCI+e3sgKGF1ZGlvTWV0YWRhdGEgfCBhc3luYyk/LmRlc2NyaXB0aW9uIH19PC9wPlxuICAgIDxwIGNsYXNzPVwiYXVkaW8tZmlsZS1zaXplXCI+e3sgKGF1ZGlvTWV0YWRhdGEgfCBhc3luYyk/LnNpemUgfCBmaWxlU2l6ZSB9fTwvcD5cblxuICAgIDxhdWRpbyAjcGxheWVyXG4gICAgICAgIFtzcmNdPVwic291cmNlXCJcbiAgICAgICAgKGFib3J0KT1cIm1lZGlhUGxheWVyU2VydmljZS5hYm9ydEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChjYW5wbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5jYW5QbGF5RXZlbnQubmV4dCh0cnVlKVwiXG4gICAgICAgIChjYW5wbGF5dGhyb3VnaCk9XCJtZWRpYVBsYXllclNlcnZpY2UuY2FuUGxheVRocm91Z2hFdmVudC5uZXh0KHRydWUpXCJcbiAgICAgICAgKGR1cmF0aW9uY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbkNoYW5nZUV2ZW50Lm5leHQocGxheWVyLmR1cmF0aW9uKVwiXG4gICAgICAgIChlbmRlZCk9XCJtZWRpYVBsYXllclNlcnZpY2UuZW5kZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoZXJyb3IpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmVycm9yRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRlZGRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZERhdGFFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZGVkbWV0YWRhdGEpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZE1ldGFkYXRhRXZlbnQubmV4dCgkZXZlbnQpXCJcbiAgICAgICAgKGxvYWRzdGFydCk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZFN0YXJ0RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBhdXNlKT1cIm1lZGlhUGxheWVyU2VydmljZS5wYXVzZUV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChwbGF5KT1cIm1lZGlhUGxheWVyU2VydmljZS5wbGF5RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBsYXlpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmdFdmVudC5uZXh0KCFwbGF5ZXIucGF1c2VkKVwiXG4gICAgICAgIChyYXRlY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS5yYXRlQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIucGxheWJhY2tSYXRlKVwiXG4gICAgICAgIChzZWVrZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnNlZWtlZEV2ZW50Lm5leHQocGxheWVyLmN1cnJlbnRUaW1lKVwiXG4gICAgICAgIChzZWVraW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS5zZWVraW5nRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHN0YWxsZWQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnN0YWxsZWRFdmVudC5uZXh0KClcIlxuICAgICAgICAoc3VzcGVuZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc3VzcGVuZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgICh0aW1ldXBkYXRlKT1cIm1lZGlhUGxheWVyU2VydmljZS50aW1lVXBkYXRlRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHZvbHVtZWNoYW5nZSk9XCJtZWRpYVBsYXllclNlcnZpY2Uudm9sdW1lQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIudm9sdW1lKVwiXG4gICAgICAgICh3YWl0aW5nKT1cIm1lZGlhUGxheWVyU2VydmljZS53YWl0aW5nRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKGNsaWNrKT1cIm1lZGlhUGxheWVyU2VydmljZS5tZWRpYUNsaWNrRXZlbnQubmV4dCgkZXZlbnQpXCI+XG4gICAgPC9hdWRpbz5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiY29udHJvbC1iYXJcIj5cbiAgICA8dXgtbWVkaWEtcGxheWVyLXRpbWVsaW5lPjwvdXgtbWVkaWEtcGxheWVyLXRpbWVsaW5lPlxuICAgIDx1eC1tZWRpYS1wbGF5ZXItY29udHJvbHM+PC91eC1tZWRpYS1wbGF5ZXItY29udHJvbHM+XG48L2Rpdj5gLFxuICAgIHByb3ZpZGVyczogW01lZGlhUGxheWVyU2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAndGFiaW5kZXgnOiAnMCcsXG4gICAgICAgICcoa2V5ZG93bi5TcGFjZSknOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLnRvZ2dsZVBsYXkoKScsXG4gICAgICAgICdbY2xhc3Muc3RhbmRhcmRdJzogJyFtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbicsXG4gICAgICAgICdbY2xhc3MuZnVsbHNjcmVlbl0nOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW4nLFxuICAgICAgICAnW2NsYXNzLnF1aWV0XSc6ICdxdWlldE1vZGUgJiYgdHlwZSA9PT0gXCJ2aWRlb1wiIHx8IG1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuJyxcbiAgICAgICAgJ1tjbGFzcy5ob3Zlcl0nOiAnaG92ZXJpbmcnLFxuICAgICAgICAnW2NsYXNzLnZpZGVvXSc6ICd0eXBlID09PSBcInZpZGVvXCInLFxuICAgICAgICAnW2NsYXNzLmF1ZGlvXSc6ICd0eXBlID09PSBcImF1ZGlvXCInLFxuICAgICAgICAnKG1vdXNlZW50ZXIpJzogJ2hvdmVyaW5nID0gdHJ1ZScsXG4gICAgICAgICcobW91c2VsZWF2ZSknOiAnaG92ZXJpbmcgPSBmYWxzZScsXG4gICAgICAgICcoZG9jdW1lbnQ6d2Via2l0ZnVsbHNjcmVlbmNoYW5nZSknOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5DaGFuZ2UoJGV2ZW50KScsXG4gICAgICAgICcoZG9jdW1lbnQ6bW96ZnVsbHNjcmVlbmNoYW5nZSknOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5DaGFuZ2UoJGV2ZW50KScsXG4gICAgICAgICcoZG9jdW1lbnQ6TVNGdWxsc2NyZWVuQ2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgkZXZlbnQpJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQFZpZXdDaGlsZCgncGxheWVyJykgcHJpdmF0ZSBfcGxheWVyUmVmOiBFbGVtZW50UmVmO1xuXG4gICAgaG92ZXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhdWRpb01ldGFkYXRhOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+O1xuXG4gICAgZ2V0IHNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2Uuc291cmNlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHNvdXJjZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnNvdXJjZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCk6IE1lZGlhUGxheWVyVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS50eXBlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHR5cGUodmFsdWU6IE1lZGlhUGxheWVyVHlwZSkge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS50eXBlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHF1aWV0TW9kZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBxdWlldE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBtZWRpYVBsYXllclNlcnZpY2U6IE1lZGlhUGxheWVyU2VydmljZSwgcHJpdmF0ZSBfYXVkaW9TZXJ2aWNlOiBBdWRpb1NlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICAvLyBzaG93IGNvbnRyb2xzIHdoZW4gaG92ZXJpbmcgYW5kIGluIHF1aWV0IG1vZGVcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlbW92ZScpLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKGV2ZW50KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVib3VuY2VUaW1lKDIwMDApLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5ob3ZlcmluZyA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnNldE1lZGlhUGxheWVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fcGxheWVyUmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMuYXVkaW9NZXRhZGF0YSA9IHRoaXMuX2F1ZGlvU2VydmljZS5nZXRBdWRpb0ZpbGVNZXRhZGF0YSh0aGlzLl9wbGF5ZXJSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmdFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheWluZy5uZXh0KHRydWUpKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheWluZy5uZXh0KGZhbHNlKSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLm1lZGlhQ2xpY2tFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudG9nZ2xlUGxheSgpKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UubG9hZGVkTWV0YWRhdGFFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UubG9hZGVkID0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgTWVkaWFQbGF5ZXJUeXBlID0gJ3ZpZGVvJyB8ICdhdWRpbyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVkaWFQbGF5ZXJCdWZmZXIge1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclNlcnZpY2UgfSBmcm9tICcuLi9tZWRpYS1wbGF5ZXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW21lZGlhUGxheWVyQmFzZUV4dGVuc2lvbl0nXG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIG1lZGlhUGxheWVyU2VydmljZTogTWVkaWFQbGF5ZXJTZXJ2aWNlKSB7IH1cbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXItdGltZWxpbmUnLFxuICAgIHRlbXBsYXRlOiBgPHAgY2xhc3M9XCJjdXJyZW50LXRpbWVcIj57eyBjdXJyZW50IHwgZHVyYXRpb24gfX08L3A+XG5cbjxkaXYgI3RpbWVsaW5lIGNsYXNzPVwidGltZWxpbmUtYmFyXCIgKG1vdXNlZW50ZXIpPVwic2NydWIudmlzaWJsZSA9IHRydWU7IHBvcC5zaG93KClcIiAobW91c2VsZWF2ZSk9XCJzY3J1Yi52aXNpYmxlID0gZmFsc2U7IHBvcC5oaWRlKClcIlxuICAgIChtb3VzZW1vdmUpPVwidXBkYXRlU2NydWIoJGV2ZW50KVwiIChtb3VzZXVwKT1cInVwZGF0ZVNjcnViKCRldmVudClcIiAobW91c2Vkb3duKT1cIm1vdXNlRG93biA9IHRydWU7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiYnVmZmVyZWQtYmFyXCIgKm5nRm9yPVwibGV0IGJ1ZmZlciBvZiBidWZmZXJlZFwiIFtzdHlsZS5sZWZ0LiVdPVwiYnVmZmVyLnN0YXJ0XCIgW3N0eWxlLndpZHRoLiVdPVwiYnVmZmVyLmVuZCAtIGJ1ZmZlci5zdGFydFwiPjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1lZGlhLXByb2dyZXNzLWJhclwiIFtzdHlsZS53aWR0aC4lXT1cInBvc2l0aW9uXCI+XG4gICAgICAgIDxkaXYgI3Byb2dyZXNzVGh1bWIgY2xhc3M9XCJtZWRpYS1wcm9ncmVzcy1iYXItdGh1bWJcIiAobW91c2VlbnRlcik9XCJzY3J1Yi52aXNpYmxlID0gZmFsc2U7IHBvcC5oaWRlKCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgICAobW91c2VsZWF2ZSk9XCJzY3J1Yi52aXNpYmxlID0gdHJ1ZTsgcG9wLnNob3coKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic2NydWItaGFuZGxlXCJcbiAgICAgICAgIFtjbGFzcy5zY3J1Yi1oYW5kbGUtaGlkZGVuXT1cIiFzY3J1Yi52aXNpYmxlXCJcbiAgICAgICAgIFtzdHlsZS5sZWZ0LnB4XT1cInNjcnViLnBvc2l0aW9uXCJcbiAgICAgICAgIFt1eFRvb2x0aXBdPVwicG9wVGVtcGxhdGVcIlxuICAgICAgICAgcGxhY2VtZW50PVwidG9wXCJcbiAgICAgICAgIFtzaG93VHJpZ2dlcnNdPVwiW11cIlxuICAgICAgICAgW2hpZGVUcmlnZ2Vyc109XCJbXVwiXG4gICAgICAgICAjcG9wPVwidXgtdG9vbHRpcFwiXG4gICAgICAgICBbdG9vbHRpcERlbGF5XT1cIjEwMFwiXG4gICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cImR1cmF0aW9uID09PSAwXCI+PC9kaXY+XG48L2Rpdj5cblxuPHAgY2xhc3M9XCJkdXJhdGlvbi10aW1lXCI+e3sgZHVyYXRpb24gfCBkdXJhdGlvbiB9fTwvcD5cblxuPG5nLXRlbXBsYXRlICNwb3BUZW1wbGF0ZT5cbiAgICA8c3Bhbj57eyBzY3J1Yi50aW1lIHwgZHVyYXRpb24gfX08L3NwYW4+XG48L25nLXRlbXBsYXRlPmAsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGRvY3VtZW50Om1vdXNldXApJzogJ21vdXNlRG93biA9IGZhbHNlJyxcbiAgICAgICAgJ1tjbGFzcy5xdWlldF0nOiAncXVpZXRNb2RlIHx8IGZ1bGxzY3JlZW4nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllclRpbWVsaW5lRXh0ZW5zaW9uQ29tcG9uZW50IGV4dGVuZHMgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQFZpZXdDaGlsZCgncHJvZ3Jlc3NUaHVtYicpIHRodW1iOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3RpbWVsaW5lJykgdGltZWxpbmVSZWY6IEVsZW1lbnRSZWY7XG5cbiAgICBjdXJyZW50OiBudW1iZXIgPSAwO1xuICAgIHBvc2l0aW9uOiBudW1iZXIgPSAwO1xuICAgIGR1cmF0aW9uOiBudW1iZXIgPSAwO1xuICAgIGJ1ZmZlcmVkOiBNZWRpYVBsYXllckJ1ZmZlcmVkW10gPSBbXTtcbiAgICBtb3VzZURvd246IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBxdWlldE1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBmdWxsc2NyZWVuOiBib29sZWFuID0gZmFsc2U7XG4gICAgc2NydWIgPSB7IHZpc2libGU6IGZhbHNlLCBwb3NpdGlvbjogMCwgdGltZTogMCB9O1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb25DaGFuZ2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZHVyYXRpb24gPT4gdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHF1aWV0TW9kZSA9PiB0aGlzLnF1aWV0TW9kZSA9IHF1aWV0TW9kZSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5FdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZnVsbHNjcmVlbiA9PiB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuO1xuICAgICAgICAgICAgdGhpcy5zY3J1Yi5wb3NpdGlvbiA9IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRpbWVVcGRhdGVFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoY3VycmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICh0aGlzLmN1cnJlbnQgLyB0aGlzLmR1cmF0aW9uKSAqIDEwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucHJvZ3Jlc3NFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKGJ1ZmZlcmVkOiBUaW1lUmFuZ2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGJ1ZmZlcmVkLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkLnB1c2goeyBzdGFydDogKGJ1ZmZlcmVkLnN0YXJ0KGlkeCkgLyB0aGlzLmR1cmF0aW9uKSAqIDEwMCwgZW5kOiAoYnVmZmVyZWQuZW5kKGlkeCkgLyB0aGlzLmR1cmF0aW9uKSAqIDEwMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtb3VzZWRvd24kID0gZnJvbUV2ZW50KHRoaXMudGh1bWIubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicpO1xuICAgICAgICBjb25zdCBtb3VzZW1vdmUkID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGNvbnN0IG1vdXNldXAkID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcpO1xuXG4gICAgICAgIG1vdXNlZG93biQucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiBtb3VzZW1vdmUkLnBpcGUodGFrZVVudGlsKG1vdXNldXAkKSkpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zY3J1Yi52aXNpYmxlID0gZmFsc2UpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTY3J1YihldmVudD86IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21lZGlhLXByb2dyZXNzLWJhci10aHVtYicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmVSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGltZWxpbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdGhpcy5zY3J1Yi5wb3NpdGlvbiA9IGV2ZW50Lm9mZnNldFg7XG4gICAgICAgIHRoaXMuc2NydWIudGltZSA9IChldmVudC5vZmZzZXRYIC8gYm91bmRzLndpZHRoKSAqIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5zY3J1Yi50aW1lO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lZGlhUGxheWVyQnVmZmVyZWQge1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgT25EZXN0cm95LCBPbkluaXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS90aW1lcic7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGZpbHRlciwgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbWVkaWEtcGxheWVyLWNvbnRyb2xzJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ2b2x1bWUtY29udGFpbmVyXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidm9sdW1lLXNsaWRlci1jb250YWluZXJcIiAjdm9sdW1lQ29udGFpbmVyIFtjbGFzcy5hY3RpdmVdPVwidm9sdW1lQWN0aXZlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ2b2x1bWUtc2xpZGVyLWljb25cIiAjdm9sdW1lSWNvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb25cIiBbY2xhc3MuaHBlLXZvbHVtZS1tdXRlXT1cInZvbHVtZSA9PT0gMFwiIFtjbGFzcy5ocGUtdm9sdW1lLWxvd109XCJ2b2x1bWUgPiAwICYmIHZvbHVtZSA8PSA3MFwiIFtjbGFzcy5ocGUtdm9sdW1lXT1cInZvbHVtZSA+IDcwXCIgW3V4VG9vbHRpcF09XCJtdXRlVG9vbHRpcFwiIChjbGljayk9XCJ0b2dnbGVNdXRlKClcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cInZvbHVtZS1zbGlkZXItbm9kZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZvbHVtZS1zbGlkZXJcIiAjdm9sdW1lU2xpZGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2b2x1bWUtdHJhY2stbG93ZXJcIiBbc3R5bGUud2lkdGguJV09XCJ2b2x1bWVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidm9sdW1lLXNsaWRlci10aHVtYlwiIChtb3VzZWRvd24pPVwiZHJhZ1N0YXJ0KCRldmVudClcIiBbc3R5bGUubGVmdC4lXT1cInZvbHVtZVwiIHRhYmluZGV4PVwiMFwiIChrZXlkb3duLkFycm93UmlnaHQpPVwidm9sdW1lID0gdm9sdW1lICsgMTBcIiAoa2V5ZG93bi5BcnJvd0xlZnQpPVwidm9sdW1lID0gdm9sdW1lIC0gMTBcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG5cbjxzdmcgdmlld0JveD1cIjAgMCA1MS41IDY0XCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE3XCIgY2xhc3M9XCJjb250cm9sLWJ1dHRvblwiIChjbGljayk9XCJnb1RvU3RhcnQoKVwiPlxuICAgIDxyZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjcuNVwiIGhlaWdodD1cIjY0XCIgLz5cbiAgICA8cG9seWdvbiBwb2ludHM9XCI1MS41LDY0IDUxLjUsMCA3LjQsMzIgXCIgLz5cbjwvc3ZnPlxuXG48c3ZnIHZpZXdCb3g9XCIwIDAgNDUgNjRcIiB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjlcIiBjbGFzcz1cImNvbnRyb2wtYnV0dG9uXCIgKm5nSWY9XCIhcGxheWluZ1wiIChjbGljayk9XCJ0b2dnbGVQbGF5KClcIj5cbiAgICA8cG9seWdvbiBwb2ludHM9XCIwLjQsMCAwLjQsNjQgNDQuNiwzMlwiIC8+XG48L3N2Zz5cblxuPHN2ZyB2aWV3Qm94PVwiMCAwIDQzIDU2LjlcIiBjbGFzcz1cImNvbnRyb2wtYnV0dG9uXCIgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjI5XCIgKm5nSWY9XCJwbGF5aW5nXCIgKGNsaWNrKT1cInRvZ2dsZVBsYXkoKVwiPlxuICAgIDxyZWN0IHk9XCIwLjFcIiB3aWR0aD1cIjE1LjdcIiBoZWlnaHQ9XCI1Ni45XCIgLz5cbiAgICA8cmVjdCB4PVwiMjcuM1wiIHk9XCIwLjFcIiB3aWR0aD1cIjE1LjdcIiBoZWlnaHQ9XCI1Ni45XCIgLz5cbjwvc3ZnPlxuXG48c3ZnIHZpZXdCb3g9XCIwIDAgNTEuNSA2NFwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxN1wiIGNsYXNzPVwiY29udHJvbC1idXR0b25cIiAoY2xpY2spPVwiZ29Ub0VuZCgpXCI+XG4gICAgPHJlY3QgeD1cIjQ0LjFcIiB5PVwiMFwiIHdpZHRoPVwiNy41XCIgaGVpZ2h0PVwiNjRcIiAvPlxuICAgIDxwb2x5Z29uIHBvaW50cz1cIjAsNjQgMCwwIDQ0LjEsMzIgXCIgLz5cbjwvc3ZnPlxuXG48ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG5cbjxzcGFuIGNsYXNzPVwiaHBlLWljb25cIiAqbmdJZj1cIm1lZGlhUGxheWVyU2VydmljZS50eXBlICE9PSAnYXVkaW8nXCIgW2NsYXNzLmhwZS1leHBhbmRdPVwiIW1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuXCIgW2NsYXNzLmhwZS1jb250cmFjdF09XCJtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlblwiXG4gICAgKGNsaWNrKT1cInNldEZ1bGxzY3JlZW4oKVwiPjwvc3Bhbj5cblxuPG5nLXRlbXBsYXRlICNtdXRlVG9vbHRpcD57eyB2b2x1bWUgPT09IDAgPyAnVW5tdXRlJyA6ICdNdXRlJyB9fTwvbmctdGVtcGxhdGU+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MucXVpZXRdJzogJ3F1aWV0TW9kZSB8fCBmdWxsc2NyZWVuJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJDb250cm9sc0V4dGVuc2lvbkNvbXBvbmVudCBleHRlbmRzIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIHBsYXlpbmc6IGJvb2xlYW47XG4gICAgcXVpZXRNb2RlOiBib29sZWFuO1xuICAgIGZ1bGxzY3JlZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICB2b2x1bWVBY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICB2b2x1bWVEcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQFZpZXdDaGlsZCgndm9sdW1lSWNvbicpIHZvbHVtZUljb246IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndm9sdW1lU2xpZGVyJykgdm9sdW1lU2xpZGVyOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3ZvbHVtZUNvbnRhaW5lcicpIHZvbHVtZUNvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIHByaXZhdGUgX3ZvbHVtZTogbnVtYmVyID0gNTA7XG4gICAgcHJpdmF0ZSBfcHJldmlvdXNWb2x1bWUgPSA1MDtcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgZ2V0IHZvbHVtZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xuICAgIH1cblxuICAgIHNldCB2b2x1bWUodmFsdWU6IG51bWJlcikge1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB0aGlzLl92b2x1bWUgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVm9sdW1lID0gdGhpcy5fdm9sdW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdm9sdW1lID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxMDApO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS52b2x1bWUgPSB0aGlzLl92b2x1bWUgLyAxMDA7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoXyA9PiB0aGlzLnBsYXlpbmcgPSB0cnVlKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoXyA9PiB0aGlzLnBsYXlpbmcgPSBmYWxzZSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShxdWlldE1vZGUgPT4gdGhpcy5xdWlldE1vZGUgPSBxdWlldE1vZGUpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS52b2x1bWVDaGFuZ2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodm9sdW1lID0+IHRoaXMudm9sdW1lID0gdm9sdW1lICogMTAwKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuaW5pdEV2ZW50LnBpcGUoZGVib3VuY2VUaW1lKDEpLCBmaWx0ZXIoaW5pdCA9PiBpbml0ID09PSB0cnVlKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnZvbHVtZSA9IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnZvbHVtZSAqIDEwMCk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5FdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZnVsbHNjcmVlbiA9PiB0aGlzLmZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuKTtcblxuICAgICAgICBjb25zdCBtb3VzZWVudGVyJCA9IGZyb21FdmVudCh0aGlzLnZvbHVtZUljb24ubmF0aXZlRWxlbWVudCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgY29uc3QgbW91c2VlbnRlckNvbnRhaW5lciQgPSBmcm9tRXZlbnQodGhpcy52b2x1bWVDb250YWluZXIubmF0aXZlRWxlbWVudCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgY29uc3QgbW91c2VsZWF2ZUNvbnRhaW5lciQgPSBmcm9tRXZlbnQodGhpcy52b2x1bWVDb250YWluZXIubmF0aXZlRWxlbWVudCwgJ21vdXNlbGVhdmUnKTtcblxuICAgICAgICBtb3VzZWVudGVyJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy52b2x1bWVBY3RpdmUgPSB0cnVlKTtcbiAgICAgICAgbW91c2VsZWF2ZUNvbnRhaW5lciQucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0aW1lcigxNTAwKS5waXBlKHRha2VVbnRpbChtb3VzZWVudGVyQ29udGFpbmVyJCkpKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMudm9sdW1lQWN0aXZlID0gZmFsc2UpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVNdXRlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy52b2x1bWUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fcHJldmlvdXNWb2x1bWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZvbHVtZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGVQbGF5KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wYXVzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0RnVsbHNjcmVlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgIH1cblxuICAgIGdvVG9TdGFydCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIGdvVG9FbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb247XG4gICAgfVxuXG4gICAgZHJhZ1N0YXJ0KGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMudm9sdW1lRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IHRodW1iID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICB0aHVtYi5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50Om1vdXNlbW92ZScsIFsnJGV2ZW50J10pXG4gICAgZHJhZ01vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnZvbHVtZURyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IHNsaWRlciA9IHRoaXMudm9sdW1lU2xpZGVyLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHNsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBNYXRoLm1heCgwLCBldmVudC5wYWdlWCAtIGJvdW5kcy5sZWZ0KSk7XG5cbiAgICAgICAgLy8gY29udmVydCB0byBhIHBlcmNlbnRhZ2VcbiAgICAgICAgdGhpcy52b2x1bWUgPSAoeCAvIGJvdW5kcy53aWR0aCkgKiAxMDA7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2V1cCcpXG4gICAgZHJhZ0VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52b2x1bWVEcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cblxufSIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICdkdXJhdGlvbidcbn0pXG5leHBvcnQgY2xhc3MgRHVyYXRpb25QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgXG4gICAgdHJhbnNmb3JtKHNlY29uZHM6IG51bWJlcik6IGFueSB7XG5cbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgbGV0IGRheXMgPSBNYXRoLmZsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIGhvdXJzID0gaG91cnMgLSAoZGF5cyAqIDI0KTtcbiAgICAgICAgbWludXRlcyA9IG1pbnV0ZXMgLSAoZGF5cyAqIDI0ICogNjApIC0gKGhvdXJzICogNjApO1xuICAgICAgICBzZWNvbmRzID0gTWF0aC5mbG9vcihzZWNvbmRzIC0gKGRheXMgKiAyNCAqIDYwICogNjApIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG5cbiAgICAgICAgaWYgKGhvdXJzID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMucGFkKGhvdXJzKX06JHt0aGlzLnBhZChtaW51dGVzKX06JHt0aGlzLnBhZChzZWNvbmRzKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMucGFkKG1pbnV0ZXMpfToke3RoaXMucGFkKHNlY29uZHMpfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYWQodmFsdWU6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gYDAke3ZhbHVlfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHVyYXRpb25QaXBlIH0gZnJvbSAnLi9kdXJhdGlvbi5waXBlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRHVyYXRpb25QaXBlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtEdXJhdGlvblBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIER1cmF0aW9uUGlwZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICdmaWxlU2l6ZSdcbn0pXG5leHBvcnQgY2xhc3MgRmlsZVNpemVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICB0cmFuc2Zvcm0odmFsdWU6IG51bWJlcik6IGFueSB7XG5cbiAgICAgICAgLy8gYWxsb3cgZm9yIGFzeW5jIHZhbHVlc1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQiddO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgd2hpY2ggdW5pdCBicmFja2V0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIGEgcGFydCBvZlxuICAgICAgICBsZXQgaWR4ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLmxvZygxMDI0KSk7XG4gICAgICAgIGxldCBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAyNCwgaWR4KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBgJHtmb3JtYXR0ZWRWYWx1ZS50b0ZpeGVkKDIpfSAke3VuaXRzW2lkeF19YDtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRmlsZVNpemVQaXBlIH0gZnJvbSAnLi9maWxlLXNpemUucGlwZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZpbGVTaXplUGlwZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRmlsZVNpemVQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBGaWxlU2l6ZVBpcGVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgTWVkaWFQbGF5ZXJDb21wb25lbnQgfSBmcm9tICcuL21lZGlhLXBsYXllci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJUaW1lbGluZUV4dGVuc2lvbkNvbXBvbmVudCB9IGZyb20gJy4vZXh0ZW5zaW9ucy90aW1lbGluZS90aW1lbGluZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIH0gZnJvbSAnLi9leHRlbnNpb25zL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZWRpYVBsYXllckNvbnRyb2xzRXh0ZW5zaW9uQ29tcG9uZW50IH0gZnJvbSAnLi9leHRlbnNpb25zL2NvbnRyb2xzL2NvbnRyb2xzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGcmFtZUV4dHJhY3Rpb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24ubW9kdWxlJztcbmltcG9ydCB7IEF1ZGlvU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2F1ZGlvL2luZGV4JztcbmltcG9ydCB7IER1cmF0aW9uUGlwZU1vZHVsZSB9IGZyb20gJy4uLy4uL3BpcGVzL2R1cmF0aW9uL2luZGV4JztcbmltcG9ydCB7IEZpbGVTaXplUGlwZU1vZHVsZSB9IGZyb20gJy4uLy4uL3BpcGVzL2ZpbGUtc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclNlcnZpY2UgfSBmcm9tICcuL21lZGlhLXBsYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIE1lZGlhUGxheWVyQ29tcG9uZW50LFxuICAgIE1lZGlhUGxheWVyVGltZWxpbmVFeHRlbnNpb25Db21wb25lbnQsXG4gICAgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlLFxuICAgIE1lZGlhUGxheWVyQ29udHJvbHNFeHRlbnNpb25Db21wb25lbnRcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZyYW1lRXh0cmFjdGlvbk1vZHVsZSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZSxcbiAgICAgICAgQXVkaW9TZXJ2aWNlTW9kdWxlLFxuICAgICAgICBEdXJhdGlvblBpcGVNb2R1bGUsXG4gICAgICAgIEZpbGVTaXplUGlwZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TLFxuICAgIHByb3ZpZGVyczogW01lZGlhUGxheWVyU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbmF2aWdhdGlvbicsXG4gICAgdGVtcGxhdGU6IGA8bmF2IGNsYXNzPVwidHJlZVwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XG4gICAgPG9sIGNsYXNzPVwibmF2XCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L29sPlxuPC9uYXY+XG5gXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Db21wb25lbnQge1xuXG59IiwiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPcHRpb25hbCwgUXVlcnlMaXN0LCBSZW5kZXJlcjIsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSwgTmF2aWdhdGlvbkVuZCwgUm91dGVyLCBVcmxUcmVlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdbdXgtbmF2aWdhdGlvbi1pdGVtXScsXG4gICAgdGVtcGxhdGU6IGA8YSAqbmdJZj1cImxpbmtcIiBbY2xhc3MuaGFzLWFycm93XT1cImNoaWxkcmVuLmxlbmd0aCA+IDBcIiBbY2xhc3Mubm8tYXJyb3ddPVwiaW5kZW50V2l0aG91dEFycm93XCIgW3JvdXRlckxpbmtdPVwibGlua1wiPlxuICAgIDxzcGFuPnt7aGVhZGVyfX08L3NwYW4+XG48L2E+XG48YSAqbmdJZj1cIiFsaW5rXCIgKGNsaWNrKT1cImV4cGFuZGVkID0gIWV4cGFuZGVkXCIgW2NsYXNzLmhhcy1hcnJvd109XCJjaGlsZHJlbi5sZW5ndGggPiAwXCIgW2NsYXNzLm5vLWFycm93XT1cImluZGVudFdpdGhvdXRBcnJvd1wiPlxuICAgIDxzcGFuPnt7aGVhZGVyfX08L3NwYW4+XG48L2E+XG48bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5gLFxufSlcbmV4cG9ydCBjbGFzcyBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBpY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgbGluazogc3RyaW5nO1xuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnY2xhc3Muc2VsZWN0ZWQnKSBleHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hY3RpdmUnKVxuICAgIGdldCBhY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmxpbmspIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXIuaXNBY3RpdmUodGhpcy5saW5rLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldmVsOiBudW1iZXIgPSAxO1xuICAgIGluZGVudFdpdGhvdXRBcnJvdzogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBwcml2YXRlIF9uYXZpZ2F0aW9uRW5kOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfY2hpbGRyZW5DaGFuZ2VzOiBTdWJzY3JpcHRpb247XG5cbiAgICBAQ29udGVudENoaWxkcmVuKE5hdmlnYXRpb25JdGVtQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSBfY2hpbGRyZW46IFF1ZXJ5TGlzdDxOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudD47XG5cbiAgICBnZXQgY2hpbGRyZW4oKTogTmF2aWdhdGlvbkl0ZW1Db21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgQE9wdGlvbmFsKCkgQFNraXBTZWxmKCkgcHJpdmF0ZSBfcGFyZW50OiBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCxcbiAgICAgICAgcHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIsXG4gICAgICAgIHByaXZhdGUgX2FjdGl2YXRlZFJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVxuICAgICkge1xuICAgICAgICB0aGlzLmxldmVsID0gX3BhcmVudCA/IF9wYXJlbnQubGV2ZWwgKyAxIDogMTtcblxuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uRW5kID0gX3JvdXRlci5ldmVudHMucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5leHBhbmRlZCA9IHRoaXMuaGFzQWN0aXZlTGluayh0aGlzLmxpbmspKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIEFkZCBjbGFzc2VzIHRvIHBhcmVudCBmb3Igc3R5bGluZ1xuICAgICAgICBjb25zdCBwYXJlbnRMaXN0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAocGFyZW50TGlzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsQ2xhc3M6IHN0cmluZyA9IHRoaXMuZ2V0TGV2ZWxDbGFzcygpO1xuICAgICAgICAgICAgaWYgKGxldmVsQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHBhcmVudExpc3RFbGVtZW50LCAnbmF2Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MocGFyZW50TGlzdEVsZW1lbnQsIGxldmVsQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICAvLyBTZXQgJ2luZGVudFdpdGhvdXRBcnJvdydcbiAgICAgICAgdGhpcy5zZXRJbmRlbnRXaXRob3V0QXJyb3coKTtcblxuICAgICAgICAvLyBVcGRhdGUgJ2luZGVudFdpdGhvdXRBcnJvdycgaW4gcmVzcG9uc2UgdG8gY2hhbmdlcyB0byBjaGlsZHJlblxuICAgICAgICB0aGlzLl9jaGlsZHJlbkNoYW5nZXMgPSB0aGlzLl9jaGlsZHJlbi5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNldEluZGVudFdpdGhvdXRBcnJvdygpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbkVuZC51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbkNoYW5nZXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhc0FjdGl2ZUxpbmsobGluazogc3RyaW5nIHwgVXJsVHJlZSk6IGJvb2xlYW4ge1xuXG4gICAgICAgIGNvbnN0IHRyZWUgPSB0aGlzLl9yb3V0ZXIuY3JlYXRlVXJsVHJlZShbbGlua10sIHtcbiAgICAgICAgICAgIHJlbGF0aXZlVG86IHRoaXMuX2FjdGl2YXRlZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHRoaXMuX2FjdGl2YXRlZFJvdXRlLnNuYXBzaG90LnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHRoaXMuX2FjdGl2YXRlZFJvdXRlLnNuYXBzaG90LmZyYWdtZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChsaW5rICYmIHRoaXMuX3JvdXRlci5pc0FjdGl2ZSh0cmVlLCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCBoYXMgY2hpbGRyZW4sIGNoZWNrIGlmIGFueSBvZiB0aGVtLCBvciB0aGVpciBkZXNjZW5kYW50cywgYXJlIGFjdGl2ZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc29tZSgoaXRlbSkgPT4gaXRlbS5oYXNBY3RpdmVMaW5rKGl0ZW0ubGluaykpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TGV2ZWxDbGFzcygpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25hdi1zZWNvbmQtbGV2ZWwnO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LXRoaXJkLWxldmVsJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25hdi1mb3VydGgtbGV2ZWwnO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LWZpZnRoLWxldmVsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldEluZGVudFdpdGhvdXRBcnJvdygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBjaGlsZHJlbiBpdCB3aWxsIGJlIGluZGVudGVkIGFuZCB3aWxsIGhhdmUgYW4gYXJyb3dcbiAgICAgICAgICAgIHRoaXMuaW5kZW50V2l0aG91dEFycm93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgYSBwYXJlbnQsIGluZGVudCBpdCBpZiBhbnkgb2YgaXRzIHNpYmxpbmdzIGhhdmUgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMuaW5kZW50V2l0aG91dEFycm93ID0gIXRoaXMuX3BhcmVudC5jaGlsZHJlbi5ldmVyeSgoaXRlbSkgPT4gaXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVG9wLWxldmVsIGVsZW1lbnRzIHNob3VsZCBiZSBpbmRlbnRlZFxuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUm91dGVyTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE5hdmlnYXRpb25Db21wb25lbnQsXG4gICAgICAgIE5hdmlnYXRpb25JdGVtQ29tcG9uZW50XG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgTmF2aWdhdGlvbkl0ZW1Db21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvckNsYXNzU2V0LCBDb2xvclZhbHVlU2V0IH0gZnJvbSAnLi9jb2xvci5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbG9yU2VydmljZSB7XG5cbiAgICBwcml2YXRlIF9odG1sOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfZWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBfY29sb3JzOiBUaGVtZUNvbG9ycztcbiAgICBwcml2YXRlIF9jb2xvclNldDogYW55ID0gY29sb3JTZXRzLmtlcHBlbDtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9jb2xvclNldC5jb2xvclZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3JzW2tleV0gPSB0aGlzLmdldENvbG9yVmFsdWVCeUhleCh0aGlzLl9jb2xvclNldC5jb2xvclZhbHVlU2V0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRDb2xvcnMoKSB7XG5cbiAgICAgICAgdGhpcy5faHRtbCA9ICcnO1xuXG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9odG1sICs9ICc8ZGl2IGNsYXNzPVwiJyArIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXRba2V5XSArICctY29sb3JcIj48L2Rpdj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTmFtZSA9ICdjb2xvci1jaGFydCc7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5faHRtbDtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMuX2NvbG9ycyA9IHt9O1xuXG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvcnNba2V5XSA9IHRoaXMuZ2V0Q29sb3JWYWx1ZSh0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0W2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q29sb3JWYWx1ZUJ5SGV4KGNvbG9yOiBzdHJpbmcpOiBUaGVtZUNvbG9yIHtcbiAgICAgICAgY29uc3QgaGV4ID0gY29sb3IucmVwbGFjZSgnIycsICcnKTtcblxuICAgICAgICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygwLCAyKSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDIsIDQpLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNCwgNiksIDE2KS50b1N0cmluZygpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVGhlbWVDb2xvcihyLCBnLCBiLCAnMScpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q29sb3JWYWx1ZShjb2xvcjogQ29sb3JJZGVudGlmaWVyKTogVGhlbWVDb2xvciB7XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXRbY29sb3JdICsgJy1jb2xvcicpO1xuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgICBjb25zdCByZ2JhID0gY29sb3JWYWx1ZS5tYXRjaCgvXnJnYmE/XFwoKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKSg/OixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pKT9cXCkkLyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHJnYmFbMV0sIHJnYmFbMl0sIHJnYmFbM10sIHJnYmFbNF0pO1xuICAgIH1cblxuICAgIGdldENvbG9yKGNvbG9yOiBDb2xvcklkZW50aWZpZXIpOiBUaGVtZUNvbG9yIHtcbiAgICAgICAgY29uc3QgdGhlbWVDb2xvciA9IHRoaXMuX2NvbG9yc1t0aGlzLnJlc29sdmVDb2xvck5hbWUoY29sb3IpXTtcbiAgICAgICAgaWYgKCF0aGVtZUNvbG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbG9yIG5vdCBmb3VuZDogJyArIGNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGhlbWVDb2xvcih0aGVtZUNvbG9yLmdldFJlZCgpLCB0aGVtZUNvbG9yLmdldEdyZWVuKCksIHRoZW1lQ29sb3IuZ2V0Qmx1ZSgpLCB0aGVtZUNvbG9yLmdldEFscGhhKCkpO1xuICAgIH1cblxuICAgIGdldENvbG9yU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JTZXQ7XG4gICAgfVxuXG4gICAgc2V0Q29sb3JTZXQoY29sb3JTZXQ6IENvbG9yU2V0KSB7XG4gICAgICAgIHRoaXMuX2NvbG9yU2V0ID0gY29sb3JTZXQ7XG4gICAgICAgIHRoaXMuX2NvbG9ycyA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnNba2V5XSA9IHRoaXMuZ2V0Q29sb3JWYWx1ZUJ5SGV4KHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNvbHZlKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2xvck5hbWUgPSB0aGlzLnJlc29sdmVDb2xvck5hbWUodmFsdWUpO1xuXG4gICAgICAgIGZvciAobGV0IGNvbG9yIGluIHRoaXMuX2NvbG9ycykge1xuICAgICAgICAgICAgaWYgKGNvbG9yTmFtZSA9PT0gY29sb3IudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbG9yKGNvbG9yTmFtZSkudG9SZ2JhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZUNvbG9yTmFtZSh2YWx1ZTogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFxzKy9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGhlbWVDb2xvciB7XG5cbiAgICBwcml2YXRlIF9yOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfZzogc3RyaW5nO1xuICAgIHByaXZhdGUgX2I6IHN0cmluZztcbiAgICBwcml2YXRlIF9hOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihyOiBzdHJpbmcsIGc6IHN0cmluZywgYjogc3RyaW5nLCBhOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fciA9IHI7XG4gICAgICAgIHRoaXMuX2cgPSBnO1xuICAgICAgICB0aGlzLl9iID0gYjtcbiAgICAgICAgdGhpcy5fYSA9IGEgPT09IHVuZGVmaW5lZCA/ICcxJyA6IGE7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlKHZhbHVlOiBzdHJpbmcpOiBUaGVtZUNvbG9yIHtcbiAgICAgICAgbGV0IHIsIGcsIGIsIGEgPSAnMSc7XG5cbiAgICAgICAgY29uc3QgcmdiYVBhdHRlcm4gPSAvXnJnYmE/XFwoKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKSg/OixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pKT9cXCkkLztcbiAgICAgICAgY29uc3Qgc2hvcnRIZXhQYXR0ZXJuID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbiAgICAgICAgY29uc3QgbG9uZ0hleFBhdHRlcm4gPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC87XG5cbiAgICAgICAgY29uc3QgcmdiYU1hdGNoID0gdmFsdWUubWF0Y2gocmdiYVBhdHRlcm4pO1xuICAgICAgICBjb25zdCBzaG9ydEhleE1hdGNoID0gdmFsdWUubWF0Y2goc2hvcnRIZXhQYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgbG9uZ0hleE1hdGNoID0gdmFsdWUubWF0Y2gobG9uZ0hleFBhdHRlcm4pO1xuXG4gICAgICAgIGlmIChyZ2JhTWF0Y2gpIHtcbiAgICAgICAgICAgIHIgPSByZ2JhTWF0Y2hbMV07XG4gICAgICAgICAgICBnID0gcmdiYU1hdGNoWzJdO1xuICAgICAgICAgICAgYiA9IHJnYmFNYXRjaFszXTtcbiAgICAgICAgICAgIGEgPSByZ2JhTWF0Y2hbNF0gPyByZ2JhTWF0Y2hbNF0gOiAnMSc7XG4gICAgICAgIH0gZWxzZSBpZiAobG9uZ0hleE1hdGNoKSB7XG4gICAgICAgICAgICByID0gcGFyc2VJbnQobG9uZ0hleE1hdGNoWzFdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChsb25nSGV4TWF0Y2hbMl0sIDE2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgYiA9IHBhcnNlSW50KGxvbmdIZXhNYXRjaFszXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvcnRIZXhNYXRjaCkge1xuICAgICAgICAgICAgciA9IHBhcnNlSW50KHNob3J0SGV4TWF0Y2hbMV0gKyBzaG9ydEhleE1hdGNoWzFdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChzaG9ydEhleE1hdGNoWzJdICsgc2hvcnRIZXhNYXRjaFsyXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoc2hvcnRIZXhNYXRjaFszXSArIHNob3J0SGV4TWF0Y2hbM10sIDE2KS50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgY29sb3IgLSAke3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBjb2xvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRoZW1lQ29sb3IociwgZywgYiwgYSk7XG4gICAgfVxuXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIGxldCByZWQgPSBwYXJzZUludCh0aGlzLl9yKS50b1N0cmluZygxNik7XG4gICAgICAgIGxldCBncmVlbiA9IHBhcnNlSW50KHRoaXMuX2cpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgbGV0IGJsdWUgPSBwYXJzZUludCh0aGlzLl9iKS50b1N0cmluZygxNik7XG5cbiAgICAgICAgaWYgKHJlZC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZWQgPSAnMCcgKyByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyZWVuLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGdyZWVuID0gJzAnICsgZ3JlZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsdWUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgYmx1ZSA9ICcwJyArIGJsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyMnICsgcmVkICsgZ3JlZW4gKyBibHVlO1xuICAgIH1cblxuICAgIHRvUmdiKCkge1xuICAgICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5fciArICcsICcgKyB0aGlzLl9nICsgJywgJyArIHRoaXMuX2IgKyAnKSc7XG4gICAgfVxuXG4gICAgdG9SZ2JhKCkge1xuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHRoaXMuX3IgKyAnLCAnICsgdGhpcy5fZyArICcsICcgKyB0aGlzLl9iICsgJywgJyArIHRoaXMuX2EgKyAnKSc7XG4gICAgfVxuXG4gICAgZ2V0UmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcjtcbiAgICB9XG5cbiAgICBnZXRHcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2c7XG4gICAgfVxuXG4gICAgZ2V0Qmx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgfVxuXG4gICAgZ2V0QWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgIH1cblxuICAgIHNldFJlZChyZWQ6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yID0gcmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRHcmVlbihncmVlbjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2cgPSBncmVlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0Qmx1ZShibHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fYiA9IGJsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldEFscGhhKGFscGhhOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fYSA9IGFscGhhLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbG9yU2V0cyA9IHtcbiAgICBrZXBwZWw6IHtcbiAgICAgICAgY29sb3JDbGFzc1NldDoge1xuICAgICAgICAgICAgJ3ByaW1hcnknOiAncHJpbWFyeScsXG4gICAgICAgICAgICAnYWNjZW50JzogJ2FjY2VudCcsXG4gICAgICAgICAgICAnc2Vjb25kYXJ5JzogJ3NlY29uZGFyeScsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMSc6ICdhbHRlcm5hdGUxJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUyJzogJ2FsdGVybmF0ZTInLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTMnOiAnYWx0ZXJuYXRlMycsXG4gICAgICAgICAgICAndmlicmFudDEnOiAndmlicmFudDEnLFxuICAgICAgICAgICAgJ3ZpYnJhbnQyJzogJ3ZpYnJhbnQyJyxcbiAgICAgICAgICAgICdncmV5MSc6ICdncmV5MScsXG4gICAgICAgICAgICAnZ3JleTInOiAnZ3JleTInLFxuICAgICAgICAgICAgJ2dyZXkzJzogJ2dyZXkzJyxcbiAgICAgICAgICAgICdncmV5NCc6ICdncmV5NCcsXG4gICAgICAgICAgICAnZ3JleTUnOiAnZ3JleTUnLFxuICAgICAgICAgICAgJ2dyZXk2JzogJ2dyZXk2JyxcbiAgICAgICAgICAgICdncmV5Nyc6ICdncmV5NycsXG4gICAgICAgICAgICAnZ3JleTgnOiAnZ3JleTgnLFxuICAgICAgICAgICAgJ2NoYXJ0MSc6ICdjaGFydDEnLFxuICAgICAgICAgICAgJ2NoYXJ0Mic6ICdjaGFydDInLFxuICAgICAgICAgICAgJ2NoYXJ0Myc6ICdjaGFydDMnLFxuICAgICAgICAgICAgJ2NoYXJ0NCc6ICdjaGFydDQnLFxuICAgICAgICAgICAgJ2NoYXJ0NSc6ICdjaGFydDUnLFxuICAgICAgICAgICAgJ2NoYXJ0Nic6ICdjaGFydDYnLFxuICAgICAgICAgICAgJ29rJzogJ29rJyxcbiAgICAgICAgICAgICd3YXJuaW5nJzogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgJ2NyaXRpY2FsJzogJ2NyaXRpY2FsJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xJzogJ3BhcnRpdGlvbjEnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjknOiAncGFydGl0aW9uOScsXG4gICAgICAgICAgICAncGFydGl0aW9uMTAnOiAncGFydGl0aW9uMTAnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjExJzogJ3BhcnRpdGlvbjExJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMic6ICdwYXJ0aXRpb24xMicsXG4gICAgICAgICAgICAncGFydGl0aW9uMTMnOiAncGFydGl0aW9uMTMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjE0JzogJ3BhcnRpdGlvbjE0JyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtbm9kZSc6ICdzb2NpYWwtY2hhcnQtbm9kZScsXG4gICAgICAgICAgICAnc29jaWFsLWNoYXJ0LWVkZ2UnOiAnc29jaWFsLWNoYXJ0LWVkZ2UnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1pY3JvRm9jdXM6IHtcbiAgICAgICAgJ2NvbG9yVmFsdWVTZXQnOiB7XG4gICAgICAgICAgICAnY2VydWxlYW4nOiAnIzE2NjhjMScsXG4gICAgICAgICAgICAnYXF1YSc6ICcjMjljZWZmJyxcbiAgICAgICAgICAgICdhcXVhbWFyaW5lJzogJyMyZmQ2YzMnLFxuICAgICAgICAgICAgJ2Z1Y2hzaWEnOiAnI2M2MTc5ZCcsXG4gICAgICAgICAgICAnaW5kaWdvJzogJyM3NDI1YWQnLFxuICAgICAgICAgICAgJ2RhcmstYmx1ZSc6ICcjMjMxY2E1JyxcbiAgICAgICAgICAgICd3aGl0ZSc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdzbGlnaHRseS1ncmF5JzogJyNmNWY3ZjgnLFxuICAgICAgICAgICAgJ2JyaWdodC1ncmF5JzogJyNmMWYyZjMnLFxuICAgICAgICAgICAgJ2dyYXknOiAnI2RjZGVkZicsXG4gICAgICAgICAgICAnc2lsdmVyJzogJyNiZGJlYzAnLFxuICAgICAgICAgICAgJ2RpbS1ncmF5JzogJyM2NTY2NjgnLFxuICAgICAgICAgICAgJ2RhcmstZ3JheSc6ICcjMzIzNDM1JyxcbiAgICAgICAgICAgICdibGFjayc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICdjcmltc29uLW5lZ2F0aXZlJzogJyNlNTAwNGMnLFxuICAgICAgICAgICAgJ2Fwcmljb3QnOiAnI2Y0OGIzNCcsXG4gICAgICAgICAgICAneWVsbG93JzogJyNmY2RiMWYnLFxuICAgICAgICAgICAgJ2dyZWVuLXBvc2l0aXZlJzogJyMxYWFjNjAnLFxuICAgICAgICAgICAgJ3VsdHJhbWFyaW5lJzogJyMzOTM5YzYnLFxuICAgICAgICAgICAgJ3NreWJsdWUnOiAnIzAwYWJmMycsXG4gICAgICAgICAgICAncGFsZS1hcXVhJzogJyM0M2U0ZmYnLFxuICAgICAgICAgICAgJ3BhbGUtZ3JlZW4nOiAnIzFmZmJiYScsXG4gICAgICAgICAgICAnbGltZSc6ICcjNzVkYTRkJyxcbiAgICAgICAgICAgICdvcmFuZ2UnOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnbWFnZW50YSc6ICcjZWIyM2MyJyxcbiAgICAgICAgICAgICdwYWxlLXB1cnBsZSc6ICcjYmE0N2UyJyxcbiAgICAgICAgICAgICdkYXJrLXVsdHJhbWFyaW5lJzogJyMyNzE3ODInLFxuICAgICAgICAgICAgJ3N0ZWVsYmx1ZSc6ICcjMDE0MjcyJyxcbiAgICAgICAgICAgICdhcmN0aWMtYmx1ZSc6ICcjMGI4ZWFjJyxcbiAgICAgICAgICAgICdlbWVyYWxkJzogJyMwMGE5ODknLFxuICAgICAgICAgICAgJ29saXZlJzogJyM1YmJhMzYnLFxuICAgICAgICAgICAgJ2dvbGRlbnJvZCc6ICcjZmZiMDAwJyxcbiAgICAgICAgICAgICdwdXJwbGUnOiAnIzliMWU4MycsXG4gICAgICAgICAgICAncGFsZS1lZ2dwbGFudCc6ICcjNTIxNmFjJyxcbiAgICAgICAgICAgICdyZWQnOiAnI2ZmNDU0ZicsXG4gICAgICAgICAgICAncGFsZS1hbWJlcic6ICcjZmZiMjRkJyxcbiAgICAgICAgICAgICdwYWxlLWxlbW9uJzogJyNmZGUxNTknLFxuICAgICAgICAgICAgJ3BhbGUtZW1lcmFsZCc6ICcjMzNjMTgwJyxcbiAgICAgICAgICAgICdwbHVtJzogJyNiMjE2NDYnLFxuICAgICAgICAgICAgJ2NvcHBlcic6ICcjZTU3ODI4JyxcbiAgICAgICAgICAgICdhbWJlcic6ICcjZmZjMDAyJyxcbiAgICAgICAgICAgICdsZWFmLWdyZWVuJzogJyMxMThjNGYnLFxuICAgICAgICAgICAgJ2ZvcmVzdC1ncmVlbic6ICcjMDA2NDVhJyxcbiAgICAgICAgICAgICdwcmltYXJ5JzogJyMwMDczZTcnLFxuICAgICAgICAgICAgJ2FjY2VudCc6ICcjNzQyNWFkJyxcbiAgICAgICAgICAgICdzZWNvbmRhcnknOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMSc6ICcjMjljZWZmJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUyJzogJyMyZmQ2YzMnLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTMnOiAnI2M2MTc5ZCcsXG4gICAgICAgICAgICAndmlicmFudDEnOiAnIzQzZTRmZicsXG4gICAgICAgICAgICAndmlicmFudDInOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnZ3JleTEnOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAnZ3JleTInOiAnIzMyMzQzNScsXG4gICAgICAgICAgICAnZ3JleTMnOiAnIzY1NjY2OCcsXG4gICAgICAgICAgICAnZ3JleTQnOiAnI2JkYmVjMCcsXG4gICAgICAgICAgICAnZ3JleTUnOiAnI2RjZGVkZicsXG4gICAgICAgICAgICAnZ3JleTYnOiAnI2YxZjJmMycsXG4gICAgICAgICAgICAnZ3JleTcnOiAnI2Y1ZjdmOCcsXG4gICAgICAgICAgICAnZ3JleTgnOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAnY2hhcnQxJzogJyMzOTM5YzYnLFxuICAgICAgICAgICAgJ2NoYXJ0Mic6ICcjMDBhYmYzJyxcbiAgICAgICAgICAgICdjaGFydDMnOiAnIzc1ZGE0ZCcsXG4gICAgICAgICAgICAnY2hhcnQ0JzogJyNmZmNlMDAnLFxuICAgICAgICAgICAgJ2NoYXJ0NSc6ICcjZWIyM2MyJyxcbiAgICAgICAgICAgICdjaGFydDYnOiAnI2JhNDdlMicsXG4gICAgICAgICAgICAnb2snOiAnIzFhYWM2MCcsXG4gICAgICAgICAgICAnd2FybmluZyc6ICcjZjQ4YjM0JyxcbiAgICAgICAgICAgICdjcml0aWNhbCc6ICdlNTAwNGMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEnOiAnIzc0MjVhZCcsXG4gICAgICAgICAgICAncGFydGl0aW9uOSc6ICcjNTIxNmFjJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMCc6ICcjNWJiYTM2JyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMSc6ICcjMDE0MjcyJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMic6ICcjZmZiMDAwJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMyc6ICcjYmRiZWMwJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xNCc6ICcjMjcxNzgyJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtbm9kZSc6ICcjZmYwMGZmJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtZWRnZSc6ICcjZmYwMGZmJ1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBUaGVtZUNvbG9ycyB7XG4gICAgW25hbWU6IHN0cmluZ106IFRoZW1lQ29sb3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JTZXQge1xuICAgIGNvbG9yQ2xhc3NTZXQ/OiBDb2xvckNsYXNzU2V0O1xuICAgIGNvbG9yVmFsdWVTZXQ/OiBDb2xvclZhbHVlU2V0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yQ2xhc3NTZXQge1xuICAgIFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JWYWx1ZVNldCB7XG4gICAgW25hbWU6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgQ29sb3JJZGVudGlmaWVyID0gc3RyaW5nO1xuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4vY29sb3Iuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgcHJvdmlkZXJzOiBbQ29sb3JTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JTZXJ2aWNlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvblNlcnZpY2Uge1xuXG4gICAgLy8gcHJvdmlkZSBkZWZhdWx0IG9wdGlvbnNcbiAgICBvcHRpb25zOiBOb3RpZmljYXRpb25PcHRpb25zID0ge1xuICAgICAgICBkdXJhdGlvbjogNCxcbiAgICAgICAgaGVpZ2h0OiAxMDAsXG4gICAgICAgIHNwYWNpbmc6IDEwLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX2NvbG9yU2VydmljZS5nZXRDb2xvcignYWNjZW50JykudG9IZXgoKSxcbiAgICAgICAgaWNvbkNvbG9yOiB0aGlzLl9jb2xvclNlcnZpY2UuZ2V0Q29sb3IoJ2FjY2VudCcpLnRvSGV4KClcbiAgICB9O1xuXG4gICAgZGlyZWN0aW9uOiBOb3RpZmljYXRpb25MaXN0RGlyZWN0aW9uID0gJ2Fib3ZlJztcblxuICAgIG5vdGlmaWNhdGlvbnMkOiBCZWhhdmlvclN1YmplY3Q8Tm90aWZpY2F0aW9uUmVmW10+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOb3RpZmljYXRpb25SZWZbXT4oW10pOyAgICBcblxuICAgIHNob3codGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIG9wdGlvbnM6IE5vdGlmaWNhdGlvbk9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIGRhdGE6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSk6IE5vdGlmaWNhdGlvblJlZiB7XG5cbiAgICAgICAgb3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zIH07XG5cbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uUmVmOiBOb3RpZmljYXRpb25SZWYgPSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVJlZjogdGVtcGxhdGVSZWYsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgIHNwYWNpbmc6IG9wdGlvbnMuc3BhY2luZyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBpY29uQ29sb3I6IG9wdGlvbnMuaWNvbkNvbG9yLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSB0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYWJvdmUnKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25zLnVuc2hpZnQobm90aWZpY2F0aW9uUmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMucHVzaChub3RpZmljYXRpb25SZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zJC5uZXh0KG5vdGlmaWNhdGlvbnMpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBub3RpZmljYXRpb24gYWZ0ZXIgZGVsYXlcbiAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNtaXNzKG5vdGlmaWNhdGlvblJlZiksIG9wdGlvbnMuZHVyYXRpb24gKiAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3RpZmljYXRpb25SZWY7XG4gICAgfVxuXG4gICAgZ2V0SGlzdG9yeSgpOiBOb3RpZmljYXRpb25SZWZbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZGlzbWlzcyhub3RpZmljYXRpb25SZWY6IE5vdGlmaWNhdGlvblJlZik6IHZvaWQge1xuICAgICAgICBub3RpZmljYXRpb25SZWYudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMkLm5leHQodGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpKTtcbiAgICB9XG4gICAgXG4gICAgZGlzbWlzc0FsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpLmZvckVhY2gobm90aWZpY2F0aW9uUmVmID0+IG5vdGlmaWNhdGlvblJlZi52aXNpYmxlID0gZmFsc2UpO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMkLm5leHQodGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpKTsgICAgICAgIFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlKSB7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlmaWNhdGlvblJlZiB7XG4gICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgZHVyYXRpb246IG51bWJlcjtcbiAgICBkYXRlOiBEYXRlO1xuICAgIHZpc2libGU/OiBib29sZWFuO1xuICAgIGhlaWdodD86IG51bWJlcjtcbiAgICBzcGFjaW5nPzogbnVtYmVyO1xuICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcbiAgICBpY29uQ29sb3I/OiBzdHJpbmc7XG4gICAgZGF0YTogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpZmljYXRpb25PcHRpb25zIHtcbiAgICBkdXJhdGlvbj86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXI7XG4gICAgc3BhY2luZz86IG51bWJlcjtcbiAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XG4gICAgaWNvbkNvbG9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBOb3RpZmljYXRpb25MaXN0RGlyZWN0aW9uID0gJ2Fib3ZlJyB8ICdiZWxvdyc7IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlLCBOb3RpZmljYXRpb25SZWYsIE5vdGlmaWNhdGlvbkxpc3REaXJlY3Rpb24gfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IHRyaWdnZXIsIHN0YXRlLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMvbWFwJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LW5vdGlmaWNhdGlvbi1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJub3RpZmljYXRpb25cIiAqbmdGb3I9XCJsZXQgbm90aWZpY2F0aW9uUmVmIG9mIG5vdGlmaWNhdGlvbnMkIHwgYXN5bmM7IGxldCBpZHggPSBpbmRleFwiXG4gICAgW3N0eWxlLnRvcC5weF09XCIobm90aWZpY2F0aW9uUmVmLmhlaWdodCArIG5vdGlmaWNhdGlvblJlZi5zcGFjaW5nKSAqIGlkeFwiXG4gICAgW3N0eWxlLmhlaWdodC5weF09XCJub3RpZmljYXRpb25SZWYuaGVpZ2h0XCJcbiAgICBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XCJub3RpZmljYXRpb25SZWYuYmFja2dyb3VuZENvbG9yXCJcbiAgICBbQG5vdGlmaWNhdGlvblN0YXRlXT5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibm90aWZpY2F0aW9uUmVmLnRlbXBsYXRlUmVmOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogbm90aWZpY2F0aW9uUmVmLCBkYXRhOiBub3RpZmljYXRpb25SZWYuZGF0YSB9XCI+PC9uZy1jb250YWluZXI+XG48L2Rpdj5cbmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgYW5pbWF0aW9uczogW1xuICAgICAgICB0cmlnZ2VyKCdub3RpZmljYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgIHN0YXRlKCdpbicsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKScsIG9wYWNpdHk6IDAuOSB9KSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MHB4KScsIG9wYWNpdHk6IDAgfSksXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDApXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDUwcHgpJywgb3BhY2l0eTogMCB9KSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25MaXN0Q29tcG9uZW50IHtcbiAgICBcbiAgICBASW5wdXQoKSBcbiAgICBzZXQgZGlyZWN0aW9uKGRpcmVjdGlvbjogTm90aWZpY2F0aW9uTGlzdERpcmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25TZXJ2aWNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2NsYXNzJykgcG9zaXRpb246IE5vdGlmaWNhdGlvbkxpc3RQb3N0aW9uID0gJ3RvcC1yaWdodCc7XG5cbiAgICBub3RpZmljYXRpb25zJDogT2JzZXJ2YWJsZTxOb3RpZmljYXRpb25SZWZbXT4gPSB0aGlzLl9ub3RpZmljYXRpb25TZXJ2aWNlLm5vdGlmaWNhdGlvbnMkLnBpcGUoXG4gICAgICAgIG1hcCgobm90aWZpY2F0aW9uUmVmczogTm90aWZpY2F0aW9uUmVmW10pID0+IG5vdGlmaWNhdGlvblJlZnMuZmlsdGVyKG5vdGlmaWNhdGlvblJlZiA9PiBub3RpZmljYXRpb25SZWYudmlzaWJsZSksXG4gICAgKSk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9ub3RpZmljYXRpb25TZXJ2aWNlOiBOb3RpZmljYXRpb25TZXJ2aWNlKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIE5vdGlmaWNhdGlvbkxpc3RQb3N0aW9uID0gJ3RvcC1sZWZ0JyB8ICd0b3AtcmlnaHQnIHwgJ2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tcmlnaHQnOyIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnQgfSBmcm9tICcuL25vdGlmaWNhdGlvbi1saXN0LmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvblNlcnZpY2UgfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGUsXHJcbiAgICAgICAgQ29sb3JTZXJ2aWNlTW9kdWxlXHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogW1xyXG4gICAgICAgIE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnRcclxuICAgIF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICBOb3RpZmljYXRpb25MaXN0Q29tcG9uZW50XHJcbiAgICBdLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgTm90aWZpY2F0aW9uU2VydmljZVxyXG4gICAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgTlVNQkVSX1BJQ0tFUl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE51bWJlclBpY2tlckNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbnVtYmVyLXBpY2tlcicsXG4gICAgdGVtcGxhdGU6IGA8aW5wdXQgdHlwZT1cIm51bWJlclwiXG4gICAgICAgcm9sZT1cInNwaW5idXR0b25cIlxuICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sIG51bWJlci1waWNrZXItaW5wdXRcIlxuICAgICAgIFsobmdNb2RlbCldPVwidmFsdWVcIlxuICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgKGtleWRvd24uQXJyb3dEb3duKT1cImRlY3JlbWVudCgkZXZlbnQpXCJcbiAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cImluY3JlbWVudCgkZXZlbnQpXCJcbiAgICAgICAod2hlZWwpPVwib25TY3JvbGwoJGV2ZW50KVwiXG4gICAgICAgc3RlcD1cImFueVwiXG4gICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWluXT1cIm1pblwiXG4gICAgICAgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJ2YWx1ZVwiXG4gICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJtYXhcIj5cblxuPGRpdiBjbGFzcz1cIm51bWJlci1waWNrZXItY29udHJvbHNcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJudW1iZXItcGlja2VyLWNvbnRyb2wtdXBcIlxuICAgICAgICAgKGNsaWNrKT1cImluY3JlbWVudCgkZXZlbnQpXCJcbiAgICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZCB8fCB2YWx1ZSA+PSBtYXhcIj5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS11cFwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJudW1iZXItcGlja2VyLWNvbnRyb2wtZG93blwiXG4gICAgICAgICAoY2xpY2spPVwiZGVjcmVtZW50KCRldmVudClcIlxuICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkIHx8IHZhbHVlIDw9IG1pblwiPlxuXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWRvd25cIj48L3NwYW4+XG4gICAgPC9kaXY+XG5cbjwvZGl2PmAsXG4gICAgcHJvdmlkZXJzOiBbTlVNQkVSX1BJQ0tFUl9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhhcy1lcnJvcl0nOiAnIWlzVmFsaWQoKSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIE51bWJlclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIHByaXZhdGUgX21pbjogbnVtYmVyID0gLUluZmluaXR5O1xuICAgIHByaXZhdGUgX21heDogbnVtYmVyID0gSW5maW5pdHk7XG4gICAgcHJpdmF0ZSBfc3RlcDogbnVtYmVyID0gMTtcbiAgICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3ZhbHVlOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgX3Byb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHsgfTtcblxuICAgIEBJbnB1dCgpIHZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIEBJbnB1dCgndmFsdWUnKVxuICAgIGdldCB2YWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZUNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgbWluKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW47XG4gICAgfVxuICAgIHNldCBtaW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWluID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgbWF4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuICAgIHNldCBtYXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWF4ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgc3RlcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICB9XG4gICAgc2V0IHN0ZXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZGlzYWJsZWQnKSB8fCB2YWx1ZSA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbmNyZW1lbnQoZXZlbnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy52YWx1ZSArIHRoaXMuc3RlcCwgdGhpcy5tYXgpLCB0aGlzLm1pbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNyZW1lbnQoZXZlbnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgodGhpcy52YWx1ZSAtIHRoaXMuc3RlcCwgdGhpcy5taW4pLCB0aGlzLm1heCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1ZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA8IHRoaXMubWluIHx8IHRoaXMudmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gICAgfVxuXG4gICAgb25TY3JvbGwoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBsZXQgc2Nyb2xsVmFsdWUgPSBldmVudC5kZWx0YVkgfHwgZXZlbnQud2hlZWxEZWx0YTtcblxuICAgICAgICBpZiAoc2Nyb2xsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlY3JlbWVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQgeyB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgTnVtYmVyUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9udW1iZXItcGlja2VyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbTnVtYmVyUGlja2VyQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtOdW1iZXJQaWNrZXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIE51bWJlclBpY2tlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLWl0ZW0uZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uU2VydmljZSB7XG5cbiAgICBhY3RpdmUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmU+KG51bGwpO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TWVudU5hdmlnYXRpb25JdGVtXSdcbn0pXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBPdXRwdXQoKSBhY3RpdmF0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2U6IE1lbnVOYXZpZ2F0aW9uU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzZXJ2aWNlLmFjdGl2ZSQuc3Vic2NyaWJlKChuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXRBY3RpdmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZC5lbWl0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eE1lbnVOYXZpZ2F0aW9uXScsXG4gICAgZXhwb3J0QXM6ICd1eE1lbnVOYXZpZ2F0aW9uJyxcbiAgICBwcm92aWRlcnM6IFtNZW51TmF2aWdhdGlvblNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KClcbiAgICB0b2dnbGVCdXR0b246IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuXG4gICAgQElucHV0KClcbiAgICB0b2dnbGVCdXR0b25Qb3NpdGlvbjogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCcgPSAndG9wJztcblxuICAgIEBPdXRwdXQoKVxuICAgIG5hdmlnYXRlZE91dCA9IG5ldyBFdmVudEVtaXR0ZXI8S2V5Ym9hcmRFdmVudD4oKTtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gICAgaXRlbXM6IFF1ZXJ5TGlzdDxNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmU+O1xuXG4gICAgZ2V0IGFjdGl2ZUluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc09yZGVyZWQuaW5kZXhPZih0aGlzLl9zZXJ2aWNlLmFjdGl2ZSQudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2l0ZW1zT3JkZXJlZDogTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlW107XG5cbiAgICBwcml2YXRlIF9kb2N1bWVudDogYW55O1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3NlcnZpY2U6IE1lbnVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgZG9jdW1lbnQ6IGFueVxuICAgICkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVCdXR0b24ua2V5RW50ZXIuc3Vic2NyaWJlKHRoaXMuZm9jdXNGaXJzdC5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgICAgICAgdGhpcy5pdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNPcmRlcmVkID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zT3JkZXJlZCA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBmb2N1c0ZpcnN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vdmVGaXJzdCgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmtleWRvd24nLCBbJyRldmVudCddKVxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gT25seSBoYW5kbGUgZXZlbnRzIHdoZW4gZm9jdXMgaW4gd2l0aGluIHRoZSBsaXN0IG9mIG1lbnUgaXRlbXNcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICBjYXNlICdVcCc6XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlUHJldmlvdXMoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlTmV4dChldmVudCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAgICBjYXNlICdMZWZ0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b25Qb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ1JpZ2h0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b25Qb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlRmlyc3QoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVMYXN0KCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZWRPdXQuZW1pdChldmVudCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlTmV4dChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlcmUncyBubyBhY3RpdmUgbWVudSBpdGVtIHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmFjdGl2ZUluZGV4ICsgMTtcbiAgICAgICAgaWYgKG5leHRJbmRleCA8IHRoaXMuX2l0ZW1zT3JkZXJlZC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgLy8gQWN0aXZhdGUgdGhlIG5leHQgbWVudSBpdGVtXG4gICAgICAgICAgICAvLyAodXhNZW51TmF2aWdhdGlvbkl0ZW0gc3Vic2NyaWJlcyB0byB0aGlzIGFuZCBhcHBsaWVzIGZvY3VzIGlmIGl0IG1hdGNoZXMpXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmFjdGl2ZSQubmV4dCh0aGlzLl9pdGVtc09yZGVyZWRbbmV4dEluZGV4XSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZm9jdXMgd2VudCBvdXQgb2YgYm91bmRzIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG9yaWdpbiB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b25Qb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVQcmV2aW91cyhldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlcmUncyBubyBhY3RpdmUgbWVudSBpdGVtIHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmFjdGl2ZUluZGV4IC0gMTtcbiAgICAgICAgaWYgKG5leHRJbmRleCA+PSAwKSB7XG5cbiAgICAgICAgICAgIC8vIEFjdGl2YXRlIHRoZSBwcmV2aW91cyBtZW51IGl0ZW1cbiAgICAgICAgICAgIC8vICh1eE1lbnVOYXZpZ2F0aW9uSXRlbSBzdWJzY3JpYmVzIHRvIHRoaXMgYW5kIGFwcGxpZXMgZm9jdXMgaWYgaXQgbWF0Y2hlcylcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFtuZXh0SW5kZXhdKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmb2N1cyB3ZW50IG91dCBvZiBib3VuZHMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZUZpcnN0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faXRlbXNPcmRlcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVMYXN0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faXRlbXNPcmRlcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFt0aGlzLl9pdGVtc09yZGVyZWQubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbi5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVCdXR0b24ubWVudU9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmF2aWdhdGVkT3V0LmVtaXQoZXZlbnQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TWVudU5hdmlnYXRpb25Ub2dnbGVdJyxcbiAgICBleHBvcnRBczogJ3V4TWVudU5hdmlnYXRpb25Ub2dnbGUnXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IG1lbnVPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVudU9wZW47XG4gICAgfVxuXG4gICAgc2V0IG1lbnVPcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lbnVPcGVuID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWVudU9wZW5DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBtZW51UG9zaXRpb246ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnID0gJ2JvdHRvbSc7XG5cbiAgICBAT3V0cHV0KClcbiAgICBtZW51T3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIGtleUVudGVyID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgcHJpdmF0ZSBfbWVudU9wZW46IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmlzS2V5TWF0Y2goZXZlbnQua2V5KSkge1xuXG4gICAgICAgICAgICAvLyBPcGVuIHRoZSBtZW51XG4gICAgICAgICAgICB0aGlzLm1lbnVPcGVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIG1lbnUgdG8gaW5pdCwgdGhlbiBzZW5kIHRoZSBldmVudCB0byBnaXZlIGl0IGZvY3VzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUVudGVyLmVtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlzS2V5TWF0Y2goa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgIGNhc2UgJ1VwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZW51UG9zaXRpb24gPT09ICd0b3AnO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudVBvc2l0aW9uID09PSAnYm90dG9tJztcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ0xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ1JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZW51UG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24tdG9nZ2xlLmRpcmVjdGl2ZSc7XG5cbmNvbnN0IEVYUE9SVFMgPSBbXG4gICAgTWVudU5hdmlnYXRpb25EaXJlY3RpdmUsXG4gICAgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlLFxuICAgIE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IEVYUE9SVFMsXG4gICAgZGVjbGFyYXRpb25zOiBFWFBPUlRTLFxufSlcbmV4cG9ydCBjbGFzcyBNZW51TmF2aWdhdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgXG4gICAgc2VsZWN0b3I6ICdbdXhQYWdlSGVhZGVyQ3VzdG9tTWVudV0nIFxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSB7IH0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSwgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIGl0ZW1zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10+KFtdKTtcbiAgICBzZWxlY3RlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4obnVsbCk7XG4gICAgc2VsZWN0ZWRSb290JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPihudWxsKTtcbiAgICBzZWNvbmRhcnkkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgYWN0aXZlSWNvbk1lbnUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVySWNvbk1lbnU+KG51bGwpO1xuICAgIHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0ID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLnNlbGVjdGVkJC5waXBlKG1hcChzZWxlY3RlZCA9PiB0aGlzLmdldFJvb3Qoc2VsZWN0ZWQpKSkuc3Vic2NyaWJlKHJvb3QgPT4gdGhpcy5zZWxlY3RlZFJvb3QkLm5leHQocm9vdCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgJiYgaXRlbSAmJiBpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGZpcnN0IGNoaWxkIGluIHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0IG1vZGVcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQoaXRlbS5jaGlsZHJlblswXSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIHNlY29uZGFyeSBuYXZpZ2F0aW9uIG1vZGUgYW5kIHdlIGNsaWNrIGEgcGFyZW50IC0gZG9udCBkZXNlbGVjdCB0aGUgY2hpbGRcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY29uZGFyeSQuZ2V0VmFsdWUoKSA9PT0gdHJ1ZSAmJiB0aGlzLmlzUGFyZW50T2YodGhpcy5zZWxlY3RlZCQuZ2V0VmFsdWUoKSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZWxlY3QgdGhlIGdpdmVuIGl0ZW1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfCBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRlc2VsZWN0IHRoZSBjdXJyZW50IGl0ZW1cbiAgICAgICAgaXRlbS5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgYW55IGNoaWxkcmVuIGFuZCBkZXNlbGVjdCB0aGVtXG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpdGVtLmNoaWxkcmVuLmZvckVhY2goX2l0ZW0gPT4gdGhpcy5kZXNlbGVjdChfaXRlbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3RBbGwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXRlbXMkLmdldFZhbHVlKCkuZm9yRWFjaChpdGVtID0+IHRoaXMuZGVzZWxlY3QoaXRlbSkpO1xuICAgIH1cblxuICAgIHVwZGF0ZUl0ZW0oaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtLCBzZWxlY3RlZDogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gSXRlbSBpcyBzZWxlY3RlZCBpZiBpdCBpcyB0aGUgc2VsZWN0ZWQgaXRlbSwgb3Igb25lIG9mIHRoZSBzZWxlY3RlZCBpdGVtJ3MgYW5jZXN0b3JzLlxuICAgICAgICBpdGVtLnNlbGVjdGVkID0gKGl0ZW0gPT09IHNlbGVjdGVkKSB8fCB0aGlzLmlzUGFyZW50T2Yoc2VsZWN0ZWQsIGl0ZW0pO1xuXG4gICAgICAgIGlmIChpdGVtID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgLy8gY2FsbCB0aGUgc2VsZWN0IGZ1bmN0aW9uIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0LmNhbGwoaXRlbSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJdGVtcyhpdGVtczogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10gPSBbXSk6IHZvaWQge1xuICAgICAgICAvLyBpZGVudGlmeSBhbGwgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB0aGlzLnNldFBhcmVudChpdGVtKSk7XG5cbiAgICAgICAgdGhpcy5pdGVtcyQubmV4dChpdGVtcyk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRoZSBpbml0YWxseSBzZWxlY3RlZCBpdGVtXG4gICAgICAgIGNvbnN0IGluaXRpYWxTZWxlY3RlZEl0ZW0gPSBpdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5zZWxlY3RlZCA9PT0gdHJ1ZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0KGluaXRpYWxTZWxlY3RlZEl0ZW0pO1xuICAgIH1cblxuICAgIHNldFNlY29uZGFyeU5hdmlnYXRpb24oZW5hYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNlY29uZGFyeSQubmV4dChlbmFibGVkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFJvb3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb24pOiBQYWdlSGVhZGVyTmF2aWdhdGlvbiB7XG4gICAgICAgIHJldHVybiBpdGVtICYmIGl0ZW0ucGFyZW50ID8gdGhpcy5nZXRSb290KGl0ZW0ucGFyZW50KSA6IGl0ZW07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRQYXJlbnQoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb24sIHBhcmVudD86IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uIHwgbnVsbCk6IHZvaWQge1xuICAgICAgICAvLyBzZXQgdGhlIHBhcmVudCBmaWVsZFxuICAgICAgICBpdGVtLnBhcmVudCA9IHBhcmVudDtcblxuICAgICAgICAvLyBjYWxsIHRoaXMgZnVuY3Rpb24gcmVjdXJzaXZlbHkgb24gYWxsIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpdGVtLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdGhpcy5zZXRQYXJlbnQoY2hpbGQsIGl0ZW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaXNQYXJlbnRPZihub2RlOiBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgcGFyZW50OiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwYXJlbnRzIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAoIW5vZGUgfHwgIW5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGlzIHRoZSBtYXRjaCB3ZSBhcmUgbG9va2luZyBmb3IgcmV0dXJuIHRydWVcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHBvdGVudGlhbGx5IGdyYW5kcGFyZW50cyB0aGVuIGNoZWNrIHRoZW0gdG9vXG4gICAgICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2Yobm9kZS5wYXJlbnQsIHBhcmVudCk7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlSGVhZGVyTmF2aWdhdGlvbiA9IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB8IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtOyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudSwgUGFnZUhlYWRlckljb25NZW51RHJvcGRvd25JdGVtIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyU2VydmljZSB9IGZyb20gJy4uL3BhZ2UtaGVhZGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWljb24tbWVudScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItaWNvbi1tZW51XCJcbiAgICBkcm9wZG93blxuICAgIHBsYWNlbWVudD1cImJvdHRvbSByaWdodFwiXG4gICAgWyhpc09wZW4pXT1cImlzT3BlblwiPlxuXG4gICAgPGEgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwicGFnZS1oZWFkZXItaWNvbi1tZW51LWJ1dHRvblwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibWVudS5sYWJlbFwiXG4gICAgICAgIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgKGNsaWNrKT1cInNlbGVjdChtZW51KVwiXG4gICAgICAgIGRyb3Bkb3duVG9nZ2xlXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25Ub2dnbGVcbiAgICAgICAgI21lbnVOYXZpZ2F0aW9uVG9nZ2xlPVwidXhNZW51TmF2aWdhdGlvblRvZ2dsZVwiXG4gICAgICAgIFsobWVudU9wZW4pXT1cImlzT3BlblwiPlxuXG4gICAgICAgIDxpIGNsYXNzPVwiaHBlLWljb25cIiBbbmdDbGFzc109XCJtZW51Lmljb25cIj48L2k+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWwgbGFiZWwtcHJpbWFyeVwiICpuZ0lmPVwibWVudT8uYmFkZ2VcIiBhcmlhLWhpZGRlbj1cInRydWVcIj57eyBtZW51LmJhZGdlIH19PC9zcGFuPlxuXG4gICAgPC9hPlxuXG4gICAgPHVsICpkcm9wZG93bk1lbnVcbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1tZW51XCJcbiAgICAgICAgcm9sZT1cIm1lbnVcIlxuICAgICAgICB1eE1lbnVOYXZpZ2F0aW9uXG4gICAgICAgIFt0b2dnbGVCdXR0b25dPVwibWVudU5hdmlnYXRpb25Ub2dnbGVcIj5cblxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGRyb3Bkb3duIG9mIG1lbnU/LmRyb3Bkb3duXCJcbiAgICAgICAgICAgIHJvbGU9XCJub25lXCJcbiAgICAgICAgICAgIFtjbGFzcy5kcm9wZG93bi1oZWFkZXJdPVwiZHJvcGRvd24uaGVhZGVyXCJcbiAgICAgICAgICAgIFtjbGFzcy5kcm9wZG93bi1kaXZpZGVyXT1cImRyb3Bkb3duLmRpdmlkZXJcIj5cblxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb250LWJvbGRcIiAqbmdJZj1cImRyb3Bkb3duLmhlYWRlclwiPnt7IGRyb3Bkb3duLnRpdGxlIH19PC9zcGFuPlxuXG4gICAgICAgICAgICA8YSAqbmdJZj1cIiFkcm9wZG93bi5oZWFkZXJcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0KGRyb3Bkb3duKVwiXG4gICAgICAgICAgICAgICAgKGtleWRvd24pPVwia2V5ZG93bkhhbmRsZXIoZHJvcGRvd24sICRldmVudClcIlxuICAgICAgICAgICAgICAgIHV4TWVudU5hdmlnYXRpb25JdGVtPlxuXG5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0tdGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtZndcIiBbbmdDbGFzc109XCJkcm9wZG93bi5pY29uXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICB7eyBkcm9wZG93bi50aXRsZSB9fVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImRyb3Bkb3duLnN1YnRpdGxlXCIgY2xhc3M9XCJkcm9wZG93bi1pdGVtLXN1YnRpdGxlXCI+e3sgZHJvcGRvd24uc3VidGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cblxuICAgIDwvdWw+XG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJJY29uTWVudUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBtZW51OiBQYWdlSGVhZGVySWNvbk1lbnU7XG5cbiAgICBnZXQgaXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuO1xuICAgIH1cblxuICAgIHNldCBpc09wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5faXNPcGVuID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmVJY29uTWVudSQubmV4dCh0aGlzLm1lbnUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQFZpZXdDaGlsZCgnbWVudU5hdmlnYXRpb25Ub2dnbGUnKSBtZW51TmF2aWdhdGlvblRvZ2dsZTogTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmU7XG5cbiAgICBwcml2YXRlIF9pc09wZW46IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZXJ2aWNlOiBQYWdlSGVhZGVyU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBfc2VydmljZS5hY3RpdmVJY29uTWVudSQuc3Vic2NyaWJlKChuZXh0KSA9PiB7XG4gICAgICAgICAgICAvLyBDbG9zZSBhbGwgYnV0IHRoZSBtb3N0IHJlY2VudGx5IG9wZW5lZCBtZW51XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gdGhpcy5tZW51KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoaXRlbTogUGFnZUhlYWRlckljb25NZW51IHwgUGFnZUhlYWRlckljb25NZW51RHJvcGRvd25JdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdCkge1xuICAgICAgICAgICAgaXRlbS5zZWxlY3QuY2FsbChpdGVtLCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtleWRvd25IYW5kbGVyKGl0ZW06IFBhZ2VIZWFkZXJJY29uTWVudSB8IFBhZ2VIZWFkZXJJY29uTWVudURyb3Bkb3duSXRlbSwgZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnVOYXZpZ2F0aW9uVG9nZ2xlLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBPbkRlc3Ryb3ksIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3BhZ2UtaGVhZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0gfSBmcm9tICcuLi9uYXZpZ2F0aW9uLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0nLFxuICAgIGV4cG9ydEFzOiAndXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdJZj1cIml0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwXCJcbiAgICBkcm9wZG93blxuICAgICNzdWJNZW51PVwiYnMtZHJvcGRvd25cIlxuICAgIFtpc09wZW5dPVwiZHJvcGRvd25PcGVuXCJcbiAgICBjb250YWluZXI9XCJib2R5XCJcbiAgICBwbGFjZW1lbnQ9XCJyaWdodFwiXG4gICAgKG1vdXNlZW50ZXIpPVwiaG92ZXJTdGFydCgpXCJcbiAgICAobW91c2VsZWF2ZSk9XCJob3ZlckxlYXZlKClcIj5cblxuICAgIDxhIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImRyb3Bkb3duT3BlblwiXG4gICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG4gICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAjYnV0dG9uXG4gICAgICAgIGRyb3Bkb3duVG9nZ2xlXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25Ub2dnbGVcbiAgICAgICAgI21lbnVOYXZpZ2F0aW9uVG9nZ2xlPVwidXhNZW51TmF2aWdhdGlvblRvZ2dsZVwiXG4gICAgICAgIFsobWVudU9wZW4pXT1cImRyb3Bkb3duT3BlblwiXG4gICAgICAgIG1lbnVQb3NpdGlvbj1cInJpZ2h0XCI+XG5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkcm9wZG93bi1pdGVtLXRpdGxlXCI+e3sgaXRlbS50aXRsZSB9fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkcm9wZG93bi1pdGVtLWljb24gaHBlLWljb24gaHBlLW5leHRcIj48L3NwYW4+XG5cbiAgICA8L2E+XG5cbiAgICA8dWwgKmRyb3Bkb3duTWVudVxuICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgIGNsYXNzPVwiZHJvcGRvd24tbWVudSBob3Jpem9udGFsLW5hdmlnYXRpb24tZHJvcGRvd24tc3VibWVudVwiXG4gICAgICAgIChtb3VzZWVudGVyKT1cImhvdmVyU3RhcnQoKVwiXG4gICAgICAgIChtb3VzZWxlYXZlKT1cImhvdmVyTGVhdmUoKVwiXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25cbiAgICAgICAgI21lbnVOYXZpZ2F0aW9uPVwidXhNZW51TmF2aWdhdGlvblwiXG4gICAgICAgIFt0b2dnbGVCdXR0b25dPVwibWVudU5hdmlnYXRpb25Ub2dnbGVcIlxuICAgICAgICB0b2dnbGVCdXR0b25Qb3NpdGlvbj1cImxlZnRcIj5cblxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IHN1Ykl0ZW0gb2YgaXRlbS5jaGlsZHJlblwiIHJvbGU9XCJub25lXCI+XG5cbiAgICAgICAgICAgIDxhIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muc2VsZWN0ZWRdPVwic3ViSXRlbS5zZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJzdWJJdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0KHN1Ykl0ZW0pXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bik9XCJrZXlkb3duSGFuZGxlcigkZXZlbnQsIHN1Ykl0ZW0pXCJcbiAgICAgICAgICAgICAgICB1eE1lbnVOYXZpZ2F0aW9uSXRlbT5cblxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZHJvcGRvd24taXRlbS10aXRsZVwiPnt7IHN1Ykl0ZW0udGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgICAgIDwvYT5cblxuICAgICAgICA8L2xpPlxuICAgIDwvdWw+XG5cbjwvZGl2PlxuXG48ZGl2ICpuZ0lmPVwiIWl0ZW0uY2hpbGRyZW4gfHwgaXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDBcIlxuICAgIChtb3VzZWVudGVyKT1cImhvdmVyU3RhcnQoKVwiXG4gICAgKG1vdXNlbGVhdmUpPVwiaG92ZXJMZWF2ZSgpXCI+XG5cbiAgICA8YSByb2xlPVwibWVudWl0ZW1cIlxuICAgICAgICAjYnV0dG9uXG4gICAgICAgIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgIChjbGljayk9XCJzZWxlY3QoaXRlbSlcIlxuICAgICAgICAoa2V5ZG93bik9XCJrZXlkb3duSGFuZGxlcigkZXZlbnQsIGl0ZW0pXCI+XG5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkcm9wZG93bi1pdGVtLXRpdGxlXCI+e3sgaXRlbS50aXRsZSB9fTwvc3Bhbj5cblxuICAgIDwvYT5cblxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbTtcblxuICAgIEBWaWV3Q2hpbGQoJ2J1dHRvbicpXG4gICAgYnV0dG9uOiBFbGVtZW50UmVmO1xuXG4gICAgZHJvcGRvd25PcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9ob3ZlciQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHN0cmVhbSB3aXRoIGEgZGVib3VuY2UgKGEgc21hbGwgZGVib3VuY2UgaXMgYWxsIHRoYXQgaXMgcmVxdWlyZWQpXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX2hvdmVyJC5waXBlKGRlYm91bmNlVGltZSgxKSkuc3Vic2NyaWJlKHZpc2libGUgPT4gdGhpcy5kcm9wZG93bk9wZW4gPSB2aXNpYmxlKTtcblxuICAgICAgICAvLyBDbG9zZSBzdWJtZW51cyB3aGVuIHNlbGVjdGVkIGl0ZW0gY2hhbmdlc1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgICAgICAgX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0pIHtcblxuICAgICAgICAvLyBjbGlja2luZyBvbiBhbiBpdGVtIHdpdGggY2hpbGRyZW4gdGhlbiByZXR1cm5cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gYW4gZXZlbnRcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0KGl0ZW0pO1xuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgaG92ZXJTdGFydCgpIHtcbiAgICAgICAgdGhpcy5faG92ZXIkLm5leHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgaG92ZXJMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5faG92ZXIkLm5leHQoZmFsc2UpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSk6IHZvaWQge1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBRdWVyeUxpc3QsIFZpZXdDaGlsZCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duRGlyZWN0aXZlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uLy4uL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCB9IGZyb20gJy4uL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS9uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB9IGZyb20gJy4uL25hdmlnYXRpb24uY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24taXRlbScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIShzZWNvbmRhcnkkIHwgYXN5bmMpXCJcbiAgICBkcm9wZG93blxuICAgICNtZW51PVwiYnMtZHJvcGRvd25cIlxuICAgIFsoaXNPcGVuKV09XCJpc09wZW5cIlxuICAgIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgIHBsYWNlbWVudD1cImJvdHRvbSBsZWZ0XCI+XG5cbiAgICA8YnV0dG9uIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgIGNsYXNzPVwiaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWJ1dHRvblwiXG4gICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgW2NsYXNzLm9wZW5dPVwiaXNPcGVuXCJcbiAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImlzT3BlblwiXG4gICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG4gICAgICAgIGRyb3Bkb3duVG9nZ2xlXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25Ub2dnbGVcbiAgICAgICAgI2J1dHRvbj1cInV4TWVudU5hdmlnYXRpb25Ub2dnbGVcIlxuICAgICAgICBbKG1lbnVPcGVuKV09XCJpc09wZW5cIj5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIG5hdmlnYXRpb24taXRlbS1pY29uXCIgKm5nSWY9XCJpdGVtLmljb25cIiBbbmdDbGFzc109XCJpdGVtPy5pY29uXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cIm5hdmlnYXRpb24taXRlbS1sYWJlbFwiPnt7IGl0ZW0/LnRpdGxlIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1kb3duXCI+PC9zcGFuPlxuXG4gICAgPC9idXR0b24+XG5cbiAgICA8ZGl2ICpkcm9wZG93bk1lbnVcbiAgICAgICAgcm9sZT1cIm1lbnVcIlxuICAgICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnUgaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLW1lbnVcIlxuICAgICAgICB1eE1lbnVOYXZpZ2F0aW9uXG4gICAgICAgIFt0b2dnbGVCdXR0b25dPVwiYnV0dG9uXCJcbiAgICAgICAgdG9nZ2xlQnV0dG9uUG9zaXRpb249XCJ0b3BcIj5cblxuICAgICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW0/LmNoaWxkcmVuXCIgdXhNZW51TmF2aWdhdGlvbkl0ZW0gKGFjdGl2YXRlZCk9XCJkcm9wZG93bkl0ZW0uZm9jdXMoKVwiPlxuICAgICAgICAgICAgPHV4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtXG4gICAgICAgICAgICAgICAgI2Ryb3Bkb3duSXRlbT1cInV4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICBbaXRlbV09XCJpdGVtXCI+XG4gICAgICAgICAgICA8L3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtPlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG48L2Rpdj5cblxuPGJ1dHRvbiAqbmdJZj1cIiFpdGVtLmNoaWxkcmVuIHx8IGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IChzZWNvbmRhcnkkIHwgYXN5bmMpXCJcbiAgICByb2xlPVwibWVudWl0ZW1cIlxuICAgIGNsYXNzPVwiaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWJ1dHRvblwiXG4gICAgW2NsYXNzLnNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG4gICAgKGNsaWNrKT1cInNlbGVjdCgpXCI+XG5cbiAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIG5hdmlnYXRpb24taXRlbS1pY29uXCIgKm5nSWY9XCJpdGVtLmljb25cIiBbbmdDbGFzc109XCJpdGVtPy5pY29uXCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwibmF2aWdhdGlvbi1pdGVtLWxhYmVsXCI+e3sgaXRlbT8udGl0bGUgfX08L3NwYW4+XG5cbjwvYnV0dG9uPmBcbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQFZpZXdDaGlsZCgnYnV0dG9uJykgYnV0dG9uOiBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZTtcbiAgICBAVmlld0NoaWxkKCdtZW51JykgbWVudTogQnNEcm9wZG93bkRpcmVjdGl2ZTtcbiAgICBAVmlld0NoaWxkcmVuKFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50KSBkcm9wZG93bnM6IFF1ZXJ5TGlzdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudD47XG5cbiAgICBASW5wdXQoKSBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW07XG5cbiAgICBzZWNvbmRhcnkkOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnkkO1xuXG4gICAgaXNPcGVuOiBib29sZWFuO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX3BhZ2VIZWFkZXJTZXJ2aWNlOiBQYWdlSGVhZGVyU2VydmljZVxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQuc3Vic2NyaWJlKG5leHQgPT4ge1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWQgc3RhdGUgZm9yIHRoaXMgaXRlbVxuICAgICAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2UudXBkYXRlSXRlbSh0aGlzLml0ZW0sIG5leHQpO1xuXG4gICAgICAgICAgICBpZiAobmV4dCAmJiB0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBtZW51IHdhcyBjbG9zZWQsIGtlZXAgZm9jdXMgb24gdGhlIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgICAgICAgICAgIHRoaXMubWVudS5vbkhpZGRlbi5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kcm9wZG93bnMuZm9yRWFjaChkcm9wZG93biA9PiBkcm9wZG93bi5jbG9zZSgpKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0KCkge1xuXG4gICAgICAgIC8vIGlmIHRoZSBpdGVtIGhhcyBjaGlsZHJlbiB0aGVuIGRvIG5vdGhpbmcgYXQgdGhpcyBzdGFnZVxuICAgICAgICBpZiAodGhpcy5pdGVtLmNoaWxkcmVuICYmIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlY29uZGFyeSQuZ2V0VmFsdWUoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBzZWxlY3QgdGhlIGN1cnJlbnQgaXRlbVxuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3QodGhpcy5pdGVtKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgZGVsYXksIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB9IGZyb20gJy4uL25hdmlnYXRpb24uY29tcG9uZW50JztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdbdXhQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW1dJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG5cclxuICAgIEBJbnB1dCgndXhQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW0nKVxyXG4gICAgaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtO1xyXG5cclxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0ZWQkLnBpcGUoZGVsYXkoMCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUobmV4dCA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWQgc3RhdGUgZm9yIHRoaXMgaXRlbVxyXG4gICAgICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS51cGRhdGVJdGVtKHRoaXMuaXRlbSwgbmV4dCk7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uLCBQYWdlSGVhZGVyU2VydmljZSB9IGZyb20gJy4uL3BhZ2UtaGVhZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uLWl0ZW0vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYDx1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24taXRlbVxuICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zJCB8IGFzeW5jXCJcbiAgICBbaXRlbV09XCJpdGVtXCI+XG48L3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1pdGVtPlxuXG48ZGl2IGNsYXNzPVwic2VsZWN0ZWQtaW5kaWNhdG9yXCJcbiAgICBbc3R5bGUub3BhY2l0eV09XCJpbmRpY2F0b3JWaXNpYmxlID8gMSA6IDBcIlxuICAgIFtzdHlsZS5tYXJnaW4tbGVmdC5weF09XCJpbmRpY2F0b3JYXCJcbiAgICBbc3R5bGUud2lkdGgucHhdPVwiaW5kaWNhdG9yV2lkdGhcIj5cbjwvZGl2PmAsXG4gICAgaG9zdDoge1xuICAgICAgICAncm9sZSc6ICdtZW51YmFyJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlck5hdmlnYXRpb25Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQFZpZXdDaGlsZHJlbihQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQpIG1lbnVJdGVtczogUXVlcnlMaXN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudD47XG5cbiAgICBpdGVtcyQ6IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1bXT4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5pdGVtcyQ7XG4gICAgaW5kaWNhdG9yVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGluZGljYXRvclg6IG51bWJlciA9IDA7XG4gICAgaW5kaWNhdG9yV2lkdGg6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlLCBwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChyZXNpemVTZXJ2aWNlLmFkZFJlc2l6ZUxpc3RlbmVyKGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkuc3Vic2NyaWJlKHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKF9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUodGhpcy51cGRhdGVTZWxlY3RlZEluZGljYXRvci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlY29uZGFyeSQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUodGhpcy51cGRhdGVTZWxlY3RlZEluZGljYXRvci5iaW5kKHRoaXMpKSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yKCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yKCk6IHZvaWQge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5tZW51SXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaXRlbS5zZWxlY3RlZCk7XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHRoZSBpbmRpY2F0b3JcbiAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yVmlzaWJsZSA9ICEhc2VsZWN0ZWQ7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgd2lkdGggb2YgdGhlIGluZGljYXRvciB0byBtYXRjaCB0aGUgd2lkdGggb2YgdGhlIG5hdmlnYXRpb24gaXRlbVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzZWxlY3RlZC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3JYID0gc2VsZWN0ZWQuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3JXaWR0aCA9IHBhcnNlSW50KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIHtcbiAgICBpY29uPzogc3RyaW5nO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgc2VsZWN0ZWQ/OiBib29sZWFuO1xuICAgIHNlbGVjdD86IChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0pID0+IHZvaWQ7XG4gICAgY2hpbGRyZW4/OiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbVtdO1xuICAgIHBhcmVudD86IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgICBzZWxlY3Q/OiAoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0pID0+IHZvaWQ7XG4gICAgY2hpbGRyZW4/OiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbVtdO1xuICAgIHBhcmVudD86IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uO1xufVxuXG4vLyBUaGlzIGlzIGFuIGFsaWFzIGZvciBNRiB1c2UgYXMgXCJEcm9wZG93bkl0ZW1cIiBkb2Vzbid0IG1ha2Ugc2Vuc2UgaW4gY29udGV4dCB3aXRoIGhvdyBpdCBpcyB1c2VkXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VIZWFkZXJTZWNvbmRhcnlOYXZpZ2F0aW9uSXRlbSBleHRlbmRzIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcbmltcG9ydCB7IEJyZWFkY3J1bWIgfSBmcm9tICcuLi9icmVhZGNydW1icy9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSB9IGZyb20gJy4vY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb24sIFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlcicsXG4gICAgZXhwb3J0QXM6ICd1eC1wYWdlLWhlYWRlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidXgtcGFnZS1oZWFkZXJcIiBbY2xhc3MucGFnZS1oZWFkZXItY29uZGVuc2VkXT1cImNvbmRlbnNlZFwiIHJvbGU9XCJiYW5uZXJcIj5cblxuICAgIDwhLS0gRGlzcGxheSBVcHBlciBTZWN0aW9uIHdoZW4gbm90IGNvbmRlbnNlZCAtLT5cbiAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItYWN0aW9uc1wiICpuZ0lmPVwiIWNvbmRlbnNlZFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1sb2dvLWNvbnRhaW5lclwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBbaGlkZGVuXT1cIiFsb2dvXCI+XG4gICAgICAgICAgICA8aW1nIFthdHRyLnNyY109XCJsb2dvXCIgY2xhc3M9XCJwYWdlLWhlYWRlci1sb2dvXCI+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1uYXZpZ2F0aW9uXCIgW25nQ2xhc3NdPVwiYWxpZ25tZW50XCIgcm9sZT1cIm5hdmlnYXRpb25cIiBhcmlhLWxhYmVsPVwiUHJpbWFyeSBOYXZpZ2F0aW9uXCI+XG5cbiAgICAgICAgICAgIDwhLS0gVGhlIFRvcCBOYXZpZ2F0aW9uIE9wdGlvbnMgLS0+XG4gICAgICAgICAgICA8dXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uPjwvdXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItaWNvbi1tZW51c1wiIHJvbGU9XCJ0b29sYmFyXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBtZW51IG9mIGN1c3RvbU1lbnVzXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibWVudVwiPjwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8dXgtcGFnZS1oZWFkZXItaWNvbi1tZW51ICpuZ0Zvcj1cImxldCBtZW51IG9mIGljb25NZW51c1wiIFttZW51XT1cIm1lbnVcIj48L3V4LXBhZ2UtaGVhZGVyLWljb24tbWVudT5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIERpc3BsYXkgTG93ZXIgU2VjdGlvbiBXaGVuIE5vdCBDb25kZW5zZWQgLS0+XG4gICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWRldGFpbHNcIiAqbmdJZj1cIiFjb25kZW5zZWRcIj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItc3RhdGUtY29udGFpbmVyXCIgcm9sZT1cIm5hdmlnYXRpb25cIj5cblxuICAgICAgICAgICAgPGJ1dHRvbiAqbmdJZj1cImJhY2tWaXNpYmxlID09PSB0cnVlXCIgY2xhc3M9XCJwYWdlLWhlYWRlci1iYWNrLWJ1dHRvblwiIChjbGljayk9XCJnb0JhY2soKVwiIGFyaWEtbGFiZWw9XCJHbyBCYWNrXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtcHJldmlvdXMgdGV4dC1wcmltYXJ5XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci10aXRsZS1jb250YWluZXJcIj5cblxuICAgICAgICAgICAgICAgIDx1eC1icmVhZGNydW1icyBbY3J1bWJzXT1cImNydW1ic1wiPjwvdXgtYnJlYWRjcnVtYnM+XG5cbiAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJwYWdlLWhlYWRlci10aXRsZVwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiZmFtaWx5QmFja2dyb3VuZFwiIFtzdHlsZS5jb2xvcl09XCJmYW1pbHlGb3JlZ3JvdW5kXCI+e3sgaGVhZGVyIH19PC9oMT5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIERpc3BsYXkgVGhpcyBTZWN0aW9uIE9wdGltaXplZCBmb3IgQ29uZGVuc2VkIE1vZGUgLS0+XG4gICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWNvbmRlbnNlZC1jb250ZW50XCIgKm5nSWY9XCJjb25kZW5zZWRcIj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItYnJlYWRjcnVtYnNcIiByb2xlPVwibmF2aWdhdGlvblwiPlxuICAgICAgICAgICAgPHV4LWJyZWFkY3J1bWJzIFtjcnVtYnNdPVwiY3J1bWJzXCI+PC91eC1icmVhZGNydW1icz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLW5hdmlnYXRpb25cIiBbbmdDbGFzc109XCJhbGlnbm1lbnRcIiByb2xlPVwibmF2aWdhdGlvblwiIGFyaWEtbGFiZWw9XCJQcmltYXJ5IE5hdmlnYXRpb25cIj5cblxuICAgICAgICAgICAgPCEtLSBUaGUgVG9wIE5hdmlnYXRpb24gT3B0aW9ucyAtLT5cbiAgICAgICAgICAgIDx1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24+PC91eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1pY29uLW1lbnVzXCIgcm9sZT1cInRvb2xiYXJcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IG1lbnUgb2YgY3VzdG9tTWVudXNcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJtZW51XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8dXgtcGFnZS1oZWFkZXItaWNvbi1tZW51ICpuZ0Zvcj1cImxldCBtZW51IG9mIGljb25NZW51c1wiIFttZW51XT1cIm1lbnVcIj48L3V4LXBhZ2UtaGVhZGVyLWljb24tbWVudT5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1zZWNvbmRhcnlcIiBbbmdDbGFzc109XCJzZWNvbmRhcnlOYXZpZ2F0aW9uQWxpZ25tZW50XCIgcm9sZT1cIm5hdmlnYXRpb25cIiAqbmdJZj1cInNlY29uZGFyeU5hdmlnYXRpb24gJiYgKHNlbGVjdGVkUm9vdCQgfCBhc3luYylcIj5cbiAgICA8dWwgY2xhc3M9XCJuYXYgbmF2LXRhYnNcIiByb2xlPVwidGFibGlzdFwiIGFyaWEtbGFiZWw9XCJTZWNvbmRhcnkgTmF2aWdhdGlvblwiICpuZ0lmPVwiKHNlbGVjdGVkUm9vdCQgfCBhc3luYyk/LmNoaWxkcmVuOyBsZXQgY2hpbGRyZW5cIj5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjaGlsZCBvZiBjaGlsZHJlblwiXG4gICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cImNoaWxkLnNlbGVjdGVkXCJcbiAgICAgICAgICAgIHJvbGU9XCJub25lXCJcbiAgICAgICAgICAgIFt1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbV09XCJjaGlsZFwiPlxuXG4gICAgICAgICAgICA8YSByb2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cImNoaWxkLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3QoY2hpbGQpXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJzZWxlY3QoY2hpbGQpXCI+e3sgY2hpbGQudGl0bGUgfX08L2E+XG5cbiAgICAgICAgPC9saT5cbiAgICA8L3VsPlxuPC9kaXY+YCxcbiAgICBwcm92aWRlcnM6IFsgUGFnZUhlYWRlclNlcnZpY2UgXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGxvZ286IHN0cmluZztcbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBhbGlnbm1lbnQ6ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyA9ICdjZW50ZXInO1xuICAgIEBJbnB1dCgpIGNvbmRlbnNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGljb25NZW51czogUGFnZUhlYWRlckljb25NZW51W107XG4gICAgQElucHV0KCkgYmFja1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNlY29uZGFyeU5hdmlnYXRpb25BbGlnbm1lbnQ6IHN0cmluZyA9ICdjZW50ZXInO1xuXG4gICAgQElucHV0KCkgc2V0IHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0KHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3Q7XG4gICAgfVxuXG4gICAgQElucHV0KCkgc2V0IGl0ZW1zKGl0ZW1zOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1bXSkge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZXRJdGVtcyhpdGVtcyk7XG4gICAgfVxuXG4gICAgQElucHV0KCkgc2V0IHNlY29uZGFyeU5hdmlnYXRpb24oZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZXRTZWNvbmRhcnlOYXZpZ2F0aW9uKGVuYWJsZWQpO1xuICAgIH1cblxuICAgIGdldCBzZWNvbmRhcnlOYXZpZ2F0aW9uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIHNldCBjcnVtYnMoY3J1bWJzOiBCcmVhZGNydW1iW10pIHtcbiAgICAgICAgdGhpcy5fY3J1bWJzID0gY3J1bWJzO1xuICAgIH1cblxuICAgIGdldCBjcnVtYnMoKTogQnJlYWRjcnVtYltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGVuc2VkID8gWy4uLnRoaXMuX2NydW1icywgeyB0aXRsZTogdGhpcy5oZWFkZXIgfV0gOiB0aGlzLl9jcnVtYnM7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgZmFtaWx5QmFja2dyb3VuZChjb2xvcjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2ZhbWlseUJhY2tncm91bmQgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZShjb2xvcik7XG4gICAgfVxuXG4gICAgZ2V0IGZhbWlseUJhY2tncm91bmQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhbWlseUJhY2tncm91bmQ7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgZmFtaWx5Rm9yZWdyb3VuZChjb2xvcjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2ZhbWlseUZvcmVncm91bmQgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZShjb2xvcik7XG4gICAgfVxuXG4gICAgZ2V0IGZhbWlseUZvcmVncm91bmQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhbWlseUZvcmVncm91bmQ7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIGJhY2tDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY3VzdG9tTWVudXM6IFF1ZXJ5TGlzdDxUZW1wbGF0ZVJlZjxhbnk+PjtcblxuICAgIHNlbGVjdGVkJDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQ7XG4gICAgc2VsZWN0ZWRSb290JDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZFJvb3QkO1xuXG4gICAgcHJpdmF0ZSBfY3J1bWJzOiBCcmVhZGNydW1iW10gPSBbXTtcbiAgICBwcml2YXRlIF9mYW1pbHlCYWNrZ3JvdW5kOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfZmFtaWx5Rm9yZWdyb3VuZDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfY29sb3JTZXJ2aWNlOiBDb2xvclNlcnZpY2UsIHByaXZhdGUgX3BhZ2VIZWFkZXJTZXJ2aWNlOiBQYWdlSGVhZGVyU2VydmljZSkgeyB9XG5cbiAgICBnb0JhY2soKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYmFja0NsaWNrLmVtaXQoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0KGl0ZW0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJzRHJvcGRvd25Nb2R1bGUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2Ryb3Bkb3duJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vaW5kZXgnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgQnJlYWRjcnVtYnNNb2R1bGUgfSBmcm9tICcuLi9icmVhZGNydW1icy9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSB9IGZyb20gJy4vY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudUNvbXBvbmVudCB9IGZyb20gJy4vaWNvbi1tZW51L2ljb24tbWVudS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLXNlY29uZGFyeS1pdGVtL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQnJlYWRjcnVtYnNNb2R1bGUsXG4gICAgICAgIENvbG9yU2VydmljZU1vZHVsZSxcbiAgICAgICAgUmVzaXplTW9kdWxlLFxuICAgICAgICBNZW51TmF2aWdhdGlvbk1vZHVsZSxcbiAgICAgICAgQnNEcm9wZG93bk1vZHVsZS5mb3JSb290KClcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVySWNvbk1lbnVDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlLFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wcm9ncmVzcy1iYXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdJZj1cIiFpbmRldGVybWluYXRlXCIgY2xhc3M9XCJwcm9ncmVzc2Jhci10cmFja1wiIFtzdHlsZS53aWR0aC4lXT1cIih2YWx1ZSAvIG1heCkgKiAxMDBcIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cImJhckNvbG9yXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+XG48ZGl2ICpuZ0lmPVwiaW5kZXRlcm1pbmF0ZVwiIGNsYXNzPVwicHJvZ3Jlc3NiYXItdHJhY2sgaW5kZXRlcm1pbmF0ZVwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiYmFyQ29sb3JcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyQ29tcG9uZW50IHtcbiAgICBASW5wdXQoKSB2YWx1ZTogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBtYXg6IG51bWJlciA9IDEwMDtcbiAgICBASW5wdXQoKSBpbmRldGVybWluYXRlOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgdHJhY2tDb2xvcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGJhckNvbG9yOiBzdHJpbmc7XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgUHJvZ3Jlc3NCYXJDb21wb25lbnQgfSBmcm9tICcuL3Byb2dyZXNzLWJhci5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbUHJvZ3Jlc3NCYXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1Byb2dyZXNzQmFyQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0Jhck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBSQURJT0JVVFRPTl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxubGV0IHVuaXF1ZVJhZGlvSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXJhZGlvLWJ1dHRvbicsXG4gICAgdGVtcGxhdGU6IGA8bGFiZWwgW2F0dHIuZm9yXT1cImlucHV0SWRcIiBjbGFzcz1cInV4LXJhZGlvLWJ1dHRvblwiXG4gICAgICAgW2NsYXNzLnV4LXJhZGlvLWJ1dHRvbi1jaGVja2VkXT1cInZhbHVlID09PSBvcHRpb25cIlxuICAgICAgIFtjbGFzcy51eC1yYWRpby1idXR0b24tc2ltcGxpZmllZF09XCJzaW1wbGlmaWVkXCJcbiAgICAgICBbY2xhc3MudXgtcmFkaW8tYnV0dG9uLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbY2xhc3MudXgtcmFkaW8tYnV0dG9uLWZvY3VzZWRdPVwiZm9jdXNlZFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXJhZGlvLWJ1dHRvbi1jb250YWluZXJcIj5cbiAgICAgICAgPGlucHV0IGNsYXNzPVwidXgtcmFkaW8tYnV0dG9uLWlucHV0XCJcbiAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICBbaWRdPVwiaW5wdXRJZFwiXG4gICAgICAgICAgICBbY2hlY2tlZF09XCJ2YWx1ZSA9PT0gb3B0aW9uXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiaW5kZXggfHwgdmFsdWUgPT09IG9wdGlvbiA/IDAgOiAtMVwiXG4gICAgICAgICAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgW3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XT1cImFyaWFEZXNjcmliZWRieVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWNoZWNrZWRdPVwidmFsdWUgPT09IG9wdGlvblwiXG4gICAgICAgICAgICAoZm9jdXMpPVwiZm9jdXNlZCA9IHRydWVcIlxuICAgICAgICAgICAgKGJsdXIpPVwiZm9jdXNlZCA9IGZhbHNlXCJcbiAgICAgICAgICAgIChjaGFuZ2UpPVwidG9nZ2xlKClcIlxuICAgICAgICAgICAgKGNsaWNrKT1cIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiPlxuICAgIDwvZGl2PlxuXG4gICAgPHNwYW4gY2xhc3M9XCJ1eC1yYWRpby1idXR0b24tbGFiZWxcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvc3Bhbj5cblxuPC9sYWJlbD5gLFxuICAgIHByb3ZpZGVyczogW1JBRElPQlVUVE9OX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBSYWRpb0J1dHRvbkNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIHByaXZhdGUgX3JhZGlvQnV0dG9uSWQ6IHN0cmluZyA9IGB1eC1yYWRpby1idXR0b24tJHsrK3VuaXF1ZVJhZGlvSWR9YDtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl9yYWRpb0J1dHRvbklkO1xuICAgIEBJbnB1dCgpIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgY2xpY2thYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNpbXBsaWZpZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBvcHRpb246IGFueTtcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWwnKSBhcmlhTGFiZWw6IHN0cmluZyA9ICcnO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JykgYXJpYUxhYmVsbGVkYnk6IHN0cmluZyA9IG51bGw7XG4gICAgQElucHV0KCdhcmlhLWRlc2NyaWJlZGJ5JykgYXJpYURlc2NyaWJlZGJ5OiBzdHJpbmcgPSBudWxsO1xuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICBzZXQgdmFsdWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBpbnZva2UgY2hhbmdlIGV2ZW50XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLl92YWx1ZSk7XG5cbiAgICAgICAgLy8gY2FsbCBjYWxsYmFja1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7ICAgICAgICBcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRJZCgpOiBzdHJpbmcgeyBcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fcmFkaW9CdXR0b25JZH0taW5wdXRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnkgPSBmYWxzZTtcblxuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9nZ2xlIHRoZSBjaGVja2VkIHN0YXRlXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbjtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbnMgcmVxdWlyZWQgdG8gdXBkYXRlIG5nLW1vZGVsXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBSYWRpb0J1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vcmFkaW9idXR0b24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbRm9ybXNNb2R1bGVdLFxuICAgIGV4cG9ydHM6IFtSYWRpb0J1dHRvbkNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbUmFkaW9CdXR0b25Db21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb21wb25lbnQtZGVmaW5pdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclF1ZXJ5IH0gZnJvbSAnLi9pbnRlcmZhY2VzL3F1ZXJ5LmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyU2VydmljZSB7XG5cbiAgcXVlcnk6IFNlYXJjaEJ1aWxkZXJRdWVyeSA9IHt9O1xuICBxdWVyeUNoYW5nZTogU3ViamVjdDxTZWFyY2hCdWlsZGVyUXVlcnk+ID0gbmV3IFN1YmplY3Q8U2VhcmNoQnVpbGRlclF1ZXJ5PigpO1xuICB2YWxpZGF0aW9uQ2hhbmdlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRydWUpO1xuXG4gIHByaXZhdGUgX2NvbXBvbmVudElkOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9jb21wb25lbnRzOiBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbltdID0gW107XG4gIHByaXZhdGUgX3ZhbGlkYXRpb246IHsgW2tleTogbnVtYmVyXTogYm9vbGVhbiB9ID0ge307XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNvbXBvbmVudCB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjb21wb25lbnRzXG4gICAqL1xuICByZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQ6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uKTogdm9pZCB7XG5cbiAgICAvLyBlbnN1cmUgdGhlcmUgYXJlIG5vIGNvbXBvbmVudHMgd2l0aCBhIG1hdGNoaW5nIG5hbWVcbiAgICBpZiAodGhpcy5fY29tcG9uZW50cy5maW5kKGNtcCA9PiBjbXAubmFtZSA9PT0gY29tcG9uZW50Lm5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlYXJjaCBidWlsZGVyIGNvbXBvbmVudHMgbXVzdCBoYXZlIGEgdW5pcXVlIG5hbWUuIFRoZSBuYW1lICR7Y29tcG9uZW50Lm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5gKTtcbiAgICB9XG5cbiAgICAvLyBpZiB1bmlxdWUgdGhlbiBhZGQgdGhlIGNvbXBvbmVudCB0byB0aGUgbGlzdFxuICAgIHRoaXMuX2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1bGsgcmVnaXN0cmF0aW9uIG9mIGNvbXBvbmVudHNcbiAgICogKEp1c3QgYSBoZWxwZXIgbWV0aG9kKVxuICAgKi9cbiAgcmVnaXN0ZXJDb21wb25lbnRzKGNvbXBvbmVudHM6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uW10pOiB2b2lkIHtcbiAgICBjb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHRoaXMucmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVnaXN0ZXJlZCBjb21wb25lbnQgY2xhc3NcbiAgICovXG4gIGdldENvbXBvbmVudChuYW1lOiBzdHJpbmcpOiBhbnkge1xuXG4gICAgLy8gZmluZCB0aGUgY29tcG9uZW50XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5fY29tcG9uZW50cy5maW5kKGNtcCA9PiBjbXAubmFtZSA9PT0gbmFtZSk7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBtYXRjaCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzZWFyY2ggYnVpbGQgY29tcG9uZW50IHdpdGggdGhlIG5hbWUgJHtuYW1lfSBleGlzdHNgKTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgY29uZmlnIGlzIGRlZmluZWQgLSBhdCBsZWFzdCB0byBhbiBlbXB0eSBvYmplY3RcbiAgICBjb21wb25lbnQuY29uZmlnID0gY29tcG9uZW50LmNvbmZpZyB8fCB7fTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBpbnRlcm5hbCBzZWFyY2ggcXVlcnkgc3RhdGVcbiAgICogbm90ZSB0aGF0IHRoZSBxdWVyeSB3aWxsIGJlIGltbXV0YWJsZVxuICAgKi9cbiAgc2V0UXVlcnkocXVlcnk6IFNlYXJjaEJ1aWxkZXJRdWVyeSk6IHZvaWQge1xuICAgIHRoaXMucXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBxdWVyeSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHF1ZXJ5IHN0YXRlXG4gICAqL1xuICBnZXRRdWVyeSgpOiBTZWFyY2hCdWlsZGVyUXVlcnkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIG9ic2VydmFibGUgdG8gaW5kaWNhdGUgdGhlIHF1ZXJ5IGhhcyBiZWVuIHVwZGF0ZWRcbiAgICovXG4gIHF1ZXJ5SGFzQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXJ5Q2hhbmdlLm5leHQodGhpcy5xdWVyeSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgdGhlIHZhbGlkYXRpb24gc3RhdGUgb2YgdGhlIHF1ZXJ5XG4gICAqL1xuICBzZXRWYWxpZChpZDogbnVtYmVyLCB2YWxpZDogYm9vbGVhbik6IHZvaWQge1xuXG4gICAgLy8gc3RvcmUgdGhlIHN0YXRlIGZvciB0aGlzIHNwZWNpZmljIGNvbXBvbmVudFxuICAgIHRoaXMuX3ZhbGlkYXRpb25baWRdID0gdmFsaWQ7XG5cbiAgICAvLyBldmFsdWF0ZSB0aGUgZW50aXJlIHZhbGlkYXRpb24gc3RhdGVcbiAgICB0aGlzLnZhbGlkYXRpb25DaGFuZ2UubmV4dCghT2JqZWN0LmtleXModGhpcy5fdmFsaWRhdGlvbikuc29tZShrZXkgPT4gIXRoaXMuX3ZhbGlkYXRpb25ba2V5XSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdW5pcXVlIGlkIGZvciBlYWNoIGNvbXBvbmVudFxuICAgKi9cbiAgZ2VuZXJhdGVDb21wb25lbnRJZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRJZCsrO1xuICB9XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3JvdXAtcXVlcnkuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlIHtcblxuICBwcml2YXRlIF9pZDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSkgeyB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgdGhlIGdyb3VwIGJ5IGRlZmluaW5nIGFuIGlkXG4gICAqL1xuICBpbml0KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBzdG9yZSB0aGUgbmFtZSBvZiB0aGUgZ3JvdXBcbiAgICB0aGlzLl9pZCA9IGlkO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBlbnRyeSBpbiB0aGUgcXVlcnkgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIXRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5W3RoaXMuX2lkXSkge1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIHNlY3Rpb25cbiAgICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5W3RoaXMuX2lkXSA9IFtdO1xuXG4gICAgICAvLyBlbWl0IHRoZSBjaGFuZ2VzIGFmdGVyIHRoZSBpbml0aWFsIHNldHVwXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5SGFzQ2hhbmdlZCgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgZmllbGQgZnJvbSB0aGUgc2VhcmNoIGJ1aWxkZXIgcXVlcnlcbiAgICovXG4gIHJlbW92ZShmaWVsZDogU2VhcmNoQnVpbGRlckdyb3VwUXVlcnkpOiB2b2lkIHtcbiAgICAvLyBnZXQgdGhlIHF1ZXJ5IGZvciB0aGlzIGdyb3VwXG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLmdldFF1ZXJ5KCk7XG5cbiAgICAvLyByZW1vdmUgdGhlIGZpZWxkIGZyb20gdGhlIGFycmF5XG4gICAgcXVlcnkuc3BsaWNlKHF1ZXJ5LmluZGV4T2YoZmllbGQpLCAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1ZXJ5IGZvciB0aGlzIHNwZWNpZmljIHNlYXJjaCBncm91cFxuICAgKi9cbiAgZ2V0UXVlcnkoKTogU2VhcmNoQnVpbGRlckdyb3VwUXVlcnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5W3RoaXMuX2lkXSA/IHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5W3RoaXMuX2lkXSA6IFtdO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZSB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXItZ3JvdXAuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckdyb3VwUXVlcnkgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2dyb3VwLXF1ZXJ5LmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXNlYXJjaC1idWlsZGVyLWdyb3VwJyxcbiAgdGVtcGxhdGU6IGA8aDQgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtdGl0bGVcIj57eyBoZWFkZXIgfX08L2g0PlxuXG48bWFpbiBjbGFzcz1cInNlYXJjaC1ncm91cC1jb250ZW50XCI+XG5cbiAgPHNlY3Rpb24gY2xhc3M9XCJzZWFyY2gtZ3JvdXAtb3BlcmF0b3Igc2VhcmNoLWdyb3VwLW9wZXJhdG9yLXt7IG9wZXJhdG9yIH19XCIgW2NsYXNzLmhpZGRlbi1vcGVyYXRvcl09XCJzZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlLmdldFF1ZXJ5KCkubGVuZ3RoIDwgMlwiPnt7IG9wZXJhdG9yIH19PC9zZWN0aW9uPlxuXG4gIDxzZWN0aW9uIGNsYXNzPVwic2VhcmNoLWdyb3VwLWl0ZW1zXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwic2VhcmNoLWdyb3VwLWl0ZW0tY29udGFpbmVyXCIgKm5nRm9yPVwibGV0IGZpZWxkIG9mIHNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UuZ2V0UXVlcnkoKVwiPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwic2VhcmNoLWdyb3VwLWl0ZW1cIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqdXhTZWFyY2hCdWlsZGVyT3V0bGV0PVwiZmllbGQudHlwZTsgY29udGV4dDogZmllbGRcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwic2VhcmNoLWdyb3VwLWl0ZW0tcmVtb3ZlXCIgKGNsaWNrKT1cInJlbW92ZUZpZWxkKGZpZWxkKVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1jbG9zZVwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBQbGFjZWhvbGRlciBJdGVtIC0tPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJzaG93UGxhY2Vob2xkZXJcIj5cblxuICAgICAgPCEtLSBUaGUgRGVmYXVsdCBQbGFjZWhvbGRlciAtLT5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbS1jb250YWluZXIgcGxhY2Vob2xkZXItaXRlbVwiICpuZ0lmPVwiIXBsYWNlaG9sZGVyXCI+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VhcmNoLWdyb3VwLWl0ZW1cIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCI+TmV3IGZpZWxkPC9sYWJlbD5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jb250cm9sXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICBcbiAgICAgIDwvZGl2PlxuXG4gICAgICA8IS0tIEFsbG93IGEgY3VzdG9tIHBsYWNlaG9sZGVyIC0tPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwbGFjZWhvbGRlclwiPjwvbmctY29udGFpbmVyPlxuXG4gICAgPC9uZy1jb250YWluZXI+XG5cbiAgPC9zZWN0aW9uPlxuXG4gIDxzZWN0aW9uIGNsYXNzPVwic2VhcmNoLWJ1aWxkZXItZ3JvdXAtYWRkLWZpZWxkXCIgKGNsaWNrKT1cImFkZC5lbWl0KCRldmVudClcIj5cblxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1pY29uIGJ0bi1jaXJjdWxhciBidXR0b24tYWNjZW50XCIgYXJpYS1sYWJlbD1cIkFkZCBGaWVsZFwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtYWRkXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuXG4gICAgPHNwYW4gY2xhc3M9XCJzZWFyY2gtYnVpbGRlci1ncm91cC1hZGQtZmllbGQtbGFiZWxcIj57eyBhZGRUZXh0IH19PC9zcGFuPlxuXG4gIDwvc2VjdGlvbj5cblxuPC9tYWluPlxuXG48aHIgY2xhc3M9XCJzZWFyY2gtYnVpbGRlci1ncm91cC1kaXZpZGVyXCI+XG5gLFxuICBwcm92aWRlcnM6IFtTZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyR3JvdXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIEBJbnB1dCgpIGlkOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICBASW5wdXQoKSBvcGVyYXRvcjogU2VhcmNoQnVpbGRlckdyb3VwT3BlcmF0b3IgPSAnYW5kJztcbiAgQElucHV0KCkgYWRkVGV4dDogc3RyaW5nID0gJ0FkZCBhIGZpZWxkJztcbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBJbnB1dCgpIHNob3dQbGFjZWhvbGRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoKSBhZGQ6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcbiAgQE91dHB1dCgpIHJlbW92ZTogRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5PiA9IG5ldyBFdmVudEVtaXR0ZXI8U2VhcmNoQnVpbGRlckdyb3VwUXVlcnk+KCk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UsIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSkgeyB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBlbnN1cmUgd2UgaGF2ZSBhIG5hbWUgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yXG4gICAgaWYgKCF0aGlzLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlYXJjaCBidWlsZGVyIGdyb3VwIG11c3QgaGF2ZSBhIG5hbWUgYXR0cmlidXRlLicpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSByZWdpc3RlciB0aGUgZ3JvdXBcbiAgICB0aGlzLnNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UuaW5pdCh0aGlzLmlkKTtcbiAgfVxuXG4gIHJlbW92ZUZpZWxkKGZpZWxkOiBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSk6IHZvaWQge1xuICAgIHRoaXMuc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZS5yZW1vdmUoZmllbGQpO1xuICAgIHRoaXMucmVtb3ZlLmVtaXQoZmllbGQpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFNlYXJjaEJ1aWxkZXJHcm91cE9wZXJhdG9yID0gJ2FuZCcgfCAnb3InIHwgJ25vdCc7XG4iLCJpbXBvcnQgeyBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgRGlyZWN0aXZlLCBJbnB1dCwgT25Jbml0LCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFNlYXJjaEJ1aWxkZXJPdXRsZXRdJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyT3V0bGV0RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIEBJbnB1dCgpIHV4U2VhcmNoQnVpbGRlck91dGxldDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHV4U2VhcmNoQnVpbGRlck91dGxldENvbnRleHQ6IGFueTtcblxuICAgIHByaXZhdGUgX2NvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPGFueT47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJpdmF0ZSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZVxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGNsYXNzIGZyb20gdGhlIHR5cGVcbiAgICAgICAgY29uc3QgY29tcG9uZW50RGVmaW5pdGlvbiA9IHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLmdldENvbXBvbmVudCh0aGlzLnV4U2VhcmNoQnVpbGRlck91dGxldCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjb21wb25lbnQgZmFjdG9yeVxuICAgICAgICBjb25zdCBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudERlZmluaXRpb24uY29tcG9uZW50KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5KTtcblxuICAgICAgICAvLyBjb21iaW5lIHRoZSBwcmVkZWZpbmVkIGNvbmZpZyB3aXRoIGFueSBkeW5tYWljIGNvbmZpZ1xuICAgICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb21wb25lbnREZWZpbml0aW9uLmNvbmZpZywgdGhpcy51eFNlYXJjaEJ1aWxkZXJPdXRsZXRDb250ZXh0LmNvbmZpZyB8fCB7fSk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBjb250ZXh0IGFuZCBjb25maWcgcHJvcGVydHkgb24gdGhlIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2UuY29udGV4dCA9IHRoaXMudXhTZWFyY2hCdWlsZGVyT3V0bGV0Q29udGV4dDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckNvbXBvbmVudENvbnRleHQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbXBvbmVudC1jb250ZXh0LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXItZ3JvdXAvc2VhcmNoLWJ1aWxkZXItZ3JvdXAuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWJhc2Utc2VhcmNoJyxcbiAgICB0ZW1wbGF0ZTogJydcbn0pXG5leHBvcnQgY2xhc3MgQmFzZVNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgY29uZmlnOiBhbnk7XG4gICAgY29udGV4dDogU2VhcmNoQnVpbGRlckNvbXBvbmVudENvbnRleHQ7XG5cbiAgICBwcml2YXRlIF9pZDogbnVtYmVyID0gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UuZ2VuZXJhdGVDb21wb25lbnRJZCgpO1xuICAgIHByaXZhdGUgX3ZhbGlkOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5SGFzQ2hhbmdlZCgpO1xuXG4gICAgICAgIC8vIGlmIHZhbHVlIGhhcyBiZWVuIHNldCBwZXJmb3JtIHZhbGlkYXRpb25cbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCB2YWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgIH1cblxuICAgIHNldCB2YWxpZCh2YWxpZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWxpZCA9IHZhbGlkO1xuICAgICAgICB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5zZXRWYWxpZCh0aGlzLl9pZCwgdmFsaWQpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9zZWFyY2hCdWlsZGVyU2VydmljZTogU2VhcmNoQnVpbGRlclNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHdlIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlc1xuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFueSByZXF1aXJlZCB2YWxpZGF0aW9uIG9uIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIHZhbGlkYXRlKCk6IHZvaWQge1xuICAgICAgICAvLyBpZiBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGhhcyBiZWVuIHByb3ZpZGVkIHRoZW4gdXNlIGl0XG4gICAgICAgIHRoaXMudmFsaWQgPSB0aGlzLmNvbmZpZy52YWxpZGF0aW9uID8gdGhpcy5jb25maWcudmFsaWRhdGlvbih0aGlzLCB0aGlzLnZhbHVlKSA6IHRydWU7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgdmFsaWRhdGlvbj86ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCwgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB9IGZyb20gJy4uL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXNlYXJjaC10ZXh0JyxcbiAgdGVtcGxhdGU6IGA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCIgKm5nSWY9XCJsYWJlbFwiPnt7IGxhYmVsIH19PC9sYWJlbD5cbjxpbnB1dCBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIiBbKG5nTW9kZWwpXT1cInZhbHVlXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIj5gXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFRleHRDb21wb25lbnQgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50IHtcblxuICB0eXBlOiBzdHJpbmcgPSAndGV4dCc7XG5cbiAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxhYmVsO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICdFbnRlciB0ZXh0JztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaFRleHRDb25maWcgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLWRhdGUnLFxuICB0ZW1wbGF0ZTogYDxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWxcIiAqbmdJZj1cImxhYmVsXCI+e3sgbGFiZWwgfX08L2xhYmVsPlxuXG48ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgZGF0ZSBtLW5pbFwiPlxuICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiB0YWJpbmRleD1cIjFcIiAoY2xpY2spPVwicG9wb3Zlci5zaG93KClcIj5cbiAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtY2FsZW5kYXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgPC9zcGFuPlxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiICNwb3BvdmVyPVwidXgtcG9wb3ZlclwiIFtuZ01vZGVsXT1cInZhbHVlIHwgZGF0ZTonZGQgTU1NTSB5eXl5J1wiIFt1eFBvcG92ZXJdPVwicG9wb3ZlclRlbXBsYXRlXCJcbiAgICAgICAgcGxhY2VtZW50PVwiYm90dG9tXCIgcG9wb3ZlckNsYXNzPVwiZGF0ZS10aW1lLXBpY2tlci1wb3BvdmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBhcmlhLWxhYmVsPVwiU2VsZWN0ZWQgZGF0ZVwiIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiPlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjcG9wb3ZlclRlbXBsYXRlPlxuICAgIDx1eC1kYXRlLXRpbWUtcGlja2VyIFsoZGF0ZSldPVwidmFsdWVcIiBbc2hvd1RpbWVdPVwiZmFsc2VcIj48L3V4LWRhdGUtdGltZS1waWNrZXI+XG48L25nLXRlbXBsYXRlPmBcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoRGF0ZUNvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICdkYXRlJztcblxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgJ0VudGVyIGRhdGUnO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBieSBkZWZhdWx0IHNldCB0byB0aGUgY3VycmVudCBkYXRlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaERhdGVDb25maWcgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2VhcmNoLWRhdGUtcmFuZ2UnLFxuICAgIHRlbXBsYXRlOiBgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbFwiICpuZ0lmPVwibGFiZWxcIj57eyBsYWJlbCB9fTwvbGFiZWw+XG5cbjxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWlubGluZVwiIFtjbGFzcy5oYXMtZXJyb3JdPVwiIXZhbGlkXCI+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHAtci1tZFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWwgbS1yLXhzXCI+e3sgZnJvbUxhYmVsIH19PC9sYWJlbD5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBkYXRlIG0tbmlsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gcC1yLXhzXCIgdGFiaW5kZXg9XCIxXCIgKGNsaWNrKT1cImZyb21Qb3BvdmVyLnNob3coKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtY2FsZW5kYXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgI2Zyb21Qb3BvdmVyPVwidXgtcG9wb3ZlclwiIFtuZ01vZGVsXT1cImZyb20gfCBkYXRlOidkZCBNTU1NIHl5eXknXCIgW3V4UG9wb3Zlcl09XCJmcm9tUG9wb3ZlclRlbXBsYXRlXCIgcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcG92ZXJDbGFzcz1cImRhdGUtdGltZS1waWNrZXItcG9wb3ZlclwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgYXJpYS1sYWJlbD1cIlNlbGVjdGVkIGRhdGVcIiBbcGxhY2Vob2xkZXJdPVwiZnJvbVBsYWNlaG9sZGVyXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcC1yLXhzXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbCBtLXIteHNcIj57eyB0b0xhYmVsIH19PC9sYWJlbD5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBkYXRlIG0tbmlsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiB0YWJpbmRleD1cIjFcIiAoY2xpY2spPVwidG9Qb3BvdmVyLnNob3coKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtY2FsZW5kYXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgI3RvUG9wb3Zlcj1cInV4LXBvcG92ZXJcIiBbbmdNb2RlbF09XCJ0byB8IGRhdGU6J2RkIE1NTU0geXl5eSdcIiBbdXhQb3BvdmVyXT1cInRvUG9wb3ZlclRlbXBsYXRlXCIgcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcG92ZXJDbGFzcz1cImRhdGUtdGltZS1waWNrZXItcG9wb3ZlclwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgYXJpYS1sYWJlbD1cIlNlbGVjdGVkIGRhdGVcIiBbcGxhY2Vob2xkZXJdPVwidG9QbGFjZWhvbGRlclwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNmcm9tUG9wb3ZlclRlbXBsYXRlPlxuICAgIDx1eC1kYXRlLXRpbWUtcGlja2VyIFsoZGF0ZSldPVwiZnJvbVwiIFtzaG93VGltZV09XCJmYWxzZVwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlcj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjdG9Qb3BvdmVyVGVtcGxhdGU+XG4gICAgPHV4LWRhdGUtdGltZS1waWNrZXIgWyhkYXRlKV09XCJ0b1wiIFtzaG93VGltZV09XCJmYWxzZVwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlcj5cbjwvbmctdGVtcGxhdGU+YFxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50IHtcblxuICAgIHR5cGU6IHN0cmluZyA9ICdkYXRlLXJhbmdlJztcblxuICAgIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gICAgfVxuXG4gICAgZ2V0IGZyb20oKSB7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgZG9lcyBub3QgZXhpc3QgdGhlIHNldCBpdFxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBmcm9tIHZhbHVlIGlzIGEgZGF0ZSBvYmplY3RcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuZnJvbSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmZyb20gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLmZyb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZnJvbTtcbiAgICB9XG5cbiAgICBzZXQgZnJvbShmcm9tVmFsdWU6IGFueSkge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGZyb20gdmFsdWUgaXMgYSBkYXRlXG4gICAgICAgIGlmIChmcm9tVmFsdWUgaW5zdGFuY2VvZiBEYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gbmV3IERhdGUoZnJvbVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICAgIHZhbHVlLmZyb20gPSBmcm9tVmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvYmplY3Qgd2hpbGUgZW5zdXJpbmcgaW1tdXRhYmlsaXR5XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdG8oKSB7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgZG9lcyBub3QgZXhpc3QgdGhlIHNldCBpdFxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUudG8pIHtcbiAgICAgICAgICAgIHRoaXMudG8gPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRvIHZhbHVlIGlzIGEgZGF0ZSBvYmplY3RcbiAgICAgICAgaWYgKHRoaXMudmFsdWUudG8gaW5zdGFuY2VvZiBEYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS50byA9IG5ldyBEYXRlKHRoaXMudmFsdWUudG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG87XG4gICAgfVxuXG4gICAgc2V0IHRvKHRvVmFsdWU6IGFueSkge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRvIHZhbHVlIGlzIGEgZGF0ZVxuICAgICAgICBpZiAodG9WYWx1ZSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1ZhbHVlID0gbmV3IERhdGUodG9WYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGxhdGVzdCB2YWx1ZVxuICAgICAgICB2YWx1ZS50byA9IHRvVmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvYmplY3Qgd2hpbGUgZW5zdXJpbmcgaW1tdXRhYmlsaXR5XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZnJvbUxhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5mcm9tTGFiZWwgfHwgJ0Zyb20nO1xuICAgIH1cblxuICAgIGdldCB0b0xhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50b0xhYmVsIHx8ICdUbyc7XG4gICAgfVxuXG4gICAgZ2V0IGZyb21QbGFjZWhvbGRlcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZnJvbVBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIGdldCB0b1BsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50b1BsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbmZpZyB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudmFsaWRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBjb3BpZXMgb2YgdGhlIGRhdGVzIHNvIHdlIGNhbiBtb2RpZnkgdGltZSB2YWx1ZSAodG8gaWdub3JlIGl0KVxuICAgICAgICBjb25zdCBmcm9tID0gbmV3IERhdGUodGhpcy52YWx1ZS5mcm9tKTtcbiAgICAgICAgY29uc3QgdG8gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLnRvKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHRpbWUgdG8gdGhlIHNhbWUgc28gd2UgZG9udCBjb21wYXJlIGl0XG4gICAgICAgIGZyb20uc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHRvLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgICAgIC8vIHZhbGlkIGlmIHRoZSBmcm9tIGRhdGUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0byBkYXRlXG4gICAgICAgIHRoaXMudmFsaWQgPSBmcm9tIDw9IHRvO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hEYXRlUmFuZ2VDb25maWcge1xuICAgIGxhYmVsPzogc3RyaW5nO1xuICAgIGZyb21MYWJlbD86IHN0cmluZztcbiAgICB0b0xhYmVsPzogc3RyaW5nO1xuICAgIGZyb21QbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICB0b1BsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIHZhbGlkYXRpb246ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCwgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB9IGZyb20gJy4uL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL2luZGV4JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLXNlbGVjdCcsXG4gIHRlbXBsYXRlOiBgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbFwiICpuZ0lmPVwibGFiZWxcIj57eyBsYWJlbCB9fTwvbGFiZWw+XG5cbjx1eC1zZWxlY3QgWyh2YWx1ZSldPVwidmFsdWVcIiBcbiAgICAgICAgICAgW29wdGlvbnNdPVwib3B0aW9uc1wiIFxuICAgICAgICAgICBbbXVsdGlwbGVdPVwibXVsdGlwbGVcIiBcbiAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCIgXG4gICAgICAgICAgIFtkcm9wRGlyZWN0aW9uXT1cImRyb3BEaXJlY3Rpb25cIlxuICAgICAgICAgICBbcGFnZVNpemVdPVwicGFnZVNpemVcIlxuICAgICAgICAgICBbYWxsb3dOdWxsXT1cImFsbG93TnVsbFwiXG4gICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgIFttYXhIZWlnaHRdPVwibWF4SGVpZ2h0XCJcbiAgICAgICAgICAgW2tleV09XCJjb25maWcua2V5XCJcbiAgICAgICAgICAgW2Rpc3BsYXldPVwiY29uZmlnLmRpc3BsYXlcIlxuICAgICAgICAgICBbbG9hZGluZ1RlbXBsYXRlXT1cImNvbmZpZy5sb2FkaW5nVGVtcGxhdGVcIlxuICAgICAgICAgICBbb3B0aW9uVGVtcGxhdGVdPVwiY29uZmlnLm9wdGlvblRlbXBsYXRlXCJcbiAgICAgICAgICAgW25vT3B0aW9uc1RlbXBsYXRlXT1cImNvbmZpZy5ub09wdGlvbnNUZW1wbGF0ZVwiPlxuPC91eC1zZWxlY3Q+YFxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hTZWxlY3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50IHtcblxuICB0eXBlOiBzdHJpbmcgPSAnc2VsZWN0JztcblxuICAvKipcbiAgICogUHJvdmlkZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIHByb3BlcnRpZXNcbiAgICovXG4gIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5sYWJlbDtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5vcHRpb25zIHx8IFtdO1xuICB9XG5cbiAgZ2V0IG11bHRpcGxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5tdWx0aXBsZSB8fCBmYWxzZTtcbiAgfVxuXG4gIGdldCBwbGFjZWhvbGRlcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciB8fCAnU2VsZWN0IGl0ZW0nO1xuICB9XG5cbiAgZ2V0IGRyb3BEaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZHJvcERpcmVjdGlvbiB8fCAnZG93bic7XG4gIH1cblxuICBnZXQgYWxsb3dOdWxsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5hbGxvd051bGwgfHwgZmFsc2U7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRpc2FibGVkIHx8IGZhbHNlO1xuICB9XG5cbiAgZ2V0IG1heEhlaWdodCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXhIZWlnaHQgfHwgJzI1MHB4JztcbiAgfVxuXG4gIGdldCBwYWdlU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wYWdlU2l6ZSB8fCAyMDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaFNlbGVjdENvbmZpZyBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcge1xuICBvcHRpb25zPzogYW55W10gfCBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcbiAgbXVsdGlwbGU/OiBib29sZWFuO1xuICBkcm9wRGlyZWN0aW9uPzogJ3VwJyB8ICdkb3duJztcbiAgYWxsb3dOdWxsPzogYm9vbGVhbjtcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICBtYXhIZWlnaHQ/OiBzdHJpbmc7XG4gIHBhZ2VTaXplPzogbnVtYmVyO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb24gfSBmcm9tICcuL2ludGVyZmFjZXMvY29tcG9uZW50LWRlZmluaXRpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJRdWVyeSB9IGZyb20gJy4vaW50ZXJmYWNlcy9xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtYnVpbGRlcicsXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmAsXG4gIHByb3ZpZGVyczogW1NlYXJjaEJ1aWxkZXJTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBASW5wdXQoKVxuICBzZXQgY29tcG9uZW50cyhjb21wb25lbnRzOiBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbltdKSB7XG4gICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucmVnaXN0ZXJDb21wb25lbnRzKGNvbXBvbmVudHMpO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IHF1ZXJ5KHZhbHVlOiBTZWFyY2hCdWlsZGVyUXVlcnkpIHtcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5zZXRRdWVyeSh2YWx1ZSk7XG4gIH1cblxuICBnZXQgcXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLmdldFF1ZXJ5KCk7XG4gIH1cblxuICBAT3V0cHV0KCkgcXVlcnlDaGFuZ2U6IEV2ZW50RW1pdHRlcjxTZWFyY2hCdWlsZGVyUXVlcnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxTZWFyY2hCdWlsZGVyUXVlcnk+KCk7XG4gIEBPdXRwdXQoKSB2YWxpZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBwcml2YXRlIF9xdWVyeVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIF92YWxpZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB0aGUgZGVmYXVsdCBzZWFyY2ggYnVpbGRlciBjb21wb25lbnRzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWFyY2hCdWlsZGVyU2VydmljZTogU2VhcmNoQnVpbGRlclNlcnZpY2UpIHtcblxuICAgIC8vIHdhdGNoIGZvciBhbnkgcXVlcnkgY2hhbmdlc1xuICAgIHRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uID0gX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5Q2hhbmdlLnN1YnNjcmliZShxdWVyeSA9PiB0aGlzLnF1ZXJ5Q2hhbmdlLmVtaXQocXVlcnkpKTtcblxuICAgIC8vIHdhdGNoIGZvciBhbnkgY2hhbmdlcyB0byB0aGUgdmFsaWRhdGlvblxuICAgIHRoaXMuX3ZhbGlkU3Vic2NyaXB0aW9uID0gX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnZhbGlkYXRpb25DaGFuZ2UucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUodmFsaWQgPT4gdGhpcy52YWxpZC5lbWl0KHZhbGlkKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFueSBzdWJzY3JpcHRpb25zIGFuZCBjbGVhbnVwXG4gICAqL1xuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9xdWVyeVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX3ZhbGlkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxufVxuIiwiZXhwb3J0IGNsYXNzIFR5cGVhaGVhZE9wdGlvbkV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgb3B0aW9uOiBhbnkpIHt9XG59IiwiaW1wb3J0IHsgVHlwZWFoZWFkQ29tcG9uZW50IH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUeXBlYWhlYWRLZXlTZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG5cbiAgICBoYW5kbGVLZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIHR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50KSB7XG4gICAgICAgIGlmICh0eXBlYWhlYWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVhaGVhZC5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQubW92ZUhpZ2hsaWdodCgtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlYWhlYWQub3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm1vdmVIaWdobGlnaHQoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFc2MnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZFNlcnZpY2Uge1xyXG5cclxuICAgIG9wZW4kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gICAgaGlnaGxpZ2h0ZWRFbGVtZW50JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SFRNTEVsZW1lbnQ+KG51bGwpO1xyXG59IiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE91dHB1dCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdCc7XHJcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4vdHlwZWFoZWFkLWV2ZW50JztcclxuaW1wb3J0IHsgVHlwZWFoZWFkU2VydmljZSB9IGZyb20gJy4vdHlwZWFoZWFkLnNlcnZpY2UnO1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10eXBlYWhlYWQnLFxyXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidXgtdHlwZWFoZWFkLW9wdGlvbnNcIlxuICAgIFt1eEluZmluaXRlU2Nyb2xsXT1cImxvYWRPcHRpb25zQ2FsbGJhY2tcIlxuICAgIFtjb2xsZWN0aW9uXT1cInZpc2libGVPcHRpb25zJCB8IGFzeW5jXCJcbiAgICAoY29sbGVjdGlvbkNoYW5nZSk9XCJ2aXNpYmxlT3B0aW9ucyQubmV4dCgkZXZlbnQpXCJcbiAgICBbZW5hYmxlZF09XCJpc0luZmluaXRlU2Nyb2xsKClcIlxuICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICBbbG9hZE9uU2Nyb2xsXT1cInRydWVcIlxuICAgIFtwYWdlU2l6ZV09XCJwYWdlU2l6ZVwiXG4gICAgW3Njcm9sbEVsZW1lbnRdPVwidHlwZWFoZWFkRWxlbWVudFwiXG4gICAgKGxvYWRpbmcpPVwibG9hZGluZyA9IHRydWVcIlxuICAgIChsb2FkZWQpPVwibG9hZGluZyA9IGZhbHNlXCI+XG5cbiAgICA8b2wgKm5nSWY9XCIodmlzaWJsZU9wdGlvbnMkIHwgYXN5bmMpLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBvcHRpb24gb2YgKHZpc2libGVPcHRpb25zJCB8IGFzeW5jKTsgbGV0IGkgPSBpbmRleFwiXG4gICAgICAgICAgICBbYXR0ci5pZF09XCJpZCArICctb3B0aW9uLScgKyBpXCJcbiAgICAgICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJpc0Rpc2FibGVkKG9wdGlvbilcIlxuICAgICAgICAgICAgW2NsYXNzLmhpZ2hsaWdodGVkXT1cImhpZ2hsaWdodGVkS2V5ID09PSBvcHRpb24ua2V5XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwibXVsdGlzZWxlY3RhYmxlID8gaXNEaXNhYmxlZChvcHRpb24pIDogbnVsbFwiXG4gICAgICAgICAgICBbdXhUeXBlYWhlYWRIaWdobGlnaHRdPVwiaGlnaGxpZ2h0ZWRLZXkgPT09IG9wdGlvbi5rZXlcIlxuICAgICAgICAgICAgW3V4U2Nyb2xsSW50b1ZpZXdJZl09XCJoaWdobGlnaHRlZEtleSA9PT0gb3B0aW9uLmtleVwiXG4gICAgICAgICAgICBbc2Nyb2xsUGFyZW50XT1cInR5cGVhaGVhZEVsZW1lbnQubmF0aXZlRWxlbWVudFwiXG4gICAgICAgICAgICAobW91c2Vkb3duKT1cIm9wdGlvbk1vdXNlZG93bkhhbmRsZXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAoY2xpY2spPVwib3B0aW9uQ2xpY2tIYW5kbGVyKCRldmVudCwgb3B0aW9uKVwiXG4gICAgICAgICAgICAobW91c2VvdmVyKT1cImhpZ2hsaWdodChvcHRpb24pXCI+XG5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwib3B0aW9uVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7b3B0aW9uOiBvcHRpb24udmFsdWUsIGFwaTogb3B0aW9uQXBpfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPC9saT5cbiAgICA8L29sPlxuXG4gICAgPGRpdiAqdXhJbmZpbml0ZVNjcm9sbExvYWRpbmc+XG4gICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwibG9hZGluZ1RlbXBsYXRlXCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuXG48L2Rpdj5cbjxkaXYgKm5nSWY9XCIodmlzaWJsZU9wdGlvbnMkIHwgYXN5bmMpLmxlbmd0aCA9PT0gMCAmJiAhbG9hZGluZ1wiPlxuICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwibm9PcHRpb25zVGVtcGxhdGVcIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRMb2FkaW5nVGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInV4LXR5cGVhaGVhZC1sb2FkaW5nXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzcGlubmVyIHNwaW5uZXItYWNjZW50IHNwaW5uZXItYm91bmNlLW1pZGRsZVwiPjwvZGl2PlxuICAgICAgICA8ZGl2PkxvYWRpbmcuLi48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdE9wdGlvblRlbXBsYXRlIGxldC1vcHRpb249XCJvcHRpb25cIiBsZXQtYXBpPVwiYXBpXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJ1eC10eXBlYWhlYWQtb3B0aW9uXCIgW2lubmVySHRtbF09XCJhcGkuZ2V0RGlzcGxheUh0bWwob3B0aW9uKVwiPjwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdE5vT3B0aW9uc1RlbXBsYXRlPlxuICAgIDxzcGFuIGNsYXNzPVwidXgtdHlwZWFoZWFkLW5vLW9wdGlvbnNcIj5ObyByZXN1bHRzPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5gLFxyXG4gICAgcHJvdmlkZXJzOiBbVHlwZWFoZWFkU2VydmljZV0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ3JvbGUnOiAnbGlzdGJveCcsXHJcbiAgICAgICAgJ1tjbGFzcy5vcGVuXSc6ICdvcGVuJyxcclxuICAgICAgICAnW2NsYXNzLmRyb3AtdXBdJzogJ2Ryb3BEaXJlY3Rpb24gPT09IFwidXBcIicsXHJcbiAgICAgICAgJ1tzdHlsZS5tYXhIZWlnaHRdJzogJ21heEhlaWdodCdcclxuICAgIH1cclxufSlcclxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcclxuXHJcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKSBpZDogc3RyaW5nID0gYHV4LXR5cGVhaGVhZC0keysrdW5pcXVlSWR9YDtcclxuXHJcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xyXG4gICAgQElucHV0KCkgZmlsdGVyOiBzdHJpbmc7XHJcblxyXG4gICAgQElucHV0KCdvcGVuJylcclxuICAgIGdldCBvcGVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlLm9wZW4kLmdldFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBzZXQgb3Blbih2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX3NlcnZpY2Uub3BlbiQubmV4dCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQE91dHB1dCgpIG9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gICAgQElucHV0KCkgZGlzcGxheTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBrZXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkgZGlzYWJsZWRPcHRpb25zOiBhbnlbXTtcclxuICAgIEBJbnB1dCgpIGRyb3BEaXJlY3Rpb246ICd1cCcgfCAnZG93bicgPSAnZG93bic7XHJcbiAgICBASW5wdXQoKSBtYXhIZWlnaHQ6IHN0cmluZyA9ICcyNTBweCc7XHJcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGUnKSBtdWx0aXNlbGVjdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIG9wZW5PbkZpbHRlckNoYW5nZTogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBASW5wdXQoKSBwYWdlU2l6ZTogbnVtYmVyID0gMjA7XHJcbiAgICBASW5wdXQoKSBzZWxlY3RGaXJzdDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgQElucHV0KCkgbG9hZGluZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgQElucHV0KCkgb3B0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBub09wdGlvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgICBAT3V0cHV0KCkgb3B0aW9uU2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFR5cGVhaGVhZE9wdGlvbkV2ZW50PigpO1xyXG5cclxuICAgIEBPdXRwdXQoKSBoaWdobGlnaHRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgQE91dHB1dCgpIGhpZ2hsaWdodGVkRWxlbWVudENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SFRNTEVsZW1lbnQ+KCk7XHJcblxyXG4gICAgQFZpZXdDaGlsZCgnZGVmYXVsdExvYWRpbmdUZW1wbGF0ZScpIHByaXZhdGUgX2RlZmF1bHRMb2FkaW5nVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0T3B0aW9uVGVtcGxhdGUnKSBwcml2YXRlIF9kZWZhdWx0T3B0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0Tm9PcHRpb25zVGVtcGxhdGUnKSBwcml2YXRlIF9kZWZhdWx0Tm9PcHRpb25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gICAgbG9hZE9wdGlvbnNDYWxsYmFjazogSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb247XHJcbiAgICB2aXNpYmxlT3B0aW9ucyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFR5cGVhaGVhZFZpc2libGVPcHRpb25bXT4oW10pO1xyXG4gICAgbG9hZGluZyA9IGZhbHNlO1xyXG4gICAgY2xpY2tpbmcgPSBmYWxzZTtcclxuICAgIGhpZ2hsaWdodGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHlwZWFoZWFkVmlzaWJsZU9wdGlvbj4obnVsbCk7XHJcbiAgICBoaWdobGlnaHRlZEtleTogc3RyaW5nID0gbnVsbDtcclxuXHJcbiAgICBnZXQgaGlnaGxpZ2h0ZWQoKTogYW55IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaGlnaGxpZ2h0ZWQkLmdldFZhbHVlKCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUudmFsdWUgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX29wZW46IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuXHJcbiAgICBvcHRpb25BcGk6IFR5cGVhaGVhZE9wdGlvbkFwaSA9IHtcclxuICAgICAgICBnZXRLZXk6IHRoaXMuZ2V0S2V5LmJpbmQodGhpcyksXHJcbiAgICAgICAgZ2V0RGlzcGxheTogdGhpcy5nZXREaXNwbGF5LmJpbmQodGhpcyksXHJcbiAgICAgICAgZ2V0RGlzcGxheUh0bWw6IHRoaXMuZ2V0RGlzcGxheUh0bWwuYmluZCh0aGlzKVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwdWJsaWMgdHlwZWFoZWFkRWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICBwcml2YXRlIF9jZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgcHJpdmF0ZSBfc2VydmljZTogVHlwZWFoZWFkU2VydmljZVxyXG4gICAgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnNDYWxsYmFjayA9IChwYWdlTnVtOiBudW1iZXIsIHBhZ2VTaXplOiBudW1iZXIsIGZpbHRlcjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayB3aGljaCBtYXkgcmV0dXJuIGFuIGFycmF5IG9yIGEgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5T3JQcm9taXNlID0gdGhpcy5vcHRpb25zKHBhZ2VOdW0sIHBhZ2VTaXplLCBmaWx0ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1hcCB0aGUgcmVzdWx0cyB0byBhbiBhcnJheSBvZiBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhcnJheU9yUHJvbWlzZSkudGhlbihuZXdPcHRpb25zID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld09wdGlvbnMubWFwKChvcHRpb246IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5nZXRLZXkob3B0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5vcGVuJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSgobmV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuQ2hhbmdlLmVtaXQobmV4dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQuc3Vic2NyaWJlKChuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkS2V5ID0gbmV4dCA/IG5leHQua2V5IDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRDaGFuZ2UuZW1pdChuZXh0ID8gbmV4dC52YWx1ZSA6IG51bGwpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXHJcbiAgICAgICAgICAgIGNvbWJpbmVMYXRlc3QodGhpcy5fc2VydmljZS5vcGVuJCwgdGhpcy5fc2VydmljZS5oaWdobGlnaHRlZEVsZW1lbnQkLCB0aGlzLnZpc2libGVPcHRpb25zJClcclxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKFtvcGVuLCBoaWdobGlnaHRlZEVsZW1lbnQsIHZpc2libGVPcHRpb25zXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRFbGVtZW50Q2hhbmdlLmVtaXQob3BlbiAmJiB2aXNpYmxlT3B0aW9ucy5sZW5ndGggPiAwID8gaGlnaGxpZ2h0ZWRFbGVtZW50IDogbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgICAgIC8vIEF0dGFjaCBkZWZhdWx0IGxvYWRpbmcgdGVtcGxhdGVcclxuICAgICAgICBpZiAoIXRoaXMubG9hZGluZ1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1RlbXBsYXRlID0gdGhpcy5fZGVmYXVsdExvYWRpbmdUZW1wbGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCBkZWZhdWx0IG9wdGlvbiB0ZW1wbGF0ZVxyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25UZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvblRlbXBsYXRlID0gdGhpcy5fZGVmYXVsdE9wdGlvblRlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIGRlZmF1bHQgXCJubyByZXN1bHRzXCIgdGVtcGxhdGVcclxuICAgICAgICBpZiAoIXRoaXMubm9PcHRpb25zVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub09wdGlvbnNUZW1wbGF0ZSA9IHRoaXMuX2RlZmF1bHROb09wdGlvbnNUZW1wbGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2NkUmVmLmRldGVjdENoYW5nZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgLy8gT3BlbiB0aGUgZHJvcGRvd24gaWYgdGhlIGZpbHRlciB2YWx1ZSB1cGRhdGVzXHJcbiAgICAgICAgaWYgKGNoYW5nZXMuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5PbkZpbHRlckNoYW5nZSAmJiBjaGFuZ2VzLmZpbHRlci5jdXJyZW50VmFsdWUgJiYgY2hhbmdlcy5maWx0ZXIuY3VycmVudFZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlLWZpbHRlciB2aXNpYmxlT3B0aW9uc1xyXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicpXHJcbiAgICBtb3VzZWRvd25IYW5kbGVyKCkge1xyXG4gICAgICAgIHRoaXMuY2xpY2tpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNldXAnKVxyXG4gICAgbW91c2V1cEhhbmRsZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jbGlja2luZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbk1vdXNlZG93bkhhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICAvLyBXb3JrYXJvdW5kIHRvIHByZXZlbnQgZm9jdXMgY2hhbmdpbmcgd2hlbiBhbiBvcHRpb24gaXMgY2xpY2tlZFxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9uQ2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50LCBvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pIHtcclxuICAgICAgICB0aGlzLnNlbGVjdChvcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGtleSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXRLZXkob3B0aW9uOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5rZXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5KG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5rZXkgPT09ICdzdHJpbmcnICYmIG9wdGlvbiAmJiBvcHRpb24uaGFzT3duUHJvcGVydHkodGhpcy5rZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25bPHN0cmluZz50aGlzLmtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldERpc3BsYXkob3B0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheShvcHRpb246IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheShvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycgJiYgb3B0aW9uICYmIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSh0aGlzLmRpc3BsYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25bPHN0cmluZz50aGlzLmRpc3BsYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uIHdpdGggSFRNTCBtYXJrdXAgYWRkZWQgdG8gaGlnaGxpZ2h0IHRoZSBwYXJ0IHdoaWNoIG1hdGNoZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvblxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5SHRtbChvcHRpb246IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYXlUZXh0ID0gdGhpcy5nZXREaXNwbGF5KG9wdGlvbikucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xyXG4gICAgICAgIGxldCBkaXNwbGF5SHRtbCA9IGRpc3BsYXlUZXh0O1xyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmZpbHRlci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBkaXNwbGF5VGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5maWx0ZXIudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBgPHNwYW4gY2xhc3M9XCJ1eC1maWx0ZXItbWF0Y2hcIj4ke2Rpc3BsYXlUZXh0LnN1YnN0cihtYXRjaEluZGV4LCBsZW5ndGgpfTwvc3Bhbj5gO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheUh0bWwgPSBkaXNwbGF5VGV4dC5zdWJzdHIoMCwgbWF0Y2hJbmRleCkgKyBoaWdobGlnaHQgKyBkaXNwbGF5VGV4dC5zdWJzdHIobWF0Y2hJbmRleCArIGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlIdG1sO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbmZpbml0ZSBzY3JvbGwgY29tcG9uZW50IHNob3VsZCBsb2FkXHJcbiAgICAgKi9cclxuICAgIGlzSW5maW5pdGVTY3JvbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMgPT09ICdmdW5jdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBvcHRpb24sIGVtaXR0aW5nIHRoZSBvcHRpb25TZWxlY3RlZCBldmVudCBhbmQgY2xvc2luZyB0aGUgZHJvcGRvd24uXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdChvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZChvcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uU2VsZWN0ZWQuZW1pdChuZXcgVHlwZWFoZWFkT3B0aW9uRXZlbnQob3B0aW9uLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQobnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb3B0aW9uIGlzIHBhcnQgb2YgdGhlIGRpc2FibGVkT3B0aW9ucyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgaXNEaXNhYmxlZChvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kaXNhYmxlZE9wdGlvbnMuZmluZCgoc2VsZWN0ZWRPcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleShzZWxlY3RlZE9wdGlvbikgPT09IG9wdGlvbi5rZXk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZ2l2ZW4gb3B0aW9uIGFzIHRoZSBjdXJyZW50IGhpZ2hsaWdodGVkIG9wdGlvbiwgYXZhaWxhYmxlIGluIHRoZSBoaWdobGlnaHRlZE9wdGlvbiBwYXJhbWV0ZXIuXHJcbiAgICAgKi9cclxuICAgIGhpZ2hsaWdodChvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZChvcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBoaWdobGlnaHRlZCBvcHRpb24gaW4gdGhlIGxpc3QuIERpc2FibGVkIG9wdGlvbnMgYXJlIHNraXBwZWQuXHJcbiAgICAgKiBAcGFyYW0gZCBWYWx1ZSB0byBiZSBhZGRlZCB0byB0aGUgaW5kZXggb2YgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbiwgaS5lLiAtMSB0byBtb3ZlIGJhY2t3YXJkcywgKzEgdG8gbW92ZSBmb3J3YXJkcy5cclxuICAgICAqL1xyXG4gICAgbW92ZUhpZ2hsaWdodChkOiBudW1iZXIpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IHZpc2libGVPcHRpb25zID0gdGhpcy52aXNpYmxlT3B0aW9ucyQuZ2V0VmFsdWUoKTtcclxuICAgICAgICBjb25zdCBoaWdobGlnaHRJbmRleCA9IHRoaXMuaW5kZXhPZlZpc2libGVPcHRpb24odGhpcy5oaWdobGlnaHRlZCk7XHJcbiAgICAgICAgbGV0IG5ld0luZGV4ID0gaGlnaGxpZ2h0SW5kZXg7XHJcbiAgICAgICAgbGV0IGRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaW5Cb3VuZHMgPSB0cnVlO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIGQ7XHJcbiAgICAgICAgICAgIGluQm91bmRzID0gKG5ld0luZGV4ID49IDAgJiYgbmV3SW5kZXggPCB2aXNpYmxlT3B0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBkaXNhYmxlZCA9IGluQm91bmRzICYmIHRoaXMuaXNEaXNhYmxlZCh2aXNpYmxlT3B0aW9uc1tuZXdJbmRleF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaW5Cb3VuZHMgJiYgZGlzYWJsZWQpO1xyXG5cclxuICAgICAgICBpZiAoIWRpc2FibGVkICYmIGluQm91bmRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQodmlzaWJsZU9wdGlvbnNbbmV3SW5kZXhdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHVwIHRoZSBvcHRpb25zIGJlZm9yZSB0aGUgZHJvcGRvd24gaXMgZGlzcGxheWVkLlxyXG4gICAgICovXHJcbiAgICBpbml0T3B0aW9ucygpIHtcclxuICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBoaWdobGlnaHRcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkJC5uZXh0KG51bGwpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdEZpcnN0KSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBoaWdobGlnaHQgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24uXHJcbiAgICAgICAgICAgIHRoaXMubW92ZUhpZ2hsaWdodCgxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHZpc2libGVPcHRpb25zIGFycmF5IHdpdGggdGhlIGN1cnJlbnQgZmlsdGVyLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVPcHRpb25zKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpc2VkSW5wdXQgPSAodGhpcy5maWx0ZXIgfHwgJycpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVPcHRpb25zID0gdGhpcy5vcHRpb25zXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREaXNwbGF5KG9wdGlvbikudG9Mb3dlckNhc2UoKS5pbmRleE9mKG5vcm1hbGlzZWRJbnB1dCkgPj0gMDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmdldEtleSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZU9wdGlvbnMkLm5leHQodmlzaWJsZU9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbml0T3B0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gb3B0aW9uIGluIHRoZSB2aXNpYmxlT3B0aW9ucyBhcnJheS4gUmV0dXJucyAtMSBpZiB0aGUgb3B0aW9uIGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbmRleE9mVmlzaWJsZU9wdGlvbihvcHRpb246IGFueSk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKG9wdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25LZXkgPSB0aGlzLmdldEtleShvcHRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlT3B0aW9ucyQuZ2V0VmFsdWUoKS5maW5kSW5kZXgoKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwua2V5ID09PSBvcHRpb25LZXk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIEFQSSBhdmFpbGFibGUgdG8gb3B0aW9uIHRlbXBsYXRlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWFoZWFkT3B0aW9uQXBpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVuaXF1ZSBrZXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0S2V5KG9wdGlvbjogYW55KTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5KG9wdGlvbjogYW55KTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uIHdpdGggSFRNTCBtYXJrdXAgYWRkZWQgdG8gaGlnaGxpZ2h0IHRoZSBwYXJ0IHdoaWNoIG1hdGNoZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHZhbHVlLiBPdmVycmlkZSB0aGUgdXgtZmlsdGVyLW1hdGNoIGNsYXNzIGluIENTUyB0byBtb2RpZnkgdGhlIGRlZmF1bHQgYXBwZWFyYW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheUh0bWwob3B0aW9uOiBhbnkpOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWFoZWFkVmlzaWJsZU9wdGlvbiB7XHJcbiAgICB2YWx1ZTogYW55O1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPdXRwdXQsIFJlbmRlcmVyMiwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uXSdcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgndXhJbmZpbml0ZVNjcm9sbExvYWRCdXR0b24nKVxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG4gICAgc2V0IHZpc2libGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSBjb250ZW50IGZvbGxvd3MgdGhlIGVsZW1lbnRSZWYsIHdoaWNoIGlzIGEgY29tbWVudC5cbiAgICAgICAgICAgICAgICBjb25zdCBjbGlja1RhcmdldCA9IHRoaXMuZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKHRoaXMuX3RlbXBsYXRlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKGNsaWNrVGFyZ2V0LCAnY2xpY2snLCB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgbG9hZDogT2JzZXJ2YWJsZTxFdmVudD47XG5cbiAgICBwcml2YXRlIF92aXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfbG9hZCA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHtcblxuICAgICAgICB0aGlzLmxvYWQgPSB0aGlzLl9sb2FkLmFzT2JzZXJ2YWJsZSgpIGFzIE9ic2VydmFibGU8RXZlbnQ+O1xuICAgIH1cblxuICAgIHByaXZhdGUgb25DbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLl9sb2FkLm5leHQoZXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKGVsZW1lbnQ6IGFueSk6IEVsZW1lbnQge1xuICAgICAgICB2YXIgbmV4dCA9IGVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChuZXh0ID0gbmV4dC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEluZmluaXRlU2Nyb2xsTG9hZGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoJ3V4SW5maW5pdGVTY3JvbGxMb2FkaW5nJylcbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfVxuICAgIHNldCB2aXNpYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF92aXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYpIHsgfVxufVxuIiwiXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBRdWVyeUxpc3QsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgYXVkaXRUaW1lLCBjb21iaW5lTGF0ZXN0LCBmaWx0ZXIgYXMgZmlsdGVyT3BlcmF0b3IsIGZpcnN0LCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1sb2FkaW5nLmRpcmVjdGl2ZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SW5maW5pdGVTY3JvbGxdJyxcbiAgICBleHBvcnRBczogJ3V4SW5maW5pdGVTY3JvbGwnXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoJ3V4SW5maW5pdGVTY3JvbGwnKSBsb2FkOiBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcblxuICAgIEBJbnB1dCgnY29sbGVjdGlvbicpIF9jb2xsZWN0aW9uOiBhbnlbXSA9IFtdO1xuICAgIGdldCBjb2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjtcbiAgICB9XG4gICAgc2V0IGNvbGxlY3Rpb24odmFsdWU6IGFueVtdKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IHZhbHVlO1xuICAgIH1cblxuXG4gICAgQElucHV0KCkgc2V0IHNjcm9sbEVsZW1lbnQoZWxlbWVudDogRWxlbWVudFJlZiB8IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudFJlZiA/IGVsZW1lbnQgOiBuZXcgRWxlbWVudFJlZihlbGVtZW50KTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBlbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBmaWx0ZXI6IGFueTtcbiAgICBASW5wdXQoKSBsb2FkT25Jbml0OiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBsb2FkT25TY3JvbGw6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHBhZ2VTaXplOiBudW1iZXIgPSAyMDtcblxuICAgIEBPdXRwdXQoKSBjb2xsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcblxuICAgIEBPdXRwdXQoJ2xvYWRpbmcnKVxuICAgIGxvYWRpbmdFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8SW5maW5pdGVTY3JvbGxMb2FkaW5nRXZlbnQ+KCk7XG5cbiAgICBAT3V0cHV0KCdsb2FkZWQnKVxuICAgIGxvYWRlZEV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxJbmZpbml0ZVNjcm9sbExvYWRlZEV2ZW50PigpO1xuXG4gICAgQE91dHB1dCgnbG9hZEVycm9yJylcbiAgICBsb2FkRXJyb3JFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8SW5maW5pdGVTY3JvbGxMb2FkRXJyb3JFdmVudD4oKTtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oSW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlKVxuICAgIHByaXZhdGUgX2xvYWRCdXR0b25RdWVyeTogUXVlcnlMaXN0PEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZT47XG5cbiAgICBAQ29udGVudENoaWxkcmVuKEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZSlcbiAgICBwcml2YXRlIF9sb2FkaW5nSW5kaWNhdG9yUXVlcnk6IFF1ZXJ5TGlzdDxJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmU+O1xuXG4gICAgcHJpdmF0ZSBfcGFnZXM6IGFueVtdW107XG4gICAgcHJpdmF0ZSBfbmV4dFBhZ2VOdW0gPSAwO1xuICAgIHByaXZhdGUgX2RvbU9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyO1xuICAgIHByaXZhdGUgX3Njcm9sbEV2ZW50U3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfdXBkYXRlUmVxdWVzdHMgPSBuZXcgU3ViamVjdDxJbmZpbml0ZVNjcm9sbFJlcXVlc3Q+KCk7XG5cbiAgICBwcml2YXRlIF9pc0xvYWRpbmcgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBwcml2YXRlIF9pc0V4aGF1c3RlZCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHByaXZhdGUgX2xvYWRCdXR0b25FbmFibGVkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcHJpdmF0ZSBfY2FuTG9hZE1hbnVhbGx5OiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuXG4gICAgcHJpdmF0ZSBfc2Nyb2xsRWxlbWVudDogRWxlbWVudFJlZjtcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICAgIHByaXZhdGUgX2xvYWRCdXR0b25TdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2NhbkxvYWRNYW51YWxseSA9IHRoaXMuX2lzTG9hZGluZy5waXBlKGNvbWJpbmVMYXRlc3QoXG4gICAgICAgICAgICB0aGlzLl9pc0V4aGF1c3RlZCxcbiAgICAgICAgICAgIHRoaXMuX2xvYWRCdXR0b25FbmFibGVkLFxuICAgICAgICAgICAgKGlzTG9hZGluZywgaXNFeGhhdXN0ZWQsIGxvYWRCdXR0b25FbmFibGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc0xvYWRpbmcgJiYgIWlzRXhoYXVzdGVkICYmIGxvYWRCdXR0b25FbmFibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zY3JvbGxFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvYWRCdXR0b25FbmFibGVkLm5leHQoIXRoaXMubG9hZE9uU2Nyb2xsKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byBraW5kcyBvZiB1cGRhdGUgcmVxdWVzdHM6IGNoZWNrIGFuZCBsb2FkLlxuICAgICAgICAvLyBDaGVjayByZXF1ZXN0cyBhcmUgdGhyb3R0bGVkIGFuZCB3aWxsIG9ubHkgY2F1c2UgYW4gdXBkYXRlIGlmIG1vcmUgZGF0YSBpcyByZXF1aXJlZFxuICAgICAgICAvLyB0byBmaWxsIHRoZSBzY3JvbGxpbmcgdmlldywgYW5kIGl0IGlzbid0IGFscmVhZHkgbG9hZGluZyBzb21lLlxuICAgICAgICAvLyBMb2FkIHJlcXVlc3RzIGFyZSBub3QgdGhyb3R0bGVkIGFuZCBhbHdheXMgcmVxdWVzdCBhIHBhZ2Ugb2YgZGF0YS5cbiAgICAgICAgdGhpcy5fdXBkYXRlUmVxdWVzdHMucGlwZShmaWx0ZXJPcGVyYXRvcihyZXF1ZXN0ID0+IHJlcXVlc3QuY2hlY2spLCBhdWRpdFRpbWUoMjAwKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLmRvUmVxdWVzdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVxdWVzdHMucGlwZShmaWx0ZXJPcGVyYXRvcihyZXF1ZXN0ID0+ICFyZXF1ZXN0LmNoZWNrKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLmRvUmVxdWVzdC5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gc2Nyb2xsIGV2ZW50cyBhbmQgRE9NIGNoYW5nZXMuXG4gICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIExvYWQgTW9yZSBidXR0b24gdmlzaWJsZSBzdGF0ZS5cbiAgICAgICAgdGhpcy5fY2FuTG9hZE1hbnVhbGx5LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShjYW5Mb2FkID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRCdXR0b25RdWVyeS5mb3JFYWNoKGxvYWRCdXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRCdXR0b24udmlzaWJsZSA9IGNhbkxvYWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgbG9hZGluZyBpbmRpY2F0b3IgdmlzaWJsZSBzdGF0ZS5cbiAgICAgICAgdGhpcy5faXNMb2FkaW5nLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShpc0xvYWRpbmcgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ0luZGljYXRvclF1ZXJ5LmZvckVhY2gobG9hZGluZyA9PiB7XG4gICAgICAgICAgICAgICAgbG9hZGluZy52aXNpYmxlID0gaXNMb2FkaW5nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExpbmsgdGhlIExvYWQgTW9yZSBidXR0b24gY2xpY2sgZXZlbnQgdG8gdHJpZ2dlciBhbiB1cGRhdGUuXG4gICAgICAgIHRoaXMuYXR0YWNoTG9hZEJ1dHRvbkV2ZW50cygpO1xuICAgICAgICB0aGlzLl9sb2FkQnV0dG9uUXVlcnkuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hMb2FkQnV0dG9uRXZlbnRzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluaXRpYWwgdXBkYXRlLlxuICAgICAgICBpZiAodGhpcy5sb2FkT25Jbml0KSB7XG4gICAgICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBsZXQgY2hlY2sgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjaGFuZ2VzLmVuYWJsZWQgJiYgY2hhbmdlcy5lbmFibGVkLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5lbmFibGVkLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmVuYWJsZWQuY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuZmlsdGVyICYmIGNoYW5nZXMuZmlsdGVyLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5maWx0ZXIucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5sb2FkT25TY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkQnV0dG9uRW5hYmxlZC5uZXh0KFxuICAgICAgICAgICAgICAgICAgICAhY2hhbmdlcy5sb2FkT25TY3JvbGwuY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZXMucGFnZVNpemUgJiYgY2hhbmdlcy5wYWdlU2l6ZS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMucGFnZVNpemUucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5uZXh0KHtcbiAgICAgICAgICAgICAgICBjaGVjazogY2hlY2ssXG4gICAgICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5fbmV4dFBhZ2VOdW0sXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYW4gYWRkaXRpb25hbCBwYWdlIG9mIGRhdGEuXG4gICAgICovXG4gICAgbG9hZE5leHRQYWdlKCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUmVxdWVzdHMubmV4dCh7XG4gICAgICAgICAgICBjaGVjazogZmFsc2UsXG4gICAgICAgICAgICBwYWdlTnVtYmVyOiB0aGlzLl9uZXh0UGFnZU51bSxcbiAgICAgICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlclxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGEgY2hlY2sgZm9yIHdoZXRoZXIgYW4gYWRkaXRpb25hbCBwYWdlIG9mIGRhdGEgaXMgcmVxdWlyZWQuIFRoaXMgaXMgdGhyb3R0bGVkLlxuICAgICAqL1xuICAgIGNoZWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUmVxdWVzdHMubmV4dCh7XG4gICAgICAgICAgICBjaGVjazogdHJ1ZSxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHRoaXMuX25leHRQYWdlTnVtLFxuICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjb2xsZWN0aW9uLiBGdXR1cmUgcmVxdWVzdHMgd2lsbCBsb2FkIGZyb20gcGFnZSAwLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIHBhZ2UgY291bnRlci5cbiAgICAgICAgdGhpcy5fbmV4dFBhZ2VOdW0gPSAwO1xuXG4gICAgICAgIHRoaXMuX3BhZ2VzID0gW107XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbGxlY3Rpb24gKHdpdGhvdXQgY2hhbmdpbmcgdGhlIHJlZmVyZW5jZSkuXG4gICAgICAgIGlmICh0aGlzLmNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbi5sZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGV4aGF1c3RlZCBmbGFnLCBhbGxvd2luZyB0aGUgTG9hZCBNb3JlIGJ1dHRvbiB0byBhcHBlYXIuXG4gICAgICAgIHRoaXMuX2lzRXhoYXVzdGVkLm5leHQoZmFsc2UpO1xuXG4gICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHJlcXVlc3QgPT4gcmVxdWVzdC51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbG9hZCB0aGUgZGF0YSB3aXRob3V0IGNsZWFyaW5nIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgdGhpcy5fcGFnZXMuZm9yRWFjaCgocGFnZSwgaSkgPT4gdGhpcy5yZWxvYWRQYWdlKGkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxvYWQgdGhlIGRhdGEgaW4gYSBzcGVjaWZpYyBwYWdlIHdpdGhvdXQgY2xlYXJpbmcgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHBhZ2VOdW0gUGFnZSBudW1iZXJcbiAgICAgKi9cbiAgICByZWxvYWRQYWdlKHBhZ2VOdW06IG51bWJlcikge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUmVxdWVzdHMubmV4dCh7XG4gICAgICAgICAgICBjaGVjazogZmFsc2UsXG4gICAgICAgICAgICBwYWdlTnVtYmVyOiBwYWdlTnVtLFxuICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyLFxuICAgICAgICAgICAgcmVsb2FkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBzY3JvbGwgZXZlbnQgaGFuZGxlciBhbmQgRE9NIG9ic2VydmVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXR0YWNoRXZlbnRIYW5kbGVycygpIHtcblxuICAgICAgICAvLyBpZiB0aGUgc2Nyb2xsRWxlbWVudCBpcyBkb2N1bWVudEVsZW1lbnQgd2UgbXVzdCB3YXRjaCBmb3IgYSBzY3JvbGwgZXZlbnQgb24gdGhlIGRvY3VtZW50XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQubmF0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxIdG1sRWxlbWVudCA/IGRvY3VtZW50IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgc2Nyb2xsIGV2ZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRTdWIgPSBmcm9tRXZlbnQodGFyZ2V0LCAnc2Nyb2xsJykuc3Vic2NyaWJlKHRoaXMuY2hlY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNoaWxkIERPTSBjaGFuZ2VzLiBUaGUgbWFpbiBlZmZlY3Qgb2YgdGhpcyBpcyB0byBjaGVjayB3aGV0aGVyIGV2ZW4gbW9yZSBkYXRhIGlzXG4gICAgICAgIC8vIHJlcXVpcmVkIGFmdGVyIHRoZSBpbml0aWFsIGxvYWQuXG4gICAgICAgIHRoaXMuX2RvbU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5jaGVjay5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9zY3JvbGxFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIHNjcm9sbCBldmVudCBoYW5kbGVyIGFuZCBET00gb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkZXRhY2hFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsRXZlbnRTdWIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEV2ZW50U3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFdmVudFN1YiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZG9tT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvbU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2RvbU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbnkgZXhpc3RpbmcgZXZlbnQgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIGxvYWQgYnV0dG9uIGBsb2FkYCBldmVudCwgdGhlbiBhdHRhY2ggc3Vic2NyaXB0aW9uc1xuICAgICAqIGZvciBhbnkgaW4gdGhlIHF1ZXJ5LlxuICAgICAqL1xuICAgIHByaXZhdGUgYXR0YWNoTG9hZEJ1dHRvbkV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5fbG9hZEJ1dHRvblN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIHRoaXMuX2xvYWRCdXR0b25TdWJzY3JpcHRpb25zID0gdGhpcy5fbG9hZEJ1dHRvblF1ZXJ5Lm1hcChcbiAgICAgICAgICAgIGxvYWRCdXR0b24gPT4gbG9hZEJ1dHRvbi5sb2FkLnN1YnNjcmliZSh0aGlzLmxvYWROZXh0UGFnZS5iaW5kKHRoaXMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFsbHkgbG9hZHMgYSBwYWdlIGludG8gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gZGlyZWN0aXZlIHN0YXRlIGFuZCByZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkb1JlcXVlc3QocmVxdWVzdDogSW5maW5pdGVTY3JvbGxSZXF1ZXN0KSB7XG5cbiAgICAgICAgLy8gTG9hZCBhIG5ldyBwYWdlIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgYmV5b25kIHRoZSB0aHJlc2hob2xkIGFuZCBpZiB0aGUgY2xpZW50IGNvZGUgZGlkIG5vdFxuICAgICAgICAvLyBjYW5jZWwuXG4gICAgICAgIGlmICh0aGlzLm5lZWRzRGF0YShyZXF1ZXN0KSAmJiB0aGlzLmJlZ2luTG9hZGluZyhyZXF1ZXN0KSkge1xuXG4gICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGxvYWQgZnVuY3Rpb24sIHdoaWNoIHJldHVybnMgYSBwcm9tb3NlIG9yIHBsYWluIGRhdGEuXG4gICAgICAgICAgICBjb25zdCBsb2FkUmVzdWx0ID0gdGhpcy5sb2FkKHJlcXVlc3QucGFnZU51bWJlciwgcmVxdWVzdC5wYWdlU2l6ZSwgcmVxdWVzdC5maWx0ZXIpO1xuXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlID0gQXJyYXkuaXNBcnJheShsb2FkUmVzdWx0KSA/IG9mKGxvYWRSZXN1bHQpIDogZnJvbTxhbnlbXT4obG9hZFJlc3VsdCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgaXRlbXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcGFyYW1ldGVycyBoYXZlIG5vdCBjaGFuZ2VkIHNpbmNlIHRoZSBsb2FkIHN0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBkaXNjYXJkIHRoZSByZXN1bHRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5maWx0ZXIgPT09IHRoaXMuZmlsdGVyICYmIHJlcXVlc3QucGFnZVNpemUgPT09IHRoaXMucGFnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBhZ2VJdGVtcyhyZXF1ZXN0LnBhZ2VOdW1iZXIsIGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgbG9hZGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZExvYWRpbmcocmVxdWVzdCwgaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWFzb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IHRoZSBsb2FkRXJyb3IgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRMb2FkaW5nV2l0aEVycm9yKHJlcXVlc3QsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIHJlcXVlc3QgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucy5maWx0ZXIocyA9PiBzICE9PSBzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgc3Vic2NyaXB0aW9uIHRvIHRoZSBsaXN0IG9mIHJlcXVlc3RzXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBzaG91bGQgYmUgZnVsZmlsbGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgbmVlZHNEYXRhKHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWx3YXlzIGxvYWQgZm9yIGEgbG9hZCByZXF1ZXN0XG4gICAgICAgIGlmICghcmVxdWVzdC5jaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZ25vcmUgYSBjaGVjayByZXF1ZXN0IHdoZW4gdGhlIGVuZCBvZiBkYXRhIGhhcyBiZWVuIGRldGVjdGVkLCBvciBpZiBkYXRhIGlzIGN1cnJlbnRseSBsb2FkaW5nLlxuICAgICAgICBpZiAodGhpcy5faXNFeGhhdXN0ZWQuZ2V0VmFsdWUoKSB8fCB0aGlzLl9pc0xvYWRpbmcuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9hZCBpZiB0aGUgcmVtYWluaW5nIHNjcm9sbCBhcmVhIGlzIDw9IHRoZSBlbGVtZW50IGhlaWdodC5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEVsZW1lbnQgJiYgdGhpcy5sb2FkT25TY3JvbGwpIHtcblxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IDxIVE1MRWxlbWVudD50aGlzLl9zY3JvbGxFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdTY3JvbGwgPVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAoZWxlbWVudC5zY3JvbGxUb3AgKyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmdTY3JvbGwgPD0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzdGF0ZSBmb3IgdGhlIGJlZ2lubmluZyBvZiBhIGxvYWQuIFJldHVybnMgZmFsc2UgaWYgdGhlIGBsb2FkaW5nYCBldmVudCB3YXMgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgYmVnaW5Mb2FkaW5nKHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCk6IGJvb2xlYW4ge1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEluZmluaXRlU2Nyb2xsTG9hZGluZ0V2ZW50KFxuICAgICAgICAgICAgcmVxdWVzdC5wYWdlTnVtYmVyLFxuICAgICAgICAgICAgcmVxdWVzdC5wYWdlU2l6ZSxcbiAgICAgICAgICAgIHJlcXVlc3QuZmlsdGVyXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9hZGluZ0V2ZW50LmVtaXQoZXZlbnQpO1xuXG4gICAgICAgIHRoaXMuX2lzTG9hZGluZy5uZXh0KCFldmVudC5kZWZhdWx0UHJldmVudGVkKCkpO1xuXG4gICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0UGFnZUl0ZW1zKHBhZ2VOdW06IG51bWJlciwgaXRlbXM6IGFueVtdKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VzW3BhZ2VOdW1dID0gaXRlbXM7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IHRoaXMuX3BhZ2VzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzLmNvbmNhdChjdXJyZW50KSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3RhdGUgZnJvbSBhIHN1Y2Nlc3NmdWwgbG9hZC4gUmFpc2VzIHRoZSBgbG9hZGVkYCBldmVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGVuZExvYWRpbmcocmVxdWVzdDogSW5maW5pdGVTY3JvbGxSZXF1ZXN0LCBkYXRhPzogYW55KSB7XG4gICAgICAgIHRoaXMuX2lzTG9hZGluZy5uZXh0KGZhbHNlKTtcblxuICAgICAgICBjb25zdCBpc0V4aGF1c3RlZCA9ICEhKGRhdGEgJiYgZGF0YS5sZW5ndGggPCB0aGlzLnBhZ2VTaXplKTtcbiAgICAgICAgdGhpcy5faXNFeGhhdXN0ZWQubmV4dChpc0V4aGF1c3RlZCk7XG5cbiAgICAgICAgdGhpcy5sb2FkZWRFdmVudC5lbWl0KFxuICAgICAgICAgICAgbmV3IEluZmluaXRlU2Nyb2xsTG9hZGVkRXZlbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYWdlTnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFnZVNpemUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBpc0V4aGF1c3RlZFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghcmVxdWVzdC5yZWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRQYWdlTnVtICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHN0YXRlIGZyb20gYSBmYWlsZWQgbG9hZC4gUmFpc2VzIHRoZSBgbG9hZEVycm9yYCBldmVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGVuZExvYWRpbmdXaXRoRXJyb3IocmVxdWVzdDogSW5maW5pdGVTY3JvbGxSZXF1ZXN0LCBlcnJvcjogYW55KSB7XG4gICAgICAgIHRoaXMuX2lzTG9hZGluZy5uZXh0KGZhbHNlKTtcblxuICAgICAgICB0aGlzLmxvYWRFcnJvckV2ZW50LmVtaXQoXG4gICAgICAgICAgICBuZXcgSW5maW5pdGVTY3JvbGxMb2FkRXJyb3JFdmVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhZ2VOdW1iZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmZpbHRlcixcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJuYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBsb2FkL2NoZWNrIHJlcXVlc3QuXG4gKi9cbmNsYXNzIEluZmluaXRlU2Nyb2xsUmVxdWVzdCB7XG4gICAgY2hlY2s6IGJvb2xlYW47XG4gICAgcGFnZU51bWJlcjogbnVtYmVyO1xuICAgIHBhZ2VTaXplOiBudW1iZXI7XG4gICAgZmlsdGVyOiBhbnk7XG4gICAgcmVsb2FkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb24gPSAoXG4gICAgcGFnZU51bTogbnVtYmVyLFxuICAgIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgZmlsdGVyOiBhbnlcbikgPT4gYW55IHwgUHJvbWlzZTxhbnk+O1xuXG4vKipcbiAqIEV2ZW50IHJhaXNlZCBiZWZvcmUgdGhlIGBsb2FkaW5nYCBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRpbmdFdmVudCB7XG4gICAgcHJpdmF0ZSBfZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHJlcXVlc3RlZCBwYWdlLCBzdGFydGluZyBmcm9tIDAuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZU51bWJlcjogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVtcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZVNpemU6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWx0ZXIgZGV0YWlscyBhcyBwcm92aWRlZCB2aWEgdGhlIGBmaWx0ZXJgIGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZmlsdGVyOiBhbnlcbiAgICApIHsgfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoZSBgbG9hZGluZ2AgZXZlbnQgKGxvYWRpbmcgZnVuY3Rpb24gd2lsbCBub3QgYmUgY2FsbGVkKS5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZGVmYXVsdFByZXZlbnRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEV2ZW50IHJhaXNlZCB3aGVuIHRoZSBsb2FkaW5nIGZ1bmN0aW9uIHJlc3VsdCBoYXMgYmVlbiByZXNvbHZlZCBhbmQgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRlZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgcmVxdWVzdGVkIHBhZ2UsIHN0YXJ0aW5nIGZyb20gMC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlU2l6ZTogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpbHRlciBkZXRhaWxzIGFzIHByb3ZpZGVkIHZpYSB0aGUgYGZpbHRlcmAgYmluZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBmaWx0ZXI6IGFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXN1bHQgb2YgdGhlIHByb21pc2UgcmV0dXJuZWQgZnJvbSB0aGUgbG9hZGluZyBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBkYXRhOiBhbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGlmIHRoZSBkYXRhIGlzIGNvbnNpZGVyZWQgZXhoYXVzdGVkIChudW1iZXIgb2YgaXRlbXMgcmV0dXJuZWQgbGVzcyB0aGFuIGBwYWdlU2l6ZWApLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGV4aGF1c3RlZDogYm9vbGVhblxuICAgICkgeyB9XG59XG5cbi8qKlxuICogRXZlbnQgcmFpc2VkIGlmIHRoZSBsb2FkaW5nIGZ1bmN0aW9uIHJldHVybnMgYSByZWplY3RlZCBwcm9taXNlLlxuICovXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkRXJyb3JFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHJlcXVlc3RlZCBwYWdlLCBzdGFydGluZyBmcm9tIDAuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZU51bWJlcjogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVtcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZVNpemU6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWx0ZXIgZGV0YWlscyBhcyBwcm92aWRlZCB2aWEgdGhlIGBmaWx0ZXJgIGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZmlsdGVyOiBhbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2JqZWN0IHByb3ZpZGVkIHdoZW4gcmVqZWN0aW5nIHRoZSBwcm9taXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGVycm9yOiBhbnlcbiAgICApIHsgfVxufVxuIiwiaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwuZGlyZWN0aXZlJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW10sXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2Nyb2xsSW50b1ZpZXdTZXJ2aWNlIHtcblxuICAgIHNjcm9sbEludG9WaWV3KGVsZW06IEhUTUxFbGVtZW50LCBzY3JvbGxQYXJlbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFRvcCA9IChlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIC0gc2Nyb2xsUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgaWYgKG9mZnNldFRvcCA8IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBvZmZzZXRUb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRCb3R0b20gPSBvZmZzZXRUb3AgKyBlbGVtLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIGlmIChvZmZzZXRCb3R0b20gPiAoc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCArIHNjcm9sbFBhcmVudC5jbGllbnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA9IG9mZnNldEJvdHRvbSAtIHNjcm9sbFBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25DaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTY3JvbGxJbnRvVmlld1NlcnZpY2UgfSBmcm9tICcuL3Njcm9sbC1pbnRvLXZpZXcuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2Nyb2xsSW50b1ZpZXdJZl0nLFxuICAgIHByb3ZpZGVyczogW1Njcm9sbEludG9WaWV3U2VydmljZV1cbiB9KVxuZXhwb3J0IGNsYXNzIFNjcm9sbEludG9WaWV3SWZEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuXG4gICAgQElucHV0KCd1eFNjcm9sbEludG9WaWV3SWYnKSBjb25kaXRpb24gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzY3JvbGxQYXJlbnQ6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfc2Nyb2xsSW50b1ZpZXdTZXJ2aWNlOiBTY3JvbGxJbnRvVmlld1NlcnZpY2UpIHt9XG5cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3Njcm9sbEludG9WaWV3U2VydmljZS5zY3JvbGxJbnRvVmlldyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMuc2Nyb2xsUGFyZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFNjcm9sbEludG9WaWV3XSdcbn0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsSW50b1ZpZXdEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIC8qKiBBbGxvdyBhIGNvbmRpdGlvbiBhcm91bmQgd2hldGhlciBvciBub3QgdGhpcyBzaG91bGQgc2Nyb2xsIGludG8gdmlldyAqL1xuICAgIEBJbnB1dCgpIHV4U2Nyb2xsSW50b1ZpZXc6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqIEFsbG93IHVzZXIgdG8gcHJvdmlkZSB0aGUgYnJvd3NlciBzdXBwb3J0ZWQgb3B0aW9ucyAqL1xuICAgIEBJbnB1dCgpIHNjcm9sbEludG9WaWV3T3B0aW9uczogU2Nyb2xsSW50b1ZpZXdPcHRpb25zIHwgYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudXhTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbEludG9WaWV3KHRoaXMuc2Nyb2xsSW50b1ZpZXdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2Nyb2xsSW50b1ZpZXdJZkRpcmVjdGl2ZSB9IGZyb20gJy4vc2Nyb2xsLWludG8tdmlldy1pZi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU2Nyb2xsSW50b1ZpZXdEaXJlY3RpdmUgfSBmcm9tICcuL3Njcm9sbC1pbnRvLXZpZXcuZGlyZWN0aXZlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtTY3JvbGxJbnRvVmlld0lmRGlyZWN0aXZlLCBTY3JvbGxJbnRvVmlld0RpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbU2Nyb2xsSW50b1ZpZXdJZkRpcmVjdGl2ZSwgU2Nyb2xsSW50b1ZpZXdEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIFNjcm9sbE1vZHVsZSB7IH0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFR5cGVhaGVhZFNlcnZpY2UgfSBmcm9tICcuL3R5cGVhaGVhZC5zZXJ2aWNlJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdbdXhUeXBlYWhlYWRIaWdobGlnaHRdJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkSGlnaGxpZ2h0RGlyZWN0aXZlIHtcclxuXHJcbiAgICBASW5wdXQoJ3V4VHlwZWFoZWFkSGlnaGxpZ2h0JylcclxuICAgIHNldCBoaWdobGlnaHQodmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5oaWdobGlnaHRlZEVsZW1lbnQkLm5leHQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VydmljZTogVHlwZWFoZWFkU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cclxufVxyXG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xuaW1wb3J0IHsgU2Nyb2xsTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zY3JvbGwvaW5kZXgnO1xuaW1wb3J0IHsgVHlwZWFoZWFkSGlnaGxpZ2h0RGlyZWN0aXZlIH0gZnJvbSAnLi90eXBlYWhlYWQtaGlnaGxpZ2h0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUeXBlYWhlYWRLZXlTZXJ2aWNlIH0gZnJvbSAnLi90eXBlYWhlYWQta2V5LnNlcnZpY2UnO1xuaW1wb3J0IHsgVHlwZWFoZWFkQ29tcG9uZW50IH0gZnJvbSAnLi90eXBlYWhlYWQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxNb2R1bGUsXG4gICAgICAgIFNjcm9sbE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1R5cGVhaGVhZENvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbVHlwZWFoZWFkQ29tcG9uZW50LCBUeXBlYWhlYWRIaWdobGlnaHREaXJlY3RpdmVdLFxuICAgIHByb3ZpZGVyczogW1R5cGVhaGVhZEtleVNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBUeXBlYWhlYWRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcywgU3RhdGljUHJvdmlkZXIsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEtleVNlcnZpY2UsIFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcclxuXHJcbmxldCB1bmlxdWVJZCA9IDA7XHJcblxyXG5leHBvcnQgY29uc3QgU0VMRUNUX1ZBTFVFX0FDQ0VTU09SOiBTdGF0aWNQcm92aWRlciA9IHtcclxuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2VsZWN0Q29tcG9uZW50KSxcclxuICAgIG11bHRpOiB0cnVlXHJcbn07XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtc2VsZWN0JyxcclxuICAgIHRlbXBsYXRlOiBgPHV4LXRhZy1pbnB1dCAqbmdJZj1cIm11bHRpcGxlXCJcclxuICAgIFtpZF09XCJpZCArICctaW5wdXQnXCJcclxuICAgIFsodGFncyldPVwidmFsdWVcIlxyXG4gICAgWyhpbnB1dCldPVwiaW5wdXRcIlxyXG4gICAgW2FkZE9uUGFzdGVdPVwiZmFsc2VcIlxyXG4gICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcclxuICAgIFtkaXNwbGF5XT1cImRpc3BsYXlcIlxyXG4gICAgW2ZyZWVJbnB1dF09XCJmYWxzZVwiXHJcbiAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxyXG4gICAgW3Nob3dUeXBlYWhlYWRPbkNsaWNrXT1cInRydWVcIj5cclxuXHJcbiAgICA8dXgtdHlwZWFoZWFkICNtdWx0aXBsZVR5cGVhaGVhZFxyXG4gICAgICAgIFtpZF09XCJpZCArICctdHlwZWFoZWFkJ1wiXHJcbiAgICAgICAgW29wdGlvbnNdPVwib3B0aW9uc1wiXHJcbiAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXIkIHwgYXN5bmNcIlxyXG4gICAgICAgIFsob3BlbildPVwiZHJvcGRvd25PcGVuXCJcclxuICAgICAgICBbZGlzcGxheV09XCJkaXNwbGF5XCJcclxuICAgICAgICBba2V5XT1cImtleVwiXHJcbiAgICAgICAgW2Rpc2FibGVkT3B0aW9uc109XCJ2YWx1ZVwiXHJcbiAgICAgICAgW2Ryb3BEaXJlY3Rpb25dPVwiZHJvcERpcmVjdGlvblwiXHJcbiAgICAgICAgW21heEhlaWdodF09XCJtYXhIZWlnaHRcIlxyXG4gICAgICAgIFttdWx0aXNlbGVjdGFibGVdPVwidHJ1ZVwiXHJcbiAgICAgICAgW3BhZ2VTaXplXT1cInBhZ2VTaXplXCJcclxuICAgICAgICBbc2VsZWN0Rmlyc3RdPVwidHJ1ZVwiXHJcbiAgICAgICAgW2xvYWRpbmdUZW1wbGF0ZV09XCJsb2FkaW5nVGVtcGxhdGVcIlxyXG4gICAgICAgIFtvcHRpb25UZW1wbGF0ZV09XCJvcHRpb25UZW1wbGF0ZVwiXHJcbiAgICAgICAgW25vT3B0aW9uc1RlbXBsYXRlXT1cIm5vT3B0aW9uc1RlbXBsYXRlXCI+XHJcbiAgICA8L3V4LXR5cGVhaGVhZD5cclxuXHJcbjwvdXgtdGFnLWlucHV0PlxyXG5cclxuPGRpdiAqbmdJZj1cIiFtdWx0aXBsZVwiXHJcbiAgICBjbGFzcz1cImlubmVyLWFkZG9uIHJpZ2h0LWFkZG9uXCJcclxuICAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXHJcbiAgICByb2xlPVwiY29tYm9ib3hcIlxyXG4gICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJkcm9wZG93bk9wZW5cIlxyXG4gICAgYXJpYS1oYXNwb3B1cD1cImxpc3Rib3hcIj5cclxuXHJcbiAgICA8aSBjbGFzcz1cImhwZS1pY29uXCJcclxuICAgICAgICBbY2xhc3MuaHBlLWRvd25dPVwiZHJvcERpcmVjdGlvbiA9PT0gJ2Rvd24nXCJcclxuICAgICAgICBbY2xhc3MuaHBlLXVwXT1cImRyb3BEaXJlY3Rpb24gPT09ICd1cCdcIj48L2k+XHJcblxyXG4gICAgPGlucHV0ICNzaW5nbGVJbnB1dCB0eXBlPVwidGV4dFwiIFthdHRyLmlkXT1cImlkICsgJy1pbnB1dCdcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiXHJcbiAgICAgICAgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImhpZ2hsaWdodGVkRWxlbWVudD8uaWRcIlxyXG4gICAgICAgIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiXHJcbiAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCJzaW5nbGVUeXBlYWhlYWQuaWRcIlxyXG4gICAgICAgIGFyaWEtbXVsdGlsaW5lPVwiZmFsc2VcIlxyXG4gICAgICAgIFsobmdNb2RlbCldPVwiaW5wdXRcIlxyXG4gICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXHJcbiAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcclxuICAgICAgICAoY2xpY2spPVwiaW5wdXRDbGlja0hhbmRsZXIoJGV2ZW50KVwiXHJcbiAgICAgICAgKGJsdXIpPVwiaW5wdXRCbHVySGFuZGxlcigkZXZlbnQpXCJcclxuICAgICAgICAoa2V5ZG93bik9XCJpbnB1dEtleUhhbmRsZXIoJGV2ZW50KVwiPlxyXG5cclxuICAgIDx1eC10eXBlYWhlYWQgI3NpbmdsZVR5cGVhaGVhZFxyXG4gICAgICAgIFtpZF09XCJpZCArICctdHlwZWFoZWFkJ1wiXHJcbiAgICAgICAgW29wdGlvbnNdPVwib3B0aW9uc1wiXHJcbiAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXIkIHwgYXN5bmNcIlxyXG4gICAgICAgIFsob3BlbildPVwiZHJvcGRvd25PcGVuXCJcclxuICAgICAgICBbZGlzcGxheV09XCJkaXNwbGF5XCJcclxuICAgICAgICBba2V5XT1cImtleVwiXHJcbiAgICAgICAgW2Ryb3BEaXJlY3Rpb25dPVwiZHJvcERpcmVjdGlvblwiXHJcbiAgICAgICAgW21heEhlaWdodF09XCJtYXhIZWlnaHRcIlxyXG4gICAgICAgIFttdWx0aXNlbGVjdGFibGVdPVwiZmFsc2VcIlxyXG4gICAgICAgIFtvcGVuT25GaWx0ZXJDaGFuZ2VdPVwiZmFsc2VcIlxyXG4gICAgICAgIFtwYWdlU2l6ZV09XCJwYWdlU2l6ZVwiXHJcbiAgICAgICAgW3NlbGVjdEZpcnN0XT1cInRydWVcIlxyXG4gICAgICAgIFtsb2FkaW5nVGVtcGxhdGVdPVwibG9hZGluZ1RlbXBsYXRlXCJcclxuICAgICAgICBbb3B0aW9uVGVtcGxhdGVdPVwib3B0aW9uVGVtcGxhdGVcIlxyXG4gICAgICAgIFtub09wdGlvbnNUZW1wbGF0ZV09XCJub09wdGlvbnNUZW1wbGF0ZVwiXHJcbiAgICAgICAgKG9wdGlvblNlbGVjdGVkKT1cInNpbmdsZU9wdGlvblNlbGVjdGVkKCRldmVudClcIlxyXG4gICAgICAgIChoaWdobGlnaHRlZEVsZW1lbnRDaGFuZ2UpPVwiaGlnaGxpZ2h0ZWRFbGVtZW50ID0gJGV2ZW50XCI+XHJcbiAgICA8L3V4LXR5cGVhaGVhZD5cclxuXHJcbjwvZGl2PlxyXG5gLFxyXG4gICAgcHJvdmlkZXJzOiBbU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xyXG5cclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGlkOiBzdHJpbmcgPSBgdXgtc2VsZWN0LSR7Kyt1bmlxdWVJZH1gO1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UodmFsdWUpO1xyXG5cclxuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGFsbG93IG11bHRpcGxlIHNlbGVjdGlvbiB1cGRhdGUgdGhlIGlucHV0IHZhbHVlIChzdXBwb3J0aW5nIG5nTW9kZWwpXHJcbiAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdldERpc3BsYXkodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGlucHV0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dCQudmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgaW5wdXQodmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2lucHV0JC5uZXh0KHZhbHVlKTtcclxuICAgICAgICB0aGlzLmlucHV0Q2hhbmdlLmVtaXQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgZHJvcGRvd25PcGVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wZG93bk9wZW47XHJcbiAgICB9XHJcbiAgICBzZXQgZHJvcGRvd25PcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fZHJvcGRvd25PcGVuID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5kcm9wZG93bk9wZW5DaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KCkgb3B0aW9uczogYW55W10gfCBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcclxuICAgIEBJbnB1dCgpIGRpc3BsYXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkga2V5OiAob3B0aW9uOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGFsbG93TnVsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIGRyb3BEaXJlY3Rpb246ICd1cCcgfCAnZG93bicgPSAnZG93bic7XHJcbiAgICBASW5wdXQoKSBtYXhIZWlnaHQ6IHN0cmluZyA9ICcyNTBweCc7XHJcbiAgICBASW5wdXQoKSBtdWx0aXBsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgcGFnZVNpemU6IG51bWJlciA9IDIwO1xyXG4gICAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZztcclxuXHJcbiAgICBASW5wdXQoKSBsb2FkaW5nVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBub09wdGlvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIG9wdGlvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgQE91dHB1dCgpIGlucHV0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XHJcbiAgICBAT3V0cHV0KCkgZHJvcGRvd25PcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ3NpbmdsZUlucHV0Jykgc2luZ2xlSW5wdXQ6IEVsZW1lbnRSZWY7XHJcbiAgICBAVmlld0NoaWxkKCdtdWx0aXBsZVR5cGVhaGVhZCcpIG11bHRpcGxlVHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQ7XHJcbiAgICBAVmlld0NoaWxkKCdzaW5nbGVUeXBlYWhlYWQnKSBzaW5nbGVUeXBlYWhlYWQ6IFR5cGVhaGVhZENvbXBvbmVudDtcclxuXHJcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gICAgZmlsdGVyJDogT2JzZXJ2YWJsZTxzdHJpbmc+O1xyXG4gICAgcHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4geyB9O1xyXG5cclxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnk7XHJcbiAgICBwcml2YXRlIF9pbnB1dCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4oJycpO1xyXG4gICAgcHJpdmF0ZSBfZHJvcGRvd25PcGVuOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55LFxyXG4gICAgICAgIHByaXZhdGUgX3R5cGVhaGVhZEtleVNlcnZpY2U6IFR5cGVhaGVhZEtleVNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG5cclxuICAgICAgICAvLyBDaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxyXG4gICAgICAgIGNvbnN0IG9uSW5wdXQgPSB0aGlzLl9pbnB1dCQucGlwZShcclxuICAgICAgICAgICAgZmlsdGVyKHZhbHVlID0+IHRoaXMuYWxsb3dOdWxsKSxcclxuICAgICAgICAgICAgZmlsdGVyKHZhbHVlID0+ICF0aGlzLm11bHRpcGxlICYmIHZhbHVlICE9PSB0aGlzLmdldERpc3BsYXkodGhpcy52YWx1ZSkpXHJcbiAgICAgICAgKS5zdWJzY3JpYmUodmFsdWUgPT4gdGhpcy52YWx1ZSA9IG51bGwpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdXAgZmlsdGVyIGZyb20gaW5wdXRcclxuICAgICAgICB0aGlzLmZpbHRlciQgPSB0aGlzLl9pbnB1dCQucGlwZShcclxuICAgICAgICAgICAgbWFwKGlucHV0ID0+ICF0aGlzLm11bHRpcGxlICYmIGlucHV0ID09PSB0aGlzLmdldERpc3BsYXkodGhpcy52YWx1ZSkgPyAnJyA6IGlucHV0KSxcclxuICAgICAgICAgICAgZGVib3VuY2VUaW1lKDIwMClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBPcGVuIHRoZSBkcm9wZG93biB3aGVuIGZpbHRlciBpcyBub25lbXB0eS5cclxuICAgICAgICBjb25zdCBvbkZpbHRlciA9IHRoaXMuZmlsdGVyJC5waXBlKGZpbHRlcih2YWx1ZSA9PiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuZHJvcGRvd25PcGVuID0gdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBzdWJzY3JpcHRpb25zXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChvbklucHV0KTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKG9uRmlsdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMubXVsdGlwbGUgJiYgIWNoYW5nZXMubXVsdGlwbGUuZmlyc3RDaGFuZ2UgJiYgY2hhbmdlcy5tdWx0aXBsZS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMubXVsdGlwbGUucHJldmlvdXNWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSB0aGlzLl92YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZSA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHsgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Q2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RJbnB1dFRleHQoKTtcclxuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRCbHVySGFuZGxlcihldmVudDogRXZlbnQpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgYSBjbGljayBvbiB0aGUgdHlwZWFoZWFkIGlzIGluIHByb2dyZXNzLCBqdXN0IHJlZm9jdXMgdGhlIGlucHV0LlxyXG4gICAgICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIGFuIGlzc3VlIGluIElFIHdoZXJlIGNsaWNraW5nIGEgc2Nyb2xsYmFyIGRyb3BzIGZvY3VzLlxyXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVR5cGVhaGVhZCAmJiB0aGlzLnNpbmdsZVR5cGVhaGVhZC5jbGlja2luZykge1xyXG4gICAgICAgICAgICB0aGlzLnNpbmdsZUlucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xvc2UgZHJvcGRvd24gYW5kIHJlc2V0IHRleHQgaW5wdXQgaWYgZm9jdXMgaXMgbG9zdFxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyh0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdldERpc3BsYXkodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2V5IGhhbmRsZXIgZm9yIHNpbmdsZSBzZWxlY3Qgb25seS4gTXVsdGlwbGUgc2VsZWN0IGtleSBoYW5kbGluZyBpcyBpbiBUYWdJbnB1dENvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgaW5wdXRLZXlIYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFN0YW5kYXJkIGtleXMgZm9yIHR5cGVhaGVhZCAodXAvZG93bi9lc2MpXHJcbiAgICAgICAgdGhpcy5fdHlwZWFoZWFkS2V5U2VydmljZS5oYW5kbGVLZXkoZXZlbnQsIHRoaXMuc2luZ2xlVHlwZWFoZWFkKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcclxuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3Bkb3duT3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uIGFzIHRoZSB2YWx1ZSBhbmQgY2xvc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zaW5nbGVUeXBlYWhlYWQuaGlnaGxpZ2h0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0IGZpZWxkLiBJZiBkcm9wZG93biBpc24ndCBvcGVuIHRoZW4gcmVzZXQgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2luZ2xlT3B0aW9uU2VsZWN0ZWQoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lm9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZXZlbnQub3B0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheShvcHRpb246IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdzdHJpbmcnICYmIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSh0aGlzLmRpc3BsYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25bPHN0cmluZz50aGlzLmRpc3BsYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2VsZWN0SW5wdXRUZXh0KCkge1xyXG4gICAgICAgIHRoaXMuc2luZ2xlSW5wdXQubmF0aXZlRWxlbWVudC5zZWxlY3QoKTtcclxuICAgIH1cclxufSIsImV4cG9ydCBjbGFzcyBUYWdJbnB1dEV2ZW50IHtcblxuICAgIHByaXZhdGUgX2RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWc6IGFueSkge31cblxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZWZhdWx0UHJldmVudGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBRdWVyeUxpc3QsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTElEQVRPUlMsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBkZWxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzL2RlbGF5JztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEtleVNlcnZpY2UgfSBmcm9tICcuLi90eXBlYWhlYWQvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4uL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQnO1xyXG5pbXBvcnQgeyBUYWdJbnB1dEV2ZW50IH0gZnJvbSAnLi90YWctaW5wdXQtZXZlbnQnO1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbmNvbnN0IFRBR0lOUFVUX1ZBTFVFX0FDQ0VTU09SID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUYWdJbnB1dENvbXBvbmVudCksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5jb25zdCBUQUdJTlBVVF9WQUxJREFUT1IgPSB7XHJcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGFnSW5wdXRDb21wb25lbnQpLFxyXG4gICAgbXVsdGk6IHRydWVcclxufTtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10YWctaW5wdXQnLFxyXG4gICAgdGVtcGxhdGU6IGA8b2wgW2F0dHIucm9sZV09XCJ0eXBlYWhlYWQgPyAnY29tYm9ib3gnIDogJ25vbmUnXCIgW2F0dHIuYXJpYS1oYXNwb3B1cF09XCJ0eXBlYWhlYWQgPyAnbGlzdGJveCcgOiBudWxsXCI+XG4gICAgPGxpICpuZ0Zvcj1cImxldCB0YWcgb2YgdGFnczsgbGV0IGkgPSBpbmRleFwiIGNsYXNzPVwidXgtdGFnXCJcbiAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgW25nQ2xhc3NdPVwidGFnQ2xhc3ModGFnLCBpLCBpc1NlbGVjdGVkKGkpKVwiXG4gICAgICAgIFthdHRyLnRhYmluZGV4XT1cImRpc2FibGVkID8gbnVsbCA6IDBcIlxuICAgICAgICBbZm9jdXNJZl09XCJpc1NlbGVjdGVkKGkpXCJcbiAgICAgICAgKGNsaWNrKT1cInRhZ0NsaWNrSGFuZGxlcigkZXZlbnQsIHRhZywgaSlcIlxuICAgICAgICAoZm9jdXMpPVwic2VsZWN0VGFnQXQoaSlcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhZ1RlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7dGFnOiB0YWcsIGluZGV4OiBpLCBkaXNhYmxlZDogZGlzYWJsZWQsIGFwaTogdGFnQXBpfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgIDwvbGk+XG4gICAgPGxpICpuZ0lmPVwiaXNJbnB1dFZpc2libGUoKVwiIGNsYXNzPVwidXgtdGFnLWlucHV0XCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgPGlucHV0ICN0YWdJbnB1dCB0eXBlPVwidGV4dFwiIFthdHRyLmlkXT1cImlkXCIgY2xhc3M9XCJ1eC10YWctaW5wdXRcIlxuICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJpbnB1dFwiXG4gICAgICAgICAgICBbY2xhc3MuaW52YWxpZF09XCIhaW5wdXRWYWxpZFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiaGlnaGxpZ2h0ZWRFbGVtZW50Py5pZFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWF1dG9jb21wbGV0ZV09XCJ0eXBlYWhlYWQgPyAnbGlzdCcgOiAnbm9uZSdcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCJ0eXBlYWhlYWQ/LmlkXCJcbiAgICAgICAgICAgIGFyaWEtbXVsdGlsaW5lPVwiZmFsc2VcIlxuICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cImRpc2FibGVkID8gJycgOiAocGxhY2Vob2xkZXIgfHwgJycpXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbZm9jdXNJZl09XCJpc1NlbGVjdGVkKHRhZ3MubGVuZ3RoKVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiaW5wdXRDbGlja0hhbmRsZXIoKVwiXG4gICAgICAgICAgICAoZm9jdXMpPVwiaW5wdXRGb2N1c0hhbmRsZXIoKVwiXG4gICAgICAgICAgICAocGFzdGUpPVwiaW5wdXRQYXN0ZUhhbmRsZXIoJGV2ZW50KVwiPlxuICAgIDwvbGk+XG48L29sPlxuXG48bmctY29udGVudCAjdHlwZWFoZWFkPjwvbmctY29udGVudD5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0VGFnVGVtcGxhdGUgbGV0LXRhZz1cInRhZ1wiIGxldC1pbmRleD1cImluZGV4XCIgbGV0LWRpc2FibGVkPVwiZGlzYWJsZWRcIiBsZXQtYXBpPVwiYXBpXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJ1eC10YWctdGV4dFwiPnt7YXBpLmdldFRhZ0Rpc3BsYXkodGFnKX19PC9zcGFuPlxuICAgIDxidXR0b24gKm5nSWY9XCJhcGkuY2FuUmVtb3ZlVGFnQXQoaW5kZXgpXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwidXgtdGFnLXJlbW92ZVwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJSZW1vdmUgSXRlbVwiXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIChjbGljayk9XCJhcGkucmVtb3ZlVGFnQXQoaW5kZXgpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWNsb3NlXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuPC9uZy10ZW1wbGF0ZT5gLFxyXG4gICAgcHJvdmlkZXJzOiBbVEFHSU5QVVRfVkFMVUVfQUNDRVNTT1IsIFRBR0lOUFVUX1ZBTElEQVRPUl0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxyXG4gICAgICAgICdbY2xhc3MuZm9jdXNdJzogJ2hhc0ZvY3VzKCknLFxyXG4gICAgICAgICdbY2xhc3MuaW52YWxpZF0nOiAnIXZhbGlkIHx8ICFpbnB1dFZhbGlkJ1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGFnSW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJykgaWQ6IHN0cmluZyA9IGB1eC10YWctaW5wdXQtJHsrK3VuaXF1ZUlkfWA7XHJcblxyXG4gICAgQElucHV0KCd0YWdzJylcclxuICAgIGdldCB0YWdzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdGFncykge1xyXG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWdzO1xyXG4gICAgfVxyXG4gICAgc2V0IHRhZ3ModmFsdWU6IGFueVtdKSB7XHJcbiAgICAgICAgdGhpcy5fdGFncyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlSGFuZGxlcih0aGlzLl90YWdzKTtcclxuICAgICAgICB0aGlzLnRhZ3NDaGFuZ2UuZW1pdCh0aGlzLl90YWdzKTtcclxuICAgIH1cclxuXHJcbiAgICBAT3V0cHV0KCkgdGFnc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XHJcblxyXG4gICAgQElucHV0KCdpbnB1dCcpXHJcbiAgICBnZXQgaW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0O1xyXG4gICAgfVxyXG4gICAgc2V0IGlucHV0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9pbnB1dCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaW5wdXRDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQE91dHB1dCgpIGlucHV0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XHJcblxyXG4gICAgQElucHV0KCkgZGlzcGxheTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBhZGRPblBhc3RlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBlbmZvcmNlVGFnTGltaXRzOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBmcmVlSW5wdXQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgQElucHV0KCkgbWF4VGFnczogbnVtYmVyID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIEBJbnB1dCgpIG1pblRhZ3M6IG51bWJlciA9IDA7XHJcbiAgICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nID0gJyc7XHJcbiAgICBASW5wdXQoKSBzaG93VHlwZWFoZWFkT25DbGljazogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgdGFnRGVsaW1pdGVyczogc3RyaW5nID0gJyc7XHJcbiAgICBASW5wdXQoKSB0YWdQYXR0ZXJuOiBSZWdFeHA7XHJcbiAgICBASW5wdXQoKSB0YWdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIHRhZ0NsYXNzOiBUYWdDbGFzc0Z1bmN0aW9uID0gKCkgPT4gdW5kZWZpbmVkO1xyXG4gICAgQElucHV0KCkgdmFsaWRhdGlvbkVycm9yczogYW55ID0ge307XHJcbiAgICBASW5wdXQoJ2NyZWF0ZVRhZycpIGNyZWF0ZVRhZ0hhbmRsZXI6ICh2YWx1ZTogc3RyaW5nKSA9PiBhbnk7XHJcblxyXG4gICAgQE91dHB1dCgpIHRhZ0FkZGluZyA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdBZGRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdJbnZhbGlkYXRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdSZW1vdmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdSZW1vdmVkID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG4gICAgQE91dHB1dCgpIHRhZ0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG5cclxuICAgIEBDb250ZW50Q2hpbGRyZW4oVHlwZWFoZWFkQ29tcG9uZW50KSB0eXBlYWhlYWRRdWVyeTogUXVlcnlMaXN0PFR5cGVhaGVhZENvbXBvbmVudD47XHJcblxyXG4gICAgQFZpZXdDaGlsZCgndGFnSW5wdXQnKSB0YWdJbnB1dDogRWxlbWVudFJlZjtcclxuXHJcbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0VGFnVGVtcGxhdGUnKSBwcml2YXRlIF9kZWZhdWx0VGFnVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyID0gLTE7XHJcblxyXG4gICAgdGFnQXBpOiBUYWdBcGkgPSB7XHJcbiAgICAgICAgZ2V0VGFnRGlzcGxheTogdGhpcy5nZXRUYWdEaXNwbGF5LmJpbmQodGhpcyksXHJcbiAgICAgICAgcmVtb3ZlVGFnQXQ6IHRoaXMucmVtb3ZlVGFnQXQuYmluZCh0aGlzKSxcclxuICAgICAgICBjYW5SZW1vdmVUYWdBdDogdGhpcy5jYW5SZW1vdmVUYWdBdC5iaW5kKHRoaXMpXHJcbiAgICB9O1xyXG5cclxuICAgIHZhbGlkOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIGlucHV0VmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50O1xyXG5cclxuICAgIGhpZ2hsaWdodGVkRWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgcHJpdmF0ZSBfaW5wdXQ6IHN0cmluZyA9ICcnO1xyXG4gICAgcHJpdmF0ZSBfdGFnczogYW55W10gPSBbXTtcclxuICAgIHByaXZhdGUgX29uQ2hhbmdlSGFuZGxlcjogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcclxuICAgIHByaXZhdGUgX29uVG91Y2hlZEhhbmRsZXI6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XHJcbiAgICBwcml2YXRlIF90eXBlYWhlYWRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICAgICAgcHJpdmF0ZSBfdHlwZWFoZWFkS2V5U2VydmljZTogVHlwZWFoZWFkS2V5U2VydmljZSkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRhZ1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnVGVtcGxhdGUgPSB0aGlzLl9kZWZhdWx0VGFnVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgICAgICAvLyBXYXRjaCBmb3Igb3B0aW9uYWwgY2hpbGQgdHlwZWFoZWFkIGNvbnRyb2xcclxuICAgICAgICB0aGlzLmNvbm5lY3RUeXBlYWhlYWQodGhpcy50eXBlYWhlYWRRdWVyeS5maXJzdCk7XHJcbiAgICAgICAgdGhpcy50eXBlYWhlYWRRdWVyeS5jaGFuZ2VzLnN1YnNjcmliZSgocXVlcnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VHlwZWFoZWFkKHF1ZXJ5LmZpcnN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZXMuZGlzYWJsZWQuY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBzZWxlY3Rpb24gYW5kIGNsb3NlIGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHZhbGlkYXRpb24gc3RhdHVzXHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueVtdKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFncyA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLl9vbkNoYW5nZUhhbmRsZXIgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkSGFuZGxlciA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sICh0YWdzIHByb3BlcnR5KS5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgbGV0IHRhZ1JhbmdlRXJyb3IgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ3MgJiYgKHRoaXMudGFncy5sZW5ndGggPCB0aGlzLm1pblRhZ3MgfHwgdGhpcy50YWdzLmxlbmd0aCA+IHRoaXMubWF4VGFncykpIHtcclxuICAgICAgICAgICAgdGFnUmFuZ2VFcnJvciA9IHtcclxuICAgICAgICAgICAgICAgIGdpdmVuOiB0aGlzLnRhZ3MubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pblRhZ3MsXHJcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4VGFnc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yc1sndGFnUmFuZ2VFcnJvciddID0gdGFnUmFuZ2VFcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcclxuICAgIGtleUhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgaW5wdXQgZmllbGQgY3Vyc29yIGxvY2F0aW9uXHJcbiAgICAgICAgY29uc3QgaW5wdXRDdXJzb3JQb3MgPSB0aGlzLnRhZ0lucHV0Lm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgaW5wdXQgZmllbGQgaGFzIGFueSB0ZXh0IHNlbGVjdGVkXHJcbiAgICAgICAgY29uc3QgaGFzU2VsZWN0aW9uID0gdGhpcy50YWdJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnRhZ0lucHV0Lm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uRW5kO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYSB0YWcgaGFzIGZvY3VzXHJcbiAgICAgICAgY29uc3QgdGFnU2VsZWN0ZWQgPSB0aGlzLmlzVmFsaWRUYWdJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBpbnB1dExlbmd0aCA9IHRoaXMuaW5wdXQgPyB0aGlzLmlucHV0Lmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGFycm93IGtleXMgY2FuIG1vdmUgdGhlIHNlbGVjdGlvbi4gT3RoZXJ3aXNlIHRoZSBpbnB1dCBmaWVsZCB0YWtlcyB0aGUgZXZlbnQuXHJcbiAgICAgICAgY29uc3QgY2FuTmF2aWdhdGVMZWZ0ID0gdGFnU2VsZWN0ZWQgfHwgKGlucHV0Q3Vyc29yUG9zIDw9IDAgJiYgIWhhc1NlbGVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgY2FuTmF2aWdhdGVSaWdodCA9IHRhZ1NlbGVjdGVkIHx8IChpbnB1dEN1cnNvclBvcyA+PSBpbnB1dExlbmd0aCAmJiAhaGFzU2VsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gRm9yd2FyZCBrZXkgZXZlbnRzIHRvIHRoZSB0eXBlYWhlYWQgY29tcG9uZW50LlxyXG4gICAgICAgIHRoaXMuX3R5cGVhaGVhZEtleVNlcnZpY2UuaGFuZGxlS2V5KGV2ZW50LCB0aGlzLnR5cGVhaGVhZCk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgdHlwZWFoZWFkIG9wdGlvbiBpcyBoaWdobGlnaHRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMudHlwZWFoZWFkLm9wZW4gJiYgdGhpcy50eXBlYWhlYWQuaGlnaGxpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHR5cGVhaGVhZCBvcHRpb24gYXMgYSB0YWcsIGNsZWFyIHRoZSBpbnB1dCwgYW5kIGNsb3NlIHRoZSBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0VHlwZWFoZWFkKHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGVhaGVhZC5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIGFuZCBhZGQgdGhlIGlucHV0IHRleHQgYXMgYSB0YWcsIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRJbnB1dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja3NwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdEZWxldGUnOlxyXG4gICAgICAgICAgICBjYXNlICdEZWwnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRhZ1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWdBdCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0xlZnQnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcclxuICAgICAgICAgICAgY2FzZSAnUmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGtleXMgaW4gdGhlIHRhZ0RlbGltaXRlcnNcclxuICAgICAgICBpZiAodGhpcy50YWdEZWxpbWl0ZXJzICYmIHRoaXMudGFnRGVsaW1pdGVycy5pbmRleE9mKHRoaXMuZ2V0S2V5Q2hhcihldmVudCkpID49IDApIHtcclxuICAgICAgICAgICAgLy8gQ29tbWl0IHByZXZpb3VzIHRleHRcclxuICAgICAgICAgICAgdGhpcy5jb21taXRJbnB1dCgpO1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXNvdXQnLCBbJyRldmVudCddKVxyXG4gICAgZm9jdXNPdXRIYW5kbGVyKGV2ZW50OiBGb2N1c0V2ZW50KSB7XHJcblxyXG4gICAgICAgIC8vIElmIGEgY2xpY2sgb24gdGhlIHR5cGVhaGVhZCBpcyBpbiBwcm9ncmVzcywgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgYW4gaXNzdWUgaW4gSUUgd2hlcmUgY2xpY2tpbmcgYSBzY3JvbGxiYXIgZHJvcHMgZm9jdXMuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMudHlwZWFoZWFkLmNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBvbiBibHVyXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFnQ2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50LCB0YWc6IGFueSwgaW5kZXg6IG51bWJlcikge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gU2VuZCB0YWdDbGljayBldmVudFxyXG4gICAgICAgIGNvbnN0IHRhZ0NsaWNrRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgIHRoaXMudGFnQ2xpY2suZW1pdCh0YWdDbGlja0V2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBmb2N1cyBpZiBwcmV2ZW50RGVmYXVsdCgpIHdhcyBjYWxsZWRcclxuICAgICAgICBpZiAodGFnQ2xpY2tFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VsZWN0IHRoZSB0YWcgKGZvciBJRSB0aGF0IGRvZXNuJ3QgcHJvcGFnYXRlIGZvY3VzKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0VGFnQXQoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Q2xpY2tIYW5kbGVyKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMuc2hvd1R5cGVhaGVhZE9uQ2xpY2spIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Rm9jdXNIYW5kbGVyKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0UGFzdGVIYW5kbGVyKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWRkT25QYXN0ZSkge1xyXG4gICAgICAgICAgICAvLyBHZXQgdGV4dCBmcm9tIHRoZSBjbGlwYm9hcmRcclxuICAgICAgICAgICAgbGV0IGlucHV0OiBzdHJpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuY2xpcGJvYXJkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgoPGFueT53aW5kb3cpLmNsaXBib2FyZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIG9ubHlcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gKDxhbnk+d2luZG93KS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSBjbGlwYm9hcmQgdGV4dCBkaXJlY3RseVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21taXQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHlwZWFoZWFkT3B0aW9uU2VsZWN0ZWRIYW5kbGVyKGV2ZW50OiBUeXBlYWhlYWRPcHRpb25FdmVudCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgdHlwZWFoZWFkIHNlbmRzIHRoZSBvcHRpb25TZWxlY3RlZCBldmVudCwgY29tbWl0IHRoZSBvYmplY3QgZGlyZWN0bHlcclxuICAgICAgICB0aGlzLmNvbW1pdFR5cGVhaGVhZChldmVudC5vcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBjdXJyZW50IGlucHV0IHZhbHVlIGFuZCBjbGVhciB0aGUgaW5wdXQgZmllbGQgaWYgc3VjY2Vzc2Z1bC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0SW5wdXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tbWl0KHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbW1pdCB0aGUgZ2l2ZW4gdGFnIG9iamVjdCBhbmQgY2xlYXIgdGhlIGlucHV0IGlmIHN1Y2Nlc3NmdWwuXHJcbiAgICAgKi9cclxuICAgIGNvbW1pdFR5cGVhaGVhZCh0YWc6IGFueSkge1xyXG4gICAgICAgIGlmICh0aGlzLmFkZFRhZyh0YWcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbW1pdCB0aGUgZ2l2ZW4gc3RyaW5nIHZhbHVlIGFzIG9uZSBvciBtb3JlIHRhZ3MsIGlmIHZhbGlkYXRpb24gcGFzc2VzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyhzKSB3ZXJlIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbW1pdChpbnB1dDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKGlucHV0ICYmIHRoaXMuZnJlZUlucHV0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgdGFncyBieSB0aGUgdGFnRGVsaW1pdGVycyBpZiBjb25maWd1cmVkXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSB0aGlzLnNwbGl0VGFnSW5wdXQoaW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGFnIHZhbGlkYXRpb24gZm9yIGFsbCBvZiB0aGUgaW5kaXZpZHVhbCB2YWx1ZXNcclxuICAgICAgICAgICAgbGV0IGFsbFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbmV3VGFnIG9mIG5ld1RhZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZVRhZyhuZXdUYWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgdGFncyBpZiBhbGwgYXJlIHZhbGlkXHJcbiAgICAgICAgICAgIGlmIChhbGxWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbmV3VGFnIG9mIG5ld1RhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0aGlzLmNyZWF0ZVRhZyhuZXdUYWcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgbm8gdGFnIGlzIHNlbGVjdGVkLCBzZWxlY3QgdGhlIHJpZ2h0bW9zdCB0YWcuIElmIGEgdGFnIGlzIHNlbGVjdGVkLCByZW1vdmUgaXQuXHJcbiAgICAgKi9cclxuICAgIGJhY2tzcGFjZSgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkVGFnSW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdFRhZ0F0KHRoaXMudGFncy5sZW5ndGggLSAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ0F0KHRoaXMuc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aGUgbGlzdC4gV3JhcHMgYXQgdGhlIGxpbWl0cy5cclxuICAgICAqIEBwYXJhbSBkIFZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoZSBzZWxlY3RlZCBpbmRleCwgaS5lLiAtMSB0byBtb3ZlIGJhY2t3YXJkcywgKzEgdG8gbW92ZSBmb3J3YXJkcy5cclxuICAgICAqL1xyXG4gICAgbW92ZVNlbGVjdGlvbihkOiBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRTZWxlY3RJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCArPSBkO1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gd3JhcHBpbmcgb2Ygc2VsZWN0aW9uIHdoZW4gb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy50YWdzLmxlbmd0aDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPiB0aGlzLnRhZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHZhbHVlIHRvIGRpc3BsYXkgZm9yIHRoZSBnaXZlbiB0YWcuIFVzZXMgZGlzcGxheSBmdW5jdGlvbi9wcm9wZXJ0eSBuYW1lIGlmIHNldCwgb3RoZXJ3aXNlIGFzc3VtZXMgdGhhdCB0aGUgdGFnIGlzIGEgc2ltcGxlIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZ2V0VGFnRGlzcGxheSh0YWc6IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheSh0YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhZ1s8c3RyaW5nPnRoaXMuZGlzcGxheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGluZGV4IGlzIHNlbGVjdGVkICh0YWcgaW5kZXggb3IgaW5wdXQgZmllbGQpLlxyXG4gICAgICovXHJcbiAgICBpc1NlbGVjdGVkKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleC4gRG9lcyBub3RoaW5nIGlmIGRpc2FibGVkIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdFRhZ0F0KHRhZ0luZGV4OiBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRUYWdJbmRleCh0YWdJbmRleCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGFnSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSBpbnB1dCBmaWVsZCwgZ2l2aW5nIGl0IGZvY3VzLiBEb2VzIG5vdGhpbmcgaWYgZGlzYWJsZWQgaXMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc2VsZWN0SW5wdXQoKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4LiBEb2VzIG5vdGhpbmcgaWYgZGlzYWJsZWQgaXMgdHJ1ZSBvciB0aGUgbWluVGFncyBwcm9wZXJ0eSBwcmV2ZW50cyByZW1vdmFsLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWdBdCh0YWdJbmRleDogbnVtYmVyKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNhblJlbW92ZVRhZ0F0KHRhZ0luZGV4KSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdGFnSW5kZXggaXMgaW4gcmFuZ2VcclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnc1t0YWdJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ1JlbW92aW5nRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ1JlbW92aW5nLmVtaXQodGFnUmVtb3ZpbmdFdmVudCk7XHJcbiAgICAgICAgICAgIGlmICghdGFnUmVtb3ZpbmdFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpbnB1dCBmaXJzdCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBkcm9wcGluZyBmb2N1c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YWdcclxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5zcGxpY2UodGFnSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIGFnYWluIHNpbmNlIGluZGljZXMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ1JlbW92ZWQuZW1pdChuZXcgVGFnSW5wdXRFdmVudCh0YWcpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgY2FuUmVtb3ZlVGFnQXQodGFnSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoID4gdGhpcy5taW5UYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGZpZWxkIHNob3VsZCBiZSBhdmFpbGFibGUuXHJcbiAgICAgKi9cclxuICAgIGlzSW5wdXRWaXNpYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoIDwgdGhpcy5tYXhUYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IHBhcnQgb2YgdGhlIGNvbnRyb2wgaGFzIGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBoYXNGb2N1cygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU2VsZWN0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbm5lY3RUeXBlYWhlYWQodHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50eXBlYWhlYWQgPSB0eXBlYWhlYWQ7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkKSB7XHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciBzZWxlY3RlZCBvcHRpb25zXHJcbiAgICAgICAgICAgIHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbiA9IHRoaXMudHlwZWFoZWFkLm9wdGlvblNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLnR5cGVhaGVhZE9wdGlvblNlbGVjdGVkSGFuZGxlci5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciB0aGUgaGlnaGxpZ2h0ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBBZGRlZCBhIGRlbGF5IHRvIG1vdmUgaXQgb3V0IG9mIHRoZSBjdXJyZW50IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGVcclxuICAgICAgICAgICAgdGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkRWxlbWVudENoYW5nZS5waXBlKGRlbGF5KDApKS5zdWJzY3JpYmUoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gdGFnVmFsdWUgd2l0aCB0aGUgdGFnUGF0dGVybiwgaWYgc2V0LiBVcGRhdGUgdmFsaWRhdGlvbkVycm9ycyBvbiB2YWxpZGF0aW9uIGZhaWx1cmUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdmFsaWRhdGVUYWcodGFnVmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBpbnB1dFBhdHRlcm4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5wdXRWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMudGFnUGF0dGVybiAmJiAhdGhpcy50YWdQYXR0ZXJuLnRlc3QodGFnVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlucHV0UGF0dGVybiA9IHtcclxuICAgICAgICAgICAgICAgIGdpdmVuOiB0YWdWYWx1ZSxcclxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHRoaXMudGFnUGF0dGVyblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0VmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRXJyb3JzWydpbnB1dFBhdHRlcm4nXSA9IGlucHV0UGF0dGVybjtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFZhbGlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgdGFnIG9iamVjdCBmb3IgdGhlIGdpdmVuIHRhZ1ZhbHVlLiBJZiBjcmVhdGVUYWdIYW5kbGVyIGlzIHNwZWNpZmllZCwgdXNlIGl0OyBvdGhlcndpc2UgaWYgZGlzcGxheVByb3BlcnR5IGlzIHNwZWNpZmllZCwgY3JlYXRlIGFuIG9iamVjdCB3aXRoIHRoZSB0YWdWYWx1ZSBhcyB0aGUgc2luZ2xlIG5hbWVkIHByb3BlcnR5OyBvdGhlcndpc2UgcmV0dXJuIHRoZSB0YWdWYWx1ZSBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlVGFnKHRhZ1ZhbHVlOiBzdHJpbmcpOiBhbnkge1xyXG4gICAgICAgIGxldCB0YWcgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLmNyZWF0ZVRhZ0hhbmRsZXIgJiYgdHlwZW9mIHRoaXMuY3JlYXRlVGFnSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0YWcgPSB0aGlzLmNyZWF0ZVRhZ0hhbmRsZXIodGFnVmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGFnID0ge307XHJcbiAgICAgICAgICAgIHRhZ1s8c3RyaW5nPnRoaXMuZGlzcGxheV0gPSB0YWdWYWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YWcgPSB0YWdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRhZyBvYmplY3QsIGNhbGxpbmcgdGhlIHRhZ0FkZGluZyBhbmQgdGFnQWRkZWQgZXZlbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyB3YXMgYWRkZWQgdG8gdGhlIHRhZ3MgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWRkVGFnKHRhZzogYW55KTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgbmV3IHRhZyBjYW4gYmUgZGlzcGxheWVkXHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IHRoaXMuZ2V0VGFnRGlzcGxheSh0YWcpO1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheVZhbHVlICYmIHR5cGVvZiBkaXNwbGF5VmFsdWUgPT09ICdzdHJpbmcnICYmIGRpc3BsYXlWYWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdBZGRpbmdFdmVudCA9IG5ldyBUYWdJbnB1dEV2ZW50KHRhZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0FkZGluZy5lbWl0KHRhZ0FkZGluZ0V2ZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGFnQWRkaW5nRXZlbnQuZGVmYXVsdFByZXZlbnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdBZGRlZC5lbWl0KG5ldyBUYWdJbnB1dEV2ZW50KHRhZykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB0YWdJbmRleCBpcyBhIHZhbGlkIHRhZyBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0YWdJbmRleCA+PSAwICYmIHRhZ0luZGV4IDwgdGhpcy50YWdzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gaW5kZXggaXMgYSB2YWxpZCBzZWxlY3Rpb24gaW5kZXggKHRhZ3Mgb3IgaW5wdXQgZmllbGQpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzVmFsaWRTZWxlY3RJbmRleChpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy50YWdzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXkgZXZlbnQsIG1haW5seSBmb3IgSUUgY29tcGF0aWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRLZXlDaGFyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xyXG4gICAgICAgICAgICBjYXNlICdTcGFjZWJhcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnQua2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlucHV0IHN0cmluZyBzcGxpdCBieSB0aGUgdGFnRGVsaW1pdGVycyBjaGFyYWN0ZXJzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNwbGl0VGFnSW5wdXQoaW5wdXQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICAgICAgICBsZXQgdGFnVmFsdWVzID0gW2lucHV0XTtcclxuICAgICAgICBpZiAodGhpcy50YWdEZWxpbWl0ZXJzICYmIHR5cGVvZiB0aGlzLnRhZ0RlbGltaXRlcnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWREZWxpbWl0ZXJzID0gdGhpcy50YWdEZWxpbWl0ZXJzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXJSZWdleCA9IG5ldyBSZWdFeHAoYFske2VzY2FwZWREZWxpbWl0ZXJzfV1gLCAnZycpO1xyXG4gICAgICAgICAgICB0YWdWYWx1ZXMgPSBpbnB1dC5zcGxpdChkZWxpbWl0ZXJSZWdleCkuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFnVmFsdWVzO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIEFQSSBhdmFpbGFibGUgdG8gdGFnIHRlbXBsYXRlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFnQXBpIHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gdGFnLCBhY2NvcmRpbmcgdG8gdGhlIGRpc3BsYXlQcm9wZXJ0eSBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0VGFnRGlzcGxheTogKHRhZzogYW55KSA9PiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBwb3NzaWJsZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVGFnQXQ6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogXHRSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXggY2FuIGJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIGNhblJlbW92ZVRhZ0F0OiAoaW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiB1c2VkIHRvIHJldHVybiBjdXN0b20gY2xhc3MgaW5mb3JtYXRpb24sIGZvciB1c2UgaW4gYG5nQ2xhc3NgLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgVGFnQ2xhc3NGdW5jdGlvbiA9ICh0YWc6IGFueSwgaW5kZXg6IG51bWJlciwgc2VsZWN0ZWQ6IGJvb2xlYW4pID0+IChzdHJpbmcgfCBzdHJpbmdbXSB8IFNldDxzdHJpbmc+KTsiLCJpbXBvcnQgeyBGb2N1c0lmTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb2N1cy1pZi9pbmRleCc7XG5pbXBvcnQgeyBUeXBlYWhlYWRNb2R1bGUgfSBmcm9tICcuLi90eXBlYWhlYWQvaW5kZXgnO1xuaW1wb3J0IHsgVGFnSW5wdXRDb21wb25lbnQgfSBmcm9tICcuL3RhZy1pbnB1dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGUsXG4gICAgICAgIFR5cGVhaGVhZE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1RhZ0lucHV0Q29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtUYWdJbnB1dENvbXBvbmVudF0sXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgVGFnSW5wdXRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvaW5maW5pdGUtc2Nyb2xsL2luZGV4JztcbmltcG9ydCB7IFRhZ0lucHV0TW9kdWxlIH0gZnJvbSAnLi4vdGFnLWlucHV0L2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XG5pbXBvcnQgeyBTZWxlY3RDb21wb25lbnQgfSBmcm9tICcuL3NlbGVjdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTW9kdWxlLFxuICAgICAgICBUYWdJbnB1dE1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbU2VsZWN0Q29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTZWxlY3RDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoVGV4dENvbXBvbmVudCB9IGZyb20gJy4vc2VhcmNoLWNvbXBvbmVudHMvdGV4dC90ZXh0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hEYXRlQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9kYXRlL2RhdGUuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLW91dGxldC9zZWFyY2gtYnVpbGRlci1vdXRsZXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IEJhc2VTZWFyY2hDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1jb21wb25lbnRzL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlck1vZHVsZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci5tb2R1bGUnO1xuaW1wb3J0IHsgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9kYXRlLXJhbmdlL2RhdGUtcmFuZ2UuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaFNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4vc2VhcmNoLWNvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0TW9kdWxlIH0gZnJvbSAnLi4vc2VsZWN0L2luZGV4JztcbmltcG9ydCB7IFBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9wb3BvdmVyL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBEYXRlVGltZVBpY2tlck1vZHVsZSxcbiAgICBQb3BvdmVyTW9kdWxlLFxuICAgIFNlbGVjdE1vZHVsZVxuICBdLFxuICBleHBvcnRzOiBbXG4gICAgU2VhcmNoQnVpbGRlckNvbXBvbmVudCxcbiAgICBTZWFyY2hCdWlsZGVyR3JvdXBDb21wb25lbnQsXG4gICAgQmFzZVNlYXJjaENvbXBvbmVudFxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBTZWFyY2hCdWlsZGVyQ29tcG9uZW50LFxuICAgIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCxcbiAgICBTZWFyY2hUZXh0Q29tcG9uZW50LFxuICAgIFNlYXJjaERhdGVDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50LFxuICAgIFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUsXG4gICAgU2VhcmNoU2VsZWN0Q29tcG9uZW50LFxuICAgIEJhc2VTZWFyY2hDb21wb25lbnRcbiAgXSxcbiAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgU2VhcmNoVGV4dENvbXBvbmVudCxcbiAgICBTZWFyY2hEYXRlQ29tcG9uZW50LFxuICAgIFNlYXJjaERhdGVSYW5nZUNvbXBvbmVudCxcbiAgICBTZWFyY2hTZWxlY3RDb21wb25lbnRcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNpZGVQYW5lbFNlcnZpY2UgfSBmcm9tICcuL3NpZGUtcGFuZWwuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2lkZVBhbmVsQ2xvc2VdJ1xufSlcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxDbG9zZURpcmVjdGl2ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZXJ2aWNlOiBTaWRlUGFuZWxTZXJ2aWNlKSB7IH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBjbGlja0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFNpZGVQYW5lbENvbXBvbmVudCB9IGZyb20gJy4vc2lkZS1wYW5lbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2lkZVBhbmVsQ2xvc2VEaXJlY3RpdmUgfSBmcm9tICcuL3NpZGUtcGFuZWwtY2xvc2UuZGlyZWN0aXZlJztcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBTaWRlUGFuZWxDb21wb25lbnQsXG4gICAgU2lkZVBhbmVsQ2xvc2VEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IEVYUE9SVFMsXG4gICAgZGVjbGFyYXRpb25zOiBFWFBPUlRTXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBEb0NoZWNrLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2xpZGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ0cmFja1wiICN0cmFjayBbY2xhc3MubmFycm93XT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLk5hcnJvd1wiIFtjbGFzcy53aWRlXT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLldpZGVcIiBbY2xhc3MucmFuZ2VdPVwib3B0aW9ucy50eXBlID09PSBzbGlkZXJUeXBlLlJhbmdlXCI+XG5cbiAgICA8IS0tIFNlY3Rpb24gQmVuZWF0aCBMb3dlciBUaHVtYiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidHJhY2stc2VjdGlvbiB0cmFjay1sb3dlclwiIFtzdHlsZS5mbGV4LWdyb3ddPVwidHJhY2tzLmxvd2VyLnNpemVcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJ0cmFja3MubG93ZXIuY29sb3JcIj48L2Rpdj5cblxuICAgIDwhLS0gTG93ZXIgVGh1bWIgQnV0dG9uIC8gTGluZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidGh1bWIgbG93ZXJcIlxuICAgICAgICB1eERyYWdcbiAgICAgICAgcm9sZT1cInNsaWRlclwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICNsb3dlcnRodW1iXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwib3B0aW9ucy50eXBlID09PSBzbGlkZXJUeXBlLlJhbmdlID8gb3B0aW9ucy5oYW5kbGVzLmFyaWEubG93ZXJUaHVtYiA6IG9wdGlvbnMuaGFuZGxlcy5hcmlhLnRodW1iXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJvcHRpb25zPy50cmFjaz8ubWluXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJvcHRpb25zLnR5cGUgPT09IHNsaWRlclR5cGUuUmFuZ2UgPyBnZXRUaHVtYlZhbHVlKHNsaWRlclRodW1iLlVwcGVyKSA6IG9wdGlvbnM/LnRyYWNrPy5tYXhcIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cImdldFRodW1iVmFsdWUoc2xpZGVyVGh1bWIuTG93ZXIpXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZXRleHRdPVwiZ2V0QXJpYVZhbHVlVGV4dChzbGlkZXJUaHVtYi5Mb3dlcilcIlxuICAgICAgICBbc3R5bGUubGVmdC4lXT1cInRodW1icy5sb3dlci5wb3NpdGlvblwiXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVwidGh1bWJzLmxvd2VyLmRyYWdcIlxuICAgICAgICBbc3R5bGUuei1pbmRleF09XCJ0aHVtYnMubG93ZXIub3JkZXJcIlxuICAgICAgICBbY2xhc3MuYnV0dG9uXT1cIm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gc2xpZGVyU3R5bGUuQnV0dG9uXCJcbiAgICAgICAgW2NsYXNzLmxpbmVdPVwib3B0aW9ucy5oYW5kbGVzLnN0eWxlID09PSBzbGlkZXJTdHlsZS5MaW5lXCJcbiAgICAgICAgW2NsYXNzLm5hcnJvd109XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5OYXJyb3dcIlxuICAgICAgICBbY2xhc3Mud2lkZV09XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5XaWRlXCJcbiAgICAgICAgKGRyYWdzdGFydCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdTdGFydCk7IGxvd2VydGh1bWIuZm9jdXMoKVwiXG4gICAgICAgIChkcmFnKT1cInVwZGF0ZVRodW1iUG9zaXRpb24oJGV2ZW50LCBzbGlkZXJUaHVtYi5Mb3dlcilcIlxuICAgICAgICAoZHJhZ2VuZCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdFbmQpXCJcbiAgICAgICAgKG1vdXNlZW50ZXIpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5Mb3dlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXIpXCJcbiAgICAgICAgKG1vdXNlbGVhdmUpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5Mb3dlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZUxlYXZlKVwiXG4gICAgICAgIChmb2N1cyk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlT3ZlcilcIlxuICAgICAgICAoYmx1cik9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlTGVhdmUpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclNuYXAuQWxsLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJzbmFwVG9OZWFyZXN0VGljayhzbGlkZXJUaHVtYi5Mb3dlciwgc2xpZGVyU25hcC5BbGwsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLlBhZ2VEb3duKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLk1ham9yLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uUGFnZVVwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLk1ham9yLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5Ib21lKT1cInNuYXBUb0VuZChzbGlkZXJUaHVtYi5Mb3dlciwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkVuZCk9XCJzbmFwVG9FbmQoc2xpZGVyVGh1bWIuTG93ZXIsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG4gICAgICAgIDwhLS0gTG93ZXIgVGh1bWIgQ2FsbG91dCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAgdG9wIHRvb2x0aXAtbG93ZXJcIiAjbG93ZXJUb29sdGlwXG4gICAgICAgICAgICBbY2xhc3MudG9vbHRpcC1keW5hbWljXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IHNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMgJiYgdGh1bWJzLmxvd2VyLmRyYWcgPT09IGZhbHNlXCJcbiAgICAgICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cInRvb2x0aXBzLmxvd2VyLnZpc2libGUgPyAxIDogMFwiXG4gICAgICAgICAgICBbc3R5bGUubGVmdC5weF09XCJ0b29sdGlwcy5sb3dlci5wb3NpdGlvblwiPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiIFtzdHlsZS5ib3JkZXItdG9wLWNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmJhY2tncm91bmRcIj48L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmJhY2tncm91bmRcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5jb2xvcl09XCJvcHRpb25zLmhhbmRsZXMuY2FsbG91dC5jb2xvclwiPlxuICAgICAgICAgICAgICAgIHt7IHRvb2x0aXBzLmxvd2VyLmxhYmVsIH19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gU2VjdGlvbiBvZiBUcmFjayBCZXR3ZWVuIExvd2VyIGFuZCBVcHBlciBUaHVtYnMgLS0+XG4gICAgPGRpdiBjbGFzcz1cInRyYWNrLXNlY3Rpb24gdHJhY2stcmFuZ2VcIiAqbmdJZj1cIm9wdGlvbnMudHlwZSA9PT0gc2xpZGVyVHlwZS5SYW5nZVwiIFtzdHlsZS5mbGV4LWdyb3ddPVwidHJhY2tzLm1pZGRsZS5zaXplXCIgW3N0eWxlLmJhY2tncm91bmRdPVwidHJhY2tzLm1pZGRsZS5jb2xvclwiPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBVcHBlciBUaHVtYiBCdXR0b24gLyBMaW5lIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJ0aHVtYiB1cHBlclwiXG4gICAgICAgIHV4RHJhZ1xuICAgICAgICByb2xlPVwic2xpZGVyXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgI3VwcGVydGh1bWJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJvcHRpb25zLmhhbmRsZXMuYXJpYS51cHBlclRodW1iXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJnZXRUaHVtYlZhbHVlKHNsaWRlclRodW1iLkxvd2VyKSB8fCBvcHRpb25zPy50cmFjaz8ubWluXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJvcHRpb25zPy50cmFjaz8ubWF4XCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJnZXRUaHVtYlZhbHVlKHNsaWRlclRodW1iLlVwcGVyKVwiXG4gICAgICAgIFthdHRyLmFyaWEtdmFsdWV0ZXh0XT1cImdldEFyaWFWYWx1ZVRleHQoc2xpZGVyVGh1bWIuVXBwZXIpXCJcbiAgICAgICAgW2hpZGRlbl09XCJvcHRpb25zLnR5cGUgIT09IHNsaWRlclR5cGUuUmFuZ2VcIlxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cInRodW1icy51cHBlci5kcmFnXCJcbiAgICAgICAgW3N0eWxlLmxlZnQuJV09XCJ0aHVtYnMudXBwZXIucG9zaXRpb25cIlxuICAgICAgICBbc3R5bGUuei1pbmRleF09XCJ0aHVtYnMudXBwZXIub3JkZXJcIlxuICAgICAgICBbY2xhc3MuYnV0dG9uXT1cIm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gc2xpZGVyU3R5bGUuQnV0dG9uXCJcbiAgICAgICAgW2NsYXNzLmxpbmVdPVwib3B0aW9ucy5oYW5kbGVzLnN0eWxlID09PSBzbGlkZXJTdHlsZS5MaW5lXCJcbiAgICAgICAgW2NsYXNzLm5hcnJvd109XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5OYXJyb3dcIlxuICAgICAgICBbY2xhc3Mud2lkZV09XCJvcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gc2xpZGVyU2l6ZS5XaWRlXCJcbiAgICAgICAgKGRyYWdzdGFydCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdTdGFydCk7IHVwcGVydGh1bWIuZm9jdXMoKVwiXG4gICAgICAgIChkcmFnKT1cInVwZGF0ZVRodW1iUG9zaXRpb24oJGV2ZW50LCBzbGlkZXJUaHVtYi5VcHBlcilcIlxuICAgICAgICAoZHJhZ2VuZCk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50LkRyYWdFbmQpXCJcbiAgICAgICAgKG1vdXNlZW50ZXIpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5VcHBlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXIpXCJcbiAgICAgICAgKG1vdXNlbGVhdmUpPVwidGh1bWJFdmVudChzbGlkZXJUaHVtYi5VcHBlciwgc2xpZGVyVGh1bWJFdmVudC5Nb3VzZUxlYXZlKVwiXG4gICAgICAgIChmb2N1cyk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlT3ZlcilcIlxuICAgICAgICAoYmx1cik9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlTGVhdmUpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclNuYXAuQWxsLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLkFsbCwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJzbmFwVG9OZWFyZXN0VGljayhzbGlkZXJUaHVtYi5VcHBlciwgc2xpZGVyU25hcC5BbGwsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLlBhZ2VEb3duKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLk1ham9yLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uUGFnZVVwKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLk1ham9yLCB0cnVlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5Ib21lKT1cInNuYXBUb0VuZChzbGlkZXJUaHVtYi5VcHBlciwgZmFsc2UpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkVuZCk9XCJzbmFwVG9FbmQoc2xpZGVyVGh1bWIuVXBwZXIsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuXG4gICAgICAgIDwhLS0gVXBwZXIgVGh1bWIgQ2FsbG91dCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAgdG9wIHRvb2x0aXAtdXBwZXJcIiAjdXBwZXJUb29sdGlwXG4gICAgICAgICAgICBbY2xhc3MudG9vbHRpcC1keW5hbWljXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IHNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMgJiYgdGh1bWJzLnVwcGVyLmRyYWcgPT09IGZhbHNlXCJcbiAgICAgICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cInRvb2x0aXBzLnVwcGVyLnZpc2libGUgPyAxIDogMFwiXG4gICAgICAgICAgICBbc3R5bGUubGVmdC5weF09XCJ0b29sdGlwcy51cHBlci5wb3NpdGlvblwiPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiIFtzdHlsZS5ib3JkZXItdG9wLWNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmJhY2tncm91bmRcIj48L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwib3B0aW9ucy50eXBlID09PSBzbGlkZXJUeXBlLlJhbmdlXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XCJvcHRpb25zLmhhbmRsZXMuY2FsbG91dC5iYWNrZ3JvdW5kXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuY29sb3JdPVwib3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuY29sb3JcIj5cbiAgICAgICAgICAgICAgICB7eyB0b29sdGlwcy51cHBlci5sYWJlbCB9fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBTZWN0aW9uIG9mIFRyYWNrIEFib3ZlciBVcHBlciBUaHVtYiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidHJhY2stc2VjdGlvbiB0cmFjay1oaWdoZXJcIiBbc3R5bGUuZmxleC1ncm93XT1cInRyYWNrcy51cHBlci5zaXplXCIgW3N0eWxlLmJhY2tncm91bmRdPVwidHJhY2tzLnVwcGVyLmNvbG9yXCI+PC9kaXY+XG5cbjwvZGl2PlxuXG48IS0tIENoYXJ0IFRpY2tzIGFuZCBUaWNrIExhYmVscyAtLT5cbjxkaXYgY2xhc3M9XCJ0aWNrLWNvbnRhaW5lclwiXG4gICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgKm5nSWY9XCIob3B0aW9ucy50cmFjay50aWNrcy5tYWpvci5zaG93IHx8IG9wdGlvbnMudHJhY2sudGlja3MubWlub3Iuc2hvdykgJiYgb3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlciAhPT0gc2xpZGVyQ2FsbG91dFRyaWdnZXIuRHluYW1pY1wiXG4gICAgW2NsYXNzLnNob3ctbGFiZWxzXT1cIm9wdGlvbnMudHJhY2sudGlja3MubWFqb3IubGFiZWxzIHx8IG9wdGlvbnMudHJhY2sudGlja3MubWlub3IubGFiZWxzXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidGlja1wiXG4gICAgICAgICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzXCJcbiAgICAgICAgW2NsYXNzLm1ham9yXT1cInRpY2sudHlwZSA9PT0gc2xpZGVyVGlja1R5cGUuTWFqb3JcIlxuICAgICAgICBbY2xhc3MubWlub3JdPVwidGljay50eXBlID09PSBzbGlkZXJUaWNrVHlwZS5NaW5vclwiXG4gICAgICAgIFtzdHlsZS5sZWZ0LiVdPVwidGljay5wb3NpdGlvblwiXG4gICAgICAgIFtoaWRkZW5dPVwiIXRpY2suc2hvd1RpY2tzXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpY2staW5kaWNhdG9yXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0aWNrLWxhYmVsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgW2hpZGRlbl09XCIhdGljay5zaG93TGFiZWxzXCI+e3sgdGljay5sYWJlbCB9fTwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIERvQ2hlY2sge1xuXG4gICAgQElucHV0KCkgdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBTbGlkZXJPcHRpb25zO1xuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPFNsaWRlclZhbHVlIHwgbnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8U2xpZGVyVmFsdWUgfCBudW1iZXI+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdsb3dlclRvb2x0aXAnKSBsb3dlclRvb2x0aXA6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndXBwZXJUb29sdGlwJykgdXBwZXJUb29sdGlwOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3RyYWNrJykgdHJhY2s6IEVsZW1lbnRSZWY7XG5cbiAgICAvLyBzdG9yZSBjdXJyZW50IHZhbHVlcyBmb3IgZGVlcCBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgcHJpdmF0ZSBfdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyO1xuXG4gICAgLy8gZXhwb3NlIGVudW1zIHRvIEFuZ3VsYXIgdmlld1xuICAgIHNsaWRlclR5cGUgPSBTbGlkZXJUeXBlO1xuICAgIHNsaWRlclN0eWxlID0gU2xpZGVyU3R5bGU7XG4gICAgc2xpZGVyU2l6ZSA9IFNsaWRlclNpemU7XG4gICAgc2xpZGVyU25hcCA9IFNsaWRlclNuYXA7XG4gICAgc2xpZGVyVGh1bWIgPSBTbGlkZXJUaHVtYjtcbiAgICBzbGlkZXJUaWNrVHlwZSA9IFNsaWRlclRpY2tUeXBlO1xuICAgIHNsaWRlclRodW1iRXZlbnQgPSBTbGlkZXJUaHVtYkV2ZW50O1xuICAgIHNsaWRlckNhbGxvdXRUcmlnZ2VyID0gU2xpZGVyQ2FsbG91dFRyaWdnZXI7XG5cbiAgICB0cmFja3MgPSB7XG4gICAgICAgIGxvd2VyOiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRvb2x0aXBzID0ge1xuICAgICAgICBsb3dlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRodW1icyA9IHtcbiAgICAgICAgbG93ZXI6IHtcbiAgICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWc6IGZhbHNlLFxuICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICBvcmRlcjogMTAwLFxuICAgICAgICAgICAgdmFsdWU6IG51bGwgYXMgbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyOiB7XG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICBkcmFnOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgb3JkZXI6IDEwMSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsIGFzIG51bWJlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0b3JlIGFsbCB0aGUgdGlja3MgdG8gZGlzcGxheVxuICAgIHRpY2tzOiBTbGlkZXJUaWNrW10gPSBbXTtcbiAgICBkZWZhdWx0T3B0aW9uczogU2xpZGVyT3B0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKGNvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlLCBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcblxuICAgICAgICAvLyBzZXR1cCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFNsaWRlclR5cGUuVmFsdWUsXG4gICAgICAgICAgICBoYW5kbGVzOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IFNsaWRlclN0eWxlLkJ1dHRvbixcbiAgICAgICAgICAgICAgICBjYWxsb3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IFNsaWRlckNhbGxvdXRUcmlnZ2VyLk5vbmUsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTInKS50b0hleCgpLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXlib2FyZDoge1xuICAgICAgICAgICAgICAgICAgICBtYWpvcjogNSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyaWE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWI6ICdTbGlkZXIgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICBsb3dlclRodW1iOiAnU2xpZGVyIGxvd2VyIHZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJUaHVtYjogJ1NsaWRlciB1cHBlciB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFNsaWRlclNpemUuV2lkZSxcbiAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc25hcDogU2xpZGVyU25hcC5Ob25lLFxuICAgICAgICAgICAgICAgICAgICBtYWpvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgfCBudW1iZXIgPT4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwczogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogY29sb3JTZXJ2aWNlLmdldENvbG9yKCdncmV5NicpLnRvSGV4KCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjb2xvclNlcnZpY2UuZ2V0Q29sb3IoJ2FjY2VudCcpLnNldEFscGhhKDAuNzUpLnRvUmdiYSgpLFxuICAgICAgICAgICAgICAgICAgICBoaWdoZXI6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTYnKS50b0hleCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlcygpO1xuXG4gICAgICAgIHRoaXMuc2V0VGh1bWJTdGF0ZShTbGlkZXJUaHVtYi5Mb3dlciwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKFNsaWRlclRodW1iLlVwcGVyLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGluaXRpYWwgdmFsdWVcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5uZXh0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCB0aGlzLl92YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHBlcnNpc3RlbnQgdG9vbHRpcHMgd2lsbCBuZWVkIHBvc2l0aW9uZWQgY29ycmVjdGx5IGF0IHRoaXMgc3RhZ2VcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5Mb3dlcik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgICAgIC8vIG1hcmsgYXMgZGlydHlcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzbmFwVG9OZWFyZXN0VGljayh0aHVtYjogU2xpZGVyVGh1bWIsIHNuYXBUYXJnZXQ6IFNsaWRlclNuYXAsIGZvcndhcmRzOiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSBmb3IgdGhlIHRodW1iXG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tzIC0gcmVtb3ZlIGFueSB0aWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gaXRcbiAgICAgICAgY29uc3QgY2xvc2VzdCA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHNuYXBUYXJnZXQpXG4gICAgICAgICAgICAuZmlsdGVyKHRpY2sgPT4gdGljay52YWx1ZSAhPT0gdmFsdWUpXG4gICAgICAgICAgICAuZmluZCh0aWNrID0+IGZvcndhcmRzID8gdGljay52YWx1ZSA+IHZhbHVlIDogdGljay52YWx1ZSA8IHZhbHVlKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIHRpY2tzIHRoZW4gbW92ZSBieSBhIHByZWRlZmluZWQgYW1vdW50XG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIGNsb3Nlc3QudmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzbmFwVGFyZ2V0ID09PSBTbGlkZXJTbmFwLk1ham9yID8gdGhpcy5vcHRpb25zLmhhbmRsZXMua2V5Ym9hcmQubWFqb3IgOiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5rZXlib2FyZC5taW5vcjtcblxuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgdmFsdWUgKyAoZm9yd2FyZHMgPyBzdGVwIDogLXN0ZXApKSk7XG5cbiAgICB9XG5cbiAgICBzbmFwVG9FbmQodGh1bWI6IFNsaWRlclRodW1iLCBmb3J3YXJkczogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgZm9yd2FyZHMgPyB0aGlzLm9wdGlvbnMudHJhY2subWF4IDogdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpO1xuICAgIH1cblxuICAgIGdldFRodW1iVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuZm9ybWF0dGVyKHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJTdGF0ZSh0aHVtYjogU2xpZGVyVGh1bWIpIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMudGh1bWJzLmxvd2VyIDogdGhpcy50aHVtYnMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlN0YXRlKHRodW1iOiBTbGlkZXJUaHVtYiwgaG92ZXI6IGJvb2xlYW4sIGRyYWc6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy5sb3dlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMubG93ZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy51cHBlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMudXBwZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXBzXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcHModGh1bWIpO1xuICAgIH1cblxuICAgIHRodW1iRXZlbnQodGh1bWI6IFNsaWRlclRodW1iLCBldmVudDogU2xpZGVyVGh1bWJFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCB0aHVtYiBzdGF0ZVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJhc2VkIHVwb24gZXZlbnRcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ1N0YXJ0OlxuICAgICAgICAgICAgICAgIHN0YXRlLmRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ0VuZDpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXI6XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTW91c2VMZWF2ZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTm9uZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgc3RhdGVcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKHRodW1iLCBzdGF0ZS5ob3Zlciwgc3RhdGUuZHJhZyk7XG4gICAgfVxuXG4gICAgZ2V0QXJpYVZhbHVlVGV4dCh0aHVtYjogU2xpZGVyVGh1bWIpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdGh1bWIgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFRodW1iVmFsdWUodGh1bWIpO1xuXG4gICAgICAgIC8vIGdldCBhbGwgdGhlIHRpY2tzXG4gICAgICAgIGNvbnN0IHRpY2sgPSB0aGlzLnRpY2tzLmZpbmQoX3RpY2sgPT4gX3RpY2sudmFsdWUgPT09IHZhbHVlKTtcblxuICAgICAgICBpZiAodGljayAmJiB0aWNrLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGljay5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBzaW1wbHkgZGlzcGxheSB0aGUgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZvcm1hdHRlZFZhbHVlKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBzKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlcikge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlckNhbGxvdXRUcmlnZ2VyLlBlcnNpc3RlbnQ6XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyQ2FsbG91dFRyaWdnZXIuRHJhZzpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5Ib3ZlcjpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuaG92ZXIgfHwgc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5EeW5hbWljOlxuICAgICAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgdGh1bWJcbiAgICAgICAgdGhpcy5nZXRUb29sdGlwKHRodW1iKS52aXNpYmxlID0gdmlzaWJsZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgdGV4dFxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFBvc2l0aW9uKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iOiBTbGlkZXJUaHVtYikge1xuXG4gICAgICAgIC8vIGdldCB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmdldFRvb2x0aXAodGh1bWIpO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBmb3JtYXR0ZWQgbGFiZWxcbiAgICAgICAgdG9vbHRpcC5sYWJlbCA9IHRoaXMuZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWIpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwRWxlbWVudCh0aHVtYjogU2xpZGVyVGh1bWIpOiBFbGVtZW50UmVmIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMubG93ZXJUb29sdGlwIDogdGhpcy51cHBlclRvb2x0aXA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwKHRodW1iOiBTbGlkZXJUaHVtYikge1xuICAgICAgICByZXR1cm4gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gdGhpcy50b29sdGlwcy5sb3dlciA6IHRoaXMudG9vbHRpcHMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUb29sdGlwUG9zaXRpb24odGh1bWI6IFNsaWRlclRodW1iKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuZ2V0VG9vbHRpcCh0aHVtYik7XG5cbiAgICAgICAgLy8gaWYgdG9vbHRpcCBpcyBub3QgdmlzaWJsZSB0aGVuIHN0b3AgaGVyZVxuICAgICAgICBpZiAodG9vbHRpcC52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRvb2x0aXBFbGVtZW50ID0gdGhpcy5nZXRUb29sdGlwRWxlbWVudCh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50IHdpZHRoc1xuICAgICAgICBsZXQgdGh1bWJXaWR0aDogbnVtYmVyO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gU2xpZGVyU3R5bGUuQnV0dG9uKSB7XG4gICAgICAgICAgICB0aHVtYldpZHRoID0gdGhpcy5vcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gU2xpZGVyU2l6ZS5OYXJyb3cgPyAxNiA6IDI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGh1bWJXaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9vbHRpcFdpZHRoID0gdG9vbHRpcEVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvb2x0aXBzIG5ldyBwb3NpdGlvblxuICAgICAgICBsZXQgdG9vbHRpcFBvc2l0aW9uID0gTWF0aC5jZWlsKCh0b29sdGlwV2lkdGggLSB0aHVtYldpZHRoKSAvIDIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uXG4gICAgICAgIHRvb2x0aXAucG9zaXRpb24gPSAtdG9vbHRpcFBvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5SYW5nZSAmJiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IFNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFRvb2x0aXBPdmVybGFwKHRvb2x0aXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmV2ZW50VG9vbHRpcE92ZXJsYXAodG9vbHRpcDogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy5sb3dlci5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdXBwZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy51cHBlci5wb3NpdGlvbjtcblxuICAgICAgICBjb25zdCBsb3dlcldpZHRoID0gdGhpcy5sb3dlclRvb2x0aXAubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHVwcGVyV2lkdGggPSB0aGlzLnVwcGVyVG9vbHRpcC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcblxuICAgICAgICBjb25zdCBkaWZmID0gKGxvd2VyICsgbG93ZXJXaWR0aCkgLSAodXBwZXIgLSB1cHBlcldpZHRoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcHMgYXJlIGNsb3NlciB0aGFuIDE2cHggdGhlbiBhZGp1c3Qgc28gdGhlIGRvbnQgbW92ZSBhbnkgY2xvc2VcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy5sb3dlciAmJiB0aGlzLnRodW1icy5sb3dlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gLT0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy51cHBlciAmJiB0aGlzLnRodW1icy51cHBlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gKz0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRodW1iUG9zaXRpb24oZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCB0aHVtYjogU2xpZGVyVGh1bWIpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgZXZlbnQgcG9zaXRpb24gLSBlaXRoZXIgbW91c2Ugb3IgdG91Y2hcbiAgICAgICAgbGV0IGV2ZW50UG9zaXRpb24gPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDAgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBudWxsO1xuXG4gICAgICAgIC8vIGlmIGV2ZW50IHBvc2l0aW9uIGlzIG51bGwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoZXZlbnRQb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGxldCBtb3VzZVggPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBldmVudFBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGdldCB0cmFjayBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICBsZXQgdHJhY2tCb3VuZHMgPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gcmVzdHJpY3QgdGhlIHZhbHVlIHdpdGhpbiB0aGUgcmFuZ2Ugc2l6ZVxuICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLmNsYW1wKG1vdXNlWCAtIHRyYWNrQm91bmRzLmxlZnQsIDAsIHRyYWNrQm91bmRzLndpZHRoKTtcblxuICAgICAgICAvLyBnZXQgZnJhY3Rpb24gcmVwcmVzZW50YXRpb24gb2YgbG9jYXRpb24gd2l0aGluIHRoZSB0cmFja1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSAocG9zaXRpb24gLyB0cmFja0JvdW5kcy53aWR0aCk7XG5cbiAgICAgICAgLy8gY29udmVydCB0byB2YWx1ZSB3aXRoaW4gdGhlIHJhbmdlXG4gICAgICAgIGxldCB2YWx1ZSA9ICgodGhpcy5vcHRpb25zLnRyYWNrLm1heCAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pICogZnJhY3Rpb24pICsgdGhpcy5vcHRpb25zLnRyYWNrLm1pbjtcblxuICAgICAgICAvLyBlbnN1cmUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIHZhbHVlKTtcblxuICAgICAgICAvLyBzbmFwIHRvIGEgdGljayBpZiByZXF1aXJlZFxuICAgICAgICB2YWx1ZSA9IHRoaXMuc25hcFRvVGljayh2YWx1ZSwgdGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVPcmRlcih0aHVtYik7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRvb2x0aXAgdGV4dCAmIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQodGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYWxsIHZpc2libGUgdG9vbHRpcHNcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwUG9zaXRpb24oU2xpZGVyVGh1bWIuTG93ZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgLy8gbWFyayBhcyBkaXJ0eSBmb3IgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU9yZGVyKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCBsb3dlciA9IHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IDEwMSA6IDEwMDtcbiAgICAgICAgbGV0IHVwcGVyID0gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gMTAwIDogMTAxO1xuXG4gICAgICAgIC8vIFRoZSBtb3N0IHJlY2VudGx5IHVzZWQgdGh1bWIgc2hvdWxkIGJlIGFib3ZlXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLm9yZGVyID0gbG93ZXI7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLm9yZGVyID0gdXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaWNrRGlzdGFuY2VzKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYiwgc25hcFRhcmdldDogU2xpZGVyU25hcCk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gaWYgc25hcCB0YXJnZXQgaXMgbm9uZSB0aGVuIHJldHVybiBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICBpZiAoc25hcFRhcmdldCA9PT0gU2xpZGVyU25hcC5Ob25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZmlsdGVyZWQgdGlja3NcbiAgICAgICAgbGV0IHRpY2tzOiBTbGlkZXJUaWNrW107XG5cbiAgICAgICAgc3dpdGNoIChzbmFwVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NaW5vcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NaW5vcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NYWpvcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBsaW1pdFxuICAgICAgICBsZXQgbG93ZXJMaW1pdCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCB1cHBlckxpbWl0ID0gdGhpcy5vcHRpb25zLnRyYWNrLm1heDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy50aHVtYnMudXBwZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLlVwcGVyKSB7XG4gICAgICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy50aHVtYnMubG93ZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHRpY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWNrcy5maWx0ZXIodGljayA9PiB0aWNrLnZhbHVlID49IGxvd2VyTGltaXQgJiYgdGljay52YWx1ZSA8PSB1cHBlckxpbWl0KTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY2xvc2UgdGlja3MgaW4gdGhlIHZhbGlkIHJhbmdlIHRoZW4gZG9udCBzbmFwXG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZS5zb3J0KCh0aWNrT25lLCB0aWNrVHdvKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRpY2tPbmVEZWx0YSA9IE1hdGgubWF4KHRpY2tPbmUudmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tPbmUudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tUd29EZWx0YSA9IE1hdGgubWF4KHRpY2tUd28udmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tUd28udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRpY2tPbmVEZWx0YSAtIHRpY2tUd29EZWx0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzbmFwVG9UaWNrKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgdGlja0Rpc3RhbmNlcyA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5zbmFwKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdGlja3MgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGlmICh0aWNrRGlzdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tcbiAgICAgICAgcmV0dXJuIHRpY2tEaXN0YW5jZXNbMF0udmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgLy8gaWYgc2xpZGVyIGlzIG5vdCBhIHJhbmdlIHZhbHVlIGlzIGFsd2F5cyB2YWxpZCBwcm92aWRpbmcgaXQgaXMgd2l0aGluIHRoZSBjaGFydCBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBTbGlkZXJUeXBlLlZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIHRoaXMub3B0aW9ucy50cmFjay5tYXgpLCB0aGlzLm9wdGlvbnMudHJhY2subWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIHdpdGggY2hhcnQgcmFuZ2VzXG4gICAgICAgIGlmICh2YWx1ZSA+IHRoaXMub3B0aW9ucy50cmFjay5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIgPyBNYXRoLm1pbih0aGlzLm9wdGlvbnMudHJhY2subWF4LCB0aGlzLnRodW1icy51cHBlci52YWx1ZSkgOiB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5vcHRpb25zLnRyYWNrLm1pbikge1xuICAgICAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5VcHBlciA/IE1hdGgubWF4KHRoaXMub3B0aW9ucy50cmFjay5taW4sIHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlKSA6IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayB0byBtYWtlIHN1cmUgbG93ZXIgdGh1bWIgY2Fubm90IGdvIGFib3ZlIGhpZ2hlciBhbmQgdmljZSB2ZXJzYVxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRodW1icy51cHBlci52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID8gdmFsdWUgOiB0aGlzLnRodW1icy51cHBlci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aHVtYiA9PT0gU2xpZGVyVGh1bWIuVXBwZXIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPyB2YWx1ZSA6IHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVPcHRpb25zKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFkZCBpbiB0aGUgZGVmYXVsdCBvcHRpb25zIHRoYXQgdXNlciBoYXNuJ3Qgc3BlY2lmaWVkXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuZGVlcE1lcmdlKHRoaXMub3B0aW9ucyB8fCB7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFja0NvbG9ycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpY2tzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVWYWx1ZXMoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb3dlclZhbHVlID0gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUubG93O1xuICAgICAgICBsZXQgdXBwZXJWYWx1ZSA9IHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJyA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmhpZ2g7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdmFsdWVzXG4gICAgICAgIGxvd2VyVmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUoU2xpZGVyVGh1bWIuTG93ZXIsIE51bWJlcihsb3dlclZhbHVlLnRvRml4ZWQoNCkpKTtcbiAgICAgICAgdXBwZXJWYWx1ZSA9IHRoaXMudmFsaWRhdGVWYWx1ZShTbGlkZXJUaHVtYi5VcHBlciwgTnVtYmVyKHVwcGVyVmFsdWUudG9GaXhlZCg0KSkpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGFzIHBlcmNlbnRhZ2VzXG4gICAgICAgIGxldCBsb3dlclBvc2l0aW9uID0gKCgobG93ZXJWYWx1ZSAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pIC8gKHRoaXMub3B0aW9ucy50cmFjay5tYXggLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSkgKiAxMDApO1xuICAgICAgICBsZXQgdXBwZXJQb3NpdGlvbiA9ICgoKHVwcGVyVmFsdWUgLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSAvICh0aGlzLm9wdGlvbnMudHJhY2subWF4IC0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpICogMTAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGh1bWIgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLnBvc2l0aW9uID0gbG93ZXJQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50aHVtYnMudXBwZXIucG9zaXRpb24gPSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhY2sgc2l6ZXNcbiAgICAgICAgdGhpcy50cmFja3MubG93ZXIuc2l6ZSA9IGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLm1pZGRsZS5zaXplID0gdXBwZXJQb3NpdGlvbiAtIGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLnVwcGVyLnNpemUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IDEwMCAtIGxvd2VyUG9zaXRpb24gOiAxMDAgLSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgaW5wdXRcbiAgICAgICAgdGhpcy5zZXRWYWx1ZShsb3dlclZhbHVlLCB1cHBlclZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFZhbHVlKGxvdzogbnVtYmVyLCBoaWdoPzogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPSBsb3c7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID0gaGlnaDtcblxuICAgICAgICBsZXQgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY2xvbmUodGhpcy5fdmFsdWUpO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IGxvdyA6IHsgbG93OiBsb3csIGhpZ2g6IGhpZ2ggfTtcblxuICAgICAgICAvLyBjYWxsIHRoZSBldmVudCBlbWl0dGVyIGlmIGNoYW5nZXMgb2NjdXJlZFxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCBwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KFNsaWRlclRodW1iLkxvd2VyKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQoU2xpZGVyVGh1bWIuVXBwZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIGZvcndhcmQgdGhlc2UgY2hhbmdlcyB0byB0aGUgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnRodW1icy5sb3dlci52YWx1ZSwgdGhpcy50aHVtYnMudXBwZXIudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVGlja3MoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRpY2sgb3B0aW9uc1xuICAgICAgICBjb25zdCBtYWpvck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudHJhY2sudGlja3MubWFqb3I7XG4gICAgICAgIGNvbnN0IG1pbm9yT3B0aW9ucyA9IHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5taW5vcjtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzaG91bGQgc2hvdyB0aWNrc1xuICAgICAgICBpZiAobWFqb3JPcHRpb25zLnNob3cgPT09IGZhbHNlICYmIG1pbm9yT3B0aW9ucy5zaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2tzIGZvciBib3RoIG1ham9yIGFuZCBtaW5vciAtIG9ubHkgZ2V0IHRoZSBvbmVzIHRvIGJlIHNob3duXG4gICAgICAgIGNvbnN0IG1ham9yVGlja3MgPSB0aGlzLmdldFRpY2tzKG1ham9yT3B0aW9ucywgU2xpZGVyVGlja1R5cGUuTWFqb3IpLmZpbHRlcih0aWNrID0+IHRpY2suc2hvd1RpY2tzKTtcbiAgICAgICAgY29uc3QgbWlub3JUaWNrcyA9IHRoaXMuZ2V0VGlja3MobWlub3JPcHRpb25zLCBTbGlkZXJUaWNrVHlwZS5NaW5vcikuZmlsdGVyKHRpY2sgPT4gdGljay5zaG93VGlja3MpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgbWlub3IgdGlja3MgdGhhdCBhcmUgb24gYSBtYWpvciBpbnRlcnZhbFxuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy51bmlvblRpY2tzKG1ham9yVGlja3MsIG1pbm9yVGlja3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVHJhY2tDb2xvcnMoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IGNvbG9ycyBmb3IgZWFjaCBwYXJ0IG9mIHRoZSB0cmFja1xuICAgICAgICBjb25zdCB7IGxvd2VyLCByYW5nZSwgaGlnaGVyIH0gPSB0aGlzLm9wdGlvbnMudHJhY2suY29sb3JzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29udHJvbGxlciB2YWx1ZVxuICAgICAgICB0aGlzLnRyYWNrcy5sb3dlci5jb2xvciA9IHR5cGVvZiBsb3dlciA9PT0gJ3N0cmluZycgPyBsb3dlciA6IGBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICR7bG93ZXIuam9pbignLCAnKX0pYDtcbiAgICAgICAgdGhpcy50cmFja3MubWlkZGxlLmNvbG9yID0gdHlwZW9mIHJhbmdlID09PSAnc3RyaW5nJyA/IHJhbmdlIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtyYW5nZS5qb2luKCcsICcpfSlgO1xuICAgICAgICB0aGlzLnRyYWNrcy51cHBlci5jb2xvciA9IHR5cGVvZiBoaWdoZXIgPT09ICdzdHJpbmcnID8gaGlnaGVyIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtoaWdoZXIuam9pbignLCAnKX0pYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFN0ZXBzKHN0ZXBzOiBudW1iZXIgfCBudW1iZXJbXSk6IG51bWJlcltdIHtcblxuICAgICAgICAvLyBpZiB0aGV5IGFyZSBhbHJlYWR5IGFuIGFycmF5IGp1c3QgcmV0dXJuIGl0XG4gICAgICAgIGlmIChzdGVwcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIHN0ZXBzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47IGlkeCA8PSB0aGlzLm9wdGlvbnMudHJhY2subWF4OyBpZHggKz0gc3RlcHMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGlja3Mob3B0aW9uczogU2xpZGVyVGlja09wdGlvbnMsIHR5cGU6IFNsaWRlclRpY2tUeXBlKTogU2xpZGVyVGlja1tdIHtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgdGhlIHRpY2tzIGFuZCBzdGVwIHBvaW50c1xuICAgICAgICBsZXQgc3RlcHMgPSB0aGlzLmdldFN0ZXBzKG9wdGlvbnMuc3RlcHMpO1xuXG4gICAgICAgIC8vIGdldCBzb21lIGNoYXJ0IG9wdGlvbnNcbiAgICAgICAgbGV0IG1pbiA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCBtYXggPSB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBzdGVwIHRvIGEgc2xpZGVyIHRpY2sgYW5kIHJlbW92ZSBpbnZhbGlkIHRpY2tzXG4gICAgICAgIHJldHVybiBzdGVwcy5tYXAoc3RlcCA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNob3dUaWNrczogb3B0aW9ucy5zaG93LFxuICAgICAgICAgICAgICAgIHNob3dMYWJlbHM6IG9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICgoc3RlcCAtIG1pbikgLyAobWF4IC0gbWluKSkgKiAxMDAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0ZXAsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbnMuZm9ybWF0dGVyKHN0ZXApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIodGljayA9PiB0aWNrLnBvc2l0aW9uID49IDAgJiYgdGljay5wb3NpdGlvbiA8PSAxMDApO1xuICAgIH1cblxuICAgIHByaXZhdGUgdW5pb25UaWNrcyhtYWpvclRpY2tzOiBTbGlkZXJUaWNrW10sIG1pbm9yVGlja3M6IFNsaWRlclRpY2tbXSk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCB0aWNrcyBjb21iaW5lZCByZW1vdmluZyBhbnkgbWlub3IgdGlja3Mgd2l0aCB0aGUgc2FtZSB2YWx1ZSBhcyBtYWpvciB0aWNrc1xuICAgICAgICByZXR1cm4gbWFqb3JUaWNrcy5jb25jYXQobWlub3JUaWNrcylcbiAgICAgICAgICAgIC5maWx0ZXIoKHRpY2ssIGluZGV4LCBhcnJheSkgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciB8fCAhYXJyYXkuZmluZCh0ayA9PiB0ay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciAmJiB0ay5wb3NpdGlvbiA9PT0gdGljay5wb3NpdGlvbikpXG4gICAgICAgICAgICAuc29ydCgodDEsIHQyKSA9PiB0MS52YWx1ZSAtIHQyLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlZXBNZXJnZTxUPihkZXN0aW5hdGlvbjogVCwgc291cmNlOiBUKTogVCB7XG5cbiAgICAgICAgLy8gbG9vcCB0aG91Z2ggYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHByb3BlcnR5IGFjcm9zc1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGFuZCBpcyBub3QgYW4gb2JqZWN0IHRoZW4gc2tpcFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltwcm9wXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgcHJvcGVydHkgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbltwcm9wXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIG9iamVjdCB0aGVuIHBlcmZvcm0gYSByZWN1cnNpdmUgY2hlY2tcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gdGhpcy5kZWVwTWVyZ2UoZGVzdGluYXRpb25bcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZXRlY3RWYWx1ZUNoYW5nZSh2YWx1ZTE6IG51bWJlciB8IFNsaWRlclZhbHVlLCB2YWx1ZTI6IG51bWJlciB8IFNsaWRlclZhbHVlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY29tcGFyZSB0d28gc2xpZGVyIHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMSkgJiYgdGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMikpIHtcblxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0cyBpbiB0aGUgY29ycmVjdCB0eXBlc1xuICAgICAgICAgICAgY29uc3Qgb2JqMSA9IHZhbHVlMSBhcyBTbGlkZXJWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9iajIgPSB2YWx1ZTIgYXMgU2xpZGVyVmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBvYmoxLmxvdyAhPT0gb2JqMi5sb3cgfHwgb2JqMS5oaWdoICE9PSBvYmoyLmhpZ2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3QgYSBzbGlkZXIgdmFsdWUgLSBzaG91bGQgYmUgbnVtYmVyIG9mIG51bGxhYmxlIHR5cGUgLSBjb21wYXJlIG5vcm1hbGx5XG4gICAgICAgIHJldHVybiB2YWx1ZTEgIT09IHZhbHVlMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb25mb3JtcyB0byB0aGVcbiAgICAgKiBTbGlkZXJWYWx1ZSBpbnRlcmZhY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG9iamVjdCB0byBjaGVjayAtIHRoaXMgbXVzdCBiZSB0eXBlIGFueVxuICAgICAqL1xuICAgIHByaXZhdGUgaXNTbGlkZXJWYWx1ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IGNoZWNrIGlmIGl0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgICAgICByZXR1cm4gJ2xvdycgaW4gdmFsdWUgJiYgJ2hpZ2gnIGluIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xvbmUodmFsdWU6IG51bWJlciB8IFNsaWRlclZhbHVlKTogbnVtYmVyIHwgU2xpZGVyVmFsdWUge1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIG5vdCBhbiBvYmplY3Qgc2ltcGx5IHJldHVybiB0aGUgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0geyAuLi52YWx1ZSB9O1xuXG4gICAgICAgIC8vIGRlbGV0ZSByZW1vdmUgdGhlIHZhbHVlIGZyb20gdGhlIG9sZCBvYmplY3RcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBuZXcgaW5zdGFuY2Ugb2YgdGhlIG9iamVjdFxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUeXBlIHtcbiAgICBWYWx1ZSxcbiAgICBSYW5nZVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTdHlsZSB7XG4gICAgQnV0dG9uLFxuICAgIExpbmVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyU2l6ZSB7XG4gICAgTmFycm93LFxuICAgIFdpZGVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyQ2FsbG91dFRyaWdnZXIge1xuICAgIE5vbmUsXG4gICAgSG92ZXIsXG4gICAgRHJhZyxcbiAgICBQZXJzaXN0ZW50LFxuICAgIER5bmFtaWNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJWYWx1ZSB7XG4gICAgbG93OiBudW1iZXI7XG4gICAgaGlnaDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTbmFwIHtcbiAgICBOb25lLFxuICAgIE1pbm9yLFxuICAgIE1ham9yLFxuICAgIEFsbFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaWNrVHlwZSB7XG4gICAgTWlub3IsXG4gICAgTWFqb3Jcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJPcHRpb25zIHtcbiAgICB0eXBlPzogU2xpZGVyVHlwZTtcbiAgICBoYW5kbGVzPzogU2xpZGVySGFuZGxlT3B0aW9ucztcbiAgICB0cmFjaz86IFNsaWRlclRyYWNrT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJIYW5kbGVPcHRpb25zIHtcbiAgICBzdHlsZT86IFNsaWRlclN0eWxlO1xuICAgIGNhbGxvdXQ/OiBTbGlkZXJDYWxsb3V0O1xuICAgIGtleWJvYXJkPzogU2xpZGVyS2V5Ym9hcmRPcHRpb25zO1xuICAgIGFyaWE/OiBTbGlkZXJBcmlhT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJBcmlhT3B0aW9ucyB7XG4gICAgdGh1bWI6IHN0cmluZztcbiAgICBsb3dlclRodW1iOiBzdHJpbmc7XG4gICAgdXBwZXJUaHVtYjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlcktleWJvYXJkT3B0aW9ucyB7XG4gICAgbWFqb3I/OiBudW1iZXI7XG4gICAgbWlub3I/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVHJhY2tPcHRpb25zIHtcbiAgICBoZWlnaHQ/OiBTbGlkZXJTaXplO1xuICAgIG1pbj86IG51bWJlcjtcbiAgICBtYXg/OiBudW1iZXI7XG4gICAgdGlja3M/OiBTbGlkZXJUaWNrc09wdGlvbnM7XG4gICAgY29sb3JzPzogU2xpZGVyVHJhY2tDb2xvcnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja3NPcHRpb25zIHtcbiAgICBzbmFwPzogU2xpZGVyU25hcDtcbiAgICBtYWpvcj86IFNsaWRlclRpY2tPcHRpb25zO1xuICAgIG1pbm9yPzogU2xpZGVyVGlja09wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja09wdGlvbnMge1xuICAgIHNob3c/OiBib29sZWFuO1xuICAgIHN0ZXBzPzogbnVtYmVyIHwgbnVtYmVyW107XG4gICAgbGFiZWxzPzogYm9vbGVhbjtcbiAgICBmb3JtYXR0ZXI/OiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRpY2sge1xuICAgIHNob3dUaWNrczogYm9vbGVhbjtcbiAgICBzaG93TGFiZWxzOiBib29sZWFuO1xuICAgIHR5cGU6IFNsaWRlclRpY2tUeXBlO1xuICAgIHBvc2l0aW9uOiBudW1iZXI7XG4gICAgdmFsdWU6IG51bWJlcjtcbiAgICBsYWJlbDogc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRyYWNrQ29sb3JzIHtcbiAgICBsb3dlcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHJhbmdlPzogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgaGlnaGVyPzogc3RyaW5nIHwgc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyQ2FsbG91dCB7XG4gICAgdHJpZ2dlcj86IFNsaWRlckNhbGxvdXRUcmlnZ2VyO1xuICAgIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gICAgY29sb3I/OiBzdHJpbmc7XG4gICAgZm9ybWF0dGVyPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyVGh1bWJFdmVudCB7XG4gICAgTm9uZSxcbiAgICBNb3VzZU92ZXIsXG4gICAgTW91c2VMZWF2ZSxcbiAgICBEcmFnU3RhcnQsXG4gICAgRHJhZ0VuZFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaHVtYiB7XG4gICAgTG93ZXIsXG4gICAgVXBwZXJcbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcblxuaW1wb3J0IHsgU2xpZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGUsXG4gICAgICAgIERyYWdNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTbGlkZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NsaWRlckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyTW9kdWxlIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5pbXBvcnQgeyBDb2xvcklkZW50aWZpZXIgfSBmcm9tICcuLi8uLi9pbmRleCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc3BhcmsnLFxuICAgIHRlbXBsYXRlOiBgPCEtLSBJbmxpbmUgU3BhcmsgQ2hhcnQgLS0+XG48ZGl2ICpuZ0lmPVwiaW5saW5lTGFiZWxcIiBjbGFzcz1cInV4LXNwYXJrLWlubGluZS1sYWJlbC1jb250YWluZXJcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1pbmxpbmUtbGFiZWwtbGVmdFwiIFtpbm5lckh0bWxdPVwiaW5saW5lTGFiZWxcIj48L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1saW5lXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLXRvcC1jb250YWluZXJcIiAqbmdJZj1cInRvcExlZnRMYWJlbCB8fCB0b3BSaWdodExhYmVsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtdG9wLWxlZnRcIiAqbmdJZj1cInRvcExlZnRMYWJlbFwiIFtpbm5lckh0bWxdPVwidG9wTGVmdExhYmVsXCI+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtdG9wLXJpZ2h0XCIgKm5nSWY9XCJ0b3BSaWdodExhYmVsXCIgW2lubmVySHRtbF09XCJ0b3BSaWdodExhYmVsXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyayB1eC1pbmxpbmUgdXgtc3BhcmstdGhlbWUte3t0aGVtZX19XCIgW3N0eWxlLmhlaWdodC5weF09XCJiYXJIZWlnaHRcIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cInRyYWNrQ29sb3JcIiBbdXhUb29sdGlwXT1cInRvb2x0aXBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1iYXJcIiAqbmdGb3I9XCJsZXQgbGluZSBvZiB2YWx1ZXM7IGxldCBpZHggPSBpbmRleDtcIiBbc3R5bGUud2lkdGguJV09XCJsaW5lXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJiYXJDb2xvcltpZHhdXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1ib3R0b20tY29udGFpbmVyXCIgKm5nSWY9XCJib3R0b21MZWZ0TGFiZWwgfHwgYm90dG9tUmlnaHRMYWJlbFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLWJvdHRvbS1sZWZ0XCIgKm5nSWY9XCJib3R0b21MZWZ0TGFiZWxcIiBbaW5uZXJIdG1sXT1cImJvdHRvbUxlZnRMYWJlbFwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLWJvdHRvbS1yaWdodFwiICpuZ0lmPVwiYm90dG9tUmlnaHRMYWJlbFwiIFtpbm5lckh0bWxdPVwiYm90dG9tUmlnaHRMYWJlbFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjwhLS0gRW5kIElubGluZSBTcGFyayBDaGFydCAtLT5cblxuXG48IS0tIE5vbiBJbmxpbmUgU3BhcmsgQ2hhcnQgLS0+XG48ZGl2ICpuZ0lmPVwiIWlubGluZUxhYmVsXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstdG9wLWNvbnRhaW5lclwiICpuZ0lmPVwidG9wTGVmdExhYmVsIHx8IHRvcFJpZ2h0TGFiZWxcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLXRvcC1sZWZ0XCIgKm5nSWY9XCJ0b3BMZWZ0TGFiZWxcIiBbaW5uZXJIdG1sXT1cInRvcExlZnRMYWJlbFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtdG9wLXJpZ2h0XCIgKm5nSWY9XCJ0b3BSaWdodExhYmVsXCIgW2lubmVySHRtbF09XCJ0b3BSaWdodExhYmVsXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmsgdXgtc3BhcmstdGhlbWUte3t0aGVtZX19XCIgW2NsYXNzLnV4LXNwYXJrLW11bHRpLXZhbHVlXT1cInZhbHVlcy5sZW5ndGggPiAxXCIgW3N0eWxlLmhlaWdodC5weF09XCJiYXJIZWlnaHRcIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cInRyYWNrQ29sb3JcIlxuICAgICAgICBbdXhUb29sdGlwXT1cInRvb2x0aXBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWJhclwiICpuZ0Zvcj1cImxldCBsaW5lIG9mIHZhbHVlOyBsZXQgaWR4ID0gaW5kZXg7XCIgW3N0eWxlLndpZHRoLiVdPVwibGluZVwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiYmFyQ29sb3JbaWR4XVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWJvdHRvbS1jb250YWluZXJcIiAqbmdJZj1cImJvdHRvbUxlZnRMYWJlbCB8fCBib3R0b21SaWdodExhYmVsXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1sYWJlbC1ib3R0b20tbGVmdFwiICpuZ0lmPVwiYm90dG9tTGVmdExhYmVsXCIgW2lubmVySHRtbF09XCJib3R0b21MZWZ0TGFiZWxcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLWJvdHRvbS1yaWdodFwiICpuZ0lmPVwiYm90dG9tUmlnaHRMYWJlbFwiIFtpbm5lckh0bWxdPVwiYm90dG9tUmlnaHRMYWJlbFwiPjwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjwhLS0gRW5kIE5vbiBJbmxpbmUgU3BhcmsgQ2hhcnQgLS0+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTcGFya0NvbXBvbmVudCB7XG5cbiAgICB2YWx1ZXM6IG51bWJlcltdID0gW107XG5cbiAgICBASW5wdXQoKSBiYXJIZWlnaHQ6IG51bWJlciA9IDEwO1xuICAgIEBJbnB1dCgpIGlubGluZUxhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgdG9wTGVmdExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgdG9wUmlnaHRMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGJvdHRvbUxlZnRMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGJvdHRvbVJpZ2h0TGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b29sdGlwOiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIF90cmFja0NvbG9yOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfdGhlbWU6IENvbG9ySWRlbnRpZmllciA9ICdwcmltYXJ5JzsgICAgXG4gICAgcHJpdmF0ZSBfYmFyQ29sb3I6IHN0cmluZyB8IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgQElucHV0KCkgXG4gICAgc2V0IHRoZW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdGhlbWUgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZUNvbG9yTmFtZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHRoZW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVtZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBcbiAgICBzZXQgdHJhY2tDb2xvcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrQ29sb3IgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHRyYWNrQ29sb3IoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrQ29sb3I7XG4gICAgfVxuXG4gICAgQElucHV0KCkgXG4gICAgc2V0IGJhckNvbG9yKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fYmFyQ29sb3IgPSB2YWx1ZS5tYXAoY29sb3IgPT4gdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUoY29sb3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JhckNvbG9yID0gW3RoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKHZhbHVlKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYmFyQ29sb3IoKTogc3RyaW5nIHwgc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFyQ29sb3I7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgdmFsdWUodmFsdWU6IG51bWJlciB8IG51bWJlcltdKSB7XG5cbiAgICAgICAgLy8gZW5zdXJlICd2YWx1ZScgaXMgYW4gYXJyYXkgYXQgdGhpcyBwb2ludFxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcblxuICAgICAgICAvLyBnZXQgdGhlIHRvdGFsIHZhbHVlIG9mIGFsbCBsaW5lc1xuICAgICAgICBjb25zdCB0b3RhbCA9IE1hdGgubWF4KHZhbHVlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBwcmV2aW91cyArIGN1cnJlbnQsIDApLCAxMDApO1xuXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIHBlcmNlbnRhZ2VzIGZvciBlYWNoIHNwYXJrIGxpbmVcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXMubWFwKHZhbCA9PiAodmFsIC8gdG90YWwpICogMTAwKTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcztcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb2xvclNlcnZpY2U6IENvbG9yU2VydmljZSkgeyB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFNwYXJrQ29tcG9uZW50IH0gZnJvbSAnLi9zcGFyay5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTcGFya0NvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbU3BhcmtDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFNwYXJrTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIvdGFiLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUYWJzZXRTZXJ2aWNlIHtcblxuICAgIHRhYnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUYWJDb21wb25lbnRbXT4oW10pO1xuICAgIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRhYkNvbXBvbmVudD4obnVsbCk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBoaWdobGlnaHRlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRhYkNvbXBvbmVudD4obnVsbCk7XG5cbiAgICBhZGQodGFiOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YWJzJC5uZXh0KFsuLi50aGlzLnRhYnMkLnZhbHVlLCB0YWJdKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHRoZSBvbmx5IHRhYi4gSWYgc28gc2VsZWN0IHRoaXMgYnkgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlJC52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGFiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZSh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdGFiXG4gICAgICAgIHRoaXMudGFicyQubmV4dCh0aGlzLnRhYnMkLnZhbHVlLmZpbHRlcihfdGFiID0+IF90YWIgIT09IHRhYikpO1xuICAgIH1cblxuICAgIHNlbGVjdCh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUkLm5leHQodGFiKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQodGFiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdEF0SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB0YWJzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy50YWJzJC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbmRleCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RBdEluZGV4KHRoaXMudGFicyQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gdGhpcy50YWJzJC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEF0SW5kZXgoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhYnMkLnZhbHVlW2luZGV4XTtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0TmV4dFRhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5pbmRleE9mKHRoaXMuYWN0aXZlJC52YWx1ZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgdGhlIHRhYnMgYWZ0ZXIgdGhlIGFjdGl2ZSBvbmUgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0YWJsZSB0YWJzXG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMkLnZhbHVlLnNsaWNlKGluZGV4ICsgMSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IG9mIHRoZSB0YWJzIGFyZSBub3QgZGlzYWJsZWRcbiAgICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgICAgIGlmICghdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHRhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSByZWFjaCBoZXJlIHRoZW4gbm8gdGFiIGNvdWxkIGJlIHNlbGVjdGVkIC0gc2VsZWN0IHRoZSBmaXJzdCB0YWJcbiAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFRhYigpO1xuICAgIH1cblxuICAgIHNlbGVjdFByZXZpb3VzVGFiKCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLmluZGV4T2YodGhpcy5hY3RpdmUkLnZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0aGUgdGFicyBiZWZvcmUgdGhlIGFjdGl2ZSBvbmUgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0YWJsZSB0YWJzXG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMkLnZhbHVlLnNsaWNlKDAsIGluZGV4KTtcblxuICAgICAgICAvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHRhYnMgYXJlIG5vdCBkaXNhYmxlZFxuICAgICAgICBmb3IgKGxldCB0YWIgb2YgdGFicy5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGlmICghdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHRhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSByZWFjaCBoZXJlIHRoZW4gbm8gcHJldmlvdXMgdGFiIGNvdWxkIGJlIHNlbGVjdGVkIC0gc2VsZWN0IHRoZSBsYXN0IHRhYlxuICAgICAgICB0aGlzLnNlbGVjdExhc3RUYWIoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RGaXJzdFRhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCB0YWJcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLmZpbmRJbmRleCh0YWIgPT4gIXRhYi5kaXNhYmxlZCk7XG5cbiAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RBdEluZGV4KHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdExhc3RUYWIoKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgdGFiXG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5zbGljZSgpLnJldmVyc2UoKS5maW5kSW5kZXgodGFiID0+ICF0YWIuZGlzYWJsZWQpO1xuXG4gICAgICAgIGlmICh0YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QXRJbmRleCgodGhpcy50YWJzJC52YWx1ZS5sZW5ndGggLSAxKSAtIHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn0gIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiL3RhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGFic2V0U2VydmljZSB9IGZyb20gJy4vdGFic2V0LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRhYnNldCcsXG4gICAgdGVtcGxhdGU6IGA8IS0tIE5hdiB0YWJzIC0tPlxuPHVsIHJvbGU9XCJ0YWJsaXN0XCJcbiAgICBjbGFzcz1cIm5hdiBuYXYtdGFic1wiXG4gICAgW2NsYXNzLm1pbmltYWwtdGFiXT1cIm1pbmltYWxcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcbiAgICBbYXR0ci5hcmlhLW9yaWVudGF0aW9uXT1cInN0YWNrZWQgPT09ICdub25lJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCdcIj5cblxuXHQ8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiIFxuICAgICAgICBjbGFzcz1cIm5hdi1pdGVtXCJcbiAgICAgICAgKm5nRm9yPVwibGV0IHRhYiBvZiB0YWJzZXQudGFicyQgfCBhc3luYzsgbGV0IGluZGV4ID0gaW5kZXhcIlxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cInRhYi5hY3RpdmUkIHwgYXN5bmNcIlxuICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwidGFiLmRpc2FibGVkXCJcbiAgICAgICAgW25nQ2xhc3NdPVwidGFiLmN1c3RvbUNsYXNzXCI+XG5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiXG4gICAgICAgICAgICBbaWRdPVwidGFiLmlkXCJcbiAgICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgICAgW3V4VGFiRm9jdXNdPVwidGFiXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCIodGFiLmFjdGl2ZSQgfCBhc3luYykgPyAwIDogLTFcIlxuICAgICAgICAgICAgW2NsYXNzLmhpZ2hsaWdodGVkXT1cIih0YWJzZXQuZm9jdXNlZCQgfCBhc3luYykgJiYgKHRhYnNldC5oaWdobGlnaHRlZCQgfCBhc3luYykgPT09IHRhYlwiICAgICAgICAgICAgXG4gICAgICAgICAgICAobW91c2Vkb3duKT1cInRhYnNldC5zZWxlY3QodGFiKVwiXG4gICAgICAgICAgICAoZm9jdXMpPVwidGFic2V0LmZvY3VzZWQkLm5leHQodHJ1ZSlcIlxuICAgICAgICAgICAgKGJsdXIpPVwidGFic2V0LmZvY3VzZWQkLm5leHQoZmFsc2UpXCJcbiAgICAgICAgICAgIChtb3VzZWRvd24pPVwidGFic2V0LmZvY3VzZWQkLm5leHQodHJ1ZSlcIlxuICAgICAgICAgICAgKGtleWRvd24uQXJyb3dVcCk9XCJzZWxlY3RQcmV2aW91c1RhYigkZXZlbnQpXCJcbiAgICAgICAgICAgIChrZXlkb3duLkFycm93TGVmdCk9XCJzZWxlY3RQcmV2aW91c1RhYigkZXZlbnQpXCJcbiAgICAgICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwic2VsZWN0TmV4dFRhYigkZXZlbnQpXCJcbiAgICAgICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJzZWxlY3ROZXh0VGFiKCRldmVudClcIlxuICAgICAgICAgICAgKGtleWRvd24uSG9tZSk9XCJ0YWJzZXQuc2VsZWN0Rmlyc3RUYWIoKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgKGtleWRvd24uRW5kKT1cInRhYnNldC5zZWxlY3RMYXN0VGFiKCk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY29udHJvbHNdPVwidGFiLmlkXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwidGFiLmFjdGl2ZSQgfCBhc3luY1wiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cInRhYi5kaXNhYmxlZFwiPlxuXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiF0YWIuaGVhZGluZ1JlZlwiPnt7IHRhYi5oZWFkaW5nIH19PC9zcGFuPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidGFiLmhlYWRpbmdSZWZcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWIuaGVhZGluZ1JlZlwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2E+XG5cblx0PC9saT5cblxuPC91bD5cblxuPCEtLSBUYWIgcGFuZXMgLS0+XG48ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRcIj5cblx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcm92aWRlcnM6IFtUYWJzZXRTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MudGFicy1sZWZ0XSc6ICdzdGFja2VkID09PSBcImxlZnRcIicsXG4gICAgICAgICdbY2xhc3MudGFicy1yaWdodF0nOiAnc3RhY2tlZCA9PT0gXCJyaWdodFwiJyxcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFRhYnNldENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBtaW5pbWFsOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzdGFja2VkOiAnbGVmdCcgfCAncmlnaHQnIHwgJ25vbmUnID0gJ25vbmUnO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHRhYnNldDogVGFic2V0U2VydmljZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyBtYW51YWwgdGFiIHNlbGVjdGVkXG4gICAgICovXG4gICAgc2VsZWN0KHRhYjogVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMudGFic2V0LnNlbGVjdCh0YWIpO1xuICAgIH1cblxuICAgIHNlbGVjdFByZXZpb3VzVGFiKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGFycm93IGtleSBpcyBwcmVzc2VkXG4gICAgICAgIGNvbnN0IGFycm93TGVmdCA9IGV2ZW50LmtleSA9PT0gJ0Fycm93TGVmdCcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzc7XG4gICAgICAgIGNvbnN0IGFycm93VXAgPSBldmVudC5rZXkgPT09ICdBcnJvd1VwJyB8fCBldmVudC5rZXlDb2RlID09PSAzODtcblxuICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWN0aW9uIGlmIHRoZSBhcnJvdyBrZXkgbWF0Y2hlcyB0aGUgb3JpZW50YXRpb25cbiAgICAgICAgaWYgKGFycm93TGVmdCAmJiB0aGlzLnN0YWNrZWQgIT09ICdub25lJyB8fCBhcnJvd1VwICYmIHRoaXMuc3RhY2tlZCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnRhYnNldC5zZWxlY3RQcmV2aW91c1RhYigpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcgd2hlbiBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgc2VsZWN0TmV4dFRhYihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBhcnJvdyBrZXkgaXMgcHJlc3NlZFxuICAgICAgICBjb25zdCBhcnJvd1JpZ2h0ID0gZXZlbnQua2V5ID09PSAnQXJyb3dSaWdodCcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzk7XG4gICAgICAgIGNvbnN0IGFycm93RG93biA9IGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHwgZXZlbnQua2V5Q29kZSA9PT0gNDA7XG5cbiAgICAgICAgLy8gb25seSBwZXJmb3JtIGFjdGlvbiBpZiB0aGUgYXJyb3cga2V5IG1hdGNoZXMgdGhlIG9yaWVudGF0aW9uXG4gICAgICAgIGlmIChhcnJvd1JpZ2h0ICYmIHRoaXMuc3RhY2tlZCAhPT0gJ25vbmUnIHx8IGFycm93RG93biAmJiB0aGlzLnN0YWNrZWQgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy50YWJzZXQuc2VsZWN0TmV4dFRhYigpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcgd2hlbiBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUYWJzZXRTZXJ2aWNlIH0gZnJvbSAnLi4vdGFic2V0LnNlcnZpY2UnO1xuXG5sZXQgdW5pcXVlVGFiSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRhYicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgIGNsYXNzPVwidGFiLXBhbmVcIlxuICAgICBbY2xhc3MuYWN0aXZlXT1cImFjdGl2ZSQgfCBhc3luY1wiXG4gICAgIFtpZF09XCJpZCArICctcGFuZWwnXCJcbiAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImlkXCJcbiAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIShhY3RpdmUkIHwgYXN5bmMpXCI+XG4gIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVGFiQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSBgdXgtdGFiLSR7Kyt1bmlxdWVUYWJJZH1gO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaGVhZGluZzogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGN1c3RvbUNsYXNzOiBzdHJpbmc7XG5cbiAgICBAT3V0cHV0KCkgc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBkZXNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIEBJbnB1dCgpIHNldCBhY3RpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJzZXQuc2VsZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGVhZGluZ1JlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBhY3RpdmUkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5fdGFic2V0LmFjdGl2ZSQucGlwZShtYXAoYWN0aXZlID0+IGFjdGl2ZSA9PT0gdGhpcykpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90YWJzZXQ6IFRhYnNldFNlcnZpY2UpIHtcbiAgICAgICAgX3RhYnNldC5hZGQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5hY3RpdmUkLnN1YnNjcmliZShhY3RpdmUgPT4gYWN0aXZlID8gdGhpcy5zZWxlY3QuZW1pdCgpIDogdGhpcy5kZXNlbGVjdC5lbWl0KCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl90YWJzZXQucmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRhYkhlYWRpbmddJ1xufSlcbmV4cG9ydCBjbGFzcyBUYWJIZWFkaW5nRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LCB0YWI6IFRhYkNvbXBvbmVudCkge1xuICAgICAgICB0YWIuaGVhZGluZ1JlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cblxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUYWJzZXRTZXJ2aWNlIH0gZnJvbSAnLi4vdGFic2V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIuY29tcG9uZW50JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhUYWJGb2N1c10nXG59KVxuZXhwb3J0IGNsYXNzIFRhYkZvY3VzRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgdXhUYWJGb2N1czogVGFiQ29tcG9uZW50O1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90YWJzZXQ6IFRhYnNldFNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3RhYnNldC5oaWdobGlnaHRlZCQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl90YWJzZXQuZm9jdXNlZCQudmFsdWUgPT09IHRydWUpLFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3RhYnNldC5oaWdobGlnaHRlZCQudmFsdWUgPT09IHRoaXMudXhUYWJGb2N1cyksXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgVGFic2V0Q29tcG9uZW50IH0gZnJvbSAnLi90YWJzZXQuY29tcG9uZW50JztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuL3RhYnNldC5zZXJ2aWNlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiL3RhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGFiSGVhZGluZ0RpcmVjdGl2ZSB9IGZyb20gJy4vdGFiL3RhYi1oZWFkaW5nLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUYWJGb2N1c0RpcmVjdGl2ZSB9IGZyb20gJy4vdGFiL3RhYi1mb2N1cy5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVGFic2V0Q29tcG9uZW50LCBUYWJDb21wb25lbnQsIFRhYkhlYWRpbmdEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW1RhYnNldENvbXBvbmVudCwgVGFiQ29tcG9uZW50LCBUYWJIZWFkaW5nRGlyZWN0aXZlLCBUYWJGb2N1c0RpcmVjdGl2ZV0sXG59KVxuZXhwb3J0IGNsYXNzIFRhYnNldE1vZHVsZSB7IH0iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10aW1lbGluZScsXHJcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ0aW1lbGluZVwiPlxyXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxyXG48L2Rpdj5cclxuYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGltZWxpbmVDb21wb25lbnQge1xyXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXRpbWVsaW5lLWV2ZW50JyxcclxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInRpbWVsaW5lLWJhZGdlXCIgW25nQ2xhc3NdPVwiYmFkZ2VDb2xvclwiPlxyXG4gICAgPHNwYW4+e3tiYWRnZVRpdGxlfX08L3NwYW4+XHJcbjwvZGl2PlxyXG48ZGl2IGNsYXNzPVwidGltZWxpbmUtcGFuZWxcIj5cclxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuPC9kaXY+XHJcbmBcclxufSlcclxuZXhwb3J0IGNsYXNzIFRpbWVsaW5lRXZlbnRDb21wb25lbnQge1xyXG5cclxuICAgIEBJbnB1dCgpIGJhZGdlQ29sb3I6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGJhZGdlVGl0bGU6IHN0cmluZztcclxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IFRpbWVsaW5lQ29tcG9uZW50IH0gZnJvbSAnLi90aW1lbGluZS5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBUaW1lbGluZUV2ZW50Q29tcG9uZW50IH0gZnJvbSAnLi90aW1lbGluZS1ldmVudC90aW1lbGluZS1ldmVudC5jb21wb25lbnQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGVcclxuICAgIF0sXHJcbiAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgVGltZWxpbmVDb21wb25lbnQsXHJcbiAgICAgICAgVGltZWxpbmVFdmVudENvbXBvbmVudFxyXG4gICAgXSxcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIFRpbWVsaW5lQ29tcG9uZW50LFxyXG4gICAgICAgIFRpbWVsaW5lRXZlbnRDb21wb25lbnRcclxuICAgIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIFRpbWVsaW5lTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5jb25zdCBUT0dHTEVTV0lUQ0hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVG9nZ2xlU3dpdGNoQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxubGV0IHVuaXF1ZVRvZ2dsZVN3aXRjaElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10b2dnbGVzd2l0Y2gnLFxuICAgIHRlbXBsYXRlOiBgPGxhYmVsIFthdHRyLmZvcl09XCJpbnB1dElkXCJcbiAgICAgICBjbGFzcz1cInV4LXRvZ2dsZXN3aXRjaFwiXG4gICAgICAgW2NsYXNzLnV4LXRvZ2dsZXN3aXRjaC1jaGVja2VkXT1cInZhbHVlXCJcbiAgICAgICBbY2xhc3MudXgtdG9nZ2xlc3dpdGNoLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbY2xhc3MudXgtdG9nZ2xlc3dpdGNoLWZvY3VzZWRdPVwiZm9jdXNlZFwiPlxuXG4gICAgPGlucHV0IGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoLWlucHV0XCJcbiAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgcm9sZT1cInN3aXRjaFwiXG4gICAgICAgICAgIFtpZF09XCJpbnB1dElkXCJcbiAgICAgICAgICAgW2NoZWNrZWRdPVwidmFsdWVcIlxuICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiaW5kZXhcIlxuICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG4gICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG4gICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJ2YWx1ZVwiXG4gICAgICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgICAgIChibHVyKT1cImZvY3VzZWQgPSBmYWxzZVwiXG4gICAgICAgICAgIChjaGFuZ2UpPVwidG9nZ2xlKClcIlxuICAgICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoLWJnXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC10b2dnbGVzd2l0Y2gtbnViXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8c3BhbiBjbGFzcz1cInV4LXRvZ2dsZXN3aXRjaC1sYWJlbFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9zcGFuPlxuPC9sYWJlbD5gLFxuICAgIHByb3ZpZGVyczogW1RPR0dMRVNXSVRDSF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfdG9nZ2xlU3dpdGNoSWQ6IHN0cmluZyA9IGB1eC10b2dnbGVzd2l0Y2gtJHsrK3VuaXF1ZVRvZ2dsZVN3aXRjaElkfWA7XG5cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nID0gdGhpcy5fdG9nZ2xlU3dpdGNoSWQ7XG4gICAgQElucHV0KCkgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBjbGlja2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmcgPSAnJztcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmcgPSBudWxsO1xuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB2YWx1ZSBvdXRwdXRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcblxuICAgICAgICAvLyBOb3RpZnkgbmdNb2RlbFxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZ2V0IGlucHV0SWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fdG9nZ2xlU3dpdGNoSWR9LWlucHV0YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gKCkgPT4geyB9O1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gISF2YWx1ZTtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IH0gZnJvbSAnLi90b2dnbGVzd2l0Y2guY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbIEZvcm1zTW9kdWxlIF0sXG4gICAgZXhwb3J0czogWyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFsgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IF1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VG9vbGJhclNlYXJjaEJ1dHRvbl0nXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmUge1xuXG4gICAgQE91dHB1dCgpXG4gICAgY2xpY2tlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIGNsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5jbGlja2VkLmVtaXQoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBPcHRpb25hbCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ01vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5jb25zdCBLRVlTID0ge1xuICAgIEVOVEVSOiAxMyxcbiAgICBFU0NBUEU6IDI3XG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRvb2xiYXJTZWFyY2hGaWVsZF0nXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSB7XG5cbiAgICBAT3V0cHV0KClcbiAgICBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIGdldCB0ZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIC8vIFVzZSBuZ01vZGVsIGlmIHNwZWNpZmllZCBvbiB0aGUgaG9zdDsgb3RoZXJ3aXNlIHJlYWQgdGhlIERPTVxuICAgICAgICBpZiAodGhpcy5fbmdNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25nTW9kZWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9uZ01vZGVsOiBOZ01vZGVsKSB7IH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBibHVyKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICAvLyBVc2UgbmdNb2RlbCBpZiBzcGVjaWZpZWQgb24gdGhlIGhvc3Q7IG90aGVyd2lzZSB1c2UgdGhlIERPTVxuICAgICAgICBpZiAodGhpcy5fbmdNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5fbmdNb2RlbC5yZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlTLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXQuZW1pdCh0aGlzLnRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlTLkVTQ0FQRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25FdmVudCwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2NvbG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWZpZWxkLmRpcmVjdGl2ZSc7XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10b29sYmFyLXNlYXJjaCcsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ2V4cGFuZGVkJywgW1xuICAgICAgICAgICAgc3RhdGUoXG4gICAgICAgICAgICAgICAgJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJ3t7aW5pdGlhbFdpZHRofX0nXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgaW5pdGlhbFdpZHRoOiAnMzBweCcgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzdGF0ZShcbiAgICAgICAgICAgICAgICAnZXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignY29sbGFwc2VkIDw9PiBleHBhbmRlZCcsIFthbmltYXRlKCcwLjNzIGVhc2Utb3V0JyldKVxuICAgICAgICBdKVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5leHBhbmRlZCcpXG4gICAgQElucHV0KClcbiAgICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgICB9XG5cbiAgICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWQgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBpbnB1dCB3aGVuIGV4cGFuZGVkXG4gICAgICAgICAgICB0aGlzLmZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0ZXh0IHdoZW4gY29udHJhY3RlZFxuICAgICAgICAgICAgdGhpcy5maWVsZC5jbGVhcigpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZm9jdXMgKHdvcmtzIGFyb3VuZCBhbiBJRSBpc3N1ZSB3aGVyZSB0aGUgY2FyZXQgcmVtYWlucyB2aXNpYmxlKVxuICAgICAgICAgICAgdGhpcy5maWVsZC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyA9ICdyaWdodCc7XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaW52ZXJzZScpXG4gICAgaW52ZXJzZSA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgYmFja2dyb3VuZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUodmFsdWUpIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpXG4gICAgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzZWFyY2ggPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIHByaXZhdGUgX2V4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASG9zdEJpbmRpbmcoJ0BleHBhbmRlZCcpXG4gICAgZ2V0IGV4cGFuZGVkQW5pbWF0aW9uKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5leHBhbmRlZCA/ICdleHBhbmRlZCcgOiAnY29sbGFwc2VkJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGluaXRpYWxXaWR0aDogdGhpcy5idXR0b24ud2lkdGggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5wb3NpdGlvbicpIHBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmJhY2tncm91bmQtY29sb3InKSBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgIEBDb250ZW50Q2hpbGQoVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlKSBmaWVsZDogVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlO1xuICAgIEBDb250ZW50Q2hpbGQoVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSkgYnV0dG9uOiBUb29sYmFyU2VhcmNoQnV0dG9uRGlyZWN0aXZlO1xuXG4gICAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHN1Ym1pdCBldmVudCBvbiB0aGUgaW5wdXQgZmllbGQsIHRyaWdnZXJpbmcgdGhlIHNlYXJjaCBldmVudFxuICAgICAgICB0aGlzLmZpZWxkLnN1Ym1pdC5zdWJzY3JpYmUoKHRleHQ6IHN0cmluZykgPT4gdGhpcy5zZWFyY2guZW1pdCh0ZXh0KSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNhbmNlbCBldmVudHMgY29taW5nIGZyb20gdGhlIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuZmllbGQuY2FuY2VsLnN1YnNjcmliZSgoKSA9PiB0aGlzLmV4cGFuZGVkID0gZmFsc2UpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgYnV0dG9uIGNsaWNrIGV2ZW50XG4gICAgICAgIHRoaXMuYnV0dG9uLmNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZGVkICYmIHRoaXMuZmllbGQudGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLmVtaXQodGhpcy5maWVsZC50ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgZWxlbWVudCB0byBhdm9pZCBjaGFuZ2luZyBsYXlvdXQgd2hlbiBzd2l0Y2hpbmcgdG8gcG9zaXRpb246IGFic29sdXRlXG4gICAgICAgIHRoaXMuY3JlYXRlUGxhY2Vob2xkZXIoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdAZXhwYW5kZWQuc3RhcnQnLCBbJyRldmVudCddKVxuICAgIGFuaW1hdGlvblN0YXJ0KGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ2V4cGFuZGVkJykge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignQGV4cGFuZGVkLmRvbmUnLCBbJyRldmVudCddKVxuICAgIGFuaW1hdGlvbkRvbmUoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAnY29sbGFwc2VkJykge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlUGxhY2Vob2xkZXIoKSB7XG4gICAgICAgIC8vIEdldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBpbnZpc2libGUgZGl2IHdpdGggdGhlIHNhbWUgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS53aWR0aCA9IHRoaXMuYnV0dG9uLndpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUuaGVpZ2h0ID0gc3R5bGVzLmhlaWdodDtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICAgIC8vIEFkZCBhcyBhIHNpYmxpbmdcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX3BsYWNlaG9sZGVyLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW5hYmxlUGxhY2Vob2xkZXIoZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gKGVuYWJsZWQgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hDb21wb25lbnQgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWZpZWxkLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi90b29sYmFyLXNlYXJjaC1idXR0b24uZGlyZWN0aXZlJztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFRvb2xiYXJTZWFyY2hDb21wb25lbnQsXG4gICAgVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlLFxuICAgIFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OUyxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBUb29sYmFyU2VhcmNoTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eFZpcnR1YWxTY3JvbGxMb2FkaW5nXScgXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIHsgfSIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uXScgXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIHsgfSIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgXG4gICAgc2VsZWN0b3I6ICdbdXhWaXJ0dWFsU2Nyb2xsQ2VsbF0nIFxufSlcbmV4cG9ydCBjbGFzcyBWaXJ0dWFsU2Nyb2xsQ2VsbERpcmVjdGl2ZSB7XG5cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIElucHV0LCBIb3N0TGlzdGVuZXIsIEVsZW1lbnRSZWYsIEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZCwgVGVtcGxhdGVSZWYsIE9uRGVzdHJveSwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsQ2VsbERpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy92aXJ0dWFsLXNjcm9sbC1jZWxsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC12aXJ0dWFsLXNjcm9sbCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidmlydHVhbC1zY3JvbGwtY29udGVudC1oZWlnaHRcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImdldFRvdGFsSGVpZ2h0KClcIj48L2Rpdj5cbjxkaXYgY2xhc3M9XCJ2aXJ0dWFsLXNjcm9sbC1jb250ZW50XCIgW3N0eWxlLnRyYW5zZm9ybV09XCIndHJhbnNsYXRlWSgnICsgc2Nyb2xsVG9wICsgJ3B4KSdcIj5cblxuICAgIDwhLS0gVmlydHVhbGx5IFJlbmRlciBDZWxscyAtLT5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBjZWxsIG9mIGNlbGxzIHwgYXN5bmNcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNlbGxUZW1wbGF0ZTsgY29udGV4dDogeyBjZWxsOiBjZWxsIH1cIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgIDwhLS0gTG9hZGluZyBJbmRpY2F0b3IgLS0+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImxvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZSAmJiBpc0xvYWRpbmdcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJsb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cblxuICAgIDwhLS0gTG9hZGluZyBCdXR0b24gLS0+XG4gICAgPGRpdiBjbGFzcz1cInZpcnR1YWwtc2Nyb2xsLWxvYWQtYnV0dG9uXCIgKm5nSWY9XCJsb2FkQnV0dG9uVGVtcGxhdGUgJiYgIWxvYWRPblNjcm9sbCAmJiAhbG9hZGluZ0NvbXBsZXRlICYmICFpc0xvYWRpbmdcIiAoY2xpY2spPVwibG9hZE5leHRQYWdlKClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImxvYWRCdXR0b25UZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuICAgIFxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBWaXJ0dWFsU2Nyb2xsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgY29sbGVjdGlvbjogT2JzZXJ2YWJsZTxhbnlbXT4gPSBPYnNlcnZhYmxlLmNyZWF0ZSgpO1xuICAgIEBJbnB1dCgpIGNlbGxIZWlnaHQ6IG51bWJlcjtcbiAgICBASW5wdXQoKSBsb2FkT25TY3JvbGw6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQE91dHB1dCgpIGxvYWRpbmc6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBAQ29udGVudENoaWxkKFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGNlbGxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBAQ29udGVudENoaWxkKFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGxvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBAQ29udGVudENoaWxkKFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGxvYWRCdXR0b25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIGNlbGxzOiBCZWhhdmlvclN1YmplY3Q8YW55W10+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChbXSk7XG4gICAgc2Nyb2xsVG9wOiBudW1iZXIgPSAwO1xuICAgIGlzTG9hZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHBhZ2VOdW1iZXI6IG51bWJlciA9IDA7XG4gICAgZGF0YTogYW55W10gPSBbXTtcbiAgICBsb2FkaW5nQ29tcGxldGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX2hlaWdodDogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSkge1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBhbnkgZnV0dXJlIGNoYW5nZXMgdG8gc2l6ZVxuICAgICAgICByZXNpemVTZXJ2aWNlLmFkZFJlc2l6ZUxpc3RlbmVyKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpLnN1YnNjcmliZShldmVudCA9PiB0aGlzLl9oZWlnaHQgPSBldmVudC5oZWlnaHQpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIGlmICghdGhpcy5jZWxsSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWwgU2Nyb2xsIENvbXBvbmVudCByZXF1aXJlcyBcImNlbGxIZWlnaHRcIiBwcm9wZXJ0eSB0byBiZSBkZWZpbmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgIHRoaXMuc2V0dXBPYnNlcnZhYmxlKCk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgZmlyc3QgcGFnZSBvZiBkYXRhXG4gICAgICAgIHRoaXMubG9hZE5leHRQYWdlKCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICAvLyByZS1yZW5kZXIgY2VsbHMgbm93IHRoYXQgd2UgY2FuIGRpc3BsYXkgYW55IGxvYWRpbmcgaW5kaWNhdG9yIG9yIGxvYWRpbmcgYnV0dG9uXG4gICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmNvbGxlY3Rpb24gJiYgY2hhbmdlcy5jb2xsZWN0aW9uLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5jb2xsZWN0aW9uLnByZXZpb3VzVmFsdWUgJiYgIWNoYW5nZXMuY29sbGVjdGlvbi5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBPYnNlcnZhYmxlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0dXBPYnNlcnZhYmxlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgY3VycmVudCBzdWJzY3JpcHRpb24sIHVuc3Vic2NyaWJlXG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb24gJiYgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuY29sbGVjdGlvbi5zdWJzY3JpYmUoY29sbGVjdGlvbiA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCguLi5jb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoKTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignc2Nyb2xsJykgcmVuZGVyQ2VsbHMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2VsbHMubmV4dCh0aGlzLmdldFZpc2libGVDZWxscygpKTtcblxuICAgICAgICBpZiAodGhpcy5sb2FkT25TY3JvbGwgJiYgIXRoaXMuaXNMb2FkaW5nICYmICF0aGlzLmxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbEhlaWdodCAtICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wICsgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGNlbGxzIHRha2UgdXAgbGVzcyB0aGFuIHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCB0aGVuIGxvYWQgdGhlIG5leHQgcGFnZVxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1Njcm9sbCA8PSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFZpc2libGVDZWxscygpOiBhbnlbXSB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgZWxlbWVudCBoZWlnaHRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHNvbWUgY2FsY3VsYXRpb25zXG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2VsbCA9IE1hdGguZmxvb3Ioc2Nyb2xsVG9wIC8gdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZW5kQ2VsbCA9IE1hdGguY2VpbCh0aGlzLl9oZWlnaHQgLyB0aGlzLmNlbGxIZWlnaHQpICsgMTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAtIChzY3JvbGxUb3AgJSB0aGlzLmNlbGxIZWlnaHQpO1xuXG4gICAgICAgIC8vIHJldHVybiBhIHN1Ymxpc3Qgb2YgaXRlbXMgdmlzaWJsZSBvbiB0aGUgc2NyZWVuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2Uoc3RhcnRDZWxsLCBzdGFydENlbGwgKyBlbmRDZWxsKTtcbiAgICB9XG5cbiAgICBnZXRUb3RhbEhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsSGVpZ2h0ICogdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBsb2FkTmV4dFBhZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nLm5leHQodGhpcy5wYWdlTnVtYmVyKTtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyKys7XG4gICAgfVxuXG4gICAgcmVzZXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVzZXQgYWxsIHZhbHVlc1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGFnZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubG9hZGluZ0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gc2V0IHNjcm9sbCBwb3NpdGlvblxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgICAgICAvLyBjbGVhciB0aGUgY3VycmVudCBjZWxsc1xuICAgICAgICB0aGlzLnJlbmRlckNlbGxzKCk7XG5cbiAgICAgICAgLy8gcmVsb2FkIGZpcnN0IHBhZ2VcbiAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgVmlydHVhbFNjcm9sbENvbXBvbmVudCB9IGZyb20gJy4vdmlydHVhbC1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsQ2VsbERpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy92aXJ0dWFsLXNjcm9sbC1jZWxsLmRpcmVjdGl2ZSc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBWaXJ0dWFsU2Nyb2xsQ29tcG9uZW50LFxuICAgIFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlLFxuICAgIFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlLFxuICAgIFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OU1xufSlcbmV4cG9ydCBjbGFzcyBWaXJ0dWFsU2Nyb2xsTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhBdXRvR3Jvd10nXG59KVxuZXhwb3J0IGNsYXNzIEF1dG9Hcm93RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgIC8vIGVuc3VyZSB0aGlzIGlzIGEgdGV4dGFyZWEgb3IgZWxzZSB0aHJvdyBlcnJvclxuICAgIGlmIChfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3RleHRhcmVhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1eEF1dG9Hcm93IGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIG9uIDx0ZXh0YXJlYT4gZWxlbWVudHMuJyk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdpbnB1dCcpXG4gIHVwZGF0ZSgpOiB2b2lkIHtcblxuICAgIC8vIHBlcmZvcm0gc2l6aW5nXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnb3ZlcmZsb3dZJywgJ2hpZGRlbicpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsICdhdXRvJyk7XG5cbiAgICAvLyBnZXQgdGhlIG5ldyB0b3RhbCBoZWlnaHQgYW5kIGVsZW1lbnQgaGVpZ2h0XG4gICAgY29uc3QgeyBzY3JvbGxIZWlnaHQgfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCB7IG1heEhlaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgdGhlIG1heGltdW0gYWxsb3dlZCBoZWlnaHQgaXNcbiAgICBjb25zdCBtYXhpbXVtID0gIWlzTmFOKHBhcnNlRmxvYXQobWF4SGVpZ2h0KSkgPyBwYXJzZUZsb2F0KG1heEhlaWdodCkgOiBJbmZpbml0eTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGEgbWF4IGhlaWdodCBzcGVjaWZlZCB3ZSB3YW50IHRvIHNob3cgdGhlIHNjcm9sbGJhcnNcbiAgICBpZiAobWF4aW11bSA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnb3ZlcmZsb3dZJywgJ2F1dG8nKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIG1heGltdW0gKyAncHgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0Jywgc2Nyb2xsSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgfVxuICB9XG5cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBdXRvR3Jvd0RpcmVjdGl2ZSB9IGZyb20gJy4vYXV0by1ncm93LmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0F1dG9Hcm93RGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtBdXRvR3Jvd0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgQXV0b0dyb3dNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3V4Rml4ZWRIZWFkZXJUYWJsZV0nXG59KVxuZXhwb3J0IGNsYXNzIEZpeGVkSGVhZGVyVGFibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIEBJbnB1dCgpIHRhYmxlSGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG4gIEBPdXRwdXQoKSB0YWJsZVBhZ2luZzogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICBwcml2YXRlIF90YWJsZUhlYWQ6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIF90YWJsZUJvZHk6IEhUTUxFbGVtZW50O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHsgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgLy8gYWRkIGNsYXNzIHRvIHRoZSB0YWJsZVxuICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWZpeGVkLWhlYWRlci10YWJsZScpO1xuXG4gICAgLy8gbG9jYXRlIHRoZSBpbXBvcnRhbnQgZWxlbWVudHNcbiAgICB0aGlzLl90YWJsZUhlYWQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGhlYWQnKTtcbiAgICB0aGlzLl90YWJsZUJvZHkgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHknKTtcblxuICAgIC8vIGJpbmQgdG8gc2Nyb2xsIGV2ZW50cyBvbiB0aGUgdGFibGUgYm9keVxuICAgIHRoaXMuX3JlbmRlcmVyLmxpc3Rlbih0aGlzLl90YWJsZUJvZHksICdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcykpO1xuXG4gICAgLy8gcmVzaXplIHRoZSB0YWJsZSBoZWFkZXIgdG8gYWNjb3VudCBmb3Igc2Nyb2xsYmFyXG4gICAgdGhpcy5zZXRMYXlvdXQoKTtcblxuICAgIC8vIHRyaWdnZXIgdGhlIGxvYWRpbmcgb2YgdGhlIGZpcnN0IHBhZ2VcbiAgICB0aGlzLnRhYmxlUGFnaW5nLmVtaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhYmxlIGVsZW1lbnRcbiAgICogUHJpbWFyaWx5IHVzZWQgYnkgY29sdW1uIHdpZHRoIGRpcmVjdGl2ZVxuICAgKi9cbiAgZ2V0VGFibGUoKTogSFRNTFRhYmxlRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2Nyb2xsIGV2ZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBvblNjcm9sbCgpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSBpZiB3ZSBhcmUgc2Nyb2xsZWQgdG8gdGhlIGJvdHRvbSBhbmQgaWYgc28gbG9hZCB0aGUgbmV4dCBwYWdlXG4gICAgaWYgKHRoaXMuX3RhYmxlQm9keS5zY3JvbGxUb3AgPT09ICh0aGlzLl90YWJsZUJvZHkuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fdGFibGVCb2R5Lm9mZnNldEhlaWdodCkpIHtcbiAgICAgIHRoaXMudGFibGVQYWdpbmcuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHNpemUgb2YgdGhlIHRhYmxlIGhlYWRlciB0byBhY2NvdW50IGZvciB0aGUgc2Nyb2xsYmFyLlxuICAgKiBUaGlzIGlzIGltcG9ydGFudCB0byBrZWVwIHRoZSBjb2x1bW5zIGFsaWduZWRcbiAgICovXG4gIHByaXZhdGUgc2V0TGF5b3V0KCk6IHZvaWQge1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoZSBzY3JvbGxiYXJcbiAgICBjb25zdCBzY3JvbGxiYXIgPSB0aGlzLl90YWJsZUJvZHkub2Zmc2V0V2lkdGggLSB0aGlzLl90YWJsZUJvZHkuY2xpZW50V2lkdGg7XG5cbiAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgaGVhZGVyIHRvIGFjY291bnQgZm9yIHRoaXNcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJsZUhlYWQsICdwYWRkaW5nLXJpZ2h0Jywgc2Nyb2xsYmFyICsgJ3B4Jyk7XG5cbiAgICAvLyBzZXQgdGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSB0YWJsZSBib2R5XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fdGFibGVCb2R5LCAnaGVpZ2h0JywgdHlwZW9mIHRoaXMudGFibGVIZWlnaHQgPT09ICdudW1iZXInID8gYCR7dGhpcy50YWJsZUhlaWdodH1weGAgOiB0aGlzLnRhYmxlSGVpZ2h0KTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlIH0gZnJvbSAnLi9maXhlZC1oZWFkZXItdGFibGUuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRml4ZWRIZWFkZXJUYWJsZURpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRml4ZWRIZWFkZXJUYWJsZURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRml4ZWRIZWFkZXJUYWJsZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhGbG9hdExhYmVsXScsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndXgtZmxvYXQtbGFiZWwnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdExhYmVsRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoJ3V4RmxvYXRMYWJlbCcpXG4gICAgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIG1vZGU6ICdmb2N1cycgfCAnaW5wdXQnID0gJ2ZvY3VzJztcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MudXgtZmxvYXQtbGFiZWwtcmFpc2VkJylcbiAgICByYWlzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgcHJpdmF0ZSBfZm9jdXNlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2V2ZW50SGFuZGxlczogYW55W10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuaW5wdXQsICdmb2N1cycsIHRoaXMuaW5wdXRGb2N1cy5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmxpc3Rlbih0aGlzLmlucHV0LCAnYmx1cicsIHRoaXMuaW5wdXRCbHVyLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuaW5wdXQsICdpbnB1dCcsIHRoaXMuaW5wdXRDaGFuZ2UuYmluZCh0aGlzKSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDaGVjayBpbml0aWFsIGlucHV0IHZhbHVlXG4gICAgICAgIHRoaXMucmFpc2VkID0gdGhpcy5oYXNUZXh0KCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGBmb3JgIGF0dHJpYnV0ZSBpcyBzZXRcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb3InKSAmJiB0aGlzLmlucHV0LmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvcicsIHRoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgICAgICBpZiAoISh0aGlzLm1vZGUgPT09ICdmb2N1cycgJiYgdGhpcy5fZm9jdXNlZCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VkID0gdGhpcy5oYXNUZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy8gVW5zdWJzY3JpYmUgZXZlbnQgaGFuZGxlc1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXMuZm9yRWFjaCgoZXZlbnRIYW5kbGUpID0+IGV2ZW50SGFuZGxlKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFzVGV4dCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5pbnB1dC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISF0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5wdXRGb2N1cygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJhaXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlucHV0Qmx1cigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW5wdXRDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VkID0gdGhpcy5oYXNUZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRmxvYXRMYWJlbERpcmVjdGl2ZSB9IGZyb20gJy4vZmxvYXQtbGFiZWwuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBleHBvcnRzOiBbRmxvYXRMYWJlbERpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRmxvYXRMYWJlbERpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRMYWJlbE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhlbHBDZW50ZXJTZXJ2aWNlIHtcblxuICAgIGl0ZW1zOiBCZWhhdmlvclN1YmplY3Q8SGVscENlbnRlckl0ZW1bXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhlbHBDZW50ZXJJdGVtW10+KFtdKTtcblxuICAgIHJlZ2lzdGVySXRlbShpdGVtOiBIZWxwQ2VudGVySXRlbSk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBpdGVtc1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgaXRlbSB0byB0aGUgbGlzdFxuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLml0ZW1zLm5leHQoaXRlbXMpO1xuICAgIH1cblxuICAgIHVucmVnaXN0ZXJJdGVtKGl0ZW06IEhlbHBDZW50ZXJJdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGl0ZW1zXG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGl0ZW0gYmVpbmcgdW5yZWdpc3RlcmVkXG4gICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0bSA9PiBpdG0gIT09IGl0ZW0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLml0ZW1zLm5leHQoaXRlbXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWxwQ2VudGVySXRlbSB7XG4gICAgaWNvbj86IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHNlbGVjdD86ICgpID0+IHZvaWQ7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhlbHBDZW50ZXJTZXJ2aWNlLCBIZWxwQ2VudGVySXRlbSB9IGZyb20gJy4vaGVscC1jZW50ZXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t1eEhlbHBDZW50ZXJJdGVtXScgfSlcbmV4cG9ydCBjbGFzcyBIZWxwQ2VudGVySXRlbURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHV4SGVscENlbnRlckl0ZW06IEhlbHBDZW50ZXJJdGVtO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaGVscENlbnRlclNlcnZpY2U6IEhlbHBDZW50ZXJTZXJ2aWNlKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBpdGVtIGluIHRoZSBzZXJ2aWNlXG4gICAgICAgIHRoaXMuX2hlbHBDZW50ZXJTZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLnV4SGVscENlbnRlckl0ZW0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyByZW1vdmUgdGhpcyBpdGVtIHdoZW4gaXQgaXMgZGVzdHJveWVkXG4gICAgICAgIHRoaXMuX2hlbHBDZW50ZXJTZXJ2aWNlLnVucmVnaXN0ZXJJdGVtKHRoaXMudXhIZWxwQ2VudGVySXRlbSk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIZWxwQ2VudGVySXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vaGVscC1jZW50ZXItaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSGVscENlbnRlclNlcnZpY2UgfSBmcm9tICcuL2hlbHAtY2VudGVyLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IFtIZWxwQ2VudGVySXRlbURpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbSGVscENlbnRlckl0ZW1EaXJlY3RpdmVdLFxuICAgIHByb3ZpZGVyczogW0hlbHBDZW50ZXJTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgSGVscENlbnRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24tY29udGFpbmVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBIb3ZlckFjdGlvblNlcnZpY2Uge1xuXG4gICAgYWN0aXZlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIHByaXZhdGUgX2NvbnRhaW5lcjogSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmU7XG4gICAgcHJpdmF0ZSBfZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2hvdmVyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBIb3ZlckFjdGlvbkRpcmVjdGl2ZVtdID0gW107XG5cbiAgICByZWdpc3RlcihhY3Rpb246IEhvdmVyQWN0aW9uRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgIH1cblxuICAgIHVucmVnaXN0ZXIoYWN0aW9uOiBIb3ZlckFjdGlvbkRpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9hY3Rpb25zID0gdGhpcy5fYWN0aW9ucy5maWx0ZXIoYWN0biA9PiBhY3RuICE9PSBhY3Rpb24pO1xuICAgIH1cblxuICAgIHNldENvbnRhaW5lcihjb250YWluZXI6IEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBzZXRGb2N1c1N0YXRlKGZvY3VzOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgc2V0SG92ZXJTdGF0ZShob3ZlcjogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlcmVkID0gaG92ZXI7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIG5leHQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgY29udGFpbmVyIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBmaXJzdCBob3ZlciBhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVySGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0FjdGlvbkF0SW5kZXgoMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhIGhvdmVyIGFjdGlvbiBoYXMgZm9jdXMgdGhlbiBmb2N1cyB0aGUgbmV4dCBhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uSGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRGb2N1c2VkQWN0aW9uSW5kZXgoKSArIDE7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWN0aW9uQXRJbmRleChpbmRleCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByZXZpb3VzKCk6IHZvaWQge1xuICAgICAgICAvLyBpZiBhIGhvdmVyIGFjdGlvbiBoYXMgZm9jdXMgdGhlbiBmb2N1cyB0aGUgcHJldmlvdXMgYWN0aW9uXG4gICAgICAgIGlmICh0aGlzLmFjdGlvbkhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0Rm9jdXNlZEFjdGlvbkluZGV4KCkgLSAxO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNBY3Rpb25BdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVWaXNpYmlsaXR5KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFjdGl2ZS5uZXh0KHRoaXMuX2ZvY3VzZWQgfHwgdGhpcy5faG92ZXJlZCB8fCB0aGlzLmFjdGlvbkhhc0ZvY3VzKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZm9jdXNBY3Rpb25BdEluZGV4KGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9hY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uc1tpbmRleF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Rm9jdXNlZEFjdGlvbkluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmZpbmRJbmRleChhY3Rpb24gPT4gYWN0aW9uID09PSB0aGlzLmdldEZvY3VzZWRBY3Rpb24oKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb250YWluZXJIYXNGb2N1cygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhY3Rpb25IYXNGb2N1cygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRGb2N1c2VkQWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGb2N1c2VkQWN0aW9uKCk6IEhvdmVyQWN0aW9uRGlyZWN0aXZlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuZmluZChhY3Rpb24gPT4gYWN0aW9uLmZvY3VzZWQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgSG92ZXJBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SG92ZXJBY3Rpb25Db250YWluZXJdJyxcbiAgICBwcm92aWRlcnM6IFtIb3ZlckFjdGlvblNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5ob3Zlci1hY3Rpb24tY29udGFpbmVyLWFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICAgICAgJ1t0YWJpbmRleF0nOiAndGFiaW5kZXgnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgICBhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYWN0aXZlJDogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfaG92ZXJBY3Rpb25TZXJ2aWNlOiBIb3ZlckFjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGNvbnRhaW5lciBlbGVtZW50IHdpdGggdGhlIHNlcnZpY2VcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldENvbnRhaW5lcih0aGlzKTtcblxuICAgICAgICAvLyBhcHBseSBhIGNsYXNzIGJhc2VkIG9uIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGNvbnRhaW5lciBhbmQgaXQncyBhY3Rpb25zXG4gICAgICAgIHRoaXMuYWN0aXZlJCA9IHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5hY3RpdmUuc3Vic2NyaWJlKGFjdGl2ZSA9PiB0aGlzLmFjdGl2ZSA9IGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWN0aXZlJC51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJykgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJykgb25Gb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldEZvY3VzU3RhdGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignYmx1cicpIG9uQmx1cigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldEZvY3VzU3RhdGUoZmFsc2UpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSBvbkhvdmVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0SG92ZXJTdGF0ZSh0cnVlKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJykgb25MZWF2ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldEhvdmVyU3RhdGUoZmFsc2UpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dyaWdodCcpIG5leHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5uZXh0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkRlc3Ryb3ksIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhIb3ZlckFjdGlvbl0nLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5ob3Zlci1hY3Rpb24tYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1mb2N1c2VkXSc6ICdmb2N1c2VkJyxcbiAgICAgICAgJ1t0YWJpbmRleF0nOiAndGFiaW5kZXgnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBIb3ZlckFjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMTtcbiAgICBhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIGFjdGl2ZSQ6IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX2hvdmVyQWN0aW9uU2VydmljZTogSG92ZXJBY3Rpb25TZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGFjdGlvblxuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UucmVnaXN0ZXIodGhpcyk7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIGFjdGl2ZW5lc3Mgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmFjdGl2ZSQgPSB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UuYWN0aXZlLnN1YnNjcmliZShhY3RpdmUgPT4gdGhpcy5hY3RpdmUgPSBhY3RpdmUpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgdGhpcy5hY3RpdmUkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJykgb25Gb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJykgb25CbHVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLmFycm93bGVmdCcsIFsnJGV2ZW50J10pIHByZXZpb3VzKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAgICAgICAgXG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5wcmV2aW91cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dyaWdodCcsIFsnJGV2ZW50J10pIG5leHQoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5uZXh0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLWNvbnRhaW5lci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSG92ZXJBY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi5kaXJlY3RpdmUnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgSG92ZXJBY3Rpb25EaXJlY3RpdmUsXG4gICAgSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbWJlZGRlZFZpZXdSZWYsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eExheW91dFN3aXRjaGVySXRlbV0nXG59KVxuZXhwb3J0IGNsYXNzIExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoJ3V4TGF5b3V0U3dpdGNoZXJJdGVtJykgcHJpdmF0ZSBfY29uZmlnOiBMYXlvdXRTd2l0Y2hlckl0ZW07XG5cbiAgICBwcml2YXRlIF9lbWJlZGRlZFZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHsgfVxuXG4gICAgZ2V0TGF5b3V0KCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVSZWY7XG4gICAgfVxuXG4gICAgZ2V0Q29uZmlnKCk6IExheW91dFN3aXRjaGVySXRlbSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlldyA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlUmVmKTtcbiAgICB9XG5cbiAgICBkZWFjdGl2YXRlKCk6IHZvaWQge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmluZGV4T2YodGhpcy5fZW1iZWRkZWRWaWV3KTtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5yZW1vdmUoaW5kZXgpO1xuICAgICAgICB0aGlzLl9lbWJlZGRlZFZpZXcgPSBudWxsO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExheW91dFN3aXRjaGVySXRlbSB7XG4gICAgZ3JvdXA/OiBzdHJpbmc7XG4gICAgbWluV2lkdGg/OiBudW1iZXI7XG4gICAgbWF4V2lkdGg/OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBRdWVyeUxpc3QsIENvbnRlbnRDaGlsZHJlbiwgSW5wdXQsIEFmdGVyQ29udGVudEluaXQsIFZpZXdDb250YWluZXJSZWYsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4uL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TGF5b3V0U3dpdGNoZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBMYXlvdXRTd2l0Y2hlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcyB7XG5cbiAgICBASW5wdXQoKSBncm91cDogc3RyaW5nO1xuICAgIEBDb250ZW50Q2hpbGRyZW4oTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlKSBwcml2YXRlIF9sYXlvdXRzOiBRdWVyeUxpc3Q8TGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlPjtcbiAgICBcbiAgICBwcml2YXRlIF93aWR0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgX2FjdGl2ZUxheW91dDogTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSBjb250YWluZXIgc2l6ZVxuICAgICAgICByZXNpemVTZXJ2aWNlLmFkZFJlc2l6ZUxpc3RlbmVyKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IGV2ZW50LndpZHRoO1xuXG4gICAgICAgICAgICAvLyByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIGxheW91dFxuICAgICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVMYXlvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZSBhY3RpdmUgZ3JvdXAgaGFzIGNoYW5nZWQgdGhlbiByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIGxheW91dFxuICAgICAgICBpZiAoY2hhbmdlcy5ncm91cC5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMuZ3JvdXAucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEFjdGl2ZUxheW91dCgpOiBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUgfCBudWxsIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgY3VycmVudGx5IG5vIGxheW91dHMgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UgZmluZCBsYXlvdXRzIHRoYXQgbWF0Y2ggdGhlIGFjdGl2ZSBncm91cCBhbmQgdGhhdCBtZWV0IHRoZSBjb25zdHJhaW50c1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0cy5maWx0ZXIobGF5b3V0ID0+IHRoaXMuZ3JvdXAgPT09IGxheW91dC5nZXRDb25maWcoKS5ncm91cCkuZmluZChsYXlvdXQgPT4ge1xuXG4gICAgICAgICAgICBsZXQgbWluV2lkdGggPSBsYXlvdXQuZ2V0Q29uZmlnKCkubWluV2lkdGggfHwgMDtcbiAgICAgICAgICAgIGxldCBtYXhXaWR0aCA9IGxheW91dC5nZXRDb25maWcoKS5tYXhXaWR0aCB8fCBJbmZpbml0eTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoID49IG1pbldpZHRoICYmIHRoaXMuX3dpZHRoIDwgbWF4V2lkdGg7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZUFjdGl2ZUxheW91dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGxheW91dCB0aGF0IHNob3VsZCBiZSBzaG93blxuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5nZXRBY3RpdmVMYXlvdXQoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgY3VycmVudGx5IHNob3dpbmcgdGhlIGxheW91dFxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlTGF5b3V0ID09PSBsYXlvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCBsYXlvdXRcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGF5b3V0LmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBuZXcgYWN0aXZlIGxheW91dFxuICAgICAgICB0aGlzLl9hY3RpdmVMYXlvdXQgPSBsYXlvdXQ7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIGxheW91dCB0aGVuIGFjdGl2YXRlXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUxheW91dC5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGN1cnJlbnQgZWxlbWVudCB3aWR0aFxuICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIGxheW91dCAtIG5lZWQgYSBkZWxheSBhcyBBbmd1bGFyIGRvZXNuJ3QgbGlrZSBjaGFuZ2VzIGxpa2UgdGhpcyBpbiB0aGVzZSBsaWZlY3ljbGUgaG9va3NcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlQWN0aXZlTGF5b3V0LmJpbmQodGhpcykpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTGF5b3V0U3dpdGNoZXJEaXJlY3RpdmUgfSBmcm9tICcuL2xheW91dC1zd2l0Y2hlci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9sYXlvdXQtc3dpdGNoZXItaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vcmVzaXplL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIExheW91dFN3aXRjaGVyRGlyZWN0aXZlLFxuICAgIExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIFJlc2l6ZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TLFxuICAgIHByb3ZpZGVyczogW10sXG59KVxuZXhwb3J0IGNsYXNzIExheW91dFN3aXRjaGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eE92ZXJmbG93T2JzZXJ2ZXJdLCBbdXhPdmVyZmxvd0hvcml6b250YWxPYnNlcnZlcl0sIFt1eE92ZXJmbG93VmVydGljYWxPYnNlcnZlcl0nLFxuICBleHBvcnRBczogJ3V4LW92ZXJmbG93LW9ic2VydmVyJ1xufSlcbmV4cG9ydCBjbGFzcyBPdmVyZmxvd0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAvKiogQWxsb3cgYSBvYnNlcnZhYmxlIHRvIGJlIHVzZWQgdG8gY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIEBJbnB1dCgpIHRyaWdnZXI6IE9ic2VydmFibGU8dm9pZD47XG5cbiAgLyoqIEFsbG93IG92ZXJmbG93IHRvIGJlIHdpdGhpbiBhIHJhbmdlIGJlZm9yZSBlbWl0dGluZyAqL1xuICBASW5wdXQoKSB0b2xlcmFuY2U6IG51bWJlciA9IDA7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSB0byB0aGUgb3ZlcmZsb3cgc3RhdGUgLSBob3Jpem9udGFsIG9yIHZlcnRpY2FsICovXG4gIEBPdXRwdXQoKSB1eE92ZXJmbG93T2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSB0byBvdmVyZmxvdyBvbiB0aGUgaG9yaXpvbnRhbCBheGlzICovXG4gIEBPdXRwdXQoKSB1eE92ZXJmbG93SG9yaXpvbnRhbE9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBFbWl0IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2UgdG8gb3ZlcmZsb3cgb24gdGhlIHZlcnRpY2FsIGF4aXMgKi9cbiAgQE91dHB1dCgpIHV4T3ZlcmZsb3dWZXJ0aWNhbE9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBTdG9yZSB0aGUgb3ZlcmZsb3cgc3RhdGUgb24gYm90aCBheGlzICovXG4gIHByaXZhdGUgX3N0YXRlID0geyBob3Jpem9udGFsT3ZlcmZsb3c6IGZhbHNlLCB2ZXJ0aWNhbE92ZXJmbG93OiBmYWxzZSB9O1xuXG4gIC8qKiBVbnN1YnNjcmliZSBmcm9tIGFsbCB0aGUgb2JzZXJ2YWJsZXMgKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAvKiogU2V0IHVwIHRoZSB0cmlnZ2VyIGlmIHNwZWNpZmllZCAqL1xuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50cmlnZ2VyKSB7XG4gICAgICB0aGlzLnRyaWdnZXIucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2hlY2tGb3JPdmVyZmxvdygpKTtcbiAgICB9XG4gIH1cblxuICAvKiogUGVyZm9ybSBhbiBpbnRpYWwgY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5jaGVja0Zvck92ZXJmbG93KCkpO1xuICB9XG5cbiAgLyoqIFVuc3Vic2NyaWJlIGZyb20gdGhlIHRyaWdnZXIgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBQcm9ncmFtbWF0aWNhbGx5IHRyaWdnZXIgY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIGNoZWNrRm9yT3ZlcmZsb3coKTogdm9pZCB7XG5cbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQsIHNjcm9sbFdpZHRoLCBzY3JvbGxIZWlnaHQgfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBob3Jpem9udGFsT3ZlcmZsb3cgPSAoc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aCkgPiB0aGlzLnRvbGVyYW5jZTtcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJmbG93ID0gKHNjcm9sbEhlaWdodCAtIG9mZnNldEhlaWdodCkgPiB0aGlzLnRvbGVyYW5jZTtcblxuICAgIGlmIChob3Jpem9udGFsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLmhvcml6b250YWxPdmVyZmxvdykge1xuICAgICAgdGhpcy51eE92ZXJmbG93SG9yaXpvbnRhbE9ic2VydmVyLmVtaXQoaG9yaXpvbnRhbE92ZXJmbG93KTtcbiAgICB9XG5cbiAgICBpZiAodmVydGljYWxPdmVyZmxvdyAhPT0gdGhpcy5fc3RhdGUudmVydGljYWxPdmVyZmxvdykge1xuICAgICAgdGhpcy51eE92ZXJmbG93VmVydGljYWxPYnNlcnZlci5lbWl0KHZlcnRpY2FsT3ZlcmZsb3cpO1xuICAgIH1cblxuICAgIGlmIChob3Jpem9udGFsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLmhvcml6b250YWxPdmVyZmxvdyB8fCB2ZXJ0aWNhbE92ZXJmbG93ICE9PSB0aGlzLl9zdGF0ZS52ZXJ0aWNhbE92ZXJmbG93KSB7XG4gICAgICB0aGlzLnV4T3ZlcmZsb3dPYnNlcnZlci5lbWl0KChob3Jpem9udGFsT3ZlcmZsb3cgfHwgdmVydGljYWxPdmVyZmxvdykpO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlID0geyBob3Jpem9udGFsT3ZlcmZsb3csIHZlcnRpY2FsT3ZlcmZsb3cgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE92ZXJmbG93RGlyZWN0aXZlIH0gZnJvbSAnLi9vdmVyZmxvdy9vdmVyZmxvdy1vYnNlcnZlci5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBleHBvcnRzOiBbT3ZlcmZsb3dEaXJlY3RpdmVdLFxuICBkZWNsYXJhdGlvbnM6IFtPdmVyZmxvd0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZXJzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlbGVjdGlvbi5zZXJ2aWNlJztcblxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvblN0cmF0ZWd5IHtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgc2VsZWN0aW9uU2VydmljZT86IFNlbGVjdGlvblNlcnZpY2UpIHsgfVxuXG4gIHNldFNlbGVjdGlvblNlcnZpY2Uoc2VsZWN0aW9uU2VydmljZTogU2VsZWN0aW9uU2VydmljZSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gIH1cblxuICBtb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQgeyB9XG5cbiAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQgeyB9XG5cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7IH1cblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBpdGVtIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgc2VsZWN0KC4uLmRhdGE6IGFueVtdKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdCguLi5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIGl0ZW0ncyBzZWxlY3RlZCBzdGF0ZSAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIHRvZ2dsZSguLi5kYXRhOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS50b2dnbGUoLi4uZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzZWxlY3QgdGhlIGl0ZW0gLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICBkZXNlbGVjdCguLi5kYXRhOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdCguLi5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYWxsIGl0ZW1zIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0KC4uLnRoaXMuc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhbGwgaXRlbXMgLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc2VsZWN0KC4uLnRoaXMuc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0KTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7IH1cbn1cbiIsImltcG9ydCB7IEtleUNvZGUgfSBmcm9tICcuL2tleWNvZGUuZW51bSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc2VsZWN0aW9uLnN0cmF0ZWd5JztcblxuZXhwb3J0IGNsYXNzIFJvd1NlbGVjdGlvblN0cmF0ZWd5IGV4dGVuZHMgU2VsZWN0aW9uU3RyYXRlZ3kge1xuXG4gIC8vIHN0b3JlIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIHJvd1xuICBwcml2YXRlIF9zZWxlY3Rpb246IFNlbGVjdGlvbiA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IG9uIHNoaWZ0IGNsaWNrIHRoZSBicm93c2VyIHdpbGwgaGlnaGxpZ2h0XG4gICAqIHRleHQuIFRoaXMgbG9va3MgYmFkIGFuZCB3ZSBkb24ndCB3YW50IHRoaXMgdG8gb2NjdXJcbiAgICovXG4gIG1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIHJvdyBpcyBjbGlja2VkIHdlIHdhbnQgdG8gaGFuZGxlIHNlbGVjdGlvblxuICAgKi9cbiAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcbiAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblxuICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB3ZSB3YW50IHRvIHBlcmZvcm0gYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGxlU2VsZWN0KGRhdGEpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBjb250cm9sIGtleSBpcyBwcmVzc2VkIHdlIHdhbnQgdG8gcGVyZm9ybSBhbiBhZGRpdGl2ZSB0b2dnbGUgc2VsZWN0aW9uXG4gICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvZ2dsZShkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGEgc2luZ2xlIHNlbGVjdGlvbiB3aGVyZSBhbGwgb3RoZXIgcm93cyBhcmUgZGVzZWxlY3RlZFxuICAgIHRoaXMuc2luZ2xlU2VsZWN0KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvIHN1cHBvcnQgZnVsbCBrZXlib2FyZCBjb250cm9sIHdlIG5lZWQgdG8gc3VwcG9ydCB0aGUgZm9sbG93aW5nOlxuICAgKiAxLiBBcnJvdyBrZXlzIHRvIG5hdmlnYXRlIHVwIGFuZCBkb3duXG4gICAqIDIuIFNwYWNlYmFyIHRvIHRvZ2dsZSBzZWxlY3Rpb25cbiAgICogMy4gU2hpZnQgKyBBcnJvdyBrZXlzIHRvIG11bHRpcGxlIHNlbGVjdFxuICAgKiA0LiBDdHJsICsgQXJyb3cga2V5cyB0byBhbGxvdyByZXRhaW5lZCBzZWxlY3Rpb24gYW5kIG5hdmlnYXRpb25cbiAgICovXG4gIGtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG5cbiAgICAgIGNhc2UgS2V5Q29kZS5VcEFycm93OlxuICAgICAgY2FzZSBLZXlDb2RlLkRvd25BcnJvdzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZShldmVudCwgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEtleUNvZGUuU3BhY2ViYXI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS50b2dnbGUoZGF0YSwgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBzdGFuZGFyZCB0b2dnbGUgZnVuY3Rpb24gdG8gc3RvcmUgb3IgY2xlYXIgdGhlXG4gICAqIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgaXRlbVxuICAgKi9cbiAgdG9nZ2xlKGRhdGE6IGFueSwgYWN0aXZhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIHN1cGVyLnRvZ2dsZShkYXRhKTtcblxuICAgIC8vIHN0b3JlIG9yIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNTZWxlY3RlZChkYXRhKSA/IHRoaXMuc2V0U2VsZWN0aW9uU3RhcnQoZGF0YSkgOiB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG5cbiAgICAvLyBpZiB3ZSB3YW50IHRvIGtlZXAgdGhlIGl0ZW0gYWN0aXZhdGVkIHRoZW4gYWN0aXZhdGVcbiAgICBpZiAoYWN0aXZhdGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG90aGVyIHNlbGVjdGVkIGl0ZW1zIGFuZCBzZWxlY3Qgb25seVxuICAgKiB0aGUgbW9zdCByZWNlbnRseSBzZWxlY3RlZCBpdGVtXG4gICAqL1xuICBwcml2YXRlIHNpbmdsZVNlbGVjdChkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgIC8vIGRlc2VsZWN0IGFsbCBvdGhlciByb3dzIGlmIG5laXRoZXIgbW9kaWZpZXIga2V5IGlzIHByZXNzZWRcbiAgICB0aGlzLmRlc2VsZWN0QWxsKCk7XG5cbiAgICAvLyBzZWxlY3QgdGhlIGN1cnJlbnQgcm93XG4gICAgdGhpcy5zZWxlY3QoZGF0YSk7XG5cbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBpdGVtIGFzIHRoZSBzZWxlY3Rpb24gc3RhcnRcbiAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtdWx0aXBsZSBzZWxlY3Rpb246XG4gICAqIDEuIElmIG5vIHN0YXJ0IGl0ZW0gc2VsZWN0ZWQgLSBzZWxlY3QgaXRcbiAgICogMi4gSWYgYSBzdGFydCBpdGVtIGhhcyBiZWVuIHNlbGVjdGVkIC0gc2VsZWN0IGFsbCBpbiBiZXR3ZWVuXG4gICAqIDMuIElmIGEgc3RhcnQgYW5kIGVuZCBpdGVtIGhhdmUgYmVlbiBzZWxlY3RlZCBjbGVhciB0aGUgcmFuZ2UgYW5kIHRoZW4gc2VsZWN0IHRoZSBuZXcgcmFuZ2VcbiAgICovXG4gIHByb3RlY3RlZCBtdWx0aXBsZVNlbGVjdChkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgIC8vIGlmIG5vIHNlbGVjdGlvbiBjdXJyZW50bHkgZXhpc3RzIHRoZW4gcGVyZm9ybSBpbml0aWFsIHNlbGVjdGlvblxuICAgIGlmICghdGhpcy5fc2VsZWN0aW9uLnN0YXJ0KSB7XG5cbiAgICAgIC8vIHNlbGVjdCB0aGUgcm93XG4gICAgICB0aGlzLnNlbGVjdChkYXRhKTtcblxuICAgICAgLy8gc3RvcmUgdGhlIHN0YXJ0aW5nIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb25TdGFydChkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBpZiBhIG11bHRpcGxlIHNlbGVjdGlvbiBhbHJlYWR5IHRvb2sgcGxhY2UgLSBjbGVhciB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbi5zdGFydCAmJiB0aGlzLl9zZWxlY3Rpb24uZW5kKSB7XG4gICAgICB0aGlzLmRlc2VsZWN0KC4uLnRoaXMuZ2V0U2VsZWN0ZWRJdGVtcygpKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIG5ldyBzZWxlY3Rpb24gZW5kIHBvaW50XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25FbmQoZGF0YSk7XG5cbiAgICAvLyBzZWxlY3QgYWxsIHRoZSBpdGVtcyBpbiB0aGUgcmFuZ2VcbiAgICB0aGlzLnNlbGVjdCguLi50aGlzLmdldFNlbGVjdGVkSXRlbXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzZWxlY3Rpb24gc3RhcnQgcG9pbnQuIElmIHRoZXJlIHdhcyBwcmV2aW91c2x5IGFcbiAgICogc2VsZWN0aW9uIGVuZCBwb2ludCB0aGVuIGNsZWFyIGl0IGFzIHRoaXMgaXMgYSBuZXcgc2VsZWN0aW9uXG4gICAqL1xuICBwcml2YXRlIHNldFNlbGVjdGlvblN0YXJ0KGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGlvbi5zdGFydCA9IGRhdGE7XG4gICAgdGhpcy5fc2VsZWN0aW9uLmVuZCA9IG51bGw7XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiBlbmQgcG9pbnRcbiAgICovXG4gIHByaXZhdGUgc2V0U2VsZWN0aW9uRW5kKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGlvbi5lbmQgPSBkYXRhO1xuXG4gICAgLy8gYWN0aXZhdGUgdGhlIGl0ZW1cbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYm90aCBzdGFydCBhbmQgZW5kIHNlbGVjdGlvbiBwb2ludHNcbiAgICovXG4gIHByb3RlY3RlZCBjbGVhclNlbGVjdGlvbihkZWFjdGl2YXRlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuXG4gICAgLy8gcmVzZXQgdGhlIHNlbGVjdGVkIGl0ZW1cbiAgICB0aGlzLl9zZWxlY3Rpb24gPSB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTtcblxuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgIGlmIChkZWFjdGl2YXRlKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgYWxsIHRoZSBpdGVtcyBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAqIE5vdGUgdGhhdCB0aGUgZW5kIHBvaW50IG1heSBiZSBhYm92ZSB0aGUgc3RhcnQgcG9pbnQgc29cbiAgICogd2UgbmVlZCB0byBhY2NvdW50IGZvciB0aGlzLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTZWxlY3RlZEl0ZW1zKCk6IGFueVtdIHtcblxuICAgIC8vIGdldCB0aGUgbGF0ZXN0IGRhdGFzZXRcbiAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXMuc2VsZWN0aW9uU2VydmljZTtcblxuICAgIC8vIGdldCB0aGUgaW5kZXhlcyBvZiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludFxuICAgIGNvbnN0IHN0YXJ0SWR4ID0gZGF0YXNldC5pbmRleE9mKHRoaXMuX3NlbGVjdGlvbi5zdGFydCk7XG4gICAgY29uc3QgZW5kSWR4ID0gZGF0YXNldC5pbmRleE9mKHRoaXMuX3NlbGVjdGlvbi5lbmQpO1xuXG4gICAgLy8gZ2V0IHRoZSByZWdpb24gb2YgdGhlIGFycmF5IHRoYXQgaXMgc2VsZWN0ZWQgLSBub3RlIHRoZSBlbmRJZHggbWF5IGJlIGJlZm9yZSB0aGUgc3RhcnRJZHggc28gYWNjb3VudCBmb3IgdGhpc1xuICAgIHJldHVybiBkYXRhc2V0LnNsaWNlKE1hdGgubWluKHN0YXJ0SWR4LCBlbmRJZHgpLCBNYXRoLm1heChzdGFydElkeCwgZW5kSWR4KSArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBzaWJsaW5nIGl0ZW0gd2hlbiBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAqL1xuICBwcml2YXRlIG5hdmlnYXRlKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSB3aGljaCBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkXG4gICAgY29uc3QgeyBjdHJsS2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG5cbiAgICAvLyBpZiBubyBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkIHRoZW4gZGVzZWxlY3QgYWxsIGFuZCBjbGVhciB0aGUgc2VsZWN0aW9uXG4gICAgaWYgKCFjdHJsS2V5ICYmICFzaGlmdEtleSkge1xuICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xuICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbihmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gYWN0aXZhdGUgdGhlIHNpYmxpbmcgLSBpZiB0aGUgdXAgYXJyb3cgaXMgcHJlc3NlZCB0aGVuIG5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBzaWJsaW5nXG4gICAgY29uc3Qgc2libGluZyA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcoZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5VcEFycm93KTtcblxuICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB0aGVuIHdlIGFsc28gd2FudCB0byB0b2dnbGUgdGhlIHN0YXRlIGlmIHRoZSBpdGVtXG4gICAgaWYgKHNoaWZ0S2V5ICYmIHNpYmxpbmcpIHtcblxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24gc3RhcnQgdGhlbiBzZWxlY3QgdGhlIGN1cnJlbnQgcm93XG4gICAgICBpZiAoIXRoaXMuX3NlbGVjdGlvbi5zdGFydCkge1xuICAgICAgICB0aGlzLm11bHRpcGxlU2VsZWN0KGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm11bHRpcGxlU2VsZWN0KHNpYmxpbmcpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvbiB7XG4gIHN0YXJ0OiBhbnk7XG4gIGVuZDogYW55O1xufVxuIiwiaW1wb3J0IHsgS2V5Q29kZSB9IGZyb20gJy4va2V5Y29kZS5lbnVtJztcclxuaW1wb3J0IHsgUm93U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3Jvdy1zZWxlY3Rpb24uc3RyYXRlZ3knO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJvd0FsdFNlbGVjdGlvblN0cmF0ZWd5IGV4dGVuZHMgUm93U2VsZWN0aW9uU3RyYXRlZ3kge1xyXG4gICAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgS2V5Q29kZS5VcEFycm93OlxyXG4gICAgICAgICAgICBjYXNlIEtleUNvZGUuRG93bkFycm93OlxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ3Vyc29yS2V5KGV2ZW50LCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBLZXlDb2RlLlNwYWNlYmFyOlxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS50b2dnbGUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgdGhlIHNpYmxpbmcgaXRlbSB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVDdXJzb3JLZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkXHJcbiAgICAgICAgY29uc3QgeyBjdHJsS2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vIGlmIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQgdGhlbiBkZXNlbGVjdCBhbGwgYW5kIGNsZWFyIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICBpZiAoIWN0cmxLZXkgJiYgIXNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbihmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3RybEtleSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKGV2ZW50LmtleUNvZGUgPT09IEtleUNvZGUuVXBBcnJvdyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5nZXRTaWJsaW5nKGV2ZW50LmtleUNvZGUgPT09IEtleUNvZGUuVXBBcnJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3Qoc2libGluZyA/IHNpYmxpbmcgOiBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgS2V5Q29kZSB9IGZyb20gJy4va2V5Y29kZS5lbnVtJztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5leHBvcnQgY2xhc3MgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGl0ZW0gaXMgY2xpY2tlZCBzaW1wbHkgdG9nZ2xlIHRoZSBjdXJyZW50IHNlbGVjdGVkIHN0YXRlXG4gICAqL1xuICBjbGljayhldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy50b2dnbGUoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGJhc2ljIGtleWJvYXJkIHN1cHBvcnQgZm9yIG5hdmlnYXRpbmdcbiAgICogYW5kIHNlbGVjdGluZy9kZXNlbGVjdGluZyBpdGVtc1xuICAgKi9cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcblxuICAgICAgY2FzZSBLZXlDb2RlLlVwQXJyb3c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKHRydWUpO1xuXG4gICAgICBjYXNlIEtleUNvZGUuRG93bkFycm93OlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyhmYWxzZSk7XG5cbiAgICAgIGNhc2UgS2V5Q29kZS5TcGFjZWJhcjpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgc3RhbmRhcmQgdG9nZ2xlIGZ1bmN0aW9uIHRvIGFsd2F5cyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgKi9cbiAgdG9nZ2xlKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHN1cGVyLnRvZ2dsZShkYXRhKTtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LWFsdC1zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgUm93U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LXNlbGVjdGlvbi5zdHJhdGVneSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvc2ltcGxlLXNlbGVjdGlvbi5zdHJhdGVneSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zZWxlY3Rpb24gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3N0cmF0ZWd5VG9EZXN0cm95OiBTZWxlY3Rpb25TdHJhdGVneTtcblxuICBkYXRhc2V0OiBhbnlbXSA9IFtdO1xuICBlbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgY2xpY2tFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAga2V5Ym9hcmRFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgc3RyYXRlZ3k6IFNlbGVjdGlvblN0cmF0ZWd5ID0gbmV3IFNpbXBsZVNlbGVjdGlvblN0cmF0ZWd5KHRoaXMpO1xuXG4gIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGFueT4obnVsbCk7XG4gIGZvY3VzVGFyZ2V0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcbiAgc2VsZWN0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55W10+KFtdKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zdHJhdGVneVRvRGVzdHJveSA9IHRoaXMuc3RyYXRlZ3k7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kpIHtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIGl0ZW0gaXMgbm90IGN1cnJlbnRseSBzZWxlY3RlZCB0aGVuIGFkZCBpdFxuICAgKiB0byB0aGUgbGlzdCBvZiBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG5cbiAgICAvLyBhZGQgZWFjaCBzZWxlY3Rpb24gdG8gdGhlIHNldFxuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5fc2VsZWN0aW9uLmFkZChzZWxlY3Rpb24pKTtcblxuICAgIC8vIHByb3BhZ2F0ZSB0aGUgY2hhbmdlc1xuICAgIHRoaXMuc2VsZWN0aW9uSGFzTXV0YXRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIGRlc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG4gICAgLy8gcmVtb3ZlIGVhY2ggaXRlbSBmcm9tIHRoZSBzZXRcbiAgICBzZWxlY3Rpb25zLmZvckVhY2goc2VsZWN0aW9uID0+IHRoaXMuX3NlbGVjdGlvbi5kZWxldGUoc2VsZWN0aW9uKSk7XG5cbiAgICAvLyBwcm9wYWdhdGUgdGhlIGNoYW5nZXNcbiAgICB0aGlzLnNlbGVjdGlvbkhhc011dGF0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIGFueSBzcGVjaWZpZWQgaXRlbXNcbiAgICovXG4gIHRvZ2dsZSguLi5zZWxlY3Rpb25zOiBhbnlbXSk6IHZvaWQge1xuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5pc1NlbGVjdGVkKHNlbGVjdGlvbikgPyB0aGlzLmRlc2VsZWN0KHNlbGVjdGlvbikgOiB0aGlzLnNlbGVjdChzZWxlY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKi9cbiAgaXNTZWxlY3RlZChkYXRhOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmhhcyhkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JzZXJ2YWJsZSBzcGVjaWZpY2FsbHkgZm9yIG5vdGlmeWluZyB0aGUgc3Vic2NyaWJlclxuICAgKiBvbmx5IHdoZW4gdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiBhIHNwZWNpZmljIG9iamVjdCBoYXMgY2hhbmdlZFxuICAgKi9cbiAgc2VsZWN0ZWQkKGRhdGE6IGFueSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiQucGlwZShtYXAoKCkgPT4gdGhpcy5pc1NlbGVjdGVkKGRhdGEpKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGhvdyBzZWxlY3Rpb25zIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gICAqIFRoaXMgYWxsb3dzIHVzIHRvIHVzZSBhbiBzdHJhdGVneSBwYXR0ZXJuIHRvIGhhbmRsZSB0aGUgdmFyaW91cyBrZXlib2FyZFxuICAgKiBhbmQgbW91c2UgaW50ZXJhY3Rpb25zIHdoaWxlIGtlZXBpbmcgZWFjaCBtb2RlIHNlcGFyYXRlZCBhbmRcbiAgICogZWFzaWx5IGV4dGVuc2libGUgaWYgd2Ugd2FudCB0byBhZGQgbW9yZSBtb2RlcyBpbiBmdXR1cmUhXG4gICAqL1xuICBzZXRNb2RlKG1vZGU6IFNlbGVjdGlvbk1vZGUgfCBTZWxlY3Rpb25TdHJhdGVneSk6IHZvaWQge1xuXG4gICAgaWYgKHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95KSB7XG4gICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHN0cmF0ZWd5IGlmIGl0IHdhcyBjcmVhdGVkIGludGVybmFsbHlcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobW9kZSBpbnN0YW5jZW9mIFNlbGVjdGlvblN0cmF0ZWd5KSB7XG5cbiAgICAgIC8vIEN1c3RvbSBzdHJhdGVneSAtIHBhc3MgaW4gdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgIHRoaXMuc3RyYXRlZ3kgPSBtb2RlO1xuICAgICAgdGhpcy5zdHJhdGVneS5zZXRTZWxlY3Rpb25TZXJ2aWNlKHRoaXMpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc3dpdGNoIChtb2RlLnRvTG93ZXJDYXNlKCkudHJpbSgpKSB7XG5cbiAgICAgICAgY2FzZSAnc2ltcGxlJzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgUm93U2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93LWFsdCc6XG4gICAgICAgICAgdGhpcy5zdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbmV3IFJvd0FsdFNlbGVjdGlvblN0cmF0ZWd5KHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2VsZWN0aW9uIG1vZGUgJyR7bW9kZX0nIGRvZXMgbm90IGV4aXN0LiBWYWxpZCBtb2RlcyBhcmUgJ3NpbXBsZScsICdyb3cnLCBvciAncm93LWFsdCcuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgKi9cbiAgYWN0aXZhdGUoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmUkLm5leHQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmUgYWxsIGl0ZW1zXG4gICAqL1xuICBkZWFjdGl2YXRlKCk6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlJC5uZXh0KG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBvciBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtLlxuICAgKiBAcGFyYW0gcHJldmlvdXMgSWYgdHJ1ZSwgdGhlIHByZXZpb3VzIHNpYmxpbmcgd2lsbCBiZSByZXR1cm5lZC5cbiAgICovXG4gIGdldFNpYmxpbmcocHJldmlvdXM6IGJvb2xlYW4gPSBmYWxzZSk6IGFueSB7XG5cbiAgICAvLyBnZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbVxuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmFjdGl2ZSQuZ2V0VmFsdWUoKTtcblxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgaXRlbVxuICAgIGNvbnN0IGlkeCA9IHRoaXMuZGF0YXNldC5pbmRleE9mKGN1cnJlbnQpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZGF0YXNldFtwcmV2aW91cyA/IGlkeCAtIDEgOiBpZHggKyAxXTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIHNpYmxpbmcgb2YgdGhlIGN1cnJlbnQgYWN0aXZlIGl0ZW0uXG4gICAqIElmIHByZXZpb3VzIGlzIHNldCB0byB0cnVlIHRoZSBwcmV2aW91cyBzaWJsaW5nIHdpbGwgYmUgYWN0aXZhdGVkXG4gICAqIHJhdGhlciB0aGFuIHRoZSBuZXh0IHNpYmxpbmcuIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIHJldHVybiB0aGVcbiAgICogZGF0YSBvZiB0aGUgbmV3bHkgYWN0aXZhdGVkIHNpYmxpbmdcbiAgICovXG4gIGFjdGl2YXRlU2libGluZyhwcmV2aW91czogYm9vbGVhbiA9IGZhbHNlKTogYW55IHtcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0U2libGluZyhwcmV2aW91cyk7XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgdGFyZ2V0IGV4aXN0c1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBkaXNhYmxlZCBzdGF0ZVxuICAgIHRoaXMuZW5hYmxlZCA9ICFkaXNhYmxlZDtcblxuICAgIC8vIGNsZWFyIGFueSBzdGF0ZWZ1bCBkYXRhXG4gICAgdGhpcy5hY3RpdmUkLm5leHQobnVsbCk7XG4gICAgdGhpcy5fc2VsZWN0aW9uLmNsZWFyKCk7XG5cbiAgICAvLyBlbWl0IHRoZSBzZWxlY3Rpb24gY2hhbmdlIGluZm9ybWF0aW9uXG4gICAgdGhpcy5zZWxlY3Rpb25IYXNNdXRhdGVkKCk7XG4gIH1cblxuICBwcml2YXRlIHNlbGVjdGlvbkhhc011dGF0ZWQoKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3Rpb24kLm5leHQoQXJyYXkuZnJvbSh0aGlzLl9zZWxlY3Rpb24pKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25Nb2RlID0gJ3NpbXBsZScgfCAncm93JyB8ICdyb3ctYWx0JztcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vc2VsZWN0aW9uLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbdXhTZWxlY3Rpb25JdGVtXScsXHJcbiAgZXhwb3J0QXM6ICd1eC1zZWxlY3Rpb24taXRlbSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gIEBJbnB1dCgpIHV4U2VsZWN0aW9uSXRlbTogYW55O1xyXG5cclxuICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2NsYXNzLnV4LXNlbGVjdGlvbi1zZWxlY3RlZCcpXHJcbiAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkOiBib29sZWFuKSB7XHJcbiAgICBzZWxlY3RlZCA/IHRoaXMuc2VsZWN0KCkgOiB0aGlzLmRlc2VsZWN0KCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnV4LXNlbGVjdGlvbi1mb2N1c2VkJykgYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXHJcbiAgZ2V0IGF0dHJUYWJJbmRleCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuICh0aGlzLnRhYmluZGV4ICE9PSBudWxsKSA/IHRoaXMudGFiaW5kZXggOiB0aGlzLl9tYW5hZ2VkVGFiSW5kZXg7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHByaXZhdGUgX21hbmFnZWRUYWJJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VsZWN0aW9uU2VydmljZTogU2VsZWN0aW9uU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG5cclxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGFzc29jaWF0ZWQgZGF0YSB0aGVuIHRocm93IGFuIGVycm9yXHJcbiAgICBpZiAoIXRoaXMudXhTZWxlY3Rpb25JdGVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHV4U2VsZWN0aW9uSXRlbSBkaXJlY3RpdmUgbXVzdCBoYXZlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0LicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBzZWxlY3Rpb24gY2hhbmdlcyBvbiB0aGlzIGl0ZW1cclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0ZWQkKHRoaXMudXhTZWxlY3Rpb25JdGVtKS5zdWJzY3JpYmUoc2VsZWN0ZWQgPT4ge1xyXG5cclxuICAgICAgLy8gc3RvcmUgdGhlIHNlbGVjdGVkIHN0YXRlXHJcbiAgICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcblxyXG4gICAgICAvLyBlbWl0IHRoZSBzZWxlY3RlZCBzdGF0ZVxyXG4gICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0ZWQpO1xyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIHRoZSBhY3RpdmUgc3RhdGVcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuYWN0aXZlJC5waXBlKG1hcChhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzLnV4U2VsZWN0aW9uSXRlbSkpLnN1YnNjcmliZShhY3RpdmUgPT4ge1xyXG5cclxuICAgICAgLy8gc3RvcmUgdGhlIGZvY3VzIHN0YXRlXHJcbiAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xyXG5cclxuICAgICAgLy8gaWYgaXQgaXMgYWN0aXZlIHRoZW4gZm9jdXMgdGhlIGVsZW1lbnRcclxuICAgICAgaWYgKGFjdGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZm9jdXNUYXJnZXQkLm5leHQodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gdGhlIGZvY3VzIHRhcmdldFxyXG4gICAgLy8gVGhpcyBpcyBtb3N0bHkgdGhlIHNhbWUgYXMgYWN0aXZlJCwgZXhjZXB0IHRoYXQgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWUgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZCh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzVGFyZ2V0JC5zdWJzY3JpYmUoZm9jdXNUYXJnZXQgPT4ge1xyXG4gICAgICB0aGlzLl9tYW5hZ2VkVGFiSW5kZXggPSAoZm9jdXNUYXJnZXQgPT09IHRoaXMudXhTZWxlY3Rpb25JdGVtKSA/IDAgOiAtMTtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKSBjbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmNsaWNrRW5hYmxlZCkge1xyXG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LmNsaWNrKGV2ZW50LCB0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nLCBbJyRldmVudCddKSBtb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQgJiYgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5jbGlja0VuYWJsZWQpIHtcclxuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS5tb3VzZWRvd24oZXZlbnQsIHRoaXMudXhTZWxlY3Rpb25JdGVtKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKSBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkICYmIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uua2V5Ym9hcmRFbmFibGVkKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kua2V5ZG93bihldmVudCwgdGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBmb2N1cygpOiB2b2lkIHtcclxuICAgIC8vIElmIHRhYmJlZCB0byBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudCwgYWN0aXZhdGUuXHJcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmUkLmdldFZhbHVlKCkgIT09IHRoaXMudXhTZWxlY3Rpb25JdGVtKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0IHRoaXMgaXRlbSB1c2luZyB0aGUgY3VycmVudCBzdHJhdGVneVxyXG4gICAqL1xyXG4gIHNlbGVjdCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS5zZWxlY3QodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzZWxlY3QgdGhpcyBpdGVtIHVzaW5nIHRoZSBjdXJyZW50IHN0cmF0ZWd5XHJcbiAgICovXHJcbiAgZGVzZWxlY3QoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuZGVzZWxlY3QodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTZWxlY3Rpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9zZWxlY3Rpb24taXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZSwgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvc2VsZWN0aW9uLnN0cmF0ZWd5JztcblxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhTZWxlY3Rpb25dJyxcbiAgZXhwb3J0QXM6ICd1eC1zZWxlY3Rpb24nLFxuICBwcm92aWRlcnM6IFsgU2VsZWN0aW9uU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KCkgc2V0IHV4U2VsZWN0aW9uKGl0ZW1zOiBhbnlbXSkge1xuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0KC4uLml0ZW1zKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBkaXNhYmxlZChkaXNhYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2V0RGlzYWJsZWQoZGlzYWJsZWQpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IG1vZGUobW9kZTogU2VsZWN0aW9uTW9kZSB8IFNlbGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZXRNb2RlKG1vZGUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGNsaWNrU2VsZWN0aW9uKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmNsaWNrRW5hYmxlZCA9IGVuYWJsZWQ7XG4gIH1cblxuICBASW5wdXQoKSBzZXQga2V5Ym9hcmRTZWxlY3Rpb24oZW5hYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uua2V5Ym9hcmRFbmFibGVkID0gZW5hYmxlZDtcbiAgfVxuXG4gIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpIHRhYmluZGV4OiBudW1iZXIgPSBudWxsO1xuXG4gIEBPdXRwdXQoKSB1eFNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihTZWxlY3Rpb25JdGVtRGlyZWN0aXZlKSBpdGVtczogUXVlcnlMaXN0PFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmU+O1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VsZWN0aW9uU2VydmljZTogU2VsZWN0aW9uU2VydmljZSwgcHJpdmF0ZSBfY2RSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uJC5zdWJzY3JpYmUoaXRlbXMgPT4gdGhpcy51eFNlbGVjdGlvbkNoYW5nZS5lbWl0KGl0ZW1zKSkpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIC8vIHByb3ZpZGUgdGhlIGluaXRpYWwgbGlzdCBvZiBzZWxlY3Rpb24gaXRlbXNcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgLy8gaWYgdGhlIGxpc3QgY2hhbmdlcyB0aGVuIGluZm9ybSB0aGUgc2VydmljZVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHRoaXMuaXRlbXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGUoKSkpO1xuXG4gICAgLy8gVGhlIGFib3ZlIGNvdWxkIHRyaWdnZXIgYSBjaGFuZ2UgaW4gdGhlIGNvbXB1dGVkIHRhYmluZGV4IGZvciBzZWxlY3Rpb24gaXRlbXNcbiAgICB0aGlzLl9jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkYXRhc2V0IHRvIHJlZmxlY3QgdGhlIGxhdGVzdCBzZWxlY3Rpb24gaXRlbXNcbiAgICovXG4gIHVwZGF0ZSgpOiB2b2lkIHtcblxuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZGF0YXNldCA9IHRoaXMuaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS51eFNlbGVjdGlvbkl0ZW0pO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYSB0YWIgdGFyZ2V0IGhhcyBiZWVuIGRlZmluZWQgc28gdGhhdCB0aGUgY29tcG9uZW50IGNhbiBiZSB0YWJiZWQgdG8uXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZm9jdXNUYXJnZXQkLmdldFZhbHVlKCkgPT09IG51bGwgJiYgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZm9jdXNUYXJnZXQkLm5leHQodGhpcy5fc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0WzBdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGFsbCB0aGUgaXRlbXMgaW4gdGhlIGxpc3RcbiAgICovXG4gIHNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnNlbGVjdEFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhbGwgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LmRlc2VsZWN0QWxsKCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL3NlbGVjdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuL3NlbGVjdGlvbi5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW1NlbGVjdGlvbkRpcmVjdGl2ZSwgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtTZWxlY3Rpb25EaXJlY3RpdmUsIFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdjb250YWN0LWdyb3VwJ1xufSlcbmV4cG9ydCBjbGFzcyBDb250YWN0c05nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgY29udGFjdHM6IENvbnRhY3RbXTtcbiAgICBASW5wdXQoKSBvcmdhbml6YXRpb246IHN0cmluZztcbiAgICBASW5wdXQoKSBzaXplOiAnbWVkaXVtJyB8ICdzbWFsbCc7XG4gICAgQElucHV0KCkgY29sb3JzOiBhbnk7XG4gICAgQElucHV0KCkgbWF4Q29udGFjdHM6IG51bWJlcjtcblxuICAgIEBPdXRwdXQoKSBvdmVyZmxvd0NsaWNrOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2NvbnRhY3RHcm91cCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFjdCB7XG4gICAgdGVzdDogc3RyaW5nO1xuICAgIHN0YXR1czogJ2FjdGl2ZScgfCAncGFzc2l2ZSc7XG4gICAgY3VzdG9tVG9vbHRpcD86IHtcbiAgICAgICAgdGVtcGxhdGU6IHN0cmluZyxcbiAgICAgICAgdG9vbHRpcFBvc2l0aW9uOiBzdHJpbmc7XG4gICAgICAgIGRhdGE/OiBhbnk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcmdhbml6YXRpb24ge1xuICAgIHRleHQ6IHN0cmluZztcbiAgICBsYWJlbDogJ2V4dGVybmFsJyB8ICdyaXNrJztcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIGN1c3RvbVRvb2x0aXA/OiB7XG4gICAgICAgIHRlbXBsYXRlOiBzdHJpbmcsXG4gICAgICAgIHRvb2x0aXBQb3NpdGlvbjogc3RyaW5nO1xuICAgICAgICBkYXRhPzogYW55O1xuICAgIH07XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2V4cGFuZC1pbnB1dCdcbn0pXG5leHBvcnQgY2xhc3MgRXhwYW5kSW5wdXROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGVsbmFtZTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHBsYWNlSG9sZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xlYXJUZXh0SWNvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNsb3NlU2VhcmNoOiBzdHJpbmc7XG4gICAgQElucHV0KCkgZXhwYW5kQWx3YXlzOiBib29sZWFuO1xuICAgIEBJbnB1dCgpIG9uRW50ZXI6IEZ1bmN0aW9uO1xuXG4gICAgQE91dHB1dCgpIGZvY3VzOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdleHBhbmRJbnB1dCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZmxvYXRpbmctYWN0aW9uLWJ1dHRvbidcbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25OZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGl0ZW1zOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbkl0ZW1bXSA9IFtdO1xuICAgIEBJbnB1dCgpIHByaW1hcnk6IHN0cmluZztcbiAgICBASW5wdXQoKSBkaXJlY3Rpb246ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnO1xuICAgIEBJbnB1dCgpIGZhYlRvb2x0aXA6IHN0cmluZztcbiAgICBASW5wdXQoKSBmYWJUb29sdGlwUGxhY2VtZW50OiAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JztcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignZmxvYXRpbmdBY3Rpb25CdXR0b24nLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZsb2F0aW5nQWN0aW9uQnV0dG9uSXRlbSB7XG4gICAgaWNvbjogc3RyaW5nO1xuICAgIGV2ZW50OiBGdW5jdGlvbjtcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIHRvb2x0aXBQbGFjZW1lbnQ/OiBzdHJpbmc7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2Zsb3QnXG59KVxuZXhwb3J0IGNsYXNzIEZsb3ROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGFzZXQ6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgY2FsbGJhY2s6IGFueTtcbiAgICBASW5wdXQoKSBkb251dExhYmVsczogYW55O1xuICAgIEBPdXRwdXQoKSBvblBsb3RDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICAgIEBPdXRwdXQoKSBvblBsb3RIb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eEZsb3ROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2dyaWQnXG59KVxuZXhwb3J0IGNsYXNzIEdyaWROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIHNvdXJjZTogYW55W10gPSBbXTtcbiAgICBASW5wdXQoKSBjb2x1bW5zOiBHcmlkQ29sdW1uW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaW5wdXRzIGFyZSB1bmRvY3VtZW50ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgZXZlbnRzOiBhbnk7XG4gICAgQElucHV0KCkgcGx1Z2luczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdncmlkJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkQ29sdW1uIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHRlbXBsYXRlOiBzdHJpbmc7XG4gICAgd2lkdGg/OiBzdHJpbmc7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnaGllcmFyY2h5LWJhcidcbn0pXG5leHBvcnQgY2xhc3MgSGllcmFyY2h5QmFyTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnlbXTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBIaWVyYXJjaHlCYXJPcHRpb25zO1xuICAgIEBJbnB1dCgpIHNlbGVjdE5vZGU6IGFueTtcbiAgICBASW5wdXQoKSBjb250YWluZXJDbGFzczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdoaWVyYXJjaHlCYXInLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpZXJhcmNoeUJhck9wdGlvbnMge1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgb3ZlcnZpZXc/OiBGdW5jdGlvbjtcbiAgICBpbWFnZTogRnVuY3Rpb247XG4gICAgdmFsdWVGb3JtYXR0ZXI6IEZ1bmN0aW9uO1xuICAgIGFjdGlvbj86IHtcbiAgICAgICAgdGl0bGU6IHN0cmluZztcbiAgICAgICAgZXZlbnQ6IEZ1bmN0aW9uO1xuICAgIH07XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ21hcnF1ZWUtd2l6YXJkJ1xufSlcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSB3aXphcmRJY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgd2l6YXJkU3RlcHM6IE1hcnF1ZWVXaXphcmRTdGVwW107XG4gICAgQElucHV0KCkgYnV0dG9uT3B0aW9uczogTWFycXVlZVdpemFyZE9wdGlvbnM7XG4gICAgQElucHV0KCkgb25DaGFuZ2luZzogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25GaW5pc2hlZDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25GaW5pc2hpbmc6IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIG9uQ2FuY2VsZWQ6IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIGlzVmlzaXRlZDogYm9vbGVhbjtcbiAgICBASW5wdXQoKSBzaWRlSW5mbzogTWFycXVlZVdpemFyZFNpZGVJbmZvO1xuXG4gICAgQE91dHB1dCgpIHdpemFyZFN0ZXBzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TWFycXVlZVdpemFyZFN0ZXBbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPE1hcnF1ZWVXaXphcmRTdGVwW10+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ21hcnF1ZWVXaXphcmQnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcnF1ZWVXaXphcmRTdGVwIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGh0bWw/OiBzdHJpbmc7XG4gICAgaGVhZGVyPzogc3RyaW5nO1xuICAgIHRlbXBsYXRlVXJsPzogc3RyaW5nO1xuICAgIGhpZGRlbj86IGJvb2xlYW47XG4gICAgZXJyb3I/OiBib29sZWFuO1xuICAgIGNvbXBsZXRlZD86IGJvb2xlYW47XG4gICAgdmlzaXRlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZE9wdGlvbnMge1xuICAgIG5leHRUZXh0Pzogc3RyaW5nO1xuICAgIHByZXZpb3VzVGV4dD86IHN0cmluZztcbiAgICBmaW5pc2hUZXh0Pzogc3RyaW5nO1xuICAgIHNob3dOZXh0PzogYm9vbGVhbjtcbiAgICBzaG93UHJldmlvdXM/OiBib29sZWFuO1xuICAgIHNob3dGaW5pc2g/OiBib29sZWFuO1xuICAgIG5leHRUb29sdGlwPzogc3RyaW5nO1xuICAgIHByZXZpb3VzVG9vbHRpcD86IHN0cmluZztcbiAgICBmaW5pc2hUb29sdGlwPzogc3RyaW5nO1xuICAgIHByZXZpb3VzRW5hYmxlZD86IGJvb2xlYW47XG4gICAgbmV4dEVuYWJsZWQ/OiBib29sZWFuO1xuICAgIGZpbmlzaEVuYWJsZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcnF1ZWVXaXphcmRTaWRlSW5mbyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ25lc3RlZC1kb251dCdcbn0pXG5leHBvcnQgY2xhc3MgTmVzdGVkRG9udXROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGFzZXQ6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4TmVzdGVkRG9udXROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdvcmdhbml6YXRpb24tY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBPdXRwdXQoKSBkYXRhQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gICAgQE91dHB1dCgpIG9wdGlvbnNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhPcmdhbml6YXRpb25DaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAncGFydGl0aW9uLW1hcCdcbn0pXG5leHBvcnQgY2xhc3MgUGFydGl0aW9uTWFwTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydE9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydExvYWRpbmc6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQYXJ0aXRpb25NYXBOZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2Jhci1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgUGVpdHlCYXJDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YTogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQZWl0eUJhckNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdsaW5lLWNoYXJ0J1xufSlcbmV4cG9ydCBjbGFzcyBQZWl0eUxpbmVDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YTogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQZWl0eUxpbmVDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAncGllLWNoYXJ0J1xufSlcbmV4cG9ydCBjbGFzcyBQZWl0eVBpZUNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5UGllQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3VwZGF0aW5nLWxpbmUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5VXBkYXRpbmdMaW5lQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgbWV0aG9kOiBhbnk7XG4gICAgQElucHV0KCkgdXBkYXRlaW50ZXJ2YWw6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhQZWl0eVVwZGF0aW5nTGluZUNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzYW5rZXknXG59KVxuZXhwb3J0IGNsYXNzIFNhbmtleU5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgY2hhcnRTaXplOiBhbnk7XG4gICAgQElucHV0KCkgY2hhcnREYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIGNsaWNrOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4U2Fua2V5TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzZWFyY2gtdG9vbGJhcidcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc2VhcmNoVHlwZWFoZWFkOiBhbnlbXTtcbiAgICBASW5wdXQoKSBwbGFjZUhvbGRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNsb3NlU2VhcmNoOiBzdHJpbmc7XG4gICAgQElucHV0KCkgb25TZWFyY2g6IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIG9uRm9jdXM6IEZ1bmN0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzZWFyY2hUb29sYmFyJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnc2VsZWN0LXRhYmxlJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3RUYWJsZU5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgdmFsdWVzOiBhbnlbXTtcbiAgICBASW5wdXQoKSBtdWx0aXBsZVNlbGVjdDogYm9vbGVhbjtcbiAgICBASW5wdXQoKSBzZWxlY3RLZXk6IHN0cmluZztcbiAgICBASW5wdXQoKSBzZWxlY3RlZDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlYXJjaFRleHQ6IHN0cmluZztcbiAgICBASW5wdXQoKSB0YWJsZUhlaWdodDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdEhpZGRlbkl0ZW1zOiAnY2xlYXInIHwgJ3Jlc2VsZWN0JztcblxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignc2VsZWN0VGFibGUnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFNMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNsaWRlckNoYXJ0TmcxQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzbGlkZXItY2hhcnQnLFxuICAgIHByb3ZpZGVyczogW1NMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgQElucHV0KCkgc2xpZGVyT3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIG5nTW9kZWw6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydE9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcblxuICAgIEBPdXRwdXQoKSBuZ01vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzbGlkZXJDaGFydCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKG9iajogYW55KTogdm9pZCB7IH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQgeyB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7IH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzb2NpYWwtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFNvY2lhbENoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIHdpZHRoOiBhbnk7XG4gICAgQElucHV0KCkgaGVpZ2h0OiBhbnk7XG4gICAgQElucHV0KCkgYXBpOiBhbnk7XG4gICAgQElucHV0KCkgY29tbXVuaXRpZXM6IGFueTtcbiAgICBASW5wdXQoKSBkZXRhaWxTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIHBvcG92ZXJTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVEZXRhaWw6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlRGV0YWlsOiBhbnk7XG4gICAgQElucHV0KCkgbm9kZVBvcG92ZXI6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlUG9wb3ZlcjogYW55O1xuICAgIEBJbnB1dCgpIGZvcmNlQXRsYXNEdXJhdGlvbjogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVTaXplQXR0cmlidXRlOiBhbnk7XG4gICAgQElucHV0KCkgc3RhcnRNYXhpbWl6ZWQ6IGFueTtcbiAgICBASW5wdXQoKSBzdGFydE1heGltaXNlZDogYW55O1xuICAgIEBJbnB1dCgpIHNob3dNYXhpbWl6ZUNvbnRyb2w6IGFueTtcbiAgICBASW5wdXQoKSBzaG93TWF4aW1pc2VDb250cm9sOiBhbnk7XG4gICAgQElucHV0KCkgc29jaWFsQ2hhcnRDb250YWluZXI6IGFueTtcbiAgICBASW5wdXQoKSBmdWxsc2NyZWVuQnV0dG9uUG9zaXRpb246IGFueTtcbiAgICBASW5wdXQoKSBsb2NhbFN0cmluZ3M6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydFRpdGxlOiBhbnk7XG4gICAgQElucHV0KCkgdGl0bGVEaXNwbGF5VGltZTogYW55O1xuICAgIEBJbnB1dCgpIGVkZ2VXZWlnaHRJbmZsdWVuY2U6IGFueTtcbiAgICBASW5wdXQoKSBtaW5MYWJlbHM6IGFueTtcbiAgICBcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhTb2NpYWxDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnc29ydC1kaXJlY3Rpb24tdG9nZ2xlJ1xufSlcbmV4cG9ydCBjbGFzcyBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNvcnRlcnM6IFNvcnREaXJlY3Rpb25Ub2dnbGVTb3J0ZXJbXTtcbiAgICBASW5wdXQoKSBkZXNjZW5kOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzb3J0RGlyZWN0aW9uVG9nZ2xlJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0RGlyZWN0aW9uVG9nZ2xlU29ydGVyIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc29ydDogc3RyaW5nO1xuICAgIGRlZmF1bHRTb3J0ZXI6IGJvb2xlYW47XG4gICAgc2VsZWN0OiBGdW5jdGlvbjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndHJlZWdyaWQnXG59KVxuZXhwb3J0IGNsYXNzIFRyZWVHcmlkTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBUcmVlR3JpZERhdGFbXSB8IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIGNvbHVtbnM6IFRyZWVHcmlkQ29sdW1uW107XG4gICAgQElucHV0KCkgdHJlZURhdGE6IFRyZWVHcmlkRGF0YVtdO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBhbnlbXTtcbiAgICBASW5wdXQoKSBjdXJyZW50Um93OiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogVHJlZUdyaWRPcHRpb25zO1xuXG4gICAgQE91dHB1dCgpIG9wdGlvbnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+KCk7XG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcbiAgICBAT3V0cHV0KCkgY3VycmVudFJvd0NoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgICBAT3V0cHV0KCkgdHJlZURhdGFDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZERhdGFbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPFRyZWVHcmlkRGF0YVtdPigpOyAgICBcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndHJlZWdyaWQnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyZWVHcmlkQ29sdW1uIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdmFsdWU/OiBzdHJpbmcgfCBGdW5jdGlvbjtcbiAgICB0ZW1wbGF0ZT86IHN0cmluZztcbiAgICBoZWFkZXJDbGFzcz86IHN0cmluZztcbiAgICBjZWxsQ2xhc3M/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBzdHJpbmc7XG4gICAgdG9vbHRpcD86IHN0cmluZztcbiAgICB0b29sdGlwUGxhY2VtZW50PzogJ3RvcCcgfCAnYm90dG9tJyB8ICdsZWZ0JyB8ICdyaWdodCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJlZUdyaWREYXRhIHtcbiAgICBkYXRhSXRlbTogYW55O1xuICAgIGNoaWxkcmVuOiBhbnlbXTtcbiAgICBleHBhbmRlZDogYm9vbGVhbjtcbiAgICBleHBhbmRpbmc6IGJvb2xlYW47XG4gICAgbGV2ZWw6IG51bWJlcjtcbiAgICBhcGk6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmVlR3JpZE9wdGlvbnMge1xuICAgIGNoaWxkcmVuUHJvcGVydHk/OiBzdHJpbmc7XG4gICAgaGFzQ2hpbGRyZW4/OiBGdW5jdGlvbjtcbiAgICBtYXhEZXB0aD86IG51bWJlcjtcbiAgICBleHBhbmRUb3BMZXZlbD86IGJvb2xlYW47XG4gICAgc2VsZWN0PzogYW55O1xuICAgIGV4cGFuZGVyPzogYW55O1xuICAgIGljb25zPzogYW55O1xuICAgIHJvd0NsYXNzPzogc3RyaW5nIHwgRnVuY3Rpb247XG4gICAgc29ydD86IEZ1bmN0aW9uO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3RodW1ibmFpbCdcbn0pXG5leHBvcnQgY2xhc3MgVGh1bWJuYWlsTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSB1cmw6IHN0cmluZztcbiAgICBASW5wdXQoKSBzaG93OiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHdpZHRoOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaGVpZ2h0OiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3RodW1ibmFpbCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0LCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSU5hdmlnYXRpb25NZW51U2VydmljZSB9IGZyb20gJy4vbmF2aWdhdGlvbi1tZW51LmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOYXZpZ2F0aW9uTWVudVNlcnZpY2UgaW1wbGVtZW50cyBJTmF2aWdhdGlvbk1lbnVTZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCBASW5qZWN0KCckbmF2aWdhdGlvbk1lbnUnKSBwcml2YXRlIF9uYXZpZ2F0aW9uTWVudVNlcnZpY2U6IElOYXZpZ2F0aW9uTWVudVNlcnZpY2UpIHsgfVxuXG4gICAgc2hvdygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLnNob3coKTtcbiAgICB9XG5cbiAgICBoaWRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2UuaGlkZSgpO1xuICAgIH1cblxuICAgIHZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2UudmlzaWJsZSgpO1xuICAgIH1cblxuICAgIGNvbGxhcHNlQXRXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLmNvbGxhcHNlQXRXaWR0aCgpO1xuICAgIH1cblxuICAgIHNldENvbGxhcHNlQXRXaWR0aCh3aWR0aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5zZXRDb2xsYXBzZUF0V2lkdGgod2lkdGgpO1xuICAgIH1cblxuICAgIHNldERlZmF1bHRDb2xsYXBzZUF0V2lkdGgoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5zZXREZWZhdWx0Q29sbGFwc2VBdFdpZHRoKCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0aW9uTWVudVNlcnZpY2VGYWN0b3J5KGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHJldHVybiBpbmplY3Rvci5nZXQoJyRuYXZpZ2F0aW9uTWVudScpO1xufVxuXG5leHBvcnQgY29uc3QgbmF2aWdhdGlvbk1lbnVTZXJ2aWNlUHJvdmlkZXIgPSB7XG4gICAgcHJvdmlkZTogJyRuYXZpZ2F0aW9uTWVudScsXG4gICAgdXNlRmFjdG9yeTogbmF2aWdhdGlvbk1lbnVTZXJ2aWNlRmFjdG9yeSxcbiAgICBkZXBzOiBbJyRpbmplY3RvciddXG59OyIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElQZGZTZXJ2aWNlLCBQZGZDb2x1bW5zLCBQZGZPcHRpb25zLCBQZGZEb2N1bWVudCB9IGZyb20gJy4vcGRmLmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQZGZTZXJ2aWNlIGltcGxlbWVudHMgSVBkZlNlcnZpY2Uge1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoJyRwZGYnKSBwcml2YXRlIF9wZGZTZXJ2aWNlOiBJUGRmU2VydmljZSkgeyB9XG4gICAgXG4gICAgY3JlYXRlVGFibGUoY29sdW1uczogUGRmQ29sdW1ucywgcm93czogYW55W10sIG9wdGlvbnM6IFBkZk9wdGlvbnMgPSB7fSk6IFBkZkRvY3VtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BkZlNlcnZpY2UuY3JlYXRlVGFibGUoY29sdW1ucywgcm93cywgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGRmU2VydmljZUZhY3RvcnkoaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgcmV0dXJuIGluamVjdG9yLmdldCgnJHBkZicpO1xufVxuXG5leHBvcnQgY29uc3QgcGRmU2VydmljZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6ICckcGRmJyxcbiAgICB1c2VGYWN0b3J5OiBwZGZTZXJ2aWNlRmFjdG9yeSxcbiAgICBkZXBzOiBbJyRpbmplY3RvciddXG59OyIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElUaW1lQWdvU2VydmljZSwgVGltZUFnb0xvY2FsaXplZFRpbWVzIH0gZnJvbSAnLi90aW1lLWFnby5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGltZUFnb1NlcnZpY2UgaW1wbGVtZW50cyBJVGltZUFnb1NlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdCgndGltZUFnb1NlcnZpY2UnKSBwcml2YXRlIF90aW1lQWdvU2VydmljZTogSVRpbWVBZ29TZXJ2aWNlKSB7IH1cblxuICAgIHNldFN0cmluZ3Moc3RyaW5nczogVGltZUFnb0xvY2FsaXplZFRpbWVzKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RpbWVBZ29TZXJ2aWNlLnNldFN0cmluZ3Moc3RyaW5ncyk7XG4gICAgfVxuXG4gICAgdGltZVNpbmNlKHBhc3Q6IERhdGUsIHByZXNlbnQ6IERhdGUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZUFnb1NlcnZpY2UudGltZVNpbmNlKHBhc3QsIHByZXNlbnQpO1xuICAgIH1cblxuICAgIHRpbWVTaW5jZU5vdyhtb21lbnQ6IERhdGUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZUFnb1NlcnZpY2UudGltZVNpbmNlTm93KG1vbWVudCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lQWdvU2VydmljZUZhY3RvcnkoaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgcmV0dXJuIGluamVjdG9yLmdldCgndGltZUFnb1NlcnZpY2UnKTtcbn1cblxuZXhwb3J0IGNvbnN0IHRpbWVBZ29TZXJ2aWNlUHJvdmlkZXIgPSB7XG4gICAgcHJvdmlkZTogJ3RpbWVBZ29TZXJ2aWNlJyxcbiAgICB1c2VGYWN0b3J5OiB0aW1lQWdvU2VydmljZUZhY3RvcnksXG4gICAgZGVwczogWyckaW5qZWN0b3InXVxufTsiLCJpbXBvcnQgeyBOZ01vZHVsZSwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRmxvYXRpbmdBY3Rpb25CdXR0b25OZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGbG90TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2Zsb3QvZmxvdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmVzdGVkRG9udXROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvbmVzdGVkLWRvbnV0L25lc3RlZC1kb251dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgT3JnYW5pemF0aW9uQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvb3JnYW5pemF0aW9uLWNoYXJ0L29yZ2FuaXphdGlvbi1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFydGl0aW9uTWFwTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BhcnRpdGlvbi1tYXAvcGFydGl0aW9uLW1hcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGVpdHlCYXJDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1iYXItY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFBlaXR5TGluZUNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LWxpbmUtY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFBlaXR5UGllQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktcGllLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eVVwZGF0aW5nTGluZUNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LXVwZGF0aW5nLWxpbmUtY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFNhbmtleU5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zYW5rZXktY2hhcnQvc2Fua2V5LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTb2NpYWxDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zb2NpYWwtY2hhcnQvc29jaWFsLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaW1lQWdvU2VydmljZSwgdGltZUFnb1NlcnZpY2VQcm92aWRlciB9IGZyb20gJy4vc2VydmljZXMvdGltZS1hZ28vdGltZS1hZ28uc2VydmljZSc7XG5pbXBvcnQgeyBQZGZTZXJ2aWNlLCBwZGZTZXJ2aWNlUHJvdmlkZXIgfSBmcm9tICcuL3NlcnZpY2VzL3BkZi9wZGYuc2VydmljZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uTWVudVNlcnZpY2UsIG5hdmlnYXRpb25NZW51U2VydmljZVByb3ZpZGVyIH0gZnJvbSAnLi9zZXJ2aWNlcy9uYXZpZ2F0aW9uLW1lbnUvbmF2aWdhdGlvbi1tZW51LnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9ncmlkL2dyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IFRodW1ibmFpbE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy90aHVtYm5haWwvdGh1bWJuYWlsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBIaWVyYXJjaHlCYXJOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250YWN0c05nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9jb250YWN0cy9jb250YWN0cy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRXhwYW5kSW5wdXROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZXhwYW5kLWlucHV0L2V4cGFuZC1pbnB1dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU29ydERpcmVjdGlvblRvZ2dsZU5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zb3J0LWRpcmVjdGlvbi10b2dnbGUvc29ydC1kaXJlY3Rpb24tdG9nZ2xlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hUb29sYmFyTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NlYXJjaC10b29sYmFyL3NlYXJjaC10b29sYmFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUcmVlR3JpZE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy90cmVlLWdyaWQvdHJlZS1ncmlkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWxlY3RUYWJsZU5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWxlY3QtdGFibGUvc2VsZWN0LXRhYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTbGlkZXJDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zbGlkZXItY2hhcnQvc2xpZGVyLWNoYXJ0LmRpcmVjdGl2ZSc7XG5cbmNvbnN0IGRlY2xhcmF0aW9ucyA9IFtcbiAgICBDb250YWN0c05nMUNvbXBvbmVudCxcbiAgICBFeHBhbmRJbnB1dE5nMUNvbXBvbmVudCxcbiAgICBGbG9hdGluZ0FjdGlvbkJ1dHRvbk5nMUNvbXBvbmVudCxcbiAgICBGbG90TmcxQ29tcG9uZW50LFxuICAgIEdyaWROZzFDb21wb25lbnQsXG4gICAgSGllcmFyY2h5QmFyTmcxQ29tcG9uZW50LFxuICAgIE1hcnF1ZWVXaXphcmROZzFDb21wb25lbnQsXG4gICAgTmVzdGVkRG9udXROZzFDb21wb25lbnQsXG4gICAgT3JnYW5pemF0aW9uQ2hhcnROZzFDb21wb25lbnQsXG4gICAgUGFydGl0aW9uTWFwTmcxQ29tcG9uZW50LFxuICAgIFBlaXR5QmFyQ2hhcnROZzFDb21wb25lbnQsXG4gICAgUGVpdHlMaW5lQ2hhcnROZzFDb21wb25lbnQsXG4gICAgUGVpdHlQaWVDaGFydE5nMUNvbXBvbmVudCxcbiAgICBQZWl0eVVwZGF0aW5nTGluZUNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFNhbmtleU5nMUNvbXBvbmVudCxcbiAgICBTZWFyY2hUb29sYmFyTmcxQ29tcG9uZW50LFxuICAgIFNlbGVjdFRhYmxlTmcxQ29tcG9uZW50LFxuICAgIFNsaWRlckNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFNvY2lhbENoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFNvcnREaXJlY3Rpb25Ub2dnbGVOZzFDb21wb25lbnQsXG4gICAgVHJlZUdyaWROZzFDb21wb25lbnQsXG4gICAgVGh1bWJuYWlsTmcxQ29tcG9uZW50LFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBleHBvcnRzOiBkZWNsYXJhdGlvbnMsXG4gICAgZGVjbGFyYXRpb25zOiBkZWNsYXJhdGlvbnMsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIG5hdmlnYXRpb25NZW51U2VydmljZVByb3ZpZGVyLFxuICAgICAgICBwZGZTZXJ2aWNlUHJvdmlkZXIsXG4gICAgICAgIHRpbWVBZ29TZXJ2aWNlUHJvdmlkZXIsXG4gICAgICAgIFRpbWVBZ29TZXJ2aWNlLFxuICAgICAgICBQZGZTZXJ2aWNlLFxuICAgICAgICBOYXZpZ2F0aW9uTWVudVNlcnZpY2UsXG4gICAgXSxcbn0pXG5leHBvcnQgY2xhc3MgSHlicmlkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgUGlwZSwgSW5qZWN0YWJsZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ3N0cmluZ0ZpbHRlcidcbn0pXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RyaW5nRmlsdGVyUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHRyYW5zZm9ybShpdGVtczogYW55W10sIHZhbHVlOiBzdHJpbmcpOiBhbnlbXSB7ICBcbiAgICAgICAgaWYgKCFpdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoaXQgPT4gaXQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbHVlLnRvTG93ZXJDYXNlKCkpID49IDApO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBTdHJpbmdGaWx0ZXJQaXBlIH0gZnJvbSAnLi9zdHJpbmctZmlsdGVyLnBpcGUnO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbU3RyaW5nRmlsdGVyUGlwZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbU3RyaW5nRmlsdGVyUGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgU3RyaW5nRmlsdGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL3N0b3JhZ2UtYWRhcHRlcic7XG5cbmV4cG9ydCBjbGFzcyBDb29raWVBZGFwdGVyIGltcGxlbWVudHMgU3RvcmFnZUFkYXB0ZXIge1xuXG4gICAgZ2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZyB7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmNvb2tpZSkge1xuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIHRoZSBjb29raWVzIGZvciB0aGlzIHNpdGVcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcblxuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgY29va2llcyBpbnRvIGEgZnJvbSB3ZSBjYW4gZWFzaWx5IG1hbmFnZVxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBjb29raWVzXG4gICAgICAgICAgICAgICAgLm1hcChjb29raWUgPT4gKHsga2V5OiBjb29raWUuc3BsaXQoJz0nKVswXS50cmltKCksIHZhbHVlOiBjb29raWUuc3BsaXQoJz0nKVsxXS50cmltKCkgfSkpXG4gICAgICAgICAgICAgICAgLmZpbmQoY29va2llID0+IGNvb2tpZS5rZXkgPT09IGtleSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoLnZhbHVlIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7a2V5fT0ke3ZhbHVlfTsgcGF0aD0vYDtcbiAgICB9XG5cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXFQb3MgPSBjb29raWUuaW5kZXhPZignPScpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGVxUG9zID4gLTEgPyBjb29raWUuc3Vic3RyKDAsIGVxUG9zKS50cmltKCkgOiBjb29raWU7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUudHJpbSgpLnJlcGxhY2UoLz0uKi8sIGA9O2V4cGlyZXM9JHtuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKCl9O3BhdGg9L2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGVhcigpOiB2b2lkIHtcblxuICAgICAgICAvLyBjYWxsIHJlbW92ZSBpdGVtIG9uIGVhY2ggY29va2llXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpLm1hcChjb29raWUgPT4gY29va2llLnNwbGl0KCc9JylbMF0udHJpbSgpKVxuICAgICAgICAgICAgLmZvckVhY2goY29va2llID0+IHRoaXMucmVtb3ZlSXRlbShjb29raWUpKTtcbiAgICB9XG5cbiAgICBnZXRTdXBwb3J0ZWQoKTogU3RvcmFnZUFkYXB0ZXIge1xuICAgICAgICAvLyBjb29raWVzIGFyZSBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufSIsImltcG9ydCB7IFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9zdG9yYWdlLWFkYXB0ZXInO1xuaW1wb3J0IHsgQ29va2llQWRhcHRlciB9IGZyb20gJy4vY29va2llLWFkYXB0ZXInO1xuXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlQWRhcHRlciBpbXBsZW1lbnRzIFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgICAgICAvLyBpZiBsb2NhbCBzdG9yYWdlIHZhcmlhYmxlIGRvZXMgbm90IGV4aXN0IGZhbGwgYmFjayB0byBjb29raWVzXG4gICAgICAgIGlmICghbG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvb2tpZUFkYXB0ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBtYWtlIGEgdGVzdCBzYXZlIHRvIGxvY2FsIHN0b3JhZ2UgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgZXhjZXB0aW9uc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJywgJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJyk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IENvb2tpZUFkYXB0ZXIgfSBmcm9tICcuL2Nvb2tpZS1hZGFwdGVyJztcblxuZXhwb3J0IGNsYXNzIFNlc3Npb25TdG9yYWdlQWRhcHRlciBpbXBsZW1lbnRzIFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH1cblxuICAgIHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBnZXRTdXBwb3J0ZWQoKTogU3RvcmFnZUFkYXB0ZXIge1xuXG4gICAgICAgIC8vIGlmIGxvY2FsIHN0b3JhZ2UgdmFyaWFibGUgZG9lcyBub3QgZXhpc3QgZmFsbCBiYWNrIHRvIGNvb2tpZXNcbiAgICAgICAgaWYgKCFzZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gbWFrZSBhIHRlc3Qgc2F2ZSB0byBsb2NhbCBzdG9yYWdlIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IGV4Y2VwdGlvbnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJywgJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJyk7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvb2tpZUFkYXB0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9zdG9yYWdlLWFkYXB0ZXInO1xuaW1wb3J0IHsgQ29va2llQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvY29va2llLWFkYXB0ZXInO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvbG9jYWwtc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IFNlc3Npb25TdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvc2Vzc2lvbi1zdG9yYWdlLWFkYXB0ZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGVyc2lzdGVudERhdGFTZXJ2aWNlIHtcblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGl0ZW0gaW4gc29tZSBmb3JtIG9mIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqL1xuICAgIHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIHR5cGU6IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUgPSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkxvY2FsU3RvcmFnZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmdldEFkYXB0ZXIodHlwZSkuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdG9yZWQgdmFsdWUgZnJvbSBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgKi9cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nLCB0eXBlOiBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlID0gUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Mb2NhbFN0b3JhZ2UpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBZGFwdGVyKHR5cGUpLmdldEl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzdG9yZWQgdmFsdWUgZnJvbSBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgKi9cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nLCB0eXBlOiBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlID0gUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Mb2NhbFN0b3JhZ2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nZXRBZGFwdGVyKHR5cGUpLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzdG9yZWQgdmFsdWUgZnJvbSBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjbGVhcih0eXBlOiBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlID0gUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Mb2NhbFN0b3JhZ2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nZXRBZGFwdGVyKHR5cGUpLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBhZGFwdGVyIGJhc2VkIG9uIHRoZSB0eXBlIHJlcXVlc3RlZFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0QWRhcHRlcih0eXBlOiBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlKTogU3RvcmFnZUFkYXB0ZXIge1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlIFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuQ29va2llOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuXG4gICAgICAgICAgICBjYXNlIFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RvcmFnZUFkYXB0ZXIgPSBuZXcgTG9jYWxTdG9yYWdlQWRhcHRlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VBZGFwdGVyLmdldFN1cHBvcnRlZCgpO1xuXG4gICAgICAgICAgICBjYXNlIFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuU2Vzc2lvblN0b3JhZ2U6XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblN0b3JhZ2VBZGFwdGVyID0gbmV3IFNlc3Npb25TdG9yYWdlQWRhcHRlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZUFkYXB0ZXIuZ2V0U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUge1xuICAgIExvY2FsU3RvcmFnZSxcbiAgICBDb29raWUsXG4gICAgU2Vzc2lvblN0b3JhZ2Vcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQZXJzaXN0ZW50RGF0YVNlcnZpY2UgfSBmcm9tICcuL3BlcnNpc3RlbnQtZGF0YS5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgICBwcm92aWRlcnM6IFtQZXJzaXN0ZW50RGF0YVNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBQZXJzaXN0ZW50RGF0YU1vZHVsZSB7IH1cbiIsImV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTdG9yYWdlQWRhcHRlciB7XG4gICAgYWJzdHJhY3QgZ2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZztcbiAgICBhYnN0cmFjdCBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZDtcbiAgICBhYnN0cmFjdCByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZDtcbiAgICBhYnN0cmFjdCBjbGVhcigpOiB2b2lkO1xuICAgIGFic3RyYWN0IGdldFN1cHBvcnRlZCgpOiBTdG9yYWdlQWRhcHRlcjtcbn0iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiSW5wdXQiLCJOZ01vZHVsZSIsIkNvbW1vbk1vZHVsZSIsIlJvdXRlck1vZHVsZSIsIlN1YnNjcmlwdGlvbiIsIkJlaGF2aW9yU3ViamVjdCIsImZyb21FdmVudCIsIkluamVjdGFibGUiLCJSZW5kZXJlckZhY3RvcnkyIiwiTmdab25lIiwiRXZlbnRFbWl0dGVyIiwiZGVib3VuY2VUaW1lIiwiRGlyZWN0aXZlIiwiRWxlbWVudFJlZiIsIk91dHB1dCIsImZpbHRlciIsIm1hcCIsIkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IiwiQ29udGVudENoaWxkIiwiVGVtcGxhdGVSZWYiLCJIb3N0QmluZGluZyIsIlZpZXdDaGlsZCIsIk5HX1ZBTFVFX0FDQ0VTU09SIiwiZm9yd2FyZFJlZiIsIkZvcm1zTW9kdWxlIiwiU3ViamVjdCIsIkNvbnRlbnRDaGlsZHJlbiIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwidGFrZVVudGlsIiwiT3B0aW9uYWwiLCJ0c2xpYl8xLl9fZXh0ZW5kcyIsInRzbGliXzEuX19hc3NpZ24iLCJkZWxheSIsIlJlbmRlcmVyMiIsIlZpZXdFbmNhcHN1bGF0aW9uIiwiUGlwZSIsImNvbWJpbmVMYXRlc3QiLCJtb250aHMiLCJIb3N0IiwiT2JzZXJ2YWJsZSIsImZyb20iLCJvZiIsImRyb3Bkb3duIiwiQ2hhbmdlRGV0ZWN0b3JSZWYiLCJ0b29sdGlwIiwiQ29tcG9uZW50UG9ydGFsIiwiVmlld0NvbnRhaW5lclJlZiIsIk92ZXJsYXkiLCJTY3JvbGxEaXNwYXRjaGVyIiwiT3ZlcmxheU1vZHVsZSIsIk9ic2VydmVyc01vZHVsZSIsIigoZHJhZ3VsYU5hbWVzcGFjZSkpLmRlZmF1bHQiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiREVDTEFSQVRJT05TIiwiVHlwZWFoZWFkTW9kdWxlIiwiQnNEcm9wZG93bkRpcmVjdGl2ZSIsIkJzRHJvcGRvd25Nb2R1bGUiLCJIb3N0TGlzdGVuZXIiLCJ0cmlnZ2VyIiwidHJhbnNpdGlvbiIsInF1ZXJ5Iiwic3R5bGUiLCJzdGFnZ2VyIiwiYW5pbWF0ZSIsIlRvb2x0aXBEaXJlY3RpdmUiLCJBdHRyaWJ1dGUiLCJmaXJzdCIsIlZpZXdDaGlsZHJlbiIsIkVTQ0FQRSIsIlF1ZXJ5TGlzdCIsIlJlc3BvbnNlQ29udGVudFR5cGUiLCJIdHRwIiwiSHR0cE1vZHVsZSIsImNvbmNhdCIsInN3aXRjaE1hcCIsInRpbWVyIiwiTmF2aWdhdGlvbkVuZCIsIlNraXBTZWxmIiwiUm91dGVyIiwiQWN0aXZhdGVkUm91dGUiLCJzdGF0ZSIsIkluamVjdCIsIkRPQ1VNRU5UIiwiQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIiwidHlwZWFoZWFkIiwiZmlsdGVyT3BlcmF0b3IiLCJhdWRpdFRpbWUiLCJ1bmlxdWVJZCIsIk5HX1ZBTElEQVRPUlMiLCJFWFBPUlRTIiwiTmdNb2RlbCIsIkluamVjdG9yIiwiVXBncmFkZUNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O1FBNkJJLHlDQUFVO1lBQVYsVUFBVyxLQUFpQixFQUFFLEtBQWlCO2dCQUMzQyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUU7b0JBQ2YsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUNuQzthQUNKOztvQkEvQkpBLGNBQVMsU0FBQzt3QkFDUCxRQUFRLEVBQUUsZ0JBQWdCO3dCQUMxQixRQUFRLEVBQUUsMHRCQWtCUDtxQkFDTjs7Ozs7K0JBSUlDLFVBQUs7O21DQTNCVjs7Ozs7OztBQ0FBOzs7O29CQU1DQyxhQUFRLFNBQUM7d0JBQ04sT0FBTyxFQUFFOzRCQUNMQyxtQkFBWTs0QkFDWkMsbUJBQVk7eUJBQ2Y7d0JBQ0QsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUM7d0JBQy9CLFlBQVksRUFBRSxDQUFDLG9CQUFvQixDQUFDO3FCQUN2Qzs7OztnQ0FiRDs7Ozs7Ozs7Ozs7O0FDQUE7UUFZSSx1QkFBWSxlQUFpQyxFQUFVLE9BQWU7WUFBZixZQUFPLEdBQVAsT0FBTyxDQUFRO2lDQUY5QyxJQUFJQyx5QkFBWSxFQUFFO1lBR3RDLElBQUksQ0FBQyxTQUFTLEdBQUcsZUFBZSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDL0Q7Ozs7UUFFRCxtQ0FBVztZQUFYO2dCQUNJLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDcEM7Ozs7O1FBRUQseUNBQWlCO1lBQWpCLFVBQWtCLGFBQTBCO2dCQUE1QyxpQkE0REM7O2dCQXpERyxxQkFBTSxPQUFPLEdBQUcsSUFBSUMsK0JBQWUsQ0FBbUIsRUFBRSxLQUFLLEVBQUUs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RSxHQUFHLEVBQUU7Z0JBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO2dCQUM5QixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRTtnQkFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7Z0JBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO2dCQUM5QixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRTtnQkFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7Z0JBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO2dCQUM5QixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRTtnQkFDN0IsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUU7Z0JBQzFCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQy9CLEVBQUUsSUFBSSxFQUFF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aERSTSxlQUFVOzs7O29DQU5YOzs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7b0JBSUNOLGFBQVEsU0FBQzt3QkFDTixTQUFTLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQztxQkFDckM7Ozs7bUNBTkQ7Ozs7Ozs7Ozs7QUNBQTs7UUFBQTs7OzZCQUFBO1FBTUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==