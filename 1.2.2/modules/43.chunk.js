webpackJsonp([43],{1559:function(t,e,n){"use strict";!function(t){for(var n in t)e.hasOwnProperty(n)||(e[n]=t[n])}(n(1560))},1560:function(t,e,n){"use strict";function o(t,e){return"rgba("+t.concat(e).join(",")+")"}function r(t,e){return Math.floor(Math.random()*(e-t+1))+t}function a(t){return{backgroundColor:o(t,.4),borderColor:o(t,1),pointBackgroundColor:o(t,1),pointBorderColor:"#fff",pointHoverBackgroundColor:"#fff",pointHoverBorderColor:o(t,.8)}}function i(t){return{backgroundColor:o(t,.6),borderColor:o(t,1),hoverBackgroundColor:o(t,.8),hoverBorderColor:o(t,1)}}function s(t){return{backgroundColor:t.map(function(t){return o(t,.6)}),borderColor:t.map(function(){return"#fff"}),pointBackgroundColor:t.map(function(t){return o(t,1)}),pointBorderColor:t.map(function(){return"#fff"}),pointHoverBackgroundColor:t.map(function(t){return o(t,1)}),pointHoverBorderColor:t.map(function(t){return o(t,1)})}}function l(t){return{backgroundColor:t.map(function(t){return o(t,.6)}),borderColor:t.map(function(t){return o(t,1)}),hoverBackgroundColor:t.map(function(t){return o(t,.8)}),hoverBorderColor:t.map(function(t){return o(t,1)})}}function d(){return[r(0,255),r(0,255),r(0,255)]}function h(t){return v.defaultColors[t]||d()}function c(t){for(var e=new Array(t),n=0;n<t;n++)e[n]=v.defaultColors[n]||d();return e}function p(t,e,n){return"pie"===t||"doughnut"===t?s(c(n)):"polarArea"===t?l(c(n)):"line"===t||"radar"===t?a(h(e)):"bar"===t||"horizontalBar"===t?i(h(e)):h(e)}var u=this&&this.__decorate||function(t,e,n,o){var r,a=arguments.length,i=a<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var s=t.length-1;s>=0;s--)(r=t[s])&&(i=(a<3?r(i):a>3?r(e,n,i):r(e,n))||i);return a>3&&i&&Object.defineProperty(e,n,i),i},f=this&&this.__metadata||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)},g=n(0),C=n(1562),v=function(){function t(t){this.labels=[],this.options={},this.chartClick=new g.EventEmitter,this.chartHover=new g.EventEmitter,this.initFlag=!1,this.element=t}return t.prototype.ngOnInit=function(){this.ctx=this.element.nativeElement.getContext("2d"),this.cvs=this.element.nativeElement,this.initFlag=!0,(this.data||this.datasets)&&this.refresh()},t.prototype.ngOnChanges=function(t){this.initFlag&&(t.hasOwnProperty("data")||t.hasOwnProperty("datasets")?(t.data?this.updateChartData(t.data.currentValue):this.updateChartData(t.datasets.currentValue),this.chart.update()):this.refresh())},t.prototype.ngOnDestroy=function(){this.chart&&(this.chart.destroy(),this.chart=void 0)},t.prototype.getChartBuilder=function(t){var e=this,n=this.getDatasets(),o=Object.assign({},this.options);!1===this.legend&&(o.legend={display:!1}),o.hover=o.hover||{},o.hover.onHover||(o.hover.onHover=function(t){t&&!t.length||e.chartHover.emit({active:t})}),o.onClick||(o.onClick=function(t,n){e.chartClick.emit({event:t,active:n})});var r={type:this.chartType,data:{labels:this.labels,datasets:n},options:o};return new C.Chart(t,r)},t.prototype.updateChartData=function(t){Array.isArray(t[0].data)?this.chart.data.datasets.forEach(function(e,n){e.data=t[n].data,t[n].label&&(e.label=t[n].label)}):this.chart.data.datasets[0].data=t},t.prototype.getDatasets=function(){var t=this,e=void 0;if((!this.datasets||!this.datasets.length&&this.data&&this.data.length)&&(e=Array.isArray(this.data[0])?this.data.map(function(e,n){return{data:e,label:t.labels[n]||"Label "+n}}):[{data:this.data,label:"Label 0"}]),(this.datasets&&this.datasets.length||e&&e.length)&&(e=(this.datasets||e).map(function(e,n){var o=Object.assign({},e);return t.colors&&t.colors.length?Object.assign(o,t.colors[n]):Object.assign(o,p(t.chartType,n,o.data.length)),o})),!e)throw new Error("ng-charts configuration error,\n      data or datasets field are required to render char "+this.chartType);return e},t.prototype.refresh=function(){this.ngOnDestroy(),this.chart=this.getChartBuilder(this.ctx)},t}();v.defaultColors=[[255,99,132],[54,162,235],[255,206,86],[231,233,237],[75,192,192],[151,187,205],[220,220,220],[247,70,74],[70,191,189],[253,180,92],[148,159,177],[77,83,96]],u([g.Input(),f("design:type",Array)],v.prototype,"data",void 0),u([g.Input(),f("design:type",Array)],v.prototype,"datasets",void 0),u([g.Input(),f("design:type",Array)],v.prototype,"labels",void 0),u([g.Input(),f("design:type",Object)],v.prototype,"options",void 0),u([g.Input(),f("design:type",String)],v.prototype,"chartType",void 0),u([g.Input(),f("design:type",Array)],v.prototype,"colors",void 0),u([g.Input(),f("design:type",Boolean)],v.prototype,"legend",void 0),u([g.Output(),f("design:type",g.EventEmitter)],v.prototype,"chartClick",void 0),u([g.Output(),f("design:type",g.EventEmitter)],v.prototype,"chartHover",void 0),v=u([g.Directive({selector:"canvas[baseChart]",exportAs:"base-chart"}),f("design:paramtypes",[g.ElementRef])],v),e.BaseChartDirective=v;var b=function(){function t(){}return t}();b=u([g.NgModule({declarations:[v],exports:[v],imports:[]})],b),e.ChartsModule=b},1674:function(t,e){t.exports=".demo-chart-container {\n    display: block;\n    position: relative;\n    height: 200px;\n}"},1675:function(t,e){t.exports='<div class="demo-chart-container">\n\n    <canvas baseChart \n            [datasets]="lineChartData"\n            [options]="lineChartOptions"\n            [legend]="lineChartLegend"\n            [colors]="lineChartColors"\n            chartType="line">\n    </canvas>\n\n</div>'},1676:function(t,e){t.exports="import { Component, ViewChild } from '@angular/core';\nimport { ColorService } from 'ux-aspects';\nimport { BaseChartDirective } from 'ng2-charts';\n\n@Component({\n    selector: 'app',\n    templateUrl: './src/app.component.html',\n    styleUrls: ['./src/app.component.css']\n})\nexport class AppComponent {\n\n    // access the chart directive properties\n    @ViewChild(BaseChartDirective) baseChart: BaseChartDirective;\n\n    // configure the directive data\n    lineChartData: Chart.ChartDataSets[];\n    lineChartOptions: Chart.ChartOptions;\n    lineChartLegend: boolean = false;\n    lineChartColors: any;\n\n    private livedata: number[] = [];\n\n    constructor(colorService: ColorService) {\n\n        let gridColor = colorService.getColor('grey6').toHex();\n        let lineBorderColor = colorService.getColor('chart1').toRgb();\n        let lineFillColor = colorService.getColor('chart1').setAlpha(0.1).toRgba();\n        let lineForecastFillColor = colorService.getColor('chart1').setAlpha(0.06).toRgba();\n        let pointBorderColor = colorService.getColor('chart1').setAlpha(0.5).toRgba();\n\n        // set the initial chart data\n        this.updateChartData();\n\n        this.lineChartOptions = {\n            maintainAspectRatio: false,\n            responsive: true,\n            animation: false,\n            elements: {\n                line: {\n                    tension: 0\n                }\n            },\n            scales: {\n                xAxes: [{\n                    type: 'linear',\n                    position: 'bottom',\n                    ticks: {\n                        min: 0,\n                        max: 299,\n                        step: 50,\n                        fontSize: 0 /* Hide Labels on X Axis */\n                    } as Chart.LinearTickOptions,\n                    gridLines: {\n                        color: gridColor\n                    }\n                }],\n                yAxes: [{\n                    ticks: {\n                        min: 0,\n                        max: 100,\n                        stepSize: 25\n                    } as Chart.LinearTickOptions,\n                    gridLines: {\n                        color: gridColor\n                    }\n                }]\n            },\n            tooltips: {\n                enabled: false\n            }\n        };\n\n        this.lineChartColors = [\n            {\n                borderColor: lineBorderColor,\n                backgroundColor: lineFillColor,\n                pointBackgroundColor: 'transparent',\n                pointBorderColor: 'transparent'\n            }\n        ];\n\n        setInterval(() => {\n            // update chart data every 40ms\n            this.updateChartData();\n        }, 40);\n    }\n\n    updateChartData() {\n\n        // instatiate new array to trigger change detection\n        this.lineChartData = new Array<Chart.ChartDataSets>();\n\n        this.lineChartData.push({\n            data: this.getRandomData(),\n            borderWidth: 1\n        });\n    }\n\n    getRandomData(): { x: number, y: number}[] {\n\n        if (this.livedata.length) {\n            this.livedata = this.livedata.slice(1);\n        }\n\n        while (this.livedata.length < 300) {\n            let previous = this.livedata.length ? this.livedata[this.livedata.length - 1] : 50;\n            let y = previous + Math.random() * 10 - 5;\n\n            this.livedata.push(y < 0 ? 0 : y > 100 ? 100 : y);\n        }\n\n        // zip the generated y values with the x values\n        let res = [];\n        for (let i = 0; i < this.livedata.length; ++i) {\n            res.push({\n                x: i,\n                y: this.livedata[i]\n            });\n        }\n\n        return res;\n    }\n\n}"},1828:function(t,e,n){"use strict";var o=this&&this.__decorate||function(t,e,n,o){var r,a=arguments.length,i=a<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var s=t.length-1;s>=0;s--)(r=t[s])&&(i=(a<3?r(i):a>3?r(e,n,i):r(e,n))||i);return a>3&&i&&Object.defineProperty(e,n,i),i},r=this&&this.__metadata||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};Object.defineProperty(e,"__esModule",{value:!0});var a=n(0),i=n(299),s=n(159),l=function(){function t(t){var e=this;this.livedata=[],this.htmlCode=n(2527),this.jsCode=n(2528),this.codepen={html:this.htmlCode,htmlAttributes:{"ng-controller":"LiveChartCtrl as lc"},js:[this.jsCode]};var o={primary:t.getColor("chart1").toRgb(),gridColor:t.getColor("grey4").toHex(),tickColor:t.getColor("grey6").toHex(),borderColor:t.getColor("grey2").setAlpha(.5).toRgba(),white:"#FFFFFF"};this.series=[{data:this.getRandomData(),lines:{fill:!0,lineWidth:1,fillColor:{colors:[{opacity:.1},{opacity:.1}]}},shadowSize:0}],this.options={grid:{color:[o.gridColor],tickColor:[o.tickColor],borderWidth:{top:0,bottom:1,left:1,right:0},borderColor:{bottom:[o.borderColor],left:[o.borderColor]},minBorderMargin:20,labelMargin:10,backgroundColor:{colors:[[o.white],[o.white]]},margin:{top:8,bottom:20,left:20},markings:function(t){for(var e=[],n=t.xaxis,r=Math.floor(n.min);r<n.max;r+=2*n.tickSize)e.push({xaxis:{from:r,to:r+n.tickSize},color:[o.white]});return e}},colors:[o.primary],xaxis:{tickFormatter:function(){return""}},yaxis:{min:0,max:110},legend:{show:!0}},setInterval(function(){e.series[0].data=e.getRandomData()},40)}return t.prototype.getRandomData=function(){for(this.livedata.length&&(this.livedata=this.livedata.slice(1));this.livedata.length<300;){var t=this.livedata.length?this.livedata[this.livedata.length-1]:50,e=t+10*Math.random()-5;this.livedata.push(e<0?0:e>100?100:e)}for(var n=[],o=0;o<this.livedata.length;++o)n.push([o,this.livedata[o]]);return n},t}();l=o([a.Component({selector:"uxd-charts-live-chart-ng1",template:n(2203),changeDetection:a.ChangeDetectionStrategy.OnPush}),i.DocumentationSectionComponent("ChartsLiveChartNg1Component"),r("design:paramtypes",[s.ColorService])],l),e.ChartsLiveChartNg1Component=l},1829:function(t,e,n){"use strict";var o=this&&this.__decorate||function(t,e,n,o){var r,a=arguments.length,i=a<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var s=t.length-1;s>=0;s--)(r=t[s])&&(i=(a<3?r(i):a>3?r(e,n,i):r(e,n))||i);return a>3&&i&&Object.defineProperty(e,n,i),i},r=this&&this.__metadata||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};Object.defineProperty(e,"__esModule",{value:!0});var a=n(0),i=n(299),s=n(159),l=n(1559),d=function(){function t(t){var e=this;this.plunk={files:{"app.component.ts":n(1676),"app.component.html":n(1675),"app.component.css":n(1674)},modules:[{library:"chart.js"},{imports:["ChartsModule"],library:"ng2-charts"},{imports:["ColorServiceModule"],library:"ux-aspects"}],mappings:[{alias:"chart.js",source:"https://unpkg.com/chart.js@2.5.0/dist/Chart.min.js"},{alias:"ng2-charts",source:"https://unpkg.com/ng2-charts@1.5.0/bundles/ng2-charts.umd.min.js"}]},this.lineChartLegend=!1,this.livedata=[],this.htmlCode=n(1675),this.tsCode=n(1676),this.cssCode=n(1674);var o=t.getColor("grey6").toHex(),r=t.getColor("chart1").toRgb(),a=t.getColor("chart1").setAlpha(.1).toRgba();t.getColor("chart1").setAlpha(.06).toRgba(),t.getColor("chart1").setAlpha(.5).toRgba();this.updateChartData(),this.lineChartOptions={maintainAspectRatio:!1,responsive:!0,animation:!1,elements:{line:{tension:0}},scales:{xAxes:[{type:"linear",position:"bottom",ticks:{min:0,max:299,step:50,fontSize:0},gridLines:{color:o}}],yAxes:[{ticks:{min:0,max:100,stepSize:25},gridLines:{color:o}}]},tooltips:{enabled:!1}},this.lineChartColors=[{borderColor:r,backgroundColor:a,pointBackgroundColor:"transparent",pointBorderColor:"transparent"}],setInterval(function(){e.updateChartData()},40)}return t.prototype.updateChartData=function(){this.lineChartData=new Array,this.lineChartData.push({data:this.getRandomData(),borderWidth:1})},t.prototype.getRandomData=function(){for(this.livedata.length&&(this.livedata=this.livedata.slice(1));this.livedata.length<300;){var t=this.livedata.length?this.livedata[this.livedata.length-1]:50,e=t+10*Math.random()-5;this.livedata.push(e<0?0:e>100?100:e)}for(var n=[],o=0;o<this.livedata.length;++o)n.push({x:o,y:this.livedata[o]});return n},t}();o([a.ViewChild(l.BaseChartDirective),r("design:type",l.BaseChartDirective)],d.prototype,"baseChart",void 0),d=o([a.Component({selector:"uxd-charts-live-chart",template:n(2204)}),i.DocumentationSectionComponent("ChartsLiveChartComponent"),r("design:paramtypes",[s.ColorService])],d),e.ChartsLiveChartComponent=d},1830:function(t,e,n){"use strict";var o=this&&this.__decorate||function(t,e,n,o){var r,a=arguments.length,i=a<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var s=t.length-1;s>=0;s--)(r=t[s])&&(i=(a<3?r(i):a>3?r(e,n,i):r(e,n))||i);return a>3&&i&&Object.defineProperty(e,n,i),i},r=this&&this.__metadata||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};Object.defineProperty(e,"__esModule",{value:!0});var a=n(0),i=n(20),s=n(1828),l=n(301),d=n(300),h=n(303),c=n(158),p=n(302),u=n(1829),f=n(1559),g=[s.ChartsLiveChartNg1Component,u.ChartsLiveChartComponent],C=[{path:"**",component:l.DocumentationCategoryComponent,data:{category:c.ResolverService.resolveCategoryData(c.DocumentationPage.Charts,"Live Chart")}}],v=function(){function t(t,e){e.registerResolver(t)}return t}();v=o([a.NgModule({imports:[p.TabsModule,h.WrappersModule,f.ChartsModule,d.DocumentationComponentsModule,i.RouterModule.forChild(C)],exports:g,declarations:g,entryComponents:g}),r("design:paramtypes",[a.ComponentFactoryResolver,c.ResolverService])],v),e.ChartsLiveChartsModule=v},2203:function(t,e){t.exports='<div class="flot-chart">\n    <ux-flot-ng1 [dataset]="series" [options]="options"></ux-flot-ng1>\n</div>\n\n<hr>\n\n<div class="demo-attributes table-responsive">\n<table class="table">\n    <tbody><tr>\n        <th>Property</th>\n        <th>Type</th>\n        <th>Description</th>\n        <th>Optional</th>\n    </tr>\n    <tr>\n        <td class="attribute">data</td>\n        <td>number or array</td>\n        <td>Coordinates in the Live chart.</td>\n        <td>false</td>\n    </tr>\n    <tr>\n        <td class="attribute">series</td>\n        <td>string</td>\n        <td>Defines the chart type and its layout. Values include \'lines\', \'bar\' and \'points\'.</td>\n        <td>false</td>\n    </tr>\n</tbody></table>\n</div>\n\n<p>The following attributes should be defined within <code>series</code></p>\n\n\n<div class="demo-attributes table-responsive">\n<table class="table">\n    <tbody><tr>\n        <th>Property</th>\n        <th>Type</th>\n        <th>Description</th>\n        <th>Optional</th>\n    </tr>\n    <tr>\n        <td class="attribute">lineWidth</td>\n        <td>number</td>\n        <td>Defines the thickness of the line chart.</td>\n        <td>true</td>\n    </tr>\n    <tr>\n        <td class="attribute">show</td>\n        <td>boolean</td>\n        <td>If set to true displays the chart.</td>\n        <td>false</td>\n    </tr>\n    <tr>\n        <td class="attribute">fillColor</td>\n        <td>array</td>\n        <td>Specifies the colors of the fill. For Line chart this produces area graphs. If more than one color is specified this will produce a gradient.</td>\n        <td>true</td>\n    </tr>\n    <tr>\n        <td class="attribute">fill</td>\n        <td>boolean or number</td>\n        <td>If set to true fills the chart with colors in the fillColors property. A number between 0 and 1 defines the opacity of the fill.</td>\n        <td>true</td>\n    </tr>\n    <tr>\n        <td class="attribute">shadowSize</td>\n        <td>number</td>\n        <td>Default size of shadows in pixels. Set it to 0 to remove shadows.</td>\n        <td>true</td>\n    </tr>\n</tbody></table>\n</div>\n\n<p>Live Charts are defined by the <code>flot</code> directive. The dataset and options attribute define the live chart data and options respectively.\nDataset and Options are defined within the LiveChartCtrl.</p>\n\n<tabset>\n    <tab heading="HTML">\n        <uxd-snippet language="html" [code]="htmlCode"></uxd-snippet>\n    </tab>\n    \n    <tab heading="Javascript">\n        <uxd-snippet language="javascript" [code]="jsCode"></uxd-snippet>\n    </tab>\n</tabset>\n\n<div class="demo-attributes table-responsive">\n<table class="table">\n  <tbody><tr>\n    <th>Property</th>\n    <th>Type</th>\n    <th>Description</th>\n    <th>Optional</th>\n  </tr>\n  <tr>\n    <td class="attribute">markings</td>\n    <td>array</td>\n    <td>Markings used to draw simple lines and rectangular areas in the background of the plot. It can be an array of ranges in the form of &#123; xaxis: &#123; from, to &#125;, yaxis: &#123; from, to &#125; &#125; or a function(above example) that returns this range.</td>\n    <td>true</td>\n  </tr>\n</tbody></table>\n</div>\n\n<blockquote>\n  <p><strong>Note</strong>: Refer to the <a routerLink="/charts/flot-options">Flot Options</a> page for details of chart options.</p>\n</blockquote>\n\n<p>To support users of assistive technologies, provide a text summary of the chart with an <code>aria-label</code> or <code>span</code> hidden with the <code>sr-only</code> class. For live charts the most appropriate information to convey will vary depending on the chartâ€™s purpose, but may typically be the highest or most recent data point.</p>\n\n<blockquote>\n    <p><strong>Note</strong>: To upgrade this component to use in an Angular 4 application use: <code>upgradeAdapter.upgradeNg1Component(\'uxFlotNg1\')</code></p>\n</blockquote>'},2204:function(t,e){t.exports='<div class="demo-chart-container">\n\n    <canvas baseChart \n            [datasets]="lineChartData"\n            [options]="lineChartOptions"\n            [legend]="lineChartLegend"\n            [colors]="lineChartColors"\n            chartType="line">\n    </canvas>\n\n</div>\n\n<hr>\n\n<p>\n    Live Charts can be added using the <code>ng2-charts</code> library. \n    The <code>chart.js</code> library needs to be imported and the <code>ChartsModule</code> needs to be added to the appropriate NgModule.\n</p>\n\n<br>\n\n<p>The <code>baseChart</code> directive should be added to a <code>canvas</code> element and the following attributes can be used to customize the chart behavior and appearance:</p>\n\n\n<table class="table">\n\n    <thead>\n        <tr>\n            <th>Name</th>\n            <th>Type</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n\n    <tbody>\n\n        <tr>\n            <td><b>@Input</b> datasets</td>\n            <td><b>object[]</b></td>\n            <td>Contains the data and properties for each data set to be displayed in the chart.</td>\n        </tr>\n\n        <tr>\n            <td><b>@Input</b> chartType</td>\n            <td><b>string</b></td>\n            <td>Indicates the type of the chart. Possible options are: <code>line</code>, <code>bar</code>, <code>radar</code>, <code>pie</code>, <code>polarArea</code>, <code>doughnut</code></td>\n        </tr>\n\n        <tr>\n            <td><b>@Input</b> options</td>\n            <td><b>ChartOptions</b></td>\n            <td>Configures the appearance and behavior of all aspects of the chart.</td>\n        </tr>\n\n        <tr>\n            <td><b>@Input</b> colors</td>\n            <td><b>object[]</b></td>\n            <td>Configure the color values to be used within the chart.</td>\n        </tr>\n\n        <tr>\n            <td><b>@Input</b> legend</td>\n            <td><b>boolean</b></td>\n            <td>Determines whether or not the legend should be displayed.</td>\n        </tr>\n\n        <tr>\n            <td><b>@Output</b> chartClick</td>\n            <td></td>\n            <td>Fires when click on a chart has occurred, returns information regarding active points and labels</td>\n        </tr>\n\n        <tr>\n            <td><b>@Output</b> chartHover</td>\n            <td></td>\n            <td>Fires when mousemove (hover) on a chart has occurred, returns information regarding active points and labels.</td>\n        </tr>\n\n    </tbody>\n</table>\n\n<p>Complete documentation on the directive and chart options can be found at the documentation links below.</p>\n\n<p>The following code can be used to create the example above: </p>\n\n<tabset>\n\n    <tab heading="HTML">\n        <uxd-snippet language="html" [code]="htmlCode"></uxd-snippet>\n    </tab>\n    \n    <tab heading="TypeScript">\n        <uxd-snippet language="javascript" [code]="tsCode"></uxd-snippet>\n    </tab>\n    \n    <tab heading="CSS">\n        <uxd-snippet language="css" [code]="cssCode"></uxd-snippet>\n    </tab>\n\n</tabset>\n\n<br>\n\n<blockquote>\n\n    <p class="m-b-nil">\n        <b>Dependencies: </b>\n        <a class="hyperlink" href="https://www.npmjs.com/package/ng2-charts">ng2-charts</a>, \n        <a class="hyperlink" href="https://www.npmjs.com/package/chart.js">chart.js</a>\n    </p>\n\n    <p class="m-b-nil">\n        <b>Type Definitions: </b>\n        <a class="hyperlink" href="https://www.npmjs.com/package/@types/chart.js">@types/chart.js</a>\n    </p>\n\n    <p class="m-b-nil">\n        <b>Modules: </b>\n        <span>ChartsModule</span>\n    </p>\n\n\n    <p class="m-b-nil">\n        <b>Documentation: </b>\n        <a class="hyperlink" href="http://valor-software.com/ng2-charts/">Angular Directive Documentation</a>, \n        <a class="hyperlink" href="http://www.chartjs.org/docs/">Chart Library Documentation</a>\n    </p>\n</blockquote>'},2527:function(t,e){t.exports='<div class="flot-chart">\n    <flot dataset="lc.liveChart.series" options="lc.liveChart.options" on-plot-click="lc.liveChart.onPlotClick(event,pos,item)"\n        on-hover-click="lc.liveChart.onPlotHover(event,pos,item)">\n    </flot>\n</div>'},2528:function(t,e){t.exports="angular.module('app').controller('LiveChartCtrl', LiveChartCtrl);\n\nLiveChartCtrl.$inject = ['$interval', '$colorService'];\n\nfunction LiveChartCtrl($interval, $colorService) {\n\n    var lc = this;\n\n    var flotChartColors = {\n        primary: $colorService.getColor('chart1').toRgb(),\n        gridColor: $colorService.getColor('grey4').toHex(),\n        tickColor: $colorService.getColor('grey6').toHex(),\n        borderColor: $colorService.getColor('grey2').setAlpha(0.5).toRgba(),\n        white: \"#FFFFFF\"\n    };\n\n    var livedata = [];\n    var maximum = 300;\n\n    function getRandomData() {\n\n        if (livedata.length) {\n            livedata = livedata.slice(1);\n        }\n\n        while (livedata.length < maximum) {\n            var previous = livedata.length ? livedata[livedata.length - 1] : 50;\n            var y = previous + Math.random() * 10 - 5;\n            livedata.push(y < 0 ? 0 : y > 100 ? 100 : y);\n        }\n\n        // zip the generated y values with the x values\n\n        var res = [];\n        for (var i = 0; i < livedata.length; ++i) {\n            res.push([i, livedata[i]]);\n        }\n\n        return res;\n    }\n\n    lc.liveChart = {\n        series: [{\n            data: getRandomData(),\n            lines: {\n                fill: true,\n                lineWidth: 1,\n                fillColor: {\n                    colors: [{\n                        opacity: 0.1\n                    }, {\n                        opacity: 0.1\n                    }]\n                }\n            },\n            shadowSize: 0\n        }],\n        options: {\n            grid: {\n                color: [flotChartColors.gridColor],\n                tickColor: [flotChartColors.tickColor],\n                borderWidth: {\n                    \"top\": 0,\n                    \"bottom\": 1,\n                    \"left\": 1,\n                    \"right\": 0\n                },\n                borderColor: {\n                    \"bottom\": [flotChartColors.borderColor],\n                    \"left\": [flotChartColors.borderColor]\n                },\n                minBorderMargin: 20,\n                labelMargin: 10,\n                backgroundColor: {\n                    colors: [\n                        [flotChartColors.white],\n                        [flotChartColors.white]\n                    ]\n                },\n                margin: {\n                    top: 8,\n                    bottom: 20,\n                    left: 20\n                },\n                markings: function (axes) {\n                    var markings = [];\n                    var xaxis = axes.xaxis;\n                    for (var x = Math.floor(xaxis.min); x < xaxis.max; x += xaxis.tickSize * 2) {\n                        markings.push({\n                            xaxis: {\n                                from: x,\n                                to: x + xaxis.tickSize\n                            },\n                            color: [flotChartColors.white]\n                        });\n                    }\n                    return markings;\n                }\n            },\n            colors: [flotChartColors.primary],\n            xaxis: {\n                tickFormatter: function () {\n                    return \"\";\n                }\n            },\n            yaxis: {\n                min: 0,\n                max: 110\n            },\n            legend: {\n                show: true\n            }\n        }\n\n    };\n\n    $interval(function () {\n        lc.liveChart.series[0].data = getRandomData();\n    }, 40);\n\n\n}"}});