(self.webpackChunk_ux_aspects_ux_aspects_docs=self.webpackChunk_ux_aspects_ux_aspects_docs||[]).push([[3705],{53705:function(e,t,o){"use strict";o.r(t),o.d(t,{BlogPageModule:function(){return p}});var n=o(56475),a=o(94121),i=o(3955),s=o(26966),r=o(29872),c=o(93988),l=o(68509);function h(e,t){if(1&e){var o=r["\u0275\u0275getCurrentView"]();r["\u0275\u0275elementStart"](0,"ux-ebox",5),r["\u0275\u0275text"](1,"\n                \n                "),r["\u0275\u0275elementStart"](2,"ux-ebox-header"),r["\u0275\u0275text"](3,"\n                    "),r["\u0275\u0275elementStart"](4,"h3",6),r["\u0275\u0275text"](5),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](6,"\n                    "),r["\u0275\u0275elementStart"](7,"p",7),r["\u0275\u0275text"](8,"by "),r["\u0275\u0275elementStart"](9,"span",8),r["\u0275\u0275text"](10),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](11," "),r["\u0275\u0275elementStart"](12,"span",9),r["\u0275\u0275text"](13,"."),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](14),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](15,"\n                    "),r["\u0275\u0275elementStart"](16,"div",10),r["\u0275\u0275text"](17,"\n                        "),r["\u0275\u0275elementStart"](18,"div",11),r["\u0275\u0275text"](19),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](20,"\n                    "),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](21,"\n                "),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](22,"\n\n                "),r["\u0275\u0275elementStart"](23,"ux-ebox-content"),r["\u0275\u0275text"](24,"\n                    "),r["\u0275\u0275element"](25,"div",12),r["\u0275\u0275text"](26,"\n\n                    "),r["\u0275\u0275elementStart"](27,"a",13),r["\u0275\u0275listener"]("click",(function(e){var t=r["\u0275\u0275restoreView"](o).$implicit;return r["\u0275\u0275nextContext"]().togglePost(t,e)})),r["\u0275\u0275text"](28),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](29,"\n                "),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](30,"\n\n            "),r["\u0275\u0275elementEnd"]()}if(2&e){var n=t.$implicit;r["\u0275\u0275advance"](5),r["\u0275\u0275textInterpolate"](n.title),r["\u0275\u0275advance"](5),r["\u0275\u0275textInterpolate"](n.author),r["\u0275\u0275advance"](4),r["\u0275\u0275textInterpolate1"](" ",n.datestamp,""),r["\u0275\u0275advance"](5),r["\u0275\u0275textInterpolate"](n.category),r["\u0275\u0275advance"](6),r["\u0275\u0275classProp"]("blog-post-content-expanded",n.expanded),r["\u0275\u0275property"]("innerHtml",n.content,r["\u0275\u0275sanitizeHtml"]),r["\u0275\u0275advance"](3),r["\u0275\u0275textInterpolate"](n.expanded?"Show less":"Show more")}}var d=[{path:"",component:function(){function e(e){this.domSanitizer=e,this.posts=[{title:"Data Visualization with UX Aspects",author:"Alastair McKee",category:"Technical",datestamp:"October 17th",content:o(54680)},{title:"End-to-end testing using Protractor",author:"Pearse McMurray",category:"Technical",datestamp:"August 24th",content:o(50690)},{title:"Angular Productivity",author:"Ashley Hunter",category:"Technical",datestamp:"May 25th",content:o(36782)},{title:"Bundle Optimization",author:"Ashley Hunter",category:"Technical",datestamp:"May 25th",content:o(98484)},{title:"Custom Validation Functions",author:"Gavin Neeson",category:"Technical",datestamp:"Jan 27th",content:o(15370)},{title:"UX Aspects Components - a tidy UX design",author:"Gavin Neeson",category:"Technical",datestamp:"Oct 10th",content:o(63435)},{title:"Angular Performance Tips",author:"Ashley Hunter",category:"Technical",datestamp:"Oct 10th",content:o(39837)},{title:"Power of UX Aspects",author:" Gita Narasimhan",category:"Technical",datestamp:"Oct 9th",content:o(96023)}],this.posts.forEach((function(t){t.content=e.bypassSecurityTrustHtml(t.content)}))}return e.prototype.togglePost=function(e,t){e.expanded=!e.expanded,t.preventDefault()},e.\u0275fac=function(t){return new(t||e)(r["\u0275\u0275directiveInject"](c.DomSanitizer))},e.\u0275cmp=r["\u0275\u0275defineComponent"]({type:e,selectors:[["uxd-blog"]],decls:12,vars:1,consts:[["header","Blog","description","Discussions and announcements from the UX Aspects team"],[1,"container"],[1,"row"],[1,"col-md-10","col-md-offset-1","col-sm-12","col-sm-offset-0","m-t"],["class","blog-post-box",4,"ngFor","ngForOf"],[1,"blog-post-box"],[1,"blog-post-title"],[1,"blog-post-info"],[1,"blog-post-author"],[1,"blog-post-separator"],[1,"blog-post-category"],[1,"label","label-accent"],[1,"blog-post-content",3,"innerHtml"],["href","",1,"hyperlink-toggle","blog-post-expand-link",3,"click"]],template:function(e,t){1&e&&(r["\u0275\u0275element"](0,"uxd-page-header",0),r["\u0275\u0275text"](1,"\n\n"),r["\u0275\u0275elementStart"](2,"div",1),r["\u0275\u0275text"](3,"\n    "),r["\u0275\u0275elementStart"](4,"div",2),r["\u0275\u0275text"](5,"\n        "),r["\u0275\u0275elementStart"](6,"div",3),r["\u0275\u0275text"](7,"\n            \n            "),r["\u0275\u0275template"](8,h,31,8,"ux-ebox",4),r["\u0275\u0275text"](9,"\n\n        "),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](10,"\n    "),r["\u0275\u0275elementEnd"](),r["\u0275\u0275text"](11,"\n"),r["\u0275\u0275elementEnd"]()),2&e&&(r["\u0275\u0275advance"](8),r["\u0275\u0275property"]("ngForOf",t.posts))},directives:[l.q,n.NgForOf,i.EboxComponent,i.EboxHeaderDirective,i.EboxContentDirective,i.DefaultFocusIndicatorDirective],styles:["/*\n    Variables for Documentation site\n*/\n.blog-post-box {\n  border-bottom: 2px solid #00a7a2;\n}\n.blog-post-title {\n  font-size: 2rem;\n  margin-bottom: 0;\n}\n.blog-post-info {\n  display: inline-block;\n  color: #999;\n  font-weight: 300;\n  font-size: 1.125rem;\n}\n.blog-post-info .blog-post-author {\n  color: #666;\n}\n.blog-post-info .blog-post-separator {\n  vertical-align: text-bottom;\n  font-weight: 600;\n}\n.blog-post-category {\n  display: inline-block;\n  float: right;\n}\n.blog-post-expand-link {\n  display: inline-block;\n  margin: 5px 0;\n}\n.blog-post-content > * {\n  display: none !important;\n}\n.blog-post-content > *:first-child {\n  display: inherit !important;\n}\n.blog-post-content.blog-post-content-expanded > * {\n  display: inherit !important;\n}\n"],encapsulation:2}),e}()}],p=function(){function e(){}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=r["\u0275\u0275defineNgModule"]({type:e}),e.\u0275inj=r["\u0275\u0275defineInjector"]({imports:[[n.CommonModule,i.EboxModule,s.N,a.RouterModule.forChild(d)]]}),e}()},86810:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),t.hash&&(e+=t.hash),t.maybeNeedQuotes&&/[\t\n\f\r "'=<>`]/.test(e)?'"'.concat(e,'"'):e):e}},8961:function(e,t,o){e.exports=o.p+"assets/angular-language-service.gif"},29603:function(e,t,o){e.exports=o.p+"assets/angular-snippets.gif"},51299:function(e,t,o){e.exports=o.p+"assets/bundle-analysis.jpg"},13996:function(e,t,o){e.exports=o.p+"assets/path-intellisense.gif"},89614:function(e,t,o){e.exports=o.p+"assets/sankey.jpg"},4189:function(e,t,o){e.exports=o.p+"assets/social.jpg"},61896:function(e,t,o){e.exports=o.p+"assets/tslint.gif"},76529:function(e,t,o){e.exports=o.p+"assets/webpack-visualizer-2.jpg"},12581:function(e,t,o){e.exports=o.p+"assets/webpack-visualizer.jpg"},96023:function(e){e.exports="<html><head></head><body><p>CSS3.0 and AngularJS facilitate eye-catchy, responsive and light-weight user experiences. UX Aspects has made optimal use of these technologies, for over an year!</p> <p>With rich Angular components providing seamless integration for your big data applications. UX Aspects takes immense pride in its agile development process, which facilitates its successful evolution.</p> <p>While UX Aspects continuously updates itself with latest advances in responsive design, the core idea of UX Aspects is to be a <strong>\u201cDeveloper\u2019s Friend\u201d</strong>. The velocity at which these standard components help build complex responsive applications is a true differentiator for any team.</p> <p>The integration of \u2018Edit in Code Pen\u2019 feature in UX Aspects creates a developer canvas for testing and updating code. This encourages test-driven development and will prove to be a developer\u2019s delight for building bug free code at lightning speed.</p> <p>UX Aspects takes into account the expansive landscape of big data application development in our Company. The \u2018Customize\u2019 functionality lends itself to brand specific theme building. The one-stop theme builder creates consistent design for any client application.</p> <p>Armed with right core idea, integrated with advances in UX technologies, with an eye for customization, the agile UX Aspects is primed to power anything that comes it's way!</p> </body></html>"},39837:function(e){e.exports='<html><head></head><body><p>Angular makes the process of writing single page applications easy with a vast array of useful directives that often negate the need to write any JavaScript at all. However, when pages start to get complex and there are large amounts of data being shown, whether in table form or visually impressive charts, things can begin to slow down and it is often very easy to just blame the framework. While this could be the case, it is much more likely slow code in the application.</p> <p>Although modern machines often have impressive specs, JavaScript is largely single threaded (with the exception of WebWorkers) and with browsers running at 60 FPS, this gives us ~16ms to run any code in a given frame. On top of that the browser can take ~8ms of that time to calculate layout and render any changes, leaving us with approximately 8ms to work with. If we can\u2019t manage to do everything in that time frame the browser will start dropping frames which can result in a bad user experience. There are certain things we can do to ensure Angular performs as quickly as it possibly can.</p> <h4 id="one-time-bindings">One Time Bindings</h4> <p>Any time we provide an Angular directive with a value, it can watch that value for any changes, which is great, as this provides us with a hassle free way to keep our model and view in sync. However in many occasions our data may be immutable, but Angular isn\u2019t aware of this and each time a digest cycle is run, Angular is checking to see if that value has changed when it really doesn\'t need to. As of Angular 1.3, we can now use one-time bindings, which will provide the directive with an initial value, but will not check again to see if it has changed. To use this feature simply add two colons before any value passed to a directive eg:</p> <pre class="hljs">&lt;p ng-bind="::vm.message"&gt;&lt;/p&gt;</pre> <h4 id="avoid-interpolation">Avoid Interpolation</h4> <p>Angular provides us with a great way to add values from our controller or scope into the view through interpolation. An example of this could be:</p> <pre class="hljs">&lt;h1&gt;{{ vm.myHeading }}&lt;/h1&gt;</pre> <p>While very useful, and sometimes unavoidable, interpolation is slow and can often be improved by using <code>ng-bind</code> instead.</p> <h4 id="track-by">Track By</h4> <p>When using the <code>ng-repeat</code> directive consider adding a \u201ctrack by\u201d key. By adding this, any time the data changes it can determine which items where previously visible and will not create a new element for that item, reducing the amount of DOM manipulation occurring and can significantly reduce the amount of garbage collection the browser needs to do.</p> <pre class="hljs">&lt;tr ng-repeat="item in vm.items track by item.id"&gt;</pre> <h4 id="digest-vs-apply">$digest vs $apply</h4> <p>Most of the time any changes to data in the application will automatically be detected by Angular and the view will be updated, however there can be occasions where this won\'t happen automatically, such as when modifying data in a <code>setTimeout</code> callback. To manually inform Angular that there have been changes we can use <code>$scope.$apply()</code> or <code>$scope.$digest()</code>. Both of these may appear to do the same thing on the surface, but behind the scenes they are quite different and knowing when to use each one can bring quite a few performance benefits to your application.</p> <p><code>$scope.$digest()</code> will begin a digest cycle on the current scope, whereas <code>$scope.$apply()</code> is essentially an alias for <code>$rootScope.$digest()</code>. Once you realize this, you can see that <code>$scope.$digest()</code> will limit the dirty checking to the current scope only, reducing the number of checks significantly. Alternatively <code>$scope.$apply()</code> will check everything on the page, making it a much more expensive operation, so where possible it is always better to use <code>$digest</code> over <code>$apply</code>.</p> <h4 id="ng-show-vs-ng-if">ng-show vs ng-if</h4> <p>When it comes to showing and hiding DOM elements, Angular gives us two options in the form of <code>ng-if</code> and <code>ng-show</code> (or <code>ng-hide</code>). The <code>ng-show</code> directive will hide the element through styling, by setting <code>display</code> to <code>none</code>. The <code>ng-if</code> directive on the other hand will remove the element from the DOM entirely and as well as that will remove any watchers on the element and its children. Due to this fact it is often more performant to use <code>ng-if</code> where possible as this avoids performing updates on elements that are not visible to the user.</p> <h4 id="profiling">Profiling</h4> <p>Chrome Dev Tools provides excellent facilities to determine what parts of your code are running slowly. The timeline tab allows you to record all code execution and see the time each function took to run.</p> <p>There are also several Chrome extensions that can help identify issues:</p> <ul> <li><p><a href="https://chrome.google.com/webstore/detail/angular-performance/hejbpbhdhhchmmcgmccpnngfedalkmkm">Angular Performance</a></p> </li> <li><p><a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk?hl=en">Angular Batarang</a></p> </li> <li><p><a href="https://chrome.google.com/webstore/detail/angularjs-inspect-watcher/gdfcinoagafkodbnkjemaajfahnmfkhg">NG Inspect Watchers</a></p> </li> <li><p><a href="https://chrome.google.com/webstore/detail/web-tracing-framework/gmdhhnlkjmknaopofnadmoamhmnlicme">Web Tracing Framework</a></p> </li> </ul> </body></html>'},63435:function(e){e.exports='<html><head></head><body><p>You might be asking yourself, why should I use UX Aspects? How do I benefit from using UX Aspects in my project? Well, UX Aspects has many features that would prove to be advantageous to your project, be it big or small. We bundle together numerous useful components that can form as the base of your project, and if you wish to use components that are responsive with a unique UX design you are in the right place.</p> <p>By just navigating through the Components section, you will undoubtedly come across features that will make you think "If only I had seen this before!". Let\u2019s say you need a neat and tidy way of displaying a summary of user details for a list of users. In this case you could benefit from the Flippable Cards component which provides a way of displaying information without taking up unnecessary screen space. All you need to do is choose what you want the front and the back of your card to contain, and by hovering or clicking the card, you can see both sides.</p> <p>What if you need to provide some sort of notifications to users? This could be tricky and time consuming to implement yourself, but with UX Aspects we already have a solution for you. The Notifications component provides a method of displaying dismissible notifications on screen, with slick animations for when the notifications appear and disappear. You have many options to choose from to suit your needs. You can provide an icon for the notification, choose the duration for which notifications appear, display notifications as a badge etc. </p> <p>Need a popup wizard to guide end users through a set of steps? No problem, why not implement the Marquee Wizard? With hooks to validation, you can provide your own validation methods to decide whether or not the user can continue to the next step. </p> <p>These are just a few of the components you can use to display information to end users in a seamless UX design. There are many more!</p> </body></html>'},15370:function(e){e.exports='<html><head></head><body><p>Forms and Inputs come with a lot of built-in validation for types such as <code>number</code>, <code>email</code> etc. Angular also provides directives for validation such as <code>ng-required</code>, <code>ng-minlength</code>, <code>ng-maxlength</code>, etc. These can be very useful when validating user input, for example, if you specify that an input is of type <code>email</code> the input field will be invalid until a valid email address has been entered.</p> <pre class="hljs">&lt;input type="email" ng-model="vm.emailAddress" name="emailInput" placeholder="Enter your email address"/&gt;</pre> <p>While this is very useful and allows you to perform a lot of validation there are constraints if you wish to apply complex validation, for example, if you want to validate that an id exists within a set of value. This is when it becomes useful to implement your own validation functions to the <code>$validators</code> object on the <code>ngModelController</code>. </p> <h4 id="validators-object">$validators object</h4> <p>To access the <code>$validators</code> object of an input you must first ensure that your <code>input</code> tag is placed within a <code>form</code> tag and that both the input and form have been named accordingly. You must then inject <code>$scope</code> to your controller and you will then be able to access the <code>$validators</code> property by watching your <code>form</code> on the <code>$scope</code> and attaching the new validator when it is ready. You know when it is ready by checking the <code>newValue</code> of the watch and if it exists then we check if our custom validator function already exists and if not we can add our own new function.</p> <p>You can see this in the example below. We access the <code>$validators</code> property by <code>formName.inputName.$validators</code> and then attach our own new validation function to this. This function will be called with <code>modelValue</code> and <code>viewValue</code> as parameters every time the <code>ngModel</code> of the input changes.</p> <p>If the input is valid the function should return <code>true</code>, otherwise it should return <code>false</code>.</p> <pre class="hljs">$scope.$watch(\'vm.myForm\', function(form) {\n    if (form &amp;&amp; !form.myInput.$validators.myCustomValidator) { \n        form.testInput.$validators.myCustomValidator = function(modelValue, viewValue) {\n            if (validValues.indexOf(viewValue) === -1) return false;\n\n            return true;\n        };\n    }\n});</pre> <h4 id="adding-styling-depending-on-validity">Adding styling depending on validity</h4> <p>When the input is invalid it will have an <code>.ng-invalid</code> class as well as an <code>.ng-invalid-my-custom-validator</code> class (depending on what your named your validator on the <code>$validators</code> object). You can then apply styling accordingly.</p> <pre class="hljs">input.ng-invalid-my-custom-validator {\n    border: 1px solid red;\n}</pre> <p>You can also check <code>$error</code> property on the input <code>ngModel</code> for your custom validation and if is invalid it will be <code>true</code>, otherwise it will be <code>false</code>.</p> <pre class="hljs">&lt;p ng-show="vm.myForm.myInput.$error.myCustomValidator"&gt;THERE IS AN ERROR&lt;/p&gt;</pre> <blockquote> <p>It is best practice to name the Form on your controller scope (i.e. <code>vm</code>) as doing otherwise my result in the form being attached to the scope of a different directive.</p> </blockquote> <p>For full documentation visit the <a href="https://docs.angularjs.org/guide/forms">Forms</a> and <a href="https://docs.angularjs.org/api/ng/type/ngModel.NgModelController">ngModelController</a> pages.</p> </body></html>'},36782:function(e,t,o){var n=o(86810),a=o(8961),i=o(29603),s=o(13996),r=o(61896),c=n(a),l=n(i),h=n(s),d=n(r);e.exports='<html><head></head><body><p>If you have started working with Angular and TypeScript one of the first things you notice is how much the tooling has improved when compared to writing apps in AngularJS and plain JavaScript. It brings many benefits such as early error detection, scalability and a productivity boost. With Type Definitions for nearly all major third party libraries the editor is now able to prompt you with contextually aware suggestions and often documentation on that function without leaving the editor. You get all these features as standard in editors such as VS Code, but there are many extensions available for the most popular editors that can further improve productivity and developer experience using Angular.</p> <h3 id="1-angular-language-service">1. Angular Language Service</h3> <p>The Angular Language Service is an extension being developed by the Angular team and provides some incredibly useful features. The extension is aware of when you are working in a component template file and will provide you with auto complete suggestions, error checking and the ability to Ctrl+Click on a component, variable or function and jump to the implementation or declaration. It is also aware what component selectors are available and all of the inputs and outputs available on each element.</p> <br> <img src="'+c+'"> <br> <br> <h3 id="2-angular-v4-typescript-snippets">2. Angular v4 TypeScript Snippets</h3> <p>When creating an Angular application you will notice that there are certain bits of code that you end up typing over and over again, in particular things like NgModule, Component and Directive decorators. To speed up this process the Angular v4 TypeScript Snippets extension allows you to easily create this boilerplate code for you.</p> <br> <img src="'+l+'"> <br> <br> <h3 id="3-path-intellisense">3. Path Intellisense</h3> <p>One thing that becomes very common when creating Angular components is having to provide relative file paths for templates and stylesheets, but this is also common when adding images in HTML and CSS rules.</p> <p>With the Path Intellisense plugin, the editor will display the list of files and folders in the directory and will update to show the appropriate results as you change the file path.</p> <br> <img src="'+h+'"> <br> <br> <h3 id="4-tslint">4. TSLint</h3> <p>TSLint is both an extension for your editor and a node module. It allows you to define a set of rules about how developers should write their code, making it consistent throughout the entire codebase. The editor extension will check your code as you type it, inform you of anything that doesn\'t conform to the rules and the editor can often provide you with auto-fix functionality. TSLint can run as part of a build process to ensure that code meets the expected standard before the build will be successful.</p> <p>In addition to this, you can add further rules describing how Angular components should be written by adding Codealyzer to your project.</p> <br> <img src="'+d+'"> <br> <br> </body></html>'},98484:function(e,t,o){var n=o(86810),a=o(12581),i=o(76529),s=o(51299),r=n(a),c=n(i),l=n(s);e.exports='<html><head></head><body><p>When building any large web application nowadays it is highly likely that you will use a bundling tool. Tools like Webpack bring some great benefits and optimizations such as Tree Shaking to remove any code that isn\'t used and code splitting to intelligently split code into different scripts so they can be lazy loaded only when they are needed, improving your page load times. Angular\'s router works extremely well with code splitting and can handle all the lazy loading for you.</p> <p>It is commonplace in JavaScript to use many libraries and frameworks in your application and the size of your bundle can grow quite quickly. It can be difficult to easily identify what your bundle actually contains and determine what libraries are increasing the output size.</p> <p>To help with this Webpack gives us a few useful tools. First we can output all the information about our Webpack build by passing the <code>--json</code> flag and streaming the output to a file. This can be done by using the following code:</p> <br> <pre class="hljs">webpack <span class="hljs-comment">--json &gt; stats.json</span></pre><br> <p>Next we can go to <a href="https://chrisbateman.github.io/webpack-visualizer/">https://chrisbateman.github.io/webpack-visualizer/</a> which is an online tool to visualize the contents of your bundle. Simply select the JSON file we just created and it will show you the contents of your bundle with more detail once you hover over a segment. <em>Note, if nothing happens when you choose the file, ensure that the stats.json file contains valid JSON as some loaders print output which can cause problems.</em></p> <br> <img src="'+r+'"> <br> <p>In the example image above you can see we have imported the entire RxJS library, adding 677.9KB to our build output. By importing only the things we need from the RxJS library we can take advantage of Tree Shaking. After we make the optimizations we can clearly see the difference.</p> <br> <img src="'+c+'"> <br> <p>Additionally Webpack offers its own online tool for analyzing bundles in more depth. This service can be found at <a href="http://webpack.github.io/analyse/">http://webpack.github.io/analyse/</a>.</p> <br> <img src="'+l+'"> </body></html>'},50690:function(e){e.exports='<html><head></head><body><p>Unit tests test the smallest level of functionality e.g. the result of executing a method. End-to-end (E2E) tests build on unit tests by combining units of code and testing that the resulting combination functions correctly. They test a particular feature for correctness by comparing the results for a given input against the specification e.g. \'pressing button X should result in checkbox Y becoming disabled\'.</p> <p>Protractor is an end-to-end, open source test framework for Angular. It uses the Jasmine framework by default and runs on top of Selenium WebDriver. Tests may be run against a local Selenium server or against a remote server e.g. a Selenium Grid system. Tests may be written in JavaScript and TypeScript.</p> <p>The UXAspects project includes a suite of E2E tests in the \'e2e\' folder of the project repository.</p> <h3 id="installation">Installation</h3> <p>Install <a href="https://nodejs.org/">Node.js</a>, which provides the npm package manager.</p> <p>Execute the command <code>npm install -g grunt-cli</code> to install the grunt command line interface.</p> <p>Follow the instructions in the "Building from Source" section in the <a href="https://uxaspects.github.io/UXAspects/#/gettingstarted">Getting Started</a> page of the UX Aspects documentation to build the components to be tested.</p> <p>Before the first test run, execute <code>./node_modules/.bin/webdriver-manager update</code> to download the binaries necessary to get an instance of the Selenium Server running.</p> <p>Execute the command <code>grunt e2e</code> to run the tests.</p> <h3 id="architecture">Architecture</h3> <p>All Protractor methods are asynchronous and return promises. WebDriver maintains a queue of pending promises called the control flow. Promises are queued and resolved in the order they were created in.</p> <p>In our tests, elements are located on the test page by using \'by.ID\' and \'by.CSS\' locators.</p> <p>The Protractor global elements() function takes a locator for an element and returns that element. When using CSS selectors as a locator, the shortcut $() notation may be used. For example, <code>checkbox1.$(\'div .ux-checked\')</code> is the same as <code>checkbox1.element(by.css(\'div .ux-checked\'))</code>.</p> <p>Multiple DOM elements may be found using the global element.all() function. As with single elements, a shortcut notation, $$(), may be used. For example <code>textsContainer.$$(\'em\').get(1)</code> is the same as <code>textsContainer.elements.all(by.css(\'em\').get(1))</code> and returns the second of an array of \'em\' elements.</p> <h3 id="test-organisation">Test organisation</h3> <h4 id="html-files">HTML files</h4> <p>The components being tested are grouped in HTML pages under the e2e/pages folder.</p> <p>The tests to be run against these pages are found under the e2e/tests folder.</p> <p>The e2e/protractor.config.js configuration file defines the location of the test files to be executed (in the \'specs\' property) and the URL for the Selenium server. The browser the tests are to run in is defined in the \'capabilities\' property (at the moment tests are run only in Chrome).</p> <h4 id="page-objects">Page Objects</h4> <p>When writing Protractor tests, it is good practice to place information about the location of elements in \'page object\' files, separate from the definitions of the tests themselves.</p> <p>A page object is a class that serves as an interface to the UI page being tested. The tests then use the methods of this class whenever they need to interact with that page.</p> <p>Encapsulating this information in a separate file means that if the organization of the page being tested changes, only the code within the page object needs to change. The tests themselves can remain unchanged. In addition, the Protractor-specific terms used to locate elements on the page are restricted to the page object files, making the test specification files easier to read.</p> <h4 id="test-specifications">Test specifications</h4> <p>The test instructions themselves are written using Jasmine syntax in test specification files. The page object class is exported from the page object file and imported into the test specification file.</p> <h3 id="results">Results</h3> <p>A variety of reporter classes are available to format tests results. Our e2e project outputs results to XML and HTML files. Further information about the reporters may be obtained at <a href="https://github.com/larrymyers/jasmine-reporters">https://github.com/larrymyers/jasmine-reporters</a>.</p> <h3 id="example-test">Example Test</h3> <p>To illustrate the organization of our Protractor tests, here is a simplified version of the tests for our Checkbox component.</p> <h4 id="html-file-containing-components-to-be-tested">HTML file containing components to be tested</h4> <p>Some checkboxes and associated elements are displayed in the HTML file to be tested (<a href="https://github.com/UXAspects/UXAspects/blob/develop/e2e/pages/app/checkbox/checkbox.testpage.component.html">e2e\\pages\\app\\checkbox\\checkbox.testpage.component.html</a>).</p> <pre class="hljs">&lt;div&gt;\n    &lt;ux-checkbox id="checkbox1" [(value)]="checkModel.option1" [disabled]="disableCheck" \n        [simplified]="simplified"&gt;Option1\n    &lt;/ux-checkbox&gt;\n&lt;/div&gt;\n\n&lt;div&gt;\n    &lt;ux-checkbox id="checkbox2" [(value)]="checkModel.option2" [indeterminateValue]="indeterminateValue"\n        [simplified]="simplified"&gt;Option2\n    &lt;/ux-checkbox&gt;\n&lt;/div&gt;\n\n&lt;div&gt;\n    &lt;button  id="button1" class="btn button-primary m-r-xs" \n        (click)="disableCheck = !disableCheck"&gt;\n        {{ disableCheck ? \'Click to enable Option1\' : \'Click to disable Option1\' }}\n    &lt;/button&gt;\n&lt;/div&gt;</pre> <h4 id="page-object-file">Page object file</h4> <p>The page object file for the tests defines an interface to be used to access the elements in the test page (<a href="https://github.com/UXAspects/UXAspects/blob/develop/e2e/tests/components/checkbox/checkbox.po.spec.ts">e2e\\tests\\components\\checkbox\\checkbox.po.spec.ts</a>).</p> <pre class="hljs">import { browser, element, by, ElementFinder } from \'protractor\';\nexport class CheckBoxesPage {\n\n    getPage(): void {\n        browser.get(\'/checkboxes\');\n    }\n\n    checkbox1 = element(by.id(\'checkbox1\'));\n    checkbox2 = element(by.id(\'checkbox2\'));\n    disableButton = element(by.id(\'button1\'));\n\n    confirmIsChecked(checkbox: ElementFinder) {    \n        return checkbox.$(\'div.ux-checked\').isPresent();\n    }\n\n    confirmIsDisabled(checkbox: ElementFinder) {\n        return checkbox.$(\'div.ux-disabled\').isPresent();\n    }\n}</pre> <h4 id="test-specification-file">Test specification file</h4> <p>The tests specification file (<a href="https://github.com/UXAspects/UXAspects/blob/develop/e2e/protractor.config.js">e2e\\tests\\components\\checkbox\\checkbox.e2e-spec.ts</a>) uses the page object class to access the elements on the page being tested. The tests use Jasmine syntax to check the values associated with elements (e.g. <code>\'expect(page.confirmIsChecked(page.checkbox1)).toBeTruthy()\'</code>) and to perform operations on elements e.g. (<code>\'page.disableButton.click()\'</code>).</p> <pre class="hljs">import { browser, Key } from \'protractor\';\nimport { CheckBoxesPage } from \'./checkbox.po.spec\';\n\ndescribe(\'Checkbox Tests\', () =&gt; {\n\n  let page: CheckBoxesPage;\n  let browserName: string;\n\n  beforeEach(() =&gt; {\n    page = new CheckBoxesPage();\n    page.getPage();\n  });\n\n  it(\'should have correct initial states\', () =&gt; {    \n    // Initial values.\n    expect(page.confirmIsChecked(page.checkbox1)).toBeTruthy();\n    expect(page.confirmIsChecked(page.checkbox2)).toBeFalsy();\n\n    // All enabled.\n    expect(page.confirmIsDisabled(page.checkbox1)).toBeFalsy();\n    expect(page.confirmIsDisabled(page.checkbox2)).toBeFalsy();\n  });\n\n  it(\'should react to clicks\', () =&gt; {\n    page.checkbox2.click();\n    expect(page.confirmIsChecked(page.checkbox2)).toBeTruthy();\n    page.checkbox1.click();\n    expect(page.confirmIsChecked(page.checkbox1)).toBeFalsy();\n  });\n\n  it(\'should react to disabling\', () =&gt; {\n    page.disableButton.click();\n    expect(page.confirmIsDisabled(page.checkbox1)).toBeTruthy();\n    page.checkbox1.click();\n    expect(page.confirmIsChecked(page.checkbox1)).toBeTruthy();\n  });\n}</pre> <h3 id="further-reading">Further reading</h3> <p>More details about Protractor may be obtained at <a href="http://www.protractortest.org/#/toc">http://www.protractortest.org/#/toc</a>.</p> </body></html>'},54680:function(e,t,o){var n=o(86810),a=o(89614),i=o(4189),s=n(a),r=n(i);e.exports='<html><head></head><body><p>When working with big data we quickly find ourselves with large volumes of data which holds key information. In order to make use of this data we need a way to analyse and present it in a way that allows us to make critical decisions. Using charts and graphs to visualize this data provides a quick and easy way to understand the data and can be used to highlight areas that need attention, identify key trends and predict how things will change in the future.</p> <p>It is important to remember that not all data should be visualized in the same way. In many cases what works for one data set will not accurately convey the information for another data set. For this reason UX Aspects provides a range of different visualization tools in the <a href="https://uxaspects.github.io/UXAspects/#/charts/bar-charts">charts section</a>. </p> <p>These cover simple bar charts, line charts and donut charts as well as some more specific charts such as the partition map, which is useful for displaying files in a repository, the organization chart, used for displaying the hierarchy of your organization, and the social chart for displaying social interactions between users. </p> <div class="row"> <img class="col-md-6" src="'+s+'"> <img class="col-md-6" src="'+r+'"> </div> <p>UX Aspects also provides a <a href="https://uxaspects.github.io/UXAspects/#/components/utilities#color-service">color service</a> which allows you to quickly and easily update the colors on your charts to give your application that personal touch.</p> <p>This is just a small overview of some of the data visualization tools UX Aspects offers to help you get the most out of your data, check out our documentation sections to preview these components in action and find out how to use them in your own application.</p> </body></html>'}}]);