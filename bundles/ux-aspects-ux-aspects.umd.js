(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Subject'), require('@angular/common'), require('@angular/router'), require('resize-observer-polyfill'), require('rxjs/ReplaySubject'), require('rxjs/operators'), require('rxjs/BehaviorSubject'), require('@angular/forms'), require('rxjs/observable/combineLatest'), require('@angular/cdk/a11y'), require('angular-split'), require('rxjs/Observable'), require('@angular/cdk/keycodes'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('rxjs/observable/fromEvent'), require('@angular/cdk/observers'), require('rxjs/Subscription'), require('rxjs/observable/from'), require('rxjs/observable/of'), require('dragula/dist/dragula'), require('ngx-bootstrap/dropdown'), require('@angular/animations'), require('rxjs/observable/concat'), require('rxjs/observable/timer'), require('@angular/common/http'), require('rxjs/operators/filter'), require('rxjs-compat/BehaviorSubject'), require('@angular/upgrade/static')) :
    typeof define === 'function' && define.amd ? define('@ux-aspects/ux-aspects', ['exports', '@angular/core', 'rxjs/Subject', '@angular/common', '@angular/router', 'resize-observer-polyfill', 'rxjs/ReplaySubject', 'rxjs/operators', 'rxjs/BehaviorSubject', '@angular/forms', 'rxjs/observable/combineLatest', '@angular/cdk/a11y', 'angular-split', 'rxjs/Observable', '@angular/cdk/keycodes', '@angular/cdk/overlay', '@angular/cdk/portal', 'rxjs/observable/fromEvent', '@angular/cdk/observers', 'rxjs/Subscription', 'rxjs/observable/from', 'rxjs/observable/of', 'dragula/dist/dragula', 'ngx-bootstrap/dropdown', '@angular/animations', 'rxjs/observable/concat', 'rxjs/observable/timer', '@angular/common/http', 'rxjs/operators/filter', 'rxjs-compat/BehaviorSubject', '@angular/upgrade/static'], factory) :
    (factory((global['ux-aspects'] = global['ux-aspects'] || {}, global['ux-aspects']['ux-aspects'] = {}),global.ng.core,global.rxjs.Subject,global.ng.common,global.ng.router,null,global.rxjs.ReplaySubject,global.rxjs.operators,global.rxjs.BehaviorSubject,global.ng.forms,global.rxjs['observable/combineLatest'],global.ng.cdk.a11y,null,global.rxjs.Observable,global.ng.cdk.keycodes,global.ng.cdk.overlay,global.ng.cdk.portal,global.rxjs['observable/fromEvent'],global.ng.cdk.observers,global.rxjs.Subscription,global.rxjs['observable/from'],global.rxjs['observable/of'],null,null,global.ng.animations,global.rxjs['observable/concat'],global.rxjs['observable/timer'],global.ng.common.http,global.rxjs['operators/filter'],null,global.ng.upgrade.static));
}(this, (function (exports,core,Subject,common,router,ResizeObserver,ReplaySubject,operators,BehaviorSubject,forms,combineLatest,a11y,angularSplit,Observable,keycodes,overlay,portal,fromEvent,observers,Subscription,from,of,dragulaNamespace,dropdown,animations,concat,timer,http,filter,BehaviorSubject$1,_static) { 'use strict';

    ResizeObserver = ResizeObserver && ResizeObserver.hasOwnProperty('default') ? ResizeObserver['default'] : ResizeObserver;
    var dragulaNamespace__default = 'default' in dragulaNamespace ? dragulaNamespace['default'] : dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionPanelHeadingDirective = (function () {
        function AccordionPanelHeadingDirective() {
        }
        AccordionPanelHeadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-accordion-panel-header'
                    },] }
        ];
        return AccordionPanelHeadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionService = (function () {
        function AccordionService() {
            this.collapseOthers = false;
            this.collapse = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        AccordionService.prototype.collapseAll = /**
         * @return {?}
         */
            function () {
                this.collapse.next();
            };
        AccordionService.decorators = [
            { type: core.Injectable }
        ];
        return AccordionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId = 1;
    var AccordionPanelComponent = (function () {
        function AccordionPanelComponent(accordion) {
            var _this = this;
            this.accordion = accordion;
            this.panelId = "ux-accordion-panel-" + uniqueId++;
            this.headingId = this.panelId + "-heading";
            this.disabled = false;
            this.expanded = false;
            this.expandedChange = new core.EventEmitter();
            accordion.collapse.subscribe(function () { return _this.collapse(); });
        }
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.expanded) {
                    this.collapse();
                    return;
                }
                // check if we should collapse others
                if (this.accordion.collapseOthers) {
                    this.accordion.collapseAll();
                }
                // store the new expanded state
                this.expand();
            };
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.expand = /**
         * @return {?}
         */
            function () {
                if (this.disabled === false && this.expanded === false) {
                    this.expanded = true;
                    this.expandedChange.next(true);
                }
            };
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.collapse = /**
         * @return {?}
         */
            function () {
                if (this.disabled === false && this.expanded === true) {
                    this.expanded = false;
                    this.expandedChange.next(false);
                }
            };
        AccordionPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-accordion-panel',
                        template: "<div class=\"panel-heading\"\n      role=\"button\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      [id]=\"headingId\"\n      [attr.aria-expanded]=\"expanded\"\n      [attr.aria-controls]=\"panelId\"\n      (click)=\"toggle()\"\n      (keydown.enter)=\"toggle()\"\n      (keydown.space)=\"toggle(); $event.preventDefault()\"\n      (keydown.spacebar)=\"toggle(); $event.preventDefault()\">\n\n  <div class=\"panel-title\">\n      {{ heading }}\n      <ng-content select=\"ux-accordion-panel-header\"></ng-content>\n  </div>\n</div>\n\n<div [id]=\"panelId\"\n      class=\"panel-collapse collapse\"\n      [class.in]=\"expanded\"\n      role=\"tabpanel\"\n      [attr.aria-labelledby]=\"headingId\">\n\n  <div class=\"panel-body\">\n    <ng-content></ng-content>\n  </div>\n</div>",
                        host: {
                            'class': 'panel panel-default',
                            'role': 'tab'
                        }
                    }] }
        ];
        /** @nocollapse */
        AccordionPanelComponent.ctorParameters = function () {
            return [
                { type: AccordionService }
            ];
        };
        AccordionPanelComponent.propDecorators = {
            panelId: [{ type: core.Input }],
            headingId: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            heading: [{ type: core.Input }],
            expanded: [{ type: core.Input }, { type: core.HostBinding, args: ['class.panel-open',] }],
            expandedChange: [{ type: core.Output }]
        };
        return AccordionPanelComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionComponent = (function () {
        function AccordionComponent(_accordion) {
            this._accordion = _accordion;
        }
        Object.defineProperty(AccordionComponent.prototype, "collapseOthers", {
            set: /**
             * @param {?} collapseOthers
             * @return {?}
             */ function (collapseOthers) {
                this._accordion.collapseOthers = collapseOthers;
            },
            enumerable: true,
            configurable: true
        });
        AccordionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-accordion',
                        template: "<ng-content></ng-content>",
                        providers: [AccordionService],
                        host: {
                            'class': 'panel-group',
                            'role': 'tablist',
                            'aria-multiselectable': 'true'
                        }
                    }] }
        ];
        /** @nocollapse */
        AccordionComponent.ctorParameters = function () {
            return [
                { type: AccordionService }
            ];
        };
        AccordionComponent.propDecorators = {
            collapseOthers: [{ type: core.Input }]
        };
        return AccordionComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionModule = (function () {
        function AccordionModule() {
        }
        AccordionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            AccordionComponent,
                            AccordionPanelComponent,
                            AccordionPanelHeadingDirective
                        ],
                        exports: [
                            AccordionComponent,
                            AccordionPanelComponent,
                            AccordionPanelHeadingDirective
                        ]
                    },] }
        ];
        return AccordionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsComponent = (function () {
        function BreadcrumbsComponent() {
        }
        /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
        BreadcrumbsComponent.prototype.clickCrumb = /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
            function (event, crumb) {
                if (crumb.onClick) {
                    crumb.onClick.call(null, event);
                }
            };
        BreadcrumbsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-breadcrumbs',
                        template: "<nav aria-label=\"Breadcrumb\">\n    <ol class=\"breadcrumb\">\n        <li *ngFor=\"let crumb of crumbs\">\n\n            <!-- If there is a router link then use a tag -->\n            <a *ngIf=\"crumb.routerLink || crumb.onClick\"\n                tabindex=\"0\"\n                [routerLink]=\"crumb.routerLink\"\n                [fragment]=\"crumb.fragment\"\n                [queryParams]=\"crumb.queryParams\"\n                (click)=\"clickCrumb($event, crumb)\">\n                {{ crumb.title }}\n            </a>\n\n            <!-- If there is not router link then display text in a span -->\n            <span *ngIf=\"!crumb.routerLink && !crumb.onClick\">{{ crumb.title }}</span>\n        </li>\n    </ol>\n</nav>"
                    }] }
        ];
        BreadcrumbsComponent.propDecorators = {
            crumbs: [{ type: core.Input }]
        };
        return BreadcrumbsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsModule = (function () {
        function BreadcrumbsModule() {
        }
        BreadcrumbsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [BreadcrumbsComponent],
                        declarations: [BreadcrumbsComponent]
                    },] }
        ];
        return BreadcrumbsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [0, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeService = (function () {
        function ResizeService(_zone) {
            this._zone = _zone;
            this._observer = new ResizeObserver(this.elementDidResize.bind(this));
            this._targets = new WeakMap();
        }
        /**
         * @return {?}
         */
        ResizeService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._observer.disconnect();
            };
        /**
         * @param {?} target
         * @return {?}
         */
        ResizeService.prototype.addResizeListener = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                var _this = this;
                this._zone.runOutsideAngular(function () { return _this._observer.observe(target); });
                if (this._targets.has(target)) {
                    return this._targets.get(target);
                }
                else {
                    var /** @type {?} */ emitter = new ReplaySubject.ReplaySubject();
                    this._targets.set(target, emitter);
                    return emitter;
                }
            };
        /**
         * @param {?} target
         * @return {?}
         */
        ResizeService.prototype.removeResizeListener = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                this._observer.unobserve(target);
            };
        /**
         * @param {?} entries
         * @return {?}
         */
        ResizeService.prototype.elementDidResize = /**
         * @param {?} entries
         * @return {?}
         */
            function (entries) {
                var _this = this;
                this._zone.run(function () {
                    try {
                        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                            var entry = entries_1_1.value;
                            if (_this._targets.has(/** @type {?} */ (entry.target))) {
                                var /** @type {?} */ emitter = _this._targets.get(/** @type {?} */ (entry.target));
                                emitter.next({ width: ((entry.target)).offsetWidth, height: ((entry.target)).offsetHeight });
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
                                _a.call(entries_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    var e_1, _a;
                });
            };
        ResizeService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ResizeService.ctorParameters = function () {
            return [
                { type: core.NgZone }
            ];
        };
        return ResizeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeDirective = (function () {
        function ResizeDirective(_elementRef, _resizeService, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._ngZone = _ngZone;
            this.throttle = 0;
            this.uxResize = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscription = this._resizeService.addResizeListener(this._elementRef.nativeElement)
                    .pipe(operators.debounceTime(this.throttle))
                    .subscribe(function (event) { return _this._ngZone.run(function () { return _this.uxResize.emit(event); }); });
            };
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._resizeService.removeResizeListener(this._elementRef.nativeElement);
                this._subscription.unsubscribe();
            };
        ResizeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxResize]',
                        providers: [ResizeService]
                    },] }
        ];
        /** @nocollapse */
        ResizeDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService },
                { type: core.NgZone }
            ];
        };
        ResizeDirective.propDecorators = {
            throttle: [{ type: core.Input }],
            uxResize: [{ type: core.Output }]
        };
        return ResizeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeModule = (function () {
        function ResizeModule() {
        }
        ResizeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ResizeDirective],
                        declarations: [ResizeDirective],
                        providers: [ResizeService]
                    },] }
        ];
        return ResizeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabContentDirective = (function () {
        function CardTabContentDirective() {
        }
        CardTabContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxCardTabContent]'
                    },] }
        ];
        return CardTabContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsService = (function () {
        function CardTabsService() {
            var _this = this;
            this.tab$ = new BehaviorSubject.BehaviorSubject(null);
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.position$ = new BehaviorSubject.BehaviorSubject('top');
            // when a tab is added or removed ensure we always select one if any are available
            this._subscription = this.tabs$.pipe(operators.filter(function (tabs) { return !_this.tab$.value || !tabs.find(function (tab) { return tab === _this.tab$.value; }); })).subscribe(function (tabs) { return _this.tab$.next(tabs.length > 0 ? tabs[0] : null); });
        }
        /**
         * @return {?}
         */
        CardTabsService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Add a tab to the list of tabs
         */
        /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.addTab = /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
            };
        /**
         * Remove a tab from the list
         */
        /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.removeTab = /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * Select the tab
         */
        /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.select = /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tab$.next(tab);
            };
        /**
         * Set the position of the tab content
         */
        /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
        CardTabsService.prototype.setPosition = /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
            function (position) {
                this.position$.next(position);
            };
        CardTabsService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        CardTabsService.ctorParameters = function () { return []; };
        return CardTabsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabComponent = (function () {
        function CardTabComponent(_tabService) {
            var _this = this;
            this._tabService = _tabService;
            this.active$ = this._tabService.tab$.pipe(operators.map(function (tab) { return tab === _this; }));
            this._tabService.addTab(this);
        }
        /**
         * @return {?}
         */
        CardTabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._tabService.removeTab(this);
            };
        CardTabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tab',
                        template: "<ng-content *ngIf=\"active$ | async\"></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        CardTabComponent.ctorParameters = function () {
            return [
                { type: CardTabsService }
            ];
        };
        CardTabComponent.propDecorators = {
            content: [{ type: core.ContentChild, args: [CardTabContentDirective, { read: core.TemplateRef },] }]
        };
        return CardTabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsetComponent = (function () {
        function CardTabsetComponent(tabService) {
            this.tabService = tabService;
            this.offset = 0;
            this.bounds = { lower: 0, upper: 0 };
        }
        Object.defineProperty(CardTabsetComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabService.position$.getValue();
            },
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this.tabService.setPosition(direction);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.select = /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
            function (tab, element) {
                // select the tab
                this.tabService.select(tab);
                // ensure the tab is moved into view if required
                this.moveIntoView(element);
            };
        /**
         * @param {?} dimensions
         * @return {?}
         */
        CardTabsetComponent.prototype.resize = /**
         * @param {?} dimensions
         * @return {?}
         */
            function (dimensions) {
                this._width = dimensions.width;
                this._innerWidth = this.tablist.nativeElement.scrollWidth;
                this.bounds.lower = 0;
                this.bounds.upper = -(this._innerWidth - this._width);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.previous = /**
         * @return {?}
         */
            function () {
                this.offset += this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.min(this.offset, this.bounds.lower);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.next = /**
         * @return {?}
         */
            function () {
                this.offset -= this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.max(this.offset, this.bounds.upper);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.moveIntoView = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                // if we dont have the dimensions we cant check
                if (!this._width || !this._innerWidth) {
                    return;
                }
                // get the current element bounds
                var offsetLeft = element.offsetLeft, offsetWidth = element.offsetWidth;
                var _a = getComputedStyle(element), marginLeft = _a.marginLeft, marginRight = _a.marginRight;
                // calculate the visible area
                var /** @type {?} */ viewportStart = Math.abs(this.offset);
                var /** @type {?} */ viewportEnd = viewportStart + this._width;
                var /** @type {?} */ cardWidth = parseFloat(marginLeft) + offsetWidth + parseFloat(marginRight);
                // if we need to move to the left - figure out how much
                if (offsetLeft < viewportStart) {
                    this.offset -= (offsetLeft - parseFloat(marginLeft)) - viewportStart;
                }
                // if we need to move to the right - figure out how much
                if ((offsetLeft + cardWidth) > viewportEnd) {
                    this.offset -= (offsetLeft + cardWidth) - viewportEnd;
                }
            };
        CardTabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tabset',
                        template: "<div class=\"card-tab-content\" role=\"tabpanel\" *ngIf=\"(tabService.tab$ | async)\">\r\n    <ng-content></ng-content>\r\n</div>\r\n\r\n<div class=\"card-tabs\" #tabs>\r\n\r\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-previous\" aria-label=\"Previous Tabs\" (click)=\"previous()\" *ngIf=\"offset < bounds.lower\">\r\n        <i class=\"hpe-icon hpe-previous\"></i>\r\n    </button>\r\n\r\n    <div class=\"card-tabs-list\" role=\"tablist\" #tablist (uxResize)=\"resize($event)\" [style.transform]=\"'translateX(' + offset + 'px)'\">\r\n\r\n        <div class=\"card-tab\"\r\n            role=\"tab\"\r\n            tabindex=\"0\" #card\r\n            *ngFor=\"let tab of tabService.tabs$ | async\"\r\n            [ngClass]=\"tabService.position$ | async\"\r\n            [class.active]=\"tab.active$ | async\"\r\n            [attr.aria-selected]=\"tab.active$ | async\"\r\n            (click)=\"select(tab, card)\"\r\n            (focus)=\"tabs.scrollLeft = 0\"\r\n            (keydown.enter)=\"select(tab, card)\">\r\n\r\n            <ng-container [ngTemplateOutlet]=\"tab.content\"></ng-container>\r\n        </div>\r\n\r\n    </div>\r\n\r\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-next\" aria-label=\"Next Tabs\" (click)=\"next()\" *ngIf=\"offset > bounds.upper\">\r\n        <i class=\"hpe-icon hpe-next\"></i>\r\n    </button>\r\n</div>",
                        providers: [CardTabsService]
                    }] }
        ];
        /** @nocollapse */
        CardTabsetComponent.ctorParameters = function () {
            return [
                { type: CardTabsService }
            ];
        };
        CardTabsetComponent.propDecorators = {
            position: [{ type: core.HostBinding, args: ['class',] }, { type: core.Input }],
            tablist: [{ type: core.ViewChild, args: ['tablist',] }]
        };
        return CardTabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsModule = (function () {
        function CardTabsModule() {
        }
        CardTabsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        declarations: [CardTabsetComponent, CardTabComponent, CardTabContentDirective],
                        exports: [CardTabsetComponent, CardTabComponent, CardTabContentDirective]
                    },] }
        ];
        return CardTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueCheckboxId = 0;
    var CheckboxComponent = (function () {
        function CheckboxComponent() {
            this._checkboxId = "ux-checkbox-" + ++uniqueCheckboxId;
            this.id = this._checkboxId;
            this.tabindex = 0;
            this.clickable = true;
            this.simplified = false;
            this.indeterminateValue = -1;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.indeterminate = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(CheckboxComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // determine if it is in the indeterminate state
                this.indeterminate = this._value === this.indeterminateValue;
                // determine the checked state
                this.ariaChecked = this.indeterminate ? 'mixed' : this._value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._checkboxId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                if (this.value === this.indeterminateValue) {
                    this.value = true;
                    return;
                }
                // toggle the checked state
                this.value = !this.value;
            };
        // Functions required to update ngModel
        /**
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        CheckboxComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-checkbox',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-checkbox\"\n       [class.ux-checkbox-checked]=\"value === true\"\n       [class.ux-checkbox-indeterminate]=\"indeterminate\"\n       [class.ux-checkbox-simplified]=\"simplified\"\n       [class.ux-checkbox-disabled]=\"disabled\"\n       [class.ux-checkbox-focused]=\"focused\">\n\n    <div class=\"ux-checkbox-container\">\n        <input type=\"checkbox\"\n               class=\"ux-checkbox-input\"\n               [id]=\"inputId\"\n               [required]=\"required\"\n               [checked]=\"value\"\n               [attr.value]=\"value\"\n               [disabled]=\"disabled\"\n               [attr.name]=\"name\"\n               [tabindex]=\"tabindex\"\n               [indeterminate]=\"indeterminate\"\n               [attr.aria-label]=\"ariaLabel\"\n               [attr.aria-labelledby]=\"ariaLabelledby\"\n               [attr.aria-checked]=\"ariaChecked\"\n               (focus)=\"focused = true\"\n               (blur)=\"focused = false\"\n               (change)=\"$event.stopPropagation()\"\n               (click)=\"toggle()\">\n    </div>\n\n    <span class=\"ux-checkbox-label\">\n        <ng-content></ng-content>\n    </span>\n</label>\n",
                        providers: [CHECKBOX_VALUE_ACCESSOR]
                    }] }
        ];
        CheckboxComponent.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            required: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            clickable: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            indeterminateValue: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input }]
        };
        return CheckboxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CheckboxModule = (function () {
        function CheckboxModule() {
        }
        CheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [CheckboxComponent],
                        declarations: [CheckboxComponent]
                    },] }
        ];
        return CheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorService = (function () {
        function ColorService() {
            this._colorSet = colorSets.keppel;
            if (this._colorSet.colorClassSet) {
                this.setColors();
            }
            else {
                for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                    this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                }
            }
        }
        /**
         * @return {?}
         */
        ColorService.prototype.setColors = /**
         * @return {?}
         */
            function () {
                this._html = '';
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._html += '<div class="' + this._colorSet.colorClassSet[key] + '-color"></div>';
                }
                this._element = document.createElement('div');
                this._element.className = 'color-chart';
                this._element.innerHTML = this._html;
                document.body.appendChild(this._element);
                this._colors = {};
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._colors[key] = this.getColorValue(this._colorSet.colorClassSet[key]);
                }
                this._element.parentNode.removeChild(this._element);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValueByHex = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                var /** @type {?} */ hex = color.replace('#', '');
                var /** @type {?} */ r = parseInt(hex.substring(0, 2), 16).toString();
                var /** @type {?} */ g = parseInt(hex.substring(2, 4), 16).toString();
                var /** @type {?} */ b = parseInt(hex.substring(4, 6), 16).toString();
                return new ThemeColor(r, g, b, '1');
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValue = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                var /** @type {?} */ target = this._element.querySelector('.' + this._colorSet.colorClassSet[color] + '-color');
                if (!target) {
                    throw new Error('Invalid color');
                }
                var /** @type {?} */ colorValue = window.getComputedStyle(target).backgroundColor;
                var /** @type {?} */ rgba = colorValue.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
                return new ThemeColor(rgba[1], rgba[2], rgba[3], rgba[4]);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColor = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                var /** @type {?} */ themeColor = this._colors[this.resolveColorName(color)];
                if (!themeColor) {
                    throw new Error('Color not found: ' + color);
                }
                return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
            };
        /**
         * @return {?}
         */
        ColorService.prototype.getColorSet = /**
         * @return {?}
         */
            function () {
                return this._colorSet;
            };
        /**
         * @param {?} colorSet
         * @return {?}
         */
        ColorService.prototype.setColorSet = /**
         * @param {?} colorSet
         * @return {?}
         */
            function (colorSet) {
                this._colorSet = colorSet;
                this._colors = {};
                if (this._colorSet.colorClassSet) {
                    this.setColors();
                }
                else {
                    for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                        this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                    }
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ColorService.prototype.resolve = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!value) {
                    return;
                }
                var /** @type {?} */ colorName = this.resolveColorName(value);
                for (var /** @type {?} */ color in this._colors) {
                    if (colorName === color.toLowerCase()) {
                        return this.getColor(colorName).toRgba();
                    }
                }
                return value;
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        ColorService.prototype.resolveColorName = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                if (value === void 0) {
                    value = '';
                }
                return value.replace(/\s+/g, '-').toLowerCase();
            };
        ColorService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ColorService.ctorParameters = function () { return []; };
        return ColorService;
    }());
    var ThemeColor = (function () {
        function ThemeColor(r, g, b, a) {
            this._r = r;
            this._g = g;
            this._b = b;
            this._a = a === undefined ? '1' : a;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ThemeColor.parse = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var /** @type {?} */ r, /** @type {?} */ g, /** @type {?} */ b, /** @type {?} */ a = '1';
                var /** @type {?} */ rgbaPattern = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
                var /** @type {?} */ shortHexPattern = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                var /** @type {?} */ longHexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
                var /** @type {?} */ rgbaMatch = value.match(rgbaPattern);
                var /** @type {?} */ shortHexMatch = value.match(shortHexPattern);
                var /** @type {?} */ longHexMatch = value.match(longHexPattern);
                if (rgbaMatch) {
                    r = rgbaMatch[1];
                    g = rgbaMatch[2];
                    b = rgbaMatch[3];
                    a = rgbaMatch[4] ? rgbaMatch[4] : '1';
                }
                else if (longHexMatch) {
                    r = parseInt(longHexMatch[1], 16).toString();
                    g = parseInt(longHexMatch[2], 16).toString();
                    b = parseInt(longHexMatch[3], 16).toString();
                }
                else if (shortHexMatch) {
                    r = parseInt(shortHexMatch[1] + shortHexMatch[1], 16).toString();
                    g = parseInt(shortHexMatch[2] + shortHexMatch[2], 16).toString();
                    b = parseInt(shortHexMatch[3] + shortHexMatch[3], 16).toString();
                }
                else {
                    throw new Error("Cannot parse color - " + value + " is not a valid color.");
                }
                return new ThemeColor(r, g, b, a);
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toHex = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ red = parseInt(this._r).toString(16);
                var /** @type {?} */ green = parseInt(this._g).toString(16);
                var /** @type {?} */ blue = parseInt(this._b).toString(16);
                if (red.length < 2) {
                    red = '0' + red;
                }
                if (green.length < 2) {
                    green = '0' + green;
                }
                if (blue.length < 2) {
                    blue = '0' + blue;
                }
                return '#' + red + green + blue;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgb = /**
         * @return {?}
         */
            function () {
                return 'rgb(' + this._r + ', ' + this._g + ', ' + this._b + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgba = /**
         * @return {?}
         */
            function () {
                return 'rgba(' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getRed = /**
         * @return {?}
         */
            function () {
                return this._r;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getGreen = /**
         * @return {?}
         */
            function () {
                return this._g;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getBlue = /**
         * @return {?}
         */
            function () {
                return this._b;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getAlpha = /**
         * @return {?}
         */
            function () {
                return this._a;
            };
        /**
         * @param {?} red
         * @return {?}
         */
        ThemeColor.prototype.setRed = /**
         * @param {?} red
         * @return {?}
         */
            function (red) {
                this._r = red;
                return this;
            };
        /**
         * @param {?} green
         * @return {?}
         */
        ThemeColor.prototype.setGreen = /**
         * @param {?} green
         * @return {?}
         */
            function (green) {
                this._g = green;
                return this;
            };
        /**
         * @param {?} blue
         * @return {?}
         */
        ThemeColor.prototype.setBlue = /**
         * @param {?} blue
         * @return {?}
         */
            function (blue) {
                this._b = blue;
                return this;
            };
        /**
         * @param {?} alpha
         * @return {?}
         */
        ThemeColor.prototype.setAlpha = /**
         * @param {?} alpha
         * @return {?}
         */
            function (alpha) {
                this._a = alpha.toString();
                return this;
            };
        return ThemeColor;
    }());
    var /** @type {?} */ colorSets = {
        keppel: {
            colorClassSet: {
                'primary': 'primary',
                'accent': 'accent',
                'secondary': 'secondary',
                'alternate1': 'alternate1',
                'alternate2': 'alternate2',
                'alternate3': 'alternate3',
                'vibrant1': 'vibrant1',
                'vibrant2': 'vibrant2',
                'grey1': 'grey1',
                'grey2': 'grey2',
                'grey3': 'grey3',
                'grey4': 'grey4',
                'grey5': 'grey5',
                'grey6': 'grey6',
                'grey7': 'grey7',
                'grey8': 'grey8',
                'chart1': 'chart1',
                'chart2': 'chart2',
                'chart3': 'chart3',
                'chart4': 'chart4',
                'chart5': 'chart5',
                'chart6': 'chart6',
                'ok': 'ok',
                'warning': 'warning',
                'critical': 'critical',
                'partition1': 'partition1',
                'partition9': 'partition9',
                'partition10': 'partition10',
                'partition11': 'partition11',
                'partition12': 'partition12',
                'partition13': 'partition13',
                'partition14': 'partition14',
                'social-chart-node': 'social-chart-node',
                'social-chart-edge': 'social-chart-edge'
            }
        },
        microFocus: {
            'colorValueSet': {
                'cerulean': '#1668c1',
                'aqua': '#29ceff',
                'aquamarine': '#2fd6c3',
                'fuchsia': '#c6179d',
                'indigo': '#7425ad',
                'dark-blue': '#231ca5',
                'white': '#ffffff',
                'slightly-gray': '#f5f7f8',
                'bright-gray': '#f1f2f3',
                'gray': '#dcdedf',
                'silver': '#bdbec0',
                'dim-gray': '#656668',
                'dark-gray': '#323435',
                'black': '#000000',
                'crimson-negative': '#e5004c',
                'apricot': '#f48b34',
                'yellow': '#fcdb1f',
                'green-positive': '#1aac60',
                'ultramarine': '#3939c6',
                'skyblue': '#00abf3',
                'pale-aqua': '#43e4ff',
                'pale-green': '#1ffbba',
                'lime': '#75da4d',
                'orange': '#ffce00',
                'magenta': '#eb23c2',
                'pale-purple': '#ba47e2',
                'dark-ultramarine': '#271782',
                'steelblue': '#014272',
                'arctic-blue': '#0b8eac',
                'emerald': '#00a989',
                'olive': '#5bba36',
                'goldenrod': '#ffb000',
                'purple': '#9b1e83',
                'pale-eggplant': '#5216ac',
                'red': '#ff454f',
                'pale-amber': '#ffb24d',
                'pale-lemon': '#fde159',
                'pale-emerald': '#33c180',
                'plum': '#b21646',
                'copper': '#e57828',
                'amber': '#ffc002',
                'leaf-green': '#118c4f',
                'forest-green': '#00645a',
                'primary': '#0073e7',
                'accent': '#7425ad',
                'secondary': '#ffffff',
                'alternate1': '#29ceff',
                'alternate2': '#2fd6c3',
                'alternate3': '#c6179d',
                'vibrant1': '#43e4ff',
                'vibrant2': '#ffce00',
                'grey1': '#000000',
                'grey2': '#323435',
                'grey3': '#656668',
                'grey4': '#bdbec0',
                'grey5': '#dcdedf',
                'grey6': '#f1f2f3',
                'grey7': '#f5f7f8',
                'grey8': '#ffffff',
                'chart1': '#3939c6',
                'chart2': '#00abf3',
                'chart3': '#75da4d',
                'chart4': '#ffce00',
                'chart5': '#eb23c2',
                'chart6': '#ba47e2',
                'ok': '#1aac60',
                'warning': '#f48b34',
                'critical': 'e5004c',
                'partition1': '#7425ad',
                'partition9': '#5216ac',
                'partition10': '#5bba36',
                'partition11': '#014272',
                'partition12': '#ffb000',
                'partition13': '#bdbec0',
                'partition14': '#271782',
                'social-chart-node': '#ff00ff',
                'social-chart-edge': '#ff00ff'
            }
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    // Values corresponding to stylesheet
    var /** @type {?} */ BUTTON_MARGIN = 8;
    var /** @type {?} */ BUTTON_WIDTHS = {
        'sm': 26,
        'md': 32,
        'lg': 40
    };
    var /** @type {?} */ uniqueId$1 = 0;
    var ColorPickerComponent = (function () {
        function ColorPickerComponent() {
            this.id = "ux-color-picker-" + uniqueId$1++;
            this.buttonStyle = 'circle';
            this.showTooltips = false;
            this.showInput = false;
            this.inputMode = 'hex';
            this.selectedChange = new core.EventEmitter();
            this.inputSubmit = new core.EventEmitter();
            this.cssWidth = 'auto';
            this.colors = [];
            this.selected$ = new BehaviorSubject.BehaviorSubject(null);
            this.columns$ = new BehaviorSubject.BehaviorSubject(-1);
            this.buttonSize$ = new BehaviorSubject.BehaviorSubject('md');
            this.inputPatterns = {
                'hex': /^#(?:[\da-fA-F]{3}){1,2}$/,
                'rgba': /^(?:rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))|(?:rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*\d(\.\d+)?\))$/
            };
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(ColorPickerComponent.prototype, "inputColors", {
            set: /**
             * @param {?} colors
             * @return {?}
             */ function (colors) {
                var /** @type {?} */ normalizedColors;
                // If it's a 1d array, convert it to 2d
                if (colors.length === 0 || !Array.isArray(colors[0])) {
                    normalizedColors = [/** @type {?} */ (colors)];
                }
                else {
                    normalizedColors = /** @type {?} */ (colors);
                }
                // Convert any string colors to ColorPickerColor
                this.colors = normalizedColors.map(function (row) {
                    return row.map(function (color) { return color instanceof ColorPickerColor ? color : new ColorPickerColor(color, color); });
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "selected", {
            set: /**
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                this.selected$.next(selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "columns", {
            set: /**
             * @param {?} columns
             * @return {?}
             */ function (columns) {
                this.columns$.next(columns);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "buttonSize", {
            set: /**
             * @param {?} buttonSize
             * @return {?}
             */ function (buttonSize) {
                this.buttonSize$.next(buttonSize);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Skip emitting the initial selectedChange
                this.selected$.pipe(operators.pairwise(), operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                    var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                    if (prev) {
                        _this.selectedChange.emit(curr);
                    }
                });
                // Set the width based on column count and button size
                combineLatest.combineLatest(this.columns$, this.buttonSize$)
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (_a) {
                    var _b = __read(_a, 2), columns = _b[0], buttonSize = _b[1];
                    if (columns > 0) {
                        var /** @type {?} */ w = columns * (BUTTON_WIDTHS[buttonSize] + (2 * BUTTON_MARGIN));
                        _this.cssWidth = w + "px";
                    }
                    else {
                        _this.cssWidth = 'auto';
                    }
                });
            };
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} input
         * @param {?} mode
         * @return {?}
         */
        ColorPickerComponent.prototype.updateColorValue = /**
         * @param {?} input
         * @param {?} mode
         * @return {?}
         */
            function (input, mode) {
                if (this.inputPatterns[mode].test(input)) {
                    this.selected$.next(new ColorPickerColor('Custom', input, mode));
                }
            };
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.toggleColorEntryType = /**
         * @return {?}
         */
            function () {
                this.inputMode = (this.inputMode === 'hex') ? 'rgba' : 'hex';
            };
        ColorPickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-color-picker',
                        exportAs: 'ux-color-picker',
                        template: "<div class=\"ux-color-picker\" uxTabbableList direction=\"horizontal\">\n    <div class=\"ux-color-picker-swatch\">\n        <div *ngFor=\"let row of colors\" class=\"ux-color-picker-swatch-row\">\n            <div *ngFor=\"let color of row\"\n                class=\"ux-color-picker-color\"\n                [class.ux-small]=\"(buttonSize$ | async) === 'sm'\"\n                [class.ux-large]=\"(buttonSize$ | async) === 'lg'\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\"\n                [class.ux-selected]=\"color === (selected$ | async)\">\n                <button type=\"button\"\n                    attr.aria-label=\"Select color {{color.name}}\" i18n-aria-label\n                    aria-selected=\"color === (selected$ | async)\"\n                    class=\"btn btn-icon\"\n                    [style.background-color]=\"color.rgba\"\n                    (click)=\"selected$.next(color)\"\n                    uxTabbableListItem\n                    [uxTooltip]=\"color.name\"\n                    [tooltipDisabled]=\"!showTooltips\"></button>\n            </div>\n        </div>\n    </div>\n    <div *ngIf=\"showInput\" class=\"ux-color-picker-input-panel\">\n        <div class=\"ux-color-picker-input-header\">\n            <div class=\"ux-color-picker-preview\"\n                [style.background-color]=\"(selected$ | async).rgba\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\"></div>\n            <label *ngIf=\"inputMode === 'hex'\" attr.for=\"{{id}}-input-field\">HEX</label>\n            <label *ngIf=\"inputMode === 'rgba'\" attr.for=\"{{id}}-input-field\">RGBA</label>\n            <button type=\"button\"\n                attr.aria-label=\"Switch input mode to {{inputMode === 'hex' ? 'RGBA' : 'hex'}}\" i18n-aria-label\n                class=\"btn btn-link btn-icon button-secondary ux-color-picker-input-toggle\"\n                (click)=\"toggleColorEntryType(); $event.stopPropagation()\">\n                <span class=\"hpe-icon hpe-chevron-right\"></span>\n            </button>\n        </div>\n        <div class=\"ux-color-picker-input\"\n            [class.has-error]=\"inputField.errors\"\n            [class.has-feedback]=\"inputField.errors\">\n            <input type=\"text\"\n                attr.id=\"{{id}}-input-field\"\n                attr.aria-description=\"Edit {{inputMode}} color value\" i18n-aria-description\n                class=\"form-control\"\n                #inputField=\"ngModel\"\n                [ngModel]=\"(selected$ | async)[inputMode]\"\n                (ngModelChange)=\"updateColorValue($event, inputMode)\"\n                [pattern]=\"inputPatterns[inputMode].source\"\n                (keyup.enter)=\"inputSubmit.emit()\">\n            <span class=\"hpe-icon hpe-alert form-control-feedback\"></span>\n        </div>\n    </div>\n</div>\n"
                    }] }
        ];
        ColorPickerComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            inputColors: [{ type: core.Input, args: ['colors',] }],
            selected: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            buttonStyle: [{ type: core.Input }],
            buttonSize: [{ type: core.Input }],
            showTooltips: [{ type: core.Input }],
            showInput: [{ type: core.Input }],
            inputMode: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            inputSubmit: [{ type: core.Output }],
            cssWidth: [{ type: core.HostBinding, args: ['style.width',] }]
        };
        return ColorPickerComponent;
    }());
    /**
     * Type representing a color, including its descriptive name.
     */
    var /**
     * Type representing a color, including its descriptive name.
     */ ColorPickerColor = (function () {
        function ColorPickerColor(name, value, inputMode) {
            this.name = name;
            this._color = ThemeColor.parse(value);
            // Preserve the format entered by the user if it's valid
            if (inputMode === 'hex') {
                this._originalHexValue = value;
            }
            else if (inputMode === 'rgba') {
                this._originalRgbaValue = value;
            }
        }
        Object.defineProperty(ColorPickerColor.prototype, "hex", {
            /**
             * Hex value of the color, e.g. `#ffffff`.
             */
            get: /**
             * Hex value of the color, e.g. `#ffffff`.
             * @return {?}
             */ function () {
                return this._originalHexValue ? this._originalHexValue : this._color.toHex();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "rgba", {
            /**
             * RGBA value of the color, e.g. `rgba(255, 255, 255, 1)`.
             */
            get: /**
             * RGBA value of the color, e.g. `rgba(255, 255, 255, 1)`.
             * @return {?}
             */ function () {
                return this._originalRgbaValue ? this._originalRgbaValue : this._color.toRgba();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "r", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getRed());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "g", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getGreen());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "b", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getBlue());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "a", {
            get: /**
             * @return {?}
             */ function () {
                return parseFloat(this._color.getAlpha());
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColorPickerColor.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this._color.toRgba();
            };
        return ColorPickerColor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusWithinDirective = (function () {
        function FocusWithinDirective(_elementRef, _focusMonitor, ngZone) {
            var _this = this;
            this._elementRef = _elementRef;
            this._focusMonitor = _focusMonitor;
            this.uxFocusWithin = new core.EventEmitter();
            this.uxBlurWithin = new core.EventEmitter();
            _focusMonitor.monitor(this._elementRef.nativeElement, true)
                .subscribe(function (origin) { return ngZone.run(function () { return origin ? _this.uxFocusWithin.emit() : _this.uxBlurWithin.emit(); }); });
        }
        /**
         * @return {?}
         */
        FocusWithinDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);
            };
        FocusWithinDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFocusWithin],[uxBlurWithin]',
                    },] }
        ];
        /** @nocollapse */
        FocusWithinDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: a11y.FocusMonitor },
                { type: core.NgZone }
            ];
        };
        FocusWithinDirective.propDecorators = {
            uxFocusWithin: [{ type: core.Output }],
            uxBlurWithin: [{ type: core.Output }]
        };
        return FocusWithinDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SplitterAccessibilityDirective = (function () {
        function SplitterAccessibilityDirective(_elementRef, _renderer, _platform, _splitter) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._platform = _platform;
            this._splitter = _splitter;
            /**
             * Emit an event whenever the gutter is moved using the keyboard
             */
            this.gutterKeydown = new core.EventEmitter();
            /**
             * Store all the gutter elements
             */
            this._gutters = [];
            /**
             * Teardown our observables on destroy
             */
            this._onDestroy = new Subject.Subject();
            // update aria values when the a gutter is dragged
            _splitter.dragProgress
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.updateGutterAttributes(); });
        }
        /** Once initialised make the gutters accessible */
        /**
         * Once initialised make the gutters accessible
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.ngAfterViewInit = /**
         * Once initialised make the gutters accessible
         * @return {?}
         */
            function () {
                var _this = this;
                // find the gutters
                this.onGutterChange();
                // if the number of split areas change then update the gutters and apply aria properties
                this.areas.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.onGutterChange(); });
                // we can't know when additional split-gutters appear using ContentChildren as the directive class is not exported and selector doesn't work - use mutation observer instead
                if (common.isPlatformBrowser(this._platform)) {
                    // create the mutation observer
                    this._observer = new MutationObserver(function () { return _this.onGutterChange(); });
                    // begin observing the child nodes
                    this._observer.observe(this._elementRef.nativeElement, { childList: true });
                }
            };
        /** Destroy all observables and observers */
        /**
         * Destroy all observables and observers
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.ngOnDestroy = /**
         * Destroy all observables and observers
         * @return {?}
         */
            function () {
                if (this._observer) {
                    this._observer.disconnect();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** We should focus the gutter when it is clicked */
        /**
         * We should focus the gutter when it is clicked
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onClick = /**
         * We should focus the gutter when it is clicked
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    ((event.target)).focus();
                }
            };
        /**
         * Find all the gutters and set their attributes
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onGutterChange = /**
         * Find all the gutters and set their attributes
         * @return {?}
         */
            function () {
                this._gutters = this.getGutters();
                this.setGutterAttributes();
            };
        /**
         * Get all the gutter elements
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.getGutters = /**
         * Get all the gutter elements
         * @return {?}
         */
            function () {
                // This function uses DOM accessing properties - which won't work if server side rendered
                if (common.isPlatformBrowser(this._platform)) {
                    var /** @type {?} */ gutters = [];
                    for (var /** @type {?} */ idx = 0; idx < this._elementRef.nativeElement.children.length; idx++) {
                        var /** @type {?} */ node = this._elementRef.nativeElement.children.item(idx);
                        if (this.isSplitterGutter(/** @type {?} */ (node))) {
                            gutters.push(/** @type {?} */ (node));
                        }
                    }
                    return gutters;
                }
                return [];
            };
        /**
         * Set the appropriate attributes on the gutter elements
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterAttributes = /**
         * Set the appropriate attributes on the gutter elements
         * @return {?}
         */
            function () {
                var _this = this;
                // apply attribute to every gutter
                this._gutters.forEach(function (gutter) {
                    // apply the separator role
                    // apply the separator role
                    _this._renderer.setAttribute(gutter, 'role', 'separator');
                    // make the gutters tabbable
                    // make the gutters tabbable
                    _this._renderer.setAttribute(gutter, 'tabindex', '0');
                    // set the value now aria property
                    // set the value now aria property
                    _this.updateGutterAttributes();
                });
            };
        /**
         * Apply the aria attribute values
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.updateGutterAttributes = /**
         * Apply the aria attribute values
         * @return {?}
         */
            function () {
                var _this = this;
                // update the value now properties of each gutter
                this._gutters.forEach(function (gutter, idx) {
                    _this.setGutterValueNow(gutter, idx);
                    _this.setGutterValueMin(gutter, idx);
                    _this.setGutterValueMax(gutter, idx);
                });
            };
        /**
         * Apply the value now aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueNow = /**
         * Apply the value now aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get the matching split area
                var /** @type {?} */ area = this._splitter.displayedAreas[index];
                // indicate the size
                this._renderer.setAttribute(gutter, 'aria-valuenow', "" + Math.round(area.size * 100));
            };
        /**
         * Apply the value min aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueMin = /**
         * Apply the value min aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get the matching split area
                var /** @type {?} */ area = this.areas.toArray()[index];
                // indicate the minimum size
                this._renderer.setAttribute(gutter, 'aria-valuemin', "" + Math.round(area.minSize * 100));
            };
        /**
         * Apply the value max aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueMax = /**
         * Apply the value max aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get every other splitter area
                var /** @type {?} */ availableSize = this.areas
                    .filter(function (_area, idx) { return index !== idx; })
                    .reduce(function (total, area) { return total + area.minSize; }, 0);
                // indicate the minimum size
                this._renderer.setAttribute(gutter, 'aria-valuemax', "" + (100 - Math.round(availableSize * 100)));
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    this.gutterKeydown.emit(event);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onIncreaseKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // only perform a move if a gutter is focused
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    this.setGutterPosition(/** @type {?} */ (event.target), -0.01);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onDecreaseKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // only perform a move if a gutter is focused
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    this.setGutterPosition(/** @type {?} */ (event.target), 0.01);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onHomeKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    // get the affected panels
                    var /** @type {?} */ areas = this.getAreasFromGutter(/** @type {?} */ (event.target));
                    // set the previous area to it's minimum size
                    var /** @type {?} */ delta = areas.previous.size - areas.previous.comp.minSize;
                    // update the sizes accordingly
                    this.setGutterPosition(/** @type {?} */ (event.target), delta);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onEndKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    // get the affected panels
                    var /** @type {?} */ areas = this.getAreasFromGutter(/** @type {?} */ (event.target));
                    // set the next area to it's minimum size
                    var /** @type {?} */ delta = areas.next.size - areas.next.comp.minSize;
                    // update the sizes accordingly
                    this.setGutterPosition(/** @type {?} */ (event.target), -delta);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * Determine if an element is a gutter
         * @param {?} element
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.isSplitterGutter = /**
         * Determine if an element is a gutter
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.tagName === 'SPLIT-GUTTER';
            };
        /**
         * Update the gutter position
         * @param {?} gutter
         * @param {?} delta
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterPosition = /**
         * Update the gutter position
         * @param {?} gutter
         * @param {?} delta
         * @return {?}
         */
            function (gutter, delta) {
                // get the affected panels
                var /** @type {?} */ areas = this.getAreasFromGutter(gutter);
                // ensure we can perform the resize
                if (areas.previous.size - delta < areas.previous.comp.minSize || areas.next.size + delta < areas.next.comp.minSize) {
                    return;
                }
                // perform the resize
                areas.previous.size -= delta;
                areas.next.size += delta;
                // update the splitter - this is a private method but we need to call it
                ((this._splitter)).refreshStyleSizes();
                // update the gutter aria values
                this.updateGutterAttributes();
            };
        /**
         * Get the split areas associated with a given gutter
         * @param {?} gutter
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.getAreasFromGutter = /**
         * Get the split areas associated with a given gutter
         * @param {?} gutter
         * @return {?}
         */
            function (gutter) {
                var /** @type {?} */ index = this._gutters.indexOf(gutter);
                return {
                    previous: this._splitter.displayedAreas[index],
                    next: this._splitter.displayedAreas[index + 1]
                };
            };
        SplitterAccessibilityDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'split'
                    },] }
        ];
        /** @nocollapse */
        SplitterAccessibilityDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: String, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
                { type: angularSplit.SplitComponent }
            ];
        };
        SplitterAccessibilityDirective.propDecorators = {
            gutterKeydown: [{ type: core.Output }],
            areas: [{ type: core.ContentChildren, args: [angularSplit.SplitAreaDirective,] }],
            onClick: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            onIncreaseKey: [{ type: core.HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: core.HostListener, args: ['keydown.ArrowRight', ['$event'],] }],
            onDecreaseKey: [{ type: core.HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: core.HostListener, args: ['keydown.ArrowLeft', ['$event'],] }],
            onHomeKey: [{ type: core.HostListener, args: ['keydown.Home', ['$event'],] }],
            onEndKey: [{ type: core.HostListener, args: ['keydown.End', ['$event'],] }]
        };
        return SplitterAccessibilityDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This is a simple RxJS operator to allow us to avoid the
     * "expression has changed after it was checked issue"
     * by making the subscription asynchronous. We could just use a
     * delay operator but this uses a timeout which is significantly
     * slower than using requestAnimationFrame.
     */
    var /** @type {?} */ tick = function () {
        return function (source) {
            return new Observable.Observable(function (subscriber) {
                source.subscribe({
                    next: /**
                     * @param {?} value
                     * @return {?}
                     */ function (value) { requestAnimationFrame(function () { return subscriber.next(value); }); },
                    error: /**
                     * @param {?} err
                     * @return {?}
                     */ function (err) { subscriber.error(err); },
                    complete: /**
                     * @return {?}
                     */ function () { subscriber.complete(); },
                });
            });
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabbableListService = (function () {
        function TabbableListService() {
            this.hierarchy = false;
            this.allowAltModifier = true;
            this.allowCtrlModifier = true;
            this.allowBoundaryKeys = false;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        TabbableListService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} items
         * @param {?} direction
         * @param {?} wrap
         * @return {?}
         */
        TabbableListService.prototype.initialize = /**
         * @param {?} items
         * @param {?} direction
         * @param {?} wrap
         * @return {?}
         */
            function (items, direction, wrap) {
                var _this = this;
                // store the items
                this._items = items;
                // create the new focus key manager
                this.focusKeyManager = new a11y.FocusKeyManager(items);
                // set the direction of the list
                direction === 'vertical' ? this.focusKeyManager.withVerticalOrientation() : this.focusKeyManager.withHorizontalOrientation('ltr');
                this._direction = direction;
                // enable wrapping if required
                if (wrap) {
                    this.focusKeyManager.withWrap();
                }
                // make sure the first item in the list is tabbable
                this.setFirstItemTabbable();
                // call the init function on each item
                this._items.forEach(function (item) { return item.onInit(); });
                // if the list changes we need to ensure there is always at least one tabbable item
                this._items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    // call the on init function on any new items
                    // call the on init function on any new items
                    _this._items.filter(function (item) { return !item.initialized; }).forEach(function (item) { return item.onInit(); });
                    // ensure there is at least one item tabbable at all times
                    // ensure there is at least one item tabbable at all times
                    _this.ensureTabbableItem();
                });
            };
        /**
         * @param {?} item
         * @return {?}
         */
        TabbableListService.prototype.activate = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (!item) {
                    return;
                }
                // get the item index
                var /** @type {?} */ index = this._items.toArray().indexOf(item);
                // active the item if it is not already active
                if (this.focusKeyManager.activeItemIndex !== index) {
                    this.focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        TabbableListService.prototype.isItemActive = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.focusKeyManager.activeItem.id === item.id;
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.setFirstItemTabbable = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // delay to prevent expression changed after check error
                requestAnimationFrame(function () {
                    // find the first item that is not disabled
                    var /** @type {?} */ first = _this._items.find(function (item) { return !item.disabled; });
                    if (first) {
                        first.tabindex = 0;
                    }
                });
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.ensureTabbableItem = /**
         * @return {?}
         */
            function () {
                // check to see if any item is tabbable
                var /** @type {?} */ active = this._items.find(function (item) { return item.tabindex === 0; });
                if (!active) {
                    this.setFirstItemTabbable();
                }
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.focusTabbableItem = /**
         * @return {?}
         */
            function () {
                if (!this._items) {
                    return;
                }
                // find the item in the list with a tab index
                var /** @type {?} */ index = this._items.toArray().findIndex(function (item) { return item.tabindex === 0; });
                // if an item was found then focus it
                if (index !== -1) {
                    this.focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} source
         * @param {?} event
         * @return {?}
         */
        TabbableListService.prototype.onKeydown = /**
         * @param {?} source
         * @param {?} event
         * @return {?}
         */
            function (source, event) {
                // prevent anything happening when modifier keys are pressed if they have been disabled
                if (!this.allowAltModifier && event.altKey || !this.allowCtrlModifier && event.ctrlKey) {
                    return;
                }
                this.focusKeyManager.onKeydown(event);
                // if the key is a boundary key and boundary keys are enabled
                if (this.allowBoundaryKeys) {
                    switch (event.which) {
                        case keycodes.HOME:
                            this.focusKeyManager.setFirstItemActive();
                            event.preventDefault();
                            break;
                        case keycodes.END:
                            this.focusKeyManager.setLastItemActive();
                            event.preventDefault();
                            break;
                    }
                }
                if (this.hierarchy) {
                    if ((this._direction === 'horizontal' && event.keyCode === keycodes.DOWN_ARROW) ||
                        (this._direction === 'vertical' && event.keyCode === keycodes.RIGHT_ARROW)) {
                        source.keyboardExpanded$.next(true);
                    }
                    else if ((this._direction === 'horizontal' && event.keyCode === keycodes.UP_ARROW) ||
                        (this._direction === 'vertical' && event.keyCode === keycodes.LEFT_ARROW)) {
                        if (source.children.length > 0 && source.expanded) {
                            source.keyboardExpanded$.next(false);
                        }
                        else if (source.parent) {
                            source.parent.keyboardExpanded$.next(false);
                        }
                    }
                }
            };
        /**
         * @param {?} list
         * @return {?}
         */
        TabbableListService.prototype.sortItemsByHierarchy = /**
         * @param {?} list
         * @return {?}
         */
            function (list) {
                var /** @type {?} */ topLevel = [];
                // Populating children - clear previously generated collection
                list.forEach(function (item) { return item.children = []; });
                // Populating children - map from child -> parent relationship
                list.forEach(function (item) {
                    if (item.parent) {
                        item.parent.children.push(item);
                    }
                    else {
                        topLevel.push(item);
                    }
                });
                // Flatten the tree to produce the cursor key order
                return this.flattenHierarchy(topLevel);
            };
        /**
         * @param {?} items
         * @return {?}
         */
        TabbableListService.prototype.flattenHierarchy = /**
         * @param {?} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                var /** @type {?} */ flatList = [];
                items.forEach(function (item) {
                    item.children.sort(function (a, b) { return a.rank - b.rank; });
                    flatList.push.apply(flatList, __spread([item], _this.flattenHierarchy(item.children)));
                });
                return flatList;
            };
        TabbableListService.decorators = [
            { type: core.Injectable }
        ];
        return TabbableListService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ nextId = 0;
    var TabbableListItemDirective = (function () {
        function TabbableListItemDirective(_tabbableList, _elementRef, focusMonitor) {
            var _this = this;
            this._tabbableList = _tabbableList;
            this._elementRef = _elementRef;
            this.rank = 0;
            this.disabled = false;
            this.expanded = false;
            this.expandedChange = new core.EventEmitter();
            this.tabindex = -1;
            this.id = nextId++;
            this.initialized = false;
            this.children = [];
            this.keyboardExpanded$ = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
            this.keyboardExpanded$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                // Emit event which may alter the DOM
                // Emit event which may alter the DOM
                _this.expandedChange.emit(expanded);
                // Activate the appropriate item
                if (expanded) {
                    if (_this.children.length > 0) {
                        _this._tabbableList.activate(_this.children[0]);
                    }
                }
                else {
                    _this._tabbableList.activate(_this);
                }
            });
            // add classes to indicate the origin of the focus event
            focusMonitor.monitor(_elementRef.nativeElement, false).pipe(operators.takeUntil(this._onDestroy)).subscribe();
        }
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.onInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.initialized = true;
                this._tabbableList.focusKeyManager.change
                    .pipe(operators.takeUntil(this._onDestroy), operators.map(function () { return _this._tabbableList.isItemActive(_this); }))
                    .subscribe(function (active) { return _this.tabindex = active ? 0 : -1; });
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // check if this is the currently focused item - if so we need to make another item tabbable
                if (this.tabindex === 0) {
                    this._tabbableList.setFirstItemTabbable();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                // apply focus to the element
                this._elementRef.nativeElement.focus();
                // ensure the focus key manager updates the active item correctly
                this._tabbableList.activate(this);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabbableListItemDirective.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._tabbableList.onKeydown(this, event);
            };
        TabbableListItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabbableListItem]',
                        exportAs: 'ux-tabbable-list-item'
                    },] }
        ];
        /** @nocollapse */
        TabbableListItemDirective.ctorParameters = function () {
            return [
                { type: TabbableListService },
                { type: core.ElementRef },
                { type: a11y.FocusMonitor }
            ];
        };
        TabbableListItemDirective.propDecorators = {
            parent: [{ type: core.Input }],
            rank: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }],
            tabindex: [{ type: core.HostBinding }],
            focus: [{ type: core.HostListener, args: ['focus',] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return TabbableListItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabbableListDirective = (function () {
        function TabbableListDirective(_tabbableList) {
            this._tabbableList = _tabbableList;
            /**
             * Determine whether the up/down arrows should be used or the left/right arrows
             */
            this.direction = 'vertical';
            /**
             * Indicate whether or not focus should loop back to the first element after the last
             */
            this.wrap = true;
            /**
             * Indicate whether or not the first item should receive focus on show - useful for modals and popovers
             */
            this.focusOnShow = false;
            /**
             * Indicate whether or not focus should be returned to the previous element (only applicable when using focusOnShow)
             */
            this.returnFocus = false;
        }
        Object.defineProperty(TabbableListDirective.prototype, "hierarchy", {
            /** Enabling handling of hierarchical lists via use of the `TabbableListItemDirective.parent` property. */
            set: /**
             * Enabling handling of hierarchical lists via use of the `TabbableListItemDirective.parent` property.
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.hierarchy = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowAltModifier", {
            /** Prevent keyboard interaction when alt modifier key is pressed */
            set: /**
             * Prevent keyboard interaction when alt modifier key is pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowAltModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowCtrlModifier", {
            /** Prevent keyboard interaction when ctrl modifier key is pressed */
            set: /**
             * Prevent keyboard interaction when ctrl modifier key is pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowCtrlModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowBoundaryKeys", {
            /** Focus the first or last item when Home or End keys are pressed */
            set: /**
             * Focus the first or last item when Home or End keys are pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowBoundaryKeys = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "focusKeyManager", {
            get: /**
             * @return {?}
             */ function () {
                return this._tabbableList.focusKeyManager;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // store the currently focused element
                this._focusedElement = /** @type {?} */ (document.activeElement);
                if (this._tabbableList.hierarchy) {
                    // Sort items in a hierarchy
                    this._orderedItems = new core.QueryList();
                    this._orderedItems.reset(this._tabbableList.sortItemsByHierarchy(this.items));
                    // Ensure that the child items remain sorted
                    this.items.changes.subscribe(function () {
                        _this._orderedItems.reset(_this._tabbableList.sortItemsByHierarchy(_this.items));
                        _this._orderedItems.notifyOnChanges();
                    });
                }
                else {
                    // Items are already in order
                    this._orderedItems = this.items;
                }
                // Set up the focus monitoring
                this._tabbableList.initialize(this._orderedItems, this.direction, this.wrap);
                // focus the first element if specified
                if (this.focusOnShow) {
                    this._tabbableList.focusKeyManager.setFirstItemActive();
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.returnFocus && this._focusedElement instanceof HTMLElement) {
                    setTimeout(function () { return _this._focusedElement.focus(); });
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (this._tabbableList.focusKeyManager && this._tabbableList.focusKeyManager.activeItem) {
                    this._tabbableList.focusKeyManager.activeItem.focus();
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.focusTabbableItem = /**
         * @return {?}
         */
            function () {
                this._tabbableList.focusTabbableItem();
            };
        TabbableListDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabbableList]',
                        exportAs: 'ux-tabbable-list',
                        providers: [TabbableListService]
                    },] }
        ];
        /** @nocollapse */
        TabbableListDirective.ctorParameters = function () {
            return [
                { type: TabbableListService }
            ];
        };
        TabbableListDirective.propDecorators = {
            direction: [{ type: core.Input }],
            wrap: [{ type: core.Input }],
            focusOnShow: [{ type: core.Input }],
            returnFocus: [{ type: core.Input }],
            hierarchy: [{ type: core.Input }],
            allowAltModifier: [{ type: core.Input }],
            allowCtrlModifier: [{ type: core.Input }],
            allowBoundaryKeys: [{ type: core.Input }],
            items: [{ type: core.ContentChildren, args: [TabbableListItemDirective, { descendants: true },] }]
        };
        return TabbableListDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccessibilityModule = (function () {
        function AccessibilityModule() {
        }
        AccessibilityModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            FocusWithinDirective,
                            TabbableListDirective,
                            TabbableListItemDirective,
                            SplitterAccessibilityDirective
                        ],
                        imports: [
                            a11y.A11yModule
                        ],
                        exports: [
                            FocusWithinDirective,
                            TabbableListDirective,
                            TabbableListItemDirective,
                            SplitterAccessibilityDirective,
                        ]
                    },] }
        ];
        return AccessibilityModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ NUMBER_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return NumberPickerComponent; }),
        multi: true
    };
    var NumberPickerComponent = (function () {
        function NumberPickerComponent() {
            this._min = -Infinity;
            this._max = Infinity;
            this._step = 1;
            this._disabled = false;
            this._value = 0;
            this._propagateChange = function (_) { };
            this.valid = true;
            this.valueChange = new core.EventEmitter();
        }
        Object.defineProperty(NumberPickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.valueChange.emit(value);
                this._propagateChange(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "min", {
            get: /**
             * @return {?}
             */ function () {
                return this._min;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._min = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "max", {
            get: /**
             * @return {?}
             */ function () {
                return this._max;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._max = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._step = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = typeof value === 'string' && (value === '' || value === 'true' || value === 'disabled') || value === true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.increment = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.max(Math.min(this.value + this.step, this.max), this.min);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.decrement = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.min(Math.max(this.value - this.step, this.min), this.max);
                }
            };
        /**
         * @return {?}
         */
        NumberPickerComponent.prototype.isValid = /**
         * @return {?}
         */
            function () {
                if (this.value < this.min || this.value > this.max) {
                    return false;
                }
                return this.valid;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.onScroll = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ scrollValue = event.deltaY || event.wheelDelta;
                if (scrollValue < 0) {
                    this.increment(event);
                }
                else {
                    this.decrement(event);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NumberPickerComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== undefined) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NumberPickerComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        NumberPickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-number-picker',
                        template: "<input type=\"number\"\n       role=\"spinbutton\"\n       class=\"form-control number-picker-input\"\n       [(ngModel)]=\"value\"\n       [min]=\"min\"\n       [max]=\"max\"\n       (keydown.ArrowDown)=\"decrement($event)\"\n       (keydown.ArrowUp)=\"increment($event)\"\n       (wheel)=\"onScroll($event)\"\n       step=\"any\"\n       [disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\">\n\n<div class=\"number-picker-controls\">\n\n    <div class=\"number-picker-control-up\"\n         (click)=\"increment($event)\"\n         [class.disabled]=\"disabled || value >= max\">\n\n        <span class=\"hpe-icon hpe-up\"></span>\n    </div>\n\n    <div class=\"number-picker-control-down\"\n         (click)=\"decrement($event)\"\n         [class.disabled]=\"disabled || value <= min\">\n\n        <span class=\"hpe-icon hpe-down\"></span>\n    </div>\n\n</div>",
                        providers: [NUMBER_PICKER_VALUE_ACCESSOR],
                        host: {
                            '[class.has-error]': '!isValid()'
                        }
                    }] }
        ];
        NumberPickerComponent.propDecorators = {
            valid: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input, args: ['value',] }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            step: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return NumberPickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NumberPickerModule = (function () {
        function NumberPickerModule() {
        }
        NumberPickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [NumberPickerComponent],
                        declarations: [NumberPickerComponent]
                    },] }
        ];
        return NumberPickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTooltipId = 0;
    var TooltipComponent = (function () {
        function TooltipComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Define a unique id for each tooltip
             */
            this.id = "ux-tooltip-" + ++uniqueTooltipId;
            /**
             * Define the tooltip role
             */
            this.role = 'tooltip';
            /**
             * Allow a custom class to be added to the tooltip to allow custom styling
             */
            this.customClass = '';
            /**
             * Indicates whether or not the content is a string or a TemplateRef
             */
            this.isTemplateRef = false;
            /**
             * Emit when the tooltip need to update it's position
             */
            this.reposition$ = new Subject.Subject();
        }
        /** Cleanup after the component is destroyed */
        /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
        TooltipComponent.prototype.ngOnDestroy = /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
            function () {
                this.reposition$.complete();
            };
        /** Inform the parent directive that it needs to recalulate the position */
        /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
        TooltipComponent.prototype.reposition = /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
            function () {
                this.reposition$.next();
            };
        /** This will update the content of the tooltip and trigger change detection */
        /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
        TooltipComponent.prototype.setContent = /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
            function (content) {
                this.content = content;
                this.isTemplateRef = content instanceof core.TemplateRef;
                this._changeDetectorRef.markForCheck();
            };
        /** This will update the tooltip placement and trigger change detection */
        /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
        TooltipComponent.prototype.setPlacement = /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
            function (placement) {
                if (!placement) {
                    return;
                }
                this.placement = placement;
                this._changeDetectorRef.markForCheck();
            };
        /** This will set a custom class on the tooltip and trigger change detection */
        /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
        TooltipComponent.prototype.setClass = /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
            function (customClass) {
                if (!customClass) {
                    return;
                }
                this.customClass = customClass;
                this._changeDetectorRef.markForCheck();
            };
        /** Updates the context used by the TemplateRef */
        /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
        TooltipComponent.prototype.setContext = /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
            function (context) {
                if (!context) {
                    return;
                }
                this.context = context;
                this._changeDetectorRef.markForCheck();
            };
        /** Specify the tooltip role attribute */
        /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
        TooltipComponent.prototype.setRole = /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
            function (role) {
                if (!role) {
                    return;
                }
                this.role = role;
                this._changeDetectorRef.markForCheck();
            };
        TooltipComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tooltip',
                        template: "<div class=\"tooltip in\" [id]=\"id\" [attr.role]=\"role\" [ngClass]=\"[placement, customClass]\">\n    <div class=\"tooltip-arrow\"></div>\n    <div class=\"tooltip-inner\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TooltipComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        return TooltipComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipService = (function () {
        function TooltipService() {
            this.shown$ = new Subject.Subject();
        }
        TooltipService.decorators = [
            { type: core.Injectable }
        ];
        return TooltipService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipDirective = (function () {
        function TooltipDirective(_elementRef, _viewContainerRef, _overlay, _scrollDispatcher, _changeDetectorRef, _renderer, _tooltipService) {
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._overlay = _overlay;
            this._scrollDispatcher = _scrollDispatcher;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._tooltipService = _tooltipService;
            /**
             * All the user to add a custom class to the tooltip
             */
            this.customClass = '';
            /**
             * All the user to add a role to the tooltip - default is tooltip
             */
            this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            this.context = {};
            /**
             * Delay the showing of the tooltip by a number of miliseconds
             */
            this.delay = 0;
            /**
             * Programmatically show and hide the tooltip
             */
            this.isOpen = false;
            /**
             * Customize how the tooltip should be positioned relative to the element
             */
            this.placement = 'top';
            /**
             * Specify which events should show the tooltip
             */
            this.showTriggers = ['mouseenter', 'focus'];
            /**
             * Specify which events should hide the tooltip
             */
            this.hideTriggers = ['mouseleave', 'blur'];
            /**
             * Emits an event when the tooltip is shown
             */
            this.shown = new core.EventEmitter();
            /**
             * Emits a event when the tooltip is hidden
             */
            this.hidden = new core.EventEmitter();
            /**
             * Allow two way binding to track the visibility of the tooltip
             */
            this.isOpenChange = new core.EventEmitter();
            /**
             * Keep track of the tooltip visibility
             */
            this.isVisible = false;
            /**
             * This will emit when the directive is destroyed allowing us to unsubscribe all subscriptions automatically
             */
            this._onDestroy = new Subject.Subject();
            /**
             * Internally store the type of this component - usual for distinctions when extending this class
             */
            this._type = 'tooltip';
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        TooltipDirective.prototype.ngOnInit = /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
            function () {
                var _this = this;
                // set up show and hide event triggers
                fromEvent.fromEvent(this._elementRef.nativeElement, 'click').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClick.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseEnter.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseleave').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseLeave.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'focus').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onFocus.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'blur').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onBlur.bind(this));
                // when any other tooltips open hide this one
                this._tooltipService.shown$.pipe(operators.filter(function () { return _this._type === 'tooltip'; }), operators.filter(function (tooltip) { return tooltip !== _this._instance; }), operators.takeUntil(this._onDestroy)).subscribe(this.hide.bind(this));
                // if the tooltip should be initially visible then open it
                if (this.isOpen) {
                    this.show();
                }
            };
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        TooltipDirective.prototype.ngOnChanges = /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // we can ignore the first change as it's handled in ngOnInit
                if (changes["isOpen"] && !changes["isOpen"].firstChange && changes["isOpen"].currentValue !== this.isVisible) {
                    changes["isOpen"].currentValue ? this.show() : this.hide();
                }
                // destroy the overlay ref so a new correctly positioned instance will be created next time
                if (changes["placement"]) {
                    this.destroyOverlay();
                }
                if (this._instance && changes["placement"]) {
                    this._instance.setPlacement(changes["placement"].currentValue);
                }
                if (this._instance && changes["content"]) {
                    this._instance.setContent(changes["content"].currentValue);
                }
                if (this._instance && changes["customClass"]) {
                    this._instance.setClass(changes["customClass"].currentValue);
                }
                if (this._instance && changes["context"]) {
                    this._instance.setContext(changes["context"].currentValue);
                }
                if (this._instance && changes["role"]) {
                    this._instance.setContext(changes["role"].currentValue);
                }
            };
        /** Ensure we clean up after ourselves */
        /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
        TooltipDirective.prototype.ngOnDestroy = /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
            function () {
                // ensure we close the tooltip when the host is destroyed
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._instance = null;
                }
                // emit this event to automatically unsubscribe from all subscriptions
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Make the tooltip open */
        /**
         * Make the tooltip open
         * @return {?}
         */
        TooltipDirective.prototype.show = /**
         * Make the tooltip open
         * @return {?}
         */
            function () {
                var _this = this;
                // if the tooltip is disabled then do nothing
                if (this.disabled || this.isVisible || this._showTimeoutId || !this.content) {
                    return;
                }
                // delay the show by the delay amount
                this._showTimeoutId = window.setTimeout(function () {
                    // create the tooltip and get the overlay ref
                    var /** @type {?} */ overlayRef = _this.createOverlay();
                    // create the portal to create the tooltip component
                    // create the portal to create the tooltip component
                    _this._portal = _this.createPortal();
                    _this._instance = _this.createInstance(overlayRef);
                    // watch for any changes to the content
                    // watch for any changes to the content
                    _this._instance.reposition$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.reposition.bind(_this));
                    // store the visible state
                    // store the visible state
                    _this.isVisible = true;
                    // ensure the overlay has the correct initial position
                    // ensure the overlay has the correct initial position
                    _this.reposition();
                    // emit the show events
                    // emit the show events
                    _this.shown.emit();
                    _this.isOpenChange.next(true);
                    // clear the interval id
                    // clear the interval id
                    _this._showTimeoutId = null;
                    // emit the show event to close any other tooltips
                    // emit the show event to close any other tooltips
                    _this._tooltipService.shown$.next(_this._instance);
                    // ensure change detection is run
                    // ensure change detection is run
                    _this._changeDetectorRef.detectChanges();
                }, this.delay);
            };
        /** If a tooltip exists and is visible, hide it */
        /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
        TooltipDirective.prototype.hide = /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
            function () {
                // if we are waiting to show a tooltip then cancel the pending timeout
                if (this._showTimeoutId) {
                    clearTimeout(this._showTimeoutId);
                    this._showTimeoutId = null;
                    return;
                }
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                this.setAriaDescribedBy(null);
                this._instance = null;
                // store the visible state
                this.isVisible = false;
                // emit the hide events
                this.hidden.emit();
                this.isOpenChange.next(false);
                // ensure change detection is run
                this._changeDetectorRef.detectChanges();
            };
        /** Toggle the visibility of the tooltip */
        /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
        TooltipDirective.prototype.toggle = /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
            function () {
                this.isVisible ? this.hide() : this.show();
            };
        /** Recalculate the position of the popover */
        /**
         * Recalculate the position of the popover
         * @return {?}
         */
        TooltipDirective.prototype.reposition = /**
         * Recalculate the position of the popover
         * @return {?}
         */
            function () {
                if (this.isVisible && this._overlayRef) {
                    this._overlayRef.updatePosition();
                }
            };
        /** Create an instance from the overlay ref - allows overriding and additional logic here */
        /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
        TooltipDirective.prototype.createInstance = /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                return instance;
            };
        /** Create the component portal - allows overriding to allow other portals eg. popovers */
        /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
        TooltipDirective.prototype.createPortal = /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
            function () {
                return this._portal || new portal.ComponentPortal(TooltipComponent, this._viewContainerRef);
            };
        /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
        TooltipDirective.prototype.createOverlay = /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
            function () {
                // if the tooltip has already been created then just return the existing instance
                if (this._overlayRef) {
                    return this._overlayRef;
                }
                // configure the tooltip
                var /** @type {?} */ strategy = this._overlay.position()
                    .connectedTo(this._elementRef, this.getOrigin(), this.getOverlayPosition());
                // correctly handle scrolling
                var /** @type {?} */ scrollableAncestors = this._scrollDispatcher
                    .getAncestorScrollContainers(this._elementRef);
                strategy.withScrollableContainers(scrollableAncestors);
                this._overlayRef = this._overlay.create({
                    positionStrategy: strategy,
                    panelClass: 'ux-overlay-pane',
                    scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                    hasBackdrop: false
                });
                return this._overlayRef;
            };
        /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
        TooltipDirective.prototype.destroyOverlay = /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
            function () {
                // destroy the existing overlay
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
                this.isVisible = false;
            };
        /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOrigin = /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top' || this.placement == 'bottom') {
                    return { originX: 'center', originY: this.placement };
                }
                else if (this.placement == 'left') {
                    return { originX: 'start', originY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { originX: 'end', originY: 'center' };
                }
            };
        /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOverlayPosition = /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top') {
                    return { overlayX: 'center', overlayY: 'bottom' };
                }
                else if (this.placement == 'bottom') {
                    return { overlayX: 'center', overlayY: 'top' };
                }
                else if (this.placement == 'left') {
                    return { overlayX: 'end', overlayY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { overlayX: 'start', overlayY: 'center' };
                }
            };
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         **/
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
        TooltipDirective.prototype.includes = /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
            function (array, value) {
                return Array.isArray(array) && !!array.find(function (item) { return item === value; });
            };
        /** Handle the click event - show or hide accordingly */
        /**
         * Handle the click event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onClick = /**
         * Handle the click event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if its not visible and click is a show trigger open it
                if (!this.isVisible && this.includes(this.showTriggers, 'click')) {
                    return this.show();
                }
                // if its visible and click is a hide trigger close it
                if (this.isVisible && this.includes(this.hideTriggers, 'click')) {
                    return this.hide();
                }
            };
        /** Handle the mouse enter event - show or hide accordingly */
        /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseEnter = /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'mouseenter')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the mouse leave event - show or hide accordingly */
        /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseLeave = /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'mouseleave')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /** Handle the focus event - show or hide accordingly */
        /**
         * Handle the focus event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onFocus = /**
         * Handle the focus event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'focus')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the blur event - show or hide accordingly */
        /**
         * Handle the blur event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onBlur = /**
         * Handle the blur event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'blur')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /**
         * Determine if the trigger element is focused
         * @return {?}
         */
        TooltipDirective.prototype.isFocused = /**
         * Determine if the trigger element is focused
         * @return {?}
         */
            function () {
                return document.activeElement === this._elementRef.nativeElement;
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        TooltipDirective.prototype.setAriaDescribedBy = /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
            function (id) {
                if (id === null) {
                    this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
                }
                else {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', id);
                }
            };
        TooltipDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTooltip]',
                        exportAs: 'ux-tooltip'
                    },] }
        ];
        /** @nocollapse */
        TooltipDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ViewContainerRef },
                { type: overlay.Overlay },
                { type: overlay.ScrollDispatcher },
                { type: core.ChangeDetectorRef },
                { type: core.Renderer2 },
                { type: TooltipService }
            ];
        };
        TooltipDirective.propDecorators = {
            content: [{ type: core.Input, args: ['uxTooltip',] }],
            disabled: [{ type: core.Input, args: ['tooltipDisabled',] }],
            customClass: [{ type: core.Input, args: ['tooltipClass',] }],
            role: [{ type: core.Input, args: ['tooltipRole',] }],
            context: [{ type: core.Input, args: ['tooltipContext',] }],
            delay: [{ type: core.Input, args: ['tooltipDelay',] }],
            isOpen: [{ type: core.Input }],
            placement: [{ type: core.Input }],
            showTriggers: [{ type: core.Input }],
            hideTriggers: [{ type: core.Input }],
            shown: [{ type: core.Output }],
            hidden: [{ type: core.Output }],
            isOpenChange: [{ type: core.Output }]
        };
        return TooltipDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipModule = (function () {
        function TooltipModule() {
        }
        TooltipModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule
                        ],
                        exports: [TooltipDirective],
                        declarations: [TooltipComponent, TooltipDirective],
                        providers: [TooltipService],
                        entryComponents: [TooltipComponent]
                    },] }
        ];
        return TooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorPickerModule = (function () {
        function ColorPickerModule() {
        }
        ColorPickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            NumberPickerModule,
                            TooltipModule,
                        ],
                        exports: [ColorPickerComponent],
                        declarations: [ColorPickerComponent],
                        providers: [],
                    },] }
        ];
        return ColorPickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingDirective = (function () {
        function ColumnSortingDirective() {
            this.events = new Subject.Subject();
            this.order = [];
        }
        /**
         * @return {?}
         */
        ColumnSortingDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.events.complete();
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleColumn = /**
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                // apply sorting based on the single or multiple sort
                this.order = this.singleSort ? this.toggleSingleColumn(sorting) : this.toggleMultipleColumn(sorting);
                // emit the latest order
                this.events.next(this.order);
                return this.order;
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleSingleColumn = /**
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                return sorting.state === ColumnSortingState.NoSort ? [] : [{ key: sorting.key, state: sorting.state }];
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleMultipleColumn = /**
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                // reorder columns here
                var /** @type {?} */ idx = this.order.findIndex(function (column) { return column.key === sorting.key; });
                // if wasnt previously selected add to list
                if (idx === -1) {
                    return __spread(this.order, [{ key: sorting.key, state: sorting.state }]);
                }
                // if we are sorting it change the sorting order
                if (sorting.state === ColumnSortingState.Ascending || sorting.state === ColumnSortingState.Descending) {
                    return __spread(this.order.filter(function (_column) { return _column.key !== sorting.key; }), [{ key: sorting.key, state: sorting.state }]);
                }
                // Otherwise remove the item
                return this.order.filter(function (_column) { return _column.key !== sorting.key; });
            };
        ColumnSortingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxColumnSorting]'
                    },] }
        ];
        ColumnSortingDirective.propDecorators = {
            singleSort: [{ type: core.Input }]
        };
        return ColumnSortingDirective;
    }());
    /** @enum {string} */
    var ColumnSortingState = {
        Ascending: 'ascending',
        Descending: 'descending',
        NoSort: 'none',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingComponent = (function () {
        function ColumnSortingComponent(_columnSorter) {
            var _this = this;
            this._columnSorter = _columnSorter;
            this.stateChange = new core.EventEmitter();
            this.columnSortingState = ColumnSortingState;
            this._onDestroy = new Subject.Subject();
            this._columnSorter.events.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (event) {
                // if we are sorting this column then find the matching data
                var /** @type {?} */ columnIdx = event.findIndex(function (_column) { return _column.key === _this.key; });
                // if we are not sorting this column then mark it as NoSort
                if (columnIdx === -1) {
                    _this.state = ColumnSortingState.NoSort;
                }
                // only store the number if we have 2 or more columns being sorted
                // only store the number if we have 2 or more columns being sorted
                _this.order = event.length < 2 || columnIdx === -1 ? null : columnIdx + 1;
                // Emit the latest change
                // Emit the latest change
                _this.stateChange.emit(_this.state);
            });
        }
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.changeState = /**
         * @return {?}
         */
            function () {
                switch (this.state) {
                    case ColumnSortingState.Ascending:
                        this.state = ColumnSortingState.Descending;
                        break;
                    case ColumnSortingState.Descending:
                        this.state = ColumnSortingState.NoSort;
                        break;
                    default:
                        this.state = ColumnSortingState.Ascending;
                }
                // inform parent
                return this._columnSorter.toggleColumn({ key: this.key, state: this.state });
            };
        ColumnSortingComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-column-sorting',
                        template: "<div class=\"ux-column-sorting\">\n\n    <i class=\"ux-column-sorting-icon hpe-icon\"\n       [class.hpe-ascend]=\"state === columnSortingState.Ascending\"\n       [class.hpe-descend]=\"state === columnSortingState.Descending\"\n       [class.column-sorting-icon-hidden]=\"state === columnSortingState.NoSort\">\n    </i>\n\n    <p class=\"ux-column-sorting-number\" aria-hidden=\"true\">{{ order }}</p>\n</div>",
                        exportAs: 'ux-column-sorting'
                    }] }
        ];
        /** @nocollapse */
        ColumnSortingComponent.ctorParameters = function () {
            return [
                { type: ColumnSortingDirective }
            ];
        };
        ColumnSortingComponent.propDecorators = {
            state: [{ type: core.Input }],
            key: [{ type: core.Input }],
            stateChange: [{ type: core.Output }]
        };
        return ColumnSortingComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingModule = (function () {
        function ColumnSortingModule() {
        }
        ColumnSortingModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ColumnSortingComponent, ColumnSortingDirective],
                        declarations: [ColumnSortingComponent, ColumnSortingDirective]
                    },] }
        ];
        return ColumnSortingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitSubject = (function () {
        function ConduitSubject(conduit, _zone, zoneId) {
            this.conduit = conduit;
            this._zone = _zone;
            this.zoneId = zoneId;
            this._onDestroy = new Subject.Subject();
            // store the target subject object
            this._subject = conduit.subject;
            // check if there are any conduits that have supplied an initial value
            this.getInitialValue();
            // subscribe to changes to the source subject
            this._subject.pipe(operators.distinctUntilChanged(conduit.changeDetection), operators.takeUntil(this._onDestroy))
                .subscribe(this.onOutput.bind(this));
            // subscribe to the zone events and root zone events
            _zone.getEvents().pipe(operators.filter(function (event) { return event.conduit.id === conduit.id; }), operators.takeUntil(this._onDestroy)).subscribe(this.onInput.bind(this));
        }
        /** Check all allow inputs to see if there is a value we should initially set the conduit to */
        /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
        ConduitSubject.prototype.getInitialValue = /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
            function () {
                var _this = this;
                // if we do not accept inputs then do nothing
                if (this.conduit.acceptsInput === false) {
                    return;
                }
                // return all subjects that are 1) Not itself 2) In a zone that is listed in acceptsInput 3) Have a currentValue set
                var /** @type {?} */ subjects = this._zone.getSubjects().filter(function (subject) {
                    // If this is itself or if it has not value to give us then do nothing
                    if (subject === _this || subject.conduit.id !== _this.conduit.id || !subject.conduit.hasOwnProperty('currentValue')) {
                        return false;
                    }
                    // if acceptsInput is true then we return every time
                    if (_this.conduit.acceptsInput === true) {
                        return true;
                    }
                    if (Array.isArray(_this.conduit.acceptsInput)) {
                        return _this.conduit.acceptsInput.indexOf(subject.zoneId) !== -1;
                    }
                });
                // if there are no matches then do nothing
                if (subjects.length === 0) {
                    return;
                }
                // otherwise sort by the last modified field
                subjects.sort(function (subjectOne, subjectTwo) { return subjectOne.conduit.lastModified.getTime() < subjectTwo.conduit.lastModified.getTime() ? 1 : -1; });
                // get the most recent value
                this._subject.next(subjects[0].conduit.currentValue);
            };
        /** This will be triggered when a conduits value has changed */
        /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
        ConduitSubject.prototype.onInput = /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if we dont accept input or we emitted this value then do nothing
                if (this.conduit.acceptsInput === false || event.conduit === this.conduit) {
                    return;
                }
                // check if the conduit produces output - if not we only do something if we are in the same zone
                if (event.conduit.producesOutput === false && event.zoneId !== this.zoneId) {
                    return;
                }
                // check if we only accept inputs from specific zones
                if (Array.isArray(this.conduit.acceptsInput)) {
                    // check if the event came from an acceptable zone
                    if (!this.conduit.acceptsInput.find(function (zone) { return zone === event.zoneId; })) {
                        return;
                    }
                }
                // if required transform the value
                var /** @type {?} */ outputValue = this.conduit.map ? this.conduit.map(event.value) : event.value;
                // update the subject
                this._subject.next(outputValue);
            };
        /** This will be fired when this conduit emits a new value */
        /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
        ConduitSubject.prototype.onOutput = /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // store the most recent value and when it was modified - can be used for any new conduits to lookup a value
                this.conduit.currentValue = value;
                this.conduit.lastModified = new Date();
                // check if this should produce output
                if (this.conduit.producesOutput) {
                    this._zone.emit({ conduit: this.conduit, zoneId: this.zoneId, value: value });
                }
            };
        /** Unsubscribe once this subject is destroyed */
        /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
        ConduitSubject.prototype.destroy = /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        return ConduitSubject;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This utility is to ensure a all functions with the specified name are called in all super classes
     * @param {?} target
     * @param {?} functionName
     * @return {?}
     */
    function invokeSuperFunction(target, functionName) {
        // get all instances of the function
        var /** @type {?} */ functionList = [];
        // store the current prototype we are checking
        var /** @type {?} */ prototype = target;
        // look through every base class and check it
        do {
            if (prototype.hasOwnProperty(functionName)) {
                functionList.push(prototype[functionName]);
            }
            prototype = prototype.__proto__;
        } while (prototype.__proto__);
        // augment the top level function to call all the functions
        target[functionName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            functionList.forEach(function (func) { return func.call.apply(func, __spread([target], args)); });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitZone = (function () {
        function ConduitZone() {
        }
        /**
         * @return {?}
         */
        ConduitZone.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // find all conduit subjects that are part of this zone
                ConduitZone.subjects.filter(function (_subject) { return _subject.zoneId === _this._zoneId; })
                    .forEach(function (_subject) { return _this.unregisterConduit(_subject.conduit); });
            };
        /** Store reference to the repository and begin watching for and emitting changes */
        /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.registerConduit = /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
            function (conduit) {
                ConduitZone.subjects.push(new ConduitSubject(conduit, this, this._zoneId));
            };
        /** Destroy a conduit */
        /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduit = /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
            function (conduit) {
                var /** @type {?} */ subject = this.getConduitSubject(conduit.subject);
                if (subject) {
                    // remove the subject from the internal list of conduit subjects
                    ConduitZone.subjects = ConduitZone.subjects.filter(function (_subject) { return _subject !== subject; });
                    // perform all unsubscriptions
                    subject.destroy();
                }
            };
        /** Provide the zone with an ID */
        /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
        ConduitZone.prototype.setZoneId = /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
            function (zoneId) {
                this._zoneId = zoneId;
            };
        /** Emit a value to all zones for checking */
        /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
        ConduitZone.prototype.emit = /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
            function (event) {
                ConduitZone.events.next(event);
            };
        /** Retrieve a conduit subsject object from the rxjs subject */
        /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
        ConduitZone.prototype.getConduitSubject = /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
            function (subject) {
                return ConduitZone.subjects.find(function (_subject) { return _subject.conduit.subject === subject; });
            };
        /** Get all subjects from all zones */
        /**
         * Get all subjects from all zones
         * @return {?}
         */
        ConduitZone.prototype.getSubjects = /**
         * Get all subjects from all zones
         * @return {?}
         */
            function () {
                return ConduitZone.subjects;
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.setConduitProperties = /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                // find the conduit with the matching subject
                var /** @type {?} */ conduitSubject = this.getSubjects().find(function (_conduit) { return _conduit.conduit.subject === subject; });
                // if a match was found update the properties
                if (conduitSubject) {
                    // update each specified property
                    for (var /** @type {?} */ prop in properties) {
                        conduitSubject.conduit[prop] = properties[prop];
                    }
                }
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.createConduit = /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                // register the conduit with the zone
                this.registerConduit(__assign({}, properties, { subject: subject }));
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.registerConduits = /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.registerConduit(__assign({}, conduit, { subject: component[conduit.propertyKey] })); });
                }
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduits = /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.unregisterConduit(conduit); });
                }
            };
        /** Return the global event stream */
        /**
         * Return the global event stream
         * @return {?}
         */
        ConduitZone.prototype.getEvents = /**
         * Return the global event stream
         * @return {?}
         */
            function () {
                return ConduitZone.events;
            };
        /**
         * Create a global subject store
         */
        ConduitZone.subjects = [];
        /**
         * Expose an event stream of new values
         */
        ConduitZone.events = new Subject.Subject();
        ConduitZone.decorators = [
            { type: core.Injectable }
        ];
        return ConduitZone;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitComponent = (function () {
        function ConduitComponent(_zone) {
            this._zone = _zone;
            // we want to ensure these functions get called even if a class overrides them
            invokeSuperFunction(this, 'ngOnInit');
            invokeSuperFunction(this, 'ngOnDestroy');
        }
        /** We need to register the conduits with the zone when the component is initialised */
        /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
        ConduitComponent.prototype.ngOnInit = /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
            function () {
                // register the conduit in the zone and ensure it gets the correct instance of the target
                this._zone.registerConduits(this);
            };
        /** We need to unregister the conduits when the component is destroyed */
        /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
        ConduitComponent.prototype.ngOnDestroy = /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
            function () {
                this._zone.unregisterConduits(this);
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.setConduitProperties = /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                this._zone.setConduitProperties(subject, properties);
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.createConduit = /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                this._zone.createConduit(subject, properties);
            };
        /** @nocollapse */
        ConduitComponent.ctorParameters = function () {
            return [
                { type: ConduitZone, decorators: [{ type: core.Optional }] }
            ];
        };
        return ConduitComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ ConduitZoneComponent = (function (_super) {
        __extends(ConduitZoneComponent, _super);
        function ConduitZoneComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        ConduitZoneComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._zone.setZoneId(this.zoneId);
            };
        return ConduitZoneComponent;
    }(ConduitComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ defaultConduitProps = {
        acceptsInput: true,
        producesOutput: true,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Expose the property that conduits will be stored in
     */
    var /** @type {?} */ CONDUITS = '_conduits';
    /**
     * Create the conduit property decorator
     * @param {?} properties
     * @return {?}
     */
    function Conduit(properties) {
        return function (target, propertyKey) {
            if (typeof properties === 'function') {
                properties = properties.call(null);
            }
            // if the target does not already have a conduit list then create one
            if (!target.hasOwnProperty(CONDUITS)) {
                Object.defineProperty(target, CONDUITS, { value: [] });
            }
            // add the conduit to the list ensuring all required properties are provided
            target[CONDUITS].push(/** @type {?} */ (__assign({}, defaultConduitProps, properties, { target: target, propertyKey: propertyKey })));
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardService = (function () {
        function DashboardService() {
            var _this = this;
            this._rowHeight = 0;
            this.widgets$ = new BehaviorSubject.BehaviorSubject([]);
            this.options$ = new BehaviorSubject.BehaviorSubject(defaultOptions);
            this.dimensions$ = new BehaviorSubject.BehaviorSubject({});
            this.height$ = this.dimensions$.pipe(operators.delay(0), operators.map(function (dimensions) { return dimensions.height; }), operators.distinctUntilChanged());
            this.placeholder$ = new BehaviorSubject.BehaviorSubject({ visible: false, x: 0, y: 0, width: 0, height: 0 });
            this.layout$ = new Subject.Subject();
            this.stacked$ = new BehaviorSubject.BehaviorSubject(false);
            this.layout$.subscribe(this.setLayoutData.bind(this));
            this.stacked$.pipe(operators.filter(function (stacked) { return stacked === true; })).subscribe(this.updateWhenStacked.bind(this));
            this.widgets$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
            this.dimensions$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
        }
        Object.defineProperty(DashboardService.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.options$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "widgets", {
            get: /**
             * @return {?}
             */ function () {
                return this.widgets$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "stacked", {
            get: /**
             * @return {?}
             */ function () {
                return this.stacked$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "dimensions", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "columnWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions.width / this.options.columns;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add a widget to the dashboard
         * @param widget The widget component to add to the dashboard
         */
        /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
        DashboardService.prototype.addWidget = /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
            function (widget) {
                this.widgets$.next(__spread(this.widgets$.getValue(), [widget]));
            };
        /**
         * Remove a widget from the dashboard
         * @param widget The widget to remove
         */
        /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
        DashboardService.prototype.removeWidget = /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
            function (widget) {
                this.widgets$.next(this.widgets$.getValue().filter(function (_widget) { return _widget !== widget; }));
            };
        /**
         * Indicate that the dashboard element has been resized
         * @param width The width of the dashboard element in px
         * @param height The height of the dashboard element in px
         */
        /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
        DashboardService.prototype.setDimensions = /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
            function (width, height) {
                if (width === void 0) {
                    width = this.dimensions.width;
                }
                if (height === void 0) {
                    height = this.dimensions.height;
                }
                if (this.dimensions.width !== width || this.dimensions.height !== height) {
                    this.dimensions$.next({ width: width, height: height });
                }
            };
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         */
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
        DashboardService.prototype.getLayoutData = /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
            function () {
                return this.widgets.map(function (widget) {
                    return { id: widget.id, col: widget.getColumn(), row: widget.getRow(), colSpan: widget.getColumnSpan(), rowSpan: widget.getRowSpan() };
                });
            };
        /**
         * Position widgets programatically
         */
        /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
        DashboardService.prototype.setLayoutData = /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
            function (widgets) {
                var _this = this;
                // iterate through each widget data and find a match
                widgets.forEach(function (widget) {
                    // find the matching widget
                    var /** @type {?} */ target = _this.widgets.find(function (_widget) { return _widget.id === widget.id; });
                    if (target) {
                        target.setColumn(widget.col);
                        target.setRow(widget.row);
                        target.setColumnSpan(widget.colSpan);
                        target.setRowSpan(widget.rowSpan);
                    }
                });
            };
        /**
         * Update the positions and sizes of the widgets
         */
        /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
        DashboardService.prototype.renderDashboard = /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
            function () {
                var _this = this;
                // get the dimensions of the dashboard
                this._rowHeight = this.options.rowHeight || this.columnWidth;
                // ensure the column width is not below the min widths
                this.stacked$.next(this.columnWidth < this.options.minWidth);
                // ensure the row height is not below the min widths
                if (this._rowHeight < this.options.minWidth) {
                    this._rowHeight = this.options.minWidth;
                }
                this.setDashboardLayout();
                // iterate through each widget and set the size - except the one being resized
                this.widgets.filter(function (widget) { return !_this._actionWidget || widget !== _this._actionWidget.widget; })
                    .forEach(function (widget) { return widget.render(); });
            };
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         */
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
        DashboardService.prototype.setDashboardLayout = /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
            function () {
                var _this = this;
                // find any widgets that do not currently have a position set
                this.widgets.filter(function (widget) { return widget.getColumn() === undefined || widget.getRow() === undefined; })
                    .forEach(function (widget) { return _this.setWidgetPosition(widget); });
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.updateWhenStacked = /**
         * @return {?}
         */
            function () {
                // iterate through each widget set it's stacked state and
                this.getWidgetsByOrder().forEach(function (widget, idx) {
                    widget.setColumn(0);
                    widget.setRow(idx);
                });
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getWidgetsByOrder = /**
         * @return {?}
         */
            function () {
                return this.widgets.sort(function (w1, w2) {
                    var /** @type {?} */ w1Position = w1.getColumn() * w1.getRow();
                    var /** @type {?} */ w2Position = w2.getColumn() * w2.getRow();
                    if (w1Position < w2Position) {
                        return -1;
                    }
                    if (w1Position > w2Position) {
                        return 1;
                    }
                    return 0;
                });
            };
        /**
         * Find a position that a widget can fit in the dashboard
         * @param widget The widget to try and position
         */
        /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
        DashboardService.prototype.setWidgetPosition = /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
            function (widget) {
                // find a position for the widget
                var /** @type {?} */ position = 0;
                var /** @type {?} */ success = false;
                // repeat until a space is found
                while (!success) {
                    // get a position to try
                    var /** @type {?} */ column = position % this.options.columns;
                    var /** @type {?} */ row = Math.floor(position / this.options.columns);
                    // check the current position
                    if (this.getPositionAvailable(column, row, widget.getColumnSpan(), widget.getRowSpan())) {
                        success = true;
                        widget.setColumn(column);
                        widget.setRow(row);
                        return;
                    }
                    if (column === 0 && widget.colSpan > this.options.columns) {
                        throw new Error('Dashboard widgets have a colSpan greater than the max number of dashboard columns!');
                    }
                    position++;
                }
            };
        /**
         * Check if a position in the dashboard is vacant or not
         */
        /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
        DashboardService.prototype.getPositionAvailable = /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
            function (column, row, columnSpan, rowSpan, ignoreWidget) {
                // get a list of grid spaces that are populated
                var /** @type {?} */ spaces = this.getOccupiedSpaces();
                // check if the block would still be in bounds
                if (column + columnSpan > this.options.columns) {
                    return false;
                }
                var _loop_1 = function (x) {
                    var _loop_2 = function (y) {
                        if (spaces.find(function (block) { return block.column === x && block.row === y && block.widget !== ignoreWidget; })) {
                            return { value: false };
                        }
                    };
                    for (var /** @type {?} */ y = row; y < row + rowSpan; y++) {
                        var state_1 = _loop_2(y);
                        if (typeof state_1 === "object")
                            return state_1;
                    }
                };
                // check each required position
                for (var /** @type {?} */ x = column; x < column + columnSpan; x++) {
                    var state_2 = _loop_1(x);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
                return true;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getOccupiedSpaces = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // find all spaces that are currently occupied
                return this.widgets.filter(function (widget) { return widget.getColumn() !== undefined && widget.getRow() !== undefined; })
                    .reduce(function (value, widget) {
                    _this.forEachBlock(widget, function (column, row) { return value.push({ widget: widget, column: column, row: row }); });
                    return value;
                }, []);
            };
        /**
         * Begin resizing a widget
         * @param action The the widget to resize
         */
        /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
        DashboardService.prototype.onResizeStart = /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
            function (action) {
                // store the mouse event
                this._mouseEvent = action.event;
                this._actionWidget = action;
                // bring the widget to the font
                this.bringToFront(action.widget);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onResizeDrag = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                var /** @type {?} */ mousePosX = this._mouseEvent.pageX - pageXOffset;
                var /** @type {?} */ mousePosY = this._mouseEvent.pageY - pageYOffset;
                // if there was no movement then do nothing
                if (action.event.x === mousePosX && action.event.y === mousePosY) {
                    return;
                }
                // update the stored mouse event
                this._mouseEvent = action.event;
                // get handle for direction
                var handle = action.handle;
                // get the bounds of the handle
                var /** @type {?} */ bounds = handle.getBoundingClientRect();
                // get the center of the handle
                var /** @type {?} */ centerX = bounds.left + (bounds.width / 2);
                var /** @type {?} */ centerY = bounds.top + (bounds.height / 2);
                // get the current mouse position
                var /** @type {?} */ mouseX = mousePosX - centerX;
                var /** @type {?} */ mouseY = mousePosY - centerY;
                // store the new proposed dimensions for the widget
                var /** @type {?} */ dimensions = {
                    x: action.widget.x,
                    y: action.widget.y,
                    width: action.widget.width,
                    height: action.widget.height
                };
                // update widget based on the handle being dragged
                switch (action.direction) {
                    case ActionDirection.Right:
                        dimensions.width += mouseX;
                        break;
                    case ActionDirection.Left:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.Bottom:
                        dimensions.height += mouseY;
                        break;
                    case ActionDirection.Top:
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    // Support resizing on multiple axis simultaneously
                    case ActionDirection.TopLeft:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.TopRight:
                        dimensions.width += mouseX;
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.BottomLeft:
                        dimensions.height += mouseY;
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.BottomRight:
                        dimensions.height += mouseY;
                        dimensions.width += mouseX;
                        break;
                }
                var /** @type {?} */ currentWidth = action.widget.x + action.widget.width;
                var /** @type {?} */ currentHeight = action.widget.y + action.widget.height;
                // ensure values are within the dashboard bounds
                if (dimensions.x < 0) {
                    dimensions.x = 0;
                    dimensions.width = currentWidth;
                }
                if (dimensions.y < 0) {
                    dimensions.y = 0;
                    dimensions.height = currentHeight;
                }
                if ((dimensions.x + dimensions.width) > this.dimensions.width) {
                    dimensions.width = this.dimensions.width - dimensions.x;
                }
                // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
                if (dimensions.width < this.options.minWidth) {
                    dimensions.x = action.widget.x;
                    dimensions.width = this.options.minWidth;
                }
                // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
                if (dimensions.height < this.options.minHeight) {
                    dimensions.y = action.widget.y;
                    dimensions.height = this.options.minHeight;
                }
                // update the widget actual values
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.updateWidgetPositions(action.widget);
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onResizeEnd = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // commit resize changes
                this.commitWidgetChanges();
                // hide placeholder
                placeholder.visible = false;
                // update the placeholder
                this.placeholder$.next(placeholder);
                this._actionWidget = null;
                this._mouseEvent = null;
                // ensure any vacant upper spaces are filled where required
                this.shiftWidgetsUp();
                // update dashboard height
                this.setDashboardHeight();
                // emit information about the layout
                this.layout$.next(this.getLayoutData());
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDragStart = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this.onResizeStart(action);
                // store the starting placeholder position
                this.setWidgetOrigin();
                this.cacheWidgets();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onDragEnd = /**
         * @return {?}
         */
            function () {
                this.onResizeEnd();
                this._widgetOrigin = {};
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDrag = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                // if there was no movement then do nothing
                if (action.event.pageX === this._mouseEvent.pageX && action.event.pageY === this._mouseEvent.pageY) {
                    return;
                }
                // get the current mouse position
                var /** @type {?} */ mouseX = action.event.pageX - this._mouseEvent.pageX;
                var /** @type {?} */ mouseY = action.event.pageY - this._mouseEvent.pageY;
                // store the latest event
                this._mouseEvent = action.event;
                var /** @type {?} */ dimensions = {
                    x: action.widget.x + mouseX,
                    y: action.widget.y + mouseY,
                    width: action.widget.width,
                    height: action.widget.height
                };
                this.restoreWidgets(true);
                // update widget position
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.shiftWidgets();
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getRowHeight = /**
         * @return {?}
         */
            function () {
                return this._rowHeight;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.cacheWidgets = /**
         * @return {?}
         */
            function () {
                this._cache = this.widgets.map(function (widget) { return ({ id: widget.id, column: widget.getColumn(), row: widget.getRow() }); });
            };
        /**
         * @param {?=} ignoreActionWidget
         * @return {?}
         */
        DashboardService.prototype.restoreWidgets = /**
         * @param {?=} ignoreActionWidget
         * @return {?}
         */
            function (ignoreActionWidget) {
                var _this = this;
                if (ignoreActionWidget === void 0) {
                    ignoreActionWidget = false;
                }
                this._cache.filter(function (widget) { return !ignoreActionWidget || widget.id !== _this._actionWidget.widget.id; }).forEach(function (widget) {
                    var /** @type {?} */ match = _this.widgets.find(function (wgt) { return wgt.id === widget.id; });
                    if (match) {
                        match.setColumn(widget.column);
                        match.setRow(widget.row);
                    }
                });
            };
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         */
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
        DashboardService.prototype.shiftWidgets = /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ widgetsToMove = [];
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var _loop_3 = function (row) {
                    var _loop_4 = function (column) {
                        // store reference to any widgets that need moved
                        this_1.getOccupiedSpaces()
                            .filter(function (space) { return space.column === column && space.row === row && space.widget !== _this._actionWidget.widget; })
                            .forEach(function (space) { return widgetsToMove.push(space.widget); });
                    };
                    for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                        _loop_4(column);
                    }
                };
                var this_1 = this;
                // check if there are any widgets under the placeholder
                for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                    _loop_3(row);
                }
                // remove any duplicates
                widgetsToMove = widgetsToMove.filter(function (widget, idx, array) { return array.indexOf(widget) === idx; });
                // if no widgets need moved then we can stop here
                if (widgetsToMove.length === 0) {
                    return;
                }
                // create a duplicate we can use to keep track of which have been moved
                var /** @type {?} */ unmovedWidgets = widgetsToMove.slice();
                // attempt to move any widgets to the previous widget position
                widgetsToMove.forEach(function (widget) {
                    // get a grid off all occupied spaces - taking into account the placeholder and ignoring widgets that need moved
                    var /** @type {?} */ grid = _this.getOccupiedSpaces().filter(function (space) { return !unmovedWidgets.find(function (wgt) { return wgt === space.widget; }); });
                    // iterate each free block
                    for (var /** @type {?} */ row = _this._widgetOrigin.row; row < _this._widgetOrigin.row + _this._widgetOrigin.rowSpan; row++) {
                        for (var /** @type {?} */ column = _this._widgetOrigin.column; column < _this._widgetOrigin.column + _this._widgetOrigin.columnSpan; column++) {
                            // determine if the block can fit in this space
                            var /** @type {?} */ requiredSpaces = _this.getRequiredSpacesFromPoint(widget, column, row);
                            // check if widget would fit in space
                            var /** @type {?} */ available = requiredSpaces.every(function (space) {
                                return !grid.find(function (gridSpace) { return gridSpace.column === space.column && gridSpace.row === space.row; }) && space.column < _this.getColumnCount();
                            });
                            if (available) {
                                widget.setColumn(column);
                                widget.setRow(row);
                                unmovedWidgets.splice(unmovedWidgets.findIndex(function (wgt) { return wgt === widget; }), 1);
                                return;
                            }
                        }
                    }
                    // if we get to here then we can't simply swap the positions - next try moving right
                    if (_this.canWidgetMoveRight(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Right);
                        return;
                    }
                    // next try moving left
                    if (_this.canWidgetMoveLeft(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Left);
                        return;
                    }
                    // determine the distance that the widget needs to be moved down
                    var /** @type {?} */ distance = (_this._actionWidget.widget.getRow() - widget.getRow()) + _this._actionWidget.widget.getRowSpan();
                    // as a last resort move the widget downwards
                    // as a last resort move the widget downwards
                    _this.moveWidgetDown(widget, distance);
                });
            };
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param shiftDirection - the position widgets were shifted
         */
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
        DashboardService.prototype.validatePlaceholderPosition = /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
            function (shiftDirection) {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check if the placeholder is over a widget
                if (this.getWidgetsAtPosition(placeholder.column, placeholder.row, true).length > 0) {
                    // move the placeholder the opposite direction
                    switch (shiftDirection) {
                        case ActionDirection.Left:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x + this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                        case ActionDirection.Right:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x - this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                    }
                    // validate this new position again
                    this.validatePlaceholderPosition(shiftDirection);
                }
            };
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveLeft = /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the action widget or occupies the first column
                if (widget === this._actionWidget.widget || widget.getColumn() === 0) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column - widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveLeft(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveLeft(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() - 1);
                }
                return moveable;
            };
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveRight = /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the dragging widget or the widget occupies the final column
                if (widget === this._actionWidget.widget || widget.getColumn() + widget.getColumnSpan() === this.options.columns) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column + widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveRight(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveRight(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() + 1);
                }
                return moveable;
            };
        /**
         * Store the initial position of the widget being dragged
         */
        /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
        DashboardService.prototype.setWidgetOrigin = /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
            function () {
                this._widgetOrigin = {
                    column: this._actionWidget.widget.getColumn(),
                    row: this._actionWidget.widget.getRow(),
                    columnSpan: this._actionWidget.widget.getColumnSpan(),
                    rowSpan: this._actionWidget.widget.getRowSpan()
                };
            };
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         */
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
        DashboardService.prototype.getRequiredSpacesFromPoint = /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
            function (widget, column, row) {
                var /** @type {?} */ spaces = [];
                for (var /** @type {?} */ y = row; y < row + widget.getRowSpan(); y++) {
                    for (var /** @type {?} */ x = column; x < column + widget.getColumnSpan(); x++) {
                        spaces.push({ column: x, row: y, widget: widget });
                    }
                }
                return spaces;
            };
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         */
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
        DashboardService.prototype.updateWidgetPositions = /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check all spaces the placeholder will occupy and move any widget currently in them down
                for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                    for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                        this.getWidgetsAtPosition(column, row, true)
                            .filter(function (wgt) { return wgt !== widget; })
                            .forEach(function (wgt) { return _this.moveWidgetDown(wgt); });
                    }
                }
                // update the height of the dashboard
                this.setDashboardHeight();
                // if we arent dragging the top handle then fill spaces
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Determine if a widget is occupying a specific row and column
         * @param column The columns to check if occupied
         * @param row The row to check if occupied
         * @param ignoreResizing Whether or not to ignore the widget currently being resized
         */
        /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
        DashboardService.prototype.getWidgetsAtPosition = /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
            function (column, row, ignoreResizing) {
                var _this = this;
                if (ignoreResizing === void 0) {
                    ignoreResizing = false;
                }
                return this.getOccupiedSpaces()
                    .filter(function (space) { return space.column === column && space.row === row; })
                    .filter(function (space) { return space.widget !== _this._actionWidget.widget || !ignoreResizing; })
                    .map(function (space) { return space.widget; });
            };
        /**
         * Update the placeholder visibility, position and size
         */
        /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.setPlaceholderBounds = /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (visible, x, y, width, height) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var /** @type {?} */ rounding = this._actionWidget.direction === ActionDirection.Left ||
                    this._actionWidget.direction === ActionDirection.Top ? Rounding.RoundDownBelowHalf : Rounding.RoundUpOverHalf;
                placeholder.visible = visible;
                placeholder.column = this.getPlaceholderColumn(x, width);
                placeholder.row = this.getPlaceholderRow(y, height);
                placeholder.columnSpan = this.getPlaceholderColumnSpan(width);
                placeholder.rowSpan = this.getPlaceholderRowSpan(height);
                // calculate the maximum number of rows
                var /** @type {?} */ rowCount = this.widgets.filter(function (widget) { return widget !== _this._actionWidget.widget; })
                    .reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
                // constrain maximum placeholder row
                placeholder.row = Math.min(placeholder.row, rowCount);
                placeholder.x = (placeholder.column * this.getColumnWidth()) + this.options.padding;
                placeholder.y = (placeholder.row * this._rowHeight) + this.options.padding;
                placeholder.width = (placeholder.columnSpan * this.getColumnWidth()) - (this.options.padding * 2);
                placeholder.height = (placeholder.rowSpan * this._rowHeight) - (this.options.padding * 2);
                // set the values of the widget to match the values of the placeholder - however do not render the changes
                this._actionWidget.widget.setColumn(placeholder.column, false);
                this._actionWidget.widget.setRow(placeholder.row, false);
                this._actionWidget.widget.setColumnSpan(placeholder.columnSpan, false);
                this._actionWidget.widget.setRowSpan(placeholder.rowSpan, false);
                // update the placeholder
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the placeholder column position
         */
        /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumn = /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
            function (x, width) {
                var /** @type {?} */ column = this.getColumnFromPx(x, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ columnSpan = Math.floor(width / this.getColumnWidth());
                var /** @type {?} */ upperLimit = this.getColumnCount() - columnSpan;
                // if we arent dragging left then just return the column
                if (this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(Math.min(column, upperLimit), 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (x <= 0 || overflow === 0 || columnSpan === 0 || overflow > (this.getColumnWidth() / 2)) ?
                    Math.max(Math.min(column, upperLimit), 0) :
                    Math.max(Math.min(column + 1, upperLimit), 0);
            };
        /**
         * Get the column span of the placeholder
         */
        /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumnSpan = /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
            function (width) {
                var /** @type {?} */ columnSpan = this.getColumnFromPx(width);
                // if we arent dragging right or left then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Right &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.BottomRight &&
                    this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(columnSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (columnSpan > 0 && overflow > (this.getColumnWidth() / 2)) ? Math.max(columnSpan + 1, 1) : Math.max(columnSpan, 1);
            };
        /**
         * Get the row position of the placeholder
         */
        /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRow = /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
            function (y, height) {
                var /** @type {?} */ row = this.getRowFromPx(y, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ rowSpan = Math.ceil(height / this._rowHeight);
                // if we arent dragging up then just return the row
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    return Math.max(row, 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = height < this._rowHeight ? 0 : height % this._rowHeight;
                return (y <= 0 || rowSpan === 0 || overflow === 0 || overflow > (this._rowHeight / 2)) ? Math.max(row, 0) : Math.max(row + 1, 0);
            };
        /**
         * Get the row span of the placeholder
         */
        /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRowSpan = /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
            function (height) {
                var /** @type {?} */ rowSpan = this.getRowFromPx(height);
                // if we arent dragging up or down then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.Bottom &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomRight) {
                    return Math.max(rowSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = height % this._rowHeight;
                return (overflow > (this._rowHeight / 2)) ? Math.max(rowSpan + 1, 1) : Math.max(rowSpan, 1);
            };
        /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getColumnFromPx = /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
            function (x, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ column = Math.floor(x / Math.floor(this.getColumnWidth()));
                var /** @type {?} */ overflow = (x % Math.floor(this.getColumnWidth()));
                var /** @type {?} */ half = this.getColumnWidth() / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return column;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? column : column + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? column + 1 : column;
                    case Rounding.RoundUp:
                        return overflow > 0 ? column + 1 : column;
                }
            };
        /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getRowFromPx = /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
            function (y, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ row = Math.floor(y / Math.floor(this._rowHeight));
                var /** @type {?} */ overflow = (y % Math.floor(this._rowHeight));
                var /** @type {?} */ half = this._rowHeight / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return row;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? row : row + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? row + 1 : row;
                    case Rounding.RoundUp:
                        return overflow > 0 ? row + 1 : row;
                }
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.commitWidgetChanges = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check that we have all the values we need
                if (placeholder.column === undefined || placeholder.row === undefined ||
                    placeholder.columnSpan === undefined || placeholder.rowSpan === undefined) {
                    return;
                }
                if (this._actionWidget) {
                    this._actionWidget.widget.setColumn(placeholder.column);
                    this._actionWidget.widget.setRow(placeholder.row);
                    this._actionWidget.widget.setColumnSpan(placeholder.columnSpan);
                    this._actionWidget.widget.setRowSpan(placeholder.rowSpan);
                }
                // reset all placeholder values
                placeholder.column = undefined;
                placeholder.row = undefined;
                placeholder.columnSpan = undefined;
                placeholder.rowSpan = undefined;
                // emit the new placeholder values
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the current column width
         */
        /**
         * Get the current column width
         * @return {?}
         */
        DashboardService.prototype.getColumnWidth = /**
         * Get the current column width
         * @return {?}
         */
            function () {
                return Math.floor(this.columnWidth);
            };
        /**
         * Calculate the number of rows populated with widgets
         */
        /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
        DashboardService.prototype.getRowCount = /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
            function () {
                return this.widgets.reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
            };
        /**
         * Set the height of the dashboard container element
         */
        /**
         * Set the height of the dashboard container element
         * @return {?}
         */
        DashboardService.prototype.setDashboardHeight = /**
         * Set the height of the dashboard container element
         * @return {?}
         */
            function () {
                // size the dashboard container to ensure all rows fit
                var /** @type {?} */ rowCount = this.getRowCount();
                // if we should show an empty row increment the row count by 1
                if (this.options.emptyRow) {
                    rowCount++;
                }
                this.setDimensions(undefined, rowCount * this._rowHeight);
            };
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param widget The widget that should be brought to the front
         */
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
        DashboardService.prototype.bringToFront = /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
            function (widget) {
                this.widgets.forEach(function (_widget) { return _widget === widget ? _widget.bringToFront() : _widget.sendToBack(); });
            };
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param widget The widget to move downwards
         */
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
        DashboardService.prototype.moveWidgetDown = /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
            function (widget, distance) {
                var _this = this;
                if (distance === void 0) {
                    distance = 1;
                }
                // move the widget down one position
                widget.setRow(widget.getRow() + distance);
                // check every space the widget occupies for collisions
                this.forEachBlock(widget, function (column, row) {
                    return _this.getWidgetsAtPosition(column, row, true)
                        .filter(function (wgt) { return wgt !== widget; })
                        .forEach(function (wgt) { return _this.moveWidgetDown(wgt, distance); });
                });
            };
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         */
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
        DashboardService.prototype.shiftWidgetsUp = /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
            function () {
                var _this = this;
                // check whether or not changes have been made - if so we need to repeat until stable
                var /** @type {?} */ stable = true;
                // iterate each widget and
                this.widgets.forEach(function (widget) {
                    // if widget is already on the top row then do nothing
                    if (widget.getRow() === 0) {
                        return;
                    }
                    // if we are currently dragging and this is the dragging widget then skip
                    if (_this._actionWidget && _this._actionWidget.widget === widget) {
                        return;
                    }
                    if (_this.getPositionAvailable(widget.getColumn(), widget.getRow() - 1, widget.getColumnSpan(), 1)) {
                        widget.setRow(widget.getRow() - 1);
                        stable = false;
                    }
                });
                // if changes occurred then we should repeat the process
                if (!stable) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Iterate over each space a widget occupied
         * @param widget The widget to determine spaces
         * @param callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         */
        /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
        DashboardService.prototype.forEachBlock = /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
            function (widget, callback) {
                for (var /** @type {?} */ row = widget.getRow(); row < widget.getRow() + widget.getRowSpan(); row++) {
                    for (var /** @type {?} */ column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                        callback.call(widget, column, row);
                    }
                }
            };
        /**
         * Returns the number of columns available
         */
        /**
         * Returns the number of columns available
         * @return {?}
         */
        DashboardService.prototype.getColumnCount = /**
         * Returns the number of columns available
         * @return {?}
         */
            function () {
                return this.stacked ? 1 : this.options.columns;
            };
        DashboardService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DashboardService.ctorParameters = function () { return []; };
        return DashboardService;
    }());
    var /** @type {?} */ defaultOptions = { columns: 5, padding: 5, minWidth: 100, minHeight: 100, emptyRow: true };
    /** @enum {number} */
    var ActionDirection = {
        Top: 0,
        TopRight: 1,
        Right: 2,
        BottomRight: 3,
        Bottom: 4,
        BottomLeft: 5,
        Left: 6,
        TopLeft: 7,
        Move: 8,
    };
    ActionDirection[ActionDirection.Top] = "Top";
    ActionDirection[ActionDirection.TopRight] = "TopRight";
    ActionDirection[ActionDirection.Right] = "Right";
    ActionDirection[ActionDirection.BottomRight] = "BottomRight";
    ActionDirection[ActionDirection.Bottom] = "Bottom";
    ActionDirection[ActionDirection.BottomLeft] = "BottomLeft";
    ActionDirection[ActionDirection.Left] = "Left";
    ActionDirection[ActionDirection.TopLeft] = "TopLeft";
    ActionDirection[ActionDirection.Move] = "Move";
    /** @enum {number} */
    var Rounding = {
        RoundDown: 0,
        RoundDownBelowHalf: 1,
        RoundUp: 2,
        RoundUpOverHalf: 3,
    };
    Rounding[Rounding.RoundDown] = "RoundDown";
    Rounding[Rounding.RoundDownBelowHalf] = "RoundDownBelowHalf";
    Rounding[Rounding.RoundUp] = "RoundUp";
    Rounding[Rounding.RoundUpOverHalf] = "RoundUpOverHalf";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardComponent = (function () {
        function DashboardComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.layoutChange = new core.EventEmitter();
            dashboardService.layout$.subscribe(function (layout) { return _this.layoutChange.emit(layout); });
        }
        Object.defineProperty(DashboardComponent.prototype, "layout", {
            set: /**
             * @param {?} layout
             * @return {?}
             */ function (layout) {
                if (layout) {
                    this.dashboardService.layout$.next(layout);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardComponent.prototype, "options", {
            set: /**
             * @param {?} options
             * @return {?}
             */ function (options) {
                this.dashboardService.options$.next(__assign({}, defaultOptions, options));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set the initial dimensions
         */
        /**
         * Set the initial dimensions
         * @return {?}
         */
        DashboardComponent.prototype.ngAfterViewInit = /**
         * Set the initial dimensions
         * @return {?}
         */
            function () {
                this.dashboardService.setDimensions(this.dashboardElement.nativeElement.offsetWidth, this.dashboardElement.nativeElement.offsetHeight);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DashboardComponent.prototype.onResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dashboardService.setDimensions(event.width, event.height);
            };
        DashboardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard',
                        template: "<div #dashboard class=\"dashboard-container\" [style.height.px]=\"dashboardService.height$ | async\">\n    <div (uxResize)=\"onResize($event)\" [throttle]=\"16\" class=\"dashboard\">\n        <ng-content></ng-content>\n    </div>\n    \n    <div class=\"position-indicator\" *ngIf=\"(dashboardService.placeholder$ | async).visible\" \n        [style.left.px]=\"(dashboardService.placeholder$ | async).x\" \n        [style.top.px]=\"(dashboardService.placeholder$ | async).y\" \n        [style.width.px]=\"(dashboardService.placeholder$ | async).width\"\n        [style.height.px]=\"(dashboardService.placeholder$ | async).height\"></div>\n</div>",
                        providers: [DashboardService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DashboardComponent.ctorParameters = function () {
            return [
                { type: DashboardService }
            ];
        };
        DashboardComponent.propDecorators = {
            layout: [{ type: core.Input }],
            options: [{ type: core.Input }],
            layoutChange: [{ type: core.Output }],
            dashboardElement: [{ type: core.ViewChild, args: ['dashboard',] }]
        };
        return DashboardComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardWidgetComponent = (function () {
        function DashboardWidgetComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.colSpan = 1;
            this.rowSpan = 1;
            this.resizable = false;
            this.x = 0;
            this.y = 0;
            this.width = 100;
            this.height = 100;
            this.padding = 0;
            this.zIndex = 0;
            this._column = { regular: undefined, stacked: undefined };
            this._row = { regular: undefined, stacked: undefined };
            this._columnSpan = { regular: 1, stacked: 1 };
            this._rowSpan = { regular: 1, stacked: 1 };
            this._subscription = dashboardService.options$.subscribe(function () { return _this.update(); });
        }
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._columnSpan.regular = this.colSpan;
                this._rowSpan.regular = this.rowSpan;
                if (!this.id) {
                    console.warn('Dashboard Widget is missing an ID.');
                    // set random id - keeps things working but prevents exporting of positions
                    this.id = Math.floor(Math.random() * 100000).toString();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // add the widget to the dashboard
                this.dashboardService.addWidget(this);
                // apply the current options
                this.update();
            };
        /**
         * If component is removed, then unregister it from the service
         */
        /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnDestroy = /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
                this.dashboardService.removeWidget(this);
            };
        /**
         * Apply the current dashboard options
         */
        /**
         * Apply the current dashboard options
         * @return {?}
         */
        DashboardWidgetComponent.prototype.update = /**
         * Apply the current dashboard options
         * @return {?}
         */
            function () {
                // get the current options at the time
                var _a = this.dashboardService.options, padding = _a.padding, columns = _a.columns;
                this.padding = padding;
                this._columnSpan.stacked = columns;
            };
        /**
         * Set the actual position and size values
         */
        /**
         * Set the actual position and size values
         * @return {?}
         */
        DashboardWidgetComponent.prototype.render = /**
         * Set the actual position and size values
         * @return {?}
         */
            function () {
                this.x = this.getColumn() * this.dashboardService.getColumnWidth();
                this.y = this.getRow() * this.dashboardService.getRowHeight();
                this.width = this.getColumnSpan() * this.dashboardService.getColumnWidth();
                this.height = this.getRowSpan() * this.dashboardService.getRowHeight();
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumn = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._column);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRow = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._row);
            };
        /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumn = /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
            function (column, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._column, column);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRow = /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
            function (row, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._row, row);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumnSpan = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._columnSpan);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRowSpan = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._rowSpan);
            };
        /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumnSpan = /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
            function (columnSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._columnSpan, columnSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRowSpan = /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
            function (rowSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._rowSpan, rowSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.bringToFront = /**
         * @return {?}
         */
            function () {
                this.zIndex = 1;
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.sendToBack = /**
         * @return {?}
         */
            function () {
                this.zIndex = 0;
            };
        /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setBounds = /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragstart = /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
            function (handle, event, direction) {
                this.dashboardService.onResizeStart({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.drag = /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
            function (handle, event, direction) {
                this.dashboardService.onResizeDrag({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragend = /**
         * @return {?}
         */
            function () {
                this.dashboardService.onResizeEnd();
            };
        /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setStackableValue = /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
            function (property, value) {
                if (this.dashboardService.stacked) {
                    property.stacked = value;
                }
                else {
                    property.regular = value;
                }
            };
        /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getStackableValue = /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
            function (property) {
                return this.dashboardService.stacked ? property.stacked : property.regular;
            };
        DashboardWidgetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard-widget',
                        template: "<div class=\"widget-content widget-col-span-{{ getColumnSpan() }} widget-row-span-{{ getRowSpan() }}\">\n    <ng-content></ng-content>\n</div>\n\n<div uxDrag\n     #handleTop\n     class=\"resizer-handle handle-top\"\n     (onDragStart)=\"dragstart(handleTop, $event, 0)\"\n     (onDrag)=\"drag(handleTop, $event, 0)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleTopRight\n     class=\"resizer-handle handle-top-right\"\n     (onDragStart)=\"dragstart(handleTopRight, $event, 1)\"\n     (onDrag)=\"drag(handleTopRight, $event, 1)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleRight\n     class=\"resizer-handle handle-right\"\n     (onDragStart)=\"dragstart(handleRight, $event, 2)\"\n     (onDrag)=\"drag(handleRight, $event, 2)\"\n     (onDragEnd)=\"dragend()\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottomRight\n     class=\"resizer-handle handle-bottom-right\"\n     (onDragStart)=\"dragstart(handleBottomRight, $event, 3)\"\n     (onDrag)=\"drag(handleBottomRight, $event, 3)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottom\n     class=\"resizer-handle handle-bottom\"\n     (onDragStart)=\"dragstart(handleBottom, $event, 4)\"\n     (onDrag)=\"drag(handleBottom, $event, 4)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleBottomLeft\n     class=\"resizer-handle handle-bottom-left\"\n     (onDragStart)=\"dragstart(handleBottomLeft, $event, 5)\"\n     (onDrag)=\"drag(handleBottomLeft, $event, 5)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleLeft\n     class=\"resizer-handle handle-left\"\n     (onDragStart)=\"dragstart(handleLeft, $event, 6)\"\n     (onDrag)=\"drag(handleLeft, $event, 6)\"\n     (onDragEnd)=\"dragend()\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleTopLeft\n     class=\"resizer-handle handle-top-left\"\n     (onDragStart)=\"dragstart(handleTopLeft, $event, 7)\"\n     (onDrag)=\"drag(handleTopLeft, $event, 7)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>"
                    }] }
        ];
        /** @nocollapse */
        DashboardWidgetComponent.ctorParameters = function () {
            return [
                { type: DashboardService }
            ];
        };
        DashboardWidgetComponent.propDecorators = {
            id: [{ type: core.Input }],
            col: [{ type: core.Input }],
            row: [{ type: core.Input }],
            colSpan: [{ type: core.Input }],
            rowSpan: [{ type: core.Input }],
            resizable: [{ type: core.Input }],
            x: [{ type: core.HostBinding, args: ['style.left.px',] }],
            y: [{ type: core.HostBinding, args: ['style.top.px',] }],
            width: [{ type: core.HostBinding, args: ['style.width.px',] }],
            height: [{ type: core.HostBinding, args: ['style.height.px',] }],
            padding: [{ type: core.HostBinding, args: ['style.padding.px',] }],
            zIndex: [{ type: core.HostBinding, args: ['style.z-index',] }]
        };
        return DashboardWidgetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragService = (function () {
        function DragService() {
            /**
             * Emit when dragging begins
             */
            this.onDragStart = new Subject.Subject();
            /**
             * Emit when dragging moves
             */
            this.onDrag = new Subject.Subject();
            /**
             * Emit when dragging ends
             */
            this.onDragEnd = new Subject.Subject();
            /**
             * Emit when the user is dragging over the drop area
             */
            this.onDropEnter = new Subject.Subject();
            /**
             * Emit when the user is dragging out of the drop area
             */
            this.onDropLeave = new Subject.Subject();
            /**
             * Emit when a drop occurs
             */
            this.onDrop = new Subject.Subject();
        }
        /** Destroy all observables */
        /**
         * Destroy all observables
         * @return {?}
         */
        DragService.prototype.ngOnDestroy = /**
         * Destroy all observables
         * @return {?}
         */
            function () {
                this.onDragStart.complete();
                this.onDrag.complete();
                this.onDragEnd.complete();
                this.onDrop.complete();
                this.onDropEnter.complete();
                this.onDropLeave.complete();
            };
        DragService.decorators = [
            { type: core.Injectable }
        ];
        return DragService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragDirective = (function () {
        function DragDirective(_elementRef, _ngZone, _renderer, _drag) {
            var _this = this;
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            this._renderer = _renderer;
            this._drag = _drag;
            /**
             * Detemine if we should show a clone when dragging
             */
            this.clone = false;
            /**
             * Allow the dragging to be enabled/disabled
             */
            this.draggable = true;
            /**
             * Emit an event when dragging starts
             */
            this.onDragStart = new core.EventEmitter();
            /**
             * Emit an event when the mouse moves while dragging
             */
            this.onDrag = new core.EventEmitter();
            /**
             * Emit an event when the dragging finishes
             */
            this.onDragEnd = new core.EventEmitter();
            /**
             * Emit when the user drops an item in a drop area
             */
            this.onDrop = new core.EventEmitter();
            /**
             * Emit when the user drags over a drop area
             */
            this.onDropEnter = new core.EventEmitter();
            /**
             * Emit when the user drags out of a drop area
             */
            this.onDropLeave = new core.EventEmitter();
            /**
             * Store the dragging state
             */
            this._isDragging = false;
            /**
             * Create an observable from the mouse down event
             */
            this._mousedown$ = fromEvent.fromEvent(this._elementRef.nativeElement, 'mousedown');
            /**
             * Create an observable from the mouse move event
             */
            this._mousemove$ = fromEvent.fromEvent(document, 'mousemove');
            /**
             * Create an observable from the mouse up event
             */
            this._mouseup$ = fromEvent.fromEvent(document, 'mouseup');
            /**
             * Use an observable to unsubscribe from all subscriptions
             */
            this._onDestroy = new Subject.Subject();
            // ensure all mouse down events on the object are captured
            this._mousedown$.pipe(operators.filter(function () { return _this.draggable; }), operators.takeUntil(this._onDestroy)).subscribe(this.dragStart.bind(this));
            // emit the outputs when drag events occur
            _drag.onDragStart.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function (dragEvent) { return _this.onDragStart.emit(dragEvent.event); });
            _drag.onDrag.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function (dragEvent) { return _this.onDrag.emit(dragEvent.event); });
            _drag.onDragEnd.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function () { return _this.onDragEnd.emit(); });
            _drag.onDrop.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function (event) { return _this.onDrop.emit(event); });
            _drag.onDropEnter.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function () { return _this.onDropEnter.emit(); });
            _drag.onDropLeave.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function () { return _this.onDropLeave.emit(); });
        }
        /** Emit events and create clone when drag starts */
        /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragStart = /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this.clone) {
                    // clone the node
                    this.cloneNode(event);
                }
                // apply a class to the element being dragged
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // store the dragging state
                this._isDragging = true;
                // emit the drag start event
                this._ngZone.run(function () { return _this._drag.onDragStart.next({ event: event, group: _this.group, data: _this.model }); });
                this._mousemove$.pipe(operators.takeUntil(this._mouseup$), operators.takeUntil(this._onDestroy))
                    .subscribe(this.dragMove.bind(this), null, this.dragEnd.bind(this));
            };
        /** Emit event and update clone position when dragging moves */
        /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragMove = /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this._clone) {
                    this.updateNodePosition(event);
                }
                // emit the drag start event
                this._ngZone.run(function () { return _this._drag.onDrag.next({ event: event, group: _this.group, data: _this.model }); });
            };
        /** Emit event and destroy clone when dragging ends */
        /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
        DragDirective.prototype.dragEnd = /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
            function () {
                var _this = this;
                // if there was a clone, remove it
                if (this._clone) {
                    this._renderer.removeChild(document.body, this._clone);
                    this._clone = null;
                }
                // remove the dragging class
                this._renderer.removeClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // emit the on drag end output
                this._ngZone.run(function () { return _this._drag.onDragEnd.next({ group: _this.group, data: _this.model }); });
                // store the dragging state
                this._isDragging = false;
            };
        /** Create an exact clone of an element */
        /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.cloneNode = /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // duplicate the node
                this._clone = this._elementRef.nativeElement.cloneNode(true);
                // store the position within the draggable element
                var _a = this._elementRef.nativeElement.getBoundingClientRect(), top = _a.top, left = _a.left, width = _a.width;
                this._offset = { x: event.clientX - left, y: event.clientY - top };
                // inline all styles so it looks identical regardless of its position in the DOM
                this.inlineStyles(this._elementRef.nativeElement, this._clone);
                // IE doesn't always calculate the correct width value using getComputedStyles... use bounding client value instead
                this._renderer.setStyle(this._clone, 'width', width + 'px');
                // ensure we can easily position the node an it is above all other elements
                this._renderer.setAttribute(this._clone, 'aria-hidden', 'true');
                this._renderer.setStyle(this._clone, 'position', 'absolute');
                this._renderer.setStyle(this._clone, 'z-index', '99999');
                // apply a class to allow custom styling
                this._renderer.addClass(this._clone, 'ux-drag-dragging-clone');
                // insert the cloned element
                this._renderer.appendChild(document.body, this._clone);
                // set the cloned element initial position
                this.updateNodePosition(event);
            };
        /** Position the clone relative to the mouse */
        /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.updateNodePosition = /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._renderer.setStyle(this._clone, 'left', (event.pageX - this._offset.x) + 'px');
                this._renderer.setStyle(this._clone, 'top', (event.pageY - this._offset.y) + 'px');
            };
        /** Inline all styles to ensure styling is consistent regardless of its position in the dom */
        /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        DragDirective.prototype.inlineStyles = /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // get all the computed styles from the source element
                var /** @type {?} */ styles = getComputedStyle(source);
                // inline every specified style
                for (var /** @type {?} */ idx = 0; idx < styles.length; idx++) {
                    var /** @type {?} */ style = styles.item(idx);
                    if (style !== undefined) {
                        this._renderer.setStyle(target, styles[idx], styles[style]);
                    }
                }
                // ensure we dont capture any move events
                this._renderer.setStyle(target, 'pointer-events', 'none');
                // do the same for all the child elements
                for (var /** @type {?} */ idx = 0; idx < source.children.length; idx++) {
                    this.inlineStyles(source.children[idx], target.children[idx]);
                }
            };
        /** Unsubscribe from all subscriptions */
        /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
        DragDirective.prototype.ngOnDestroy = /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        DragDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDrag]'
                    },] }
        ];
        /** @nocollapse */
        DragDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.NgZone },
                { type: core.Renderer2 },
                { type: DragService }
            ];
        };
        DragDirective.propDecorators = {
            clone: [{ type: core.Input }],
            group: [{ type: core.Input }],
            model: [{ type: core.Input }],
            draggable: [{ type: core.Input }],
            onDragStart: [{ type: core.Output }],
            onDrag: [{ type: core.Output }],
            onDragEnd: [{ type: core.Output }],
            onDrop: [{ type: core.Output }],
            onDropEnter: [{ type: core.Output }],
            onDropLeave: [{ type: core.Output }]
        };
        return DragDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DropDirective = (function () {
        function DropDirective(_dragService) {
            var _this = this;
            this._dragService = _dragService;
            /**
             * Emit the model of the item dropped
             */
            this.onDrop = new core.EventEmitter();
            /**
             * Determine whether or not the mouse is within the drop region
             */
            this.isMouseOver = false;
            /**
             * Determine whether or not we are currently dragging an item
             */
            this.isDragging = false;
            /**
             * Ensure we destroy all subscriptions
             */
            this._onDestroy = new Subject.Subject();
            // subscribe to drag events
            _dragService.onDragStart.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return _this.isGroupAllowed(event.group); })).subscribe(this.onDragStart.bind(this));
            _dragService.onDragEnd.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return _this.isGroupAllowed(event.group); })).subscribe(this.onDragEnd.bind(this));
        }
        /**
         * @return {?}
         */
        DropDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Update the mouse over state */
        /**
         * Update the mouse over state
         * @return {?}
         */
        DropDirective.prototype.onMouseOver = /**
         * Update the mouse over state
         * @return {?}
         */
            function () {
                if (this.isGroupAllowed(this._group)) {
                    this.isMouseOver = true;
                    // emit that we are over a drop area
                    this._dragService.onDropEnter.next();
                }
            };
        /** Update the mouse over state */
        /**
         * Update the mouse over state
         * @return {?}
         */
        DropDirective.prototype.onMouseLeave = /**
         * Update the mouse over state
         * @return {?}
         */
            function () {
                // always ensure this value is reset
                this.isMouseOver = false;
                // only emit the dropd leave event when appropriate
                if (this.isGroupAllowed(this._group)) {
                    this._dragService.onDropLeave.next();
                }
            };
        /** Update the dragging state */
        /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
        DropDirective.prototype.onDragStart = /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.isDragging = true;
                this._group = event.group;
            };
        /** Update the dragging state */
        /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
        DropDirective.prototype.onDragEnd = /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // update the dragging state
                this.isDragging = false;
                // clear the cached group
                this._group = null;
                // if the mouse is over and it is in an allowed group emit the dop event
                if (this.isMouseOver && this.isGroupAllowed(event.group)) {
                    this.onDrop.emit(event.data);
                    this._dragService.onDrop.next(event.data);
                }
            };
        /**
         * Determine whether or not the event is part of the specified groups
         * @param {?} group
         * @return {?}
         */
        DropDirective.prototype.isGroupAllowed = /**
         * Determine whether or not the event is part of the specified groups
         * @param {?} group
         * @return {?}
         */
            function (group) {
                // if no group specified allow all groups
                if (!this.group) {
                    return true;
                }
                // if it is an array then ensure it is allowed
                if (Array.isArray(this.group)) {
                    return !!this.group.find(function (_group) { return _group === group; });
                }
                return this.group === group;
            };
        DropDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDrop]',
                        host: {
                            '[class.ux-drop-hover]': 'isMouseOver && isDragging'
                        }
                    },] }
        ];
        /** @nocollapse */
        DropDirective.ctorParameters = function () {
            return [
                { type: DragService }
            ];
        };
        DropDirective.propDecorators = {
            group: [{ type: core.Input }],
            onDrop: [{ type: core.Output }],
            onMouseOver: [{ type: core.HostListener, args: ['mouseenter',] }],
            onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }]
        };
        return DropDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragModule = (function () {
        function DragModule() {
        }
        DragModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DragDirective, DropDirective],
                        declarations: [DragDirective, DropDirective],
                        providers: [DragService]
                    },] }
        ];
        return DragModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardDragHandleDirective = (function (_super) {
        __extends(DashboardDragHandleDirective, _super);
        function DashboardDragHandleDirective(widget, dashboardService, elementRef, ngZone, renderer, drag) {
            var _this = _super.call(this, elementRef, ngZone, renderer, drag) || this;
            _this.onDragStart.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDragStart({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.onDrag.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDrag({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.onDragEnd.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function () { return dashboardService.onDragEnd(); });
            return _this;
        }
        DashboardDragHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDashboardWidgetDragHandle], [ux-dashboard-widget-drag-handle]'
                    },] }
        ];
        /** @nocollapse */
        DashboardDragHandleDirective.ctorParameters = function () {
            return [
                { type: DashboardWidgetComponent },
                { type: DashboardService },
                { type: core.ElementRef },
                { type: core.NgZone },
                { type: core.Renderer2 },
                { type: DragService }
            ];
        };
        return DashboardDragHandleDirective;
    }(DragDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS = [
        DashboardComponent,
        DashboardWidgetComponent,
        DashboardDragHandleDirective
    ];
    var DashboardModule = (function () {
        function DashboardModule() {
        }
        DashboardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            DragModule
                        ],
                        exports: DECLARATIONS,
                        declarations: DECLARATIONS,
                        providers: [DashboardService],
                    },] }
        ];
        return DashboardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Convert a single dimension array to a double dimension array
     * @template T
     * @param {?} items the single dimension array to convert
     * @param {?} columns the number of items each array should have
     * @return {?}
     */
    function gridify(items, columns) {
        // create a copy of array so not to effect the original
        items = items.slice(0);
        var /** @type {?} */ grid = [];
        while (items.length) {
            grid.push(items.splice(0, columns));
        }
        return grid;
    }
    /**
     * Create an array of numbers between two limits
     * @param {?} start the lower limit
     * @param {?} end the upper limit
     * @return {?}
     */
    function range(start, end) {
        var /** @type {?} */ list = [];
        for (var /** @type {?} */ idx = start; idx <= end; idx++) {
            list.push(idx);
        }
        return list;
    }
    /**
     * Create an array of dates between two points
     * @param {?} start the date to start the array
     * @param {?} end the date to end the array
     * @return {?}
     */
    function dateRange(start, end) {
        var /** @type {?} */ dates = [];
        // loop through all the days between the date range
        while (start <= end) {
            // add the date to the array
            dates.push(new Date(start));
            // move to the next day
            start.setDate(start.getDate() + 1);
        }
        return dates;
    }
    /**
     * Compare two dates to see if they are on the same day
     * @param {?} day1 the first date to compare
     * @param {?} day2 the second date to compare
     * @return {?}
     */
    function compareDays(day1, day2) {
        return day1.getDate() === day2.getDate() &&
            day1.getMonth() === day2.getMonth() &&
            day1.getFullYear() === day2.getFullYear();
    }
    /**
     * Date comparison for use primarily with distinctUntilChanged
     * @param {?} dateOne
     * @param {?} dateTwo
     * @return {?}
     */
    function dateComparator(dateOne, dateTwo) {
        return dateOne.getTime() === dateTwo.getTime();
    }
    /**
     * Timezone comparison for use primarily with distinctUntilChanged
     * @param {?} zoneOne
     * @param {?} zoneTwo
     * @return {?}
     */
    function timezoneComparator(zoneOne, zoneTwo) {
        return zoneOne.name === zoneTwo.name && zoneOne.offset === zoneTwo.offset;
    }
    /**
     * Export an array of all the available months
     */
    var /** @type {?} */ months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var /** @type {?} */ monthsShort = months.map(function (month) { return month.substring(0, 3); });
    /**
     * Export an array of all the available days of the week
     */
    var /** @type {?} */ weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    var /** @type {?} */ weekdaysShort = weekdays.map(function (weekday) { return weekday.substring(0, 3); });
    /**
     * Export the default set of time zone
     */
    var /** @type {?} */ timezones = [
        { name: 'GMT-11', offset: 660 },
        { name: 'GMT-10', offset: 600 },
        { name: 'GMT-9', offset: 540 },
        { name: 'GMT-8', offset: 480 },
        { name: 'GMT-7', offset: 420 },
        { name: 'GMT-6', offset: 360 },
        { name: 'GMT-5', offset: 300 },
        { name: 'GMT-4', offset: 240 },
        { name: 'GMT-3', offset: 180 },
        { name: 'GMT-2', offset: 120 },
        { name: 'GMT-1', offset: 60 },
        { name: 'GMT', offset: 0 },
        { name: 'GMT+1', offset: -60 },
        { name: 'GMT+2', offset: -120 },
        { name: 'GMT+3', offset: -180 },
        { name: 'GMT+4', offset: -240 },
        { name: 'GMT+5', offset: -300 },
        { name: 'GMT+6', offset: -360 },
        { name: 'GMT+7', offset: -420 },
        { name: 'GMT+8', offset: -480 },
        { name: 'GMT+9', offset: -540 },
        { name: 'GMT+10', offset: -600 },
        { name: 'GMT+11', offset: -660 },
        { name: 'GMT+12', offset: -720 }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerConfig = (function () {
        function DateTimePickerConfig() {
            this.showDate = true;
            this.showTime = true;
            this.showTimezone = true;
            this.showSeconds = false;
            this.showMeridian = true;
            this.showSpinners = true;
            this.weekdays = weekdaysShort;
            this.nowBtnText = 'Today';
            this.timezones = timezones;
            this.months = months;
            this.monthsShort = monthsShort;
        }
        DateTimePickerConfig.decorators = [
            { type: core.Injectable }
        ];
        return DateTimePickerConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerService = (function () {
        function DateTimePickerService(_config) {
            var _this = this;
            this._config = _config;
            this.mode$ = new BehaviorSubject.BehaviorSubject(DatePickerMode.Day);
            this.date$ = new BehaviorSubject.BehaviorSubject(new Date());
            this.timezone$ = new BehaviorSubject.BehaviorSubject(this.getCurrentTimezone());
            this.selected$ = new BehaviorSubject.BehaviorSubject(new Date());
            // the month and year to display in the viewport
            this.month$ = new BehaviorSubject.BehaviorSubject(new Date().getMonth());
            this.year$ = new BehaviorSubject.BehaviorSubject(new Date().getFullYear());
            this.showDate$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.showDate : true);
            this.showTime$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.showTime : true);
            this.showTimezone$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.showTimezone : true);
            this.showSeconds$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.showSeconds : false);
            this.showMeridian$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.showMeridian : true);
            this.showSpinners$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.showSpinners : true);
            this.weekdays$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.weekdays : weekdaysShort);
            this.nowBtnText$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.nowBtnText : 'Today');
            this.timezones$ = new BehaviorSubject.BehaviorSubject(this._config ? this._config.timezones : timezones);
            this.header$ = new BehaviorSubject.BehaviorSubject(null);
            this.headerEvent$ = new Subject.Subject();
            this.modeDirection = ModeDirection.None;
            this.months = this._config ? this._config.months : months;
            this.monthsShort = this._config ? this._config.monthsShort : monthsShort;
            // when the active date changes set the currently selected date
            this._subscription = this.selected$.pipe(operators.distinctUntilChanged(dateComparator)).subscribe(function (date) {
                // the month and year displayed in the viewport should reflect the newly selected items
                // the month and year displayed in the viewport should reflect the newly selected items
                _this.setViewportMonth(date.getMonth());
                _this.setViewportYear(date.getFullYear());
                // emit the new date to the component host
                // emit the new date to the component host
                _this.date$.next(date);
            });
        }
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMonth = /**
         * @param {?} month
         * @return {?}
         */
            function (month) {
                if (month < 0) {
                    this.month$.next(11);
                    this.year$.next(this.year$.value - 1);
                }
                else if (month > 11) {
                    this.month$.next(0);
                    this.year$.next(this.year$.value + 1);
                }
                else {
                    this.month$.next(month);
                }
            };
        /**
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportYear = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.year$.next(year);
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setDate = /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (day, month, year) {
                var /** @type {?} */ date = new Date(this.selected$.value);
                date.setDate(day);
                date.setMonth(month);
                date.setFullYear(year);
                this.selected$.next(date);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.setDateToNow = /**
         * @return {?}
         */
            function () {
                this.selected$.next(new Date());
            };
        /**
         * @param {?} mode
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMode = /**
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                this.mode$.next(mode);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToChildMode = /**
         * @return {?}
         */
            function () {
                this.modeDirection = ModeDirection.Descend;
                switch (this.mode$.value) {
                    case DatePickerMode.Year:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Day);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToParentMode = /**
         * @return {?}
         */
            function () {
                this.modeDirection = ModeDirection.Ascend;
                switch (this.mode$.value) {
                    case DatePickerMode.Day:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Year);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToNext = /**
         * @return {?}
         */
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Next);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToPrevious = /**
         * @return {?}
         */
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Previous);
            };
        /**
         * @param {?} header
         * @return {?}
         */
        DateTimePickerService.prototype.setHeader = /**
         * @param {?} header
         * @return {?}
         */
            function (header) {
                this.header$.next(header);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.getCurrentTimezone = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ offset = new Date().getTimezoneOffset();
                var /** @type {?} */ zones = this._config ? this._config.timezones : timezones;
                return zones.find(function (timezone) { return timezone.offset === offset; });
            };
        /**
         * @param {?} timezone
         * @return {?}
         */
        DateTimePickerService.prototype.setTimezone = /**
         * @param {?} timezone
         * @return {?}
         */
            function (timezone) {
                this.timezone$.next(timezone);
            };
        DateTimePickerService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DateTimePickerService.ctorParameters = function () {
            return [
                { type: DateTimePickerConfig, decorators: [{ type: core.Optional }] }
            ];
        };
        return DateTimePickerService;
    }());
    /** @enum {number} */
    var DatePickerMode = {
        Day: 0,
        Month: 1,
        Year: 2,
    };
    DatePickerMode[DatePickerMode.Day] = "Day";
    DatePickerMode[DatePickerMode.Month] = "Month";
    DatePickerMode[DatePickerMode.Year] = "Year";
    /** @enum {number} */
    var ModeDirection = {
        None: 0,
        Ascend: 1,
        Descend: 2,
    };
    ModeDirection[ModeDirection.None] = "None";
    ModeDirection[ModeDirection.Ascend] = "Ascend";
    ModeDirection[ModeDirection.Descend] = "Descend";
    /** @enum {number} */
    var DatePickerHeaderEvent = {
        Previous: 0,
        Next: 1,
    };
    DatePickerHeaderEvent[DatePickerHeaderEvent.Previous] = "Previous";
    DatePickerHeaderEvent[DatePickerHeaderEvent.Next] = "Next";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerComponent = (function () {
        function DateTimePickerComponent(datepicker) {
            var _this = this;
            this.datepicker = datepicker;
            this.dateChange = new core.EventEmitter();
            this.timezoneChange = new core.EventEmitter();
            // expose enum to view
            this.DatePickerMode = DatePickerMode;
            this._onDestroy = new Subject.Subject();
            datepicker.selected$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(dateComparator))
                .subscribe(function (date) { return _this.dateChange.emit(date); });
            datepicker.timezone$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(timezoneComparator))
                .subscribe(function (timezone) { return _this.timezoneChange.emit(timezone); });
        }
        Object.defineProperty(DateTimePickerComponent.prototype, "showDate", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showDate$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTime", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTime$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTimezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTimezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSeconds", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSeconds$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showMeridian", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showMeridian$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSpinners", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSpinners$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "weekdays", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.weekdays$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "months", {
            set: /**
             * @param {?} months
             * @return {?}
             */ function (months$$1) {
                this.datepicker.months = months$$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "monthsShort", {
            set: /**
             * @param {?} months
             * @return {?}
             */ function (months$$1) {
                this.datepicker.monthsShort = months$$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "nowBtnText", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.nowBtnText$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezones", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezones$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "date", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!dateComparator(value, this.datepicker.selected$.value)) {
                    this.datepicker.selected$.next(new Date(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateTimePickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Change the date to the current date and time
         */
        /**
         * Change the date to the current date and time
         * @return {?}
         */
        DateTimePickerComponent.prototype.setToNow = /**
         * Change the date to the current date and time
         * @return {?}
         */
            function () {
                // set the date to the current moment
                this.datepicker.setDateToNow();
            };
        DateTimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker',
                        template: "<div class=\"calendar-container\">\n\n  <ux-date-time-picker-header></ux-date-time-picker-header>\n\n  <ng-container *ngIf=\"datepicker.showDate$ | async\" [ngSwitch]=\"datepicker.mode$ | async\">\n\n      <!-- Display days in the current month -->\n      <ux-date-time-picker-day-view *ngSwitchCase=\"DatePickerMode.Day\"></ux-date-time-picker-day-view>\n\n      <!-- Display the months in the current year -->\n      <ux-date-time-picker-month-view *ngSwitchCase=\"DatePickerMode.Month\"></ux-date-time-picker-month-view>\n\n      <!-- Display a decade -->\n      <ux-date-time-picker-year-view *ngSwitchCase=\"DatePickerMode.Year\"></ux-date-time-picker-year-view>\n\n  </ng-container>\n\n  <!-- Display a Time Picker -->\n  <ux-date-time-picker-time-view *ngIf=\"datepicker.showTime$ | async\"></ux-date-time-picker-time-view>\n\n</div>\n\n<button class=\"now-button\" aria-label=\"Set date to now\" (click)=\"setToNow()\">{{ datepicker.nowBtnText$ | async }}</button>",
                        providers: [DateTimePickerService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DateTimePickerComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        DateTimePickerComponent.propDecorators = {
            showDate: [{ type: core.Input }],
            showTime: [{ type: core.Input }],
            showTimezone: [{ type: core.Input }],
            showSeconds: [{ type: core.Input }],
            showMeridian: [{ type: core.Input }],
            showSpinners: [{ type: core.Input }],
            weekdays: [{ type: core.Input }],
            months: [{ type: core.Input }],
            monthsShort: [{ type: core.Input }],
            nowBtnText: [{ type: core.Input }],
            timezones: [{ type: core.Input }],
            dateChange: [{ type: core.Output }],
            timezoneChange: [{ type: core.Output }],
            date: [{ type: core.Input }],
            timezone: [{ type: core.Input }]
        };
        return DateTimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SPIN_BUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SpinButtonComponent; }),
        multi: true
    };
    var SpinButtonComponent = (function () {
        function SpinButtonComponent() {
            this.type = 'text';
            this.placeholder = '';
            this.disabled = false;
            this.spinners = true;
            this.readOnly = true;
            this.scrolling = true;
            this.arrowkeys = true;
            this.valueChange = new core.EventEmitter();
            this.increment = new core.EventEmitter();
            this.decrement = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(SpinButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        SpinButtonComponent.prototype.scroll = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.scrolling) {
                    return;
                }
                if (event.deltaY > 0) {
                    this.triggerDecrement();
                }
                else {
                    this.triggerIncrement();
                }
                event.preventDefault();
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerIncrement = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.increment.emit();
                }
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerDecrement = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.decrement.emit();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SpinButtonComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SpinButtonComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        SpinButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spin-button',
                        template: "<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"incrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerIncrement()\">\n\n  <span class=\"hpe-icon hpe-up\"></span>\n</button>\n\n<input [type]=\"type\"\n       role=\"spinbutton\"\n       [min]=\"min\"\n       [max]=\"max\"\n       [tabindex]=\"0\"\n       class=\"form-control\"\n       [placeholder]=\"placeholder\"\n       [readOnly]=\"readOnly\"\n       [disabled]=\"disabled\"\n       [attr.aria-label]=\"inputAriaLabel\"\n       [attr.aria-disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\"\n       [attr.aria-readonly]=\"readOnly\"\n       [ngModel]=\"value\"\n       (ngModelChange)=\"valueChange.emit($event)\"\n       (wheel)=\"scroll($event)\"\n       (keydown.arrowup)=\"arrowkeys ? triggerIncrement() : null; $event.preventDefault()\"\n       (keydown.arrowdown)=\"arrowkeys ? triggerDecrement() : null; $event.preventDefault()\">\n\n<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"decrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerDecrement()\">\n\n  <span class=\"hpe-icon hpe-down\"></span>\n</button>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [SPIN_BUTTON_VALUE_ACCESSOR]
                    }] }
        ];
        SpinButtonComponent.propDecorators = {
            value: [{ type: core.Input }],
            type: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            spinners: [{ type: core.Input }],
            readOnly: [{ type: core.Input }],
            scrolling: [{ type: core.Input }],
            arrowkeys: [{ type: core.Input }],
            incrementAriaLabel: [{ type: core.Input }],
            inputAriaLabel: [{ type: core.Input }],
            decrementAriaLabel: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            increment: [{ type: core.Output }],
            decrement: [{ type: core.Output }]
        };
        return SpinButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SpinButtonModule = (function () {
        function SpinButtonModule() {
        }
        SpinButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [SpinButtonComponent],
                        declarations: [SpinButtonComponent]
                    },] }
        ];
        return SpinButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeFormatPipe = (function () {
        function TimeFormatPipe() {
        }
        /**
         * @param {?} value
         * @param {?} pad
         * @return {?}
         */
        TimeFormatPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} pad
         * @return {?}
         */
            function (value, pad) {
                return value < 10 && pad ? '0' + value : value;
            };
        TimeFormatPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'timeFormat'
                    },] }
        ];
        return TimeFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TIME_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TimePickerComponent; }),
        multi: true
    };
    var TimePickerComponent = (function () {
        function TimePickerComponent() {
            var _this = this;
            this.arrowkeys = true;
            this.mousewheel = true;
            this.disabled = false;
            this.readOnly = false;
            this.showMeridian = false;
            this.showHours = true;
            this.showMinutes = true;
            this.showSeconds = false;
            this.showSpinners = true;
            this.hourStep = 1;
            this.minuteStep = 1;
            this.secondStep = 1;
            this.meridians = ['AM', 'PM'];
            this.valueChange = new core.EventEmitter();
            this.isValid = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this.value$ = new BehaviorSubject.BehaviorSubject(new Date());
            // create observables that are derived from the latest value
            this.hour$ = this.value$.pipe(operators.map(function (date) { return date.getHours(); }), operators.map(function (hour) { return _this.showMeridian ? _this.getMeridianTime(hour) : hour; }));
            this.minute$ = this.value$.pipe(operators.map(function (date) { return date.getMinutes(); }));
            this.second$ = this.value$.pipe(operators.map(function (date) { return date.getSeconds(); }));
            this.meridian$ = this.value$.pipe(operators.map(function (date) { return date.getHours() < 12 ? _this.meridians[0] : _this.meridians[1]; }));
            this.valid$ = this.value$.pipe(operators.map(function (date) { return _this.checkValidity(date); }));
            this._meridian = this.meridians[0];
            this._subscription = this.valid$.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.isValid.emit(valid); });
        }
        Object.defineProperty(TimePickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return new Date(this.value$.value);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.value$.next(new Date(value));
                this.valueChange.emit(this.value$.value);
                this.onChangeCallback(this.value$.value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TimePickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TimePickerComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.getMeridianTime = /**
         * @param {?} hour
         * @return {?}
         */
            function (hour) {
                return hour > 12 ? hour - 12 : hour;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.setHour = /**
         * @param {?} hour
         * @return {?}
         */
            function (hour) {
                var /** @type {?} */ date = this.value;
                date.setHours(hour ? hour : 0);
                this.value = date;
            };
        /**
         * @param {?} minute
         * @return {?}
         */
        TimePickerComponent.prototype.setMinute = /**
         * @param {?} minute
         * @return {?}
         */
            function (minute) {
                var /** @type {?} */ date = this.value;
                date.setMinutes(minute ? minute : 0);
                this.value = date;
            };
        /**
         * @param {?} seconds
         * @return {?}
         */
        TimePickerComponent.prototype.setSeconds = /**
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                var /** @type {?} */ date = this.value;
                date.setSeconds(seconds ? seconds : 0);
                this.value = date;
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementHour = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() + this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementHour = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() - this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementMinute = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() + this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementMinute = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() - this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementSecond = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() + this.secondStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementSecond = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() - this.secondStep);
            };
        /**
         * @param {?} meridian
         * @return {?}
         */
        TimePickerComponent.prototype.selectMeridian = /**
         * @param {?} meridian
         * @return {?}
         */
            function (meridian) {
                this._meridian = meridian;
                // get the current time
                var /** @type {?} */ hour = this.value.getHours();
                // if we have selected AM
                if (meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        this.setHour(hour - 12);
                    }
                }
                // if we have selected PM
                if (meridian === this.meridians[1]) {
                    if (hour < 12) {
                        this.setHour(hour + 12);
                    }
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        TimePickerComponent.prototype.checkValidity = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                var /** @type {?} */ valid = true;
                if (this.min && date.getTime() <= this.min.getTime()) {
                    valid = false;
                }
                if (this.max && date.getTime() >= this.max.getTime()) {
                    valid = false;
                }
                return valid;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.hourChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                var /** @type {?} */ hour = parseInt(value);
                var /** @type {?} */ currentHour = this.value.getHours();
                // if the value hasn't changed, do nothing
                if (hour === currentHour) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(hour)) {
                    if (hour < 0) {
                        hour = 0;
                    }
                    if (hour > (this.showMeridian ? 12 : 23)) {
                        hour = this.showMeridian ? 12 : 23;
                    }
                }
                hour = isNaN(hour) ? currentHour : hour;
                // if the number is invalid then restore it to the previous value
                if (this._meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        hour -= 12;
                    }
                }
                // if we have selected PM
                if (this._meridian === this.meridians[1]) {
                    if (hour < 12) {
                        hour += 12;
                    }
                }
                this.setHour(hour);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.minuteChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                var /** @type {?} */ minute = parseInt(value);
                var /** @type {?} */ currentMinute = this.value.getMinutes();
                // if the value hasn't changed, do nothing
                if (minute === currentMinute) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(minute)) {
                    if (minute < 0) {
                        minute = 59;
                    }
                    if (minute > 59) {
                        minute = 0;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setMinute(isNaN(minute) ? currentMinute : minute);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.secondChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                var /** @type {?} */ second = parseInt(value);
                var /** @type {?} */ currentSecond = this.value.getSeconds();
                // if the value hasn't changed, do nothing
                if (second === currentSecond) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(second)) {
                    if (second < 0) {
                        second = 0;
                    }
                    if (second > 59) {
                        second = 59;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setSeconds(isNaN(second) ? currentSecond : second);
            };
        TimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-time-picker',
                        template: "<div class=\"time-picker\" aria-label=\"Time picker\">\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showHours\">\n\n        <ux-spin-button\n            type=\"text\"\n            class=\"time-spinner\"\n            placeholder=\"HH\"\n            [min]=\"0\"\n            [max]=\"showMeridian ? 12 : 23\"\n            [value]=\"hour$ | async | timeFormat:!showMeridian\"\n            (valueChange)=\"hourChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"hour\"\n            incrementAriaLabel=\"Increment the hour\"\n            decrementAriaLabel=\"Decrement the hour\"\n            (increment)=\"incrementHour()\"\n            (decrement)=\"decrementHour()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showMinutes\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showMinutes\">\n\n        <ux-spin-button\n            type=\"text\"\n            class=\"time-spinner\"\n            placeholder=\"MM\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"minute$ | async | timeFormat:true\"\n            (valueChange)=\"minuteChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"minute\"\n            incrementAriaLabel=\"Increment the minute\"\n            decrementAriaLabel=\"Decrement the minute\"\n            (increment)=\"incrementMinute()\"\n            (decrement)=\"decrementMinute()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showSeconds\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showSeconds\">\n\n        <ux-spin-button\n            type=\"text\"\n            class=\"time-spinner\"\n            placeholder=\"SS\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"second$ | async | timeFormat:true\"\n            (valueChange)=\"secondChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"seconds\"\n            incrementAriaLabel=\"Increment the second\"\n            decrementAriaLabel=\"Decrement the second\"\n            (increment)=\"incrementSecond()\"\n            (decrement)=\"decrementSecond()\">\n        </ux-spin-button>\n\n    </div>\n</div>\n\n<div class=\"time-picker-meridian\" *ngIf=\"showMeridian\">\n\n    <div class=\"btn-group\" role=\"radiogroup\">\n\n        <button class=\"btn button-toggle-accent\"\n                *ngFor=\"let meridian of meridians\"\n                role=\"radio\"\n                tabindex=\"0\"\n                [disabled]=\"disabled\"\n                (click)=\"selectMeridian(meridian)\"\n                [class.active]=\"meridian === (meridian$ | async)\"\n                [attr.aria-label]=\"meridian\"\n                [attr.aria-checked]=\"meridian === (meridian$ | async)\"\n                [attr.aria-disabled]=\"disabled\">\n                {{ meridian }}\n        </button>\n\n    </div>\n</div>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TIME_PICKER_VALUE_ACCESSOR],
                        host: {
                            'aria-label': 'Time Picker'
                        }
                    }] }
        ];
        /** @nocollapse */
        TimePickerComponent.ctorParameters = function () { return []; };
        TimePickerComponent.propDecorators = {
            arrowkeys: [{ type: core.Input }],
            mousewheel: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            readOnly: [{ type: core.Input }],
            showMeridian: [{ type: core.Input }],
            showHours: [{ type: core.Input }],
            showMinutes: [{ type: core.Input }],
            showSeconds: [{ type: core.Input }],
            showSpinners: [{ type: core.Input }],
            hourStep: [{ type: core.Input }],
            minuteStep: [{ type: core.Input }],
            secondStep: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            meridians: [{ type: core.Input }],
            value: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            isValid: [{ type: core.Output }]
        };
        return TimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimePickerModule = (function () {
        function TimePickerModule() {
        }
        TimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            SpinButtonModule
                        ],
                        exports: [TimePickerComponent],
                        declarations: [TimePickerComponent, TimeFormatPipe],
                    },] }
        ];
        return TimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewService = (function () {
        function DayViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = combineLatest.combineLatest(_datepicker.month$, _datepicker.year$)
                .subscribe(function (_a) {
                var _b = __read(_a, 2), month = _b[0], year = _b[1];
                return _this.createDayGrid(month, year);
            });
        }
        /**
         * @return {?}
         */
        DayViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.setFocus = /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (day, month, year) {
                this.focused$.next({ day: day, month: month, year: year });
                // update the date picker to show the required month and year
                this._datepicker.setViewportMonth(month);
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.createDayGrid = /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (month, year) {
                var _this = this;
                // update the header
                this._datepicker.setHeader(this._datepicker.months[month] + ' ' + year);
                // find the lower and upper boundaries
                var /** @type {?} */ start = new Date(year, month, 1);
                var /** @type {?} */ end = new Date(year, month + 1, 0);
                // we always want to show from the sunday - this may include showing some dates from the previous month
                start.setDate(start.getDate() - start.getDay());
                // we also want to make sure that the range ends on a saturday
                end.setDate(end.getDate() + (6 - end.getDay()));
                // create an array of all the days to display
                var /** @type {?} */ dates = dateRange(start, end).map(function (date) {
                    return ({
                        day: date.getDate(),
                        month: date.getMonth(),
                        year: date.getFullYear(),
                        date: date,
                        isToday: _this.isToday(date),
                        isActive: _this.isActive(date),
                        isCurrentMonth: date.getMonth() === month
                    });
                });
                // turn the dates into a grid
                var /** @type {?} */ items = gridify(dates, 7);
                this.grid$.next(items);
                // if no item has yet been focused then focus the first day of the month
                if ((this._datepicker.modeDirection === ModeDirection.None || this._datepicker.modeDirection === ModeDirection.Descend) && this.focused$.value === null) {
                    // check if the selected item is visible
                    var /** @type {?} */ selectedDay = dates.find(function (day) { return day.isCurrentMonth && day.isActive; });
                    if (selectedDay) {
                        this.setFocus(selectedDay.day, selectedDay.month, selectedDay.year);
                    }
                    else {
                        // find the first day of the month
                        var /** @type {?} */ first = dates.find(function (date) { return date.day === 1; });
                        // focus the date
                        this.setFocus(first.day, first.month, first.year);
                    }
                }
            };
        /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
        DayViewService.prototype.isToday = /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
            function (date) {
                return compareDays(new Date(), date);
            };
        /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
        DayViewService.prototype.isActive = /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
            function (date) {
                return compareDays(this._datepicker.selected$.value, date);
            };
        DayViewService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DayViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return DayViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewComponent = (function () {
        function DayViewComponent(datePicker, dayService) {
            var _this = this;
            this.datePicker = datePicker;
            this.dayService = dayService;
            this._subscription = datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        DayViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Navigate to the previous page of dates
         */
        /**
         * Navigate to the previous page of dates
         * @return {?}
         */
        DayViewComponent.prototype.previous = /**
         * Navigate to the previous page of dates
         * @return {?}
         */
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value - 1);
            };
        /**
         * Navigate to the next page of dates
         */
        /**
         * Navigate to the next page of dates
         * @return {?}
         */
        DayViewComponent.prototype.next = /**
         * Navigate to the next page of dates
         * @return {?}
         */
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value + 1);
            };
        /**
         * Select a particular date
         * @param date the date to select
         */
        /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
        DayViewComponent.prototype.select = /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
            function (date) {
                // update the current date object
                this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear());
                // focus the newly selected date
                this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        DayViewComponent.prototype.trackWeekByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.trackDayByFn = /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
            function (_index, item) {
                return item.day + " " + item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
        DayViewComponent.prototype.focusDate = /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
            function (item, dayOffset) {
                // determine the date of the day
                var /** @type {?} */ target = new Date(item.date.setDate(item.date.getDate() + dayOffset));
                // identify which date should be focused
                this.dayService.setFocus(target.getDate(), target.getMonth(), target.getFullYear());
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ focused = this.dayService.focused$.value;
                var /** @type {?} */ grid = this.dayService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused day is visible
                    var /** @type {?} */ isFocusedDayVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.day === focused.day && _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedDayVisible) {
                        return focused.day === item.day && focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable day then check if there is a selected day
                var /** @type {?} */ isSelectedDayVisible = !!grid.find(function (row) { return !!row.find(function (day) { return day.isActive; }); });
                if (isSelectedDayVisible) {
                    return item.isActive;
                }
                // otherwise make the first day tabbable
                return item.day === 1;
            };
        DayViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-day-view',
                        template: "<table class=\"calendar\">\n    <thead>\n        <tr>\n            <th *ngFor=\"let day of datePicker.weekdays$ | async\" class=\"weekday\" [attr.aria-label]=\"day\">{{ day }}</th>\n        </tr>\n    </thead>\n\n    <tbody role=\"grid\">\n        <tr role=\"row\" *ngFor=\"let row of dayService.grid$ | async; trackBy: trackWeekByFn\">\n\n            <td *ngFor=\"let item of row; trackBy: trackDayByFn\" class=\"date-cell\" role=\"gridcell\">\n\n                <button class=\"date-button\"\n                        [focusIf]=\"(dayService.focused$ | async)?.day === item.day && (dayService.focused$ | async)?.month === item.month && (dayService.focused$ | async)?.year === item.year\"\n                        [attr.aria-label]=\"item.date | date\"\n                        [attr.aria-selected]=\"item.isActive\"\n                        [attr.aria-hidden]=\"!item.isCurrentMonth\"\n                        [class.current]=\"item.isToday\"\n                        [class.active]=\"item.isActive\"\n                        [class.preview]=\"!item.isCurrentMonth\"\n                        [tabindex]=\"getTabbable(item) ? 0 : -1\"\n                        (click)=\"select(item.date); $event.stopPropagation()\"\n                        (keydown.ArrowLeft)=\"focusDate(item, -1); $event.preventDefault()\"\n                        (keydown.ArrowRight)=\"focusDate(item, 1); $event.preventDefault()\"\n                        (keydown.ArrowUp)=\"focusDate(item, -7); $event.preventDefault()\"\n                        (keydown.ArrowDown)=\"focusDate(item, 7); $event.preventDefault()\">\n\n                    {{ item.date.getDate() }}\n                </button>\n\n            </td>\n        </tr>\n    </tbody>\n</table>",
                        providers: [DayViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DayViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: DayViewService }
            ];
        };
        return DayViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HeaderComponent = (function () {
        function HeaderComponent(datepicker) {
            this.datepicker = datepicker;
            this.canAscend$ = this.datepicker.mode$.pipe(operators.map(function (mode) { return mode !== DatePickerMode.Year; }));
            this.mode$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Day';
                    case DatePickerMode.Month:
                        return 'Month';
                    case DatePickerMode.Year:
                        return 'Year';
                }
            }));
            this.headerAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Switch to show months in the year';
                    case DatePickerMode.Month:
                        return 'Switch to show years in the decade';
                    case DatePickerMode.Year:
                        return '';
                }
            }));
            this.previousAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Previous month';
                    case DatePickerMode.Month:
                        return 'Previous year';
                    case DatePickerMode.Year:
                        return 'Previous decade';
                }
            }));
            this.nextAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Next month';
                    case DatePickerMode.Month:
                        return 'Next year';
                    case DatePickerMode.Year:
                        return 'Next decade';
                }
            }));
        }
        /**
         * @return {?}
         */
        HeaderComponent.prototype.previous = /**
         * @return {?}
         */
            function () {
                this.datepicker.goToPrevious();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.ascend = /**
         * @return {?}
         */
            function () {
                this.datepicker.goToParentMode();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.next = /**
         * @return {?}
         */
            function () {
                this.datepicker.goToNext();
            };
        HeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-header',
                        template: "<header class=\"header\">\n\n  <button class=\"header-navigation\"\n          (click)=\"previous(); $event.stopPropagation()\"\n          [attr.aria-label]=\"previousAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-previous\"></i>\n  </button>\n\n  <button class=\"header-title\"\n          [attr.aria-label]=\"headerAria$ | async\"\n          [class.active]=\"canAscend$ | async\"\n          (click)=\"ascend(); $event.stopPropagation()\"\n          [tabindex]=\"(canAscend$ | async) ? 0 : -1\">\n       {{ datepicker.header$ | async }}\n  </button>\n\n  <button class=\"header-navigation\"\n          (click)=\"next(); $event.stopPropagation()\"\n          [attr.aria-label]=\"nextAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-next\"></i>\n  </button>\n</header>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HeaderComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return HeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewService = (function () {
        function MonthViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = _datepicker.year$.subscribe(function (year) { return _this.createMonthGrid(year); });
        }
        /**
         * @return {?}
         */
        MonthViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.setFocus = /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (month, year) {
                this.focused$.next({ month: month, year: year });
                // update the viewport to ensure focused month is visible
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.createMonthGrid = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                var _this = this;
                // update the header
                this._datepicker.setHeader(year.toString());
                // get the current year and month
                var /** @type {?} */ currentMonth = new Date().getMonth();
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // get the currently selected month
                var /** @type {?} */ activeMonth = this._datepicker.selected$.value.getMonth();
                var /** @type {?} */ activeYear = this._datepicker.selected$.value.getFullYear();
                // create a 4x3 grid of month numbers
                var /** @type {?} */ months$$1 = range(0, 11).map(function (month) {
                    return {
                        name: _this._datepicker.monthsShort[month],
                        month: month,
                        year: year,
                        isCurrentMonth: year === currentYear && month === currentMonth,
                        isActiveMonth: year === activeYear && month === activeMonth
                    };
                });
                // map these to the appropriate format
                var /** @type {?} */ items = gridify(months$$1, 4);
                // update the grid
                this.grid$.next(items);
                // if there is no focused month select the first one
                if (this._datepicker.modeDirection === ModeDirection.Descend && this.focused$.value === null) {
                    // check if the selected month is in view
                    var /** @type {?} */ selectedMonth = months$$1.find(function (month) { return month.isActiveMonth; });
                    this.setFocus(selectedMonth ? selectedMonth.month : 0, year);
                }
            };
        MonthViewService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        MonthViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return MonthViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewComponent = (function () {
        function MonthViewComponent(_datePicker, monthService) {
            var _this = this;
            this._datePicker = _datePicker;
            this.monthService = monthService;
            this._subscription = _datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        MonthViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Go to the previous year
         */
        /**
         * Go to the previous year
         * @return {?}
         */
        MonthViewComponent.prototype.previous = /**
         * Go to the previous year
         * @return {?}
         */
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value - 1);
            };
        /**
         * Go to the next year
         */
        /**
         * Go to the next year
         * @return {?}
         */
        MonthViewComponent.prototype.next = /**
         * Go to the next year
         * @return {?}
         */
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value + 1);
            };
        /**
         * Select a month in the calendar
         * @param month the index of the month to select
         */
        /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
        MonthViewComponent.prototype.select = /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
            function (month) {
                this._datePicker.setViewportMonth(month);
                // show the day picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
        MonthViewComponent.prototype.focusMonth = /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
            function (item, monthOffset) {
                var /** @type {?} */ targetMonth = item.month + monthOffset;
                var /** @type {?} */ targetYear = item.year;
                if (targetMonth < 0) {
                    targetMonth += 12;
                    targetYear -= 1;
                }
                if (targetMonth >= 12) {
                    targetMonth -= 12;
                    targetYear += 1;
                }
                this.monthService.setFocus(targetMonth, targetYear);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        MonthViewComponent.prototype.trackRowByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.trackMonthByFn = /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
            function (index, item) {
                return item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ focused = this.monthService.focused$.value;
                var /** @type {?} */ grid = this.monthService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused month is visible
                    var /** @type {?} */ isFocusedMonthVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedMonthVisible) {
                        return focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable month then check if there is a selected month
                var /** @type {?} */ isSelectedMonthVisible = !!grid.find(function (row) { return !!row.find(function (month) { return month.isActiveMonth; }); });
                if (isSelectedMonthVisible) {
                    return item.isActiveMonth;
                }
                // otherwise make the first month tabbable
                return item.month === 0;
            };
        MonthViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-month-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" *ngFor=\"let row of monthService.grid$ | async; trackBy: trackRowByFn\" role=\"row\">\n\n    <button role=\"gridcell\"\n         class=\"calendar-item\"\n         *ngFor=\"let item of row; trackBy: trackMonthByFn\"\n         [focusIf]=\"(monthService.focused$ | async)?.month === item.month && (monthService.focused$ | async)?.year === item.year\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\"\n         [attr.aria-label]=\"item.name + ' ' + item.year\"\n         [attr.aria-selected]=\"item.isActiveMonth\"\n         [class.active]=\"item.isActiveMonth\"\n         [class.current]=\"item.isCurrentMonth\"\n         (click)=\"select(item.month); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusMonth(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusMonth(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusMonth(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusMonth(item, 4); $event.preventDefault()\">\n         {{ item.name }}\n    </button>\n  </div>\n</div>\n",
                        providers: [MonthViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        MonthViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: MonthViewService }
            ];
        };
        return MonthViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeViewComponent = (function () {
        function TimeViewComponent(datepicker) {
            this.datepicker = datepicker;
        }
        /**
         * @param {?} name
         * @return {?}
         */
        TimeViewComponent.prototype.selectTimezone = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                // find matching timezone
                var /** @type {?} */ timezone = timezones.find(function (_timezone) { return _timezone.name === name; });
                if (timezone) {
                    this.datepicker.setTimezone(timezone);
                }
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.incrementTimezone = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone + 1] ? timezones[currentZone + 1] : timezones[currentZone]);
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.decrementTimezone = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone - 1] ? timezones[currentZone - 1] : timezones[currentZone]);
            };
        TimeViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-time-view',
                        template: "<ux-time-picker *ngIf=\"datepicker.showTime$ | async\"\n    [value]=\"datepicker.selected$ | async\"\n    (valueChange)=\"datepicker.selected$.next($event)\"\n    [showSeconds]=\"datepicker.showSeconds$ | async\"\n    [showMeridian]=\"datepicker.showMeridian$ | async\"\n    [showSpinners]=\"datepicker.showSpinners$ | async\">\n</ux-time-picker>\n\n<ng-container *ngIf=\"datepicker.showTimezone$ | async\">\n\n    <div class=\"time-zone-picker\" *ngIf=\"datepicker.showSpinners$ | async\">\n\n        <ux-spin-button\n            class=\"time-zone-spinner\"\n            [value]=\"(datepicker.timezone$ | async).name\"\n            [readOnly]=\"true\"\n            (increment)=\"incrementTimezone()\"\n            (decrement)=\"decrementTimezone()\"\n            inputAriaLabel=\"Time Zone\"\n            incrementAriaLabel=\"Switch to the next time zone\"\n            decrementAriaLabel=\"Switch to the previous time zone\">\n        </ux-spin-button>\n    </div>\n\n    <div class=\"time-zone-picker\" *ngIf=\"!(datepicker.showSpinners$ | async)\">\n\n        <select class=\"form-control time-zone-select\"\n                tabindex=\"0\"\n                [ngModel]=\"(datepicker.timezone$ | async).name\"\n                (ngModelChange)=\"selectTimezone($event)\"\n                aria-label=\"Timezone\"\n                [attr.aria-valuenow]=\"(datepicker.timezone$ | async).name\">\n\n            <option *ngFor=\"let zone of datepicker.timezones$ | async\"\n                    [selected]=\"zone.name === (datepicker.timezone$ | async).name\"\n                    [value]=\"zone.name\">\n                {{ zone?.name }}\n            </option>\n\n        </select>\n    </div>\n\n</ng-container>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TimeViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return TimeViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewService = (function () {
        function YearViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._year = new Date().getFullYear();
            this._subscription = new Subscription.Subscription();
            var /** @type {?} */ year = _datepicker.year$.subscribe(function (_year) { return _this.createYearGrid(_year); });
            var /** @type {?} */ event = _datepicker.headerEvent$
                .subscribe(function (_event) { return _event === DatePickerHeaderEvent.Next ? _this.goToNextDecade() : _this.goToPreviousDecade(); });
            this._subscription.add(year);
            this._subscription.add(event);
        }
        /**
         * @return {?}
         */
        YearViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.setFocus = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.focused$.next(year);
                this.createYearGrid(year);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToPreviousDecade = /**
         * @return {?}
         */
            function () {
                this.createYearGrid(this._year - 10);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToNextDecade = /**
         * @return {?}
         */
            function () {
                this.createYearGrid(this._year + 10);
            };
        /**
         * @param {?=} year
         * @return {?}
         */
        YearViewService.prototype.createYearGrid = /**
         * @param {?=} year
         * @return {?}
         */
            function (year) {
                var _this = this;
                if (year === void 0) {
                    year = this._year;
                }
                this._year = year;
                // get the years to display
                var /** @type {?} */ decade = this.getDecade(year);
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // produce items in the correct format
                var /** @type {?} */ items = decade.range.map(function (_year) {
                    return {
                        year: _year,
                        isCurrentYear: _year === currentYear,
                        isActiveYear: _year === _this._datepicker.year$.value
                    };
                });
                // update the header text
                this._datepicker.setHeader(decade.start + ' - ' + decade.end);
                // create the grid
                this.grid$.next(gridify(items, 4));
            };
        /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.getDecade = /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
            function (year) {
                // figure the start and end points
                var /** @type {?} */ start = (year - (year % 10));
                var /** @type {?} */ end = start + 9;
                // create an array containing all the numbers between the start and end points
                return { start: start, end: end, range: range(start, end) };
            };
        YearViewService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        YearViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return YearViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewComponent = (function () {
        function YearViewComponent(_datePicker, yearService) {
            this._datePicker = _datePicker;
            this.yearService = yearService;
        }
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewComponent.prototype.select = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this._datePicker.setViewportYear(year);
                // show the month picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
        YearViewComponent.prototype.focusYear = /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
            function (item, yearOffset) {
                this.yearService.setFocus(item.year + yearOffset);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        YearViewComponent.prototype.trackRowByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.trackYearByFn = /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
            function (index, item) {
                return item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ focused = this.yearService.focused$.value;
                var /** @type {?} */ grid = this.yearService.grid$.value;
                // if there is a focused year check if this is it
                if (focused) {
                    // check if the focused year is visible
                    var /** @type {?} */ isFocusedYearVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.year === focused; }); });
                    if (isFocusedYearVisible) {
                        return focused === item.year;
                    }
                }
                // if there is no focusable year then check if there is a selected year
                var /** @type {?} */ isSelectedYearVisible = !!grid.find(function (row) { return !!row.find(function (year) { return year.isActiveYear; }); });
                if (isSelectedYearVisible) {
                    return item.isActiveYear;
                }
                // otherwise make the first month tabbable
                return grid[0][0].year === item.year;
            };
        YearViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-year-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" role=\"row\" *ngFor=\"let row of yearService.grid$ | async; trackBy: trackRowByFn\">\n\n    <button *ngFor=\"let item of row; trackBy: trackYearByFn\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         [focusIf]=\"(yearService.focused$ | async) === item.year\"\n         [attr.aria-label]=\"item.year\"\n         [attr.aria-selected]=\"item.isActiveYear\"\n         [class.current]=\"item.isCurrentYear\"\n         [class.active]=\"item.isActiveYear\"\n         (click)=\"select(item.year); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusYear(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusYear(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusYear(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusYear(item, 4); $event.preventDefault()\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\">\n         {{ item.year }}\n    </button>\n  </div>\n</div>\n",
                        providers: [YearViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        YearViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: YearViewService }
            ];
        };
        return YearViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfDirective = (function () {
        function FocusIfDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.focusIfDelay = 0;
            this.focusIfScroll = true;
            this._timeout = null;
        }
        Object.defineProperty(FocusIfDirective.prototype, "focusIf", {
            set: /**
             * @param {?} focus
             * @return {?}
             */ function (focus) {
                var _this = this;
                // if a timeout is pending then cancel it
                if (!focus && this._timeout !== null) {
                    clearTimeout(this._timeout);
                    this._timeout = null;
                }
                if (focus && this._timeout === null) {
                    this._timeout = window.setTimeout(function () {
                        _this._elementRef.nativeElement.focus({ preventScroll: !_this.focusIfScroll });
                        _this._timeout = null;
                    }, this.focusIfDelay);
                }
            },
            enumerable: true,
            configurable: true
        });
        FocusIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[focusIf]'
                    },] }
        ];
        /** @nocollapse */
        FocusIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        FocusIfDirective.propDecorators = {
            focusIfDelay: [{ type: core.Input }],
            focusIfScroll: [{ type: core.Input }],
            focusIf: [{ type: core.Input }]
        };
        return FocusIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfModule = (function () {
        function FocusIfModule() {
        }
        FocusIfModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FocusIfDirective],
                        declarations: [FocusIfDirective]
                    },] }
        ];
        return FocusIfModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerModule = (function () {
        function DateTimePickerModule() {
        }
        /**
         * @return {?}
         */
        DateTimePickerModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: DateTimePickerModule,
                    providers: [
                        DateTimePickerConfig
                    ]
                };
            };
        DateTimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            TimePickerModule,
                            SpinButtonModule,
                            FocusIfModule
                        ],
                        exports: [DateTimePickerComponent],
                        declarations: [DateTimePickerComponent, HeaderComponent, DayViewComponent, MonthViewComponent, YearViewComponent, TimeViewComponent]
                    },] }
        ];
        return DateTimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxComponent = (function () {
        function EboxComponent() {
        }
        EboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-ebox',
                        template: "<div class=\"ux-ebox-header\">\n    <ng-content select=\"ux-ebox-header\"></ng-content>\n</div>\n\n<div class=\"ux-ebox-content\">\n    <ng-content select=\"ux-ebox-content\"></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return EboxComponent;
    }());
    var EboxHeaderDirective = (function () {
        function EboxHeaderDirective() {
        }
        EboxHeaderDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-header'
                    },] }
        ];
        return EboxHeaderDirective;
    }());
    var EboxContentDirective = (function () {
        function EboxContentDirective() {
        }
        EboxContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-content'
                    },] }
        ];
        return EboxContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxModule = (function () {
        function EboxModule() {
        }
        EboxModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [EboxComponent, EboxContentDirective, EboxHeaderDirective],
                        declarations: [EboxComponent, EboxContentDirective, EboxHeaderDirective]
                    },] }
        ];
        return EboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadOptionEvent = (function () {
        function TypeaheadOptionEvent(option) {
            this.option = option;
        }
        return TypeaheadOptionEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadKeyService = (function () {
        function TypeaheadKeyService() {
        }
        /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
        TypeaheadKeyService.prototype.handleKey = /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
            function (event, typeahead) {
                if (typeahead) {
                    switch (event.key) {
                        case 'ArrowUp':
                        case 'Up':
                            if (!typeahead.open) {
                                typeahead.open = true;
                            }
                            else {
                                typeahead.moveHighlight(-1);
                            }
                            event.preventDefault();
                            break;
                        case 'ArrowDown':
                        case 'Down':
                            if (!typeahead.open) {
                                typeahead.open = true;
                            }
                            else {
                                typeahead.moveHighlight(1);
                            }
                            event.preventDefault();
                            break;
                        case 'Escape':
                        case 'Esc':
                            typeahead.open = false;
                            break;
                        case 'Enter':
                            if (typeahead.selectOnEnter) {
                                typeahead.selectHighlighted();
                            }
                    }
                }
            };
        TypeaheadKeyService.decorators = [
            { type: core.Injectable }
        ];
        return TypeaheadKeyService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadService = (function () {
        function TypeaheadService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlightedElement$ = new BehaviorSubject.BehaviorSubject(null);
        }
        TypeaheadService.decorators = [
            { type: core.Injectable }
        ];
        return TypeaheadService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$2 = 0;
    var TypeaheadComponent = (function () {
        function TypeaheadComponent(typeaheadElement, _changeDetector, _service) {
            var _this = this;
            this.typeaheadElement = typeaheadElement;
            this._changeDetector = _changeDetector;
            this._service = _service;
            this.id = "ux-typeahead-" + ++uniqueId$2;
            this.openChange = new core.EventEmitter();
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiselectable = false;
            this.openOnFilterChange = true;
            this.pageSize = 20;
            this.selectFirst = true;
            this.selectOnEnter = false;
            this.loading = false;
            this.optionSelected = new core.EventEmitter();
            this.highlightedChange = new core.EventEmitter();
            this.highlightedElementChange = new core.EventEmitter();
            this.visibleOptions$ = new BehaviorSubject.BehaviorSubject([]);
            this.clicking = false;
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
            this.highlightedKey = null;
            this._onDestroy = new Subject.Subject();
            this.optionApi = {
                getKey: this.getKey.bind(this),
                getDisplay: this.getDisplay.bind(this),
                getDisplayHtml: this.getDisplayHtml.bind(this)
            };
            this.loadOptionsCallback = function (pageNum, pageSize, filter$$1) {
                if (typeof _this.options === 'function') {
                    // Invoke the callback which may return an array or a promise.
                    var /** @type {?} */ arrayOrPromise = _this.options(pageNum, pageSize, filter$$1);
                    // Map the results to an array of TypeaheadVisibleOption.
                    return Promise.resolve(arrayOrPromise).then(function (newOptions) {
                        if (!Array.isArray(newOptions)) {
                            return newOptions;
                        }
                        return newOptions.map(function (option) {
                            return {
                                value: option,
                                key: _this.getKey(option)
                            };
                        });
                    });
                }
                return null;
            };
            this._service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.openChange.emit(next);
                if (next) {
                    _this.initOptions();
                }
            });
            this.highlighted$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.highlightedKey = next ? next.key : null;
                _this.highlightedChange.emit(next ? next.value : null);
            });
            combineLatest.combineLatest(this._service.open$, this._service.highlightedElement$, this.visibleOptions$)
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (_a) {
                var _b = __read(_a, 3), open = _b[0], highlightedElement = _b[1], visibleOptions = _b[2];
                _this.highlightedElementChange.emit(open && visibleOptions.length > 0 ? highlightedElement : null);
            });
        }
        Object.defineProperty(TypeaheadComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._service.open$.getValue();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "highlighted", {
            get: /**
             * @return {?}
             */ function () {
                var /** @type {?} */ value = this.highlighted$.getValue();
                return value ? value.value : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // Open the dropdown if the filter value updates
                if (changes["filter"]) {
                    if (this.openOnFilterChange && changes["filter"].currentValue && changes["filter"].currentValue.length > 0) {
                        this.open = true;
                    }
                }
                // Re-filter visibleOptions
                this.updateOptions();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mousedownHandler = /**
         * @return {?}
         */
            function () {
                this.clicking = true;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mouseupHandler = /**
         * @return {?}
         */
            function () {
                this.clicking = false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TypeaheadComponent.prototype.optionMousedownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Workaround to prevent focus changing when an option is clicked
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.optionClickHandler = /**
         * @param {?} event
         * @param {?} option
         * @return {?}
         */
            function (event, option) {
                this.select(option);
            };
        /**
         * Returns the unique key value of the given option.
         */
        /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getKey = /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (typeof this.key === 'function') {
                    return this.key(option);
                }
                if (typeof this.key === 'string' && option && option.hasOwnProperty(this.key)) {
                    return option[(this.key)];
                }
                return this.getDisplay(option);
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplay = /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param option
         */
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplayHtml = /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                var /** @type {?} */ displayText = this.getDisplay(option).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                var /** @type {?} */ displayHtml = displayText;
                if (this.filter) {
                    var /** @type {?} */ length_1 = this.filter.length;
                    var /** @type {?} */ matchIndex = displayText.toLowerCase().indexOf(this.filter.toLowerCase());
                    if (matchIndex >= 0) {
                        var /** @type {?} */ highlight = "<span class=\"ux-filter-match\">" + displayText.substr(matchIndex, length_1) + "</span>";
                        displayHtml = displayText.substr(0, matchIndex) + highlight + displayText.substr(matchIndex + length_1);
                    }
                }
                return displayHtml;
            };
        /**
         * Returns true if the infinite scroll component should load
         */
        /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
        TypeaheadComponent.prototype.isInfiniteScroll = /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
            function () {
                return typeof this.options === 'function';
            };
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         */
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.select = /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (!this.isDisabled(option)) {
                    this.optionSelected.emit(new TypeaheadOptionEvent(option.value));
                    this.highlighted$.next(null);
                    this.open = false;
                }
            };
        /**
         * Returns true if the given option is part of the disabledOptions array.
         */
        /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.isDisabled = /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                var _this = this;
                if (this.disabledOptions) {
                    var /** @type {?} */ result = this.disabledOptions.find(function (selectedOption) {
                        return _this.getKey(selectedOption) === option.key;
                    });
                    return result !== undefined;
                }
                return false;
            };
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         */
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.highlight = /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (!this.isDisabled(option)) {
                    this.highlighted$.next(option);
                    this._changeDetector.detectChanges();
                }
            };
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TypeaheadComponent.prototype.moveHighlight = /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
            function (d) {
                var /** @type {?} */ visibleOptions = this.visibleOptions$.getValue();
                var /** @type {?} */ highlightIndex = this.indexOfVisibleOption(this.highlighted);
                var /** @type {?} */ newIndex = highlightIndex;
                var /** @type {?} */ disabled = true;
                var /** @type {?} */ inBounds = true;
                do {
                    newIndex = newIndex + d;
                    inBounds = (newIndex >= 0 && newIndex < visibleOptions.length);
                    disabled = inBounds && this.isDisabled(visibleOptions[newIndex]);
                } while (inBounds && disabled);
                if (!disabled && inBounds) {
                    this.highlight(visibleOptions[newIndex]);
                }
                return this.highlighted;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.selectHighlighted = /**
         * @return {?}
         */
            function () {
                if (this.highlighted) {
                    this.select({ value: this.highlighted, key: this.getKey(this.highlighted) });
                }
            };
        /**
         * Set up the options before the dropdown is displayed.
         */
        /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
        TypeaheadComponent.prototype.initOptions = /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
            function () {
                // Clear previous highlight
                this.highlighted$.next(null);
                if (this.selectFirst) {
                    // This will highlight the first non-disabled option.
                    this.moveHighlight(1);
                }
            };
        /**
         * Update the visibleOptions array with the current filter.
         */
        /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
        TypeaheadComponent.prototype.updateOptions = /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
            function () {
                var _this = this;
                if (typeof this.options === 'object') {
                    var /** @type {?} */ normalisedInput_1 = (this.filter || '').toLowerCase();
                    var /** @type {?} */ visibleOptions = this.options
                        .filter(function (option) {
                        return _this.getDisplay(option).toLowerCase().indexOf(normalisedInput_1) >= 0;
                    })
                        .map(function (value) {
                        return {
                            value: value,
                            key: _this.getKey(value)
                        };
                    });
                    this.visibleOptions$.next(visibleOptions);
                }
                this.initOptions();
                this._changeDetector.detectChanges();
            };
        /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.indexOfVisibleOption = /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (option) {
                    var /** @type {?} */ optionKey_1 = this.getKey(option);
                    return this.visibleOptions$.getValue().findIndex(function (el) {
                        return el.key === optionKey_1;
                    });
                }
                return -1;
            };
        TypeaheadComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-typeahead',
                        template: "<div class=\"ux-typeahead-options\"\n    [uxInfiniteScroll]=\"loadOptionsCallback\"\n    [collection]=\"visibleOptions$ | async\"\n    (collectionChange)=\"visibleOptions$.next($event)\"\n    [enabled]=\"isInfiniteScroll()\"\n    [filter]=\"filter\"\n    [loadOnScroll]=\"true\"\n    [pageSize]=\"pageSize\"\n    [scrollElement]=\"typeaheadElement\"\n    (loading)=\"loading = true\"\n    (loaded)=\"loading = false\">\n\n    <ol *ngIf=\"(visibleOptions$ | async).length > 0\">\n        <li *ngFor=\"let option of (visibleOptions$ | async); let i = index\"\n            [attr.id]=\"id + '-option-' + i\"\n            [class.disabled]=\"isDisabled(option)\"\n            [class.highlighted]=\"highlightedKey === option.key\"\n            [attr.aria-selected]=\"multiselectable ? isDisabled(option) : null\"\n            [uxTypeaheadHighlight]=\"highlightedKey === option.key\"\n            [uxScrollIntoViewIf]=\"highlightedKey === option.key\"\n            [scrollParent]=\"typeaheadElement.nativeElement\"\n            (mousedown)=\"optionMousedownHandler($event)\"\n            (click)=\"optionClickHandler($event, option)\"\n            (mouseover)=\"highlight(option)\">\n\n            <ng-container [ngTemplateOutlet]=\"optionTemplate || defaultOptionTemplate\"\n                [ngTemplateOutletContext]=\"{option: option.value, api: optionApi}\">\n            </ng-container>\n\n        </li>\n    </ol>\n\n    <div *uxInfiniteScrollLoading>\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n    <div *ngIf=\"isInfiniteScroll() === false && (visibleOptions$ | async).length === 0 && loading\">\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n</div>\n<div *ngIf=\"(visibleOptions$ | async).length === 0 && !loading\">\n    <ng-container [ngTemplateOutlet]=\"noOptionsTemplate || defaultNoOptionsTemplate\">\n    </ng-container>\n</div>\n\n<ng-template #defaultLoadingTemplate>\n    <div class=\"ux-typeahead-loading\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n        <div>Loading...</div>\n    </div>\n</ng-template>\n\n<ng-template #defaultOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span class=\"ux-typeahead-option\" [innerHtml]=\"api.getDisplayHtml(option)\"></span>\n</ng-template>\n\n<ng-template #defaultNoOptionsTemplate>\n    <span class=\"ux-typeahead-no-options\">No results</span>\n</ng-template>",
                        providers: [TypeaheadService],
                        host: {
                            'role': 'listbox',
                            '[class.open]': 'open',
                            '[class.drop-up]': 'dropDirection === "up"',
                            '[style.maxHeight]': 'maxHeight'
                        }
                    }] }
        ];
        /** @nocollapse */
        TypeaheadComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef },
                { type: TypeaheadService }
            ];
        };
        TypeaheadComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            options: [{ type: core.Input }],
            filter: [{ type: core.Input }],
            open: [{ type: core.Input }],
            openChange: [{ type: core.Output }],
            display: [{ type: core.Input }],
            key: [{ type: core.Input }],
            disabledOptions: [{ type: core.Input }],
            dropDirection: [{ type: core.Input }],
            maxHeight: [{ type: core.Input }],
            multiselectable: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-multiselectable',] }],
            openOnFilterChange: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            selectFirst: [{ type: core.Input }],
            selectOnEnter: [{ type: core.Input }],
            loading: [{ type: core.Input }],
            loadingTemplate: [{ type: core.Input }],
            optionTemplate: [{ type: core.Input }],
            noOptionsTemplate: [{ type: core.Input }],
            optionSelected: [{ type: core.Output }],
            highlightedChange: [{ type: core.Output }],
            highlightedElementChange: [{ type: core.Output }],
            mousedownHandler: [{ type: core.HostListener, args: ['mousedown',] }],
            mouseupHandler: [{ type: core.HostListener, args: ['mouseup',] }]
        };
        return TypeaheadComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadButtonDirective = (function () {
        function InfiniteScrollLoadButtonDirective(_element, _template, _viewContainer, _renderer) {
            this._element = _element;
            this._template = _template;
            this._viewContainer = _viewContainer;
            this._renderer = _renderer;
            this._visible = false;
            this._load = new Subject.Subject();
            this.load = /** @type {?} */ (this._load.asObservable());
        }
        Object.defineProperty(InfiniteScrollLoadButtonDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._template);
                        // Template content follows the elementRef, which is a comment.
                        var /** @type {?} */ clickTarget = this.getNextElementSibling(this._template.elementRef.nativeElement);
                        this._renderer.listen(clickTarget, 'click', this.onClick.bind(this));
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._load.next(event);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.getNextElementSibling = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                var /** @type {?} */ next = element;
                while (next = next.nextSibling) {
                    if (next.nodeType === 1) {
                        return next;
                    }
                }
                return null;
            };
        InfiniteScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoadButton]'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollLoadButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.TemplateRef },
                { type: core.ViewContainerRef },
                { type: core.Renderer2 }
            ];
        };
        InfiniteScrollLoadButtonDirective.propDecorators = {
            visible: [{ type: core.Input, args: ['uxInfiniteScrollLoadButton',] }],
            load: [{ type: core.Output }]
        };
        return InfiniteScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadingDirective = (function () {
        function InfiniteScrollLoadingDirective(_templateRef, _viewContainer) {
            this._templateRef = _templateRef;
            this._viewContainer = _viewContainer;
            this._visible = false;
        }
        Object.defineProperty(InfiniteScrollLoadingDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._templateRef);
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        InfiniteScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoading]'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollLoadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef },
                { type: core.ViewContainerRef }
            ];
        };
        InfiniteScrollLoadingDirective.propDecorators = {
            visible: [{ type: core.Input, args: ['uxInfiniteScrollLoading',] }]
        };
        return InfiniteScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollDirective = (function () {
        function InfiniteScrollDirective(_element) {
            this._element = _element;
            this._collection = [];
            this.enabled = true;
            this.loadOnInit = true;
            this.loadOnScroll = true;
            this.pageSize = 20;
            this.collectionChange = new core.EventEmitter();
            this.loadingEvent = new core.EventEmitter();
            this.loadedEvent = new core.EventEmitter();
            this.loadErrorEvent = new core.EventEmitter();
            this._nextPageNum = 0;
            this._updateRequests = new Subject.Subject();
            this._isLoading = new BehaviorSubject.BehaviorSubject(false);
            this._isExhausted = new BehaviorSubject.BehaviorSubject(false);
            this._loadButtonEnabled = new BehaviorSubject.BehaviorSubject(false);
            this._subscriptions = [];
            this._loadButtonSubscriptions = [];
            this._onDestroy = new Subject.Subject();
            this._canLoadManually = this._isLoading.pipe(operators.combineLatest(this._isExhausted, this._loadButtonEnabled, function (isLoading, isExhausted, loadButtonEnabled) {
                return !isLoading && !isExhausted && loadButtonEnabled;
            }));
        }
        Object.defineProperty(InfiniteScrollDirective.prototype, "collection", {
            get: /**
             * @return {?}
             */ function () {
                return this._collection;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.collectionChange.emit(value);
                this._collection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollDirective.prototype, "scrollElement", {
            set: /**
             * @param {?} element
             * @return {?}
             */ function (element) {
                this._scrollElement = element instanceof core.ElementRef ? element : new core.ElementRef(element);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this._scrollElement) {
                    this._scrollElement = this._element;
                }
                this._loadButtonEnabled.next(!this.loadOnScroll);
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // There are two kinds of update requests: check and load.
                // Check requests are throttled and will only cause an update if more data is required
                // to fill the scrolling view, and it isn't already loading some.
                // Load requests are not throttled and always request a page of data.
                this._updateRequests.pipe(operators.filter(function (request) { return request.check; }), operators.auditTime(200), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                this._updateRequests.pipe(operators.filter(function (request) { return !request.check; }), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                if (this.enabled) {
                    // Subscribe to scroll events and DOM changes.
                    this.attachEventHandlers();
                }
                // Connect the Load More button visible state.
                this._canLoadManually.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (canLoad) {
                    _this._loadButtonQuery.forEach(function (loadButton) {
                        loadButton.visible = canLoad;
                    });
                });
                // Connect the loading indicator visible state.
                this._isLoading.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isLoading) {
                    _this._loadingIndicatorQuery.forEach(function (loading) {
                        loading.visible = isLoading;
                    });
                });
                // Link the Load More button click event to trigger an update.
                this.attachLoadButtonEvents();
                this._loadButtonQuery.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.attachLoadButtonEvents();
                });
                // Initial update.
                if (this.loadOnInit) {
                    this.loadNextPage();
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                var /** @type {?} */ check = true;
                if (changes["enabled"] && changes["enabled"].currentValue !== changes["enabled"].previousValue) {
                    if (changes["enabled"].currentValue) {
                        this.attachEventHandlers();
                        this.reset();
                        check = false;
                    }
                    else {
                        this.detachEventHandlers();
                    }
                }
                if (this.enabled) {
                    if (changes["filter"] && changes["filter"].currentValue !== changes["filter"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    if (changes["loadOnScroll"]) {
                        this._loadButtonEnabled.next(!changes["loadOnScroll"].currentValue);
                    }
                    if (changes["pageSize"] && changes["pageSize"].currentValue !== changes["pageSize"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    this._updateRequests.next({
                        check: check,
                        pageNumber: this._nextPageNum,
                        pageSize: this.pageSize,
                        filter: this.filter
                    });
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.detachEventHandlers();
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Request an additional page of data.
         */
        /**
         * Request an additional page of data.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.loadNextPage = /**
         * Request an additional page of data.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         */
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.check = /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: true,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Clear the collection. Future requests will load from page 0.
         */
        /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reset = /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                // Reset the page counter.
                this._nextPageNum = 0;
                this._pages = [];
                // Clear the collection (without changing the reference).
                if (this.collection) {
                    this.collection.length = 0;
                }
                // Reset the exhausted flag, allowing the Load More button to appear.
                this._isExhausted.next(false);
                // Cancel any pending requests
                if (this._subscriptions) {
                    this._subscriptions.forEach(function (request) { return request.unsubscribe(); });
                }
            };
        /**
         * Reload the data without clearing the view.
         */
        /**
         * Reload the data without clearing the view.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reload = /**
         * Reload the data without clearing the view.
         * @return {?}
         */
            function () {
                var _this = this;
                this._pages.forEach(function (page, i) { return _this.reloadPage(i); });
            };
        /**
         * Reload the data in a specific page without clearing the view.
         * @param pageNum Page number
         */
        /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reloadPage = /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
            function (pageNum) {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: pageNum,
                    pageSize: this.pageSize,
                    filter: this.filter,
                    reload: true
                });
            };
        /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachEventHandlers = /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
            function () {
                // if the scrollElement is documentElement we must watch for a scroll event on the document
                var /** @type {?} */ target = this._scrollElement.nativeElement instanceof HTMLHtmlElement ? document : this._scrollElement.nativeElement;
                // Subscribe to the scroll event on the target element.
                this._scrollEventSub = fromEvent.fromEvent(target, 'scroll').subscribe(this.check.bind(this));
                // Subscribe to child DOM changes. The main effect of this is to check whether even more data is
                // required after the initial load.
                this._domObserver = new MutationObserver(this.check.bind(this));
                this._domObserver.observe(this._scrollElement.nativeElement, {
                    childList: true,
                    subtree: true
                });
            };
        /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.detachEventHandlers = /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
            function () {
                if (this._scrollEventSub) {
                    this._scrollEventSub.unsubscribe();
                    this._scrollEventSub = null;
                }
                if (this._domObserver) {
                    this._domObserver.disconnect();
                    this._domObserver = null;
                }
            };
        /**
         * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
         * for any in the query.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachLoadButtonEvents = /**
         * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
         * for any in the query.
         * @return {?}
         */
            function () {
                var _this = this;
                this._loadButtonSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._loadButtonSubscriptions = this._loadButtonQuery.map(function (loadButton) { return loadButton.load.subscribe(_this.loadNextPage.bind(_this)); });
            };
        /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.doRequest = /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                var _this = this;
                // Load a new page if the scroll position is beyond the threshhold and if the client code did not
                // cancel.
                if (this.needsData(request) && this.beginLoading(request)) {
                    // Invoke the callback load function, which returns a promose or plain data.
                    var /** @type {?} */ loadResult = this.load(request.pageNumber, request.pageSize, request.filter);
                    var /** @type {?} */ observable = Array.isArray(loadResult) ? of.of(loadResult) : from.from(loadResult);
                    var /** @type {?} */ subscription_1 = observable.pipe(operators.first()).subscribe(function (items) {
                        // Make sure that the parameters have not changed since the load started;
                        // otherwise discard the results.
                        if (request.filter === _this.filter && request.pageSize === _this.pageSize) {
                            if (items && items.length) {
                                _this.setPageItems(request.pageNumber, items);
                            }
                            // Emit the loaded event
                            // Emit the loaded event
                            _this.endLoading(request, items);
                        }
                    }, function (reason) {
                        // Emit the loadError event
                        // Emit the loadError event
                        _this.endLoadingWithError(request, reason);
                    }, function () {
                        // remove this request from the list
                        // remove this request from the list
                        _this._subscriptions = _this._subscriptions.filter(function (s) { return s !== subscription_1; });
                    });
                    // add the subscription to the list of requests
                    this._subscriptions.push(subscription_1);
                }
            };
        /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.needsData = /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                if (!this.enabled) {
                    return false;
                }
                // Always load for a load request
                if (!request.check) {
                    return true;
                }
                // Ignore a check request when the end of data has been detected, or if data is currently loading.
                if (this._isExhausted.getValue() || this._isLoading.getValue()) {
                    return false;
                }
                // Load if the remaining scroll area is <= the element height.
                if (this._scrollElement && this.loadOnScroll) {
                    var /** @type {?} */ element = (this._scrollElement.nativeElement);
                    var /** @type {?} */ remainingScroll = element.scrollHeight -
                        (element.scrollTop + element.clientHeight);
                    return remainingScroll <= element.clientHeight;
                }
                return false;
            };
        /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.beginLoading = /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                var /** @type {?} */ event = new InfiniteScrollLoadingEvent(request.pageNumber, request.pageSize, request.filter);
                this.loadingEvent.emit(event);
                this._isLoading.next(!event.defaultPrevented());
                return !event.defaultPrevented();
            };
        /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
        InfiniteScrollDirective.prototype.setPageItems = /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
            function (pageNum, items) {
                this._pages[pageNum] = items;
                this.collection = this._pages.reduce(function (previous, current) { return previous.concat(current); }, []);
            };
        /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoading = /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
            function (request, data) {
                this._isLoading.next(false);
                var /** @type {?} */ isExhausted = !!(data && data.length < this.pageSize);
                this._isExhausted.next(isExhausted);
                this.loadedEvent.emit(new InfiniteScrollLoadedEvent(request.pageNumber, request.pageSize, request.filter, data, isExhausted));
                if (!request.reload) {
                    this._nextPageNum += 1;
                }
            };
        /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoadingWithError = /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
            function (request, error) {
                this._isLoading.next(false);
                this.loadErrorEvent.emit(new InfiniteScrollLoadErrorEvent(request.pageNumber, request.pageSize, request.filter, error));
            };
        InfiniteScrollDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScroll]',
                        exportAs: 'uxInfiniteScroll'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        InfiniteScrollDirective.propDecorators = {
            load: [{ type: core.Input, args: ['uxInfiniteScroll',] }],
            _collection: [{ type: core.Input, args: ['collection',] }],
            scrollElement: [{ type: core.Input }],
            enabled: [{ type: core.Input }],
            filter: [{ type: core.Input }],
            loadOnInit: [{ type: core.Input }],
            loadOnScroll: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            collectionChange: [{ type: core.Output }],
            loadingEvent: [{ type: core.Output, args: ['loading',] }],
            loadedEvent: [{ type: core.Output, args: ['loaded',] }],
            loadErrorEvent: [{ type: core.Output, args: ['loadError',] }],
            _loadButtonQuery: [{ type: core.ContentChildren, args: [InfiniteScrollLoadButtonDirective,] }],
            _loadingIndicatorQuery: [{ type: core.ContentChildren, args: [InfiniteScrollLoadingDirective,] }]
        };
        return InfiniteScrollDirective;
    }());
    /**
     * Event raised before the `loading` function is called.
     */
    var /**
     * Event raised before the `loading` function is called.
     */ InfiniteScrollLoadingEvent = (function () {
        function InfiniteScrollLoadingEvent(pageNumber, pageSize, filter$$1) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter$$1;
            this._defaultPrevented = false;
        }
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         */
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.preventDefault = /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.defaultPrevented = /**
         * @return {?}
         */
            function () {
                return this._defaultPrevented;
            };
        return InfiniteScrollLoadingEvent;
    }());
    /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */
    var /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */ InfiniteScrollLoadedEvent = (function () {
        function InfiniteScrollLoadedEvent(pageNumber, pageSize, filter$$1, data, exhausted) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter$$1;
            this.data = data;
            this.exhausted = exhausted;
        }
        return InfiniteScrollLoadedEvent;
    }());
    /**
     * Event raised if the loading function returns a rejected promise.
     */
    var /**
     * Event raised if the loading function returns a rejected promise.
     */ InfiniteScrollLoadErrorEvent = (function () {
        function InfiniteScrollLoadErrorEvent(pageNumber, pageSize, filter$$1, error) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter$$1;
            this.error = error;
        }
        return InfiniteScrollLoadErrorEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollModule = (function () {
        function InfiniteScrollModule() {
        }
        InfiniteScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        declarations: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        providers: [],
                    },] }
        ];
        return InfiniteScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewService = (function () {
        function ScrollIntoViewService() {
        }
        /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
        ScrollIntoViewService.prototype.scrollIntoView = /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
            function (elem, scrollParent) {
                var /** @type {?} */ offsetTop = (elem.getBoundingClientRect().top + scrollParent.scrollTop) - scrollParent.getBoundingClientRect().top;
                if (offsetTop < scrollParent.scrollTop) {
                    scrollParent.scrollTop = offsetTop;
                }
                else {
                    var /** @type {?} */ offsetBottom = offsetTop + elem.offsetHeight;
                    if (offsetBottom > (scrollParent.scrollTop + scrollParent.clientHeight)) {
                        scrollParent.scrollTop = offsetBottom - scrollParent.clientHeight;
                    }
                }
            };
        ScrollIntoViewService.decorators = [
            { type: core.Injectable }
        ];
        return ScrollIntoViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewIfDirective = (function () {
        function ScrollIntoViewIfDirective(_element, _scrollIntoViewService) {
            this._element = _element;
            this._scrollIntoViewService = _scrollIntoViewService;
            this.condition = false;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewIfDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.condition) {
                    setTimeout(function () { return _this._scrollIntoViewService.scrollIntoView(_this._element.nativeElement, _this.scrollParent); });
                }
            };
        ScrollIntoViewIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoViewIf]',
                        providers: [ScrollIntoViewService]
                    },] }
        ];
        /** @nocollapse */
        ScrollIntoViewIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ScrollIntoViewService }
            ];
        };
        ScrollIntoViewIfDirective.propDecorators = {
            condition: [{ type: core.Input, args: ['uxScrollIntoViewIf',] }],
            scrollParent: [{ type: core.Input }]
        };
        return ScrollIntoViewIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewDirective = (function () {
        function ScrollIntoViewDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow a condition around whether or not this should scroll into view
             */
            this.uxScrollIntoView = true;
            /**
             * Allow user to provide the browser supported options
             */
            this.scrollIntoViewOptions = true;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (this.uxScrollIntoView) {
                    this._elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
                }
            };
        ScrollIntoViewDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoView]'
                    },] }
        ];
        /** @nocollapse */
        ScrollIntoViewDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ScrollIntoViewDirective.propDecorators = {
            uxScrollIntoView: [{ type: core.Input }],
            scrollIntoViewOptions: [{ type: core.Input }]
        };
        return ScrollIntoViewDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollModule = (function () {
        function ScrollModule() {
        }
        ScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ScrollIntoViewIfDirective, ScrollIntoViewDirective],
                        declarations: [ScrollIntoViewIfDirective, ScrollIntoViewDirective]
                    },] }
        ];
        return ScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadHighlightDirective = (function () {
        function TypeaheadHighlightDirective(_service, _elementRef) {
            this._service = _service;
            this._elementRef = _elementRef;
        }
        Object.defineProperty(TypeaheadHighlightDirective.prototype, "highlight", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._service.highlightedElement$.next(this._elementRef.nativeElement);
                }
            },
            enumerable: true,
            configurable: true
        });
        TypeaheadHighlightDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTypeaheadHighlight]'
                    },] }
        ];
        /** @nocollapse */
        TypeaheadHighlightDirective.ctorParameters = function () {
            return [
                { type: TypeaheadService },
                { type: core.ElementRef }
            ];
        };
        TypeaheadHighlightDirective.propDecorators = {
            highlight: [{ type: core.Input, args: ['uxTypeaheadHighlight',] }]
        };
        return TypeaheadHighlightDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadModule = (function () {
        function TypeaheadModule() {
        }
        TypeaheadModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            InfiniteScrollModule,
                            ScrollModule
                        ],
                        exports: [TypeaheadComponent],
                        declarations: [TypeaheadComponent, TypeaheadHighlightDirective],
                        providers: [TypeaheadKeyService],
                    },] }
        ];
        return TypeaheadModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableHandleDirective = (function () {
        function ReorderableHandleDirective() {
        }
        ReorderableHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableHandle]'
                    },] }
        ];
        return ReorderableHandleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModelDirective = (function () {
        // this can be used to identify which instance of the directive relates to which element
        function ReorderableModelDirective(elementRef) {
            this.elementRef = elementRef;
        }
        ReorderableModelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableModel]'
                    },] }
        ];
        /** @nocollapse */
        ReorderableModelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ReorderableModelDirective.propDecorators = {
            uxReorderableModel: [{ type: core.Input }]
        };
        return ReorderableModelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ dragula = dragulaNamespace__default || dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableService = (function () {
        function ReorderableService() {
            this._groups = {};
            this._uniqueGroupId = 0;
        }
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         */
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
        ReorderableService.prototype.getUniqueGroupName = /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
            function () {
                return '_uxReorderable_' + this._uniqueGroupId++;
            };
        /**
         * Adds the container to the named group.
         */
        /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.register = /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
            function (groupName, container) {
                if (!this._groups[groupName]) {
                    this._groups[groupName] = new ReorderableGroup();
                }
                this._groups[groupName].register(container);
                return this._groups[groupName];
            };
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         */
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.unregister = /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
            function (groupName, container) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.unregister(container);
                    if (group.isEmpty()) {
                        group.destroy();
                        delete this._groups[groupName];
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
        ReorderableService.prototype.initialize = /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
            function (groupName) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.initialize();
                }
                return group;
            };
        /**
         * Returns the group object for the given name.
         */
        /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
        ReorderableService.prototype.getGroup = /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
            function (group) {
                return this._groups[group];
            };
        ReorderableService.decorators = [
            { type: core.Injectable }
        ];
        return ReorderableService;
    }());
    /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */
    var /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */ ReorderableGroup = (function () {
        function ReorderableGroup() {
            this.drag = new core.EventEmitter();
            this.dragEnd = new core.EventEmitter();
            this.drop = new core.EventEmitter();
            this.cancel = new core.EventEmitter();
            this.cloned = new core.EventEmitter();
            this._containers = [];
            this._config = {
                moves: this.canMove.bind(this)
            };
        }
        /**
         * Returns true if there are no containers registered with the group.
         */
        /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
        ReorderableGroup.prototype.isEmpty = /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
            function () {
                return this._containers.length === 0;
            };
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         */
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
        ReorderableGroup.prototype.getModelForElement = /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
            function (element) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        var /** @type {?} */ model = container.getModelFromElement(element);
                        if (model) {
                            return model;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return null;
                var e_1, _c;
            };
        /**
         * Adds the container to the group.
         */
        /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.register = /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
            function (container) {
                this._containers.push(container);
                if (this._instance) {
                    this._instance.containers = this._containers.map(function (c) { return c.element; });
                }
                if (!this._config.mirrorContainer) {
                    this._config.mirrorContainer = container.element;
                }
            };
        /**
         * Removes the container from the group.
         */
        /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.unregister = /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
            function (container) {
                var /** @type {?} */ index = this._containers.indexOf(container);
                if (index >= 0) {
                    this._containers.splice(index, 1);
                    if (this._instance) {
                        this._instance.containers = this._containers.map(function (c) { return c.element; });
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
        ReorderableGroup.prototype.initialize = /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._instance) {
                    return;
                }
                this._instance = dragula(this._containers.map(function (c) { return c.element; }), this._config);
                this._instance.on('drag', function (element, source) {
                    _this.drag.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        source: source
                    });
                });
                this._instance.on('dragend', function (element) {
                    _this.dragEnd.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('drop', function (element, target, source, sibling) {
                    _this.drop.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        target: target,
                        source: source,
                        sibling: sibling
                    });
                });
                this._instance.on('cancel', function (element) {
                    _this.cancel.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('cloned', function (clone, element, type) {
                    _this.cloned.emit({
                        clone: clone,
                        element: element,
                        type: type
                    });
                });
            };
        /**
         * Destroys the dragula instance.
         */
        /**
         * Destroys the dragula instance.
         * @return {?}
         */
        ReorderableGroup.prototype.destroy = /**
         * Destroys the dragula instance.
         * @return {?}
         */
            function () {
                if (this._instance) {
                    this._instance.destroy();
                    this._instance = null;
                }
            };
        /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
        ReorderableGroup.prototype.canMove = /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
            function (element, containerElement, handle) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        if (container.element.isSameNode(containerElement)) {
                            return container.canMove(element, containerElement, handle);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                var e_2, _c;
            };
        return ReorderableGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableDirective = (function () {
        function ReorderableDirective(_elementRef, _renderer, _service) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._service = _service;
            this.reorderingDisabled = false;
            this.reorderableModelChange = new core.EventEmitter();
            this.reorderStart = new core.EventEmitter();
            this.reorderCancel = new core.EventEmitter();
            this.reorderEnd = new core.EventEmitter();
            this.dragging = false;
            this._subscriptions = new Subscription.Subscription();
        }
        /**
         * Initialise dragula and bind to all the required events
         */
        /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnInit = /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
            function () {
                var _this = this;
                // If no group name then generate a unique one for this instance only
                if (!this.reorderableGroup) {
                    this.reorderableGroup = this._service.getUniqueGroupName();
                }
                this._container = {
                    element: this._elementRef.nativeElement,
                    getModelFromElement: this.getModelFromElement.bind(this),
                    canMove: this.canMove.bind(this)
                };
                // Register for drag events on this element
                var /** @type {?} */ group = this._service.register(this.reorderableGroup, this._container);
                this._subscriptions.add(group.drag.subscribe(this.onDrag.bind(this)));
                this._subscriptions.add(group.dragEnd.subscribe(this.onDragEnd.bind(this)));
                this._subscriptions.add(group.drop.subscribe(this.onDrop.bind(this)));
                this._subscriptions.add(group.cancel.subscribe(function (event) { return _this.reorderCancel.emit({ element: event.element, model: event.model }); }));
                this._subscriptions.add(group.cloned.subscribe(this.onClone.bind(this)));
            };
        /**
         * @return {?}
         */
        ReorderableDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._service.initialize(this.reorderableGroup);
            };
        /**
         * We need to destroy the dragula instance on component destroy
         */
        /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnDestroy = /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
            function () {
                this._service.unregister(this.reorderableGroup, this._container);
                this._subscriptions.unsubscribe();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrag = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dragging = true;
                this.reorderStart.emit({ element: event.element, model: event.model });
            };
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         */
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrop = /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if there is no provided module we can skip this
                if (!this.reorderableModel) {
                    return;
                }
                var /** @type {?} */ changed = false;
                if (event.source.isSameNode(this._elementRef.nativeElement)) {
                    // remove this model from the list of models
                    var /** @type {?} */ index = this.reorderableModel.indexOf(event.model);
                    if (index >= 0) {
                        this.reorderableModel.splice(index, 1);
                        changed = true;
                    }
                }
                if (event.target.isSameNode(this._elementRef.nativeElement)) {
                    // get the position of sibling element
                    var /** @type {?} */ index = event.sibling && !event.sibling.classList.contains('gu-mirror') ?
                        this.reorderableModel.indexOf(this.getModelFromElement(event.sibling)) :
                        this.reorderableModel.length;
                    // insert the model at its new location
                    this.reorderableModel.splice(index, 0, event.model);
                    changed = true;
                }
                // Emit event if any changes were made
                if (changed) {
                    this.reorderableModelChange.emit(this.reorderableModel);
                }
            };
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         */
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
        ReorderableDirective.prototype.getModelFromElement = /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
            function (element) {
                var /** @type {?} */ model = this.models.find(function (_model) { return _model.elementRef.nativeElement === element; });
                if (!model) {
                    return null;
                }
                return model.uxReorderableModel;
            };
        /**
         * When we finish dragging remove the utillity class from the element being moved
         */
        /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDragEnd = /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dragging = false;
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this._renderer.removeClass(event.element, 'ux-reorderable-moving');
                    this.reorderEnd.emit({
                        element: event.element,
                        model: event.model
                    });
                }
            };
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         */
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onClone = /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this.setTableCellWidths(event.element, event.clone);
                    this.captureCanvases(event.element, event.clone);
                    this._renderer.addClass(event.element, 'ux-reorderable-moving');
                }
            };
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         */
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
        ReorderableDirective.prototype.canMove = /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
            function (element, container, handle) {
                if (this.reorderingDisabled) {
                    return false;
                }
                return this.handles.length === 0 ? true : !!this.handles.find(function (_handle) { return _handle.nativeElement === handle; });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.setTableCellWidths = /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // if it is not a table row then skip this
                if (source.tagName !== 'TR') {
                    return;
                }
                // find any immediate td children and fix their width
                var /** @type {?} */ sourceCells = (Array.from(source.children));
                var /** @type {?} */ targetCells = (Array.from(target.children));
                // fix the width of these cells
                sourceCells.forEach(function (cell, idx) { return targetCells[idx].style.minWidth = getComputedStyle(cell).getPropertyValue('width'); });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.captureCanvases = /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // find all child canvas elements
                var /** @type {?} */ sourceCanvases = Array.from(source.querySelectorAll('canvas'));
                var /** @type {?} */ targetCanvases = Array.from(target.querySelectorAll('canvas'));
                // replicate the canvas content
                targetCanvases.map(function (canvas) { return canvas.getContext('2d'); })
                    .forEach(function (context, idx) { return context.drawImage(sourceCanvases[idx], 0, 0); });
            };
        ReorderableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderable]'
                    },] }
        ];
        /** @nocollapse */
        ReorderableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: ReorderableService }
            ];
        };
        ReorderableDirective.propDecorators = {
            reorderableModel: [{ type: core.Input }],
            reorderableGroup: [{ type: core.Input }],
            reorderingDisabled: [{ type: core.Input }],
            reorderableModelChange: [{ type: core.Output }],
            reorderStart: [{ type: core.Output }],
            reorderCancel: [{ type: core.Output }],
            reorderEnd: [{ type: core.Output }],
            handles: [{ type: core.ContentChildren, args: [ReorderableHandleDirective, { read: core.ElementRef, descendants: true },] }],
            models: [{ type: core.ContentChildren, args: [ReorderableModelDirective,] }],
            dragging: [{ type: core.HostBinding, args: ['class.ux-reorderable-container-moving',] }]
        };
        return ReorderableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModule = (function () {
        function ReorderableModule() {
        }
        ReorderableModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        exports: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        providers: [
                            ReorderableService
                        ]
                    },] }
        ];
        return ReorderableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetSelect = (function () {
        function FacetSelect(facet) {
            this.facet = facet;
        }
        return FacetSelect;
    }());
    var FacetDeselect = (function () {
        function FacetDeselect(facet) {
            this.facet = facet;
        }
        return FacetDeselect;
    }());
    var FacetDeselectAll = (function () {
        function FacetDeselectAll() {
        }
        return FacetDeselectAll;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetContainerComponent = (function () {
        function FacetContainerComponent(_announcer) {
            this._announcer = _announcer;
            this.header = 'Selected:';
            this.clearTooltip = 'Clear All';
            this.emptyText = 'No Items';
            this.facets = [];
            this.facetsReorderable = false;
            this.facetsChange = new core.EventEmitter();
            this.events = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.events.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.selectFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // push the facet on to the list
                this.facets.push(facet);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetSelect(facet));
            };
        /**
         * @param {?} facet
         * @param {?=} tag
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectFacet = /**
         * @param {?} facet
         * @param {?=} tag
         * @return {?}
         */
            function (facet, tag) {
                // find the index of the item in the selected array
                var /** @type {?} */ idx = this.facets.findIndex(function (selectedFacet) { return facet === selectedFacet; });
                // if match there was no match then finish
                if (idx === -1) {
                    return;
                }
                // remove the last item
                this.facets.splice(idx, 1);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselect(facet));
                // announce the facet removal
                this._announcer.announce("Option " + facet.title + " deselected.", 'assertive');
                // focus another tag if there is one
                if (tag) {
                    var /** @type {?} */ sibling = tag.previousElementSibling || tag.nextElementSibling;
                    // if there is a sibling then focus it
                    if (sibling) {
                        ((sibling)).focus();
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectAllFacets = /**
         * @return {?}
         */
            function () {
                // empty the selected array
                this.facets = [];
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselectAll());
                // announce the facet removal
                this._announcer.announce("All options deselected.", 'assertive');
            };
        /**
         * @param {?} _index
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.trackBy = /**
         * @param {?} _index
         * @param {?} facet
         * @return {?}
         */
            function (_index, facet) {
                return facet.id || facet.title;
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftRight = /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, 1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved down.");
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftLeft = /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, -1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved up.");
            };
        /**
         * @param {?} facet
         * @param {?} distance
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftFacet = /**
         * @param {?} facet
         * @param {?} distance
         * @return {?}
         */
            function (facet, distance) {
                var /** @type {?} */ index = this.facets.indexOf(facet);
                var /** @type {?} */ target = index + distance;
                // Ensure the move is valid
                if (target < 0 || target === this.facets.length) {
                    return;
                }
                // Perform the move
                this.facets.splice(index, 1);
                this.facets.splice(target, 0, facet);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetContainerComponent.prototype.triggerEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.events.next(event);
            };
        FacetContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-container',
                        template: "<!-- Display Any Selected Facets -->\n<div class=\"facets-selected-container\">\n\n    <!-- Display Title an Clear Button -->\n    <div class=\"facets-selected-header-container\">\n\n        <!-- Show The Selected Text -->\n        <span class=\"facets-selected-header-label\">{{ header }}</span>\n\n        <!-- Add a Clear Button -->\n        <button class=\"btn btn-link btn-icon button-secondary\"\n            tabindex=\"0\"\n            [attr.aria-label]=\"clearTooltip\"\n            [uxTooltip]=\"clearTooltip\"\n            placement=\"left\"\n            (click)=\"deselectAllFacets()\"\n            *ngIf=\"facets.length > 0\">\n\n            <svg class=\"facets-selected-clear-graphic\" focusable=\"false\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n                <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n                <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n                <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n                <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n                <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n            </svg>\n        </button>\n\n    </div>\n\n    <!-- Display Tags For Selected Items -->\n    <div class=\"facets-selected-list\"\n        uxReorderable\n        role=\"list\"\n        [reorderingDisabled]=\"!facetsReorderable\"\n        [(reorderableModel)]=\"facets\"\n        (reorderableModelChange)=\"facetsChange.emit(facets)\">\n\n        <!-- Show Selected Tags -->\n        <div #tag\n            class=\"facet-selected-tag\"\n            role=\"listitem\"\n            tabindex=\"0\"\n            uxReorderableHandle\n            *ngFor=\"let facet of facets; trackBy: trackBy\"\n            [attr.aria-label]=\"facet.title\"\n            [uxReorderableModel]=\"facet\"\n            (mousedown)=\"tag.focus()\"\n            (keydown.ArrowRight)=\"shiftRight(facet, tag)\"\n            (keydown.ArrowLeft)=\"shiftLeft(facet, tag)\">\n\n            <!-- Display Label -->\n            <span class=\"facet-selected-tag-label\">{{ facet.title }}</span>\n\n            <!-- Display Remove Icon -->\n            <button class=\"facet-selected-remove-btn\"\n                i18n-aria-label\n                aria-label=\"Deselect Facet\"\n                (click)=\"deselectFacet(facet, tag)\">\n\n                <i class=\"hpe-icon hpe-close\"></i>\n            </button>\n        </div>\n\n    </div>\n\n    <!-- Show Message Here if No Facets Selected -->\n    <p class=\"facets-selected-none-label\" *ngIf=\"emptyText && facets.length === 0\">{{ emptyText }}</p>\n\n</div>\n\n<!-- Any Facet Elements Should be Added Here By User -->\n<div class=\"facets-region\">\n    <ng-content></ng-content>\n</div>"
                    }] }
        ];
        /** @nocollapse */
        FacetContainerComponent.ctorParameters = function () {
            return [
                { type: a11y.LiveAnnouncer }
            ];
        };
        FacetContainerComponent.propDecorators = {
            header: [{ type: core.Input }],
            clearTooltip: [{ type: core.Input }],
            emptyText: [{ type: core.Input }],
            facets: [{ type: core.Input }],
            facetsReorderable: [{ type: core.Input }],
            facetsChange: [{ type: core.Output }],
            events: [{ type: core.Output }]
        };
        return FacetContainerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetBaseComponent = (function () {
        function FacetBaseComponent(facetContainer, _elementRef) {
            var _this = this;
            this.facetContainer = facetContainer;
            this._elementRef = _elementRef;
            this.selected = [];
            this.selectedChange = new core.EventEmitter();
            this.events = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
            if (facetContainer) {
                // subscribe to any deselect events from the facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselect; }), operators.filter(function (event) { return !!_this.selected.find(function (facet) { return facet === event.facet; }); }), operators.takeUntil(this._onDestroy)).subscribe(function (event) { return _this.deselectFacet(event.facet); });
                // subscribe to any deselect all events from facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselectAll; }), operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.deselectAll(); });
            }
        }
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // check if there should be any facets initially selected
                if (this.facetContainer) {
                    this.selected.forEach(function (facet) { return _this.facetContainer.selectFacet(facet); });
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.selectFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // if the facet is disabled it should not be selected
                if (facet.disabled) {
                    return;
                }
                // add the facet to the list of selected facets
                this.selected.push(facet);
                // send the new value to the event emitter
                this.selectedChange.emit(this.selected);
                // fire the event to the observable
                this.triggerEvent(new FacetSelect(facet));
                // tell the facet container about the selected facet
                if (this.facetContainer) {
                    this.facetContainer.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // find facet to remove
                var /** @type {?} */ index = this.selected.findIndex(function (selectedFacet) { return selectedFacet === facet; });
                // only continue if facet is found
                if (index !== -1) {
                    // remove the facet from the selected list
                    this.selected.splice(index, 1);
                    // emit the changes to selected event emitter
                    this.selectedChange.emit(this.selected);
                    // fire the event to the observable
                    this.triggerEvent(new FacetDeselect(facet));
                    // deselect the facet in the facet container
                    if (this.facetContainer) {
                        this.facetContainer.deselectFacet(facet);
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectAll = /**
         * @return {?}
         */
            function () {
                // remove all selected facets
                this.selected = [];
                // fire the event to the observable
                this.triggerEvent(new FacetDeselectAll());
                // emit the changes to the selected event emitter
                this.selectedChange.emit(this.selected);
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.toggleFacetSelection = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // if the facet is selected then deselect - otherwise select it
                if (this.isFacetSelected(facet)) {
                    this.deselectFacet(facet);
                }
                else {
                    this.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.isFacetSelected = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // determine if a facet is currently selected
                return !!this.selected.find(function (selectedFacet) { return selectedFacet === facet; });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetBaseComponent.prototype.triggerEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.events.next(event);
            };
        FacetBaseComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-base',
                        template: ''
                    }] }
        ];
        /** @nocollapse */
        FacetBaseComponent.ctorParameters = function () {
            return [
                { type: FacetContainerComponent, decorators: [{ type: core.Host }] },
                { type: core.ElementRef }
            ];
        };
        FacetBaseComponent.propDecorators = {
            selected: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            events: [{ type: core.Output }]
        };
        return FacetBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetHeaderComponent = (function () {
        function FacetHeaderComponent() {
            this.canExpand = true;
            this.expanded = true;
            this.expandedChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FacetHeaderComponent.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                // if not expandable then do nothing
                if (this.canExpand) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        FacetHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-header',
                        template: "<span class=\"facet-header-title\">{{ header }}</span>\n<span class=\"hpe-icon\" [class.hpe-down]=\"expanded\" [class.hpe-previous]=\"!expanded\" *ngIf=\"canExpand\"></span>",
                        host: {
                            'role': 'button',
                            'tabindex': '0',
                            '(click)': 'toggleExpand()',
                            '(keyup.enter)': 'toggleExpand()',
                            '[attr.aria-expanded]': 'expanded',
                            '[attr.aria-label]': 'header + \' Facet: Activate to \' + (expanded ? \'collapse\' : \'expand\')'
                        }
                    }] }
        ];
        FacetHeaderComponent.propDecorators = {
            header: [{ type: core.Input }],
            canExpand: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }]
        };
        return FacetHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetCheckListItemComponent = (function () {
        function FacetCheckListItemComponent() {
            this.facet = null;
            this.selected = false;
            this.tabbable = false;
            this.selectedChange = new core.EventEmitter();
            this.itemFocus = new core.EventEmitter();
            this.itemBlur = new core.EventEmitter();
        }
        Object.defineProperty(FacetCheckListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.getLabel = /**
         * @return {?}
         */
            function () {
                return this.facet ? this.facet.title : '';
            };
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.option.nativeElement.focus();
            };
        FacetCheckListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-check-list-item',
                        template: "<div #option\n    class=\"facet-check-list-item\"\n    [class.facet-active]=\"selected\"\n    [attr.aria-checked]=\"selected\"\n    role=\"option\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (blur)=\"itemBlur.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    [class.disabled]=\"facet?.disabled\">\n\n    <!-- Show check icon to indicate the state -->\n    <span class=\"facet-check-list-item-check\" aria-hidden=\"true\">\n        <span class=\"hpe-icon hpe-active\"></span>\n    </span>\n\n    <!-- Display the title -->\n    <span class=\"facet-check-list-item-title\">\n        {{ facet?.title }}\n    </span>\n\n    <!-- Display the count if specified -->\n    <span class=\"facet-check-list-item-count\"\n        *ngIf=\"facet?.count !== undefined\"\n        attr.aria-label=\"{{ facet?.count }}\"\n        i18n-aria-label>\n        ({{ facet?.count }})\n    </span>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        FacetCheckListItemComponent.propDecorators = {
            facet: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            tabbable: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            itemFocus: [{ type: core.Output }],
            itemBlur: [{ type: core.Output }],
            option: [{ type: core.ViewChild, args: ['option',] }]
        };
        return FacetCheckListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetCheckListComponent = (function (_super) {
        __extends(FacetCheckListComponent, _super);
        function FacetCheckListComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.facets = [];
            _this.scrollbar = true;
            _this.expanded = true;
            _this.isFocused = false;
            _this.activeIndex = 0;
            return _this;
        }
        /**
         * @return {?}
         */
        FacetCheckListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._focusKeyManager = new a11y.FocusKeyManager(this.options)
                    .withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetCheckListComponent.prototype.onFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetCheckListComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetCheckListComponent.prototype.toggleFacet = /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
            function (index, facet) {
                this.toggleFacetSelection(facet);
                this._focusKeyManager.setActiveItem(index);
            };
        FacetCheckListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-check-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<!-- Create a container which will show when section is expanded -->\n<div class=\"facet-check-list-container\"\n    tabindex=\"-1\"\n    role=\"listbox\"\n    [class.facet-check-list-scrollbar]=\"scrollbar\"\n    [class.facet-check-list-scrollbar-focused]=\"isFocused\"\n    *ngIf=\"expanded\">\n\n    <!-- Iterate through each possible facet -->\n    <ux-facet-check-list-item *ngFor=\"let facet of facets; let index = index\"\n        [facet]=\"facet\"\n        [tabbable]=\"activeIndex === index\"\n        [selected]=\"isFacetSelected(facet)\"\n        (selectedChange)=\"toggleFacet(index, facet)\"\n        (keydown)=\"onKeydown($event)\"\n        (itemFocus)=\"isFocused = true; onFocus(index)\"\n        (itemBlur)=\"isFocused = false\">\n    </ux-facet-check-list-item>\n\n</div>"
                    }] }
        ];
        FacetCheckListComponent.propDecorators = {
            facets: [{ type: core.Input }],
            header: [{ type: core.Input }],
            scrollbar: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            options: [{ type: core.ViewChildren, args: [FacetCheckListItemComponent,] }]
        };
        return FacetCheckListComponent;
    }(FacetBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetTypeaheadListItemComponent = (function () {
        function FacetTypeaheadListItemComponent() {
            this.selected = false;
            this.simplified = false;
            this.tabbable = false;
            this.itemFocus = new core.EventEmitter();
            this.selectedChange = new core.EventEmitter();
        }
        Object.defineProperty(FacetTypeaheadListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.getLabel = /**
         * @return {?}
         */
            function () {
                return this.facet ? this.facet.title : null;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.option.nativeElement.focus();
            };
        FacetTypeaheadListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-typeahead-list-item',
                        template: "<div #option\n    role=\"option\"\n    class=\"facet-typeahead-list-selected-option\"\n    [attr.aria-checked]=\"selected\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\">\n\n    <ux-checkbox [clickable]=\"false\" [value]=\"selected\" [simplified]=\"simplified\" [tabindex]=\"-1\" [disabled]=\"disabled\">\n        <span class=\"facet-typeahead-list-selected-option-title\">{{ facet?.title }}</span>\n        <span class=\"facet-typeahead-list-selected-option-count\">({{ facet?.count }})</span>\n    </ux-checkbox>\n\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        FacetTypeaheadListItemComponent.propDecorators = {
            facet: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            tabbable: [{ type: core.Input }],
            itemFocus: [{ type: core.Output }],
            selectedChange: [{ type: core.Output }],
            option: [{ type: core.ViewChild, args: ['option',] }]
        };
        return FacetTypeaheadListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$3 = 1;
    var FacetTypeaheadListComponent = (function (_super) {
        __extends(FacetTypeaheadListComponent, _super);
        function FacetTypeaheadListComponent(typeaheadKeyService, facetContainer, elementRef, _announcer) {
            var _this = _super.call(this, facetContainer, elementRef) || this;
            _this.typeaheadKeyService = typeaheadKeyService;
            _this._announcer = _announcer;
            _this.expanded = true;
            _this.suggestions = [];
            _this.simplified = true;
            _this.query$ = new BehaviorSubject.BehaviorSubject('');
            _this.loading = false;
            _this.activeIndex = 0;
            _this.typeaheadId = "ux-facet-typeahead-" + uniqueId$3++;
            _this.typeaheadOpen = false;
            _this.typeaheadOptions = [];
            _this._config = { placeholder: '', maxResults: 50, minCharacters: 1 };
            return _this;
        }
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "typeaheadConfig", {
            get: /**
             * @return {?}
             */ function () {
                return this._config;
            },
            set: /**
             * @param {?} config
             * @return {?}
             */ function (config) {
                this._config = __assign({ placeholder: '', maxResults: 50, minCharacters: 1 }, config);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // set up search query subscription
                this.query$.pipe(operators.takeUntil(this._onDestroy), operators.tap(function () {
                    _this.loading = true;
                    _this.typeaheadOptions = [];
                }), operators.mergeMap(function () {
                    return _this.getFacetObservable().pipe(operators.map(function (facets) {
                        return facets.filter(function (facet) { return !facet.disabled && !_this.selected.find(function (selectedFacet) { return selectedFacet === facet; }); })
                            .slice(0, _this._config.maxResults);
                    }));
                })).subscribe(function (facets) {
                    _this.loading = false;
                    _this.typeaheadOptions = facets;
                });
                this._focusKeyManager = new a11y.FocusKeyManager(this.options).withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.toggleFacet = /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
            function (index, facet) {
                this.toggleFacetSelection(facet);
                this._focusKeyManager.setActiveItem(index);
            };
        /** Only show typeahead if we have enough characters */
        /**
         * Only show typeahead if we have enough characters
         * @param {?=} query
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.updateTypeahead = /**
         * Only show typeahead if we have enough characters
         * @param {?=} query
         * @return {?}
         */
            function (query) {
                if (query === void 0) {
                    query = '';
                }
                this.typeaheadOpen = query.length >= this._config.minCharacters;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.getFacetObservable = /**
         * @return {?}
         */
            function () {
                return this.facets instanceof Observable.Observable ? this.facets : of.of(this.facets);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.select = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // check to make sure that the item is not currently selected
                if (this.selected.find(function (facet) { return facet === event.option; })) {
                    return;
                }
                // select the facet
                this.selectFacet(event.option);
                // clear the typeahead
                this.query$.next('');
                // announce the selected facet
                this._announcer.announce((((event.option))).title + " selected.");
            };
        FacetTypeaheadListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-typeahead-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<div class=\"facet-typeahead-list-container\" role=\"listbox\" *ngIf=\"expanded\">\n\n    <div class=\"facet-typeahead-list-selected-container\" tabindex=\"-1\" *ngIf=\"suggestions?.length > 0\">\n\n        <ux-facet-typeahead-list-item\n            *ngFor=\"let facet of suggestions; let index = index\"\n            [facet]=\"facet\"\n            [tabbable]=\"activeIndex === index\"\n            [selected]=\"isFacetSelected(facet)\"\n            (selectedChange)=\"toggleFacet(index, facet)\"\n            (keydown)=\"onKeydown($event)\"\n            (itemFocus)=\"onFocus(index)\">\n        </ux-facet-typeahead-list-item>\n\n    </div>\n\n    <div class=\"facet-typeahead-list-control\">\n\n        <!-- Create Typeahead Control -->\n        <input type=\"text\"\n            class=\"form-control\"\n            [placeholder]=\"typeaheadConfig?.placeholder\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            aria-autocomplete=\"list\"\n            aria-multiline=\"false\"\n            [attr.aria-controls]=\"typeaheadId\"\n            [ngModel]=\"query$ | async\"\n            (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n            (keydown)=\"typeaheadKeyService.handleKey($event, typeahead)\"\n            (blur)=\"typeaheadOpen = false\">\n\n        <ux-typeahead #typeahead\n            [id]=\"typeaheadId\"\n            [(open)]=\"typeaheadOpen\"\n            [loading]=\"loading\"\n            display=\"title\"\n            [options]=\"typeaheadOptions\"\n            [optionTemplate]=\"facetOptionTemplate\"\n            [selectOnEnter]=\"true\"\n            (optionSelected)=\"select($event)\"\n            (highlightedElementChange)=\"highlightedElement = $event\">\n        </ux-typeahead>\n\n    </div>\n\n</div>\n\n<ng-template #facetOptionTemplate let-option=\"option\" let-api=\"api\">\n    <p class=\"facet-typeahead-list-option\" [attr.aria-label]=\"option.title\">\n        <span [innerHTML]=\"option.title | facetTypeaheadHighlight: (query$ | async)\"></span>\n        <span class=\"facet-typeahead-list-option-count\"\n            *ngIf=\"option.count\">\n            ({{ option.count }})\n        </span>\n    </p>\n</ng-template>"
                    }] }
        ];
        /** @nocollapse */
        FacetTypeaheadListComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService },
                { type: FacetContainerComponent },
                { type: core.ElementRef },
                { type: a11y.LiveAnnouncer }
            ];
        };
        FacetTypeaheadListComponent.propDecorators = {
            facets: [{ type: core.Input }],
            header: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            suggestions: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            typeaheadConfig: [{ type: core.Input }],
            options: [{ type: core.ViewChildren, args: [FacetTypeaheadListItemComponent,] }]
        };
        return FacetTypeaheadListComponent;
    }(FacetBaseComponent));
    var FacetTypeaheadHighlight = (function () {
        function FacetTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FacetTypeaheadHighlight.prototype.transform = /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
            function (value, searchQuery) {
                var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"facet-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FacetTypeaheadHighlight.decorators = [
            { type: core.Pipe, args: [{
                        name: 'facetTypeaheadHighlight'
                    },] }
        ];
        return FacetTypeaheadHighlight;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$1 = [
        FacetContainerComponent,
        FacetHeaderComponent,
        FacetBaseComponent,
        FacetCheckListComponent,
        FacetCheckListItemComponent,
        FacetTypeaheadListComponent,
        FacetTypeaheadListItemComponent,
        FacetTypeaheadHighlight
    ];
    var FacetsModule = (function () {
        function FacetsModule() {
        }
        FacetsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            common.CommonModule,
                            forms.FormsModule,
                            CheckboxModule,
                            TooltipModule,
                            ReorderableModule,
                            TypeaheadModule
                        ],
                        exports: DECLARATIONS$1,
                        declarations: DECLARATIONS$1
                    },] }
        ];
        return FacetsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Facet = (function () {
        function Facet(title, data, count, disabled, id) {
            if (data === void 0) {
                data = {};
            }
            if (disabled === void 0) {
                disabled = false;
            }
            this.title = title;
            this.data = data;
            this.count = count;
            this.disabled = disabled;
            this.id = id;
        }
        return Facet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterAddEvent = (function () {
        function FilterAddEvent(filter$$1) {
            this.filter = filter$$1;
        }
        return FilterAddEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterRemoveAllEvent = (function () {
        function FilterRemoveAllEvent() {
        }
        return FilterRemoveAllEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterRemoveEvent = (function () {
        function FilterRemoveEvent(filter$$1) {
            this.filter = filter$$1;
        }
        return FilterRemoveEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterService = (function () {
        function FilterService() {
            /**
             * The list of active filters
             */
            this.filters$ = new BehaviorSubject.BehaviorSubject([]);
            /**
             * Emit all the events when they occur
             */
            this.events$ = new Subject.Subject();
        }
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterService.prototype.add = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter$$1) {
                // if the filter is already selected or it is the intial filter then do nothing
                if (this.isSelected(filter$$1) || filter$$1.initial) {
                    return;
                }
                // update the list of active filters
                this.filters$.next(__spread(this.filters$.value, [filter$$1]));
                // emit the event
                this.events$.next(new FilterAddEvent(filter$$1));
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterService.prototype.remove = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter$$1) {
                // if the filter is not selected then do nothing
                if (!this.isSelected(filter$$1)) {
                    return;
                }
                // update the list of active filters
                this.filters$.next(this.filters$.value.filter(function (_filter) { return _filter !== filter$$1; }));
                // emit the event
                this.events$.next(new FilterRemoveEvent(filter$$1));
            };
        /**
         * @return {?}
         */
        FilterService.prototype.removeAll = /**
         * @return {?}
         */
            function () {
                // empty the list of active filters
                this.filters$.next([]);
                // emit the event
                this.events$.next(new FilterRemoveAllEvent());
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterService.prototype.isSelected = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter$$1) {
                return this.filters$.value.indexOf(filter$$1) > -1;
            };
        FilterService.decorators = [
            { type: core.Injectable }
        ];
        return FilterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterContainerComponent = (function () {
        function FilterContainerComponent(filterService) {
            var _this = this;
            this.filterService = filterService;
            /**
             * Emit when the active filters chance
             */
            this.filtersChange = new core.EventEmitter();
            /**
             * Emit when a specific event occurs
             */
            this.events = new core.EventEmitter();
            /**
             * Unsubscribe from the subscriptions on destroy
             */
            this._onDestroy = new Subject.Subject();
            // subscribe to changes to the active filters
            filterService.filters$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged())
                .subscribe(function (filters) { return _this.filtersChange.emit(filters); });
            // relay any events to the event emitter
            this.filterService.events$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return _this.events.emit(event); });
        }
        Object.defineProperty(FilterContainerComponent.prototype, "filters", {
            /** Allow filters to set from outside the component */
            set: /**
             * Allow filters to set from outside the component
             * @param {?} filters
             * @return {?}
             */ function (filters) { this.filterService.filters$.next(filters); },
            enumerable: true,
            configurable: true
        });
        /** Destroy all subscriptions */
        /**
         * Destroy all subscriptions
         * @return {?}
         */
        FilterContainerComponent.prototype.ngOnDestroy = /**
         * Destroy all subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        FilterContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-container',
                        template: "<ng-content></ng-content>\n\n<!-- Add a Clear Button -->\n<button class=\"btn btn-link btn-icon btn-secondary m-l-xs\"\n    tabindex=\"0\"\n    aria-label=\"Clear all filters\"\n    i18n-aria-label\n    *ngIf=\"(filterService.filters$ | async).length > 0\"\n    [uxTooltip]=\"clearTooltip || 'Clear All'\"\n    (click)=\"filterService.removeAll()\">\n\n    <svg class=\"filter-selected-clear-graphic\" width=\"100%\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n        <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n        <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n        <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n        <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n        <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n    </svg>\n\n</button>",
                        providers: [FilterService]
                    }] }
        ];
        /** @nocollapse */
        FilterContainerComponent.ctorParameters = function () {
            return [
                { type: FilterService }
            ];
        };
        FilterContainerComponent.propDecorators = {
            filters: [{ type: core.Input }],
            clearTooltip: [{ type: core.Input }],
            filtersChange: [{ type: core.Output }],
            events: [{ type: core.Output }]
        };
        return FilterContainerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @deprecated
     * This should no longer be used as we now have the FilterService
     * which is easier to use than this base component.
     */
    var FilterBaseComponent = (function () {
        function FilterBaseComponent(filtersContainer, _announcer) {
            this.filtersContainer = filtersContainer;
            this._announcer = _announcer;
            this._subscription = filtersContainer.events.pipe(operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; })).subscribe(this.removeFilter.bind(this));
        }
        /**
         * @return {?}
         */
        FilterBaseComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.addFilter = /**
         * @param {?} _filter
         * @return {?}
         */
            function (_filter) {
                if (!_filter.initial) {
                    this.filtersContainer.filterService.add(_filter);
                    this._announcer.announce("Filter " + _filter.name + " selected.");
                }
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.removeFilter = /**
         * @param {?} _filter
         * @return {?}
         */
            function (_filter) {
                if (!_filter) {
                    return;
                }
                this.filtersContainer.filterService.remove(_filter);
                this._announcer.announce("Filter " + _filter.name + " deselected.");
            };
        FilterBaseComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-filter-base'
                    },] }
        ];
        /** @nocollapse */
        FilterBaseComponent.ctorParameters = function () {
            return [
                { type: FilterContainerComponent, decorators: [{ type: core.Host }] },
                { type: a11y.LiveAnnouncer }
            ];
        };
        FilterBaseComponent.propDecorators = {
            filters: [{ type: core.Input }]
        };
        return FilterBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterDropdownComponent = (function () {
        function FilterDropdownComponent(_filterService) {
            var _this = this;
            this._filterService = _filterService;
            /**
             * The list of items to display in the dropdown
             */
            this.filters = [];
            this._onDestroy = new Subject.Subject();
            _filterService.events$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; }))
                .subscribe(function () { return _this.removeFilter(); });
            // ensure that the current selected filter is still selected when the active filters change
            _filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                if (_this.selected && filters.indexOf(_this.selected) === -1) {
                    _this.removeFilter();
                }
            });
        }
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.selected = this.initial;
                // check to see if any of the filters have been preselected or changes to selected filters
                this._filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                    filters.forEach(function (filter$$1) {
                        if (_this.filters.indexOf(filter$$1) !== -1) {
                            _this.selected = filter$$1;
                        }
                    });
                });
            };
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} filter
         * @param {?} event
         * @return {?}
         */
        FilterDropdownComponent.prototype.selectFilter = /**
         * @param {?} filter
         * @param {?} event
         * @return {?}
         */
            function (filter$$1, event) {
                this.removeFilter();
                this.selected = filter$$1;
                this._filterService.add(this.selected);
                event.stopPropagation();
                event.preventDefault();
            };
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.removeFilter = /**
         * @return {?}
         */
            function () {
                this._filterService.remove(this.selected);
                this.selected = this.initial;
            };
        FilterDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dropdown',
                        template: "<div class=\"btn-group\" dropdown [autoClose]=\"true\" #dropdown=\"bs-dropdown\">\n\n    <button\n        type=\"button\"\n        tabindex=\"0\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdown.isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdown.isOpen\"\n        class=\"filter-dropdown btn dropdown-toggle\"\n        [class.active]=\"selected !== initial\">\n        {{ selected?.title }}\n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n\n    <ul *dropdownMenu\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\"\n        class=\"dropdown-menu\" role=\"menu\">\n\n        <li class=\"dropdown-list-item\"\n            *ngFor=\"let filter of filters\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"listitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem\n                [attr.aria-selected]=\"filter === selected\"\n                (click)=\"selectFilter(filter, $event); dropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.enter)=\"selectFilter(filter, $event); dropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.escape)=\"menuNavigationToggle.focus()\">\n\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n            </a>\n        </li>\n    </ul>\n</div>"
                    }] }
        ];
        /** @nocollapse */
        FilterDropdownComponent.ctorParameters = function () {
            return [
                { type: FilterService }
            ];
        };
        FilterDropdownComponent.propDecorators = {
            filters: [{ type: core.Input }],
            initial: [{ type: core.Input }]
        };
        return FilterDropdownComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$4 = 1;
    var FilterDynamicComponent = (function () {
        function FilterDynamicComponent(typeaheadKeyService, _filterService, _elementRef) {
            var _this = this;
            this.typeaheadKeyService = typeaheadKeyService;
            this._filterService = _filterService;
            this._elementRef = _elementRef;
            /**
             * The list of possible filter options
             */
            this.filters = [];
            /**
             * Generate a unique id for the typeahead
             */
            this.typeaheadId = "ux-filter-dynamic-typeahead-" + uniqueId$4++;
            /**
             * Store the current search query
             */
            this.query$ = new BehaviorSubject.BehaviorSubject('');
            /**
             * Indicate whether or not the typeahead should be shown
             */
            this.showTypeahead = true;
            /**
             * Store the items that should be displayed in the typeahead
             */
            this.typeaheadItems = [];
            /**
             * Store the open state of the typeahead
             */
            this.typeaheadOpen = false;
            /**
             * The default options
             */
            this._defaultOptions = { placeholder: '', minCharacters: 3, maxResults: Infinity };
            /**
             * Store the user specified typeahead options
             */
            this._options = __assign({}, this._defaultOptions);
            /**
             * Unsubscribe from all subscriptions
             */
            this._onDestroy = new Subject.Subject();
            // listen for remove all events in which case we should deselect event initial filters
            _filterService.events$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; }))
                .subscribe(function () { return _this.removeFilter(); });
            // ensure that the current selected filter is still selected when the active filters change
            _filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                if (_this.selected && filters.indexOf(_this.selected) === -1) {
                    _this.removeFilter();
                }
            });
        }
        Object.defineProperty(FilterDynamicComponent.prototype, "options", {
            /** Get the options with the defaults for any missing options */
            get: /**
             * Get the options with the defaults for any missing options
             * @return {?}
             */ function () {
                return __assign({}, this._defaultOptions, this._options);
            },
            /** Specify the typeahead options */
            set: /**
             * Specify the typeahead options
             * @param {?} options
             * @return {?}
             */ function (options) { this._options = options; },
            enumerable: true,
            configurable: true
        });
        /** Set up the initial conditions */
        /**
         * Set up the initial conditions
         * @return {?}
         */
        FilterDynamicComponent.prototype.ngOnInit = /**
         * Set up the initial conditions
         * @return {?}
         */
            function () {
                var _this = this;
                // The initially selected item should be set the the specified initial item
                this.selected = this.initial;
                // watch for changes to the selected filters
                this._filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                    filters.forEach(function (filter$$1) {
                        if (_this.filters.indexOf(filter$$1) !== -1) {
                            _this.selected = filter$$1;
                        }
                    });
                });
                // get the items to be displayed in the typeahead
                this.typeaheadItems = this.getItems();
                // determine if we should show the typeahead control
                if (this.options && this.options.maxIndividualItems && this.options.maxIndividualItems + 1 >= this.filters.length) {
                    this.showTypeahead = false;
                }
            };
        /** Cleanup all subscriptions */
        /**
         * Cleanup all subscriptions
         * @return {?}
         */
        FilterDynamicComponent.prototype.ngOnDestroy = /**
         * Cleanup all subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Get the items to display in the typeahead based on the search query */
        /**
         * Get the items to display in the typeahead based on the search query
         * @return {?}
         */
        FilterDynamicComponent.prototype.getItems = /**
         * Get the items to display in the typeahead based on the search query
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ query = this.query$.value.toLowerCase();
                return this.filters.filter(function (item) { return item !== _this.initial && item.name.toLowerCase().indexOf(query) !== -1; })
                    .map(function (item) { return item.name; })
                    .slice(0, this._options.maxResults);
            };
        /** Handle selection of a typeahead options */
        /**
         * Handle selection of a typeahead options
         * @param {?} typeaheadOption
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectOption = /**
         * Handle selection of a typeahead options
         * @param {?} typeaheadOption
         * @return {?}
         */
            function (typeaheadOption) {
                // remove any current filters
                this.removeFilter();
                // find the filter that corresponds to the selected item
                this.selected = this.filters.find(function (_filter) { return _filter.name === typeaheadOption.value; });
                // store the selection in the service
                this._filterService.add(this.selected);
                // clear the search query
                this.query$.next('');
                // hide the dropdown
                this.dropdown.hide();
            };
        /** If a click occurred that was outside the dropdown then close the dropdown */
        /**
         * If a click occurred that was outside the dropdown then close the dropdown
         * @param {?} target
         * @return {?}
         */
        FilterDynamicComponent.prototype.clickOff = /**
         * If a click occurred that was outside the dropdown then close the dropdown
         * @param {?} target
         * @return {?}
         */
            function (target) {
                // if the click was outside the dropdown then close it
                if (!((this._elementRef.nativeElement)).contains(target)) {
                    this.query$.next('');
                    this.dropdown.hide();
                }
            };
        /** If a filter needs removed, and is not the initial filter then remove it */
        /**
         * If a filter needs removed, and is not the initial filter then remove it
         * @return {?}
         */
        FilterDynamicComponent.prototype.removeFilter = /**
         * If a filter needs removed, and is not the initial filter then remove it
         * @return {?}
         */
            function () {
                // check if the filter we want to remove is the initial filter
                if (this.selected !== this.initial) {
                    this._filterService.remove(this.selected);
                    this.selected = this.initial;
                }
                // clear the search query
                this.query$.next('');
            };
        /** Select a specific filter */
        /**
         * Select a specific filter
         * @param {?} filter
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectFilter = /**
         * Select a specific filter
         * @param {?} filter
         * @return {?}
         */
            function (filter$$1) {
                // clear any current filters
                this.removeFilter();
                // store the newly selected filter
                this.selected = filter$$1;
                // store the filter in the service
                this._filterService.add(this.selected);
            };
        /** Update typeahead items and visibility */
        /**
         * Update typeahead items and visibility
         * @param {?} query
         * @return {?}
         */
        FilterDynamicComponent.prototype.updateTypeahead = /**
         * Update typeahead items and visibility
         * @param {?} query
         * @return {?}
         */
            function (query) {
                this.typeaheadOpen = query.length >= this._options.minCharacters;
                this.typeaheadItems = this.getItems();
            };
        /** Select a filter from a typeahead item */
        /**
         * Select a filter from a typeahead item
         * @param {?} event
         * @return {?}
         */
        FilterDynamicComponent.prototype.select = /**
         * Select a filter from a typeahead item
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // find the filter with the matching name
                var /** @type {?} */ filter$$1 = this.filters.find(function (_filter) { return _filter.name === event.option; });
                if (filter$$1) {
                    this.selectFilter(filter$$1);
                }
            };
        FilterDynamicComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dynamic',
                        template: "<div class=\"btn-group ux-dynamic-filter\"\n    dropdown\n    [autoClose]=\"true\"\n    #dynamicDropdown=\"bs-dropdown\">\n\n    <button\n        type=\"button\"\n        tabindex=\"0\"\n        dropdownToggle\n        aria-haspopup=\"true\"\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dynamicDropdown.isOpen\"\n        [attr.aria-expanded]=\"dynamicDropdown.isOpen\"\n        [class.active]=\"selected !== initial\"\n        class=\"filter-dropdown btn dropdown-toggle\">\n        {{ selected?.title }}\n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li class=\"dropdown-list-item\"\n            *ngIf=\"showTypeahead\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"menuitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem\n                [attr.aria-selected]=\"initial === selected\"\n                (click)=\"removeFilter(); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.enter)=\"removeFilter(); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.escape)=\"menuNavigationToggle.focus()\">\n\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"initial === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ initial.name }}</span>\n            </a>\n        </li>\n\n        <li class=\"dropdown-list-item\"\n            *ngIf=\"selected !== initial && showTypeahead\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"menuitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem>\n                <i class=\"hpe-icon hpe-checkmark\"></i>\n                <span class=\"filter-dropdown-title\">{{ selected.name }}</span>\n            </a>\n        </li>\n\n        <hr>\n\n        <li *ngIf=\"showTypeahead\" class=\"typeahead-box\" role=\"none\">\n\n                <input type=\"text\"\n                    class=\"form-control\"\n                    [placeholder]=\"options?.placeholder\"\n                    [attr.aria-activedescendant]=\"highlightedElement?.id\"\n                    [attr.aria-controls]=\"typeaheadId\"\n                    aria-autocomplete=\"list\"\n                    aria-multiline=\"false\"\n                    [ngModel]=\"query$ | async\"\n                    (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n                    (keydown)=\"typeaheadKeyService.handleKey($event, typeahead); $event.stopPropagation();\"\n                    (keydown.enter)=\"$event.preventDefault()\"\n                    (blur)=\"typeaheadOpen = false\"\n                    (click)=\"$event.stopPropagation()\">\n\n                <ux-typeahead #typeahead\n                    [id]=\"typeaheadId\"\n                    [(open)]=\"typeaheadOpen\"\n                    display=\"title\"\n                    [selectOnEnter]=\"true\"\n                    [options]=\"typeaheadItems\"\n                    [optionTemplate]=\"filterOptionTemplate\"\n                    (optionSelected)=\"select($event); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                    (highlightedElementChange)=\"highlightedElement = $event\">\n                </ux-typeahead>\n        </li>\n\n        <ng-container *ngIf=\"!showTypeahead\">\n\n            <li class=\"dropdown-list-item\"\n                *ngFor=\"let filter of filters\"\n                role=\"none\">\n\n                <a class=\"dropdown-item\"\n                    role=\"menuitem\"\n                    tabindex=\"-1\"\n                    uxMenuNavigationItem\n                    [attr.aria-selected]=\"filter === selected\"\n                    (click)=\"selectFilter(filter); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                    (keydown.enter)=\"selectFilter(filter); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\">\n\n                    <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                    <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n                </a>\n            </li>\n\n        </ng-container>\n\n    </ul>\n</div>\n\n<ng-template #filterOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span [attr.aria-label]=\"option\" [innerHTML]=\"option | filterTypeaheadHighlight: (query$ | async)\"></span>\n</ng-template>"
                    }] }
        ];
        /** @nocollapse */
        FilterDynamicComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService },
                { type: FilterService },
                { type: core.ElementRef }
            ];
        };
        FilterDynamicComponent.propDecorators = {
            filters: [{ type: core.Input }],
            initial: [{ type: core.Input }],
            options: [{ type: core.Input }],
            dropdown: [{ type: core.ViewChild, args: [dropdown.BsDropdownDirective,] }],
            clickOff: [{ type: core.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return FilterDynamicComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterTypeaheadHighlight = (function () {
        function FilterTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FilterTypeaheadHighlight.prototype.transform = /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
            function (value, searchQuery) {
                var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"filter-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FilterTypeaheadHighlight.decorators = [
            { type: core.Pipe, args: [{
                        name: 'filterTypeaheadHighlight'
                    },] }
        ];
        return FilterTypeaheadHighlight;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationService = (function () {
        function MenuNavigationService() {
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
        }
        MenuNavigationService.decorators = [
            { type: core.Injectable }
        ];
        return MenuNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationItemDirective = (function () {
        function MenuNavigationItemDirective(service, _elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.activated = new core.EventEmitter();
            this._subscription = service.active$.pipe(operators.filter(function (item) { return item === _this; }))
                .subscribe(function () { return _this.setActive(); });
        }
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.setActive = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
                this.activated.emit();
            };
        MenuNavigationItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationItem]'
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationItemDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService },
                { type: core.ElementRef }
            ];
        };
        MenuNavigationItemDirective.propDecorators = {
            activated: [{ type: core.Output }]
        };
        return MenuNavigationItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationDirective = (function () {
        function MenuNavigationDirective(_service, _elementRef, _document) {
            this._service = _service;
            this._elementRef = _elementRef;
            this._document = _document;
            this.toggleButtonPosition = 'top';
            this.navigatedOut = new core.EventEmitter();
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(MenuNavigationDirective.prototype, "activeIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemsOrdered.indexOf(this._service.active$.value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.toggleButton) {
                    this.toggleButton.keyEnter.pipe(operators.takeUntil(this._onDestroy))
                        .subscribe(function () { return _this.focusFirst(); });
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.items.changes.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._itemsOrdered = _this.items.toArray(); });
                this._itemsOrdered = this.items.toArray();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.focusFirst = /**
         * @return {?}
         */
            function () {
                this.moveFirst();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Only handle events when focus in within the list of menu items
                if (!this._elementRef.nativeElement.contains(this._document.activeElement)) {
                    return;
                }
                var /** @type {?} */ handled = false;
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        this.movePrevious(event);
                        handled = true;
                        break;
                    case keycodes.DOWN_ARROW:
                        this.moveNext(event);
                        handled = true;
                        break;
                    case keycodes.LEFT_ARROW:
                        if (this.toggleButtonPosition === 'left') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case keycodes.RIGHT_ARROW:
                        if (this.toggleButtonPosition === 'right') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case keycodes.HOME:
                        this.moveFirst();
                        handled = true;
                        break;
                    case keycodes.END:
                        this.moveLast();
                        handled = true;
                        break;
                    case keycodes.ESCAPE:
                        this.navigatedOut.emit(event);
                        handled = true;
                        break;
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveNext = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex + 1;
                if (nextIndex < this._itemsOrdered.length) {
                    // Activate the next menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'bottom') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.movePrevious = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex - 1;
                if (nextIndex >= 0) {
                    // Activate the previous menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'top') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveFirst = /**
         * @return {?}
         */
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[0]);
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveLast = /**
         * @return {?}
         */
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[this._itemsOrdered.length - 1]);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveToToggleButton = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.toggleButton) {
                    this.toggleButton.focus();
                    this.toggleButton.menuOpen = false;
                }
                this.navigatedOut.emit(event);
            };
        MenuNavigationDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigation]',
                        exportAs: 'uxMenuNavigation',
                        providers: [MenuNavigationService]
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService },
                { type: core.ElementRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        MenuNavigationDirective.propDecorators = {
            toggleButton: [{ type: core.Input }],
            toggleButtonPosition: [{ type: core.Input }],
            navigatedOut: [{ type: core.Output }],
            items: [{ type: core.ContentChildren, args: [MenuNavigationItemDirective, { descendants: true },] }],
            keydownHandler: [{ type: core.HostListener, args: ['document:keydown', ['$event'],] }]
        };
        return MenuNavigationDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationToggleDirective = (function () {
        function MenuNavigationToggleDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.menuPosition = 'bottom';
            this.menuOpenChange = new core.EventEmitter();
            this.keyEnter = new core.EventEmitter();
        }
        Object.defineProperty(MenuNavigationToggleDirective.prototype, "menuOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._menuOpen = value;
                this.menuOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                if (this.isKeyMatch(event.which)) {
                    // Open the menu
                    this.menuOpen = true;
                    // Allow the menu to init, then send the event to give it focus
                    setTimeout(function () { return _this.keyEnter.emit(); });
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} key
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.isKeyMatch = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                switch (key) {
                    case keycodes.ENTER:
                    case keycodes.SPACE:
                        return true;
                    case keycodes.UP_ARROW:
                        return this.menuPosition === 'top';
                    case keycodes.DOWN_ARROW:
                        return this.menuPosition === 'bottom';
                    case keycodes.LEFT_ARROW:
                        return this.menuPosition === 'left';
                    case keycodes.RIGHT_ARROW:
                        return this.menuPosition === 'right';
                }
                return false;
            };
        MenuNavigationToggleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationToggle]',
                        exportAs: 'uxMenuNavigationToggle'
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationToggleDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        MenuNavigationToggleDirective.propDecorators = {
            menuOpen: [{ type: core.Input }],
            menuPosition: [{ type: core.Input }],
            menuOpenChange: [{ type: core.Output }],
            keyEnter: [{ type: core.Output }],
            keydownHandler: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return MenuNavigationToggleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS = [
        MenuNavigationDirective,
        MenuNavigationItemDirective,
        MenuNavigationToggleDirective
    ];
    var MenuNavigationModule = (function () {
        function MenuNavigationModule() {
        }
        MenuNavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: EXPORTS,
                        declarations: EXPORTS,
                    },] }
        ];
        return MenuNavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$2 = [
        FilterBaseComponent,
        FilterContainerComponent,
        FilterDropdownComponent,
        FilterDynamicComponent,
        FilterTypeaheadHighlight
    ];
    var FilterModule = (function () {
        function FilterModule() {
        }
        FilterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            dropdown.BsDropdownModule.forRoot(),
                            TooltipModule,
                            forms.FormsModule,
                            MenuNavigationModule,
                            common.CommonModule,
                            TypeaheadModule,
                            a11y.A11yModule
                        ],
                        exports: DECLARATIONS$2,
                        declarations: DECLARATIONS$2
                    },] }
        ];
        return FilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardComponent = (function () {
        function FlippableCardComponent() {
            this.direction = 'horizontal';
            this.trigger = 'hover';
            this.width = 280;
            this.height = 200;
            this.flipped = false;
            this.flippedChange = new core.EventEmitter();
        }
        /**
         * @param {?} state
         * @return {?}
         */
        FlippableCardComponent.prototype.setFlipped = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                this.flipped = state;
                this.flippedChange.emit(this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.toggleFlipped = /**
         * @return {?}
         */
            function () {
                this.setFlipped(!this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.clickTrigger = /**
         * @return {?}
         */
            function () {
                // add or remove the class depending on whether or not the card has been flipped
                if (this.trigger === 'click') {
                    this.toggleFlipped();
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverEnter = /**
         * @return {?}
         */
            function () {
                // if the trigger is hover then begin to flip
                if (this.trigger === 'hover') {
                    this.setFlipped(true);
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverExit = /**
         * @return {?}
         */
            function () {
                if (this.trigger === 'hover') {
                    this.setFlipped(false);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FlippableCardComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.trigger !== 'manual') {
                    this.toggleFlipped();
                    event.preventDefault();
                }
            };
        FlippableCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-flippable-card',
                        template: "<div class=\"ux-flipper\"\n     [class.ux-flip-card]=\"flipped\"\n     [style.width.px]=\"width\"\n     [style.height.px]=\"height\">\n\n    <div class=\"ux-flippable-card-front\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"flipped\">\n\n        <ng-content select=\"ux-flippable-card-front\"></ng-content>\n    </div>\n\n    <div class=\"ux-flippable-card-back\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"!flipped\">\n\n        <ng-content select=\"ux-flippable-card-back\"></ng-content>\n    </div>\n</div>",
                        host: {
                            'tabindex': '0',
                            '[class.horizontal]': 'direction === "horizontal"',
                            '[class.vertical]': 'direction === "vertical"'
                        },
                        exportAs: 'ux-flippable-card'
                    }] }
        ];
        FlippableCardComponent.propDecorators = {
            direction: [{ type: core.Input }],
            trigger: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            flipped: [{ type: core.Input }],
            flippedChange: [{ type: core.Output }],
            clickTrigger: [{ type: core.HostListener, args: ['click',] }],
            hoverEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
            hoverExit: [{ type: core.HostListener, args: ['mouseleave',] }],
            onKeyDown: [{ type: core.HostListener, args: ['keydown.enter', ['$event'],] }, { type: core.HostListener, args: ['keydown.space', ['$event'],] }, { type: core.HostListener, args: ['keydown.spacebar', ['$event'],] }]
        };
        return FlippableCardComponent;
    }());
    var FlippableCardFrontDirective = (function () {
        function FlippableCardFrontDirective() {
        }
        FlippableCardFrontDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-front'
                    },] }
        ];
        return FlippableCardFrontDirective;
    }());
    var FlippableCardBackDirective = (function () {
        function FlippableCardBackDirective() {
        }
        FlippableCardBackDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-back'
                    },] }
        ];
        return FlippableCardBackDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardModule = (function () {
        function FlippableCardModule() {
        }
        FlippableCardModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective],
                        declarations: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective]
                    },] }
        ];
        return FlippableCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsService = (function () {
        function FloatingActionButtonsService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
            this.direction$ = new BehaviorSubject.BehaviorSubject('top');
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.open = /**
         * @return {?}
         */
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.open$.next(!this.open$.getValue());
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open$.next(false);
                // make the first button tabbable again
                this.setPrimaryButtonFocusable();
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.isHorizontal = /**
         * @return {?}
         */
            function () {
                return this.direction$.value === 'left' || this.direction$.value === 'right';
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.isVertical = /**
         * @return {?}
         */
            function () {
                return this.direction$.value === 'top' || this.direction$.value === 'bottom';
            };
        /**
         * @param {?} buttons
         * @return {?}
         */
        FloatingActionButtonsService.prototype.setButtons = /**
         * @param {?} buttons
         * @return {?}
         */
            function (buttons) {
                this._buttons = buttons;
                // make the first button tabbable
                this.setPrimaryButtonFocusable();
            };
        /** Make only the first button tabbable */
        /**
         * Make only the first button tabbable
         * @return {?}
         */
        FloatingActionButtonsService.prototype.setPrimaryButtonFocusable = /**
         * Make only the first button tabbable
         * @return {?}
         */
            function () {
                this._buttons.forEach(function (btn) { return btn.tabindex$.next(btn.primary ? 0 : -1); });
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.focusPrimaryButton = /**
         * @return {?}
         */
            function () {
                this.focus(this._buttons.find(function (btn) { return btn.primary; }));
            };
        /**
         * @param {?} button
         * @return {?}
         */
        FloatingActionButtonsService.prototype.focus = /**
         * @param {?} button
         * @return {?}
         */
            function (button) {
                // if the button is not defined then do nothing
                if (!button) {
                    return;
                }
                // set the button tab index
                this._buttons.forEach(function (btn) { return btn.tabindex$.next(button === btn ? 0 : -1); });
                // apply the focus
                button.focus();
            };
        /**
         * @param {?} next
         * @return {?}
         */
        FloatingActionButtonsService.prototype.focusSibling = /**
         * @param {?} next
         * @return {?}
         */
            function (next) {
                // if the buttons are not visible then do nothing
                if (this.open$.value === false) {
                    return;
                }
                // get the current focused item
                var /** @type {?} */ button = this.getFocusedButton();
                if (next && button === this._buttons.last) {
                    return this.focus(this._buttons.first);
                }
                else if (!next && button === this._buttons.first) {
                    return this.focus(this._buttons.last);
                }
                // find the sibling button
                var /** @type {?} */ sibling = this._buttons.toArray()[this.getButtonIndex(button) + (next ? 1 : -1)];
                // focus the next button
                this.focus(sibling);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.getFocusedButton = /**
         * @return {?}
         */
            function () {
                return this._buttons.find(function (btn) { return btn.tabindex$.value === 0; });
            };
        /**
         * @param {?} button
         * @return {?}
         */
        FloatingActionButtonsService.prototype.getButtonIndex = /**
         * @param {?} button
         * @return {?}
         */
            function (button) {
                return this._buttons.toArray().findIndex(function (btn) { return btn === button; });
            };
        FloatingActionButtonsService.decorators = [
            { type: core.Injectable }
        ];
        return FloatingActionButtonsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonComponent = (function () {
        function FloatingActionButtonComponent(primary, fab, _tooltip) {
            this.fab = fab;
            this._tooltip = _tooltip;
            this.primary = false;
            this.tabindex$ = new BehaviorSubject.BehaviorSubject(-1);
            this._onDestroy = new Subject.Subject();
            this.primary = primary !== null;
        }
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._tooltip) {
                    // ensure the tooltip gets hidden when the button is hidden
                    this.fab.open$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (isOpen) { return !isOpen && !_this.primary; }))
                        .subscribe(function () { return _this._tooltip.hide(); });
                }
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.button.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                // ensure the tooltip gets shown
                if (this._tooltip) {
                    this._tooltip.show();
                }
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                // ensure the tooltip gets hidden
                if (this._tooltip) {
                    this._tooltip.hide();
                }
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.close = /**
         * @return {?}
         */
            function () {
                this.fab.close();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        if (this.fab.isVertical()) {
                            this.fab.focusSibling(this.fab.direction$.value !== 'bottom');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.DOWN_ARROW:
                        if (this.fab.isVertical()) {
                            this.fab.focusSibling(this.fab.direction$.value === 'bottom');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.LEFT_ARROW:
                        if (this.fab.isHorizontal()) {
                            this.fab.focusSibling(this.fab.direction$.value !== 'right');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.RIGHT_ARROW:
                        if (this.fab.isHorizontal()) {
                            this.fab.focusSibling(this.fab.direction$.value === 'right');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.ENTER:
                        this.fab.focusPrimaryButton();
                        break;
                    case keycodes.ESCAPE:
                        this.fab.focusPrimaryButton();
                        this.fab.close();
                        break;
                }
            };
        FloatingActionButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-button',
                        template: "<button #button class=\"btn floating-action-button\"\n        [class.button-primary]=\"primary\"\n        [class.button-secondary]=\"!primary\"\n        [attr.aria-label]=\"ariaLabel\"\n        [tabIndex]=\"tabindex$ | async\"\n        (focus)=\"onFocus()\"\n        (blur)=\"onBlur()\"\n        (click)=\"primary ? fab.toggle() : close()\">\n\n    <span class=\"hpe-icon floating-action-button-icon\" *ngIf=\"icon\" [ngClass]=\"icon\"></span>\n    <ng-content *ngIf=\"!icon\"></ng-content>\n\n</button>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false
                    }] }
        ];
        /** @nocollapse */
        FloatingActionButtonComponent.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: core.Attribute, args: ['fab-primary',] }] },
                { type: FloatingActionButtonsService },
                { type: TooltipDirective, decorators: [{ type: core.Optional }] }
            ];
        };
        FloatingActionButtonComponent.propDecorators = {
            icon: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            button: [{ type: core.ViewChild, args: ['button',] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return FloatingActionButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsComponent = (function () {
        function FloatingActionButtonsComponent(fab, _elementRef) {
            var _this = this;
            this.fab = fab;
            this._elementRef = _elementRef;
            /**
             * Emit whenever the open state changes
             */
            this.openChange = new core.EventEmitter();
            this._subscription = new Subscription.Subscription();
            this._subscription.add(this.fab.open$.subscribe(function (value) { return _this.openChange.emit(value); }));
        }
        Object.defineProperty(FloatingActionButtonsComponent.prototype, "direction", {
            /** Specify the direction that the FAB should display */
            set: /**
             * Specify the direction that the FAB should display
             * @param {?} direction
             * @return {?}
             */ function (direction) { this.fab.direction$.next(direction); },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.fab.setButtons(this.buttons);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /*
         * Detect any clicks to trigger close of the menu
         */
        /**
         * @param {?} target
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.close = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                if (!this._elementRef.nativeElement.contains(target)) {
                    this.fab.close();
                }
            };
        FloatingActionButtonsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-buttons',
                        template: "<ng-content select=\"[fab-primary]\"></ng-content>\n\n<div class=\"floating-action-button-list\" [@fabAnimation]=\"fab.open$ | async\" [ngClass]=\"fab.direction$ | async\" *ngIf=\"fab.open$ | async\">\n    <ng-content></ng-content>\n</div>",
                        providers: [FloatingActionButtonsService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        animations: [
                            animations.trigger('fabAnimation', [
                                animations.transition('void => true', [
                                    animations.query('ux-floating-action-button', animations.style({ opacity: 0 })),
                                    animations.query('ux-floating-action-button', animations.stagger(50, animations.animate(250, animations.style({ opacity: 1 }))))
                                ]),
                                animations.transition('true => void', [
                                    animations.query('ux-floating-action-button', animations.stagger(-50, animations.animate(250, animations.style({ opacity: 0 }))))
                                ])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        FloatingActionButtonsComponent.ctorParameters = function () {
            return [
                { type: FloatingActionButtonsService },
                { type: core.ElementRef }
            ];
        };
        FloatingActionButtonsComponent.propDecorators = {
            direction: [{ type: core.Input }],
            openChange: [{ type: core.Output }],
            buttons: [{ type: core.ContentChildren, args: [FloatingActionButtonComponent,] }],
            close: [{ type: core.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return FloatingActionButtonsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsModule = (function () {
        function FloatingActionButtonsModule() {
        }
        FloatingActionButtonsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ],
                        declarations: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ]
                    },] }
        ];
        return FloatingActionButtonsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideDirective = (function () {
        function ClickOutsideDirective(_elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.uxClickOutside = new core.EventEmitter();
            /**
             * Often a click event makes the element appear - if so we can end up closing it immediately
             */
            this._initialised = false;
            setTimeout(function () { return _this._initialised = true; });
        }
        /**
         * @param {?} event
         * @return {?}
         */
        ClickOutsideDirective.prototype.click = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._initialised && this._elementRef.nativeElement !== event.target && !this._elementRef.nativeElement.contains(event.target)) {
                    this.uxClickOutside.emit(event);
                }
            };
        ClickOutsideDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxClickOutside]'
                    },] }
        ];
        /** @nocollapse */
        ClickOutsideDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ClickOutsideDirective.propDecorators = {
            uxClickOutside: [{ type: core.Output }],
            click: [{ type: core.HostListener, args: ['document:click', ['$event'],] }]
        };
        return ClickOutsideDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideModule = (function () {
        function ClickOutsideModule() {
        }
        ClickOutsideModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ClickOutsideDirective],
                        declarations: [ClickOutsideDirective]
                    },] }
        ];
        return ClickOutsideModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniquePopoverId = 0;
    var PopoverComponent = (function (_super) {
        __extends(PopoverComponent, _super);
        function PopoverComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Define a unique id for each popover
             */
            _this.id = "ux-popover-" + ++uniquePopoverId;
            /**
             * This will emit an event any time the user clicks outside the popover
             */
            _this.clickOutside$ = new Subject.Subject();
            return _this;
        }
        /** This will update the title of the popover and trigger change detection */
        /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
        PopoverComponent.prototype.setTitle = /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
            function (title) {
                this.title = title;
                this._changeDetectorRef.markForCheck();
            };
        PopoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-popover',
                        template: "<div class=\"popover show\" [ngClass]=\"[placement, customClass]\" [id]=\"id\" [attr.role]=\"role\" (uxClickOutside)=\"clickOutside$.next($event)\">\n    <div class=\"arrow\"></div>\n    <h3 class=\"popover-title\" *ngIf=\"title\">{{ title }}</h3>\n    <div class=\"popover-content\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return PopoverComponent;
    }(TooltipComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverDirective = (function (_super) {
        __extends(PopoverDirective, _super);
        function PopoverDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * All the user to add a custom class to the popover
             */
            _this.customClass = '';
            /**
             * All the user to add a role to the popover - default is tooltip
             */
            _this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            _this.context = {};
            /**
             * Delay the showing of the popover by a number of miliseconds
             */
            _this.delay = 0;
            /**
             * Specify which events should show the popover
             */
            _this.showTriggers = ['click'];
            /**
             * Specify which events should hide the popover
             */
            _this.hideTriggers = ['click', 'clickoutside', 'escape'];
            /**
             * Keep track of the tooltip visibility and update aria-expanded attribute
             */
            _this.isVisible = false;
            /**
             * Internally store the type of this component - usual for distinctions when extending the tooltip class
             */
            _this._type = 'popover';
            return _this;
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        PopoverDirective.prototype.ngOnInit = /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
            function () {
                // set up the event triggers
                fromEvent.fromEvent(document, 'keydown').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onKeyDown.bind(this));
                // check if there is an aria-described by attribute
                this._ariaDescribedBy = this._elementRef.nativeElement.hasAttribute('aria-describedby');
                // set up the default event triggers
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        PopoverDirective.prototype.ngOnChanges = /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (this._instance && changes["title"]) {
                    this._instance.setTitle(changes["title"].currentValue);
                }
            };
        /**
         * @param {?} overlayRef
         * @return {?}
         */
        PopoverDirective.prototype.createInstance = /**
         * @param {?} overlayRef
         * @return {?}
         */
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setTitle(this.title);
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                // subscribe to the outside click event
                instance.clickOutside$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClickOutside.bind(this));
                return instance;
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.createPortal = /**
         * @return {?}
         */
            function () {
                return this._portal || new portal.ComponentPortal(PopoverComponent, this._viewContainerRef);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        PopoverDirective.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if visible and the escape key is pressed and it is one of the hide triggers
                if (this.isVisible && event.keyCode === keycodes.ESCAPE && this.includes(this.hideTriggers, 'escape')) {
                    this.hide();
                }
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.onClickOutside = /**
         * @return {?}
         */
            function () {
                // if visible and it is one of the hide triggers
                if (this.isVisible && this.includes(this.hideTriggers, 'clickoutside')) {
                    this.hide();
                }
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        PopoverDirective.prototype.setAriaDescribedBy = /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
            function (id) {
                // we only want to set the aria-describedby attr when the content is a string and there was no user defined attribute already
                if (this._ariaDescribedBy === false && typeof this.content === 'string') {
                    _super.prototype.setAriaDescribedBy.call(this, id);
                }
            };
        PopoverDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPopover]',
                        exportAs: 'ux-popover'
                    },] }
        ];
        PopoverDirective.propDecorators = {
            content: [{ type: core.Input, args: ['uxPopover',] }],
            title: [{ type: core.Input, args: ['popoverTitle',] }],
            disabled: [{ type: core.Input, args: ['popoverDisabled',] }],
            customClass: [{ type: core.Input, args: ['popoverClass',] }],
            role: [{ type: core.Input, args: ['popoverRole',] }],
            context: [{ type: core.Input, args: ['popoverContext',] }],
            delay: [{ type: core.Input, args: ['popoverDelay',] }],
            showTriggers: [{ type: core.Input }],
            hideTriggers: [{ type: core.Input }],
            isVisible: [{ type: core.HostBinding, args: ['attr.aria-expanded',] }]
        };
        return PopoverDirective;
    }(TooltipDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverModule = (function () {
        function PopoverModule() {
        }
        PopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule,
                            ClickOutsideModule,
                            TooltipModule
                        ],
                        exports: [PopoverDirective],
                        declarations: [PopoverComponent, PopoverDirective],
                        entryComponents: [PopoverComponent]
                    },] }
        ];
        return PopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarService = (function () {
        function HierarchyBarService() {
            this.nodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._nodes = [];
        }
        /**
         * Store the root node of the hierarchy tree
         */
        /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
        HierarchyBarService.prototype.setRootNode = /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
            function (root) {
                // store the root node
                this._root = root;
                // create a flat structure of nodes
                this._nodes = this.getNodeList(root);
                // flatten the array - based on the selected node
                this.nodes$.next(this.getSelectedChildren(root));
            };
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         */
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.selectNode = /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // deselect all nodes
                this.deselectAll();
                // ensure the current node is selected and its parents
                this.select(node);
                // emit a new node list to trigger change detection
                this.nodes$.next(this.getSelectedChildren(this._root));
            };
        /**
         * Handles getting children with support for both arrays and observables
         */
        /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getChildren = /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
            function (node) {
                var _this = this;
                if (Array.isArray(node.children)) {
                    return of.of({ loading: false, children: node.children });
                }
                var /** @type {?} */ children$ = node.children;
                // if it is an observable then handle loading
                return Observable.Observable.create(function (observer) {
                    // emit initial value
                    observer.next({ loading: true, children: [] });
                    // now wait until the children observable completes
                    children$.pipe(operators.first()).subscribe(function (children) {
                        // replace the observable with an array for future loading
                        node.children = children;
                        // rebuild the node tree
                        // rebuild the node tree
                        _this.setRootNode(_this._root);
                        // emit the latest value
                        observer.next({ loading: false, children: children });
                        // close the observable stream
                        observer.complete();
                    });
                });
            };
        /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.select = /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
            function (node) {
                node.selected = true;
                if (node.parent) {
                    this.select(node.parent);
                }
            };
        /**
         * Deselects all nodes
         * @return {?}
         */
        HierarchyBarService.prototype.deselectAll = /**
         * Deselects all nodes
         * @return {?}
         */
            function () {
                this._nodes.forEach(function (node) { return node.selected = false; });
            };
        /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getNodeList = /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
            function (node) {
                var _this = this;
                // if there are no children then return only itself
                if (!node.children || node.children instanceof Observable.Observable || node.children.length === 0) {
                    return [node];
                }
                // store the parent property
                node.children.forEach(function (child) { return child.parent = node; });
                // get all descendants of this node
                var /** @type {?} */ descendants = node.children.reduce(function (nodes, current) { return __spread(nodes, _this.getNodeList(current)); }, []);
                return __spread([node], descendants);
            };
        /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getSelectedChildren = /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (node.children instanceof Observable.Observable) {
                    return [node];
                }
                // get the children - and account for when there is none
                var /** @type {?} */ children = node.children || [];
                // check if any child is selected
                var /** @type {?} */ child = children.find(function (_child) { return _child.selected; });
                // return the remaining chain of selected items
                return child ? __spread([node], this.getSelectedChildren(child)) : [node];
            };
        HierarchyBarService.decorators = [
            { type: core.Injectable }
        ];
        return HierarchyBarService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarComponent = (function () {
        function HierarchyBarComponent(hierarchyBar) {
            var _this = this;
            this.hierarchyBar = hierarchyBar;
            this.selectedChange = new core.EventEmitter();
            this.overflow$ = new BehaviorSubject.BehaviorSubject(false);
            this.overflowNodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._subscription = new Subscription.Subscription();
            // subscribe to changes in the selected node
            var /** @type {?} */ selected = hierarchyBar.nodes$.subscribe(function (nodes) { return _this.selectedChange.emit(nodes.length === 0 ? null : nodes[nodes.length - 1]); });
            var /** @type {?} */ changed = hierarchyBar.nodes$.pipe(operators.debounceTime(0)).subscribe(function () { return _this.scrollIntoView(); });
            // store subscriptions
            this._subscription.add(selected);
            this._subscription.add(changed);
        }
        Object.defineProperty(HierarchyBarComponent.prototype, "root", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.setRootNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "selected", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.selectNode(node);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        HierarchyBarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         */
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
        HierarchyBarComponent.prototype.scrollIntoView = /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.nodelist) {
                    return;
                }
                // get the native element
                var nativeElement = this.nodelist.nativeElement;
                // emit whether or not there is overflow
                this.overflow$.next(nativeElement.scrollWidth > nativeElement.offsetWidth);
                // if the hierarchy bar contents do not overflow then do nothing
                if (nativeElement.scrollWidth > nativeElement.offsetWidth) {
                    // determine the amount of overflow
                    var /** @type {?} */ overflowAmount_1 = nativeElement.scrollWidth - nativeElement.offsetWidth;
                    // determine which nodes are not fully visible
                    this.overflowNodes$.next(this.nodes.filter(function (node) { return node.nativeElement.offsetLeft < overflowAmount_1; })
                        .map(function (node, index) { return _this.hierarchyBar.nodes$.value[index]; }));
                    // move the scroll position to always show the last itme
                    this.nodelist.nativeElement.scrollLeft = overflowAmount_1;
                }
            };
        HierarchyBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-hierarchy-bar',
                        template: "<!-- Allow content to be placed on the left of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarLeftAddon]\"></ng-content>\n</aside>\n\n<main #nodelist class=\"hierarchy-bar-nodes\" (uxResize)=\"scrollIntoView()\">\n\n    <div *ngIf=\"overflow$ | async\"\n         #popover=\"ux-popover\"\n         class=\"hierarchy-bar-overflow-indicator\"\n         [style.left.px]=\"nodelist.scrollLeft\"\n         [uxPopover]=\"overflow\"\n         [popoverContext]=\"{ popover: popover }\"\n         placement=\"bottom\"\n         popoverClass=\"hierarchy-bar-popover\">\n        . . .\n    </div>\n\n    <div #nodeElement class=\"hierarchy-bar-node\"\n         *ngFor=\"let node of hierarchyBar.nodes$ | async\">\n\n        <button class=\"hierarchy-bar-node-content\"\n                [attr.aria-label]=\"node.title\"\n                (click)=\"hierarchyBar.selectNode(node)\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n        </button>\n\n        <!-- Show a dropdown arrow if there are children -->\n        <button *ngIf=\"node.children\"\n                #popover=\"ux-popover\"\n                aria-label=\"Show children\"\n                role=\"button\"\n                class=\"hierarchy-bar-node-arrow hpe-icon hpe-next\"\n                [uxPopover]=\"content\"\n                [popoverContext]=\"{ node: node, popover: popover }\"\n                placement=\"bottom\"\n                popoverClass=\"hierarchy-bar-popover\"\n                tabindex=\"0\">\n        </button>\n\n    </div>\n\n</main>\n\n<!-- Allow content to be placed on the right of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarRightAddon]\"></ng-content>\n</aside>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n\n    <!-- Loading Indicator -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li class=\"hierarchy-bar-node-list-item\">\n            <ng-container [ngTemplateOutlet]=\"loadingIndicator || defaultLoadingIndicator\"></ng-container>\n        </li>\n    </ul>\n\n    <!-- List of children -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"!(hierarchyBar.getChildren(node) | async).loading\" uxTabbableList [returnFocus]=\"true\">\n\n        <li *ngFor=\"let child of (hierarchyBar.getChildren(node) | async).children; let first = first\"\n            [focusIf]=\"first\"\n            uxTabbableListItem\n            class=\"hierarchy-bar-node-list-item\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Template for the overflow popover list -->\n<ng-template #overflow let-popover=\"popover\">\n\n    <ul class=\"hierarchy-bar-node-list\" uxTabbableList [returnFocus]=\"true\">\n\n        <li *ngFor=\"let child of overflowNodes$ | async; let first = first\"\n            [focusIf]=\"first\"\n            uxTabbableListItem\n            class=\"hierarchy-bar-node-list-item\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Loading Indicator Template -->\n<ng-template #defaultLoadingIndicator>\n    <div class=\"hierarchy-bar-node-icon\" alt=\"Hierarchy Bar Loading Indicator\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n    </div>\n\n    <!-- Show the name of the current node -->\n    <span class=\"hierarchy-bar-node-title\">Loading...</span>\n</ng-template>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        viewProviders: [HierarchyBarService]
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService }
            ];
        };
        HierarchyBarComponent.propDecorators = {
            root: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            loadingIndicator: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            nodelist: [{ type: core.ViewChild, args: ['nodelist',] }],
            nodes: [{ type: core.ViewChildren, args: ['nodeElement',] }]
        };
        return HierarchyBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarModule = (function () {
        function HierarchyBarModule() {
        }
        HierarchyBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            FocusIfModule,
                            PopoverModule,
                            AccessibilityModule
                        ],
                        exports: [HierarchyBarComponent],
                        declarations: [HierarchyBarComponent],
                    },] }
        ];
        return HierarchyBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelService = (function () {
        function SidePanelService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        SidePanelService.prototype.open = /**
         * @return {?}
         */
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        SidePanelService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open$.next(false);
            };
        SidePanelService.decorators = [
            { type: core.Injectable }
        ];
        return SidePanelService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelComponent = (function () {
        function SidePanelComponent(service, _elementRef) {
            this.service = service;
            this._elementRef = _elementRef;
            this.inline = false;
            this.attachTo = 'window';
            this.width = '50%';
            this.top = '0';
            this.modal = false;
            this.animate = false;
            this.closeOnExternalClick = false;
            this.focusOnShow = false;
            this.openChange = new core.EventEmitter();
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(SidePanelComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this.service.open$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return 'static';
                }
                if (this.attachTo === 'container') {
                    return 'absolute';
                }
                return 'fixed';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.width === 'number') {
                    return this.width === 0 ? '0' : this.width + 'px';
                }
                return this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssTop", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.top === 'number') {
                    return this.top === 0 ? '0' : this.top + 'px';
                }
                return this.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "componentWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return this.open ? this.cssWidth : '0';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "hostWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline ? '100%' : this.cssWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.service.open$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isOpen) { return _this.openChange.emit(isOpen); });
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.openPanel = /**
         * @return {?}
         */
            function () {
                this.service.open();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.closePanel = /**
         * @return {?}
         */
            function () {
                this.service.close();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SidePanelComponent.prototype.clickHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.open || !this.closeOnExternalClick) {
                    return;
                }
                var /** @type {?} */ target = (event.target);
                if (!this._elementRef.nativeElement.contains(target) ||
                    (target && target.classList.contains('modal-backdrop'))) {
                    this.closePanel();
                }
            };
        SidePanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-side-panel',
                        exportAs: 'ux-side-panel',
                        template: "<div *ngIf=\"modal && open\" class=\"modal-backdrop\"\n    [style.position]=\"position\"\n    [style.top]=\"cssTop\"></div>\n\n<div class=\"ux-side-panel-host\"\n    [class.modal-panel]=\"modal\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [tabindex]=\"open ? 0 : -1\"\n    [focusIf]=\"open && focusOnShow\"\n    [focusIfScroll]=\"false\"\n    [cdkTrapFocus]=\"open && modal\">\n    <ng-content></ng-content>\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel'
                        }
                    }] }
        ];
        /** @nocollapse */
        SidePanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService },
                { type: core.ElementRef }
            ];
        };
        SidePanelComponent.propDecorators = {
            open: [{ type: core.Input }, { type: core.HostBinding, args: ['class.open',] }],
            inline: [{ type: core.Input }, { type: core.HostBinding, args: ['class.inline',] }],
            attachTo: [{ type: core.Input }],
            width: [{ type: core.Input }],
            top: [{ type: core.Input }],
            modal: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-modal',] }],
            animate: [{ type: core.Input }, { type: core.HostBinding, args: ['class.animate',] }],
            closeOnExternalClick: [{ type: core.Input }],
            focusOnShow: [{ type: core.Input }],
            openChange: [{ type: core.Output }],
            componentWidth: [{ type: core.HostBinding, args: ['style.width',] }],
            closePanel: [{ type: core.HostListener, args: ['document:keyup.escape',] }],
            clickHandler: [{ type: core.HostListener, args: ['document:click', ['$event'],] }]
        };
        return SidePanelComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ItemDisplayPanelContentDirective = (function () {
        function ItemDisplayPanelContentDirective() {
        }
        ItemDisplayPanelContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelContent]'
                    },] }
        ];
        return ItemDisplayPanelContentDirective;
    }());
    var ItemDisplayPanelFooterDirective = (function () {
        function ItemDisplayPanelFooterDirective() {
        }
        ItemDisplayPanelFooterDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelFooter]'
                    },] }
        ];
        return ItemDisplayPanelFooterDirective;
    }());
    var ItemDisplayPanelComponent = (function (_super) {
        __extends(ItemDisplayPanelComponent, _super);
        function ItemDisplayPanelComponent(service, elementRef) {
            var _this = _super.call(this, service, elementRef) || this;
            _this.boxShadow = true;
            _this.closeVisible = true;
            _this.shadow = false;
            _this.visibleChange = new core.EventEmitter();
            _this.animate = false;
            _this.closeOnExternalClick = true;
            return _this;
        }
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "preventClose", {
            get: /**
             * @return {?}
             */ function () {
                return !this.closeOnExternalClick;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.closeOnExternalClick = !value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "title", {
            get: /**
             * @return {?}
             */ function () {
                return this.header;
            },
            /**
             * @deprecated
             * Title used for adding tooltips and shouldn't be used as an input
             * instead header will be used. This is here to support backward compatibility only
             * this property should not be used.
             */
            set: /**
             * @deprecated
             * Title used for adding tooltips and shouldn't be used as an input
             * instead header will be used. This is here to support backward compatibility only
             * this property should not be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.header = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this.open;
            },
            set: /**
             * @param {?} visible
             * @return {?}
             */ function (visible) {
                this.open = visible;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (isVisible) { return _this.visibleChange.emit(isVisible); });
            };
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (this.panel) {
                    this.panel.nativeElement.focus();
                }
            };
        ItemDisplayPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-item-display-panel',
                        template: "<div class=\"ux-side-panel-host ux-item-display-panel\" #panel\n    [class.box-shadow]=\"boxShadow\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [tabindex]=\"open ? 0 : -1\"\n    [focusIf]=\"open && focusOnShow\">\n\n    <div class=\"ux-side-panel-header\" [class.item-display-panel-shadow]=\"shadow\">\n        <h3>{{ header }}</h3>\n        <button *ngIf=\"closeVisible\" aria-label=\"Close\" i18n-aria-label type=\"button\" class=\"btn btn-lg btn-link btn-icon button-secondary\" (click)=\"visible = false\">\n            <i class=\"hpe-icon hpe-close\"></i>\n        </button>\n    </div>\n\n    <div class=\"ux-side-panel-content\">\n        <ng-content select=\"[uxItemDisplayPanelContent]\"></ng-content>\n    </div>\n\n    <div class=\"ux-side-panel-footer\" *ngIf=\"footer\">\n        <ng-content select=\"[uxItemDisplayPanelFooter]\"></ng-content>\n    </div>\n\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel ux-item-display-panel'
                        }
                    }] }
        ];
        /** @nocollapse */
        ItemDisplayPanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService },
                { type: core.ElementRef }
            ];
        };
        ItemDisplayPanelComponent.propDecorators = {
            header: [{ type: core.Input }],
            boxShadow: [{ type: core.Input }],
            closeVisible: [{ type: core.Input }],
            preventClose: [{ type: core.Input }],
            shadow: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            footer: [{ type: core.ContentChild, args: [ItemDisplayPanelFooterDirective,] }],
            panel: [{ type: core.ViewChild, args: ['panel',] }],
            title: [{ type: core.Input }],
            visible: [{ type: core.Input }]
        };
        return ItemDisplayPanelComponent;
    }(SidePanelComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$3 = [
        ItemDisplayPanelComponent,
        ItemDisplayPanelContentDirective,
        ItemDisplayPanelFooterDirective
    ];
    var ItemDisplayPanelModule = (function () {
        function ItemDisplayPanelModule() {
        }
        ItemDisplayPanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            FocusIfModule
                        ],
                        exports: DECLARATIONS$3,
                        declarations: DECLARATIONS$3
                    },] }
        ];
        return ItemDisplayPanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardStepComponent = (function () {
        function WizardStepComponent() {
            this.valid = true;
            this.visitedChange = new core.EventEmitter();
            this._active = false;
            this._visited = false;
        }
        Object.defineProperty(WizardStepComponent.prototype, "visited", {
            get: /**
             * @return {?}
             */ function () {
                return this._visited;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._visited = value;
                this.visitedChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // store the active state of the step
                this._active = value;
                // if the value is true then the step should also be marked as visited
                if (value === true) {
                    this.visited = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        WizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>",
                        host: {
                            'role': 'tabpanel',
                            '[attr.aria-labelledby]': 'id + "-label"'
                        }
                    }] }
        ];
        WizardStepComponent.propDecorators = {
            header: [{ type: core.Input }],
            valid: [{ type: core.Input }],
            visitedChange: [{ type: core.Input }],
            visited: [{ type: core.Input }],
            active: [{ type: core.HostBinding, args: ['attr.aria-expanded',] }],
            id: [{ type: core.HostBinding, args: ['id',] }]
        };
        return WizardStepComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$5 = 0;
    var WizardComponent = (function () {
        function WizardComponent() {
            this.orientation = 'horizontal';
            this.nextText = 'Next';
            this.previousText = 'Previous';
            this.cancelText = 'Cancel';
            this.finishText = 'Finish';
            this.nextTooltip = 'Go to the next step';
            this.previousTooltip = 'Go to the previous step';
            this.cancelTooltip = 'Cancel the wizard';
            this.finishTooltip = 'Finish the wizard';
            this.nextAriaLabel = 'Go to the next step';
            this.previousAriaLabel = 'Go to the previous step';
            this.cancelAriaLabel = 'Cancel the wizard';
            this.finishAriaLabel = 'Finish the wizard';
            this.nextDisabled = false;
            this.previousDisabled = false;
            this.cancelDisabled = false;
            this.finishDisabled = false;
            this.nextVisible = true;
            this.previousVisible = true;
            this.cancelVisible = true;
            this.finishVisible = true;
            this.cancelAlwaysVisible = false;
            this.finishAlwaysVisible = false;
            this.onNext = new core.EventEmitter();
            this.onPrevious = new core.EventEmitter();
            this.onCancel = new core.EventEmitter();
            this.onFinishing = new core.EventEmitter();
            this.onFinish = new core.EventEmitter();
            this.stepChanging = new core.EventEmitter();
            this.stepChange = new core.EventEmitter();
            this.stepError = new core.EventEmitter();
            this.steps = new core.QueryList();
            this.id = "ux-wizard-" + uniqueId$5++;
            this.invalidIndicator = false;
            this._step = 0;
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(WizardComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // only accept numbers as valid options
                if (typeof value === 'number') {
                    // store the active step
                    this._step = value;
                    // update which steps should be active
                    this.update();
                    // emit the change event
                    this.stepChange.next(this.step);
                    // reset the invalid state
                    this.invalidIndicator = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WizardComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // initially set the correct visibility of the steps
                setTimeout(this.update.bind(this));
                // initially set the ids for each step
                this.setWizardStepIds();
                // if the steps change then update the ids
                this.steps.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.setWizardStepIds(); });
            };
        /**
         * @return {?}
         */
        WizardComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Set ids for each of the wizard steps */
        /**
         * Set ids for each of the wizard steps
         * @return {?}
         */
        WizardComponent.prototype.setWizardStepIds = /**
         * Set ids for each of the wizard steps
         * @return {?}
         */
            function () {
                var _this = this;
                this.steps.forEach(function (step, idx) { return step.id = _this.id + "-step-" + idx; });
            };
        /**
         * Navigate to the next step
         */
        /**
         * Navigate to the next step
         * @return {?}
         */
        WizardComponent.prototype.next = /**
         * Navigate to the next step
         * @return {?}
         */
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step + 1));
                // check if current step is invalid
                if (!this.getCurrentStep().valid) {
                    this.invalidIndicator = true;
                    this.stepError.next(this.step);
                    return;
                }
                // check if we are currently on the last step
                if ((this.step + 1) < this.steps.length) {
                    this.step++;
                    // emit the current step
                    this.onNext.next(this.step);
                }
            };
        /**
         * Navigate to the previous step
         */
        /**
         * Navigate to the previous step
         * @return {?}
         */
        WizardComponent.prototype.previous = /**
         * Navigate to the previous step
         * @return {?}
         */
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step - 1));
                // check if we are currently on the last step
                if (this.step > 0) {
                    this.step--;
                    // emit the current step
                    this.onPrevious.next(this.step);
                }
            };
        /**
         * Perform actions when the finish button is clicked
         */
        /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
        WizardComponent.prototype.finish = /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
            function () {
                var _this = this;
                // fires when the finish button is clicked always
                this.onFinishing.next();
                /**
                         * This is required because we need to ensure change detection has run
                         * to determine whether or not we have the latest value for the 'valid' input
                         * on the current step. Unfortunately we can't use ChangeDetectorRef as we are looking to run
                         * on content children, and we cant use ApplicationRef.tick() as this does not work in a hybrid app, eg. our docs
                         */
                return new Promise(function (resolve) {
                    setTimeout(function () {
                        // only fires when the finish button is clicked and the step is valid
                        if (_this.getCurrentStep().valid) {
                            _this.onFinish.next();
                        }
                        else {
                            _this.stepError.next(_this.step);
                        }
                        resolve();
                    });
                });
            };
        /**
         * Perform actions when the cancel button is clicked
         */
        /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
        WizardComponent.prototype.cancel = /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
            function () {
                this.onCancel.next();
            };
        /**
         * Update the active state of each step
         */
        /**
         * Update the active state of each step
         * @return {?}
         */
        WizardComponent.prototype.update = /**
         * Update the active state of each step
         * @return {?}
         */
            function () {
                var _this = this;
                // update which steps should be active
                this.steps.forEach(function (step, idx) { return step.active = idx === _this.step; });
            };
        /**
         * Jump to a specific step only if the step has previously been visited
         */
        /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
        WizardComponent.prototype.gotoStep = /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
            function (step) {
                if (step.visited) {
                    var /** @type {?} */ stepIndex = this.steps.toArray().findIndex(function (stp) { return stp === step; });
                    this.stepChanging.next(new StepChangingEvent(this.step, stepIndex));
                    this.step = stepIndex;
                }
            };
        /**
         * Determine if the current step is the last step
         */
        /**
         * Determine if the current step is the last step
         * @return {?}
         */
        WizardComponent.prototype.isLastStep = /**
         * Determine if the current step is the last step
         * @return {?}
         */
            function () {
                return this.step === (this.steps.length - 1);
            };
        /**
         * Reset the wizard - goes to first step and resets visited state
         */
        /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
        WizardComponent.prototype.reset = /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
            function () {
                // mark all steps as not visited
                this.steps.forEach(function (step) { return step.visited = false; });
                // go to the first step
                this.step = 0;
            };
        /**
         * Get the step at the current index
         */
        /**
         * Get the step at the current index
         * @return {?}
         */
        WizardComponent.prototype.getCurrentStep = /**
         * Get the step at the current index
         * @return {?}
         */
            function () {
                return this.getStepAtIndex(this.step);
            };
        /**
         * Return a step at a specific index
         */
        /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
        WizardComponent.prototype.getStepAtIndex = /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this.steps.toArray()[index];
            };
        WizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard',
                        template: "<div class=\"wizard-body\">\n\n    <div class=\"wizard-steps\"\n        uxTabbableList\n        [direction]=\"orientation\"\n        role=\"tablist\"\n        [attr.aria-orientation]=\"orientation\">\n\n        <div *ngFor=\"let stp of steps; let index = index\"\n            role=\"tab\"\n            uxTabbableListItem\n            [disabled]=\"!stp.visited\"\n            class=\"wizard-step\"\n            [class.active]=\"stp.active\"\n            [class.visited]=\"stp.visited\"\n            [class.invalid]=\"stp.active && !stp.valid && invalidIndicator\"\n            [attr.aria-posinset]=\"index + 1\"\n            [attr.aria-setsize]=\"steps.length\"\n            [attr.aria-selected]=\"stp.active\"\n            [attr.aria-controls]=\"stp.id\"\n            [id]=\"stp.id + '-label'\"\n            (click)=\"gotoStep(stp)\"\n            (keydown.enter)=\"gotoStep(stp)\">\n            {{ stp.header }}\n        </div>\n\n    </div>\n\n    <div class=\"wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n</div>\n\n<div class=\"wizard-footer\">\n    <button #tip=\"ux-tooltip\"\n            class=\"btn button-secondary\"\n            *ngIf=\"previousVisible\"\n            [uxTooltip]=\"previousTooltip\"\n            [disabled]=\"previousDisabled || step === 0\"\n            [attr.aria-label]=\"previousAriaLabel\"\n            (click)=\"previous(); tip.hide()\">\n        {{ previousText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            class=\"btn button-primary\"\n            *ngIf=\"nextVisible && !isLastStep()\"\n            [uxTooltip]=\"nextTooltip\"\n            [disabled]=\"nextDisabled\"\n            [attr.aria-label]=\"nextAriaLabel\"\n            (click)=\"next(); tip.hide()\">\n        {{ nextText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            class=\"btn button-primary\"\n            *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\"\n            [uxTooltip]=\"finishTooltip\"\n            [disabled]=\"finishDisabled\"\n            [attr.aria-label]=\"finishAriaLabel\"\n            (click)=\"finish(); tip.hide()\">\n        {{ finishText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            class=\"btn button-secondary\"\n            *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\"\n            [uxTooltip]=\"cancelTooltip\"\n            [disabled]=\"cancelDisabled\"\n            [attr.aria-label]=\"cancelAriaLabel\"\n            (click)=\"cancel(); tip.hide()\">\n        {{ cancelText }}\n    </button>\n</div>\n",
                        host: {
                            '[class]': 'orientation'
                        }
                    }] }
        ];
        WizardComponent.propDecorators = {
            orientation: [{ type: core.Input }],
            nextText: [{ type: core.Input }],
            previousText: [{ type: core.Input }],
            cancelText: [{ type: core.Input }],
            finishText: [{ type: core.Input }],
            nextTooltip: [{ type: core.Input }],
            previousTooltip: [{ type: core.Input }],
            cancelTooltip: [{ type: core.Input }],
            finishTooltip: [{ type: core.Input }],
            nextAriaLabel: [{ type: core.Input }],
            previousAriaLabel: [{ type: core.Input }],
            cancelAriaLabel: [{ type: core.Input }],
            finishAriaLabel: [{ type: core.Input }],
            nextDisabled: [{ type: core.Input }],
            previousDisabled: [{ type: core.Input }],
            cancelDisabled: [{ type: core.Input }],
            finishDisabled: [{ type: core.Input }],
            nextVisible: [{ type: core.Input }],
            previousVisible: [{ type: core.Input }],
            cancelVisible: [{ type: core.Input }],
            finishVisible: [{ type: core.Input }],
            cancelAlwaysVisible: [{ type: core.Input }],
            finishAlwaysVisible: [{ type: core.Input }],
            onNext: [{ type: core.Output }],
            onPrevious: [{ type: core.Output }],
            onCancel: [{ type: core.Output }],
            onFinishing: [{ type: core.Output }],
            onFinish: [{ type: core.Output }],
            stepChanging: [{ type: core.Output }],
            stepChange: [{ type: core.Output }],
            stepError: [{ type: core.Output }],
            steps: [{ type: core.ContentChildren, args: [WizardStepComponent,] }],
            step: [{ type: core.Input }]
        };
        return WizardComponent;
    }());
    var StepChangingEvent = (function () {
        function StepChangingEvent(from$$1, to) {
            this.from = from$$1;
            this.to = to;
        }
        return StepChangingEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$4 = [
        WizardComponent,
        WizardStepComponent
    ];
    var WizardModule = (function () {
        function WizardModule() {
        }
        WizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TooltipModule,
                            AccessibilityModule
                        ],
                        exports: DECLARATIONS$4,
                        declarations: DECLARATIONS$4
                    },] }
        ];
        return WizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This service is required to provide a form of communication
     * between the marquee wizard steps and the containing marquee wizard.
     * We cannot inject the Host due to the steps being content children
     * rather than view children.
     */
    var MarqueeWizardService = (function () {
        function MarqueeWizardService() {
            this.valid$ = new Subject.Subject();
        }
        MarqueeWizardService.decorators = [
            { type: core.Injectable }
        ];
        return MarqueeWizardService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardStepComponent = (function (_super) {
        __extends(MarqueeWizardStepComponent, _super);
        function MarqueeWizardStepComponent(_marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this._marqueeWizardService = _marqueeWizardService;
            _this.completed = false;
            _this.completedChange = new core.EventEmitter();
            _this._valid = true;
            return _this;
        }
        Object.defineProperty(MarqueeWizardStepComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                if (this._marqueeWizardService) {
                    this._marqueeWizardService.valid$.next({ step: this, valid: valid });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Update the completed state and emit the latest value
         * @param completed whether or not the step is completed
         */
        /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
        MarqueeWizardStepComponent.prototype.setCompleted = /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
            function (completed) {
                this.completed = completed;
                this.completedChange.emit(completed);
            };
        MarqueeWizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                    }] }
        ];
        /** @nocollapse */
        MarqueeWizardStepComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService }
            ];
        };
        MarqueeWizardStepComponent.propDecorators = {
            icon: [{ type: core.Input }],
            completed: [{ type: core.Input }],
            completedChange: [{ type: core.Output }]
        };
        return MarqueeWizardStepComponent;
    }(WizardStepComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardComponent = (function (_super) {
        __extends(MarqueeWizardComponent, _super);
        function MarqueeWizardComponent(marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this.steps = new core.QueryList();
            marqueeWizardService.valid$.pipe(operators.filter(function (event) { return !event.valid; }))
                .subscribe(_this.validChange.bind(_this));
            return _this;
        }
        Object.defineProperty(MarqueeWizardComponent.prototype, "isTemplate", {
            get: /**
             * @return {?}
             */ function () {
                return this.description && this.description instanceof core.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         */
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
        MarqueeWizardComponent.prototype.next = /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
            function () {
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                if (step.valid) {
                    _super.prototype.next.call(this);
                    // mark this step as completed
                    step.setCompleted(true);
                }
                else {
                    this.stepError.next(this.step);
                }
            };
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         */
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
        MarqueeWizardComponent.prototype.finish = /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
            function () {
                var _this = this;
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                // call the original finish function
                return _super.prototype.finish.call(this).then(function () {
                    // if the step is valid indicate that it is now complete
                    if (step.valid) {
                        step.setCompleted(true);
                    }
                    else {
                        _this.stepError.next(_this.step);
                    }
                });
            };
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         */
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
        MarqueeWizardComponent.prototype.validChange = /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
            function (state) {
                var /** @type {?} */ steps = this.steps.toArray();
                var /** @type {?} */ current = steps.findIndex(function (step) { return step === state.step; });
                var /** @type {?} */ affected = steps.slice(current);
                affected.forEach(function (step) {
                    // the step should no longer be completed
                    step.completed = false;
                    // if the step is not the current step then also mark it as unvisited
                    if (step !== state.step) {
                        step.visited = false;
                    }
                });
            };
        MarqueeWizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard',
                        template: "<div class=\"marquee-wizard-side-panel\">\n\n    <div class=\"marquee-wizard-description-container\" *ngIf=\"description\">\n        <!-- If a template was provided display it -->\n        <ng-container *ngIf=\"isTemplate\" [ngTemplateOutlet]=\"description\"></ng-container>\n\n        <!-- Otherwise wimply display the string -->\n        <ng-container *ngIf=\"!isTemplate\">\n            <p>{{ description }}</p>\n        </ng-container>\n    </div>\n\n    <ul class=\"marquee-wizard-steps\"\n        uxTabbableList\n        direction=\"vertical\"\n        role=\"tablist\"\n        aria-orientation=\"vertical\">\n\n        <li *ngFor=\"let step of steps; let index = index\"\n            role=\"tab\"\n            uxTabbableListItem\n            [disabled]=\"!step.visited\"\n            class=\"marquee-wizard-step\"\n            [class.active]=\"step.active\"\n            [class.visited]=\"step.visited\"\n            [class.invalid]=\"!step.valid\"\n            [attr.aria-posinset]=\"index + 1\"\n            [attr.aria-setsize]=\"steps.length\"\n            [attr.aria-selected]=\"step.active\"\n            [attr.aria-controls]=\"step.id\"\n            [id]=\"step.id + '-label'\"\n            (click)=\"gotoStep(step)\"\n            (keydown.enter)=\"gotoStep(step)\">\n\n            <i class=\"marquee-wizard-step-icon\" [ngClass]=\"step.icon\"></i>\n            <span class=\"marquee-wizard-step-title\">{{ step.header }}</span>\n            <span class=\"marquee-wizard-step-status hpe-icon hpe-checkmark\" *ngIf=\"step.completed\"></span>\n        </li>\n\n    </ul>\n</div>\n\n<div class=\"marquee-wizard-content-panel\">\n    <div class=\"marquee-wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n    <div class=\"modal-footer\">\n\n        <button #tip=\"ux-tooltip\"\n                class=\"btn button-secondary\"\n                *ngIf=\"previousVisible\"\n                [uxTooltip]=\"previousTooltip\"\n                [attr.aria-label]=\"previousAriaLabel\"\n                container=\"body\"\n                [disabled]=\"previousDisabled || step === 0\"\n                (click)=\"previous(); tip.hide()\">\n                {{ previousText }}\n        </button>\n\n        <button #tip=\"ux-tooltip\"\n                class=\"btn button-primary\"\n                *ngIf=\"nextVisible && !isLastStep()\"\n                [uxTooltip]=\"nextTooltip\"\n                [attr.aria-label]=\"nextAriaLabel\"\n                container=\"body\"\n                [disabled]=\"nextDisabled\"\n                (click)=\"next(); tip.hide()\">\n                {{ nextText }}\n        </button>\n\n        <button #tip=\"ux-tooltip\"\n                class=\"btn button-primary\"\n                *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\"\n                [uxTooltip]=\"finishTooltip\"\n                [attr.aria-label]=\"finishAriaLabel\"\n                container=\"body\"\n                [disabled]=\"finishDisabled\"\n                (click)=\"finish(); tip.hide()\">\n                {{ finishText }}\n        </button>\n\n        <button #tip=\"ux-tooltip\"\n                class=\"btn button-secondary\"\n                *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\"\n                [uxTooltip]=\"cancelTooltip\"\n                [attr.aria-label]=\"cancelAriaLabel\"\n                container=\"body\"\n                [disabled]=\"cancelDisabled\"\n                (click)=\"cancel(); tip.hide()\">\n                {{ cancelText }}\n        </button>\n    </div>\n</div>",
                        providers: [MarqueeWizardService]
                    }] }
        ];
        /** @nocollapse */
        MarqueeWizardComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService }
            ];
        };
        MarqueeWizardComponent.propDecorators = {
            description: [{ type: core.Input }],
            steps: [{ type: core.ContentChildren, args: [MarqueeWizardStepComponent,] }]
        };
        return MarqueeWizardComponent;
    }(WizardComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardModule = (function () {
        function MarqueeWizardModule() {
        }
        MarqueeWizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            WizardModule,
                            TooltipModule,
                            AccessibilityModule
                        ],
                        exports: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ],
                        declarations: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ]
                    },] }
        ];
        return MarqueeWizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionService = (function () {
        function FrameExtractionService() {
        }
        /**
         * @param {?} source
         * @return {?}
         */
        FrameExtractionService.prototype.createVideoPlayer = /**
         * @param {?} source
         * @return {?}
         */
            function (source) {
                var /** @type {?} */ videoPlayer = document.createElement('video');
                videoPlayer.preload = 'auto';
                videoPlayer.src = source;
                return videoPlayer;
            };
        /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        FrameExtractionService.prototype.createCanvas = /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (width, height) {
                var /** @type {?} */ canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            };
        /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.goToFrame = /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
            function (videoPlayer, time) {
                videoPlayer.currentTime = time;
                return fromEvent.fromEvent(videoPlayer, time === 0 ? 'loadeddata' : 'seeked');
            };
        /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
        FrameExtractionService.prototype.getThumbnail = /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
            function (videoPlayer, canvas, time, width, height) {
                var _this = this;
                if (width === void 0) {
                    width = 160;
                }
                if (height === void 0) {
                    height = 90;
                }
                return Observable.Observable.create(function (observer) {
                    // go to specified frame
                    var /** @type {?} */ subscription = _this.goToFrame(videoPlayer, time).subscribe(function () {
                        // create image from current frame
                        canvas.getContext('2d').drawImage(videoPlayer, 0, 0, width, height);
                        observer.next({ image: canvas.toDataURL(), width: width, height: height, time: time });
                        observer.complete();
                        subscription.unsubscribe();
                    });
                });
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnail = /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
            function (source, width, height, time) {
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                var /** @type {?} */ frameSubscription = this.getThumbnail(videoPlayer, canvas, time, width, height);
                // ensure we release memory after we are finished
                frameSubscription.subscribe(null, null, function () {
                    videoPlayer = null;
                    canvas = null;
                });
                return frameSubscription;
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnails = /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
            function (source, width, height, start, end, skip) {
                var _this = this;
                if (skip === void 0) {
                    skip = 5;
                }
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                return Observable.Observable.create(function (observer) {
                    fromEvent.fromEvent(videoPlayer, 'loadedmetadata').subscribe(function () {
                        // calculate the frames required
                        var /** @type {?} */ frames = [];
                        for (var /** @type {?} */ idx = start; idx < end; idx += skip) {
                            frames.push(_this.getThumbnail(videoPlayer, canvas, idx, width, height));
                        }
                        concat.concat.apply(void 0, __spread(frames)).subscribe(function (frame) { return observer.next(frame); }, null, function () {
                            videoPlayer = null;
                            canvas = null;
                            observer.complete();
                        });
                    });
                });
            };
        FrameExtractionService.decorators = [
            { type: core.Injectable }
        ];
        return FrameExtractionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionModule = (function () {
        function FrameExtractionModule() {
        }
        FrameExtractionModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [FrameExtractionService],
                    },] }
        ];
        return FrameExtractionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerService = (function () {
        function MediaPlayerService(_frameExtractionService) {
            var _this = this;
            this._frameExtractionService = _frameExtractionService;
            this.type = 'video';
            this.loaded = false;
            /*
                    Create observables for media player events
                */
            this.playing = new BehaviorSubject.BehaviorSubject(false);
            this.initEvent = new ReplaySubject.ReplaySubject();
            this.abortEvent = new Subject.Subject();
            this.canPlayEvent = new BehaviorSubject.BehaviorSubject(false);
            this.canPlayThroughEvent = new BehaviorSubject.BehaviorSubject(false);
            this.durationChangeEvent = new Subject.Subject();
            this.endedEvent = new Subject.Subject();
            this.errorEvent = new Subject.Subject();
            this.loadedDataEvent = new Subject.Subject();
            this.loadedMetadataEvent = new Subject.Subject();
            this.loadStartEvent = new Subject.Subject();
            this.pauseEvent = new Subject.Subject();
            this.playEvent = new Subject.Subject();
            this.playingEvent = new Subject.Subject();
            this.rateChangeEvent = new Subject.Subject();
            this.seekedEvent = new Subject.Subject();
            this.seekingEvent = new Subject.Subject();
            this.stalledEvent = new Subject.Subject();
            this.suspendEvent = new Subject.Subject();
            this.timeUpdateEvent = new Subject.Subject();
            this.volumeChangeEvent = new Subject.Subject();
            this.waitingEvent = new Subject.Subject();
            this.mediaClickEvent = new Subject.Subject();
            this.fullscreenEvent = new BehaviorSubject.BehaviorSubject(false);
            this.quietModeEvent = new BehaviorSubject.BehaviorSubject(false);
            this.progressEvent = Observable.Observable.create(function (observer) {
                // repeat until the whole video has fully loaded
                var /** @type {?} */ interval = setInterval(function () {
                    var /** @type {?} */ buffered = (_this._mediaPlayer.buffered);
                    observer.next(buffered);
                    if (buffered.length === 1 && buffered.start(0) === 0 && buffered.end(0) === _this.duration) {
                        observer.complete();
                        clearInterval(interval);
                    }
                }, 1000);
            });
            this._fullscreen = false;
        }
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayer", {
            /*
                Create all the getters and setters the can be used by media player extensions
            */
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this._quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // quiet mode cannot be enabled on audio player
                if (this.type === 'audio') {
                    value = false;
                }
                this._quietMode = value;
                this.quietModeEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetWidth : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetHeight : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "audioTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.audioTracks : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "autoplay", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.autoplay : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.autoplay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "buffered", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.buffered : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "crossOrigin", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.crossOrigin : null;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.crossOrigin = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentSrc", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentSrc : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentTime", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentTime : 0;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.currentTime = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultMuted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultMuted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultMuted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultPlaybackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultPlaybackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultPlaybackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "duration", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.duration : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "ended", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.ended : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "loop", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.loop : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "muted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.muted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.muted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "networkState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer.networkState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "paused", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.paused : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "playbackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.playbackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.playbackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "played", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.played : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "preload", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.preload : 'auto';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.preload = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "readyState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.readyState : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seekable", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seekable : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seeking", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seeking : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "src", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.src : '';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.src = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "textTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.textTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "videoTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.videoTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.volume : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._mediaPlayer) {
                    this._mediaPlayer.volume = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "fullscreen", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._fullscreen : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._fullscreen = value;
                this.fullscreenEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
        MediaPlayerService.prototype.setMediaPlayer = /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
            function (hostElement, mediaPlayer) {
                this._hostElement = hostElement;
                this._mediaPlayer = mediaPlayer;
                this.initEvent.next(true);
            };
        /**
         * Toggle playing state
         */
        /**
         * Toggle playing state
         * @return {?}
         */
        MediaPlayerService.prototype.togglePlay = /**
         * Toggle playing state
         * @return {?}
         */
            function () {
                // prevent any action is not loaded
                if (this.loaded === false) {
                    return;
                }
                if (this.paused) {
                    this.play();
                }
                else {
                    this.pause();
                }
            };
        /**
         * Starts playing the audio/video
         */
        /**
         * Starts playing the audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.play = /**
         * Starts playing the audio/video
         * @return {?}
         */
            function () {
                this._mediaPlayer.play();
            };
        /**
         * Pauses the currently playing audio/video
         */
        /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.pause = /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
            function () {
                this._mediaPlayer.pause();
            };
        /**
         * Re-loads the audio/video element
         */
        /**
         * Re-loads the audio/video element
         * @return {?}
         */
        MediaPlayerService.prototype.load = /**
         * Re-loads the audio/video element
         * @return {?}
         */
            function () {
                this._mediaPlayer.load();
            };
        /**
         * Checks if the browser can play the specified audio/video type
         */
        /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
        MediaPlayerService.prototype.canPlayType = /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
            function (type) {
                return this._mediaPlayer.canPlayType(type);
            };
        /**
         * Adds a new text track to the audio/video
         */
        /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
        MediaPlayerService.prototype.addTextTrack = /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
            function (kind, label, language) {
                return this._mediaPlayer.addTextTrack(kind, label, language);
            };
        /**
         * Attempt to display media in fullscreen mode
         */
        /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
        MediaPlayerService.prototype.requestFullscreen = /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
            function () {
                if (this._hostElement.requestFullscreen) {
                    this._hostElement.requestFullscreen();
                }
                else if (this._hostElement.webkitRequestFullscreen) {
                    this._hostElement.webkitRequestFullscreen();
                }
                else if (((this._hostElement)).msRequestFullscreen) {
                    ((this._hostElement)).msRequestFullscreen();
                }
                else if (((this._hostElement)).mozRequestFullScreen) {
                    ((this._hostElement)).mozRequestFullScreen();
                }
            };
        /**
         * Exit full screen mode
         */
        /**
         * Exit full screen mode
         * @return {?}
         */
        MediaPlayerService.prototype.exitFullscreen = /**
         * Exit full screen mode
         * @return {?}
         */
            function () {
                if (((this._hostElement)).exitFullscreen) {
                    document.exitFullscreen();
                }
                else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                else if (((document)).msExitFullscreen) {
                    ((document)).msExitFullscreen();
                }
                else if (((document)).mozCancelFullScreen) {
                    ((document)).mozCancelFullScreen();
                }
            };
        /**
         * @return {?}
         */
        MediaPlayerService.prototype.fullscreenChange = /**
         * @return {?}
         */
            function () {
                this.fullscreen = ((document)).fullscreen || document.webkitIsFullScreen || ((document)).mozFullScreen || ((document)).msFullscreenElement !== null && ((document)).msFullscreenElement !== undefined;
                this.fullscreenEvent.next(this.fullscreen);
            };
        /**
         * Toggle Fullscreen State
         */
        /**
         * Toggle Fullscreen State
         * @return {?}
         */
        MediaPlayerService.prototype.toggleFullscreen = /**
         * Toggle Fullscreen State
         * @return {?}
         */
            function () {
                if (this.fullscreen) {
                    this.exitFullscreen();
                }
                else {
                    this.requestFullscreen();
                }
            };
        /**
         * Extract the frames from the video
         */
        /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
        MediaPlayerService.prototype.getFrames = /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
            function (width, height, skip) {
                if (this.type === 'video') {
                    return this._frameExtractionService.getFrameThumbnails(this.source, width, height, 0, this.duration, 10);
                }
                return from.from([]);
            };
        /**
         * @return {?}
         */
        MediaPlayerService.prototype.hideSubtitleTracks = /**
         * @return {?}
         */
            function () {
                for (var /** @type {?} */ index = 0; index < this.textTracks.length; index++) {
                    this.textTracks[index].mode = 'hidden';
                }
            };
        MediaPlayerService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        MediaPlayerService.ctorParameters = function () {
            return [
                { type: FrameExtractionService }
            ];
        };
        return MediaPlayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerBaseExtensionDirective = (function () {
        function MediaPlayerBaseExtensionDirective(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
        }
        MediaPlayerBaseExtensionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mediaPlayerBaseExtension]'
                    },] }
        ];
        /** @nocollapse */
        MediaPlayerBaseExtensionDirective.ctorParameters = function () {
            return [
                { type: MediaPlayerService }
            ];
        };
        return MediaPlayerBaseExtensionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorServiceModule = (function () {
        function ColorServiceModule() {
        }
        ColorServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [ColorService],
                    },] }
        ];
        return ColorServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderComponent = (function () {
        function SliderComponent(colorService, _changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.value = 0;
            this.valueChange = new core.EventEmitter();
            // expose enums to Angular view
            this.sliderType = SliderType;
            this.sliderStyle = SliderStyle;
            this.sliderSize = SliderSize;
            this.sliderSnap = SliderSnap;
            this.sliderThumb = SliderThumb;
            this.sliderTickType = SliderTickType;
            this.sliderThumbEvent = SliderThumbEvent;
            this.sliderCalloutTrigger = SliderCalloutTrigger;
            this.tracks = {
                lower: {
                    size: 0,
                    color: ''
                },
                middle: {
                    size: 0,
                    color: ''
                },
                upper: {
                    size: 0,
                    color: ''
                }
            };
            this.tooltips = {
                lower: {
                    visible: false,
                    position: 0,
                    label: ''
                },
                upper: {
                    visible: false,
                    position: 0,
                    label: ''
                }
            };
            this.thumbs = {
                lower: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 100,
                    value: /** @type {?} */ (null)
                },
                upper: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 101,
                    value: /** @type {?} */ (null)
                }
            };
            // store all the ticks to display
            this.ticks = [];
            // setup default options
            this.defaultOptions = {
                type: SliderType.Value,
                handles: {
                    style: SliderStyle.Button,
                    callout: {
                        trigger: SliderCalloutTrigger.None,
                        background: colorService.getColor('grey2').toHex(),
                        color: '#fff',
                        formatter: function (value) { return value; }
                    },
                    keyboard: {
                        major: 5,
                        minor: 1
                    },
                    aria: {
                        thumb: 'Slider value',
                        lowerThumb: 'Slider lower value',
                        upperThumb: 'Slider upper value'
                    }
                },
                track: {
                    height: SliderSize.Wide,
                    min: 0,
                    max: 100,
                    ticks: {
                        snap: SliderSnap.None,
                        major: {
                            show: true,
                            steps: 10,
                            labels: true,
                            formatter: function (value) { return value; }
                        },
                        minor: {
                            show: true,
                            steps: 5,
                            labels: false,
                            formatter: function (value) { return value; }
                        }
                    },
                    colors: {
                        lower: colorService.getColor('grey6').toHex(),
                        range: colorService.getColor('accent').setAlpha(0.75).toRgba(),
                        higher: colorService.getColor('grey6').toHex()
                    }
                }
            };
        }
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.updateOptions();
                this.updateValues();
                this.setThumbState(SliderThumb.Lower, false, false);
                this.setThumbState(SliderThumb.Upper, false, false);
                // emit the initial value
                this.valueChange.next(this.clone(this.value));
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (this.detectValueChange(this.value, this._value)) {
                    this.updateValues();
                    this._value = this.clone(this.value);
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // persistent tooltips will need positioned correctly at this stage
                setTimeout(function () {
                    _this.updateTooltipPosition(SliderThumb.Lower);
                    _this.updateTooltipPosition(SliderThumb.Upper);
                    // mark as dirty
                    // mark as dirty
                    _this._changeDetectorRef.markForCheck();
                });
            };
        /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToNearestTick = /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
            function (thumb, snapTarget, forwards) {
                // get the value for the thumb
                var value = this.getThumbState(thumb).value;
                // get the closest ticks - remove any tick if we are currently on it
                var /** @type {?} */ closest = this.getTickDistances(value, thumb, snapTarget)
                    .filter(function (tick) { return tick.value !== value; })
                    .find(function (tick) { return forwards ? tick.value > value : tick.value < value; });
                // If we have no ticks then move by a predefined amount
                if (closest) {
                    return this.setThumbValue(thumb, this.validateValue(thumb, closest.value));
                }
                var /** @type {?} */ step = snapTarget === SliderSnap.Major ? this.options.handles.keyboard.major : this.options.handles.keyboard.minor;
                this.setThumbValue(thumb, this.validateValue(thumb, value + (forwards ? step : -step)));
            };
        /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToEnd = /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
            function (thumb, forwards) {
                this.setThumbValue(thumb, this.validateValue(thumb, forwards ? this.options.track.max : this.options.track.min));
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbValue = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return this.getThumbState(thumb).value;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getFormattedValue = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return this.options.handles.callout.formatter(this.getThumbState(thumb).value);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbState = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.thumbs.lower : this.thumbs.upper;
            };
        /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
        SliderComponent.prototype.setThumbState = /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
            function (thumb, hover, drag) {
                if (thumb === SliderThumb.Lower) {
                    this.thumbs.lower.hover = hover;
                    this.thumbs.lower.drag = drag;
                }
                else {
                    this.thumbs.upper.hover = hover;
                    this.thumbs.upper.drag = drag;
                }
                // update the visibility of the tooltips
                this.updateTooltips(thumb);
            };
        /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.thumbEvent = /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
            function (thumb, event) {
                // get the current thumb state
                var /** @type {?} */ state = this.getThumbState(thumb);
                // update based upon event
                switch (event) {
                    case SliderThumbEvent.DragStart:
                        state.drag = true;
                        break;
                    case SliderThumbEvent.DragEnd:
                        state.drag = false;
                        break;
                    case SliderThumbEvent.MouseOver:
                        state.hover = true;
                        break;
                    case SliderThumbEvent.MouseLeave:
                        state.hover = false;
                        break;
                    case SliderThumbEvent.None:
                        state.drag = false;
                        state.hover = false;
                        break;
                }
                // update the thumb state
                this.setThumbState(thumb, state.hover, state.drag);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getAriaValueText = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                // get the current thumb value
                var /** @type {?} */ value = this.getThumbValue(thumb);
                // get all the ticks
                var /** @type {?} */ tick = this.ticks.find(function (_tick) { return _tick.value === value; });
                if (tick && tick.label) {
                    return tick.label;
                }
                // otherwise simply display the formatted value
                return this.getFormattedValue(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltips = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                var /** @type {?} */ visible = false;
                var /** @type {?} */ state = this.getThumbState(thumb);
                switch (this.options.handles.callout.trigger) {
                    case SliderCalloutTrigger.Persistent:
                        visible = true;
                        break;
                    case SliderCalloutTrigger.Drag:
                        visible = state.drag;
                        break;
                    case SliderCalloutTrigger.Hover:
                        visible = state.hover || state.drag;
                        break;
                    case SliderCalloutTrigger.Dynamic:
                        visible = true;
                        break;
                }
                // update the state for the corresponding thumb
                this.getTooltip(thumb).visible = visible;
                // update the tooltip text
                this.updateTooltipText(thumb);
                // update the tooltip positions
                this.updateTooltipPosition(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipText = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                // get the thumb value
                var /** @type {?} */ state = this.getThumbState(thumb);
                var /** @type {?} */ tooltip = this.getTooltip(thumb);
                // store the formatted label
                tooltip.label = this.getFormattedValue(thumb).toString();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltipElement = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.lowerTooltip : this.upperTooltip;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltip = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.tooltips.lower : this.tooltips.upper;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipPosition = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                var /** @type {?} */ tooltip = this.getTooltip(thumb);
                // if tooltip is not visible then stop here
                if (tooltip.visible === false) {
                    return;
                }
                var /** @type {?} */ tooltipElement = this.getTooltipElement(thumb);
                // get the element widths
                var /** @type {?} */ thumbWidth;
                if (this.options.handles.style === SliderStyle.Button) {
                    thumbWidth = this.options.track.height === SliderSize.Narrow ? 16 : 24;
                }
                else {
                    thumbWidth = 2;
                }
                var /** @type {?} */ tooltipWidth = tooltipElement.nativeElement.offsetWidth;
                // calculate the tooltips new position
                var /** @type {?} */ tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);
                // update tooltip position
                tooltip.position = -tooltipPosition;
                if (this.options.type === SliderType.Range && this.options.handles.callout.trigger === SliderCalloutTrigger.Dynamic) {
                    this.preventTooltipOverlap(tooltip);
                }
            };
        /**
         * @param {?} tooltip
         * @return {?}
         */
        SliderComponent.prototype.preventTooltipOverlap = /**
         * @param {?} tooltip
         * @return {?}
         */
            function (tooltip) {
                var /** @type {?} */ trackWidth = this.track.nativeElement.offsetWidth;
                var /** @type {?} */ lower = (trackWidth / 100) * this.thumbs.lower.position;
                var /** @type {?} */ upper = (trackWidth / 100) * this.thumbs.upper.position;
                var /** @type {?} */ lowerWidth = this.lowerTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ upperWidth = this.upperTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ diff = (lower + lowerWidth) - (upper - upperWidth);
                // if the tooltips are closer than 16px then adjust so the dont move any close
                if (diff > 0) {
                    if (tooltip === this.tooltips.lower && this.thumbs.lower.drag === false) {
                        tooltip.position -= (diff / 2);
                    }
                    else if (tooltip === this.tooltips.upper && this.thumbs.upper.drag === false) {
                        tooltip.position += (diff / 2);
                    }
                }
            };
        /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
        SliderComponent.prototype.clamp = /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
            function (value, min, max) {
                return Math.min(Math.max(value, min), max);
            };
        /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateThumbPosition = /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
            function (event, thumb) {
                // get event position - either mouse or touch
                var /** @type {?} */ eventPosition = event instanceof MouseEvent ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;
                // if event position is null do nothing
                if (eventPosition === null) {
                    return;
                }
                // get mouse position
                var /** @type {?} */ mouseX = window.pageXOffset + eventPosition;
                // get track size and position
                var /** @type {?} */ trackBounds = this.track.nativeElement.getBoundingClientRect();
                // restrict the value within the range size
                var /** @type {?} */ position = this.clamp(mouseX - trackBounds.left, 0, trackBounds.width);
                // get fraction representation of location within the track
                var /** @type {?} */ fraction = (position / trackBounds.width);
                // convert to value within the range
                var /** @type {?} */ value = ((this.options.track.max - this.options.track.min) * fraction) + this.options.track.min;
                // ensure value is valid
                value = this.validateValue(thumb, value);
                // snap to a tick if required
                value = this.snapToTick(value, thumb);
                // update the value accordingly
                this.setThumbValue(thumb, value);
                this.updateOrder(thumb);
                this.updateValues();
                // update tooltip text & position
                this.updateTooltipText(thumb);
                // update the position of all visible tooltips
                this.updateTooltipPosition(SliderThumb.Lower);
                this.updateTooltipPosition(SliderThumb.Upper);
                // mark as dirty for change detection
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateOrder = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                var /** @type {?} */ lower = thumb === SliderThumb.Lower ? 101 : 100;
                var /** @type {?} */ upper = thumb === SliderThumb.Lower ? 100 : 101;
                // The most recently used thumb should be above
                this.thumbs.lower.order = lower;
                this.thumbs.upper.order = upper;
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
        SliderComponent.prototype.getTickDistances = /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
            function (value, thumb, snapTarget) {
                // if snap target is none then return original value
                if (snapTarget === SliderSnap.None) {
                    return [];
                }
                // get filtered ticks
                var /** @type {?} */ ticks;
                switch (snapTarget) {
                    case SliderSnap.Minor:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Minor; });
                        break;
                    case SliderSnap.Major:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Major; });
                        break;
                    default:
                        ticks = this.ticks.slice(0);
                }
                // get the track limit
                var /** @type {?} */ lowerLimit = this.options.track.min;
                var /** @type {?} */ upperLimit = this.options.track.max;
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Lower) {
                    upperLimit = this.thumbs.upper.value;
                }
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Upper) {
                    lowerLimit = this.thumbs.lower.value;
                }
                // Find the closest tick to the current position
                var /** @type {?} */ range = ticks.filter(function (tick) { return tick.value >= lowerLimit && tick.value <= upperLimit; });
                // If there are no close ticks in the valid range then dont snap
                if (range.length === 0) {
                    return [];
                }
                return range.sort(function (tickOne, tickTwo) {
                    var /** @type {?} */ tickOneDelta = Math.max(tickOne.value, value) - Math.min(tickOne.value, value);
                    var /** @type {?} */ tickTwoDelta = Math.max(tickTwo.value, value) - Math.min(tickTwo.value, value);
                    return tickOneDelta - tickTwoDelta;
                });
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.snapToTick = /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
            function (value, thumb) {
                var /** @type {?} */ tickDistances = this.getTickDistances(value, thumb, this.options.track.ticks.snap);
                // if there are no ticks return the current value
                if (tickDistances.length === 0) {
                    return value;
                }
                // get the closest tick
                return tickDistances[0].value;
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.validateValue = /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
            function (thumb, value) {
                // if slider is not a range value is always valid providing it is within the chart min and max values
                if (this.options.type === SliderType.Value) {
                    return Math.max(Math.min(value, this.options.track.max), this.options.track.min);
                }
                // check if value is with chart ranges
                if (value > this.options.track.max) {
                    return thumb === SliderThumb.Lower ? Math.min(this.options.track.max, this.thumbs.upper.value) : this.options.track.max;
                }
                if (value < this.options.track.min) {
                    return thumb === SliderThumb.Upper ? Math.max(this.options.track.min, this.thumbs.lower.value) : this.options.track.min;
                }
                // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
                if (thumb === SliderThumb.Lower) {
                    if (this.thumbs.upper.value === null) {
                        return value;
                    }
                    return value <= this.thumbs.upper.value ? value : this.thumbs.upper.value;
                }
                if (thumb === SliderThumb.Upper) {
                    if (this.thumbs.lower.value === null) {
                        return value;
                    }
                    return value >= this.thumbs.lower.value ? value : this.thumbs.lower.value;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateOptions = /**
         * @return {?}
         */
            function () {
                // add in the default options that user hasn't specified
                this.options = this.deepMerge(this.options || {}, this.defaultOptions);
                this.updateTrackColors();
                this.updateTicks();
                this.updateValues();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateValues = /**
         * @return {?}
         */
            function () {
                if (this.value === undefined || this.value === null) {
                    this.value = 0;
                }
                var /** @type {?} */ lowerValue = typeof this.value === 'number' ? this.value : this.value.low;
                var /** @type {?} */ upperValue = typeof this.value === 'number' ? this.value : this.value.high;
                // validate values
                lowerValue = this.validateValue(SliderThumb.Lower, Number(lowerValue.toFixed(4)));
                upperValue = this.validateValue(SliderThumb.Upper, Number(upperValue.toFixed(4)));
                // calculate the positions as percentages
                var /** @type {?} */ lowerPosition = (((lowerValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                var /** @type {?} */ upperPosition = (((upperValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                // update thumb positions
                this.thumbs.lower.position = lowerPosition;
                this.thumbs.upper.position = upperPosition;
                // calculate the track sizes
                this.tracks.lower.size = lowerPosition;
                this.tracks.middle.size = upperPosition - lowerPosition;
                this.tracks.upper.size = this.options.type === SliderType.Value ? 100 - lowerPosition : 100 - upperPosition;
                // update the value input
                this.setValue(lowerValue, upperValue);
            };
        /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
        SliderComponent.prototype.setValue = /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
            function (low, high) {
                this.thumbs.lower.value = low;
                this.thumbs.upper.value = high;
                var /** @type {?} */ previousValue = this.clone(this._value);
                this.value = this.options.type === SliderType.Value ? low : { low: low, high: high };
                // call the event emitter if changes occured
                if (this.detectValueChange(this.value, previousValue)) {
                    this.valueChange.emit(this.clone(this.value));
                    this.updateTooltipText(SliderThumb.Lower);
                    this.updateTooltipText(SliderThumb.Upper);
                }
                else {
                    this.valueChange.emit(this.clone(this.value));
                }
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.setThumbValue = /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
            function (thumb, value) {
                // update the thumb value
                this.getThumbState(thumb).value = value;
                // forward these changes to the value
                this.setValue(this.thumbs.lower.value, this.thumbs.upper.value);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTicks = /**
         * @return {?}
         */
            function () {
                // get tick options
                var /** @type {?} */ majorOptions = this.options.track.ticks.major;
                var /** @type {?} */ minorOptions = this.options.track.ticks.minor;
                // check if we should show ticks
                if (majorOptions.show === false && minorOptions.show === false) {
                    this.ticks = [];
                }
                // create ticks for both major and minor - only get the ones to be shown
                var /** @type {?} */ majorTicks = this.getTicks(majorOptions, SliderTickType.Major).filter(function (tick) { return tick.showTicks; });
                var /** @type {?} */ minorTicks = this.getTicks(minorOptions, SliderTickType.Minor).filter(function (tick) { return tick.showTicks; });
                // remove any minor ticks that are on a major interval
                this.ticks = this.unionTicks(majorTicks, minorTicks);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTrackColors = /**
         * @return {?}
         */
            function () {
                // get colors for each part of the track
                var _a = this.options.track.colors, lower = _a.lower, range = _a.range, higher = _a.higher;
                // update the controller value
                this.tracks.lower.color = typeof lower === 'string' ? lower : "linear-gradient(to right, " + lower.join(', ') + ")";
                this.tracks.middle.color = typeof range === 'string' ? range : "linear-gradient(to right, " + range.join(', ') + ")";
                this.tracks.upper.color = typeof higher === 'string' ? higher : "linear-gradient(to right, " + higher.join(', ') + ")";
            };
        /**
         * @param {?} steps
         * @return {?}
         */
        SliderComponent.prototype.getSteps = /**
         * @param {?} steps
         * @return {?}
         */
            function (steps) {
                // if they are already an array just return it
                if (steps instanceof Array) {
                    return steps;
                }
                var /** @type {?} */ output = [];
                // otherwise calculate the steps
                for (var /** @type {?} */ idx = this.options.track.min; idx <= this.options.track.max; idx += steps) {
                    output.push(idx);
                }
                return output;
            };
        /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
        SliderComponent.prototype.getTicks = /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
            function (options, type) {
                // create an array to store the ticks and step points
                var /** @type {?} */ steps = this.getSteps(options.steps);
                // get some chart options
                var /** @type {?} */ min = this.options.track.min;
                var /** @type {?} */ max = this.options.track.max;
                // convert each step to a slider tick and remove invalid ticks
                return steps.map(function (step) {
                    return {
                        showTicks: options.show,
                        showLabels: options.labels,
                        type: type,
                        position: ((step - min) / (max - min)) * 100,
                        value: step,
                        label: options.formatter(step)
                    };
                }).filter(function (tick) { return tick.position >= 0 && tick.position <= 100; });
            };
        /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
        SliderComponent.prototype.unionTicks = /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
            function (majorTicks, minorTicks) {
                // get all ticks combined removing any minor ticks with the same value as major ticks
                return majorTicks.concat(minorTicks)
                    .filter(function (tick, index, array) { return tick.type === SliderTickType.Major || !array.find(function (tk) { return tk.type === SliderTickType.Major && tk.position === tick.position; }); })
                    .sort(function (t1, t2) { return t1.value - t2.value; });
            };
        /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
        SliderComponent.prototype.deepMerge = /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
            function (destination, source) {
                // loop though all of the properties in the source object
                for (var /** @type {?} */ prop in source) {
                    // check if the destination object has the property
                    if (!destination.hasOwnProperty(prop)) {
                        // copy the property across
                        destination[prop] = source[prop];
                        continue;
                    }
                    // if the property exists and is not an object then skip
                    if (typeof destination[prop] !== 'object') {
                        continue;
                    }
                    // check if property is an array
                    if (destination[prop] instanceof Array) {
                        continue;
                    }
                    // if it is an object then perform a recursive check
                    destination[prop] = this.deepMerge(destination[prop], source[prop]);
                }
                return destination;
            };
        /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
        SliderComponent.prototype.detectValueChange = /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
            function (value1, value2) {
                // compare two slider values
                if (this.isSliderValue(value1) && this.isSliderValue(value2)) {
                    // references to the objects in the correct types
                    var /** @type {?} */ obj1 = (value1);
                    var /** @type {?} */ obj2 = (value2);
                    return obj1.low !== obj2.low || obj1.high !== obj2.high;
                }
                // if not a slider value - should be number of nullable type - compare normally
                return value1 !== value2;
            };
        /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
        SliderComponent.prototype.isSliderValue = /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
            function (value) {
                // check if is an object
                if (typeof value !== 'object') {
                    return false;
                }
                // next check if it contains the necessary properties
                return 'low' in value && 'high' in value;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.clone = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // if it is not an object simply return the value
                if (typeof value !== 'object') {
                    return value;
                }
                // create a new object from the existing one
                var /** @type {?} */ instance = __assign({}, value);
                // delete remove the value from the old object
                value = undefined;
                // return the new instance of the object
                return instance;
            };
        SliderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-slider',
                        template: "<div class=\"track\" #track [class.narrow]=\"options.track.height === sliderSize.Narrow\" [class.wide]=\"options.track.height === sliderSize.Wide\" [class.range]=\"options.type === sliderType.Range\">\n\n    <!-- Section Beneath Lower Thumb -->\n    <div class=\"track-section track-lower\" [style.flex-grow]=\"tracks.lower.size\" [style.background]=\"tracks.lower.color\"></div>\n\n    <!-- Lower Thumb Button / Line -->\n    <div class=\"thumb lower\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #lowerthumb\n        [attr.aria-label]=\"options.type === sliderType.Range ? options.handles.aria.lowerThumb : options.handles.aria.thumb\"\n        [attr.aria-valuemin]=\"options?.track?.min\"\n        [attr.aria-valuemax]=\"options.type === sliderType.Range ? getThumbValue(sliderThumb.Upper) : options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Lower)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Lower)\"\n        [style.left.%]=\"thumbs.lower.position\"\n        [class.active]=\"thumbs.lower.drag\"\n        [style.z-index]=\"thumbs.lower.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragStart); lowerthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Lower)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Lower, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Lower, true); $event.preventDefault()\">\n\n        <!-- Lower Thumb Callout -->\n        <div class=\"tooltip top tooltip-lower\" #lowerTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.lower.drag === false\"\n            [style.opacity]=\"tooltips.lower.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.lower.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.lower.label }}\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Section of Track Between Lower and Upper Thumbs -->\n    <div class=\"track-section track-range\" *ngIf=\"options.type === sliderType.Range\" [style.flex-grow]=\"tracks.middle.size\" [style.background]=\"tracks.middle.color\">\n    </div>\n\n    <!-- Upper Thumb Button / Line -->\n    <div class=\"thumb upper\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #upperthumb\n        [attr.aria-label]=\"options.handles.aria.upperThumb\"\n        [attr.aria-valuemin]=\"getThumbValue(sliderThumb.Lower) || options?.track?.min\"\n        [attr.aria-valuemax]=\"options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Upper)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Upper)\"\n        [hidden]=\"options.type !== sliderType.Range\"\n        [class.active]=\"thumbs.upper.drag\"\n        [style.left.%]=\"thumbs.upper.position\"\n        [style.z-index]=\"thumbs.upper.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragStart); upperthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Upper)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Upper, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Upper, true); $event.preventDefault()\">\n\n        <!-- Upper Thumb Callout -->\n        <div class=\"tooltip top tooltip-upper\" #upperTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.upper.drag === false\"\n            [style.opacity]=\"tooltips.upper.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.upper.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                *ngIf=\"options.type === sliderType.Range\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.upper.label }}\n            </div>\n        </div>\n    </div>\n\n    <!-- Section of Track Abover Upper Thumb -->\n    <div class=\"track-section track-higher\" [style.flex-grow]=\"tracks.upper.size\" [style.background]=\"tracks.upper.color\"></div>\n\n</div>\n\n<!-- Chart Ticks and Tick Labels -->\n<div class=\"tick-container\"\n    role=\"presentation\"\n    *ngIf=\"(options.track.ticks.major.show || options.track.ticks.minor.show) && options.handles.callout.trigger !== sliderCalloutTrigger.Dynamic\"\n    [class.show-labels]=\"options.track.ticks.major.labels || options.track.ticks.minor.labels\">\n\n    <div class=\"tick\"\n        *ngFor=\"let tick of ticks\"\n        [class.major]=\"tick.type === sliderTickType.Major\"\n        [class.minor]=\"tick.type === sliderTickType.Minor\"\n        [style.left.%]=\"tick.position\"\n        [hidden]=\"!tick.showTicks\">\n\n        <div class=\"tick-indicator\"></div>\n        <div class=\"tick-label\" aria-hidden=\"true\" [hidden]=\"!tick.showLabels\">{{ tick.label }}</div>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SliderComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: core.ChangeDetectorRef }
            ];
        };
        SliderComponent.propDecorators = {
            value: [{ type: core.Input }],
            options: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            lowerTooltip: [{ type: core.ViewChild, args: ['lowerTooltip',] }],
            upperTooltip: [{ type: core.ViewChild, args: ['upperTooltip',] }],
            track: [{ type: core.ViewChild, args: ['track',] }]
        };
        return SliderComponent;
    }());
    /** @enum {number} */
    var SliderType = {
        Value: 0,
        Range: 1,
    };
    SliderType[SliderType.Value] = "Value";
    SliderType[SliderType.Range] = "Range";
    /** @enum {number} */
    var SliderStyle = {
        Button: 0,
        Line: 1,
    };
    SliderStyle[SliderStyle.Button] = "Button";
    SliderStyle[SliderStyle.Line] = "Line";
    /** @enum {number} */
    var SliderSize = {
        Narrow: 0,
        Wide: 1,
    };
    SliderSize[SliderSize.Narrow] = "Narrow";
    SliderSize[SliderSize.Wide] = "Wide";
    /** @enum {number} */
    var SliderCalloutTrigger = {
        None: 0,
        Hover: 1,
        Drag: 2,
        Persistent: 3,
        Dynamic: 4,
    };
    SliderCalloutTrigger[SliderCalloutTrigger.None] = "None";
    SliderCalloutTrigger[SliderCalloutTrigger.Hover] = "Hover";
    SliderCalloutTrigger[SliderCalloutTrigger.Drag] = "Drag";
    SliderCalloutTrigger[SliderCalloutTrigger.Persistent] = "Persistent";
    SliderCalloutTrigger[SliderCalloutTrigger.Dynamic] = "Dynamic";
    /** @enum {number} */
    var SliderSnap = {
        None: 0,
        Minor: 1,
        Major: 2,
        All: 3,
    };
    SliderSnap[SliderSnap.None] = "None";
    SliderSnap[SliderSnap.Minor] = "Minor";
    SliderSnap[SliderSnap.Major] = "Major";
    SliderSnap[SliderSnap.All] = "All";
    /** @enum {number} */
    var SliderTickType = {
        Minor: 0,
        Major: 1,
    };
    SliderTickType[SliderTickType.Minor] = "Minor";
    SliderTickType[SliderTickType.Major] = "Major";
    /** @enum {number} */
    var SliderThumbEvent = {
        None: 0,
        MouseOver: 1,
        MouseLeave: 2,
        DragStart: 3,
        DragEnd: 4,
    };
    SliderThumbEvent[SliderThumbEvent.None] = "None";
    SliderThumbEvent[SliderThumbEvent.MouseOver] = "MouseOver";
    SliderThumbEvent[SliderThumbEvent.MouseLeave] = "MouseLeave";
    SliderThumbEvent[SliderThumbEvent.DragStart] = "DragStart";
    SliderThumbEvent[SliderThumbEvent.DragEnd] = "DragEnd";
    /** @enum {number} */
    var SliderThumb = {
        Lower: 0,
        Upper: 1,
    };
    SliderThumb[SliderThumb.Lower] = "Lower";
    SliderThumb[SliderThumb.Upper] = "Upper";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderModule = (function () {
        function SliderModule() {
        }
        SliderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            DragModule
                        ],
                        exports: [SliderComponent],
                        declarations: [SliderComponent]
                    },] }
        ];
        return SliderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$6 = 1;
    var MediaPlayerControlsExtensionComponent = (function (_super) {
        __extends(MediaPlayerControlsExtensionComponent, _super);
        function MediaPlayerControlsExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.volumeActive = false;
            _this.volumeFocus = false;
            _this.returnFocus = true;
            _this.subtitlesId = "ux-media-player-subtitle-popover-" + uniqueId$6++;
            _this.subtitlesOpen = false;
            _this.mouseEnterVolume = new Subject.Subject();
            _this.mouseLeaveVolume = new Subject.Subject();
            _this.options = {
                handles: {
                    aria: {
                        thumb: 'Volume'
                    }
                },
                track: {
                    colors: {
                        lower: '#666'
                    },
                    height: SliderSize.Narrow,
                    ticks: {
                        major: {
                            show: false
                        },
                        minor: {
                            show: false
                        }
                    }
                }
            };
            _this._volume = 50;
            _this._previousVolume = 50;
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        Object.defineProperty(MediaPlayerControlsExtensionComponent.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._volume;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === 0 && this._volume !== 0) {
                    this._previousVolume = this._volume;
                }
                this._volume = Math.min(Math.max(value, 0), 100);
                this.mediaPlayerService.volume = this._volume / 100;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.mediaPlayerService.volumeChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (volume) { return _this.volume = volume * 100; });
                this.mediaPlayerService.initEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volume = _this.mediaPlayerService.volume * 100; });
                this.mouseEnterVolume.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = true; });
                this.mouseLeaveVolume.pipe(operators.switchMap(function () { return timer.timer(1500).pipe(operators.takeUntil(_this.mouseEnterVolume)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.toggleMute = /**
         * @return {?}
         */
            function () {
                this.volume = this.volume === 0 ? this._previousVolume : 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToStart = /**
         * @return {?}
         */
            function () {
                this.mediaPlayerService.currentTime = 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToEnd = /**
         * @return {?}
         */
            function () {
                this.mediaPlayerService.currentTime = this.mediaPlayerService.duration;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.isSubtitleActive = /**
         * @return {?}
         */
            function () {
                for (var /** @type {?} */ idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                    if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                        return true;
                    }
                }
                return false;
            };
        /**
         * @param {?} track
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.setSubtitleTrack = /**
         * @param {?} track
         * @return {?}
         */
            function (track) {
                // hide all tracks
                this.mediaPlayerService.hideSubtitleTracks();
                // set the position of the subtitle track
                for (var /** @type {?} */ idx = 0; idx < track.cues.length; idx++) {
                    var /** @type {?} */ cue = track.cues[idx];
                    cue.line = -3;
                }
                // activate the selected one
                track.mode = 'showing';
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.getSubtitleTrack = /**
         * @return {?}
         */
            function () {
                for (var /** @type {?} */ idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                    if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                        return this.mediaPlayerService.textTracks[idx].label;
                    }
                }
                return 'No subtitles';
            };
        MediaPlayerControlsExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-controls',
                        template: "<div class=\"volume-container\">\n\n    <div class=\"volume-slider-container\"\n        #volumeContainer\n        [class.active]=\"volumeActive || volumeFocus\"\n        (mouseenter)=\"mouseEnterVolume.next()\"\n        (mouseleave)=\"mouseLeaveVolume.next()\"\n        (uxFocusWithin)=\"volumeFocus = true\"\n        (uxBlurWithin)=\"volumeFocus = false\">\n\n        <button #volumeIcon\n                class=\"volume-slider-icon\"\n                attr.aria-label=\"{{ volume === 0 ? 'Unmute' : 'Mute' }}\"\n                i18n-aria-label\n                [uxTooltip]=\"muteTooltip\"\n                [showTriggers]=\"['mouseenter']\"\n                [hideTriggers]=\"['mouseleave']\"\n                (click)=\"toggleMute()\"\n                (mouseup)=\"volumeIcon.blur()\">\n\n            <span class=\"hpe-icon\"\n                  [class.hpe-volume-mute]=\"volume === 0\"\n                  [class.hpe-volume-low]=\"volume > 0 && volume <= 70\"\n                  [class.hpe-volume]=\"volume > 70\">\n            </span>\n        </button>\n\n        <div class=\"volume-slider-node\">\n            <ux-slider [(value)]=\"volume\" [options]=\"options\"></ux-slider>\n        </div>\n    </div>\n</div>\n\n<button #startButton\n    class=\"control-button\"\n    (click)=\"goToStart()\"\n    (mouseup)=\"startButton.blur()\"\n    aria-label=\"Go to start\"\n    i18n-aria-label>\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"0\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"51.5,64 51.5,0 7.4,32 \" />\n    </svg>\n</button>\n\n<button #playButton\n    class=\"control-button\"\n    attr.aria-label=\"{{ (mediaPlayerService.playing | async) ? 'Pause' : 'Play' }}\"\n    i18n-aria-label\n    (click)=\"mediaPlayerService.togglePlay()\"\n    (mouseup)=\"playButton.blur()\">\n\n    <svg *ngIf=\"!(mediaPlayerService.playing | async)\" viewBox=\"0 0 45 64\" width=\"20\" height=\"29\" focusable=\"false\">\n        <polygon points=\"0.4,0 0.4,64 44.6,32\" />\n    </svg>\n    <svg *ngIf=\"mediaPlayerService.playing | async\" viewBox=\"0 0 43 56.9\" width=\"20\" height=\"29\" focusable=\"false\">\n        <rect y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n        <rect x=\"27.3\" y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n    </svg>\n</button>\n\n<button #endButton\n    class=\"control-button\"\n    (click)=\"goToEnd()\"\n    (mouseup)=\"endButton.blur()\"\n    aria-label=\"Go to end\"\n    i18n-aria-label>\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"44.1\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"0,64 0,0 44.1,32\" />\n    </svg>\n</button>\n\n<div class=\"actions-list\">\n\n    <ng-content></ng-content>\n\n    <div class=\"action-button-container\" *ngIf=\"mediaPlayerService.textTracks.length > 0 && mediaPlayerService.type === 'video'\">\n        <button #subtitlesButton\n            class=\"action-button\"\n            (keydown)=\"returnFocus = true\"\n            (click)=\"subtitlesOpen = !subtitlesOpen\"\n            (mouseup)=\"subtitlesButton.blur(); returnFocus = false\"\n            i18n-aria-label\n            attr.aria-label=\"Select subtitles, {{ getSubtitleTrack() }} currently selected.\"\n            [attr.aria-expanded]=\"subtitlesOpen\"\n            [attr.aria-describedby]=\"subtitlesId\"\n            aria-haspopup=\"true\">\n            <span class=\"hpe-icon hpe-subtitles\"></span>\n        </button>\n\n        <div #subtitles\n            [style.top.px]=\"-subtitles.offsetHeight\"\n            class=\"popover top media-player-subtitles-popover show\"\n            [id]=\"subtitlesId\"\n            (keydown.escape)=\"subtitlesOpen = false\"\n            (uxClickOutside)=\"subtitlesOpen = false\"\n            *ngIf=\"subtitlesOpen\">\n            <div class=\"arrow\"></div>\n            <h3 class=\"popover-title\" i18n>Subtitles</h3>\n            <div class=\"popover-content\">\n                <ul class=\"subtitles-list\" uxTabbableList [focusOnShow]=\"returnFocus\" [returnFocus]=\"returnFocus\">\n                    <li uxTabbableListItem\n                        tabindex=\"0\"\n                        class=\"subtitles-list-item\"\n                        [class.active]=\"!isSubtitleActive()\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false\"\n                        (keydown.enter)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false; returnFocus = true\">\n\n                        <i class=\"hpe-icon hpe-checkmark m-r-xs\"></i>\n                        <span i18n>Subtitles Off</span>\n                    </li>\n                    <li uxTabbableListItem\n                        class=\"subtitles-list-item\"\n                        *ngFor=\"let track of mediaPlayerService.textTracks\"\n                        [class.active]=\"track.mode === 'showing'\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"setSubtitleTrack(track); subtitlesOpen = false\"\n                        (keydown.enter)=\"setSubtitleTrack(track); subtitlesOpen = false; returnFocus = true\">\n                        <i class=\"hpe-icon hpe-checkmark m-r-xs\"></i>\n                        <span>{{ track.label }}</span>\n                    </li>\n                </ul>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"action-button-container\">\n        <button #fullscreenButton\n            *ngIf=\"mediaPlayerService.type !== 'audio'\"\n            class=\"action-button\"\n            attr.aria-label=\"{{ mediaPlayerService.fullscreen ? 'Exit full screen' : 'Full screen' }}\"\n            i18n-aria-label\n            (click)=\"mediaPlayerService.toggleFullscreen()\"\n            (mouseup)=\"fullscreenButton.blur()\">\n\n            <span class=\"hpe-icon\"\n                  [class.hpe-expand]=\"!mediaPlayerService.fullscreen\"\n                  [class.hpe-contract]=\"mediaPlayerService.fullscreen\">\n            </span>\n        </button>\n    </div>\n</div>\n\n\n\n<ng-template #muteTooltip>\n    <span aria-hidden=\"true\">{{ volume === 0 ? 'Unmute' : 'Mute' }}</span>\n</ng-template>",
                        host: {
                            '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                        }
                    }] }
        ];
        return MediaPlayerControlsExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerCustomControlDirective = (function () {
        function MediaPlayerCustomControlDirective() {
        }
        MediaPlayerCustomControlDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMediaPlayerCustomControl]',
                    },] }
        ];
        return MediaPlayerCustomControlDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerTimelineExtensionComponent = (function (_super) {
        __extends(MediaPlayerTimelineExtensionComponent, _super);
        function MediaPlayerTimelineExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.current = 0;
            _this.position = 0;
            _this.buffered = [];
            _this.mouseDown = false;
            _this.scrub = { visible: false, position: 0, time: 0 };
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // watch for changes to the current time
                this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) {
                    _this.scrub.position = 0;
                });
                this.mediaPlayerService.timeUpdateEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (current) {
                    _this.current = current;
                    _this.position = (_this.current / _this.mediaPlayerService.duration) * 100;
                });
                this.mediaPlayerService.progressEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (buffered) {
                    _this.buffered = [];
                    for (var /** @type {?} */ idx = 0; idx < buffered.length; idx++) {
                        _this.buffered.push({
                            start: (buffered.start(idx) / _this.mediaPlayerService.duration) * 100,
                            end: (buffered.end(idx) / _this.mediaPlayerService.duration) * 100
                        });
                    }
                });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ mousedown$ = fromEvent.fromEvent(this.thumb.nativeElement, 'mousedown');
                var /** @type {?} */ mousemove$ = fromEvent.fromEvent(document, 'mousemove');
                var /** @type {?} */ mouseup$ = fromEvent.fromEvent(document, 'mouseup');
                mousedown$.pipe(operators.switchMap(function () { return mousemove$.pipe(operators.takeUntil(mouseup$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.scrub.visible = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.updateScrub = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ target = (event.target);
                if (target.classList.contains('media-progress-bar-thumb')) {
                    return;
                }
                var /** @type {?} */ timeline = (this.timelineRef.nativeElement);
                var /** @type {?} */ bounds = timeline.getBoundingClientRect();
                this.scrub.position = event.offsetX;
                this.scrub.time = (event.offsetX / bounds.width) * this.mediaPlayerService.duration;
                if (this.mouseDown) {
                    this.mediaPlayerService.pause();
                    this.mediaPlayerService.currentTime = this.scrub.time;
                }
            };
        /** Skip a number of seconds in any direction */
        /**
         * Skip a number of seconds in any direction
         * @param {?} seconds
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.skip = /**
         * Skip a number of seconds in any direction
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                var /** @type {?} */ target = this.current + seconds;
                // ensure that the target position is within the bounds of the clip
                if (target < 0) {
                    target = 0;
                }
                if (target > this.mediaPlayerService.duration) {
                    target = this.mediaPlayerService.duration;
                }
                this.mediaPlayerService.currentTime = target;
            };
        MediaPlayerTimelineExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-timeline',
                        template: "<p class=\"current-time\">{{ current | duration }}</p>\n\n<div #timeline\n     class=\"timeline-bar\"\n     tabindex=\"0\"\n     role=\"slider\"\n     aria-label=\"Seek slider\"\n     i18n-aria-label\n     aria-valuemin=\"0\"\n     [attr.aria-valuemax]=\"mediaPlayerService.duration | number: '0.0-0'\"\n     [attr.aria-valuenow]=\"mediaPlayerService.currentTime | number: '0.0-0'\"\n     attr.aria-valuetext=\"{{ mediaPlayerService.currentTime | duration }} of {{ mediaPlayerService.duration | duration }}\"\n     (keydown.ArrowLeft)=\"skip(-5)\"\n     (keydown.ArrowRight)=\"skip(5)\"\n     (mouseenter)=\"scrub.visible = true; tooltip.show()\"\n     (mouseleave)=\"scrub.visible = false; tooltip.hide()\"\n     (mousemove)=\"updateScrub($event); tooltip.reposition()\"\n     (mouseup)=\"updateScrub($event)\"\n     (mousedown)=\"mouseDown = true; $event.preventDefault()\">\n\n    <div class=\"buffered-bar\"\n         *ngFor=\"let buffer of buffered\"\n         [style.left.%]=\"buffer.start\"\n         [style.width.%]=\"buffer.end - buffer.start\">\n    </div>\n\n    <div class=\"media-progress-bar\" [style.width.%]=\"position\">\n        <div #progressThumb\n             class=\"media-progress-bar-thumb\"\n             (mouseenter)=\"scrub.visible = false; tooltip.hide(); $event.stopPropagation()\"\n             (mouseleave)=\"scrub.visible = true; tooltip.show(); $event.stopPropagation()\">\n        </div>\n    </div>\n\n    <div #tooltip=\"ux-tooltip\"\n         class=\"scrub-handle\"\n         [class.scrub-handle-hidden]=\"!scrub.visible\"\n         [style.left.px]=\"scrub.position\"\n         [uxTooltip]=\"popTemplate\"\n         tooltipClass=\"ux-media-player-timeline-tooltip\"\n         placement=\"top\"\n         [showTriggers]=\"[]\"\n         [hideTriggers]=\"[]\"\n         [tooltipDelay]=\"100\"\n         [tooltipDisabled]=\"mediaPlayerService.duration === 0\"></div>\n</div>\n\n<p class=\"duration-time\">{{ mediaPlayerService.duration | duration }}</p>\n\n<ng-template #popTemplate>\n    <span>{{ scrub.time | duration }}</span>\n</ng-template>",
                        host: {
                            '(document:mouseup)': 'mouseDown = false',
                            '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                        }
                    }] }
        ];
        MediaPlayerTimelineExtensionComponent.propDecorators = {
            thumb: [{ type: core.ViewChild, args: ['progressThumb',] }],
            timelineRef: [{ type: core.ViewChild, args: ['timeline',] }]
        };
        return MediaPlayerTimelineExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioService = (function () {
        function AudioService(_http) {
            this._http = _http;
        }
        /**
         * @param {?} mediaElement
         * @return {?}
         */
        AudioService.prototype.getAudioFileMetadata = /**
         * @param {?} mediaElement
         * @return {?}
         */
            function (mediaElement) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this._http.get(mediaElement.src, { responseType: 'blob' }).subscribe(function (response) {
                        var /** @type {?} */ filename = mediaElement.src.substring(mediaElement.src.lastIndexOf('/') + 1);
                        var /** @type {?} */ extension = mediaElement.src.substring(mediaElement.src.lastIndexOf('.') + 1).toLowerCase();
                        var /** @type {?} */ description;
                        switch (extension) {
                            case 'mp3':
                                description = 'MPEG audio layer 3 file';
                                break;
                            case 'wma':
                                description = 'Windows media audio file';
                                break;
                            case 'wav':
                                description = 'WAVE audio file';
                                break;
                            case 'ogg':
                                description = 'Ogg Vorbis file';
                                break;
                            case 'aac':
                                description = 'Advanced audio coding file';
                                break;
                            case 'midi':
                                description = 'Musical instrument digital interface file';
                                break;
                            default:
                                description = 'Audio file';
                                break;
                        }
                        observer.next({
                            filename: filename,
                            extension: extension,
                            description: description,
                            size: response.size
                        });
                    });
                });
            };
        /**
         * @param {?} url
         * @return {?}
         */
        AudioService.prototype.getWaveformFromUrl = /**
         * @param {?} url
         * @return {?}
         */
            function (url) {
                var _this = this;
                // if audio context is not support return a stream of empty data
                if (!((window)).AudioContext) {
                    return of.of([new Float32Array(0)]);
                }
                this._audioContext = new AudioContext();
                this.createVolumeNode();
                this.createAnalyserNode();
                return Observable.Observable.create(function (observer) {
                    // load the media from the URL provided
                    // load the media from the URL provided
                    _this._http.get(url, { responseType: 'arraybuffer' }).subscribe(function (response) {
                        _this.getAudioBuffer(response).subscribe(function (audioBuffer) {
                            // create the buffer source
                            // create the buffer source
                            _this.createBufferSource(audioBuffer);
                            var /** @type {?} */ dataPoints = [];
                            var /** @type {?} */ channels = _this._audioBuffer.numberOfChannels;
                            // extract the data from each channel
                            for (var /** @type {?} */ channelIdx = 0; channelIdx < channels; channelIdx++) {
                                dataPoints[channelIdx] = _this._audioBuffer.getChannelData(channelIdx);
                            }
                            observer.next(dataPoints);
                            observer.complete();
                            // cleanup after ourselves
                            dataPoints = null;
                        }, function (error) { return observer.error(error); });
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
        AudioService.prototype.getWaveformPoints = /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
            function (channels, skip) {
                if (channels === void 0) {
                    channels = [];
                }
                if (skip === void 0) {
                    skip = 1000;
                }
                var /** @type {?} */ waveform = [];
                var /** @type {?} */ duration = channels.length > 0 ? channels[0].length : 0;
                var _loop_1 = function (idx) {
                    // get all the channel data for a specific point
                    var /** @type {?} */ points = channels.map(function (channel) { return channel[idx]; });
                    // find the minimum point and maximum points at each position across all channels
                    waveform.push({
                        min: points.reduce(function (previous, current) { return current < previous ? current : previous; }),
                        max: points.reduce(function (previous, current) { return current > previous ? current : previous; })
                    });
                };
                // convert each channel data to a series of waveform points
                for (var /** @type {?} */ idx = 0; idx < duration; idx += skip) {
                    _loop_1(idx);
                }
                return waveform;
            };
        /**
         * @param {?} arrayBuffer
         * @return {?}
         */
        AudioService.prototype.getAudioBuffer = /**
         * @param {?} arrayBuffer
         * @return {?}
         */
            function (arrayBuffer) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this.getOfflineAudioContext().decodeAudioData(arrayBuffer, function (audioBuffer) {
                        observer.next(audioBuffer);
                        observer.complete();
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @return {?}
         */
        AudioService.prototype.getOfflineAudioContext = /**
         * @return {?}
         */
            function () {
                return new OfflineAudioContext(1, 2, this._audioContext.sampleRate || 44100);
            };
        /**
         * @param {?} audioBuffer
         * @return {?}
         */
        AudioService.prototype.createBufferSource = /**
         * @param {?} audioBuffer
         * @return {?}
         */
            function (audioBuffer) {
                this.disconnectSource();
                this._audioBuffer = audioBuffer;
                this._audioBufferSource = this._audioContext.createBufferSource();
                this._audioBufferSource.buffer = this._audioBuffer;
                this._audioBufferSource.connect(this._analyserNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createVolumeNode = /**
         * @return {?}
         */
            function () {
                this._gainNode = this._audioContext.createGain();
                this._gainNode.connect(this._audioContext.destination);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createAnalyserNode = /**
         * @return {?}
         */
            function () {
                this._analyserNode = this._audioContext.createAnalyser();
                this._analyserNode.connect(this._gainNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.disconnectSource = /**
         * @return {?}
         */
            function () {
                if (this._audioBufferSource) {
                    this._audioBufferSource.disconnect();
                }
            };
        AudioService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        AudioService.ctorParameters = function () {
            return [
                { type: http.HttpClient }
            ];
        };
        return AudioService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioServiceModule = (function () {
        function AudioServiceModule() {
        }
        AudioServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [http.HttpClientModule],
                        providers: [AudioService]
                    },] }
        ];
        return AudioServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerComponent = (function () {
        function MediaPlayerComponent(mediaPlayerService, _audioService, _elementRef) {
            var _this = this;
            this.mediaPlayerService = mediaPlayerService;
            this._audioService = _audioService;
            this._elementRef = _elementRef;
            this.hovering = false;
            this.focused = false;
            this.crossorigin = 'use-credentials';
            this._onDestroy = new Subject.Subject();
            // show controls when hovering and in quiet mode
            fromEvent.fromEvent(this._elementRef.nativeElement, 'mousemove').pipe(operators.tap(function () { return _this.hovering = true; }), operators.debounceTime(2000), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.hovering = false; });
        }
        Object.defineProperty(MediaPlayerComponent.prototype, "source", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.source;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.type;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.type = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.quietMode = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.mediaPlayerService.setMediaPlayer(this._elementRef.nativeElement, this._playerRef.nativeElement);
                this.audioMetadata = this._audioService.getAudioFileMetadata(this._playerRef.nativeElement);
                this.mediaPlayerService.playingEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(true); });
                this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(false); });
                this.mediaPlayerService.mediaClickEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.togglePlay(); });
                this.mediaPlayerService.loadedMetadataEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.loaded = true; });
                // initially hide all text tracks
                this.mediaPlayerService.hideSubtitleTracks();
            };
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        MediaPlayerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player',
                        template: "<div class=\"player-container\"\n     tabindex=\"0\"\n     aria-label=\"Media Player\"\n     i18n-aria-label\n     [cdkTrapFocus]=\"mediaPlayerService.fullscreen\">\n\n    <div class=\"video-player-container\" *ngIf=\"type === 'video'\">\n\n        <video class=\"video-player\"\n            #player\n            tabindex=\"-1\"\n            [src]=\"source\"\n            [crossOrigin]=\"crossorigin\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n\n            <ng-content select=\"track\"></ng-content>\n        </video>\n\n        <div class=\"video-overlay\" [class.playing]=\"mediaPlayerService.playing | async\">\n            <svg class=\"play-graphic\" x=\"0px\" y=\"0px\" viewBox=\"0 0 64 64\">\n                <circle class=\"play-circle\" cx=\"32.2\" cy=\"31.8\" r=\"31.8\" />\n                <polygon class=\"play-triangle\" points=\"23,14.1 23,50.8 48.3,32.5\" />\n            </svg>\n        </div>\n\n    </div>\n\n    <div class=\"audio-player\" *ngIf=\"type === 'audio'\">\n\n        <svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n            <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n                <g transform=\"translate(-98.000000, -458.000000)\">\n                    <g transform=\"translate(98.000000, 458.000000)\">\n                        <path d=\"M4.5,0.5 L18.0435308,0.5 L23.5,6.22251502 L23.5,23.5 L4.5,23.5 L4.5,0.5 Z\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4.5,8 L4.5,0.5 L18,0.5 L23.5,6 L23.5,23.5 L18,23.5\" stroke=\"#60798D\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4,13.5 L0.5,13.5 L0.5,18.5 L4,18.5 L9.5,22.5 L9.5,9.5 L4,13.5 Z\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                        <path d=\"M11.5,12.5137939 C13.7576225,12.5137939 14.5,14.3709236 14.5,16 C14.5,17.6849236 13.7089152,19.5420532 11.5,19.5420532\"\n                            stroke=\"#60798D\"></path>\n                        <path d=\"M11.5,9 C15.8037643,9.04168701 18.5,11.6604805 18.5,16 C18.5,20.3395195 15.8804302,23.0079956 11.5,23\" stroke=\"#60798D\"></path>\n                        <path d=\"M17.5219116,0.761413574 L17.5219116,6 L23,6\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                    </g>\n                </g>\n            </g>\n        </svg>\n\n        <p class=\"audio-file-name\">{{ (audioMetadata | async)?.filename }}</p>\n        <p class=\"audio-file-format\">{{ (audioMetadata | async)?.description }}</p>\n        <p class=\"audio-file-size\">{{ (audioMetadata | async)?.size | fileSize }}</p>\n\n        <audio #player\n            [src]=\"source\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n        </audio>\n    </div>\n\n    <div class=\"control-bar\"\n        (uxFocusWithin)=\"focused = true\"\n        (uxBlurWithin)=\"focused = false\">\n\n        <ux-media-player-timeline></ux-media-player-timeline>\n        <ux-media-player-controls>\n            <ng-content select=\"[uxMediaPlayerCustomControl]\"></ng-content>\n        </ux-media-player-controls>\n    </div>\n</div>",
                        providers: [MediaPlayerService],
                        host: {
                            '(keydown.Space)': 'mediaPlayerService.togglePlay(); $event.preventDefault()',
                            '[class.standard]': '!mediaPlayerService.fullscreen',
                            '[class.fullscreen]': 'mediaPlayerService.fullscreen',
                            '[class.quiet]': 'quietMode && type === "video" || mediaPlayerService.fullscreen',
                            '[class.hover]': 'hovering || focused',
                            '[class.video]': 'type === "video"',
                            '[class.audio]': 'type === "audio"',
                            '(mouseenter)': 'hovering = true',
                            '(mouseleave)': 'hovering = false',
                            '(document:webkitfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                            '(document:mozfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                            '(document:MSFullscreenChange)': 'mediaPlayerService.fullscreenChange()'
                        }
                    }] }
        ];
        /** @nocollapse */
        MediaPlayerComponent.ctorParameters = function () {
            return [
                { type: MediaPlayerService },
                { type: AudioService },
                { type: core.ElementRef }
            ];
        };
        MediaPlayerComponent.propDecorators = {
            _playerRef: [{ type: core.ViewChild, args: ['player',] }],
            crossorigin: [{ type: core.Input }],
            source: [{ type: core.Input }],
            type: [{ type: core.Input }],
            quietMode: [{ type: core.Input }]
        };
        return MediaPlayerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipe = (function () {
        function DurationPipe() {
        }
        /**
         * @param {?} seconds
         * @return {?}
         */
        DurationPipe.prototype.transform = /**
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                var /** @type {?} */ minutes = Math.floor(seconds / 60);
                var /** @type {?} */ hours = Math.floor(minutes / 60);
                var /** @type {?} */ days = Math.floor(hours / 24);
                hours = hours - (days * 24);
                minutes = minutes - (days * 24 * 60) - (hours * 60);
                seconds = Math.floor(seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60));
                if (hours > 0) {
                    return this.pad(hours) + ":" + this.pad(minutes) + ":" + this.pad(seconds);
                }
                else {
                    return this.pad(minutes) + ":" + this.pad(seconds);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        DurationPipe.prototype.pad = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value < 10) {
                    return "0" + value;
                }
                return value.toString();
            };
        DurationPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'duration'
                    },] }
        ];
        return DurationPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipeModule = (function () {
        function DurationPipeModule() {
        }
        DurationPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DurationPipe],
                        declarations: [DurationPipe]
                    },] }
        ];
        return DurationPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipe = (function () {
        function FileSizePipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        FileSizePipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // allow for async values
                if (!value) {
                    return value;
                }
                var /** @type {?} */ units = ['B', 'KB', 'MB', 'GB', 'TB'];
                // calculate the which unit bracket the values should be a part of
                var /** @type {?} */ idx = Math.floor(Math.log(value) / Math.log(1024));
                var /** @type {?} */ formattedValue = value / Math.pow(1024, idx);
                return formattedValue.toFixed(2) + " " + units[idx];
            };
        FileSizePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'fileSize'
                    },] }
        ];
        return FileSizePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipeModule = (function () {
        function FileSizePipeModule() {
        }
        FileSizePipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FileSizePipe],
                        declarations: [FileSizePipe]
                    },] }
        ];
        return FileSizePipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$5 = [
        MediaPlayerComponent,
        MediaPlayerTimelineExtensionComponent,
        MediaPlayerBaseExtensionDirective,
        MediaPlayerControlsExtensionComponent,
        MediaPlayerCustomControlDirective
    ];
    var MediaPlayerModule = (function () {
        function MediaPlayerModule() {
        }
        MediaPlayerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            FrameExtractionModule,
                            TooltipModule,
                            AudioServiceModule,
                            DurationPipeModule,
                            FileSizePipeModule,
                            SliderModule,
                            AccessibilityModule,
                            a11y.A11yModule,
                            ClickOutsideModule
                        ],
                        exports: DECLARATIONS$5,
                        declarations: DECLARATIONS$5
                    },] }
        ];
        return MediaPlayerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationItemComponent = (function () {
        function NavigationItemComponent(_elementRef, _renderer, _parent, _router) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._parent = _parent;
            this._router = _router;
            this.expanded = false;
            this.level = 1;
            this.indentWithoutArrow = true;
            this.level = _parent ? _parent.level + 1 : 1;
            this._navigationEnd = _router.events.pipe(filter.filter(function (event) { return event instanceof router.NavigationEnd; })).subscribe(function (event) {
                // Expand this component if it or a descendant is active.
                // Expand this component if it or a descendant is active.
                _this.expanded = _this.hasActiveLink(_this.link);
            });
        }
        Object.defineProperty(NavigationItemComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                if (this.link) {
                    return this._router.isActive(this.link, true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationItemComponent.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                var _this = this;
                return this._children.filter(function (item) { return item !== _this; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // Add classes to parent for styling
                var /** @type {?} */ parentListElement = this._elementRef.nativeElement.parentElement;
                if (parentListElement) {
                    var /** @type {?} */ levelClass = this.getLevelClass();
                    if (levelClass.length > 0) {
                        this._renderer.addClass(parentListElement, 'nav');
                        this._renderer.addClass(parentListElement, levelClass);
                    }
                }
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Set 'indentWithoutArrow'
                this.setIndentWithoutArrow();
                // Update 'indentWithoutArrow' in response to changes to children
                this._childrenChanges = this._children.changes.subscribe(function () { return _this.setIndentWithoutArrow(); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._navigationEnd.unsubscribe();
                this._childrenChanges.unsubscribe();
            };
        /**
         * @param {?} link
         * @return {?}
         */
        NavigationItemComponent.prototype.hasActiveLink = /**
         * @param {?} link
         * @return {?}
         */
            function (link) {
                // If this component has a link, check if it is active.
                if (link && this._router.isActive(link, true)) {
                    return true;
                }
                // If this component has children, check if any of them, or their descendants, are active.
                return this.children.some(function (item) { return item.hasActiveLink(item.link); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.getLevelClass = /**
         * @return {?}
         */
            function () {
                switch (this.level) {
                    case 2:
                        return 'nav-second-level';
                    case 3:
                        return 'nav-third-level';
                    case 4:
                        return 'nav-fourth-level';
                    case 5:
                        return 'nav-fifth-level';
                }
                return '';
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.setIndentWithoutArrow = /**
         * @return {?}
         */
            function () {
                if (this.children.length > 0) {
                    // If this element has children it will be indented and will have an arrow
                    this.indentWithoutArrow = false;
                }
                else if (this._parent) {
                    // If this element has a parent, indent it if any of its siblings have children
                    this.indentWithoutArrow = !this._parent.children.every(function (item) { return item.children.length === 0; });
                }
                else {
                    // Top-level elements should be indented
                    this.indentWithoutArrow = true;
                }
            };
        NavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: '[ux-navigation-item]',
                        template: "<a *ngIf=\"link\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\" [routerLink]=\"link\">\n    <span>{{header}}</span>\n</a>\n<a *ngIf=\"!link\" (click)=\"expanded = !expanded\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\">\n    <span>{{header}}</span>\n</a>\n<ng-content></ng-content>\n",
                        host: {
                            '[class.active]': 'active',
                            '[class.selected]': 'expanded',
                        }
                    }] }
        ];
        /** @nocollapse */
        NavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: NavigationItemComponent, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
                { type: router.Router }
            ];
        };
        NavigationItemComponent.propDecorators = {
            header: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            link: [{ type: core.Input }],
            _children: [{ type: core.ContentChildren, args: [NavigationItemComponent, { descendants: true },] }]
        };
        return NavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationService = (function () {
        function NavigationService() {
            this.autoCollapse = true;
        }
        /**
         * @param {?} source
         * @param {?} expanded
         * @return {?}
         */
        NavigationService.prototype.setExpanded = /**
         * @param {?} source
         * @param {?} expanded
         * @return {?}
         */
            function (source, expanded) {
                if (expanded && this.autoCollapse) {
                    this.collapseSiblings(source);
                }
            };
        /**
         * @param {?} source
         * @return {?}
         */
        NavigationService.prototype.collapseSiblings = /**
         * @param {?} source
         * @return {?}
         */
            function (source) {
                var /** @type {?} */ siblings = this.items;
                try {
                    for (var _a = __values(this.items), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var item = _b.value;
                        var /** @type {?} */ parent_1 = this.getParent(source, item);
                        if (parent_1) {
                            siblings = parent_1.children;
                            break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                try {
                    for (var siblings_1 = __values(siblings), siblings_1_1 = siblings_1.next(); !siblings_1_1.done; siblings_1_1 = siblings_1.next()) {
                        var item = siblings_1_1.value;
                        if (item !== source) {
                            this.collapseAll(item);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (siblings_1_1 && !siblings_1_1.done && (_d = siblings_1.return))
                            _d.call(siblings_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                var e_1, _c, e_2, _d;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        NavigationService.prototype.collapseAll = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                item.expanded = false;
                if (item.children) {
                    try {
                        for (var _a = __values(item.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var child = _b.value;
                            this.collapseAll(child);
                        }
                    }
                    catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return))
                                _c.call(_a);
                        }
                        finally {
                            if (e_3)
                                throw e_3.error;
                        }
                    }
                }
                var e_3, _c;
            };
        /**
         * @param {?} target
         * @param {?} item
         * @return {?}
         */
        NavigationService.prototype.getParent = /**
         * @param {?} target
         * @param {?} item
         * @return {?}
         */
            function (target, item) {
                if (item.children) {
                    try {
                        for (var _a = __values(item.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var child = _b.value;
                            if (child === target) {
                                return item;
                            }
                        }
                    }
                    catch (e_4_1) {
                        e_4 = { error: e_4_1 };
                    }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return))
                                _c.call(_a);
                        }
                        finally {
                            if (e_4)
                                throw e_4.error;
                        }
                    }
                }
                return null;
                var e_4, _c;
            };
        NavigationService.decorators = [
            { type: core.Injectable }
        ];
        return NavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationLinkDirective = (function () {
        function NavigationLinkDirective(_router, _locationStrategy, _navigationService) {
            this._router = _router;
            this._locationStrategy = _locationStrategy;
            this._navigationService = _navigationService;
            this.ariaExpanded = 'undefined';
            this._expanded$ = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(NavigationLinkDirective.prototype, "expanded", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._expanded$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._expanded$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function (expanded) {
                    if (_this.navigationItem.children && _this.navigationItem.children.length > 0) {
                        _this.ariaExpanded = "" + expanded;
                        _this._navigationService.setExpanded(_this.navigationItem, expanded);
                    }
                });
                this._router.events
                    .pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.takeUntil(this._onDestroy))
                    .subscribe(this.updateNavigationState.bind(this));
                this.updateNavigationState();
                this.updateAttributes();
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this.updateAttributes();
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NavigationLinkDirective.prototype.activated = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.navigationItem.routerLink) {
                    var /** @type {?} */ commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                    this._router.navigate(commands, this.navigationItem.routerExtras);
                }
                // Toggle expanded state (relevant only if it has children)
                this.navigationItem.expanded = !this.navigationItem.expanded;
                // Invoke the custom click handler if specified
                if (this.navigationItem.click) {
                    this.navigationItem.click(event, this.navigationItem);
                }
                return false;
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.updateNavigationState = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.isActive = this.isActiveItem(this.navigationItem);
                if (this.navigationItem.children) {
                    var /** @type {?} */ activeChild = this.navigationItem.children.find(function (child) { return _this.isActiveItem(child); });
                    if (activeChild) {
                        this.navigationItem.expanded = true;
                    }
                }
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.updateAttributes = /**
         * @return {?}
         */
            function () {
                this.href = this.getHref();
                this.role = (this.navigationItem.children && this.navigationItem.children.length > 0) ? 'button' : 'treeitem';
                this.indentChildren = this.navigationItem.children && this.navigationItem.children.some(function (item) { return item.children && item.children.length > 0; });
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.getHref = /**
         * @return {?}
         */
            function () {
                if (this.navigationItem.routerLink) {
                    var /** @type {?} */ commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                    var /** @type {?} */ urlTree = this._router.createUrlTree(commands, this.navigationItem.routerExtras);
                    return this._locationStrategy.prepareExternalUrl(this._router.serializeUrl(urlTree));
                }
                return null;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        NavigationLinkDirective.prototype.isActiveItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (item.routerLink) {
                    var /** @type {?} */ commands = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    var /** @type {?} */ urlTree = this._router.createUrlTree(commands, item.routerExtras);
                    return this._router.isActive(urlTree, true);
                }
                return false;
            };
        NavigationLinkDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxNavigationLink]',
                        exportAs: 'uxNavigationLink'
                    },] }
        ];
        /** @nocollapse */
        NavigationLinkDirective.ctorParameters = function () {
            return [
                { type: router.Router },
                { type: common.LocationStrategy },
                { type: NavigationService }
            ];
        };
        NavigationLinkDirective.propDecorators = {
            navigationItem: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            canExpand: [{ type: core.Input }],
            indent: [{ type: core.Input }, { type: core.HostBinding, args: ['class.indent',] }],
            href: [{ type: core.HostBinding, args: ['attr.href',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            ariaExpanded: [{ type: core.HostBinding, args: ['attr.aria-expanded',] }],
            activated: [{ type: core.HostListener, args: ['click', ['$event'],] }, { type: core.HostListener, args: ['keydown.enter', ['$event'],] }]
        };
        return NavigationLinkDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationComponent = (function () {
        function NavigationComponent(_navigationService) {
            this._navigationService = _navigationService;
            /**
             * Whether to present the menu as a hierarchical tree.
             */
            this.tree = true;
            this.hierarchyClasses = [
                '',
                'nav-second-level',
                'nav-third-level',
                'nav-fourth-level',
                'nav-fifth-level',
            ];
        }
        Object.defineProperty(NavigationComponent.prototype, "items", {
            get: /**
             * @return {?}
             */ function () {
                return this._navigationService.items;
            },
            /** The navigation items to populate the menu with. */
            set: /**
             * The navigation items to populate the menu with.
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._navigationService.items = items;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "autoCollapse", {
            /** Whether to collapse other menu items when expanding a menu item. */
            set: /**
             * Whether to collapse other menu items when expanding a menu item.
             * @param {?} autoCollapse
             * @return {?}
             */ function (autoCollapse) {
                this._navigationService.autoCollapse = autoCollapse;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "depthLimit", {
            get: /**
             * @return {?}
             */ function () {
                return this.tree ? this.hierarchyClasses.length : 2;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
        NavigationComponent.prototype.itemClick = /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
            function (item, event) {
                // Toggle expanded state (relevant only if it has children)
                item.expanded = !item.expanded;
                // Invoke the custom click handler if specified
                if (item.click) {
                    item.click(event, item);
                }
            };
        /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         */
        /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         * @param {?} items
         * @return {?}
         */
        NavigationComponent.prototype.needsIndent = /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         * @param {?} items
         * @return {?}
         */
            function (items) {
                return items && items.some(function (item) { return item.children && item.children.length > 0; });
            };
        NavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-navigation',
                        template: "<nav class=\"ux-side-nav\" [class.tree]=\"tree\" role=\"navigation\">\n\n    <ol *ngIf=\"items\" role=\"tree\" class=\"nav\" uxTabbableList [hierarchy]=\"true\">\n\n        <ng-container *ngFor=\"let item of items; let rank = index\"\n            [ngTemplateOutlet]=\"navigationNode\"\n            [ngTemplateOutletContext]=\"{item: item, level: 1, rank: rank, indent: needsIndent(items)}\">\n        </ng-container>\n\n        <ng-template #navigationNode let-item=\"item\" let-parent=\"parent\" let-level=\"level\" let-rank=\"rank\" let-indent=\"indent\">\n\n            <li [attr.role]=\"(item.children && item.children.length > 0) ? 'treeitem' : 'none'\"\n                [attr.aria-expanded]=\"item.expanded\"\n                [class.selected]=\"item.expanded\"\n                [class.active]=\"navigationLink.isActive\">\n\n                <a uxNavigationLink\n                    #navigationLink=\"uxNavigationLink\"\n                    [navigationItem]=\"item\"\n                    [expanded]=\"item.expanded\"\n                    [canExpand]=\"level < depthLimit\"\n                    [indent]=\"indent\"\n                    uxTabbableListItem\n                    #tli=\"ux-tabbable-list-item\"\n                    [parent]=\"parent\"\n                    [rank]=\"rank\"\n                    [(expanded)]=\"item.expanded\">\n\n                    <span *ngIf=\"!navigationItemTemplate && item.children && item.children.length > 0 && level < depthLimit\"\n                        aria-hidden=\"true\"\n                        class=\"nav-expander\"\n                        (click)=\"item.expanded = !item.expanded; $event.stopPropagation(); $event.preventDefault()\">\n                    </span>\n                    <span *ngIf=\"!navigationItemTemplate && item.icon && !tree\" class=\"nav-icon hpe-icon\" [ngClass]=\"item.icon\"></span>\n                    <img *ngIf=\"!navigationItemTemplate && item.iconUrl && !tree\" class=\"nav-icon\" [src]=\"item.iconUrl\" alt=\"item.iconLabel\">\n                    <span *ngIf=\"!navigationItemTemplate\" class=\"nav-title\">{{item.title}}</span>\n\n                    <ng-container [ngTemplateOutlet]=\"navigationItemTemplate\"\n                        [ngTemplateOutletContext]=\"{item: item, level: level}\">\n                    </ng-container>\n\n                </a>\n\n                <ol *ngIf=\"item.children && item.expanded && level < depthLimit\"\n                    role=\"group\" class=\"nav\" [ngClass]=\"hierarchyClasses[level]\">\n\n                    <ng-container *ngFor=\"let child of item.children; let rank = index\"\n                        [ngTemplateOutlet]=\"navigationNode\"\n                        [ngTemplateOutletContext]=\"{item: child, parent: tli, level: level + 1, rank: rank, indent: navigationLink.indentChildren}\">\n                    </ng-container>\n\n                </ol>\n\n            </li>\n\n        </ng-template>\n\n    </ol>\n\n    <!-- Backward compatibility with the original ux-navigation -->\n    <ol *ngIf=\"!items\" role=\"tree\" class=\"nav\">\n        <ng-content></ng-content>\n    </ol>\n\n</nav>\n",
                        providers: [NavigationService]
                    }] }
        ];
        /** @nocollapse */
        NavigationComponent.ctorParameters = function () {
            return [
                { type: NavigationService }
            ];
        };
        NavigationComponent.propDecorators = {
            items: [{ type: core.Input }],
            tree: [{ type: core.Input }],
            autoCollapse: [{ type: core.Input }],
            navigationItemTemplate: [{ type: core.ContentChild, args: ['uxNavigationItem',] }]
        };
        return NavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationModule = (function () {
        function NavigationModule() {
        }
        NavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [
                            NavigationComponent,
                            NavigationItemComponent
                        ],
                        declarations: [
                            NavigationComponent,
                            NavigationItemComponent,
                            NavigationLinkDirective
                        ]
                    },] }
        ];
        return NavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationService = (function () {
        function NotificationService(_colorService) {
            this._colorService = _colorService;
            // provide default options
            this.options = {
                duration: 4,
                height: 100,
                spacing: 10,
                backgroundColor: this._colorService.getColor('accent').toHex(),
                iconColor: this._colorService.getColor('accent').toHex()
            };
            this.direction = 'above';
            this.notifications$ = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} templateRef
         * @param {?=} options
         * @param {?=} data
         * @return {?}
         */
        NotificationService.prototype.show = /**
         * @param {?} templateRef
         * @param {?=} options
         * @param {?=} data
         * @return {?}
         */
            function (templateRef, options, data) {
                var _this = this;
                if (options === void 0) {
                    options = this.options;
                }
                if (data === void 0) {
                    data = {};
                }
                options = __assign({}, this.options, options);
                var /** @type {?} */ notificationRef = {
                    templateRef: templateRef,
                    duration: options.duration,
                    date: new Date(),
                    visible: true,
                    height: options.height,
                    spacing: options.spacing,
                    backgroundColor: options.backgroundColor,
                    iconColor: options.iconColor,
                    data: data
                };
                var /** @type {?} */ notifications = this.notifications$.getValue();
                if (this.direction === 'above') {
                    notifications.unshift(notificationRef);
                }
                else {
                    notifications.push(notificationRef);
                }
                this.notifications$.next(notifications);
                // remove notification after delay
                if (options.duration !== 0) {
                    setTimeout(function () { return _this.dismiss(notificationRef); }, options.duration * 1000);
                }
                return notificationRef;
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.getHistory = /**
         * @return {?}
         */
            function () {
                return this.notifications$.getValue();
            };
        /**
         * @param {?} notificationRef
         * @return {?}
         */
        NotificationService.prototype.dismiss = /**
         * @param {?} notificationRef
         * @return {?}
         */
            function (notificationRef) {
                notificationRef.visible = false;
                this.notifications$.next(this.notifications$.getValue());
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.dismissAll = /**
         * @return {?}
         */
            function () {
                this.notifications$.getValue().forEach(function (notificationRef) { return notificationRef.visible = false; });
                this.notifications$.next(this.notifications$.getValue());
            };
        NotificationService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NotificationService.ctorParameters = function () {
            return [
                { type: ColorService }
            ];
        };
        return NotificationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationListComponent = (function () {
        function NotificationListComponent(_notificationService) {
            this._notificationService = _notificationService;
            this.position = 'top-right';
            this.notifications$ = this._notificationService.notifications$.pipe(operators.map(function (notificationRefs) { return notificationRefs.filter(function (notificationRef) { return notificationRef.visible; }); }));
        }
        Object.defineProperty(NotificationListComponent.prototype, "direction", {
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this._notificationService.direction = direction;
            },
            enumerable: true,
            configurable: true
        });
        NotificationListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-notification-list',
                        template: "<div class=\"notification\" *ngFor=\"let notificationRef of notifications$ | async; let idx = index\"\r\n    [style.top.px]=\"(notificationRef.height + notificationRef.spacing) * idx\"\r\n    [style.height.px]=\"notificationRef.height\"\r\n    [style.background-color]=\"notificationRef.backgroundColor\"\r\n    [@notificationState]>\r\n    <ng-container *ngTemplateOutlet=\"notificationRef.templateRef; context: { $implicit: notificationRef, data: notificationRef.data }\"></ng-container>\r\n</div>\r\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('notificationState', [
                                animations.state('in', animations.style({ transform: 'translateY(0)', opacity: 0.9 })),
                                animations.transition(':enter', [
                                    animations.style({ transform: 'translateY(-50px)', opacity: 0 }),
                                    animations.animate(500)
                                ]),
                                animations.transition(':leave', [
                                    animations.animate(500, animations.style({ transform: 'translateY(50px)', opacity: 0 }))
                                ])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        NotificationListComponent.ctorParameters = function () {
            return [
                { type: NotificationService }
            ];
        };
        NotificationListComponent.propDecorators = {
            direction: [{ type: core.Input }],
            position: [{ type: core.Input }, { type: core.HostBinding, args: ['class',] }]
        };
        return NotificationListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationModule = (function () {
        function NotificationModule() {
        }
        NotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule
                        ],
                        exports: [
                            NotificationListComponent
                        ],
                        declarations: [
                            NotificationListComponent
                        ],
                        providers: [
                            NotificationService
                        ]
                    },] }
        ];
        return NotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderCustomMenuDirective = (function () {
        function PageHeaderCustomMenuDirective() {
        }
        PageHeaderCustomMenuDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderCustomMenu]'
                    },] }
        ];
        return PageHeaderCustomMenuDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderService = (function () {
        function PageHeaderService(_router) {
            var _this = this;
            this._router = _router;
            this.items$ = new BehaviorSubject.BehaviorSubject([]);
            this.selected$ = new BehaviorSubject.BehaviorSubject(null);
            this.selectedRoot$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondary$ = new BehaviorSubject.BehaviorSubject(false);
            this.activeIconMenu$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondaryNavigationAutoselect = false;
            this._onDestroy = new Subject.Subject();
            this.selected$
                .pipe(operators.takeUntil(this._onDestroy), operators.map(function (selected) { return _this.getRoot(selected); }))
                .subscribe(function (root) { return _this.selectedRoot$.next(root); });
            this._router.events
                .pipe(operators.takeUntil(this._onDestroy), operators.filter(function (e) { return e instanceof router.NavigationEnd; }))
                .subscribe(this.updateItemsWithActiveRoute.bind(this));
        }
        /**
         * @return {?}
         */
        PageHeaderService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (!item) {
                    return;
                }
                if (item.routerLink) {
                    // Trigger router navigation
                    var /** @type {?} */ routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    this._router.navigate(routerLink, item.routerExtras);
                }
                else if (this.secondaryNavigationAutoselect && item.children && item.children.length > 0) {
                    // Select the first child in secondaryNavigationAutoselect mode
                    this.select(item.children[0]);
                }
                else {
                    // if we are in secondary navigation mode and we click a parent - dont deselect the child
                    if (this.secondary$.getValue() === true && this.isParentOf(this.selected$.getValue(), item)) {
                        return;
                    }
                    // Otherwise select the given item
                    this.selected$.next(item);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.deselect = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _this = this;
                // deselect the current item
                item.selected = false;
                // iterate any children and deselect them
                if (item.children) {
                    item.children.forEach(function (_item) { return _this.deselect(_item); });
                }
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.deselectAll = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.items$.getValue().forEach(function (item) { return _this.deselect(item); });
            };
        /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
        PageHeaderService.prototype.updateItem = /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
            function (item, selected) {
                // Item is selected if it is the selected item, or one of the selected item's ancestors.
                item.selected = item === selected || this.isParentOf(selected, item);
                if (item === selected) {
                    // call the select function if present
                    if (item.select) {
                        item.select.call(item, item);
                    }
                }
            };
        /**
         * @param {?=} items
         * @return {?}
         */
        PageHeaderService.prototype.setItems = /**
         * @param {?=} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                if (items === void 0) {
                    items = [];
                }
                // identify all parent elements
                items.forEach(function (item) { return _this.setParent(item); });
                this.items$.next(items);
                // Set up the initally selected item
                // If nothing is set as selected, using the initial route
                var /** @type {?} */ initialSelectedItem = items.find(function (item) { return item.selected === true; });
                if (initialSelectedItem) {
                    this.select(initialSelectedItem);
                }
                else {
                    this.updateItemsWithActiveRoute();
                }
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        PageHeaderService.prototype.setSecondaryNavigation = /**
         * @param {?} enabled
         * @return {?}
         */
            function (enabled) {
                this.secondary$.next(enabled);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.getRoot = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item && item.parent ? this.getRoot(item.parent) : item;
            };
        /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
        PageHeaderService.prototype.setParent = /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
            function (item, parent) {
                var _this = this;
                // set the parent field
                item.parent = parent;
                // call this function recursively on all children
                if (item.children) {
                    item.children.forEach(function (child) { return _this.setParent(child, item); });
                }
            };
        /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
        PageHeaderService.prototype.isParentOf = /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
            function (node, parent) {
                // if there are no parents return false
                if (!node || !node.parent) {
                    return false;
                }
                // if the parent is the match we are looking for return true
                if (node.parent === parent) {
                    return true;
                }
                // if there are potentially grandparents then check them too
                return this.isParentOf(node.parent, parent);
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.updateItemsWithActiveRoute = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ activeItem = new PageHeaderActiveNavigationItem();
                try {
                    for (var _a = __values(this.items$.getValue()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var item = _b.value;
                        this.findActiveItem(item, activeItem);
                        if (activeItem.exact) {
                            break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                if (activeItem.item) {
                    this.selected$.next(activeItem.item);
                }
                var e_1, _c;
            };
        /**
         * @param {?} item
         * @param {?} activeItem
         * @return {?}
         */
        PageHeaderService.prototype.findActiveItem = /**
         * @param {?} item
         * @param {?} activeItem
         * @return {?}
         */
            function (item, activeItem) {
                if (item.routerLink) {
                    var /** @type {?} */ routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    var /** @type {?} */ urlTree = this._router.createUrlTree(routerLink, item.routerExtras);
                    if (this._router.isActive(urlTree, true) && !activeItem.exact) {
                        // When the item route is an exact match, no need to look any further
                        activeItem.item = item;
                        activeItem.exact = true;
                        return;
                    }
                    if (this._router.isActive(urlTree, false)) {
                        // Store an inexact match and continue looking
                        activeItem.item = item;
                        activeItem.exact = false;
                    }
                }
                if (item.children) {
                    try {
                        for (var _a = __values(item.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var childItem = _b.value;
                            this.findActiveItem(childItem, activeItem);
                            if (activeItem.exact) {
                                return;
                            }
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return))
                                _c.call(_a);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
                var e_2, _c;
            };
        PageHeaderService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PageHeaderService.ctorParameters = function () {
            return [
                { type: router.Router }
            ];
        };
        return PageHeaderService;
    }());
    var PageHeaderActiveNavigationItem = (function () {
        function PageHeaderActiveNavigationItem() {
        }
        return PageHeaderActiveNavigationItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderIconMenuComponent = (function () {
        function PageHeaderIconMenuComponent(_service) {
            var _this = this;
            this._service = _service;
            this._subscription = _service.activeIconMenu$.subscribe(function (next) {
                // Close all but the most recently opened menu
                if (next !== _this.menu) {
                    _this._isOpen = false;
                }
            });
        }
        Object.defineProperty(PageHeaderIconMenuComponent.prototype, "isOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._isOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._isOpen = value;
                if (value) {
                    this._service.activeIconMenu$.next(this.menu);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (item.select) {
                    item.select.call(item, item);
                }
            };
        /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.keydownHandler = /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
            function (item, event) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        this.isOpen = false;
                        this.menuNavigationToggle.focus();
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderIconMenuComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-icon-menu',
                        template: "<div class=\"page-header-icon-menu\"\n    dropdown\n    placement=\"bottom right\"\n    [(isOpen)]=\"isOpen\">\n\n    <a role=\"button\"\n        class=\"page-header-icon-menu-button\"\n        [attr.aria-label]=\"menu.label\"\n        aria-haspopup=\"true\"\n        tabindex=\"0\"\n        (click)=\"select(menu)\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <i class=\"hpe-icon\" [ngClass]=\"menu.icon\"></i>\n        <span class=\"label label-primary\" *ngIf=\"menu?.badge\" aria-hidden=\"true\">{{ menu.badge }}</span>\n\n    </a>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li *ngFor=\"let dropdown of menu?.dropdown\"\n            role=\"none\"\n            [class.dropdown-header]=\"dropdown.header\"\n            [class.dropdown-divider]=\"dropdown.divider\">\n\n            <span class=\"font-bold\" *ngIf=\"dropdown.header\">{{ dropdown.title }}</span>\n\n            <a *ngIf=\"!dropdown.header\"\n                role=\"menuitem\"\n                class=\"dropdown-item\"\n                tabindex=\"-1\"\n                (click)=\"select(dropdown)\"\n                (keydown)=\"keydownHandler(dropdown, $event)\"\n                uxMenuNavigationItem>\n\n\n                <span class=\"dropdown-item-title\">\n                    <i class=\"hpe-icon hpe-fw\" [ngClass]=\"dropdown.icon\"></i>\n                    {{ dropdown.title }}\n                </span>\n                <span *ngIf=\"dropdown.subtitle\" class=\"dropdown-item-subtitle\">{{ dropdown.subtitle }}</span>\n\n            </a>\n        </li>\n\n    </ul>\n</div>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderIconMenuComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderIconMenuComponent.propDecorators = {
            menu: [{ type: core.Input }],
            menuNavigationToggle: [{ type: core.ViewChild, args: ['menuNavigationToggle',] }]
        };
        return PageHeaderIconMenuComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationDropdownItemComponent = (function () {
        function PageHeaderNavigationDropdownItemComponent(_pageHeaderService) {
            var _this = this;
            this._pageHeaderService = _pageHeaderService;
            this.dropdownOpen = false;
            this._hover$ = new Subject.Subject();
            // subscribe to stream with a debounce (a small debounce is all that is required)
            this._subscription = this._hover$.pipe(operators.debounceTime(1)).subscribe(function (visible) { return _this.dropdownOpen = visible; });
            // Close submenus when selected item changes
            this._subscription.add(_pageHeaderService.selected$.subscribe(function () {
                _this.dropdownOpen = false;
            }));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // clicking on an item with children then return
                if (item.children) {
                    return;
                }
                // emit the selected item in an event
                this._pageHeaderService.select(item);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.button.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverStart = /**
         * @return {?}
         */
            function () {
                this._hover$.next(true);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverLeave = /**
         * @return {?}
         */
            function () {
                this._hover$.next(false);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dropdownOpen = false;
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.keydownHandler = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderNavigationDropdownItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-dropdown-item',
                        exportAs: 'ux-page-header-horizontal-navigation-dropdown-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0\"\n    dropdown\n    #subMenu=\"bs-dropdown\"\n    [isOpen]=\"dropdownOpen\"\n    container=\"body\"\n    placement=\"right\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdownOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        #button\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdownOpen\"\n        menuPosition=\"right\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n        <span class=\"dropdown-item-icon hpe-icon hpe-next\"></span>\n\n    </a>\n\n    <ul *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-submenu\"\n        (mouseenter)=\"hoverStart()\"\n        (mouseleave)=\"hoverLeave()\"\n        uxMenuNavigation\n        #menuNavigation=\"uxMenuNavigation\"\n        [toggleButton]=\"menuNavigationToggle\"\n        toggleButtonPosition=\"left\">\n\n        <li *ngFor=\"let subItem of item.children\" role=\"none\">\n\n            <a role=\"menuitem\"\n                class=\"dropdown-item\"\n                [class.selected]=\"subItem.selected\"\n                [attr.aria-selected]=\"subItem.selected\"\n                tabindex=\"-1\"\n                (click)=\"select(subItem)\"\n                (keydown)=\"keydownHandler($event, subItem)\"\n                uxMenuNavigationItem>\n\n                <span class=\"dropdown-item-title\">{{ subItem.title }}</span>\n\n            </a>\n\n        </li>\n    </ul>\n\n</div>\n\n<div *ngIf=\"!item.children || item.children.length === 0\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        #button\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        (click)=\"select(item)\"\n        (keydown)=\"keydownHandler($event, item)\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n\n    </a>\n\n</div>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationDropdownItemComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationDropdownItemComponent.propDecorators = {
            item: [{ type: core.Input }],
            button: [{ type: core.ViewChild, args: ['button',] }]
        };
        return PageHeaderNavigationDropdownItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationItemComponent = (function () {
        function PageHeaderNavigationItemComponent(elementRef, _pageHeaderService) {
            this.elementRef = elementRef;
            this._pageHeaderService = _pageHeaderService;
            this.secondary$ = this._pageHeaderService.secondary$;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                    if (next && _this.isOpen) {
                        _this.isOpen = false;
                        // If menu was closed, keep focus on the toggle button
                        // If menu was closed, keep focus on the toggle button
                        _this.button.focus();
                    }
                });
                if (this.menu) {
                    this.menu.onHidden
                        .pipe(operators.takeUntil(this._onDestroy))
                        .subscribe(function () { return _this.dropdowns.forEach(function (dropdown$$1) { return dropdown$$1.close(); }); });
                }
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.select = /**
         * @return {?}
         */
            function () {
                // if the item has children then do nothing at this stage
                if (this.item.children && this._pageHeaderService.secondary$.getValue() === false) {
                    return;
                }
                // otherwise select the current item
                this._pageHeaderService.select(this.item);
            };
        PageHeaderNavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0 && !(secondary$ | async)\"\n    dropdown\n    #menu=\"bs-dropdown\"\n    [(isOpen)]=\"isOpen\"\n    container=\"body\"\n    placement=\"bottom left\">\n\n    <button role=\"menuitem\"\n        class=\"horizontal-navigation-button\"\n        [class.selected]=\"item.selected\"\n        [class.open]=\"isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"isOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #button=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n        <span class=\"navigation-item-label\">{{ item?.title }}</span>\n        <span class=\"hpe-icon hpe-down\"></span>\n\n    </button>\n\n    <div *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-menu\"\n        uxMenuNavigation\n        [toggleButton]=\"button\"\n        toggleButtonPosition=\"top\">\n\n        <div *ngFor=\"let item of item?.children\" uxMenuNavigationItem (activated)=\"dropdownItem.focus()\">\n            <ux-page-header-horizontal-navigation-dropdown-item\n                #dropdownItem=\"ux-page-header-horizontal-navigation-dropdown-item\"\n                [item]=\"item\">\n            </ux-page-header-horizontal-navigation-dropdown-item>\n        </div>\n\n    </div>\n\n</div>\n\n<button *ngIf=\"!item.children || item.children.length === 0 || (secondary$ | async)\"\n    role=\"menuitem\"\n    class=\"horizontal-navigation-button\"\n    [class.selected]=\"item.selected\"\n    [attr.aria-selected]=\"item.selected\"\n    (click)=\"select()\">\n\n    <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n    <span class=\"navigation-item-label\">{{ item?.title }}</span>\n\n</button>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationItemComponent.propDecorators = {
            button: [{ type: core.ViewChild, args: ['button',] }],
            menu: [{ type: core.ViewChild, args: ['menu',] }],
            dropdowns: [{ type: core.ViewChildren, args: [PageHeaderNavigationDropdownItemComponent,] }],
            item: [{ type: core.Input }]
        };
        return PageHeaderNavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationSecondaryItemDirective = (function () {
        function PageHeaderNavigationSecondaryItemDirective(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(operators.delay(0), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                });
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        PageHeaderNavigationSecondaryItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderNavigationSecondaryItem]'
                    },] }
        ];
        /** @nocollapse */
        PageHeaderNavigationSecondaryItemDirective.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationSecondaryItemDirective.propDecorators = {
            item: [{ type: core.Input, args: ['uxPageHeaderNavigationSecondaryItem',] }]
        };
        return PageHeaderNavigationSecondaryItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationComponent = (function () {
        function PageHeaderNavigationComponent(elementRef, resizeService, _pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this.items$ = this._pageHeaderService.items$;
            this.indicatorVisible = false;
            this.indicatorX = 0;
            this.indicatorWidth = 0;
            this._subscription = new Subscription.Subscription();
            this._subscription.add(resizeService.addResizeListener(elementRef.nativeElement).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.selected$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.secondary$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.updateSelectedIndicator();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.updateSelectedIndicator = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () {
                    // find the selected item
                    var /** @type {?} */ selected = _this.menuItems.find(function (item) { return item.item.selected; });
                    // determine whether or not to show the indicator
                    // determine whether or not to show the indicator
                    _this.indicatorVisible = !!selected;
                    // set the width of the indicator to match the width of the navigation item
                    if (selected) {
                        var /** @type {?} */ styles = getComputedStyle(selected.elementRef.nativeElement);
                        _this.indicatorX = selected.elementRef.nativeElement.offsetLeft;
                        _this.indicatorWidth = parseInt(styles.getPropertyValue('width'));
                    }
                });
            };
        PageHeaderNavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation',
                        template: "<ux-page-header-horizontal-navigation-item\r\n    *ngFor=\"let item of items$ | async\"\r\n    [item]=\"item\">\r\n</ux-page-header-horizontal-navigation-item>\r\n\r\n<div class=\"selected-indicator\"\r\n    [style.opacity]=\"indicatorVisible ? 1 : 0\"\r\n    [style.margin-left.px]=\"indicatorX\"\r\n    [style.width.px]=\"indicatorWidth\">\r\n</div>",
                        host: {
                            'role': 'menubar'
                        }
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService },
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationComponent.propDecorators = {
            menuItems: [{ type: core.ViewChildren, args: [PageHeaderNavigationItemComponent,] }]
        };
        return PageHeaderNavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderComponent = (function () {
        function PageHeaderComponent(_colorService, _pageHeaderService) {
            this._colorService = _colorService;
            this._pageHeaderService = _pageHeaderService;
            this.alignment = 'center';
            this.condensed = false;
            this.backVisible = true;
            this.secondaryNavigationAlignment = 'center';
            this.crumbsStyle = 'standard';
            this.backClick = new core.EventEmitter();
            this.selected$ = this._pageHeaderService.selected$;
            this.selectedRoot$ = this._pageHeaderService.selectedRoot$;
            this._crumbs = [];
        }
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigationAutoselect", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondaryNavigationAutoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._pageHeaderService.secondaryNavigationAutoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "items", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._pageHeaderService.setItems(items);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigation", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondary$.getValue();
            },
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._pageHeaderService.setSecondaryNavigation(enabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "crumbs", {
            get: /**
             * @return {?}
             */ function () {
                return this.condensed ? __spread(this._crumbs, [{ title: this.header }]) : this._crumbs;
            },
            set: /**
             * @param {?} crumbs
             * @return {?}
             */ function (crumbs) {
                this._crumbs = crumbs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoBackground", {
            get: /**
             * @return {?}
             */ function () {
                return this._logoBackground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._logoBackground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoForeground", {
            get: /**
             * @return {?}
             */ function () {
                return this._logoForeground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._logoForeground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyBackground", {
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this.logoBackground = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyForeground", {
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this.logoForeground = color;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.goBack = /**
         * @return {?}
         */
            function () {
                this.backClick.emit();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this._pageHeaderService.select(item);
            };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header',
                        exportAs: 'ux-page-header',
                        template: "<div class=\"ux-page-header\" [class.page-header-condensed]=\"condensed\" role=\"banner\">\n\n    <div *ngIf=\"!condensed\" class=\"page-header-content\">\n\n        <!-- Logo/product acronym -->\n        <div class=\"page-header-logo-container\" role=\"presentation\" [style.backgroundColor]=\"logoBackground\" [style.color]=\"logoForeground\">\n            <img *ngIf=\"logo\" [attr.src]=\"logo\" [alt]=\"header\" class=\"page-header-logo\">\n            <h1 *ngIf=\"header && !logo\" class=\"page-header-acronym\">{{header}}</h1>\n        </div>\n\n        <!-- Sub-title -->\n        <div *ngIf=\"title || titleTemplate\" class=\"page-header-subtitle-container\">\n            <span *ngIf=\"title\" class=\"page-header-subtitle\">{{title}}</span>\n            <ng-container [ngTemplateOutlet]=\"titleTemplate\"></ng-container>\n        </div>\n\n        <div class=\"page-header-state-container\" role=\"navigation\">\n\n            <!-- Back button -->\n            <button *ngIf=\"backVisible === true\" class=\"page-header-back-button\" (click)=\"goBack()\" aria-label=\"Go Back\">\n                <span class=\"hpe-icon hpe-previous text-primary\"></span>\n            </button>\n\n            <!-- Breadcrumbs and header -->\n            <div class=\"page-header-title-container\">\n\n                <ux-breadcrumbs *ngIf=\"crumbs && crumbs.length > 0\"\n                    [class.ux-breadcrumbs-small]=\"crumbsStyle === 'small'\"\n                    [crumbs]=\"crumbs\"></ux-breadcrumbs>\n\n                <h1 class=\"page-header-title\">{{header}}</h1>\n\n            </div>\n\n        </div>\n\n        <!-- Primary navigation -->\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <!-- Icon menus -->\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n    </div>\n\n    <!-- Display This Section Optimized for Condensed Mode -->\n    <div class=\"page-header-condensed-content\" *ngIf=\"condensed\">\n\n        <div class=\"page-header-breadcrumbs\" role=\"navigation\">\n            <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n\n    </div>\n\n</div>\n\n<div *ngIf=\"secondaryNavigation && ((selectedRoot$ | async) !== (selected$ | async))\"\n    class=\"page-header-secondary\" [ngClass]=\"secondaryNavigationAlignment\" role=\"navigation\">\n\n    <ux-tabset *ngIf=\"(selectedRoot$ | async)?.children; let children\">\n        <ux-tab *ngFor=\"let child of children\"\n            [heading]=\"child.title\"\n            [active]=\"child === (selected$ | async)\"\n            (select)=\"select(child)\"\n            [uxPageHeaderNavigationSecondaryItem]=\"child\">\n        </ux-tab>\n    </ux-tabset>\n\n</div>\n",
                        providers: [PageHeaderService]
                    }] }
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: PageHeaderService }
            ];
        };
        PageHeaderComponent.propDecorators = {
            logo: [{ type: core.Input }],
            header: [{ type: core.Input }],
            title: [{ type: core.Input }],
            alignment: [{ type: core.Input }],
            condensed: [{ type: core.Input }],
            iconMenus: [{ type: core.Input }],
            backVisible: [{ type: core.Input }],
            secondaryNavigationAlignment: [{ type: core.Input }],
            secondaryNavigationAutoselect: [{ type: core.Input }],
            items: [{ type: core.Input }],
            secondaryNavigation: [{ type: core.Input }],
            crumbs: [{ type: core.Input }],
            crumbsStyle: [{ type: core.Input }],
            logoBackground: [{ type: core.Input }],
            logoForeground: [{ type: core.Input }],
            familyBackground: [{ type: core.Input }],
            familyForeground: [{ type: core.Input }],
            backClick: [{ type: core.Output }],
            titleTemplate: [{ type: core.ContentChild, args: ['title',] }],
            customMenus: [{ type: core.ContentChildren, args: [PageHeaderCustomMenuDirective, { read: core.TemplateRef },] }]
        };
        return PageHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetService = (function () {
        function TabsetService() {
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.focused$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
        }
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.add = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
                // check if this is the only tab. If so select this by default
                if (!this.active$.value) {
                    this.select(tab);
                }
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.remove = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                // remove the tab
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.select = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                if (!tab.disabled) {
                    this.active$.next(tab);
                    this.highlighted$.next(tab);
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        TabsetService.prototype.selectAtIndex = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // if there are no tabs then do nothing
                if (this.tabs$.value.length === 0) {
                    return;
                }
                // check if the index is within the bounds
                if (index < 0) {
                    return this.selectAtIndex(this.tabs$.value.length - 1);
                }
                else if (index >= this.tabs$.value.length) {
                    return this.selectAtIndex(0);
                }
                var /** @type {?} */ target = this.tabs$.value[index];
                if (target) {
                    this.select(target);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectNextTab = /**
         * @return {?}
         */
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs after the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(index + 1);
                try {
                    // check if any of the tabs are not disabled
                    for (var tabs_1 = __values(tabs), tabs_1_1 = tabs_1.next(); !tabs_1_1.done; tabs_1_1 = tabs_1.next()) {
                        var tab = tabs_1_1.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (tabs_1_1 && !tabs_1_1.done && (_a = tabs_1.return))
                            _a.call(tabs_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // if we reach here then no tab could be selected - select the first tab
                this.selectFirstTab();
                var e_1, _a;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectPreviousTab = /**
         * @return {?}
         */
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs before the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(0, index);
                try {
                    // check if any of the tabs are not disabled
                    for (var _a = __values(tabs.reverse()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var tab = _b.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                // if we reach here then no previous tab could be selected - select the last tab
                this.selectLastTab();
                var e_2, _c;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectFirstTab = /**
         * @return {?}
         */
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex(tabIndex);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectLastTab = /**
         * @return {?}
         */
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.slice().reverse().findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex((this.tabs$.value.length - 1) - tabIndex);
                }
            };
        TabsetService.decorators = [
            { type: core.Injectable }
        ];
        return TabsetService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabFocusDirective = (function () {
        function TabFocusDirective(_tabset, _elementRef) {
            this._tabset = _tabset;
            this._elementRef = _elementRef;
        }
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscription = this._tabset.highlighted$.pipe(operators.filter(function () { return _this._tabset.focused$.value === true; }), operators.filter(function () { return _this._tabset.highlighted$.value === _this.uxTabFocus; })).subscribe(function () { return _this._elementRef.nativeElement.focus(); });
            };
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        TabFocusDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabFocus]'
                    },] }
        ];
        /** @nocollapse */
        TabFocusDirective.ctorParameters = function () {
            return [
                { type: TabsetService },
                { type: core.ElementRef }
            ];
        };
        TabFocusDirective.propDecorators = {
            uxTabFocus: [{ type: core.Input }]
        };
        return TabFocusDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTabId = 0;
    var TabComponent = (function () {
        function TabComponent(_tabset) {
            var _this = this;
            this._tabset = _tabset;
            this.id = "ux-tab-" + ++uniqueTabId;
            this.disabled = false;
            this.select = new core.EventEmitter();
            this.deselect = new core.EventEmitter();
            this.active$ = this._tabset.active$.pipe(operators.map(function (active) { return active === _this; }));
            _tabset.add(this);
            this._subscription = this.active$.subscribe(function (active) { return active ? _this.select.emit() : _this.deselect.emit(); });
        }
        Object.defineProperty(TabComponent.prototype, "active", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._tabset.select(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._tabset.remove(this);
                this._subscription.unsubscribe();
            };
        TabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tab',
                        template: "<div role=\"tabpanel\"\n     class=\"tab-pane\"\n     [class.active]=\"active$ | async\"\n     [id]=\"id + '-panel'\"\n     [attr.aria-labelledby]=\"id\"\n     [attr.aria-hidden]=\"!(active$ | async)\">\n  <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TabComponent.ctorParameters = function () {
            return [
                { type: TabsetService }
            ];
        };
        TabComponent.propDecorators = {
            id: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            heading: [{ type: core.Input }],
            customClass: [{ type: core.Input }],
            select: [{ type: core.Output }],
            deselect: [{ type: core.Output }],
            active: [{ type: core.Input }]
        };
        return TabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabHeadingDirective = (function () {
        function TabHeadingDirective(templateRef, tab) {
            tab.headingRef = templateRef;
        }
        TabHeadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabHeading]'
                    },] }
        ];
        /** @nocollapse */
        TabHeadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef },
                { type: TabComponent }
            ];
        };
        return TabHeadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetComponent = (function () {
        function TabsetComponent(tabset) {
            this.tabset = tabset;
            this.minimal = true;
            this.stacked = 'none';
        }
        /**
         * Allow manual tab selected
         */
        /**
         * Allow manual tab selected
         * @param {?} tab
         * @return {?}
         */
        TabsetComponent.prototype.select = /**
         * Allow manual tab selected
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabset.select(tab);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectPreviousTab = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowLeft = event.key === 'ArrowLeft' || event.keyCode === 37;
                var /** @type {?} */ arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
                // only perform action if the arrow key matches the orientation
                if (arrowLeft && this.stacked !== 'none' || arrowUp && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectPreviousTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectNextTab = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowRight = event.key === 'ArrowRight' || event.keyCode === 39;
                var /** @type {?} */ arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
                // only perform action if the arrow key matches the orientation
                if (arrowRight && this.stacked !== 'none' || arrowDown && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectNextTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        TabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tabset',
                        template: "<!-- Nav tabs -->\n<ul role=\"tablist\"\n    class=\"nav nav-tabs\"\n    [class.minimal-tab]=\"minimal\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-orientation]=\"stacked === 'none' ? 'horizontal' : 'vertical'\">\n\n\t<li role=\"presentation\" \n        class=\"nav-item\"\n        *ngFor=\"let tab of tabset.tabs$ | async; let index = index\"\n        [class.active]=\"tab.active$ | async\"\n        [class.disabled]=\"tab.disabled\"\n        [ngClass]=\"tab.customClass\">\n\n        <a class=\"nav-link\"\n            [id]=\"tab.id\"\n            role=\"tab\"\n            [uxTabFocus]=\"tab\"\n            [tabindex]=\"(tab.active$ | async) ? 0 : -1\"\n            [class.highlighted]=\"(tabset.focused$ | async) && (tabset.highlighted$ | async) === tab\"            \n            (mousedown)=\"tabset.select(tab)\"\n            (focus)=\"tabset.focused$.next(true)\"\n            (blur)=\"tabset.focused$.next(false)\"\n            (mousedown)=\"tabset.focused$.next(true)\"\n            (keydown.ArrowUp)=\"selectPreviousTab($event)\"\n            (keydown.ArrowLeft)=\"selectPreviousTab($event)\"\n            (keydown.ArrowRight)=\"selectNextTab($event)\"\n            (keydown.ArrowDown)=\"selectNextTab($event)\"\n            (keydown.Home)=\"tabset.selectFirstTab(); $event.preventDefault()\"\n            (keydown.End)=\"tabset.selectLastTab(); $event.preventDefault()\"\n            [attr.aria-controls]=\"tab.id\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            [attr.aria-disabled]=\"tab.disabled\">\n\n            <span *ngIf=\"!tab.headingRef\">{{ tab.heading }}</span>\n\n            <ng-container *ngIf=\"tab.headingRef\" [ngTemplateOutlet]=\"tab.headingRef\"></ng-container>\n        </a>\n\n\t</li>\n\n</ul>\n\n<!-- Tab panes -->\n<div class=\"tab-content\">\n\t<ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TabsetService],
                        host: {
                            '[class.tabs-left]': 'stacked === "left"',
                            '[class.tabs-right]': 'stacked === "right"',
                        }
                    }] }
        ];
        /** @nocollapse */
        TabsetComponent.ctorParameters = function () {
            return [
                { type: TabsetService }
            ];
        };
        TabsetComponent.propDecorators = {
            minimal: [{ type: core.Input }],
            stacked: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }]
        };
        return TabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetModule = (function () {
        function TabsetModule() {
        }
        TabsetModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [TabsetComponent, TabComponent, TabHeadingDirective],
                        declarations: [TabsetComponent, TabComponent, TabHeadingDirective, TabFocusDirective],
                    },] }
        ];
        return TabsetModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderModule = (function () {
        function PageHeaderModule() {
        }
        PageHeaderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            BreadcrumbsModule,
                            dropdown.BsDropdownModule.forRoot(),
                            ColorServiceModule,
                            common.CommonModule,
                            MenuNavigationModule,
                            ResizeModule,
                            router.RouterModule,
                            TabsetModule
                        ],
                        exports: [
                            PageHeaderComponent,
                            PageHeaderCustomMenuDirective
                        ],
                        declarations: [
                            PageHeaderComponent,
                            PageHeaderIconMenuComponent,
                            PageHeaderCustomMenuDirective,
                            PageHeaderNavigationComponent,
                            PageHeaderNavigationItemComponent,
                            PageHeaderNavigationDropdownItemComponent,
                            PageHeaderNavigationSecondaryItemDirective
                        ]
                    },] }
        ];
        return PageHeaderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ PAGINATION_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return PaginationComponent; }),
        multi: true
    };
    var PaginationComponent = (function () {
        function PaginationComponent() {
            /**
             * Specify if we should show the next and previous buttons
             */
            this.directionButtons = true;
            /**
             * Limit the number of pages shown at any given time
             */
            this.maxSize = 5;
            /**
             * Specify if the component should be disabled
             */
            this.disabled = false;
            /**
             * Aria Label for the component navigation
             */
            this.ariaLabel = 'Pagination Navigation';
            /**
             * Aria label for the previous button
             */
            this.previousAriaLabel = 'Navigate to the previous page';
            /**
             * Aria label for the next button
             */
            this.nextAriaLabel = 'Navigate to the next page';
            /**
             * Emit the current page number
             */
            this.pageChange = new core.EventEmitter();
            /**
             * Emit the total number of pages
             */
            this.numPages = new core.EventEmitter();
            /**
             * Store a list of pages to display in the UI
             */
            this.pages = [];
            /**
             * ControlValueAccessor functions
             */
            this.onTouched = function () { };
            this.onChange = function () { };
            this.isKeyboardEvent = false;
            this._page = 1;
            this._total = 100;
            this._pagesize = 10;
        }
        Object.defineProperty(PaginationComponent.prototype, "page", {
            get: /**
             * @return {?}
             */ function () {
                return this._page;
            },
            /** Specify the index of the active page */
            set: /**
             * Specify the index of the active page
             * @param {?} page
             * @return {?}
             */ function (page) {
                // do nothing if the page has not changed
                if (page === this._page) {
                    return;
                }
                this._page = page;
                this.pages = this.getPages();
                // mark this component as changed
                this.onChange(this.page);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "itemsPerPage", {
            /** Specify the page size */
            set: /**
             * Specify the page size
             * @param {?} pagesize
             * @return {?}
             */ function (pagesize) {
                this._pagesize = pagesize;
                this.pages = this.getPages();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "totalItems", {
            /** Specify how many items there are in total */
            set: /**
             * Specify how many items there are in total
             * @param {?} total
             * @return {?}
             */ function (total) {
                this._total = total;
                this.pages = this.getPages();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "pageCount", {
            get: /**
             * @return {?}
             */ function () {
                return Math.ceil(this._total / this._pagesize);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PaginationComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.pages = this.getPages();
            };
        /**
         * @param {?} index
         * @return {?}
         */
        PaginationComponent.prototype.select = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // find the page we want to go to
                var /** @type {?} */ target = this.pages.find(function (page) { return page.index === index; });
                // if the page is out of bounds then do nothing
                if (!target) {
                    return;
                }
                // mark this component as touched
                this.onTouched();
                // set this as the current page
                this.page = target.index;
                // update the visible pages
                this.pages = this.getPages();
                // emit the current page
                this.pageChange.emit(this.page);
            };
        /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
        PaginationComponent.prototype.trackByFn = /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
            function (_index, item) {
                return item.index;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        PaginationComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        PaginationComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouched = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        PaginationComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} page
         * @return {?}
         */
        PaginationComponent.prototype.writeValue = /**
         * @param {?} page
         * @return {?}
         */
            function (page) {
                this.page = page;
            };
        /**
         * @return {?}
         */
        PaginationComponent.prototype.getPages = /**
         * @return {?}
         */
            function () {
                // create a new array to store the pages
                var /** @type {?} */ pages = [];
                // create all possible pages
                for (var /** @type {?} */ index = 1; index <= this.pageCount; index++) {
                    pages.push({ index: index, visible: this.isPageVisible(index) });
                }
                // emit the number of pages
                this.numPages.emit(this.pageCount);
                return pages;
            };
        /**
         * @param {?} index
         * @return {?}
         */
        PaginationComponent.prototype.isPageVisible = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // if we do not have a max size specified or the number of pages is less than the max size then it is always visible
                if (!this.maxSize || this.pageCount <= this.maxSize) {
                    return true;
                }
                // find the starting position
                var /** @type {?} */ start = Math.max(1, Math.ceil(this.page - (this.maxSize / 2)));
                var /** @type {?} */ end = Math.min(start + this.maxSize, this.pageCount + 1);
                // if the range is less than the max size we need to adjust the starting point
                var /** @type {?} */ range = end - start;
                if (range < this.maxSize) {
                    start = start - (this.maxSize - range);
                }
                // if the item equals the start position or is less than the end position then show it
                return index >= start && index < end;
            };
        PaginationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-pagination',
                        template: "<nav role=\"navigation\" [attr.aria-label]=\"ariaLabel\">\n  <ul #container class=\"pagination\"\n    [ngClass]=\"classes\"\n    direction=\"horizontal\"\n    (blur)=\"isKeyboardEvent = false\"\n    (keydown.ArrowLeft)=\"select(page - 1); isKeyboardEvent = true\"\n    (keydown.ArrowRight)=\"select(page + 1); isKeyboardEvent = true\"\n    (keydown.Home)=\"select(1); isKeyboardEvent = true; $event.preventDefault()\"\n    (keydown.End)=\"select(pageCount); isKeyboardEvent = true; $event.preventDefault()\">\n\n    <li class=\"pagination-prev page-item\"\n        *ngIf=\"directionButtons\"\n        [class.disabled]=\"page === 1 || disabled\">\n\n      <a class=\"page-link ux-keyboard-focus\"\n         tabindex=\"0\"\n         cdkMonitorElementFocus\n         [attr.aria-label]=\"previousAriaLabel\"\n         [ngClass]=\"pageBtnClass\"\n         (click)=\"select(page - 1)\"\n         (keydown.enter)=\"select(page - 1)\">\n        <ng-container [ngTemplateOutlet]=\"previousBtnTemplate || defaultPreviousBtnTemplate\"></ng-container>\n      </a>\n    </li>\n\n    <ng-container *ngFor=\"let pg of pages; trackBy: trackByFn\">\n      <li *ngIf=\"pg.visible\"\n          [class.disabled]=\"disabled\"\n          [class.active]=\"page === pg.index\"\n          class=\"pagination-page page-item\">\n\n        <a class=\"page-link ux-keyboard-focus\"\n           tabindex=\"0\"\n           [ngClass]=\"pageBtnClass\"\n           cdkMonitorElementFocus\n           [focusIf]=\"isKeyboardEvent && page === pg.index\"\n           [attr.aria-current]=\"page === pg.index\"\n           [attr.aria-setsize]=\"pageCount\"\n           [attr.aria-posinset]=\"pg.index\"\n           (click)=\"select(pg.index)\"\n           (keydown.enter)=\"select(pg.index)\">\n            {{ pg.index }}\n        </a>\n      </li>\n    </ng-container>\n\n    <li class=\"pagination-next page-item\"\n        *ngIf=\"directionButtons\"\n        [class.disabled]=\"page === pageCount || disabled\">\n\n      <a class=\"page-link ux-keyboard-focus\"\n         tabindex=\"0\"\n         cdkMonitorElementFocus\n         [attr.aria-label]=\"nextAriaLabel\"\n         [ngClass]=\"pageBtnClass\"\n         (click)=\"select(page + 1)\"\n         (keydown.enter)=\"select(page + 1)\">\n\n        <ng-container [ngTemplateOutlet]=\"nextBtnTemplate || defaultNextBtnTemplate\"></ng-container>\n      </a>\n    </li>\n  </ul>\n</nav>\n\n<ng-template #defaultPreviousBtnTemplate>\n  <span class=\"hpe-icon hpe-previous\"></span>\n</ng-template>\n\n<ng-template #defaultNextBtnTemplate>\n  <span class=\"hpe-icon hpe-next\"></span>\n</ng-template>\n",
                        providers: [PAGINATION_CONTROL_VALUE_ACCESSOR]
                    }] }
        ];
        PaginationComponent.propDecorators = {
            directionButtons: [{ type: core.Input }],
            maxSize: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            classes: [{ type: core.Input, args: ['class',] }],
            pageBtnClass: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            previousAriaLabel: [{ type: core.Input }],
            nextAriaLabel: [{ type: core.Input }],
            page: [{ type: core.Input }],
            previousBtnTemplate: [{ type: core.Input }],
            nextBtnTemplate: [{ type: core.Input }],
            itemsPerPage: [{ type: core.Input }],
            totalItems: [{ type: core.Input }],
            pageChange: [{ type: core.Output }],
            numPages: [{ type: core.Output }]
        };
        return PaginationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PaginationModule = (function () {
        function PaginationModule() {
        }
        PaginationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            a11y.A11yModule,
                            AccessibilityModule,
                            FocusIfModule
                        ],
                        declarations: [
                            PaginationComponent
                        ],
                        exports: [
                            PaginationComponent
                        ]
                    },] }
        ];
        return PaginationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarComponent = (function () {
        function ProgressBarComponent() {
            this.value = 0;
            this.min = 0;
            this.max = 100;
            this.indeterminate = false;
        }
        Object.defineProperty(ProgressBarComponent.prototype, "valueNow", {
            /** When indeteminate we should omit the valuenow label */
            get: /**
             * When indeteminate we should omit the valuenow label
             * @return {?}
             */ function () {
                return this.indeterminate ? null : this.value;
            },
            enumerable: true,
            configurable: true
        });
        ProgressBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-progress-bar',
                        template: "<div *ngIf=\"!indeterminate\" class=\"progressbar-track\" [style.width.%]=\"((value - min) / (max - min)) * 100\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n<div *ngIf=\"indeterminate\" class=\"progressbar-track indeterminate\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n\n<!-- Workaround for Multiple ng-content tags issue: https://github.com/angular/angular/issues/22972 -->\n<ng-template #content><ng-content></ng-content></ng-template>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            role: 'progressbar'
                        }
                    }] }
        ];
        ProgressBarComponent.propDecorators = {
            value: [{ type: core.Input }],
            min: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-valuemin',] }],
            max: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-valuemax',] }],
            indeterminate: [{ type: core.Input }],
            trackColor: [{ type: core.Input }],
            barColor: [{ type: core.Input }],
            valueNow: [{ type: core.HostBinding, args: ['attr.aria-valuenow',] }]
        };
        return ProgressBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarModule = (function () {
        function ProgressBarModule() {
        }
        ProgressBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [ProgressBarComponent],
                        declarations: [ProgressBarComponent]
                    },] }
        ];
        return ProgressBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ RADIOBUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueRadioId = 0;
    var RadioButtonComponent = (function () {
        function RadioButtonComponent() {
            this._radioButtonId = "ux-radio-button-" + ++uniqueRadioId;
            this.id = this._radioButtonId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.simplified = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.ariaDescribedby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(RadioButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._radioButtonId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                // toggle the checked state
                this.value = this.option;
                // call callback
                this.onChangeCallback(this.value);
            };
        // Functions required to update ng-model
        /**
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        RadioButtonComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        RadioButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-radio-button',
                        template: "<label [attr.for]=\"inputId\" class=\"ux-radio-button\"\n       [class.ux-radio-button-checked]=\"value === option\"\n       [class.ux-radio-button-simplified]=\"simplified\"\n       [class.ux-radio-button-disabled]=\"disabled\"\n       [class.ux-radio-button-focused]=\"focused\">\n\n    <div class=\"ux-radio-button-container\">\n        <input class=\"ux-radio-button-input\"\n            type=\"radio\"\n            [id]=\"inputId\"\n            [checked]=\"value === option\"\n            [disabled]=\"disabled\"\n            [tabindex]=\"tabindex || value === option ? 0 : -1\"\n            [attr.name]=\"name\"\n            [required]=\"required\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [attr.aria-checked]=\"value === option\"\n            (focus)=\"focused = true\"\n            (blur)=\"focused = false\"\n            (change)=\"toggle()\"\n            (click)=\"$event.stopPropagation()\">\n    </div>\n\n    <span class=\"ux-radio-button-label\">\n        <ng-content></ng-content>\n    </span>\n\n</label>",
                        providers: [RADIOBUTTON_VALUE_ACCESSOR]
                    }] }
        ];
        RadioButtonComponent.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            required: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            clickable: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            option: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            ariaDescribedby: [{ type: core.Input, args: ['aria-describedby',] }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input }]
        };
        return RadioButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RadioButtonModule = (function () {
        function RadioButtonModule() {
        }
        RadioButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [RadioButtonComponent],
                        declarations: [RadioButtonComponent]
                    },] }
        ];
        return RadioButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ UNSET_FOCUS = { groupId: null, index: -1 };
    var SearchBuilderFocusService = (function () {
        function SearchBuilderFocusService() {
            this.focus$ = new BehaviorSubject.BehaviorSubject(UNSET_FOCUS);
        }
        /**
         * Set focus on a search builder component.
         * @param groupId The `id` of the group containing the component.
         * @param index The (zero-based) index of the component.
         */
        /**
         * Set focus on a search builder component.
         * @param {?} groupId The `id` of the group containing the component.
         * @param {?} index The (zero-based) index of the component.
         * @return {?}
         */
        SearchBuilderFocusService.prototype.setFocus = /**
         * Set focus on a search builder component.
         * @param {?} groupId The `id` of the group containing the component.
         * @param {?} index The (zero-based) index of the component.
         * @return {?}
         */
            function (groupId, index) {
                this.focus$.next({ groupId: groupId, index: index });
            };
        /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         */
        /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         * @return {?}
         */
        SearchBuilderFocusService.prototype.clearFocus = /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         * @return {?}
         */
            function () {
                this.focus$.next(UNSET_FOCUS);
            };
        SearchBuilderFocusService.decorators = [
            { type: core.Injectable }
        ];
        return SearchBuilderFocusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderService = (function () {
        function SearchBuilderService() {
            this.query = {};
            this.queryChange = new Subject.Subject();
            this.validationChange = new BehaviorSubject.BehaviorSubject(true);
            this._componentId = 0;
            this._components = [];
            this._validation = {};
        }
        /**
         * Add a component to the internal list of components
         */
        /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponent = /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
            function (component) {
                // ensure there are no components with a matching name
                if (this._components.find(function (cmp) { return cmp.name === component.name; })) {
                    throw new Error("Search builder components must have a unique name. The name " + component.name + " has already been used.");
                }
                // if unique then add the component to the list
                this._components.push(component);
            };
        /**
         * Bulk registration of components
         * (Just a helper method)
         */
        /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponents = /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
            function (components) {
                var _this = this;
                components.forEach(function (component) { return _this.registerComponent(component); });
            };
        /**
         * Get a registered component class
         */
        /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
        SearchBuilderService.prototype.getComponent = /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
            function (name) {
                // find the component
                var /** @type {?} */ component = this._components.find(function (cmp) { return cmp.name === name; });
                // if there is no match throw an exception
                if (!component) {
                    throw new Error("No search build component with the name " + name + " exists");
                }
                // ensure config is defined - at least to an empty object
                component.config = component.config || {};
                return component;
            };
        /**
         * Update the internal search query state
         * note that the query will be immutable
         */
        /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
        SearchBuilderService.prototype.setQuery = /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
            function (query) {
                this.query = Object.assign({}, query);
            };
        /**
         * Return the current query state
         */
        /**
         * Return the current query state
         * @return {?}
         */
        SearchBuilderService.prototype.getQuery = /**
         * Return the current query state
         * @return {?}
         */
            function () {
                return this.query;
            };
        /**
         * Trigger the observable to indicate the query has been updated
         */
        /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
        SearchBuilderService.prototype.queryHasChanged = /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
            function () {
                this.queryChange.next(this.query);
            };
        /**
         * Store the validation state of the query
         */
        /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
        SearchBuilderService.prototype.setValid = /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
            function (id, valid) {
                var _this = this;
                // store the state for this specific component
                this._validation[id] = valid;
                // evaluate the entire validation state
                this.validationChange.next(!Object.keys(this._validation).some(function (key) { return !_this._validation[key]; }));
            };
        /**
         * Generate a unique id for each component
         */
        /**
         * Generate a unique id for each component
         * @return {?}
         */
        SearchBuilderService.prototype.generateComponentId = /**
         * Generate a unique id for each component
         * @return {?}
         */
            function () {
                return this._componentId++;
            };
        SearchBuilderService.decorators = [
            { type: core.Injectable }
        ];
        return SearchBuilderService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupService = (function () {
        function SearchBuilderGroupService(_searchBuilderService, _searchBuilderFocusService) {
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
        }
        /**
         * Initialise the group by defining an id
         */
        /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
        SearchBuilderGroupService.prototype.init = /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
            function (id) {
                var _this = this;
                // store the name of the group
                this._id = id;
                // create the entry in the query object if it doesn't exist
                if (!this._searchBuilderService.query[this._id]) {
                    // create the section
                    this._searchBuilderService.query[this._id] = [];
                    // emit the changes after the initial setup
                    setTimeout(function () { return _this._searchBuilderService.queryHasChanged(); });
                }
            };
        /**
         * Remove a field from the search builder query and return focus to the previous field.
         */
        /**
         * Remove a field from the search builder query and return focus to the previous field.
         * @param {?} index
         * @return {?}
         */
        SearchBuilderGroupService.prototype.removeAtIndex = /**
         * Remove a field from the search builder query and return focus to the previous field.
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // get the query for this group
                var /** @type {?} */ query = this.getQuery();
                // remove the field from the array
                query.splice(index, 1);
                // Focus the previous item if available
                this._searchBuilderFocusService.setFocus(this._id, index <= 0 ? 0 : index - 1);
            };
        /**
         * Get the query for this specific search group
         */
        /**
         * Get the query for this specific search group
         * @return {?}
         */
        SearchBuilderGroupService.prototype.getQuery = /**
         * Get the query for this specific search group
         * @return {?}
         */
            function () {
                return this._searchBuilderService.query[this._id] ? this._searchBuilderService.query[this._id] : [];
            };
        SearchBuilderGroupService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SearchBuilderGroupService.ctorParameters = function () {
            return [
                { type: SearchBuilderService },
                { type: SearchBuilderFocusService }
            ];
        };
        return SearchBuilderGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupComponent = (function () {
        function SearchBuilderGroupComponent(searchBuilderGroupService, _searchBuilderFocusService) {
            this.searchBuilderGroupService = searchBuilderGroupService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this.operator = 'and';
            this.addText = 'Add a field';
            this.showPlaceholder = false;
            this.add = new core.EventEmitter();
            this.remove = new core.EventEmitter();
            this.focusIndex = -1;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // ensure we have a name otherwise throw an error
                if (!this.id) {
                    throw new Error('Search builder group must have an id attribute.');
                }
                // otherwise register the group
                this.searchBuilderGroupService.init(this.id);
                // Track focus for child components
                this._searchBuilderFocusService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focus) {
                    _this.focusIndex = (focus.groupId === _this.id) ? focus.index : -1;
                });
            };
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.addField = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.add.emit(event);
            };
        /**
         * @param {?} index
         * @param {?} field
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.removeFieldAtIndex = /**
         * @param {?} index
         * @param {?} field
         * @return {?}
         */
            function (index, field) {
                this.searchBuilderGroupService.removeAtIndex(index);
                this.remove.emit(field);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.setFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this._searchBuilderFocusService.setFocus(this.id, index);
            };
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.clearFocus = /**
         * @return {?}
         */
            function () {
                this._searchBuilderFocusService.clearFocus();
            };
        SearchBuilderGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder-group',
                        template: "<h4 class=\"search-group-title\">{{ header }}</h4>\n\n<div class=\"search-group-content\">\n\n  <div class=\"search-group-operator search-group-operator-{{ operator }}\"\n    [class.hidden-operator]=\"searchBuilderGroupService.getQuery().length < 2\">{{ operator }}</div>\n\n  <div class=\"search-group-items\">\n\n    <div *ngFor=\"let field of searchBuilderGroupService.getQuery(); let i = index\"\n      class=\"search-group-item-container\"\n      [class.search-group-item-focus]=\"focusIndex === i\"\n      (uxFocusWithin)=\"setFocus(i)\"\n      (uxBlurWithin)=\"clearFocus()\">\n\n      <div class=\"search-group-item\">\n        <ng-container *uxSearchBuilderOutlet=\"field.type; context: field; groupId: id; index: i\"></ng-container>\n      </div>\n\n      <button type=\"button\"\n        aria-label=\"Remove field\"\n        class=\"search-group-item-remove\"\n        (click)=\"removeFieldAtIndex(i, field)\">\n\n        <span class=\"hpe-icon hpe-close\"></span>\n\n      </button>\n\n    </div>\n\n    <!-- Placeholder Item -->\n    <ng-container *ngIf=\"showPlaceholder\">\n\n      <!-- The Default Placeholder -->\n      <div class=\"search-group-item-container placeholder-item\" *ngIf=\"!placeholder\">\n\n        <div class=\"search-group-item\">\n          <label class=\"form-label\">New field</label>\n          <div class=\"form-control\"></div>\n        </div>\n\n      </div>\n\n      <!-- Allow a custom placeholder -->\n      <ng-container *ngTemplateOutlet=\"placeholder\"></ng-container>\n\n    </ng-container>\n\n  </div>\n\n  <button type=\"button\" class=\"search-builder-group-add-field\" (click)=\"addField($event)\">\n    <span class=\"search-builder-group-add-field-icon hpe-icon hpe-add\" aria-hidden=\"true\"></span>\n    <span class=\"search-builder-group-add-field-label\">{{ addText }}</span>\n  </button>\n\n</div>\n\n<hr class=\"search-builder-group-divider\">\n",
                        providers: [SearchBuilderGroupService]
                    }] }
        ];
        /** @nocollapse */
        SearchBuilderGroupComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderGroupService },
                { type: SearchBuilderFocusService }
            ];
        };
        SearchBuilderGroupComponent.propDecorators = {
            id: [{ type: core.Input }],
            header: [{ type: core.Input }],
            operator: [{ type: core.Input }],
            addText: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            showPlaceholder: [{ type: core.Input }],
            add: [{ type: core.Output }],
            remove: [{ type: core.Output }]
        };
        return SearchBuilderGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderOutletDirective = (function () {
        function SearchBuilderOutletDirective(_viewContainerRef, _componentFactoryResolver, _searchBuilderService, _searchBuilderFocusService) {
            this._viewContainerRef = _viewContainerRef;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // get the class from the type
                var /** @type {?} */ componentDefinition = this._searchBuilderService.getComponent(this.outlet);
                // create the component factory
                var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentDefinition.component);
                // create the component instance
                this._componentRef = this._viewContainerRef.createComponent(componentFactory);
                // combine the predefined config with any dynmaic config
                var /** @type {?} */ config = Object.assign({}, componentDefinition.config, this.context.config || {});
                // set the context and config property on the component instance
                this._componentRef.instance.context = this.context;
                this._componentRef.instance.config = config;
                this._searchBuilderFocusService.focus$
                    .pipe(operators.distinctUntilChanged(), operators.delay(0), operators.takeUntil(this._onDestroy))
                    .subscribe(function (focus) {
                    _this._componentRef.instance.focus = (focus.groupId === _this.groupId && focus.index === _this.index);
                });
            };
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        SearchBuilderOutletDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSearchBuilderOutlet]'
                    },] }
        ];
        /** @nocollapse */
        SearchBuilderOutletDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef },
                { type: core.ComponentFactoryResolver },
                { type: SearchBuilderService },
                { type: SearchBuilderFocusService }
            ];
        };
        SearchBuilderOutletDirective.propDecorators = {
            outlet: [{ type: core.Input, args: ['uxSearchBuilderOutlet',] }],
            context: [{ type: core.Input, args: ['uxSearchBuilderOutletContext',] }],
            groupId: [{ type: core.Input, args: ['uxSearchBuilderOutletGroupId',] }],
            index: [{ type: core.Input, args: ['uxSearchBuilderOutletIndex',] }]
        };
        return SearchBuilderOutletDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderComponent = (function () {
        /**
         * Register the default search builder components
         */
        function SearchBuilderComponent(_searchBuilderService) {
            var _this = this;
            this._searchBuilderService = _searchBuilderService;
            this.queryChange = new core.EventEmitter();
            this.valid = new core.EventEmitter(true);
            // watch for any query changes
            this._querySubscription = _searchBuilderService.queryChange.subscribe(function (query) { return _this.queryChange.emit(query); });
            // watch for any changes to the validation
            this._validSubscription = _searchBuilderService.validationChange.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.valid.emit(valid); });
        }
        Object.defineProperty(SearchBuilderComponent.prototype, "components", {
            set: /**
             * @param {?} components
             * @return {?}
             */ function (components) {
                this._searchBuilderService.registerComponents(components);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBuilderComponent.prototype, "query", {
            get: /**
             * @return {?}
             */ function () {
                return this._searchBuilderService.getQuery();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._searchBuilderService.setQuery(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Remove any subscriptions and cleanup
         */
        /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
        SearchBuilderComponent.prototype.ngOnDestroy = /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
            function () {
                this._querySubscription.unsubscribe();
                this._validSubscription.unsubscribe();
            };
        SearchBuilderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder',
                        template: "<ng-content></ng-content>",
                        providers: [SearchBuilderService]
                    }] }
        ];
        /** @nocollapse */
        SearchBuilderComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService }
            ];
        };
        SearchBuilderComponent.propDecorators = {
            components: [{ type: core.Input }],
            query: [{ type: core.Input }],
            queryChange: [{ type: core.Output }],
            valid: [{ type: core.Output }]
        };
        return SearchBuilderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$7 = 0;
    var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SelectComponent; }),
        multi: true
    };
    var SelectComponent = (function () {
        function SelectComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-select-" + ++uniqueId$7;
            this.allowNull = false;
            this.disabled = false;
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiple = false;
            this.pageSize = 20;
            this.autocomplete = 'off';
            this.valueChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.dropdownOpenChange = new core.EventEmitter();
            this.propagateChange = function (_) { };
            this._value$ = new BehaviorSubject.BehaviorSubject(null);
            this._input$ = new BehaviorSubject.BehaviorSubject('');
            this._dropdownOpen = false;
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(SelectComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "dropdownOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._dropdownOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._dropdownOpen = value;
                this.dropdownOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Emit change events
                this._value$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(function (value) {
                    _this.valueChange.emit(value);
                    _this.propagateChange(value);
                });
                this._input$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(function (value) {
                    _this.inputChange.emit(value);
                });
                // Changes to the input field
                this._input$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (value) { return _this.allowNull; }), operators.filter(function (value) { return !_this.multiple && value !== _this.getDisplay(_this.value); })).subscribe(function (value) { return _this.value = null; });
                // Set up filter from input
                this.filter$ = this._input$.pipe(operators.map(function (input) { return !_this.multiple && input === _this.getDisplay(_this.value) ? '' : input; }), operators.debounceTime(200));
                // Open the dropdown when filter is nonempty.
                this.filter$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (value) { return value && value.length > 0; })).subscribe(function () { return _this.dropdownOpen = true; });
                // Update the single-select input when the model changes
                this._value$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(), operators.delay(0), operators.filter(function (value) { return value !== null && !_this.multiple; })).subscribe(function (value) {
                    _this.input = _this.getDisplay(value);
                });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SelectComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes["multiple"] && !changes["multiple"].firstChange && changes["multiple"].currentValue !== changes["multiple"].previousValue) {
                    this.input = '';
                }
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.onfocus = /**
         * @return {?}
         */
            function () {
                if (this.singleInput) {
                    this.singleInput.nativeElement.focus();
                }
                else if (this.tagInput) {
                    this.tagInput.focus();
                }
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SelectComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                if (obj !== undefined && obj !== this.value) {
                    this.value = obj;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SelectComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputClickHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.selectInputText();
                this.dropdownOpen = true;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputBlurHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                // If a click on the typeahead is in progress, just refocus the input.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.singleTypeahead && this.singleTypeahead.clicking) {
                    this.singleInput.nativeElement.focus();
                    return;
                }
                // Close dropdown and reset text input if focus is lost
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.dropdownOpen = false;
                        if (!_this.multiple) {
                            _this.input = _this.getDisplay(_this.value);
                        }
                    }
                }, 200);
            };
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         */
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputKeyHandler = /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Standard keys for typeahead (up/down/esc)
                this._typeaheadKeyService.handleKey(event, this.singleTypeahead);
                switch (event.key) {
                    case 'Enter':
                        if (this._dropdownOpen) {
                            // Set the highlighted option as the value and close
                            this.value = this.singleTypeahead.highlighted;
                            this.dropdownOpen = false;
                        }
                        // Update the input field. If dropdown isn't open then reset it to the previous value.
                        this.input = this.getDisplay(this.value);
                        event.preventDefault();
                        break;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.singleOptionSelected = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.option) {
                    this.value = event.option;
                    this.dropdownOpen = false;
                }
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        SelectComponent.prototype.getDisplay = /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (option === null || option === undefined) {
                    return '';
                }
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.selectInputText = /**
         * @return {?}
         */
            function () {
                this.singleInput.nativeElement.select();
            };
        SelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select',
                        template: "<ux-tag-input *ngIf=\"multiple\"\r\n    #tagInput=\"ux-tag-input\"\r\n    [id]=\"id + '-input'\"\r\n    [(tags)]=\"value\"\r\n    [(input)]=\"input\"\r\n    [autocomplete]=\"autocomplete\"\r\n    [addOnPaste]=\"false\"\r\n    [disabled]=\"disabled\"\r\n    [display]=\"display\"\r\n    [freeInput]=\"false\"\r\n    [placeholder]=\"placeholder\"\r\n    [showTypeaheadOnClick]=\"true\">\r\n\r\n    <ux-typeahead #multipleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [disabledOptions]=\"value\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"true\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\">\r\n    </ux-typeahead>\r\n\r\n</ux-tag-input>\r\n\r\n<div *ngIf=\"!multiple\"\r\n    class=\"inner-addon right-addon\"\r\n    [class.disabled]=\"disabled\"\r\n    role=\"combobox\"\r\n    [attr.aria-expanded]=\"dropdownOpen\"\r\n    aria-haspopup=\"listbox\">\r\n\r\n    <i class=\"hpe-icon\"\r\n        [class.hpe-down]=\"dropDirection === 'down'\"\r\n        [class.hpe-up]=\"dropDirection === 'up'\"></i>\r\n\r\n    <input #singleInput type=\"text\" [attr.id]=\"id + '-input'\" class=\"form-control\"\r\n        [attr.aria-activedescendant]=\"highlightedElement?.id\"\r\n        [autocomplete]=\"autocomplete\"\r\n        aria-autocomplete=\"list\"\r\n        [attr.aria-controls]=\"singleTypeahead.id\"\r\n        aria-multiline=\"false\"\r\n        [(ngModel)]=\"input\"\r\n        [placeholder]=\"placeholder\"\r\n        [disabled]=\"disabled\"\r\n        (click)=\"inputClickHandler($event)\"\r\n        (blur)=\"inputBlurHandler($event)\"\r\n        (keydown)=\"inputKeyHandler($event)\">\r\n\r\n    <ux-typeahead #singleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"false\"\r\n        [openOnFilterChange]=\"false\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\"\r\n        (optionSelected)=\"singleOptionSelected($event)\"\r\n        (highlightedElementChange)=\"highlightedElement = $event\">\r\n    </ux-typeahead>\r\n\r\n</div>\r\n",
                        providers: [SELECT_VALUE_ACCESSOR],
                        host: {
                            'tabindex': '0'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: TypeaheadKeyService }
            ];
        };
        SelectComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            value: [{ type: core.Input }],
            input: [{ type: core.Input }],
            dropdownOpen: [{ type: core.Input }],
            options: [{ type: core.Input }],
            display: [{ type: core.Input }],
            key: [{ type: core.Input }],
            allowNull: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            dropDirection: [{ type: core.Input }],
            maxHeight: [{ type: core.Input }],
            multiple: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            autocomplete: [{ type: core.Input }],
            loadingTemplate: [{ type: core.Input }],
            noOptionsTemplate: [{ type: core.Input }],
            optionTemplate: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            inputChange: [{ type: core.Output }],
            dropdownOpenChange: [{ type: core.Output }],
            singleInput: [{ type: core.ViewChild, args: ['singleInput',] }],
            tagInput: [{ type: core.ViewChild, args: ['tagInput',] }],
            multipleTypeahead: [{ type: core.ViewChild, args: ['multipleTypeahead',] }],
            singleTypeahead: [{ type: core.ViewChild, args: ['singleTypeahead',] }],
            onfocus: [{ type: core.HostListener, args: ['focus',] }]
        };
        return SelectComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputEvent = (function () {
        function TagInputEvent(tag) {
            this.tag = tag;
            this._defaultPrevented = false;
        }
        /**
         * @return {?}
         */
        TagInputEvent.prototype.preventDefault = /**
         * @return {?}
         */
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        TagInputEvent.prototype.defaultPrevented = /**
         * @return {?}
         */
            function () {
                return this._defaultPrevented;
            };
        return TagInputEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$8 = 0;
    var /** @type {?} */ TAGINPUT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var /** @type {?} */ TAGINPUT_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var TagInputComponent = (function () {
        function TagInputComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-tag-input-" + ++uniqueId$8;
            this.tagsChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.addOnPaste = true;
            this.disabled = false;
            this.enforceTagLimits = false;
            this.freeInput = true;
            this.maxTags = Number.MAX_VALUE;
            this.minTags = 0;
            this.placeholder = '';
            this.showTypeaheadOnClick = false;
            this.tagDelimiters = '';
            this.tagClass = function () { return undefined; };
            this.validationErrors = {};
            this.autocomplete = 'off';
            /**
             * @deprecated
             * Workaround for EL-3224 - No longer needed
             */
            this.trackAriaDescendant = true;
            this.tagAdding = new core.EventEmitter();
            this.tagAdded = new core.EventEmitter();
            this.tagInvalidated = new core.EventEmitter();
            this.tagRemoving = new core.EventEmitter();
            this.tagRemoved = new core.EventEmitter();
            this.tagClick = new core.EventEmitter();
            this.selectedIndex = -1;
            this.tagApi = {
                getTagDisplay: this.getTagDisplay.bind(this),
                removeTagAt: this.removeTagAt.bind(this),
                canRemoveTagAt: this.canRemoveTagAt.bind(this)
            };
            this.valid = true;
            this.inputValid = true;
            this._input = '';
            this._tags = [];
            this._onChangeHandler = function () { };
            this._onTouchedHandler = function () { };
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(TagInputComponent.prototype, "tags", {
            get: /**
             * @return {?}
             */ function () {
                if (!this._tags) {
                    this._tags = [];
                }
                return this._tags;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._tags = value;
                this._onChangeHandler(this._tags);
                this.tagsChange.emit(this._tags);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TagInputComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input = value;
                this.inputChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.tagTemplate) {
                    this.tagTemplate = this._defaultTagTemplate;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Watch for optional child typeahead control
                this.connectTypeahead(this.typeaheadQuery.first);
                this.typeaheadQuery.changes.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (query) { return _this.connectTypeahead(query.first); });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        TagInputComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes["disabled"]) {
                    if (changes["disabled"].currentValue) {
                        // Clear selection and close dropdown
                        this.selectedIndex = -1;
                        if (this.typeahead) {
                            this.typeahead.open = false;
                        }
                    }
                }
                // Update validation status
                this.validate();
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._subscription) {
                    this._subscription.unsubscribe();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TagInputComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.tags = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChangeHandler = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouchedHandler = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TagInputComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * Set focus on the input field.
         */
        /**
         * Set focus on the input field.
         * @return {?}
         */
        TagInputComponent.prototype.focus = /**
         * Set focus on the input field.
         * @return {?}
         */
            function () {
                if (this.tagInput) {
                    this.tagInput.nativeElement.focus();
                }
            };
        /**
         * Validate the value of the control (tags property).
         */
        /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
        TagInputComponent.prototype.validate = /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
            function () {
                this.valid = true;
                var /** @type {?} */ tagRangeError = null;
                if (this.tags && (this.tags.length < this.minTags || this.tags.length > this.maxTags)) {
                    tagRangeError = {
                        given: this.tags.length,
                        min: this.minTags,
                        max: this.maxTags
                    };
                    this.valid = false;
                }
                this.validationErrors['tagRangeError'] = tagRangeError;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.keyHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                // Get the input field cursor location
                var /** @type {?} */ inputCursorPos = this.tagInput.nativeElement.selectionStart;
                // Determine if the input field has any text selected
                var /** @type {?} */ hasSelection = this.tagInput.nativeElement.selectionStart !== this.tagInput.nativeElement.selectionEnd;
                // Determine if a tag has focus
                var /** @type {?} */ tagSelected = this.isValidTagIndex(this.selectedIndex);
                var /** @type {?} */ inputLength = this.input ? this.input.length : 0;
                // Check whether the arrow keys can move the selection. Otherwise the input field takes the event.
                var /** @type {?} */ canNavigateLeft = tagSelected || (inputCursorPos <= 0 && !hasSelection);
                var /** @type {?} */ canNavigateRight = tagSelected || (inputCursorPos >= inputLength && !hasSelection);
                // Forward key events to the typeahead component.
                this._typeaheadKeyService.handleKey(event, this.typeahead);
                switch (event.which) {
                    case keycodes.ENTER:
                        // Check if a typeahead option is highlighted
                        if (this.typeahead && this.typeahead.open && this.typeahead.highlighted) {
                            // Add the typeahead option as a tag, clear the input, and close the dropdown
                            this.commitTypeahead(this.typeahead.highlighted);
                            this.typeahead.open = false;
                        }
                        else {
                            // Validate and add the input text as a tag, if possible
                            this.commitInput();
                        }
                        event.preventDefault();
                        break;
                    case keycodes.BACKSPACE:
                        if (canNavigateLeft) {
                            this.backspace();
                            event.stopPropagation();
                            event.preventDefault();
                        }
                        break;
                    case keycodes.DELETE:
                        if (tagSelected) {
                            this.removeTagAt(this.selectedIndex);
                        }
                        break;
                    case keycodes.LEFT_ARROW:
                        if (canNavigateLeft) {
                            this.moveSelection(-1);
                            event.preventDefault();
                        }
                        break;
                    case keycodes.RIGHT_ARROW:
                        if (canNavigateRight) {
                            this.moveSelection(1);
                            event.preventDefault();
                        }
                        break;
                }
                // Check for keys in the tagDelimiters
                if (this.tagDelimiters && this.tagDelimiters.indexOf(this.getKeyChar(event)) >= 0) {
                    // Commit previous text
                    this.commitInput();
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.focusOutHandler = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // If a click on the typeahead is in progress, don't do anything.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.typeahead && this.typeahead.clicking) {
                    return;
                }
                // Close the dropdown on blur
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.selectedIndex = -1;
                        if (_this.typeahead) {
                            _this.typeahead.open = false;
                        }
                    }
                }, 200);
            };
        /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.tagClickHandler = /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
            function (event, tag, index) {
                if (this.disabled) {
                    return;
                }
                // Send tagClick event
                var /** @type {?} */ tagClickEvent = new TagInputEvent(tag);
                this.tagClick.emit(tagClickEvent);
                // Prevent focus if preventDefault() was called
                if (tagClickEvent.defaultPrevented()) {
                    event.preventDefault();
                    return;
                }
                // Select the tag (for IE that doesn't propagate focus)
                this.selectTagAt(index);
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputClickHandler = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                if (this.typeahead && this.showTypeaheadOnClick) {
                    this.typeahead.open = true;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputFocusHandler = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectInput();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.inputPasteHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                if (this.addOnPaste) {
                    // Get text from the clipboard
                    var /** @type {?} */ input = null;
                    if (event.clipboardData) {
                        input = event.clipboardData.getData('text/plain');
                    }
                    else if (((window)).clipboardData) {
                        // Internet Explorer only
                        input = ((window)).clipboardData.getData('Text');
                    }
                    // Commit the clipboard text directly
                    if (this.commit(input)) {
                        this.selectInput();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.typeaheadOptionSelectedHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                // When the typeahead sends the optionSelected event, commit the object directly
                this.commitTypeahead(event.option);
            };
        /**
         * Commit the current input value and clear the input field if successful.
         */
        /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
        TagInputComponent.prototype.commitInput = /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
            function () {
                if (this.commit(this.input)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given tag object and clear the input if successful.
         */
        /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.commitTypeahead = /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (this.addTag(tag)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         */
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.commit = /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
            function (input) {
                if (input && this.freeInput) {
                    // Split the tags by the tagDelimiters if configured
                    var /** @type {?} */ newTags = this.splitTagInput(input);
                    // Check tag validation for all of the individual values
                    var /** @type {?} */ allValid = true;
                    try {
                        for (var newTags_1 = __values(newTags), newTags_1_1 = newTags_1.next(); !newTags_1_1.done; newTags_1_1 = newTags_1.next()) {
                            var newTag = newTags_1_1.value;
                            var /** @type {?} */ valid = this.validateTag(newTag);
                            if (!valid) {
                                allValid = false;
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (newTags_1_1 && !newTags_1_1.done && (_a = newTags_1.return))
                                _a.call(newTags_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    // Add the tags if all are valid
                    if (allValid) {
                        try {
                            for (var newTags_2 = __values(newTags), newTags_2_1 = newTags_2.next(); !newTags_2_1.done; newTags_2_1 = newTags_2.next()) {
                                var newTag = newTags_2_1.value;
                                this.addTag(this.createTag(newTag));
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (newTags_2_1 && !newTags_2_1.done && (_b = newTags_2.return))
                                    _b.call(newTags_2);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                        return true;
                    }
                }
                return false;
                var e_1, _a, e_2, _b;
            };
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         */
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
        TagInputComponent.prototype.backspace = /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                if (!this.isValidTagIndex(this.selectedIndex)) {
                    this.selectTagAt(this.tags.length - 1);
                }
                else {
                    this.removeTagAt(this.selectedIndex);
                }
            };
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TagInputComponent.prototype.moveSelection = /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
            function (delta) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidSelectIndex(this.selectedIndex)) {
                    this.selectedIndex += delta;
                    // Do wrapping of selection when out of bounds
                    if (this.selectedIndex < 0) {
                        this.selectedIndex = this.tags.length;
                    }
                    else if (this.selectedIndex > this.tags.length) {
                        this.selectedIndex = 0;
                    }
                }
            };
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         */
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.getTagDisplay = /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (typeof this.display === 'function') {
                    return this.display(tag);
                }
                if (typeof this.display === 'string') {
                    return tag[(this.display)];
                }
                return tag;
            };
        /**
         * Returns true if the given index is selected (tag index or input field).
         */
        /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isSelected = /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index === this.selectedIndex;
            };
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         */
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.selectTagAt = /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidTagIndex(tagIndex)) {
                    this.selectedIndex = tagIndex;
                }
            };
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         */
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
        TagInputComponent.prototype.selectInput = /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectedIndex = this.tags.length;
            };
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         */
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.removeTagAt = /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                if (this.disabled || !this.canRemoveTagAt(tagIndex)) {
                    return;
                }
                // Check that the tagIndex is in range
                if (this.isValidTagIndex(tagIndex)) {
                    var /** @type {?} */ tag = this.tags[tagIndex];
                    var /** @type {?} */ tagRemovingEvent = new TagInputEvent(tag);
                    this.tagRemoving.emit(tagRemovingEvent);
                    if (!tagRemovingEvent.defaultPrevented()) {
                        // Select input first to avoid issues with dropping focus
                        this.selectInput();
                        // Remove the tag
                        this.tags.splice(tagIndex, 1);
                        // Set focus again since indices have changed
                        this.selectInput();
                        this.tagRemoved.emit(new TagInputEvent(tag));
                        this.validate();
                    }
                }
            };
        /**
         * Returns true if the tag at the given index can be removed.
         */
        /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.canRemoveTagAt = /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                return this.tags.length > this.minTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if the input field should be available.
         */
        /**
         * Returns true if the input field should be available.
         * @return {?}
         */
        TagInputComponent.prototype.isInputVisible = /**
         * Returns true if the input field should be available.
         * @return {?}
         */
            function () {
                return this.tags.length < this.maxTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if any part of the control has focus.
         */
        /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
        TagInputComponent.prototype.hasFocus = /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
            function () {
                return this.isValidSelectIndex(this.selectedIndex);
            };
        /**
         * @param {?} typeahead
         * @return {?}
         */
        TagInputComponent.prototype.connectTypeahead = /**
         * @param {?} typeahead
         * @return {?}
         */
            function (typeahead) {
                var _this = this;
                if (this._subscription) {
                    this._subscription.unsubscribe();
                    this._subscription = null;
                }
                this.typeahead = typeahead;
                if (this.typeahead) {
                    // Set up event handler for selected options
                    this._subscription = this.typeahead.optionSelected.subscribe(this.typeaheadOptionSelectedHandler.bind(this));
                    // Set up event handler for the highlighted element
                    // Added a delay to move it out of the current change detection cycle
                    this._subscription.add(this.typeahead.highlightedElementChange.pipe(tick())
                        .subscribe(function (element) { return _this.highlightedElement = element; }));
                }
            };
        /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.validateTag = /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
            function (tagValue) {
                var /** @type {?} */ inputPattern = null;
                this.inputValid = true;
                if (this.tagPattern && !this.tagPattern.test(tagValue)) {
                    inputPattern = {
                        given: tagValue,
                        pattern: this.tagPattern
                    };
                    this.inputValid = false;
                }
                this.validationErrors['inputPattern'] = inputPattern;
                return this.inputValid;
            };
        /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.createTag = /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
            function (tagValue) {
                var /** @type {?} */ tag = null;
                if (this.createTagHandler && typeof this.createTagHandler === 'function') {
                    tag = this.createTagHandler(tagValue);
                }
                else if (typeof this.display === 'string') {
                    tag = {};
                    tag[(this.display)] = tagValue;
                }
                else {
                    tag = tagValue;
                }
                return tag;
            };
        /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.addTag = /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (tag) {
                    // Verify that the new tag can be displayed
                    var /** @type {?} */ displayValue = this.getTagDisplay(tag);
                    if (displayValue && typeof displayValue === 'string' && displayValue.length > 0) {
                        var /** @type {?} */ tagAddingEvent = new TagInputEvent(tag);
                        this.tagAdding.emit(tagAddingEvent);
                        if (!tagAddingEvent.defaultPrevented()) {
                            this.tags = this.tags || [];
                            this.tags.push(tag);
                            this.tagAdded.emit(new TagInputEvent(tag));
                            this.validate();
                            return true;
                        }
                    }
                }
                return false;
            };
        /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.isValidTagIndex = /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                return tagIndex >= 0 && tagIndex < this.tags.length;
            };
        /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isValidSelectIndex = /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index >= 0 && index <= this.tags.length;
            };
        /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.getKeyChar = /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.which) {
                    case keycodes.SPACE:
                        return ' ';
                }
                return event.key;
            };
        /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.splitTagInput = /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
            function (input) {
                var /** @type {?} */ tagValues = [input];
                if (this.tagDelimiters && typeof this.tagDelimiters === 'string') {
                    var /** @type {?} */ escapedDelimiters = this.tagDelimiters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    var /** @type {?} */ delimiterRegex = new RegExp("[" + escapedDelimiters + "]", 'g');
                    tagValues = input.split(delimiterRegex).filter(function (s) { return s.length > 0; });
                }
                return tagValues;
            };
        TagInputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tag-input',
                        exportAs: 'ux-tag-input',
                        template: "<ol [attr.role]=\"typeahead ? 'combobox' : 'none'\" [attr.aria-haspopup]=\"typeahead ? 'listbox' : null\">\n    <li *ngFor=\"let tag of tags; let i = index\" class=\"ux-tag\"\n        [class.disabled]=\"disabled\"\n        [ngClass]=\"tagClass(tag, i, isSelected(i))\"\n        [attr.tabindex]=\"disabled ? null : 0\"\n        [focusIf]=\"isSelected(i)\"\n        (click)=\"tagClickHandler($event, tag, i)\"\n        (focus)=\"selectTagAt(i)\">\n\n        <ng-container [ngTemplateOutlet]=\"tagTemplate\"\n            [ngTemplateOutletContext]=\"{tag: tag, index: i, disabled: disabled, api: tagApi}\">\n        </ng-container>\n\n    </li>\n    <li *ngIf=\"isInputVisible()\" class=\"ux-tag-input\" role=\"none\">\n        <input #tagInput type=\"text\" [attr.id]=\"id\" class=\"ux-tag-input\"\n            [(ngModel)]=\"input\"\n            [autocomplete]=\"autocomplete\"\n            [class.invalid]=\"!inputValid\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            [attr.aria-autocomplete]=\"typeahead ? 'list' : 'none'\"\n            [attr.aria-controls]=\"typeahead?.id\"\n            aria-multiline=\"false\"\n            [placeholder]=\"disabled ? '' : (placeholder || '')\"\n            [disabled]=\"disabled\"\n            [focusIf]=\"isSelected(tags.length)\"\n            (click)=\"inputClickHandler()\"\n            (focus)=\"inputFocusHandler()\"\n            (paste)=\"inputPasteHandler($event)\">\n    </li>\n</ol>\n\n<ng-content #typeahead></ng-content>\n\n<ng-template #defaultTagTemplate let-tag=\"tag\" let-index=\"index\" let-disabled=\"disabled\" let-api=\"api\">\n    <span class=\"ux-tag-text\">{{api.getTagDisplay(tag)}}</span>\n    <button *ngIf=\"api.canRemoveTagAt(index)\"\n        type=\"button\"\n        class=\"ux-tag-remove\"\n        aria-label=\"Remove Item\"\n        [disabled]=\"disabled\"\n        (click)=\"api.removeTagAt(index); $event.stopPropagation();\">\n        <span class=\"hpe-icon hpe-close\"></span>\n    </button>\n</ng-template>",
                        providers: [TAGINPUT_VALUE_ACCESSOR, TAGINPUT_VALIDATOR],
                        host: {
                            '[class.disabled]': 'disabled',
                            '[class.focus]': 'hasFocus()',
                            '[class.invalid]': '!valid || !inputValid'
                        }
                    }] }
        ];
        /** @nocollapse */
        TagInputComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: TypeaheadKeyService }
            ];
        };
        TagInputComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            tags: [{ type: core.Input, args: ['tags',] }],
            tagsChange: [{ type: core.Output }],
            input: [{ type: core.Input, args: ['input',] }],
            inputChange: [{ type: core.Output }],
            display: [{ type: core.Input }],
            addOnPaste: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            enforceTagLimits: [{ type: core.Input }],
            freeInput: [{ type: core.Input }],
            maxTags: [{ type: core.Input }],
            minTags: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            showTypeaheadOnClick: [{ type: core.Input }],
            tagDelimiters: [{ type: core.Input }],
            tagPattern: [{ type: core.Input }],
            tagTemplate: [{ type: core.Input }],
            tagClass: [{ type: core.Input }],
            validationErrors: [{ type: core.Input }],
            autocomplete: [{ type: core.Input }],
            createTagHandler: [{ type: core.Input, args: ['createTag',] }],
            trackAriaDescendant: [{ type: core.Input }],
            tagAdding: [{ type: core.Output }],
            tagAdded: [{ type: core.Output }],
            tagInvalidated: [{ type: core.Output }],
            tagRemoving: [{ type: core.Output }],
            tagRemoved: [{ type: core.Output }],
            tagClick: [{ type: core.Output }],
            typeaheadQuery: [{ type: core.ContentChildren, args: [TypeaheadComponent,] }],
            tagInput: [{ type: core.ViewChild, args: ['tagInput',] }],
            _defaultTagTemplate: [{ type: core.ViewChild, args: ['defaultTagTemplate',] }],
            keyHandler: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            focusOutHandler: [{ type: core.HostListener, args: ['focusout',] }]
        };
        return TagInputComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputModule = (function () {
        function TagInputModule() {
        }
        TagInputModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            FocusIfModule,
                            TypeaheadModule
                        ],
                        exports: [TagInputComponent],
                        declarations: [TagInputComponent],
                        providers: [],
                    },] }
        ];
        return TagInputModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectModule = (function () {
        function SelectModule() {
        }
        SelectModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            InfiniteScrollModule,
                            TagInputModule,
                            TypeaheadModule
                        ],
                        exports: [SelectComponent],
                        declarations: [SelectComponent]
                    },] }
        ];
        return SelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BaseSearchComponent = (function () {
        function BaseSearchComponent(_searchBuilderService) {
            this._searchBuilderService = _searchBuilderService;
            this._id = this._searchBuilderService.generateComponentId();
            this._valid = true;
        }
        Object.defineProperty(BaseSearchComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "ux-search-builder-search-component-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "value", {
            /**
             * Get the current value of the component
             */
            get: /**
             * Get the current value of the component
             * @return {?}
             */ function () {
                return this.context.value;
            },
            /**
             * Set the current value of the component
             */
            set: /**
             * Set the current value of the component
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.context.value = value;
                this._searchBuilderService.queryHasChanged();
                // if value has been set perform validation
                this.validate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                this._searchBuilderService.setValid(this._id, valid);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Make sure we clean up after ourselves
         */
        /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
        BaseSearchComponent.prototype.ngOnDestroy = /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
            function () {
                this.valid = true;
            };
        /**
         * Perform any required validation on the value
         */
        /**
         * Perform any required validation on the value
         * @return {?}
         */
        BaseSearchComponent.prototype.validate = /**
         * Perform any required validation on the value
         * @return {?}
         */
            function () {
                // if a custom validation function has been provided then use it
                this.valid = this.config.validation ? this.config.validation(this, this.value) : true;
            };
        BaseSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-base-search',
                        template: ''
                    }] }
        ];
        /** @nocollapse */
        BaseSearchComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService }
            ];
        };
        return BaseSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateRangeComponent = (function (_super) {
        __extends(SearchDateRangeComponent, _super);
        function SearchDateRangeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date-range';
            return _this;
        }
        Object.defineProperty(SearchDateRangeComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "from", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.from) {
                    this.from = new Date();
                }
                // ensure that the from value is a date object
                if (this.value.from instanceof Date === false) {
                    this.value.from = new Date(this.value.from);
                }
                return this.value.from;
            },
            set: /**
             * @param {?} fromValue
             * @return {?}
             */ function (fromValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the from value is a date
                if (fromValue instanceof Date === false) {
                    fromValue = new Date(fromValue);
                }
                // set the latest value
                value.from = fromValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "to", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.to) {
                    this.to = new Date();
                }
                // ensure that the to value is a date object
                if (this.value.to instanceof Date === false) {
                    this.value.to = new Date(this.value.to);
                }
                return this.value.to;
            },
            set: /**
             * @param {?} toValue
             * @return {?}
             */ function (toValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the to value is a date
                if (toValue instanceof Date === false) {
                    toValue = new Date(toValue);
                }
                // set the latest value
                value.to = toValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromLabel || 'From';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toLabel || 'To';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Override the default validation
         */
        /**
         * Override the default validation
         * @return {?}
         */
        SearchDateRangeComponent.prototype.validate = /**
         * Override the default validation
         * @return {?}
         */
            function () {
                // check if there is a config validation function
                if (this.config.validation) {
                    return _super.prototype.validate.call(this);
                }
                // create copies of the dates so we can modify time value (to ignore it)
                var /** @type {?} */ from$$1 = new Date(this.value.from);
                var /** @type {?} */ to = new Date(this.value.to);
                // set the time to the same so we dont compare it
                from$$1.setHours(0, 0, 0, 0);
                to.setHours(0, 0, 0, 0);
                // valid if the from date is less than or equal to the to date
                this.valid = from$$1 <= to;
            };
        SearchDateRangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date-range',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"row\">\n    <div class=\"col-sm-12\">\n        <div class=\"form-inline\" [class.has-error]=\"!valid\">\n\n            <div class=\"form-group p-r-md\">\n                <label class=\"form-label m-r-xs\">{{ fromLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon p-r-xs\" tabindex=\"1\" (click)=\"fromPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #fromPopover=\"ux-popover\" [ngModel]=\"from | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"fromPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"fromPlaceholder\" [focusIf]=\"focus\">\n                </div>\n            </div>\n\n            <div class=\"form-group p-r-xs\">\n                <label class=\"form-label m-r-xs\">{{ toLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"toPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #toPopover=\"ux-popover\" [ngModel]=\"to | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"toPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"toPlaceholder\">\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n\n<ng-template #fromPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"from\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>\n\n<ng-template #toPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"to\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    }] }
        ];
        return SearchDateRangeComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateComponent = (function (_super) {
        __extends(SearchDateComponent, _super);
        function SearchDateComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date';
            return _this;
        }
        Object.defineProperty(SearchDateComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter date';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SearchDateComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // by default set to the current date if not specified
                if (!this.value) {
                    this.value = new Date();
                }
            };
        SearchDateComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"input-group date m-nil\">\n    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"popover.show()\">\n        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n    </span>\n    <input type=\"text\"\n        class=\"form-control\"\n        aria-label=\"Selected date\"\n        [placeholder]=\"placeholder\"\n        #popover=\"ux-popover\"\n        [ngModel]=\"value | date:'dd MMMM yyyy'\"\n        [uxPopover]=\"popoverTemplate\"\n        placement=\"bottom\"\n        popoverClass=\"date-time-picker-popover\"\n        [focusIf]=\"focus\">\n</div>\n\n<ng-template #popoverTemplate>\n    <ux-date-time-picker [(date)]=\"value\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    }] }
        ];
        return SearchDateComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchSelectComponent = (function (_super) {
        __extends(SearchSelectComponent, _super);
        function SearchSelectComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'select';
            return _this;
        }
        Object.defineProperty(SearchSelectComponent.prototype, "label", {
            /**
             * Provide defaults for undefined properties
             */
            get: /**
             * Provide defaults for undefined properties
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.options || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "multiple", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.multiple || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Select item';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "dropDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.dropDirection || 'down';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "allowNull", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.allowNull || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.disabled || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "maxHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.maxHeight || '250px';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "pageSize", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.pageSize || 20;
            },
            enumerable: true,
            configurable: true
        });
        SearchSelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-select',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<ux-select [(value)]=\"value\"\n           [options]=\"options\"\n           [multiple]=\"multiple\"\n           [placeholder]=\"placeholder\"\n           [dropDirection]=\"dropDirection\"\n           [pageSize]=\"pageSize\"\n           [allowNull]=\"allowNull\"\n           [disabled]=\"disabled\"\n           [maxHeight]=\"maxHeight\"\n           [key]=\"config.key\"\n           [display]=\"config.display\"\n           [loadingTemplate]=\"config.loadingTemplate\"\n           [optionTemplate]=\"config.optionTemplate\"\n           [noOptionsTemplate]=\"config.noOptionsTemplate\"\n           [focusIf]=\"focus\">\n</ux-select>"
                    }] }
        ];
        return SearchSelectComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchTextComponent = (function (_super) {
        __extends(SearchTextComponent, _super);
        function SearchTextComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'text';
            return _this;
        }
        Object.defineProperty(SearchTextComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchTextComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter text';
            },
            enumerable: true,
            configurable: true
        });
        SearchTextComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-text',
                        template: "<label *ngIf=\"label\" class=\"form-label\" [attr.for]=\"id\">{{ label }}</label>\n<input [attr.id]=\"id\" class=\"form-control\" [placeholder]=\"placeholder\" [(ngModel)]=\"value\" [focusIf]=\"focus\">"
                    }] }
        ];
        return SearchTextComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderModule = (function () {
        function SearchBuilderModule() {
        }
        SearchBuilderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            DateTimePickerModule,
                            FocusIfModule,
                            forms.FormsModule,
                            PopoverModule,
                            SelectModule,
                        ],
                        exports: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            BaseSearchComponent
                        ],
                        declarations: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchBuilderOutletDirective,
                            SearchSelectComponent,
                            BaseSearchComponent
                        ],
                        entryComponents: [
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchSelectComponent
                        ],
                        providers: [
                            SearchBuilderFocusService
                        ]
                    },] }
        ];
        return SearchBuilderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionStrategy = (function () {
        function SelectionStrategy(selectionService) {
            this.selectionService = selectionService;
        }
        /**
         * @param {?} selectionService
         * @return {?}
         */
        SelectionStrategy.prototype.setSelectionService = /**
         * @param {?} selectionService
         * @return {?}
         */
            function (selectionService) {
                this.selectionService = selectionService;
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.mousedown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.click = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * Select the item - default behavior
         */
        /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.select = /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).select.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Toggle the item's selected state - default behavior
         */
        /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.toggle = /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).toggle.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Deselect the item - default behavior
         */
        /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.deselect = /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).deselect.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Select all items - default behavior
         */
        /**
         * Select all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.selectAll = /**
         * Select all items - default behavior
         * @return {?}
         */
            function () {
                this.select.apply(this, __spread(this.selectionService.dataset));
            };
        /**
         * Deselect all items - default behavior
         */
        /**
         * Deselect all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.deselectAll = /**
         * Deselect all items - default behavior
         * @return {?}
         */
            function () {
                // call deselect on all items in the dataset
                this.selectionService.deselectAll();
            };
        /**
         * @return {?}
         */
        SelectionStrategy.prototype.destroy = /**
         * @return {?}
         */
            function () { };
        return SelectionStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowSelectionStrategy = (function (_super) {
        __extends(RowSelectionStrategy, _super);
        function RowSelectionStrategy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._selection = { start: null, end: null };
            return _this;
        }
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         */
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
        RowSelectionStrategy.prototype.mousedown = /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
            };
        /**
         * When a row is clicked we want to handle selection
         */
        /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.click = /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if the shift key is pressed we want to perform a multiple selection
                if (shiftKey) {
                    return this.multipleSelect(data);
                }
                // if the control key is pressed we want to perform an additive toggle selection
                if (ctrlKey) {
                    return this.toggle(data);
                }
                // perform a single selection where all other rows are deselected
                this.singleSelect(data);
            };
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         */
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.keydown = /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        this.navigate(event, data);
                        break;
                    case keycodes.SPACE:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data, true);
                        break;
                }
            };
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         */
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @param {?=} activate
         * @return {?}
         */
        RowSelectionStrategy.prototype.toggle = /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @param {?=} activate
         * @return {?}
         */
            function (data, activate) {
                if (activate === void 0) {
                    activate = false;
                }
                _super.prototype.toggle.call(this, data);
                // store or clear the selection
                this.selectionService.isSelected(data) ? this.setSelectionStart(data) : this.clearSelection();
                // if we want to keep the item activated then activate
                if (activate) {
                    this.selectionService.activate(data);
                }
            };
        /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.singleSelect = /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // deselect all other rows if neither modifier key is pressed
                this.deselectAll();
                // select the current row
                this.select(data);
                // store the current item as the selection start
                this.setSelectionStart(data);
            };
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         */
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.multipleSelect = /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // if no selection currently exists then perform initial selection
                if (!this._selection.start) {
                    // select the row
                    this.select(data);
                    // store the starting point
                    return this.setSelectionStart(data);
                }
                // if a multiple selection already took place - clear the previous selection
                if (this._selection.start && this._selection.end) {
                    this.deselect.apply(this, __spread(this.getSelectedItems()));
                }
                // set the new selection end point
                this.setSelectionEnd(data);
                // select all the items in the range
                this.select.apply(this, __spread(this.getSelectedItems()));
            };
        /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionStart = /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._selection.start = data;
                this._selection.end = null;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionEnd = /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._selection.end = data;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Clear both start and end selection points
         */
        /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
        RowSelectionStrategy.prototype.clearSelection = /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
            function (deactivate) {
                if (deactivate === void 0) {
                    deactivate = true;
                }
                // reset the selected item
                this._selection = { start: null, end: null };
                // remove the current active item
                if (deactivate) {
                    this.selectionService.deactivate();
                }
            };
        /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
        RowSelectionStrategy.prototype.getSelectedItems = /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
            function () {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                var /** @type {?} */ startIdx = dataset.indexOf(this._selection.start);
                var /** @type {?} */ endIdx = dataset.indexOf(this._selection.end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.navigate = /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                // activate the sibling - if the up arrow is pressed then navigate to the previous sibling
                var /** @type {?} */ sibling = this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
                // if the shift key is pressed then we also want to toggle the state if the item
                if (shiftKey && sibling) {
                    // if there is no current selection start then select the current row
                    if (!this._selection.start) {
                        this.multipleSelect(data);
                    }
                    this.multipleSelect(sibling);
                }
            };
        return RowSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowAltSelectionStrategy = (function (_super) {
        __extends(RowAltSelectionStrategy, _super);
        function RowAltSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        this.handleCursorKey(event, data);
                        break;
                    case keycodes.SPACE:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data);
                        break;
                }
            };
        /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.handleCursorKey = /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                if (ctrlKey) {
                    this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
                }
                else {
                    var /** @type {?} */ sibling = this.selectionService.getSibling(event.which === keycodes.UP_ARROW);
                    this.multipleSelect(sibling ? sibling : data);
                }
            };
        return RowAltSelectionStrategy;
    }(RowSelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SimpleSelectionStrategy = (function (_super) {
        __extends(SimpleSelectionStrategy, _super);
        function SimpleSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * When the item is clicked simply toggle the current selected state
         */
        /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.click = /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
            function (_event, data) {
                this.toggle(data);
            };
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         */
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.keydown = /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        event.preventDefault();
                        return this.selectionService.activateSibling(true);
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        return this.selectionService.activateSibling(false);
                    case keycodes.SPACE:
                        event.preventDefault();
                        return this.toggle(data);
                }
            };
        /**
         * Override the standard toggle function to always activate the item
         */
        /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.toggle = /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                _super.prototype.toggle.call(this, data);
                this.selectionService.activate(data);
            };
        return SimpleSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionService = (function () {
        function SelectionService() {
            this.strategy = new SimpleSelectionStrategy(this);
            this.isEnabled = true;
            this.isClickEnabled = true;
            this.isKeyboardEnabled = true;
            this.focus$ = new BehaviorSubject.BehaviorSubject(null);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.selection$ = new BehaviorSubject.BehaviorSubject([]);
            this._dataset = [];
            this._selection = new Set();
            this._strategyToDestroy = this.strategy;
        }
        Object.defineProperty(SelectionService.prototype, "dataset", {
            get: /**
             * @return {?}
             */ function () {
                return this._dataset;
            },
            set: /**
             * @param {?} dataset
             * @return {?}
             */ function (dataset) {
                this._dataset = dataset;
                if (this._dataset.indexOf(this._active) === -1) {
                    this.setFirstItemFocusable();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._strategyToDestroy) {
                    this._strategyToDestroy.destroy();
                }
            };
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         */
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.select = /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // add each selection to the set
                selections.forEach(function (selection) { return _this._selection.add(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Remove an item from the list of selected items
         */
        /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.deselect = /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // remove each item from the set
                selections.forEach(function (selection) { return _this._selection.delete(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Remove all items from the list of selected items
         */
        /**
         * Remove all items from the list of selected items
         * @return {?}
         */
        SelectionService.prototype.deselectAll = /**
         * Remove all items from the list of selected items
         * @return {?}
         */
            function () {
                // remove all items in the array
                this.deselect.apply(this, __spread(this._dataset));
                // clear the set in case any items have been removed from the DOM but are still selected
                this._selection.clear();
            };
        /**
         * Toggle the selected state of any specified items
         */
        /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.toggle = /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                selections.forEach(function (selection) { return _this.isSelected(selection) ? _this.deselect(selection) : _this.select(selection); });
            };
        /**
         * Determine whether or not a specific item is currently selected
         */
        /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.isSelected = /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return this._selection.has(data);
            };
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         */
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.getSelectionState = /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var _this = this;
                return this.selection$.pipe(operators.map(function () { return _this.isSelected(data); }), operators.distinctUntilChanged());
            };
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         */
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
        SelectionService.prototype.setStrategy = /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                if (this._strategyToDestroy) {
                    // Destroy previous strategy if it was created internally
                    this._strategyToDestroy.destroy();
                    this._strategyToDestroy = null;
                }
                if (mode instanceof SelectionStrategy) {
                    // Custom strategy - pass in the service instance
                    this.strategy = mode;
                    this.strategy.setSelectionService(this);
                }
                else {
                    switch (mode.toLowerCase().trim()) {
                        case 'simple':
                            this.strategy = this._strategyToDestroy = new SimpleSelectionStrategy(this);
                            break;
                        case 'row':
                            this.strategy = this._strategyToDestroy = new RowSelectionStrategy(this);
                            break;
                        case 'row-alt':
                            this.strategy = this._strategyToDestroy = new RowAltSelectionStrategy(this);
                            break;
                        default:
                            throw new Error("The selection mode '" + mode + "' does not exist. Valid modes are 'simple', 'row', or 'row-alt'.");
                    }
                }
            };
        /**
         * Set the current active item
         */
        /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.activate = /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._active = data;
                this.active$.next(this._active);
            };
        /**
         * Deactive all items
         */
        /**
         * Deactive all items
         * @return {?}
         */
        SelectionService.prototype.deactivate = /**
         * Deactive all items
         * @return {?}
         */
            function () {
                this._active = null;
                this.active$.next(this._active);
            };
        /**
         * Return the next or previous sibling of the current active item.
         * @param previous If true, the previous sibling will be returned.
         */
        /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
        SelectionService.prototype.getSibling = /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                // check if there is a current active item
                if (!this._active) {
                    return;
                }
                // get the index of the current item
                var /** @type {?} */ idx = this.dataset.indexOf(this._active);
                var /** @type {?} */ target = this.dataset[previous ? idx - 1 : idx + 1];
                return target;
            };
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         */
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
        SelectionService.prototype.activateSibling = /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                var /** @type {?} */ target = this.getSibling(previous);
                // check if the target exists
                if (target) {
                    this.activate(target);
                }
                return target;
            };
        /**
         * @param {?} disabled
         * @return {?}
         */
        SelectionService.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
            function (disabled) {
                // store the current disabled state
                this.isEnabled = !disabled;
                // clear any stateful data
                this._active = null;
                this.active$.next(this._active);
                this._selection.clear();
                // emit the selection change information
                this.selectionHasMutated();
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.selectionHasMutated = /**
         * @return {?}
         */
            function () {
                this.selection$.next(Array.from(this._selection));
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.setFirstItemFocusable = /**
         * @return {?}
         */
            function () {
                if (this._dataset.length > 0) {
                    this.focus$.next(this._dataset[0]);
                    this._active = this._dataset[0];
                }
                else {
                    this._active = null;
                }
            };
        SelectionService.decorators = [
            { type: core.Injectable }
        ];
        return SelectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectListItemComponent = (function () {
        function SelectListItemComponent(_selection, elementRef) {
            var _this = this;
            this._selection = _selection;
            this.tabindex = -1;
            this._onDestroy = new Subject.Subject();
            _selection.active$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (data) { return data === _this.data; })).subscribe(function (active) {
                _selection.focus$.next(active);
                elementRef.nativeElement.focus();
            });
            // make this item tabbable or not based on the focused element
            _selection.focus$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (focused) { return _this.tabindex = focused === _this.data ? 0 : -1; });
        }
        Object.defineProperty(SelectListItemComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selection.isSelected(this.data);
            },
            set: /**
             * @param {?} isSelected
             * @return {?}
             */ function (isSelected) {
                isSelected ? this._selection.select(this.data) : this._selection.deselect(this.data);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectListItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onMouseDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.mousedown(event, this.data);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.click(event, this.data);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.keydown(event, this.data);
            };
        SelectListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select-list-item',
                        template: "<ng-content></ng-content>",
                        host: {
                            role: 'listitem'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectListItemComponent.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: core.ElementRef }
            ];
        };
        SelectListItemComponent.propDecorators = {
            data: [{ type: core.Input }],
            tabindex: [{ type: core.HostBinding, args: ['tabindex',] }],
            selected: [{ type: core.HostBinding, args: ['class.selected',] }, { type: core.HostBinding, args: ['attr.aria-selected',] }],
            onMouseDown: [{ type: core.HostListener, args: ['mousedown', ['$event'],] }],
            onClick: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return SelectListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MultipleSelectListStrategy = (function (_super) {
        __extends(MultipleSelectListStrategy, _super);
        function MultipleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** Prevent the browser from highlighting text on shift click */
        /**
         * Prevent the browser from highlighting text on shift click
         * @param {?} event
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.mousedown = /**
         * Prevent the browser from highlighting text on shift click
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.click = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // activate the clicked item
                this.selectionService.activate(data);
                // if the shift key is pressed we want to perform a multiple selection
                if (event.shiftKey) {
                    return this.multipleSelect(data);
                }
                // otherwise perform a single toggle selection
                if (this.selectionService.isSelected(data)) {
                    this.deselect(data);
                    this._lastSelection = null;
                }
                else {
                    this.select(data);
                    this._lastSelection = data;
                }
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW: {
                        event.preventDefault();
                        var /** @type {?} */ sibling = this.selectionService.activateSibling(true);
                        if (event.shiftKey) {
                            this.select(data, sibling);
                            this._lastSelection = sibling;
                        }
                        break;
                    }
                    case keycodes.DOWN_ARROW: {
                        event.preventDefault();
                        var /** @type {?} */ sibling = this.selectionService.activateSibling(false);
                        if (event.shiftKey) {
                            this.select(data, sibling);
                            this._lastSelection = sibling;
                        }
                        break;
                    }
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        event.preventDefault();
                        this.toggle(data);
                        this._lastSelection = this.selectionService.isSelected(data) ? data : null;
                        break;
                }
            };
        /**
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.multipleSelect = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // if there is no start item selected
                if (!this._lastSelection) {
                    this.select(data);
                    return this._lastSelection = data;
                }
                // if there already is a start item then find the items in the range
                this.select.apply(this, __spread(this.getSelectedItems(this._lastSelection, data)));
                // store the selection end point
                this._lastSelection = data;
            };
        /**
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.getSelectedItems = /**
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
            function (start, end) {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                var /** @type {?} */ startIdx = dataset.indexOf(start);
                var /** @type {?} */ endIdx = dataset.indexOf(end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        return MultipleSelectListStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SingleSelectListStrategy = (function (_super) {
        __extends(SingleSelectListStrategy, _super);
        function SingleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
        SingleSelectListStrategy.prototype.click = /**
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
            function (_event, data) {
                if (!this.selectionService.isSelected(data)) {
                    // deselect all other items
                    this.deselectAll();
                }
                // activate the clicked item
                this.selectionService.activate(data);
                // toggle the selected state of the item
                this.toggle(data);
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SingleSelectListStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW: {
                        event.preventDefault();
                        this.selectionService.activateSibling(true);
                        break;
                    }
                    case keycodes.DOWN_ARROW: {
                        event.preventDefault();
                        this.selectionService.activateSibling(false);
                        break;
                    }
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        event.preventDefault();
                        this.click(null, data);
                        break;
                }
            };
        return SingleSelectListStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectListComponent = (function () {
        function SelectListComponent(_selection) {
            var _this = this;
            this._selection = _selection;
            this.selected = [];
            this.selectedChange = new core.EventEmitter();
            // set the selection strategy to single by default
            this._selection.setStrategy(new SingleSelectListStrategy());
            // emit the selection changes when they occur
            this._subscription = this._selection.selection$.subscribe(function (selection) { return _this.selectedChange.emit(selection); });
        }
        Object.defineProperty(SelectListComponent.prototype, "multiple", {
            set: /**
             * @param {?} multiple
             * @return {?}
             */ function (multiple) {
                this._selection.strategy.deselectAll();
                this._selection.setStrategy(multiple ? new MultipleSelectListStrategy() : new SingleSelectListStrategy());
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // supply the initial item set
                this._selection.dataset = this.items.map(function (item) { return item.data; });
                // if the item set changes update the list
                this.items.changes.subscribe(function () { return _this._selection.dataset = _this.items.map(function (item) { return item.data; }); });
            };
        /**
         * @return {?}
         */
        SelectListComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        SelectListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select-list',
                        template: "<ng-content></ng-content>",
                        providers: [SelectionService],
                        host: {
                            role: 'list'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectListComponent.ctorParameters = function () {
            return [
                { type: SelectionService }
            ];
        };
        SelectListComponent.propDecorators = {
            multiple: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            items: [{ type: core.ContentChildren, args: [SelectListItemComponent,] }]
        };
        return SelectListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectListModule = (function () {
        function SelectListModule() {
        }
        SelectListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SelectListComponent,
                            SelectListItemComponent
                        ],
                        exports: [
                            SelectListComponent,
                            SelectListItemComponent
                        ],
                    },] }
        ];
        return SelectListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelCloseDirective = (function () {
        function SidePanelCloseDirective(_service) {
            this._service = _service;
        }
        /**
         * @return {?}
         */
        SidePanelCloseDirective.prototype.clickHandler = /**
         * @return {?}
         */
            function () {
                this._service.close();
            };
        SidePanelCloseDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSidePanelClose]'
                    },] }
        ];
        /** @nocollapse */
        SidePanelCloseDirective.ctorParameters = function () {
            return [
                { type: SidePanelService }
            ];
        };
        SidePanelCloseDirective.propDecorators = {
            clickHandler: [{ type: core.HostListener, args: ['click',] }]
        };
        return SidePanelCloseDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS$1 = [
        SidePanelComponent,
        SidePanelCloseDirective
    ];
    var SidePanelModule = (function () {
        function SidePanelModule() {
        }
        SidePanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            a11y.A11yModule,
                            FocusIfModule
                        ],
                        exports: EXPORTS$1,
                        declarations: EXPORTS$1
                    },] }
        ];
        return SidePanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkComponent = (function () {
        function SparkComponent(_colorService) {
            this._colorService = _colorService;
            this.values = [];
            this.barHeight = 10;
            this._theme = 'primary';
            this._barColor = [];
        }
        Object.defineProperty(SparkComponent.prototype, "theme", {
            get: /**
             * @return {?}
             */ function () {
                return this._theme;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._theme = this._colorService.resolveColorName(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "trackColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._trackColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._trackColor = this._colorService.resolve(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "barColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._barColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (Array.isArray(value)) {
                    this._barColor = value.map(function (color) { return _this._colorService.resolve(color); });
                }
                else {
                    this._barColor = [this._colorService.resolve(value)];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.values;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // ensure 'value' is an array at this point
                var /** @type {?} */ values = Array.isArray(value) ? value : [value];
                // get the total value of all lines
                var /** @type {?} */ total = Math.max(values.reduce(function (previous, current) { return previous + current; }, 0), 100);
                // figure out the percentages for each spark line
                this.values = values.map(function (val) { return (val / total) * 100; });
            },
            enumerable: true,
            configurable: true
        });
        SparkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spark',
                        template: "<!-- Inline Spark Chart -->\n<div *ngIf=\"inlineLabel\" class=\"ux-spark-inline-label-container\">\n\n    <div class=\"ux-spark-inline-label-left\" [innerHtml]=\"inlineLabel\"></div>\n\n    <div class=\"ux-spark-line\">\n\n        <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n            <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n            <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n        </div>\n\n        <div class=\"ux-spark ux-inline ux-spark-theme-{{theme}}\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\" [uxTooltip]=\"tooltip\">\n            <div class=\"ux-spark-bar\" *ngFor=\"let line of values; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n        </div>\n\n        <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n            <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n            <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n        </div>\n\n    </div>\n</div>\n\n<!-- End Inline Spark Chart -->\n\n\n<!-- Non Inline Spark Chart -->\n<div *ngIf=\"!inlineLabel\">\n\n    <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n        <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n        <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n    </div>\n\n    <div class=\"ux-spark ux-spark-theme-{{theme}}\" [class.ux-spark-multi-value]=\"values.length > 1\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\"\n        [uxTooltip]=\"tooltip\">\n        <div class=\"ux-spark-bar\" *ngFor=\"let line of value; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n    </div>\n\n    <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n        <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n        <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n    </div>\n</div>\n\n<!-- End Non Inline Spark Chart -->",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SparkComponent.ctorParameters = function () {
            return [
                { type: ColorService }
            ];
        };
        SparkComponent.propDecorators = {
            barHeight: [{ type: core.Input }],
            inlineLabel: [{ type: core.Input }],
            topLeftLabel: [{ type: core.Input }],
            topRightLabel: [{ type: core.Input }],
            bottomLeftLabel: [{ type: core.Input }],
            bottomRightLabel: [{ type: core.Input }],
            tooltip: [{ type: core.Input }],
            theme: [{ type: core.Input }],
            trackColor: [{ type: core.Input }],
            barColor: [{ type: core.Input }],
            value: [{ type: core.Input }]
        };
        return SparkComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkModule = (function () {
        function SparkModule() {
        }
        SparkModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            TooltipModule
                        ],
                        exports: [SparkComponent],
                        declarations: [SparkComponent]
                    },] }
        ];
        return SparkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizableTableService = (function () {
        function ResizableTableService() {
            /**
             * Indicate when the columns are ready
             */
            this.isInitialised = new BehaviorSubject.BehaviorSubject(false);
            /**
             * Determine if we are currently resizing
             */
            this.isResizing = false;
            /**
             * Store the percentage widths of each column
             */
            this.columns = [];
            /**
             * Store the current width of the table
             */
            this.tableWidth = 0;
        }
        /** Store the size of each column */
        /**
         * Store the size of each column
         * @param {?} columns
         * @return {?}
         */
        ResizableTableService.prototype.setColumns = /**
         * Store the size of each column
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                // store the current columns
                this._columns = columns;
                // store the sizes
                this.columns = columns.map(function (column) { return (column.getNaturalWidth() / _this.tableWidth) * 100; });
                // indicate we are now initialised
                if (this.isInitialised.value === false) {
                    this.isInitialised.next(true);
                }
            };
        /** Update the resizing state */
        /**
         * Update the resizing state
         * @param {?} isResizing
         * @return {?}
         */
        ResizableTableService.prototype.setResizing = /**
         * Update the resizing state
         * @param {?} isResizing
         * @return {?}
         */
            function (isResizing) {
                this.isResizing = isResizing;
            };
        /** Get the width of a column in a specific unit */
        /**
         * Get the width of a column in a specific unit
         * @param {?} index
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
        ResizableTableService.prototype.getColumnWidth = /**
         * Get the width of a column in a specific unit
         * @param {?} index
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
            function (index, unit, columns) {
                if (columns === void 0) {
                    columns = this.columns;
                }
                switch (unit) {
                    case ColumnUnit.Percentage:
                        return columns[index];
                    case ColumnUnit.Pixel:
                        return (this.tableWidth / 100) * columns[index];
                }
            };
        /** Allow setting the column size in any unit */
        /**
         * Allow setting the column size in any unit
         * @param {?} index
         * @param {?} value
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
        ResizableTableService.prototype.setColumnWidth = /**
         * Allow setting the column size in any unit
         * @param {?} index
         * @param {?} value
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
            function (index, value, unit, columns) {
                if (columns === void 0) {
                    columns = this.columns;
                }
                // create a new array so we keep the instance array immutable
                var /** @type {?} */ sizes = __spread(columns);
                switch (unit) {
                    case ColumnUnit.Percentage:
                        sizes[index] = value;
                        break;
                    case ColumnUnit.Pixel:
                        sizes[index] = (value / this.tableWidth) * 100;
                        break;
                }
                // update the instance variable
                return sizes;
            };
        /** Resize a column by a specific pixel amount */
        /**
         * Resize a column by a specific pixel amount
         * @param {?} index
         * @param {?} delta
         * @return {?}
         */
        ResizableTableService.prototype.resizeColumn = /**
         * Resize a column by a specific pixel amount
         * @param {?} index
         * @param {?} delta
         * @return {?}
         */
            function (index, delta) {
                // get the sibling column that will also be resized
                var /** @type {?} */ sibling = this.getSiblingColumn(index);
                // if there is no sibling that can be resized then stop here
                if (!sibling) {
                    return;
                }
                // create a new array for the sizes
                var /** @type {?} */ columns = (__spread(this.columns));
                // resize the column to the desired size
                columns = /** @type {?} */ (this.setColumnWidth(index, Math.round(this.getColumnWidth(index, ColumnUnit.Pixel) + delta), ColumnUnit.Pixel, columns));
                columns = /** @type {?} */ (this.setColumnWidth(sibling, Math.round(this.getColumnWidth(sibling, ColumnUnit.Pixel) - delta), ColumnUnit.Pixel, columns));
                // if the move is not possible then stop here
                if (!this.isWidthValid(index, this.getColumnWidth(index, ColumnUnit.Pixel, columns)) || !this.isWidthValid(sibling, this.getColumnWidth(sibling, ColumnUnit.Pixel, columns))) {
                    return;
                }
                // check that we add up to exactly 100%
                var /** @type {?} */ total = columns.reduce(function (count, column) { return column + count; }, 0);
                // if the columns to not add to 100 ensure we make them
                if (total !== 100) {
                    columns[index] += (100 - total);
                }
                // store the new sizes
                this.columns = columns;
            };
        /**
         * Determine whether a column is above or below its minimum width
         * @param {?} index
         * @param {?} width
         * @return {?}
         */
        ResizableTableService.prototype.isWidthValid = /**
         * Determine whether a column is above or below its minimum width
         * @param {?} index
         * @param {?} width
         * @return {?}
         */
            function (index, width) {
                // get the column at a given position
                var /** @type {?} */ column = this.getColumnInstance(index);
                // determine if the specified width is greater than the min width
                return column && width >= column.minWidth;
            };
        /**
         * Get the next column in the sequence of columns
         * @param {?} index
         * @return {?}
         */
        ResizableTableService.prototype.getSiblingColumn = /**
         * Get the next column in the sequence of columns
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // find the first sibling that is not disabled
                for (var /** @type {?} */ idx = index + 1; idx < this.columns.length; idx++) {
                    var /** @type {?} */ sibling = this.getColumnInstance(idx);
                    if (!sibling || !sibling.disabled) {
                        return idx;
                    }
                }
                return null;
            };
        /**
         * Get the column class from our query list
         * @param {?} index
         * @return {?}
         */
        ResizableTableService.prototype.getColumnInstance = /**
         * Get the column class from our query list
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this._columns ? this._columns.toArray()[index] : null;
            };
        ResizableTableService.decorators = [
            { type: core.Injectable }
        ];
        return ResizableTableService;
    }());
    /** @enum {number} */
    var ColumnUnit = {
        Pixel: 0,
        Percentage: 1,
    };
    ColumnUnit[ColumnUnit.Pixel] = "Pixel";
    ColumnUnit[ColumnUnit.Percentage] = "Percentage";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizableTableCellDirective = (function () {
        function ResizableTableCellDirective(_elementRef, _table) {
            this._elementRef = _elementRef;
            this._table = _table;
        }
        Object.defineProperty(ResizableTableCellDirective.prototype, "width", {
            /** The percentage width of the column */
            get: /**
             * The percentage width of the column
             * @return {?}
             */ function () {
                return this._table.isResizing ?
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit.Pixel) + "px" :
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit.Percentage) + "%";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizableTableCellDirective.prototype, "flex", {
            /** The flex width of the column */
            get: /**
             * The flex width of the column
             * @return {?}
             */ function () {
                // if we are resizing then always return 'none' to allow free movement
                if (this._table.isResizing) {
                    return 'none';
                }
                return this._table.isInitialised.value ? "0 1 " + this._table.getColumnWidth(this.getCellIndex(), ColumnUnit.Percentage) + "%" : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get the column index this cell is part of
         * @return {?}
         */
        ResizableTableCellDirective.prototype.getCellIndex = /**
         * Get the column index this cell is part of
         * @return {?}
         */
            function () {
                return ((this._elementRef.nativeElement)).cellIndex;
            };
        ResizableTableCellDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxResizableTableCell]'
                    },] }
        ];
        /** @nocollapse */
        ResizableTableCellDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizableTableService }
            ];
        };
        ResizableTableCellDirective.propDecorators = {
            width: [{ type: core.HostBinding, args: ['style.width',] }],
            flex: [{ type: core.HostBinding, args: ['style.flex',] }]
        };
        return ResizableTableCellDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizableTableColumnComponent = (function () {
        function ResizableTableColumnComponent(_elementRef, _table) {
            this._elementRef = _elementRef;
            this._table = _table;
            /**
             * Disabled the column resizing
             */
            this.disabled = false;
        }
        Object.defineProperty(ResizableTableColumnComponent.prototype, "width", {
            /** The percentage width of the column */
            get: /**
             * The percentage width of the column
             * @return {?}
             */ function () {
                if (!this._table.isInitialised.value) {
                    return;
                }
                return this._table.isResizing ?
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit.Pixel) + "px" :
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit.Percentage) + "%";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizableTableColumnComponent.prototype, "flex", {
            /** The flex width of the column */
            get: /**
             * The flex width of the column
             * @return {?}
             */ function () {
                // if we are resizing then always return 'none' to allow free movement
                if (this._table.isResizing) {
                    return 'none';
                }
                return this._table.isInitialised.value ? "0 1 " + this._table.getColumnWidth(this.getCellIndex(), ColumnUnit.Percentage) + "%" : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizableTableColumnComponent.prototype, "minWidth", {
            /** Get the minimum width allowed by the column */
            get: /**
             * Get the minimum width allowed by the column
             * @return {?}
             */ function () {
                // determine the minimum width of the column based on its computed CSS value
                var /** @type {?} */ computed = parseFloat(getComputedStyle(this._elementRef.nativeElement).minWidth);
                // if it is disabled use its current width - otherwise use its CSS min width if it is valid
                return this.disabled ? this._elementRef.nativeElement.offsetWidth : isNaN(computed) ? 0 : computed;
            },
            enumerable: true,
            configurable: true
        });
        /** Get the natural pixel width of the column */
        /**
         * Get the natural pixel width of the column
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.getNaturalWidth = /**
         * Get the natural pixel width of the column
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement.offsetWidth;
            };
        /** When the dragging starts */
        /**
         * When the dragging starts
         * @param {?} event
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onDragStart = /**
         * When the dragging starts
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // determine the mouse position within the handle
                this._offset = event.clientX - ((event.target)).getBoundingClientRect().left;
            };
        /** When the mouse is moved */
        /**
         * When the mouse is moved
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onDragMove = /**
         * When the mouse is moved
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
            function (event, handle) {
                // get the current mouse position
                var /** @type {?} */ mouseX = event.pageX - pageXOffset;
                // position of the drag handle
                var left = handle.getBoundingClientRect().left;
                // determine how much the mouse has moved since the last update
                var /** @type {?} */ delta = mouseX - (left + this._offset);
                // perform resizing
                this._table.resizeColumn(this.getCellIndex(), delta);
                this._table.setResizing(true);
            };
        /** When the dragging ends */
        /**
         * When the dragging ends
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onDragEnd = /**
         * When the dragging ends
         * @return {?}
         */
            function () {
                this._table.setResizing(false);
            };
        /**
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onMoveLeft = /**
         * @return {?}
         */
            function () {
                this._table.resizeColumn(this.getCellIndex(), -10);
            };
        /**
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onMoveRight = /**
         * @return {?}
         */
            function () {
                this._table.resizeColumn(this.getCellIndex(), 10);
            };
        /**
         * Get the column index this cell is part of
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.getCellIndex = /**
         * Get the column index this cell is part of
         * @return {?}
         */
            function () {
                return ((this._elementRef.nativeElement)).cellIndex;
            };
        ResizableTableColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: '[uxResizableTableColumn]',
                        template: "<ng-content></ng-content>\n\n<div #handle\n     uxDrag\n     cdkMonitorElementFocus\n     tabindex=\"0\"\n     aria-label=\"Column resize handle. Use arrow keys to change the column width.\"\n     class=\"ux-resizable-table-column-handle\"\n     *ngIf=\"!disabled\"\n     (onDragStart)=\"onDragStart($event)\"\n     (onDrag)=\"onDragMove($event, handle)\"\n     (onDragEnd)=\"onDragEnd()\"\n     (keydown.ArrowLeft)=\"onMoveLeft()\"\n     (keydown.ArrowRight)=\"onMoveRight()\">\n\n     <div class=\"ux-resizable-table-column-handle-icon\"></div>\n</div>\n",
                        host: {
                            class: 'ux-resizable-table-column'
                        }
                    }] }
        ];
        /** @nocollapse */
        ResizableTableColumnComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizableTableService }
            ];
        };
        ResizableTableColumnComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            width: [{ type: core.HostBinding, args: ['style.width',] }],
            flex: [{ type: core.HostBinding, args: ['style.flex',] }]
        };
        return ResizableTableColumnComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizableTableDirective = (function () {
        function ResizableTableDirective(_elementRef, _table, resize) {
            var _this = this;
            this._elementRef = _elementRef;
            this._table = _table;
            /**
             * Unsubscribe from the observables
             */
            this._onDestroy = new Subject.Subject();
            // watch for the table being resized
            resize.addResizeListener(this._elementRef.nativeElement)
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (dimensions) { return _table.tableWidth = _this.getScrollWidth(); });
        }
        /** Once we have the columns make them resizable and watch for changes to columns */
        /**
         * Once we have the columns make them resizable and watch for changes to columns
         * @return {?}
         */
        ResizableTableDirective.prototype.ngAfterViewInit = /**
         * Once we have the columns make them resizable and watch for changes to columns
         * @return {?}
         */
            function () {
                var _this = this;
                // ensure we initially set the table width
                this._table.tableWidth = this.getScrollWidth();
                // set the columns - prevent expression changed error
                requestAnimationFrame(function () { return _this._table.setColumns(_this.columns); });
                // watch for any future changes to the columns
                this.columns.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this._table.setColumns(_this.columns); });
            };
        /** Cleanup after the component is destroyed */
        /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
        ResizableTableDirective.prototype.ngOnDestroy = /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Get the smallest tbody width taking into account scrollbars (uxFixedHeaderTable)
         * @return {?}
         */
        ResizableTableDirective.prototype.getScrollWidth = /**
         * Get the smallest tbody width taking into account scrollbars (uxFixedHeaderTable)
         * @return {?}
         */
            function () {
                return Array.from(((this._elementRef.nativeElement)).tBodies)
                    .reduce(function (width, tbody) { return Math.min(width, tbody.scrollWidth); }, ((this._elementRef.nativeElement)).offsetWidth);
            };
        ResizableTableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxResizableTable]',
                        providers: [ResizableTableService],
                        host: {
                            class: 'ux-resizable-table'
                        }
                    },] }
        ];
        /** @nocollapse */
        ResizableTableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizableTableService },
                { type: ResizeService }
            ];
        };
        ResizableTableDirective.propDecorators = {
            columns: [{ type: core.ContentChildren, args: [ResizableTableColumnComponent, { descendants: true },] }]
        };
        return ResizableTableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TableModule = (function () {
        function TableModule() {
        }
        TableModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            DragModule,
                            ResizeModule,
                            a11y.A11yModule
                        ],
                        declarations: [
                            ResizableTableDirective,
                            ResizableTableColumnComponent,
                            ResizableTableCellDirective
                        ],
                        exports: [
                            ResizableTableDirective,
                            ResizableTableColumnComponent,
                            ResizableTableCellDirective
                        ]
                    },] }
        ];
        return TableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineComponent = (function () {
        function TimelineComponent() {
        }
        TimelineComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline',
                        template: "<div class=\"timeline\">\r\n    <ng-content></ng-content>\r\n</div>\r\n"
                    }] }
        ];
        return TimelineComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$9 = 0;
    var TimelineEventComponent = (function () {
        function TimelineEventComponent() {
            this.id = "ux-timeline-event-" + uniqueId$9++;
        }
        TimelineEventComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline-event',
                        template: "<div class=\"timeline-badge\" [ngClass]=\"badgeColor\" [attr.aria-describedby]=\"id\">\r\n    <span>{{ badgeTitle }}</span>\r\n</div>\r\n\r\n<div class=\"timeline-panel\" [id]=\"id\">\r\n    <ng-content></ng-content>\r\n</div>\r\n"
                    }] }
        ];
        TimelineEventComponent.propDecorators = {
            id: [{ type: core.Input }],
            badgeColor: [{ type: core.Input }],
            badgeTitle: [{ type: core.Input }]
        };
        return TimelineEventComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineModule = (function () {
        function TimelineModule() {
        }
        TimelineModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            TimelineComponent,
                            TimelineEventComponent
                        ],
                        declarations: [
                            TimelineComponent,
                            TimelineEventComponent
                        ]
                    },] }
        ];
        return TimelineModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TOGGLESWITCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ToggleSwitchComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueToggleSwitchId = 0;
    var ToggleSwitchComponent = (function () {
        function ToggleSwitchComponent() {
            this._toggleSwitchId = "ux-toggleswitch-" + ++uniqueToggleSwitchId;
            this.id = this._toggleSwitchId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(ToggleSwitchComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // Update value output
                this.valueChange.emit(value);
                // Notify ngModel
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToggleSwitchComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._toggleSwitchId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToggleSwitchComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (!this.disabled && this.clickable) {
                    this.value = !this.value;
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ToggleSwitchComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = !!value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        ToggleSwitchComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        ToggleSwitchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toggleswitch',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-toggleswitch\"\n       [class.ux-toggleswitch-checked]=\"value\"\n       [class.ux-toggleswitch-disabled]=\"disabled\"\n       [class.ux-toggleswitch-focused]=\"focused\">\n\n    <input class=\"ux-toggleswitch-input\"\n           type=\"checkbox\"\n           role=\"switch\"\n           [id]=\"inputId\"\n           [checked]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"value\"\n           (focus)=\"focused = true\"\n           (blur)=\"focused = false\"\n           (change)=\"toggle()\"\n           (click)=\"$event.stopPropagation()\">\n\n    <div class=\"ux-toggleswitch-container\">\n        <div class=\"ux-toggleswitch-bg\"></div>\n        <div class=\"ux-toggleswitch-nub\"></div>\n    </div>\n\n    <span class=\"ux-toggleswitch-label\">\n        <ng-content></ng-content>\n    </span>\n</label>",
                        providers: [TOGGLESWITCH_VALUE_ACCESSOR]
                    }] }
        ];
        ToggleSwitchComponent.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            clickable: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input }]
        };
        return ToggleSwitchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToggleSwitchModule = (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [ToggleSwitchComponent],
                        declarations: [ToggleSwitchComponent]
                    },] }
        ];
        return ToggleSwitchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchButtonDirective = (function () {
        function ToolbarSearchButtonDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.clicked = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchButtonDirective.prototype, "width", {
            get: /**
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.offsetWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchButtonDirective.prototype.clickHandler = /**
         * @return {?}
         */
            function () {
                this.clicked.emit();
            };
        ToolbarSearchButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchButton]'
                    },] }
        ];
        /** @nocollapse */
        ToolbarSearchButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ToolbarSearchButtonDirective.propDecorators = {
            clicked: [{ type: core.Output }],
            clickHandler: [{ type: core.HostListener, args: ['click',] }]
        };
        return ToolbarSearchButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ KEYS = {
        ENTER: 13,
        ESCAPE: 27
    };
    var ToolbarSearchFieldDirective = (function () {
        function ToolbarSearchFieldDirective(_elementRef, _ngModel) {
            this._elementRef = _elementRef;
            this._ngModel = _ngModel;
            this.cancel = new core.EventEmitter();
            this.submit = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchFieldDirective.prototype, "text", {
            get: /**
             * @return {?}
             */ function () {
                // Use ngModel if specified on the host; otherwise read the DOM
                if (this._ngModel) {
                    return this._ngModel.value;
                }
                return this._elementRef.nativeElement.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.focus();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.blur = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.blur();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.clear = /**
         * @return {?}
         */
            function () {
                // Use ngModel if specified on the host; otherwise use the DOM
                if (this._ngModel) {
                    this._ngModel.reset();
                }
                else {
                    this._elementRef.nativeElement.value = '';
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                setTimeout(function () {
                    if (event.keyCode === KEYS.ENTER) {
                        _this.submit.emit(_this.text);
                    }
                    else if (event.keyCode === KEYS.ESCAPE) {
                        _this._elementRef.nativeElement.blur();
                        _this.cancel.emit();
                    }
                });
            };
        ToolbarSearchFieldDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchField]'
                    },] }
        ];
        /** @nocollapse */
        ToolbarSearchFieldDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: forms.NgModel, decorators: [{ type: core.Optional }] }
            ];
        };
        ToolbarSearchFieldDirective.propDecorators = {
            cancel: [{ type: core.Output }],
            submit: [{ type: core.Output }],
            keydownHandler: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ToolbarSearchFieldDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchComponent = (function () {
        function ToolbarSearchComponent(_elementRef, _colorService, _document) {
            this._elementRef = _elementRef;
            this._colorService = _colorService;
            this._document = _document;
            this.direction = 'right';
            this.inverse = false;
            this.expandedChange = new core.EventEmitter();
            this.search = new core.EventEmitter();
            this._expanded = false;
            this.position = 'relative';
            this.backgroundColor = 'transparent';
        }
        Object.defineProperty(ToolbarSearchComponent.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._expanded = value;
                this.expandedChange.emit(value);
                if (value) {
                    // Set focus on the input when expanded
                    this.field.focus();
                }
                else {
                    // Clear text when contracted
                    this.field.clear();
                    // Remove focus (works around an IE issue where the caret remains visible)
                    this.field.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "background", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.backgroundColor = this._colorService.resolve(value) || 'transparent';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "expandedAnimation", {
            get: /**
             * @return {?}
             */ function () {
                return {
                    value: this.expanded ? 'expanded' : 'collapsed',
                    params: {
                        initialWidth: this.button.width + 'px'
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Subscribe to the submit event on the input field, triggering the search event
                this.field.submit.subscribe(function (text) { return _this.search.emit(text); });
                // Subscribe to cancel events coming from the input field
                this.field.cancel.subscribe(function () { return _this.expanded = false; });
                // Subscribe to the button click event
                this.button.clicked.subscribe(function () {
                    if (_this.expanded && _this.field.text) {
                        _this.search.emit(_this.field.text);
                    }
                    else {
                        _this.expanded = !_this.expanded;
                    }
                });
                // Create placeholder element to avoid changing layout when switching to position: absolute
                this.createPlaceholder();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationStart = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'expanded') {
                    this.position = 'absolute';
                    this.enablePlaceholder(true);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationDone = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'collapsed') {
                    this.position = 'relative';
                    this.enablePlaceholder(false);
                }
            };
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.createPlaceholder = /**
         * @return {?}
         */
            function () {
                // Get width and height of the component
                var /** @type {?} */ styles = getComputedStyle(this._elementRef.nativeElement);
                // Create invisible div with the same dimensions
                this._placeholder = this._document.createElement('div');
                this._placeholder.style.display = 'none';
                this._placeholder.style.width = this.button.width + 'px';
                this._placeholder.style.height = styles.height;
                this._placeholder.style.visibility = 'hidden';
                // Add as a sibling
                this._elementRef.nativeElement.parentNode.insertBefore(this._placeholder, this._elementRef.nativeElement);
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        ToolbarSearchComponent.prototype.enablePlaceholder = /**
         * @param {?} enabled
         * @return {?}
         */
            function (enabled) {
                this._placeholder.style.display = (enabled ? 'inline-block' : 'none');
            };
        ToolbarSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toolbar-search',
                        template: "<ng-content></ng-content>",
                        animations: [
                            animations.trigger('expanded', [
                                animations.state('collapsed', animations.style({
                                    width: '{{initialWidth}}'
                                }), {
                                    params: { initialWidth: '30px' }
                                }),
                                animations.state('expanded', animations.style({
                                    width: '100%'
                                })),
                                animations.transition('collapsed <=> expanded', [animations.animate('0.3s ease-out')])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        ToolbarSearchComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ColorService },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        ToolbarSearchComponent.propDecorators = {
            expanded: [{ type: core.HostBinding, args: ['class.expanded',] }, { type: core.Input }],
            direction: [{ type: core.Input }, { type: core.HostBinding, args: ['class',] }],
            inverse: [{ type: core.Input }, { type: core.HostBinding, args: ['class.inverse',] }],
            background: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }],
            search: [{ type: core.Output }],
            expandedAnimation: [{ type: core.HostBinding, args: ['@expanded',] }],
            position: [{ type: core.HostBinding, args: ['style.position',] }],
            backgroundColor: [{ type: core.HostBinding, args: ['style.background-color',] }],
            field: [{ type: core.ContentChild, args: [ToolbarSearchFieldDirective,] }],
            button: [{ type: core.ContentChild, args: [ToolbarSearchButtonDirective,] }],
            animationStart: [{ type: core.HostListener, args: ['@expanded.start', ['$event'],] }],
            animationDone: [{ type: core.HostListener, args: ['@expanded.done', ['$event'],] }]
        };
        return ToolbarSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$6 = [
        ToolbarSearchComponent,
        ToolbarSearchFieldDirective,
        ToolbarSearchButtonDirective
    ];
    var ToolbarSearchModule = (function () {
        function ToolbarSearchModule() {
        }
        ToolbarSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$6,
                        declarations: DECLARATIONS$6,
                        providers: [],
                    },] }
        ];
        return ToolbarSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadingDirective = (function () {
        function VirtualScrollLoadingDirective() {
        }
        VirtualScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoading]'
                    },] }
        ];
        return VirtualScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadButtonDirective = (function () {
        function VirtualScrollLoadButtonDirective() {
        }
        VirtualScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoadButton]'
                    },] }
        ];
        return VirtualScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollCellDirective = (function () {
        function VirtualScrollCellDirective() {
        }
        VirtualScrollCellDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollCell]'
                    },] }
        ];
        return VirtualScrollCellDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollComponent = (function () {
        function VirtualScrollComponent(_elementRef, resizeService) {
            var _this = this;
            this._elementRef = _elementRef;
            this.collection = Observable.Observable.create();
            this.loadOnScroll = true;
            this.loading = new core.EventEmitter();
            this.cells = new BehaviorSubject.BehaviorSubject([]);
            this.scrollTop = 0;
            this.isLoading = false;
            this.pageNumber = 0;
            this.data = [];
            this.loadingComplete = false;
            // watch for any future changes to size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) { return _this._height = event.height; });
        }
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.cellHeight) {
                    throw new Error('Virtual Scroll Component requires "cellHeight" property to be defined.');
                }
                // subscribe to the collection
                this.setupObservable();
                // load the first page of data
                this.loadNextPage();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // re-render cells now that we can display any loading indicator or loading button
                this.renderCells();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes["collection"] && changes["collection"].currentValue !== changes["collection"].previousValue && !changes["collection"].isFirstChange()) {
                    this.setupObservable();
                    this.reset();
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.setupObservable = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there is a current subscription, unsubscribe
                if (this._subscription && this._subscription.unsubscribe) {
                    this._subscription.unsubscribe();
                }
                this._subscription = this.collection.subscribe(function (collection) {
                    (_a = _this.data).push.apply(_a, __spread(collection));
                    _this.renderCells();
                    _this.isLoading = false;
                    var _a;
                }, null, function () {
                    _this.loadingComplete = true;
                });
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.renderCells = /**
         * @return {?}
         */
            function () {
                this.cells.next(this.getVisibleCells());
                if (this.loadOnScroll && !this.isLoading && !this.loadingComplete) {
                    var /** @type {?} */ remainingScroll = this._elementRef.nativeElement.scrollHeight - (this._elementRef.nativeElement.scrollTop + this._elementRef.nativeElement.clientHeight);
                    // if the current cells take up less than the height of the component then load the next page
                    if (remainingScroll <= this._elementRef.nativeElement.clientHeight) {
                        this.loadNextPage();
                    }
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getVisibleCells = /**
         * @return {?}
         */
            function () {
                // store the initial element height
                if (!this._height) {
                    this._height = this._elementRef.nativeElement.offsetHeight;
                }
                // perform some calculations
                var /** @type {?} */ scrollTop = this._elementRef.nativeElement.scrollTop;
                var /** @type {?} */ startCell = Math.floor(scrollTop / this.cellHeight);
                var /** @type {?} */ endCell = Math.ceil(this._height / this.cellHeight) + 1;
                // update the scroll position
                this.scrollTop = scrollTop - (scrollTop % this.cellHeight);
                // return a sublist of items visible on the screen
                return this.data.slice(startCell, startCell + endCell);
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getTotalHeight = /**
         * @return {?}
         */
            function () {
                return this.cellHeight * this.data.length;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.loadNextPage = /**
         * @return {?}
         */
            function () {
                this.isLoading = true;
                this.loading.next(this.pageNumber);
                this.pageNumber++;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.reset = /**
         * @return {?}
         */
            function () {
                // reset all values
                this.scrollTop = 0;
                this.data = [];
                this._height = undefined;
                this.pageNumber = 0;
                this.loadingComplete = false;
                // set scroll position
                this._elementRef.nativeElement.scrollTop = 0;
                // clear the current cells
                this.renderCells();
                // reload first page
                this.loadNextPage();
            };
        VirtualScrollComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-virtual-scroll',
                        template: "<div class=\"virtual-scroll-content-height\" [style.height.px]=\"getTotalHeight()\"></div>\n<div class=\"virtual-scroll-content\" [style.transform]=\"'translateY(' + scrollTop + 'px)'\">\n\n    <!-- Virtually Render Cells -->\n    <ng-container *ngFor=\"let cell of cells | async\">\n        <ng-container *ngTemplateOutlet=\"cellTemplate; context: { cell: cell }\"></ng-container>\n    </ng-container>\n\n    <!-- Loading Indicator -->\n    <ng-container *ngIf=\"loadingIndicatorTemplate && isLoading\" [ngTemplateOutlet]=\"loadingIndicatorTemplate\"></ng-container>\n\n    <!-- Loading Button -->\n    <div class=\"virtual-scroll-load-button\" *ngIf=\"loadButtonTemplate && !loadOnScroll && !loadingComplete && !isLoading\" (click)=\"loadNextPage()\">\n        <ng-container *ngTemplateOutlet=\"loadButtonTemplate\"></ng-container>\n    </div>\n    \n</div>"
                    }] }
        ];
        /** @nocollapse */
        VirtualScrollComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService }
            ];
        };
        VirtualScrollComponent.propDecorators = {
            collection: [{ type: core.Input }],
            cellHeight: [{ type: core.Input }],
            loadOnScroll: [{ type: core.Input }],
            loading: [{ type: core.Output }],
            cellTemplate: [{ type: core.ContentChild, args: [VirtualScrollCellDirective, { read: core.TemplateRef },] }],
            loadingIndicatorTemplate: [{ type: core.ContentChild, args: [VirtualScrollLoadingDirective, { read: core.TemplateRef },] }],
            loadButtonTemplate: [{ type: core.ContentChild, args: [VirtualScrollLoadButtonDirective, { read: core.TemplateRef },] }],
            renderCells: [{ type: core.HostListener, args: ['scroll',] }]
        };
        return VirtualScrollComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$7 = [
        VirtualScrollComponent,
        VirtualScrollLoadingDirective,
        VirtualScrollLoadButtonDirective,
        VirtualScrollCellDirective
    ];
    var VirtualScrollModule = (function () {
        function VirtualScrollModule() {
        }
        VirtualScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        exports: DECLARATIONS$7,
                        declarations: DECLARATIONS$7
                    },] }
        ];
        return VirtualScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowDirective = (function () {
        function AutoGrowDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            // ensure this is a textarea or else throw error
            if (_elementRef.nativeElement.tagName.toLowerCase() !== 'textarea') {
                throw new Error('uxAutoGrow directive can only be used on <textarea> elements.');
            }
        }
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.update();
            };
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.update = /**
         * @return {?}
         */
            function () {
                // perform sizing
                this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'hidden');
                this._renderer.setStyle(this._elementRef.nativeElement, 'height', 'auto');
                // get the new total height and element height
                var scrollHeight = this._elementRef.nativeElement.scrollHeight;
                var maxHeight = getComputedStyle(this._elementRef.nativeElement).maxHeight;
                // determine what the maximum allowed height is
                var /** @type {?} */ maximum = !isNaN(parseFloat(maxHeight)) ? parseFloat(maxHeight) : Infinity;
                // if there is a max height specifed we want to show the scrollbars
                if (maximum < scrollHeight) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'auto');
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', maximum + 'px');
                }
                else {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', scrollHeight + 'px');
                }
            };
        AutoGrowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxAutoGrow]'
                    },] }
        ];
        /** @nocollapse */
        AutoGrowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        AutoGrowDirective.propDecorators = {
            update: [{ type: core.HostListener, args: ['input',] }]
        };
        return AutoGrowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowModule = (function () {
        function AutoGrowModule() {
        }
        AutoGrowModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [AutoGrowDirective],
                        declarations: [AutoGrowDirective]
                    },] }
        ];
        return AutoGrowModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableDirective = (function () {
        function FixedHeaderTableDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.tablePaging = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // add class to the table
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-fixed-header-table');
                // locate the important elements
                this._tableHead = this._elementRef.nativeElement.querySelector('thead');
                this._tableBody = this._elementRef.nativeElement.querySelector('tbody');
                // bind to scroll events on the table body
                this._renderer.listen(this._tableBody, 'scroll', this.onScroll.bind(this));
                // resize the table header to account for scrollbar
                this.setLayout();
                // trigger the loading of the first page
                this.tablePaging.emit();
            };
        /**
         * Get the table element
         * Primarily used by column width directive
         */
        /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.getTable = /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement;
            };
        /**
         * Handle scroll events
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.onScroll = /**
         * Handle scroll events
         * @return {?}
         */
            function () {
                // determine if we are scrolled to the bottom and if so load the next page
                if (this._tableBody.scrollTop === (this._tableBody.scrollHeight - this._tableBody.offsetHeight)) {
                    this.tablePaging.emit();
                }
            };
        /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.setLayout = /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
            function () {
                // calculate the size of the scrollbar
                var /** @type {?} */ scrollbar = this._tableBody.offsetWidth - this._tableBody.clientWidth;
                // add padding to the header to account for this
                this._renderer.setStyle(this._tableHead, 'padding-right', scrollbar + 'px');
                // set the desired height of the table body
                this._renderer.setStyle(this._tableBody, 'height', typeof this.tableHeight === 'number' ? this.tableHeight + "px" : this.tableHeight);
            };
        FixedHeaderTableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFixedHeaderTable]'
                    },] }
        ];
        /** @nocollapse */
        FixedHeaderTableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        FixedHeaderTableDirective.propDecorators = {
            tableHeight: [{ type: core.Input }],
            tablePaging: [{ type: core.Output }]
        };
        return FixedHeaderTableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableModule = (function () {
        function FixedHeaderTableModule() {
        }
        FixedHeaderTableModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FixedHeaderTableDirective],
                        declarations: [FixedHeaderTableDirective]
                    },] }
        ];
        return FixedHeaderTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelDirective = (function () {
        function FloatLabelDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.mode = 'focus';
            this.raised = false;
            this._focused = false;
            this._eventHandles = [];
        }
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._eventHandles.push(this._renderer.listen(this.input, 'focus', this.inputFocus.bind(this)), this._renderer.listen(this.input, 'blur', this.inputBlur.bind(this)), this._renderer.listen(this.input, 'input', this.inputChange.bind(this)));
                // Check initial input value
                this.raised = this.hasText();
                // Ensure that the `for` attribute is set
                if (!this._elementRef.nativeElement.getAttribute('for') && this.input.getAttribute('id')) {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'for', this.input.getAttribute('id'));
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                if (!(this.mode === 'focus' && this._focused)) {
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // Unsubscribe event handles
                this._eventHandles.forEach(function (eventHandle) { return eventHandle(); });
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.hasText = /**
         * @return {?}
         */
            function () {
                if (this.value === undefined) {
                    return !!this.input.value;
                }
                return !!this.value;
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputFocus = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'focus') {
                    this._focused = true;
                    this.raised = true;
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputBlur = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'focus') {
                    this._focused = false;
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputChange = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'input') {
                    this.raised = this.hasText();
                }
            };
        FloatLabelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFloatLabel]',
                        host: {
                            'class': 'ux-float-label'
                        }
                    },] }
        ];
        /** @nocollapse */
        FloatLabelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        FloatLabelDirective.propDecorators = {
            input: [{ type: core.Input, args: ['uxFloatLabel',] }],
            value: [{ type: core.Input }],
            mode: [{ type: core.Input }],
            raised: [{ type: core.HostBinding, args: ['class.ux-float-label-raised',] }]
        };
        return FloatLabelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelModule = (function () {
        function FloatLabelModule() {
        }
        FloatLabelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [FloatLabelDirective],
                        declarations: [FloatLabelDirective],
                        providers: [],
                    },] }
        ];
        return FloatLabelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterService = (function () {
        function HelpCenterService() {
            this.items = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.registerItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // add the new item to the list
                items.push(item);
                // update the observable
                this.items.next(items);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.unregisterItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // remove the item being unregistered
                items = items.filter(function (itm) { return itm !== item; });
                // update the observable
                this.items.next(items);
            };
        HelpCenterService.decorators = [
            { type: core.Injectable }
        ];
        return HelpCenterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterItemDirective = (function () {
        function HelpCenterItemDirective(_helpCenterService) {
            this._helpCenterService = _helpCenterService;
        }
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // register the item in the service
                this._helpCenterService.registerItem(this.uxHelpCenterItem);
            };
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // remove this item when it is destroyed
                this._helpCenterService.unregisterItem(this.uxHelpCenterItem);
            };
        HelpCenterItemDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[uxHelpCenterItem]' },] }
        ];
        /** @nocollapse */
        HelpCenterItemDirective.ctorParameters = function () {
            return [
                { type: HelpCenterService }
            ];
        };
        HelpCenterItemDirective.propDecorators = {
            uxHelpCenterItem: [{ type: core.Input }]
        };
        return HelpCenterItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterModule = (function () {
        function HelpCenterModule() {
        }
        HelpCenterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [HelpCenterItemDirective],
                        declarations: [HelpCenterItemDirective],
                        providers: [HelpCenterService],
                    },] }
        ];
        return HelpCenterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionService = (function () {
        function HoverActionService() {
            this.active = new BehaviorSubject.BehaviorSubject(false);
            this._focused = false;
            this._hovered = false;
            this._actions = [];
        }
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.register = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this._actions.push(action);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.unregister = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this._actions = this._actions.filter(function (actn) { return actn !== action; });
            };
        /**
         * @param {?} container
         * @return {?}
         */
        HoverActionService.prototype.setContainer = /**
         * @param {?} container
         * @return {?}
         */
            function (container) {
                this._container = container;
            };
        /**
         * @param {?} focus
         * @return {?}
         */
        HoverActionService.prototype.setFocusState = /**
         * @param {?} focus
         * @return {?}
         */
            function (focus) {
                this._focused = focus;
                this.updateVisibility();
            };
        /**
         * @param {?} hover
         * @return {?}
         */
        HoverActionService.prototype.setHoverState = /**
         * @param {?} hover
         * @return {?}
         */
            function (hover) {
                this._hovered = hover;
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.next = /**
         * @return {?}
         */
            function () {
                // if container has focus then focus the first hover action
                if (this.containerHasFocus()) {
                    this.focusActionAtIndex(0);
                    return this.updateVisibility();
                }
                // if a hover action has focus then focus the next action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() + 1;
                    this.focusActionAtIndex(index);
                    this.updateVisibility();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.previous = /**
         * @return {?}
         */
            function () {
                // if a hover action has focus then focus the previous action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() - 1;
                    if (index >= 0) {
                        this.focusActionAtIndex(index);
                    }
                    else {
                        this._container.focus();
                    }
                }
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.updateVisibility = /**
         * @return {?}
         */
            function () {
                this.active.next(this._focused || this._hovered || this.actionHasFocus());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        HoverActionService.prototype.focusActionAtIndex = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (index >= 0 && index < this._actions.length) {
                    this._actions[index].focus();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedActionIndex = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this._actions.findIndex(function (action) { return action === _this.getFocusedAction(); });
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.containerHasFocus = /**
         * @return {?}
         */
            function () {
                return this._focused;
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.actionHasFocus = /**
         * @return {?}
         */
            function () {
                return !!this.getFocusedAction();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedAction = /**
         * @return {?}
         */
            function () {
                return this._actions.find(function (action) { return action.focused; });
            };
        HoverActionService.decorators = [
            { type: core.Injectable }
        ];
        return HoverActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionContainerDirective = (function () {
        function HoverActionContainerDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            // register the container element with the service
            this._hoverActionService.setContainer(this);
            // apply a class based on the active state of the container and it's actions
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setFocusState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setFocusState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onHover = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setHoverState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onLeave = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setHoverState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.next = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.next();
            };
        HoverActionContainerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverActionContainer]',
                        providers: [HoverActionService],
                        host: {
                            '[class.hover-action-container-active]': 'active',
                            '[tabindex]': 'tabindex'
                        }
                    },] }
        ];
        /** @nocollapse */
        HoverActionContainerDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: HoverActionService }
            ];
        };
        HoverActionContainerDirective.propDecorators = {
            tabindex: [{ type: core.Input }],
            focus: [{ type: core.HostListener, args: ['click',] }],
            onFocus: [{ type: core.HostListener, args: ['focus',] }],
            onBlur: [{ type: core.HostListener, args: ['blur',] }],
            onHover: [{ type: core.HostListener, args: ['mouseenter',] }],
            onLeave: [{ type: core.HostListener, args: ['mouseleave',] }],
            next: [{ type: core.HostListener, args: ['keydown.arrowright',] }]
        };
        return HoverActionContainerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionDirective = (function () {
        function HoverActionDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 1;
            this.active = false;
            this.focused = false;
            // register the action
            this._hoverActionService.register(this);
            // watch for changes to the activeness of the container
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.unregister(this);
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                this.focused = true;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                this.focused = false;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.previous = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.stopPropagation();
                this._hoverActionService.previous();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.next = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.stopPropagation();
                this._hoverActionService.next();
            };
        HoverActionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverAction]',
                        host: {
                            '[class.hover-action-active]': 'active',
                            '[class.hover-action-focused]': 'focused',
                            '[tabindex]': 'tabindex'
                        }
                    },] }
        ];
        /** @nocollapse */
        HoverActionDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: HoverActionService }
            ];
        };
        HoverActionDirective.propDecorators = {
            tabindex: [{ type: core.Input }],
            onFocus: [{ type: core.HostListener, args: ['focus',] }],
            onBlur: [{ type: core.HostListener, args: ['blur',] }],
            previous: [{ type: core.HostListener, args: ['keydown.arrowleft', ['$event'],] }],
            next: [{ type: core.HostListener, args: ['keydown.arrowright', ['$event'],] }]
        };
        return HoverActionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$8 = [
        HoverActionDirective,
        HoverActionContainerDirective
    ];
    var HoverActionModule = (function () {
        function HoverActionModule() {
        }
        HoverActionModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: DECLARATIONS$8,
                        declarations: DECLARATIONS$8
                    },] }
        ];
        return HoverActionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherItemDirective = (function () {
        function LayoutSwitcherItemDirective(_templateRef, _viewContainerRef) {
            this._templateRef = _templateRef;
            this._viewContainerRef = _viewContainerRef;
        }
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getLayout = /**
         * @return {?}
         */
            function () {
                return this._templateRef;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getConfig = /**
         * @return {?}
         */
            function () {
                return this._config;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.activate = /**
         * @return {?}
         */
            function () {
                this._embeddedView = this._viewContainerRef.createEmbeddedView(this._templateRef);
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.deactivate = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ index = this._viewContainerRef.indexOf(this._embeddedView);
                this._viewContainerRef.remove(index);
                this._embeddedView = null;
            };
        LayoutSwitcherItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcherItem]'
                    },] }
        ];
        /** @nocollapse */
        LayoutSwitcherItemDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef },
                { type: core.ViewContainerRef }
            ];
        };
        LayoutSwitcherItemDirective.propDecorators = {
            _config: [{ type: core.Input, args: ['uxLayoutSwitcherItem',] }]
        };
        return LayoutSwitcherItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherDirective = (function () {
        function LayoutSwitcherDirective(_elementRef, resizeService, _viewContainerRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            // watch for changes to the container size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) {
                _this._width = event.width;
                // render the appropriate layout
                // render the appropriate layout
                _this.updateActiveLayout();
            });
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // if the active group has changed then render the appropriate layout
                if (changes["group"].currentValue !== changes["group"].previousValue) {
                    this.updateActiveLayout();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.getActiveLayout = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there are currently no layouts then do nothing
                if (!this._layouts) {
                    return null;
                }
                // otherwise find layouts that match the active group and that meet the constraints
                return this._layouts.filter(function (layout) { return _this.group === layout.getConfig().group; }).find(function (layout) {
                    var /** @type {?} */ minWidth = layout.getConfig().minWidth || 0;
                    var /** @type {?} */ maxWidth = layout.getConfig().maxWidth || Infinity;
                    return _this._width >= minWidth && _this._width < maxWidth;
                });
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.updateActiveLayout = /**
         * @return {?}
         */
            function () {
                // get the layout that should be shown
                var /** @type {?} */ layout = this.getActiveLayout();
                // check if we are currently showing the layout
                if (this._activeLayout === layout) {
                    return;
                }
                // remove the current layout
                if (this._activeLayout) {
                    this._activeLayout.deactivate();
                }
                // store the new active layout
                this._activeLayout = layout;
                // if there is an active layout then activate
                if (this._activeLayout) {
                    this._activeLayout.activate();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // store the initial current element width
                this._width = this._elementRef.nativeElement.offsetWidth;
                // render the appropriate layout - need a delay as Angular doesn't like changes like this in these lifecycle hooks
                requestAnimationFrame(this.updateActiveLayout.bind(this));
            };
        LayoutSwitcherDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcher]'
                    },] }
        ];
        /** @nocollapse */
        LayoutSwitcherDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService },
                { type: core.ViewContainerRef }
            ];
        };
        LayoutSwitcherDirective.propDecorators = {
            group: [{ type: core.Input }],
            _layouts: [{ type: core.ContentChildren, args: [LayoutSwitcherItemDirective,] }]
        };
        return LayoutSwitcherDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$9 = [
        LayoutSwitcherDirective,
        LayoutSwitcherItemDirective
    ];
    var LayoutSwitcherModule = (function () {
        function LayoutSwitcherModule() {
        }
        LayoutSwitcherModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            ResizeModule
                        ],
                        exports: DECLARATIONS$9,
                        declarations: DECLARATIONS$9,
                        providers: [],
                    },] }
        ];
        return LayoutSwitcherModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OverflowDirective = (function () {
        function OverflowDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow overflow to be within a range before emitting
             */
            this.tolerance = 0;
            /**
             * Emit when there is a change to the overflow state - horizontal or vertical
             */
            this.uxOverflowObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the horizontal axis
             */
            this.uxOverflowHorizontalObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the vertical axis
             */
            this.uxOverflowVerticalObserver = new core.EventEmitter();
            /**
             * Store the overflow state on both axis
             */
            this._state = { horizontalOverflow: false, verticalOverflow: false };
            /**
             * Unsubscribe from all the observables
             */
            this._onDestroy = new Subject.Subject();
        }
        /** Set up the trigger if specified */
        /**
         * Set up the trigger if specified
         * @return {?}
         */
        OverflowDirective.prototype.ngOnInit = /**
         * Set up the trigger if specified
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.trigger) {
                    this.trigger.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.checkForOverflow(); });
                }
            };
        /** Perform an intial check for overflow */
        /**
         * Perform an intial check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.ngAfterViewInit = /**
         * Perform an intial check for overflow
         * @return {?}
         */
            function () {
                var _this = this;
                requestAnimationFrame(function () { return _this.checkForOverflow(); });
            };
        /** Unsubscribe from the trigger */
        /**
         * Unsubscribe from the trigger
         * @return {?}
         */
        OverflowDirective.prototype.ngOnDestroy = /**
         * Unsubscribe from the trigger
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Programmatically trigger check for overflow */
        /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.checkForOverflow = /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
            function () {
                var _a = this._elementRef.nativeElement, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scrollWidth = _a.scrollWidth, scrollHeight = _a.scrollHeight;
                var /** @type {?} */ horizontalOverflow = (scrollWidth - offsetWidth) > this.tolerance;
                var /** @type {?} */ verticalOverflow = (scrollHeight - offsetHeight) > this.tolerance;
                if (horizontalOverflow !== this._state.horizontalOverflow) {
                    this.uxOverflowHorizontalObserver.emit(horizontalOverflow);
                }
                if (verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowVerticalObserver.emit(verticalOverflow);
                }
                if (horizontalOverflow !== this._state.horizontalOverflow || verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowObserver.emit((horizontalOverflow || verticalOverflow));
                }
                // store the state
                this._state = { horizontalOverflow: horizontalOverflow, verticalOverflow: verticalOverflow };
            };
        OverflowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxOverflowObserver], [uxOverflowHorizontalObserver], [uxOverflowVerticalObserver]',
                        exportAs: 'ux-overflow-observer'
                    },] }
        ];
        /** @nocollapse */
        OverflowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        OverflowDirective.propDecorators = {
            trigger: [{ type: core.Input }],
            tolerance: [{ type: core.Input }],
            uxOverflowObserver: [{ type: core.Output }],
            uxOverflowHorizontalObserver: [{ type: core.Output }],
            uxOverflowVerticalObserver: [{ type: core.Output }]
        };
        return OverflowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ObserversModule = (function () {
        function ObserversModule() {
        }
        ObserversModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [OverflowDirective],
                        declarations: [OverflowDirective]
                    },] }
        ];
        return ObserversModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionItemDirective = (function () {
        function SelectionItemDirective(_selectionService, _elementRef) {
            this._selectionService = _selectionService;
            this._elementRef = _elementRef;
            this.tabindex = null;
            this.selectedChange = new core.EventEmitter();
            this.active = false;
            this._selected = false;
            this._managedTabIndex = -1;
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(SelectionItemDirective.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            set: /**
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                selected ? this.select() : this.deselect();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "attrTabIndex", {
            get: /**
             * @return {?}
             */ function () {
                return (this.tabindex !== null) ? this.tabindex : this._managedTabIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there is no associated data then throw an error
                if (!this.uxSelectionItem) {
                    throw new Error('The uxSelectionItem directive must have data associated with it.');
                }
                // subscribe to selection changes on this item
                this._selectionService.getSelectionState(this.uxSelectionItem).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (selected) {
                    // store the selected state
                    // store the selected state
                    _this._selected = selected;
                    // emit the selected state
                    // emit the selected state
                    _this.selectedChange.emit(selected);
                });
                this._selected = this._selectionService.isSelected(this.uxSelectionItem);
                this.selectedChange.emit(this._selected);
                // subscribe to changes to the active state
                this._selectionService.active$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (active) { return active === _this.uxSelectionItem; })).subscribe(function (active) {
                    // store the focus state
                    // store the focus state
                    _this.active = active;
                    // if it is active then focus the element
                    if (active === true) {
                        _this._selectionService.focus$.next(_this.uxSelectionItem);
                        _this._elementRef.nativeElement.focus();
                    }
                });
                // Subscribe to changes to the focus target
                // This is mostly the same as active$, except that it has an initial value of the first item in the collection.
                this._selectionService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focusTarget) {
                    _this._managedTabIndex = (focusTarget === _this.uxSelectionItem) ? 0 : -1;
                });
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.click = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                    this._selectionService.strategy.click(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.mousedown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                    this._selectionService.strategy.mousedown(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.keydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._selectionService.isEnabled && this._selectionService.isKeyboardEnabled) {
                    this._selectionService.strategy.keydown(event, this.uxSelectionItem);
                }
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                // If tabbed to from outside the component, activate.
                if (this._selectionService.active$.getValue() !== this.uxSelectionItem) {
                    this._selectionService.activate(this.uxSelectionItem);
                }
            };
        /**
         * Select this item using the current strategy
         */
        /**
         * Select this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.select = /**
         * Select this item using the current strategy
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.select(this.uxSelectionItem);
                }
            };
        /**
         * Deselect this item using the current strategy
         */
        /**
         * Deselect this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.deselect = /**
         * Deselect this item using the current strategy
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.deselect(this.uxSelectionItem);
                }
            };
        SelectionItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelectionItem]',
                        exportAs: 'ux-selection-item'
                    },] }
        ];
        /** @nocollapse */
        SelectionItemDirective.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: core.ElementRef }
            ];
        };
        SelectionItemDirective.propDecorators = {
            uxSelectionItem: [{ type: core.Input }],
            selected: [{ type: core.Input }, { type: core.HostBinding, args: ['class.ux-selection-selected',] }, { type: core.HostBinding, args: ['attr.aria-selected',] }],
            tabindex: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            active: [{ type: core.HostBinding, args: ['class.ux-selection-focused',] }],
            attrTabIndex: [{ type: core.HostBinding, args: ['attr.tabindex',] }],
            click: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            mousedown: [{ type: core.HostListener, args: ['mousedown', ['$event'],] }],
            keydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            focus: [{ type: core.HostListener, args: ['focus',] }]
        };
        return SelectionItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionDirective = (function () {
        function SelectionDirective(_selectionService, _cdRef) {
            var _this = this;
            this._selectionService = _selectionService;
            this._cdRef = _cdRef;
            this.tabindex = null;
            this.uxSelectionChange = new core.EventEmitter();
            this._onDestroy = new Subject.Subject();
            _selectionService.selection$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (items) { return _this.uxSelectionChange.emit(items); });
        }
        Object.defineProperty(SelectionDirective.prototype, "uxSelection", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                (_a = this._selectionService).select.apply(_a, __spread(items));
                var _a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "disabled", {
            set: /**
             * @param {?} disabled
             * @return {?}
             */ function (disabled) {
                this._selectionService.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "mode", {
            set: /**
             * @param {?} mode
             * @return {?}
             */ function (mode) {
                this._selectionService.setStrategy(mode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "clickSelection", {
            set: /**
             * @param {?} isClickEnabled
             * @return {?}
             */ function (isClickEnabled) {
                this._selectionService.isClickEnabled = isClickEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "keyboardSelection", {
            set: /**
             * @param {?} isKeyboardEnabled
             * @return {?}
             */ function (isKeyboardEnabled) {
                this._selectionService.isKeyboardEnabled = isKeyboardEnabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // provide the initial list of selection items
                this.update();
                // if the list changes then inform the service
                this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.update(); });
            };
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Update the dataset to reflect the latest selection items
         */
        /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
        SelectionDirective.prototype.update = /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
            function () {
                this._selectionService.dataset = this.items.map(function (item) { return item.uxSelectionItem; });
                // Make sure that a tab target has been defined so that the component can be tabbed to.
                if (this._selectionService.focus$.getValue() === null && this._selectionService.dataset.length > 0) {
                    this._selectionService.focus$.next(this._selectionService.dataset[0]);
                }
                // The above could trigger a change in the computed tabindex for selection items
                this._cdRef.detectChanges();
            };
        /**
         * Select all the items in the list
         */
        /**
         * Select all the items in the list
         * @return {?}
         */
        SelectionDirective.prototype.selectAll = /**
         * Select all the items in the list
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.selectAll();
                }
            };
        /**
         * Deselect all currently selected items
         */
        /**
         * Deselect all currently selected items
         * @return {?}
         */
        SelectionDirective.prototype.deselectAll = /**
         * Deselect all currently selected items
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.deselectAll();
                }
            };
        SelectionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelection]',
                        exportAs: 'ux-selection',
                        providers: [SelectionService]
                    },] }
        ];
        /** @nocollapse */
        SelectionDirective.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: core.ChangeDetectorRef }
            ];
        };
        SelectionDirective.propDecorators = {
            uxSelection: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            mode: [{ type: core.Input }],
            clickSelection: [{ type: core.Input }],
            keyboardSelection: [{ type: core.Input }],
            tabindex: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.tabindex',] }],
            uxSelectionChange: [{ type: core.Output }],
            items: [{ type: core.ContentChildren, args: [SelectionItemDirective,] }]
        };
        return SelectionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionModule = (function () {
        function SelectionModule() {
        }
        SelectionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [SelectionDirective, SelectionItemDirective],
                        exports: [SelectionDirective, SelectionItemDirective]
                    },] }
        ];
        return SelectionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridState = (function () {
        function TreeGridState(level, setSize, positionInSet) {
            this.level = level;
            this.setSize = setSize;
            this.positionInSet = positionInSet;
            this.loading$ = new BehaviorSubject.BehaviorSubject(false);
        }
        return TreeGridState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridService = (function () {
        function TreeGridService(_changeDetector) {
            var _this = this;
            this._changeDetector = _changeDetector;
            /**
             * The raw table data
             */
            this.data$ = new BehaviorSubject.BehaviorSubject([]);
            /**
             * The flattened table data
             */
            this.rows$ = new BehaviorSubject.BehaviorSubject([]);
            /**
             * Ensure we destroy all observables correctly
             */
            this._onDestroy = new Subject.Subject();
            this.data$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (data) { return _this.rows$.next(_this.getFlattenedTree(data)); });
        }
        /** Unsubscribe from all observables */
        /**
         * Unsubscribe from all observables
         * @return {?}
         */
        TreeGridService.prototype.ngOnDestroy = /**
         * Unsubscribe from all observables
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Set the expanded state of a row */
        /**
         * Set the expanded state of a row
         * @param {?} item
         * @param {?} expanded
         * @return {?}
         */
        TreeGridService.prototype.setExpanded = /**
         * Set the expanded state of a row
         * @param {?} item
         * @param {?} expanded
         * @return {?}
         */
            function (item, expanded) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!expanded)
                                    return [3 /*break*/, 2];
                                return [4 /*yield*/, this.getChildren(item)];
                            case 1:
                                _a.sent();
                                this.insertChildren(item);
                                return [3 /*break*/, 3];
                            case 2:
                                this.removeChildren(item);
                                _a.label = 3;
                            case 3:
                                this._changeDetector.detectChanges();
                                return [2 /*return*/];
                        }
                    });
                });
            };
        /**
         * A function to flatten tree data
         * @param {?} data
         * @param {?=} parent
         * @return {?}
         */
        TreeGridService.prototype.getFlattenedTree = /**
         * A function to flatten tree data
         * @param {?} data
         * @param {?=} parent
         * @return {?}
         */
            function (data, parent) {
                var _this = this;
                // flatten the nodes at this level
                return data.reduce(function (previous, item, index) {
                    item.state = new TreeGridState(parent ? parent.state.level + 1 : 0, data.length, index + 1);
                    // Convert any child nodes
                    var /** @type {?} */ children = (item.children && item.expanded) ? _this.getFlattenedTree(item.children, item) : [];
                    // return the nodes in a flattened array
                    return __spread(previous, [item], children);
                }, []);
            };
        /**
         * Load any children dynamically
         * @param {?} item
         * @return {?}
         */
        TreeGridService.prototype.getChildren = /**
         * Load any children dynamically
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!(!item.children && this.loadChildren))
                                    return [3 /*break*/, 4];
                                item.state.loading$.next(true);
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, , 3, 4]);
                                _a = item;
                                return [4 /*yield*/, this.getNormalizedChildren(this.loadChildren(item))];
                            case 2:
                                _a.children = _b.sent();
                                return [3 /*break*/, 4];
                            case 3:
                                item.state.loading$.next(false);
                                return [7 /*endfinally*/];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            };
        /**
         * We want to support an array, a promise and an observable. This will return all types as a promise
         * @param {?} response
         * @return {?}
         */
        TreeGridService.prototype.getNormalizedChildren = /**
         * We want to support an array, a promise and an observable. This will return all types as a promise
         * @param {?} response
         * @return {?}
         */
            function (response) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(response instanceof Observable.Observable))
                                    return [3 /*break*/, 2];
                                return [4 /*yield*/, response.toPromise()];
                            case 1: return [2 /*return*/, _a.sent()];
                            case 2:
                                if (!(response instanceof Promise))
                                    return [3 /*break*/, 4];
                                return [4 /*yield*/, response];
                            case 3: return [2 /*return*/, _a.sent()];
                            case 4:
                                // if it is an array then make it an observable
                                return [2 /*return*/, response];
                        }
                    });
                });
            };
        /**
         * Insert the children into the flattened tree at the correct location
         * @param {?} parent
         * @return {?}
         */
        TreeGridService.prototype.insertChildren = /**
         * Insert the children into the flattened tree at the correct location
         * @param {?} parent
         * @return {?}
         */
            function (parent) {
                if (!parent.children) {
                    return;
                }
                var /** @type {?} */ row = this.rows$.getValue();
                var /** @type {?} */ index = row.indexOf(parent);
                if (index < 0) {
                    return;
                }
                // Skip duplicates - this could happen if an already expanded child has been inserted
                var /** @type {?} */ uniqueChildren = parent.children.filter(function (child) { return row.indexOf(child) === -1; });
                var /** @type {?} */ childRows = this.getFlattenedTree(uniqueChildren, parent);
                row.splice.apply(row, __spread([index + 1, 0], childRows));
            };
        /**
         * Remove all rows from the flattened tree
         * @param {?} parent
         * @return {?}
         */
        TreeGridService.prototype.removeChildren = /**
         * Remove all rows from the flattened tree
         * @param {?} parent
         * @return {?}
         */
            function (parent) {
                var /** @type {?} */ rows = this.rows$.getValue();
                var /** @type {?} */ index = rows.indexOf(parent);
                if (index < 0) {
                    return;
                }
                while (index + 1 < rows.length && rows[index + 1].state.level > parent.state.level) {
                    rows.splice(index + 1, 1);
                }
            };
        TreeGridService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        TreeGridService.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        return TreeGridService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridRowDirective = (function () {
        function TreeGridRowDirective(_treeGridService) {
            var _this = this;
            this._treeGridService = _treeGridService;
            this.expandedChange = new core.EventEmitter();
            this.loading = false;
            this.isExpanded = false;
            this._expanded$ = new BehaviorSubject$1.BehaviorSubject(false);
            this._onDestroy = new Subject.Subject();
            this._expanded$.pipe(operators.skip(1), tick(), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                _this.expandedChange.emit(expanded);
                _this._treeGridService.setExpanded(_this.item, expanded);
                _this.isExpanded = expanded;
            });
        }
        Object.defineProperty(TreeGridRowDirective.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded$.getValue();
            },
            set: /**
             * @param {?} expanded
             * @return {?}
             */ function (expanded) {
                this._expanded$.next(!!expanded);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.item || !this.item.state) {
                    throw new Error('uxTreeGridRow should be configured with an object emitted by uxTreeGrid.rows.');
                }
                this.item.state.loading$.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (loading) { return _this.loading = loading; });
            };
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        TreeGridRowDirective.prototype.collapse = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                this.expanded = false;
                if (event) {
                    event.preventDefault();
                }
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        TreeGridRowDirective.prototype.expand = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                // take into account whether or not the item can expanded
                this.expanded = this.canExpand && true;
                if (event) {
                    event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.expanded ? this.collapse() : this.expand();
            };
        TreeGridRowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTreeGridRow]',
                        exportAs: 'uxTreeGridRow',
                        host: {
                            '[class.treegrid-row]': 'true'
                        }
                    },] }
        ];
        /** @nocollapse */
        TreeGridRowDirective.ctorParameters = function () {
            return [
                { type: TreeGridService }
            ];
        };
        TreeGridRowDirective.propDecorators = {
            item: [{ type: core.Input, args: ['uxTreeGridRow',] }],
            canExpand: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }],
            loading: [{ type: core.HostBinding, args: ['class.treegrid-row-loading',] }],
            isExpanded: [{ type: core.HostBinding, args: ['class.treegrid-row-expanded',] }],
            collapse: [{ type: core.HostListener, args: ['keydown.ArrowLeft', ['$event'],] }],
            expand: [{ type: core.HostListener, args: ['keydown.ArrowRight', ['$event'],] }]
        };
        return TreeGridRowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridIndentDirective = (function () {
        function TreeGridIndentDirective(_row) {
            this._row = _row;
        }
        Object.defineProperty(TreeGridIndentDirective.prototype, "indentation", {
            /** The padding value applied to each level */
            get: /**
             * The padding value applied to each level
             * @return {?}
             */ function () {
                return this._row && this._row.item ? 7 + (this._row.item.state.level * (this.uxTreeGridIndent || 25)) : 7;
            },
            enumerable: true,
            configurable: true
        });
        TreeGridIndentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTreeGridIndent]',
                    },] }
        ];
        /** @nocollapse */
        TreeGridIndentDirective.ctorParameters = function () {
            return [
                { type: TreeGridRowDirective }
            ];
        };
        TreeGridIndentDirective.propDecorators = {
            uxTreeGridIndent: [{ type: core.Input }],
            indentation: [{ type: core.HostBinding, args: ['style.padding-left.px',] }]
        };
        return TreeGridIndentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridDirective = (function () {
        function TreeGridDirective(_treeGridService) {
            this._treeGridService = _treeGridService;
            this.rowsChange = new core.EventEmitter();
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(TreeGridDirective.prototype, "data", {
            set: /**
             * @param {?} data
             * @return {?}
             */ function (data) {
                this._treeGridService.data$.next(data);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeGridDirective.prototype, "loadChildren", {
            set: /**
             * @param {?} loadChildren
             * @return {?}
             */ function (loadChildren) {
                this._treeGridService.loadChildren = loadChildren;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TreeGridDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._treeGridService.rows$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (rows) { return _this.rowsChange.emit(rows); });
            };
        /**
         * @return {?}
         */
        TreeGridDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        TreeGridDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTreeGrid]',
                        providers: [TreeGridService],
                        host: {
                            class: 'treegrid'
                        }
                    },] }
        ];
        /** @nocollapse */
        TreeGridDirective.ctorParameters = function () {
            return [
                { type: TreeGridService }
            ];
        };
        TreeGridDirective.propDecorators = {
            data: [{ type: core.Input, args: ['uxTreeGrid',] }],
            loadChildren: [{ type: core.Input }],
            rows: [{ type: core.Input }],
            rowsChange: [{ type: core.Output }]
        };
        return TreeGridDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridModule = (function () {
        function TreeGridModule() {
        }
        TreeGridModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            TreeGridDirective,
                            TreeGridRowDirective,
                            TreeGridIndentDirective
                        ],
                        exports: [
                            TreeGridDirective,
                            TreeGridRowDirective,
                            TreeGridIndentDirective
                        ]
                    },] }
        ];
        return TreeGridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ContactsNg1Component = (function (_super) {
        __extends(ContactsNg1Component, _super);
        function ContactsNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'contactGroup', elementRef, injector) || this;
            _this.overflowClick = new core.EventEmitter();
            return _this;
        }
        ContactsNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'contact-group'
                    },] }
        ];
        /** @nocollapse */
        ContactsNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        ContactsNg1Component.propDecorators = {
            contacts: [{ type: core.Input }],
            organization: [{ type: core.Input }],
            size: [{ type: core.Input }],
            colors: [{ type: core.Input }],
            maxContacts: [{ type: core.Input }],
            overflowClick: [{ type: core.Output }]
        };
        return ContactsNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ExpandInputNg1Component = (function (_super) {
        __extends(ExpandInputNg1Component, _super);
        function ExpandInputNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'expandInput', elementRef, injector) || this;
            _this.focus = new core.EventEmitter();
            return _this;
        }
        ExpandInputNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'expand-input'
                    },] }
        ];
        /** @nocollapse */
        ExpandInputNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        ExpandInputNg1Component.propDecorators = {
            elname: [{ type: core.Input }],
            placeHolder: [{ type: core.Input }],
            className: [{ type: core.Input }],
            clearTextIcon: [{ type: core.Input }],
            closeSearch: [{ type: core.Input }],
            expandAlways: [{ type: core.Input }],
            onEnter: [{ type: core.Input }],
            focus: [{ type: core.Output }]
        };
        return ExpandInputNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonNg1Component = (function (_super) {
        __extends(FloatingActionButtonNg1Component, _super);
        function FloatingActionButtonNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'floatingActionButton', elementRef, injector) || this;
            _this.items = [];
            return _this;
        }
        FloatingActionButtonNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'floating-action-button'
                    },] }
        ];
        /** @nocollapse */
        FloatingActionButtonNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        FloatingActionButtonNg1Component.propDecorators = {
            items: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            direction: [{ type: core.Input }],
            fabTooltip: [{ type: core.Input }],
            fabTooltipPlacement: [{ type: core.Input }]
        };
        return FloatingActionButtonNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlotNg1Component = (function (_super) {
        __extends(FlotNg1Component, _super);
        function FlotNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxFlotNg1', elementRef, injector) || this;
            _this.onPlotClick = new core.EventEmitter();
            _this.onPlotHover = new core.EventEmitter();
            return _this;
        }
        FlotNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'flot'
                    },] }
        ];
        /** @nocollapse */
        FlotNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        FlotNg1Component.propDecorators = {
            dataset: [{ type: core.Input }],
            options: [{ type: core.Input }],
            callback: [{ type: core.Input }],
            donutLabels: [{ type: core.Input }],
            onPlotClick: [{ type: core.Output }],
            onPlotHover: [{ type: core.Output }]
        };
        return FlotNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GridNg1Component = (function (_super) {
        __extends(GridNg1Component, _super);
        function GridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'grid', elementRef, injector) || this;
            _this.source = [];
            _this.columns = [];
            return _this;
        }
        GridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'grid'
                    },] }
        ];
        /** @nocollapse */
        GridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        GridNg1Component.propDecorators = {
            source: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            options: [{ type: core.Input }],
            events: [{ type: core.Input }],
            plugins: [{ type: core.Input }]
        };
        return GridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarNg1Component = (function (_super) {
        __extends(HierarchyBarNg1Component, _super);
        function HierarchyBarNg1Component(elementRef, injector) {
            return _super.call(this, 'hierarchyBar', elementRef, injector) || this;
        }
        HierarchyBarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'hierarchy-bar'
                    },] }
        ];
        /** @nocollapse */
        HierarchyBarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        HierarchyBarNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            selectNode: [{ type: core.Input }],
            containerClass: [{ type: core.Input }]
        };
        return HierarchyBarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardNg1Component = (function (_super) {
        __extends(MarqueeWizardNg1Component, _super);
        function MarqueeWizardNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'marqueeWizard', elementRef, injector) || this;
            _this.wizardStepsChange = new core.EventEmitter();
            return _this;
        }
        MarqueeWizardNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'marquee-wizard'
                    },] }
        ];
        /** @nocollapse */
        MarqueeWizardNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        MarqueeWizardNg1Component.propDecorators = {
            wizardIcon: [{ type: core.Input }],
            wizardSteps: [{ type: core.Input }],
            buttonOptions: [{ type: core.Input }],
            onChanging: [{ type: core.Input }],
            onFinished: [{ type: core.Input }],
            onFinishing: [{ type: core.Input }],
            onCanceled: [{ type: core.Input }],
            isVisited: [{ type: core.Input }],
            sideInfo: [{ type: core.Input }],
            wizardStepsChange: [{ type: core.Output }]
        };
        return MarqueeWizardNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NestedDonutNg1Component = (function (_super) {
        __extends(NestedDonutNg1Component, _super);
        function NestedDonutNg1Component(elementRef, injector) {
            return _super.call(this, 'uxNestedDonutNg1', elementRef, injector) || this;
        }
        NestedDonutNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'nested-donut'
                    },] }
        ];
        /** @nocollapse */
        NestedDonutNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        NestedDonutNg1Component.propDecorators = {
            dataset: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return NestedDonutNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OrganizationChartNg1Component = (function (_super) {
        __extends(OrganizationChartNg1Component, _super);
        function OrganizationChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxOrganizationChartNg1', elementRef, injector) || this;
            _this.dataChange = new core.EventEmitter();
            _this.optionsChange = new core.EventEmitter();
            return _this;
        }
        OrganizationChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'organization-chart'
                    },] }
        ];
        /** @nocollapse */
        OrganizationChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        OrganizationChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            dataChange: [{ type: core.Output }],
            optionsChange: [{ type: core.Output }]
        };
        return OrganizationChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PartitionMapNg1Component = (function (_super) {
        __extends(PartitionMapNg1Component, _super);
        function PartitionMapNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPartitionMapNg1', elementRef, injector) || this;
        }
        PartitionMapNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'partition-map'
                    },] }
        ];
        /** @nocollapse */
        PartitionMapNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PartitionMapNg1Component.propDecorators = {
            chartData: [{ type: core.Input }],
            chartOptions: [{ type: core.Input }],
            chartLoading: [{ type: core.Input }]
        };
        return PartitionMapNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityBarChartNg1Component = (function (_super) {
        __extends(PeityBarChartNg1Component, _super);
        function PeityBarChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityBarChartNg1', elementRef, injector) || this;
        }
        PeityBarChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'bar-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityBarChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityBarChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return PeityBarChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityLineChartNg1Component = (function (_super) {
        __extends(PeityLineChartNg1Component, _super);
        function PeityLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityLineChartNg1', elementRef, injector) || this;
        }
        PeityLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'line-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityLineChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return PeityLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityPieChartNg1Component = (function (_super) {
        __extends(PeityPieChartNg1Component, _super);
        function PeityPieChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityPieChartNg1', elementRef, injector) || this;
        }
        PeityPieChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'pie-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityPieChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityPieChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return PeityPieChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityUpdatingLineChartNg1Component = (function (_super) {
        __extends(PeityUpdatingLineChartNg1Component, _super);
        function PeityUpdatingLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityUpdatingLineChartNg1', elementRef, injector) || this;
        }
        PeityUpdatingLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'updating-line-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityUpdatingLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityUpdatingLineChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            method: [{ type: core.Input }],
            updateinterval: [{ type: core.Input }]
        };
        return PeityUpdatingLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SankeyNg1Component = (function (_super) {
        __extends(SankeyNg1Component, _super);
        function SankeyNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSankeyNg1', elementRef, injector) || this;
        }
        SankeyNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sankey'
                    },] }
        ];
        /** @nocollapse */
        SankeyNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SankeyNg1Component.propDecorators = {
            chartSize: [{ type: core.Input }],
            chartData: [{ type: core.Input }],
            options: [{ type: core.Input }],
            click: [{ type: core.Input }]
        };
        return SankeyNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchToolbarNg1Component = (function (_super) {
        __extends(SearchToolbarNg1Component, _super);
        function SearchToolbarNg1Component(elementRef, injector) {
            return _super.call(this, 'searchToolbar', elementRef, injector) || this;
        }
        SearchToolbarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'search-toolbar'
                    },] }
        ];
        /** @nocollapse */
        SearchToolbarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SearchToolbarNg1Component.propDecorators = {
            searchTypeahead: [{ type: core.Input }],
            placeHolder: [{ type: core.Input }],
            closeSearch: [{ type: core.Input }],
            onSearch: [{ type: core.Input }],
            onFocus: [{ type: core.Input }]
        };
        return SearchToolbarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectTableNg1Component = (function (_super) {
        __extends(SelectTableNg1Component, _super);
        function SelectTableNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'selectTable', elementRef, injector) || this;
            _this.selectedChange = new core.EventEmitter();
            return _this;
        }
        SelectTableNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'select-table'
                    },] }
        ];
        /** @nocollapse */
        SelectTableNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SelectTableNg1Component.propDecorators = {
            values: [{ type: core.Input }],
            multipleSelect: [{ type: core.Input }],
            selectKey: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            searchText: [{ type: core.Input }],
            tableHeight: [{ type: core.Input }],
            template: [{ type: core.Input }],
            templateUrl: [{ type: core.Input }],
            selectHiddenItems: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }]
        };
        return SelectTableNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SLIDER_CHART_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SliderChartNg1Component; }),
        multi: true
    };
    var SliderChartNg1Component = (function (_super) {
        __extends(SliderChartNg1Component, _super);
        function SliderChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'sliderChart', elementRef, injector) || this;
            _this.ngModelChange = new core.EventEmitter();
            return _this;
        }
        /**
         * @param {?} obj
         * @return {?}
         */
        SliderChartNg1Component.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        SliderChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'slider-chart',
                        providers: [SLIDER_CHART_VALUE_ACCESSOR]
                    },] }
        ];
        /** @nocollapse */
        SliderChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SliderChartNg1Component.propDecorators = {
            sliderOptions: [{ type: core.Input }],
            ngModel: [{ type: core.Input }],
            chartOptions: [{ type: core.Input }],
            chartData: [{ type: core.Input }],
            ngModelChange: [{ type: core.Output }]
        };
        return SliderChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SocialChartNg1Component = (function (_super) {
        __extends(SocialChartNg1Component, _super);
        function SocialChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSocialChartNg1', elementRef, injector) || this;
        }
        SocialChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'social-chart'
                    },] }
        ];
        /** @nocollapse */
        SocialChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SocialChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            api: [{ type: core.Input }],
            communities: [{ type: core.Input }],
            detailStyle: [{ type: core.Input }],
            popoverStyle: [{ type: core.Input }],
            nodeDetail: [{ type: core.Input }],
            edgeDetail: [{ type: core.Input }],
            nodePopover: [{ type: core.Input }],
            edgePopover: [{ type: core.Input }],
            forceAtlasDuration: [{ type: core.Input }],
            nodeSizeAttribute: [{ type: core.Input }],
            startMaximized: [{ type: core.Input }],
            startMaximised: [{ type: core.Input }],
            showMaximizeControl: [{ type: core.Input }],
            showMaximiseControl: [{ type: core.Input }],
            socialChartContainer: [{ type: core.Input }],
            fullscreenButtonPosition: [{ type: core.Input }],
            localStrings: [{ type: core.Input }],
            chartTitle: [{ type: core.Input }],
            titleDisplayTime: [{ type: core.Input }],
            edgeWeightInfluence: [{ type: core.Input }],
            minLabels: [{ type: core.Input }]
        };
        return SocialChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SortDirectionToggleNg1Component = (function (_super) {
        __extends(SortDirectionToggleNg1Component, _super);
        function SortDirectionToggleNg1Component(elementRef, injector) {
            return _super.call(this, 'sortDirectionToggle', elementRef, injector) || this;
        }
        SortDirectionToggleNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sort-direction-toggle'
                    },] }
        ];
        /** @nocollapse */
        SortDirectionToggleNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SortDirectionToggleNg1Component.propDecorators = {
            label: [{ type: core.Input }],
            sorters: [{ type: core.Input }],
            descend: [{ type: core.Input }]
        };
        return SortDirectionToggleNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridNg1Component = (function (_super) {
        __extends(TreeGridNg1Component, _super);
        function TreeGridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'treegrid', elementRef, injector) || this;
            _this.optionsChange = new core.EventEmitter();
            _this.selectedChange = new core.EventEmitter();
            _this.currentRowChange = new core.EventEmitter();
            _this.treeDataChange = new core.EventEmitter();
            return _this;
        }
        TreeGridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'treegrid'
                    },] }
        ];
        /** @nocollapse */
        TreeGridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        TreeGridNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            treeData: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            currentRow: [{ type: core.Input }],
            options: [{ type: core.Input }],
            optionsChange: [{ type: core.Output }],
            selectedChange: [{ type: core.Output }],
            currentRowChange: [{ type: core.Output }],
            treeDataChange: [{ type: core.Output }]
        };
        return TreeGridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ThumbnailNg1Component = (function (_super) {
        __extends(ThumbnailNg1Component, _super);
        function ThumbnailNg1Component(elementRef, injector) {
            return _super.call(this, 'thumbnail', elementRef, injector) || this;
        }
        ThumbnailNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'thumbnail'
                    },] }
        ];
        /** @nocollapse */
        ThumbnailNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        ThumbnailNg1Component.propDecorators = {
            url: [{ type: core.Input }],
            show: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }]
        };
        return ThumbnailNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationMenuService = (function () {
        function NavigationMenuService(_navigationMenuService) {
            this._navigationMenuService = _navigationMenuService;
        }
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.show = /**
         * @return {?}
         */
            function () {
                this._navigationMenuService.show();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.hide = /**
         * @return {?}
         */
            function () {
                this._navigationMenuService.hide();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.visible = /**
         * @return {?}
         */
            function () {
                return this._navigationMenuService.visible();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.collapseAtWidth = /**
         * @return {?}
         */
            function () {
                return this._navigationMenuService.collapseAtWidth();
            };
        /**
         * @param {?} width
         * @return {?}
         */
        NavigationMenuService.prototype.setCollapseAtWidth = /**
         * @param {?} width
         * @return {?}
         */
            function (width) {
                this._navigationMenuService.setCollapseAtWidth(width);
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.setDefaultCollapseAtWidth = /**
         * @return {?}
         */
            function () {
                this._navigationMenuService.setDefaultCollapseAtWidth();
            };
        NavigationMenuService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NavigationMenuService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$navigationMenu',] }] }
            ];
        };
        return NavigationMenuService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function navigationMenuServiceFactory(injector) {
        return injector.get('$navigationMenu');
    }
    var /** @type {?} */ navigationMenuServiceProvider = {
        provide: '$navigationMenu',
        useFactory: navigationMenuServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PdfService = (function () {
        function PdfService(_pdfService) {
            this._pdfService = _pdfService;
        }
        /**
         * @param {?} columns
         * @param {?} rows
         * @param {?=} options
         * @return {?}
         */
        PdfService.prototype.createTable = /**
         * @param {?} columns
         * @param {?} rows
         * @param {?=} options
         * @return {?}
         */
            function (columns, rows, options) {
                if (options === void 0) {
                    options = {};
                }
                return this._pdfService.createTable(columns, rows, options);
            };
        PdfService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PdfService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$pdf',] }] }
            ];
        };
        return PdfService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function pdfServiceFactory(injector) {
        return injector.get('$pdf');
    }
    var /** @type {?} */ pdfServiceProvider = {
        provide: '$pdf',
        useFactory: pdfServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeAgoService = (function () {
        function TimeAgoService(_timeAgoService) {
            this._timeAgoService = _timeAgoService;
        }
        /**
         * @param {?} strings
         * @return {?}
         */
        TimeAgoService.prototype.setStrings = /**
         * @param {?} strings
         * @return {?}
         */
            function (strings) {
                this._timeAgoService.setStrings(strings);
            };
        /**
         * @param {?} past
         * @param {?} present
         * @return {?}
         */
        TimeAgoService.prototype.timeSince = /**
         * @param {?} past
         * @param {?} present
         * @return {?}
         */
            function (past, present) {
                return this._timeAgoService.timeSince(past, present);
            };
        /**
         * @param {?} moment
         * @return {?}
         */
        TimeAgoService.prototype.timeSinceNow = /**
         * @param {?} moment
         * @return {?}
         */
            function (moment) {
                return this._timeAgoService.timeSinceNow(moment);
            };
        TimeAgoService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        TimeAgoService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['timeAgoService',] }] }
            ];
        };
        return TimeAgoService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function timeAgoServiceFactory(injector) {
        return injector.get('timeAgoService');
    }
    var /** @type {?} */ timeAgoServiceProvider = {
        provide: 'timeAgoService',
        useFactory: timeAgoServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ declarations = [
        ContactsNg1Component,
        ExpandInputNg1Component,
        FloatingActionButtonNg1Component,
        FlotNg1Component,
        GridNg1Component,
        HierarchyBarNg1Component,
        MarqueeWizardNg1Component,
        NestedDonutNg1Component,
        OrganizationChartNg1Component,
        PartitionMapNg1Component,
        PeityBarChartNg1Component,
        PeityLineChartNg1Component,
        PeityPieChartNg1Component,
        PeityUpdatingLineChartNg1Component,
        SankeyNg1Component,
        SearchToolbarNg1Component,
        SelectTableNg1Component,
        SliderChartNg1Component,
        SocialChartNg1Component,
        SortDirectionToggleNg1Component,
        TreeGridNg1Component,
        ThumbnailNg1Component,
    ];
    var HybridModule = (function () {
        function HybridModule() {
        }
        HybridModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: declarations,
                        declarations: declarations,
                        providers: [
                            navigationMenuServiceProvider,
                            pdfServiceProvider,
                            timeAgoServiceProvider,
                            TimeAgoService,
                            PdfService,
                            NavigationMenuService,
                        ],
                    },] }
        ];
        return HybridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterPipe = (function () {
        function StringFilterPipe() {
        }
        /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
        StringFilterPipe.prototype.transform = /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
            function (items, value) {
                if (!items) {
                    return [];
                }
                return items.filter(function (it) { return it.toLowerCase().indexOf(value.toLowerCase()) >= 0; });
            };
        StringFilterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'stringFilter'
                    },] },
            { type: core.Injectable }
        ];
        return StringFilterPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterModule = (function () {
        function StringFilterModule() {
        }
        StringFilterModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [StringFilterPipe],
                        declarations: [StringFilterPipe]
                    },] }
        ];
        return StringFilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CookieAdapter = (function () {
        function CookieAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                if (document.cookie) {
                    // get all the cookies for this site
                    var /** @type {?} */ cookies = document.cookie.split(';');
                    // process the cookies into a from we can easily manage
                    var /** @type {?} */ match = cookies
                        .map(function (cookie) { return ({ key: cookie.split('=')[0].trim(), value: cookie.split('=')[1].trim() }); })
                        .find(function (cookie) { return cookie.key === key; });
                    return match ? match.value : null;
                }
                return null;
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        CookieAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                document.cookie = key + "=" + value + "; path=/";
            };
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                document.cookie.split(';').forEach(function (cookie) {
                    var /** @type {?} */ eqPos = cookie.indexOf('=');
                    var /** @type {?} */ name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie;
                    if (name === key) {
                        document.cookie = cookie.trim().replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                    }
                });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // call remove item on each cookie
                document.cookie.split(';').map(function (cookie) { return cookie.split('=')[0].trim(); })
                    .forEach(function (cookie) { return _this.removeItem(cookie); });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // cookies are supported in all browsers
                return this;
            };
        return CookieAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LocalStorageAdapter = (function () {
        function LocalStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return localStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        LocalStorageAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                localStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                localStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                localStorage.clear();
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!localStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    localStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    localStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return LocalStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SessionStorageAdapter = (function () {
        function SessionStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return sessionStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        SessionStorageAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                sessionStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                sessionStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                sessionStorage.clear();
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!sessionStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    sessionStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    sessionStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return SessionStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataService = (function () {
        function PersistentDataService() {
        }
        /**
         * Save the item in some form of persistent storage
         */
        /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.setItem = /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
            function (key, value, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).setItem(key, value);
            };
        /**
         * Get a stored value from persistent storage
         */
        /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.getItem = /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                return this.getAdapter(type).getItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.removeItem = /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).removeItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.clear = /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
            function (type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).clear();
            };
        /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
        PersistentDataService.prototype.getAdapter = /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
            function (type) {
                switch (type) {
                    case PersistentDataStorageType.Cookie:
                        return new CookieAdapter();
                    case PersistentDataStorageType.LocalStorage:
                        var /** @type {?} */ localStorageAdapter = new LocalStorageAdapter();
                        return localStorageAdapter.getSupported();
                    case PersistentDataStorageType.SessionStorage:
                        var /** @type {?} */ sessionStorageAdapter = new SessionStorageAdapter();
                        return sessionStorageAdapter.getSupported();
                }
            };
        PersistentDataService.decorators = [
            { type: core.Injectable }
        ];
        return PersistentDataService;
    }());
    /** @enum {number} */
    var PersistentDataStorageType = {
        LocalStorage: 0,
        Cookie: 1,
        SessionStorage: 2,
    };
    PersistentDataStorageType[PersistentDataStorageType.LocalStorage] = "LocalStorage";
    PersistentDataStorageType[PersistentDataStorageType.Cookie] = "Cookie";
    PersistentDataStorageType[PersistentDataStorageType.SessionStorage] = "SessionStorage";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataModule = (function () {
        function PersistentDataModule() {
        }
        PersistentDataModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [PersistentDataService],
                    },] }
        ];
        return PersistentDataModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ StorageAdapter = (function () {
        function StorageAdapter() {
        }
        return StorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.AccordionPanelHeadingDirective = AccordionPanelHeadingDirective;
    exports.AccordionPanelComponent = AccordionPanelComponent;
    exports.AccordionComponent = AccordionComponent;
    exports.AccordionModule = AccordionModule;
    exports.AccordionService = AccordionService;
    exports.BreadcrumbsComponent = BreadcrumbsComponent;
    exports.BreadcrumbsModule = BreadcrumbsModule;
    exports.CardTabsModule = CardTabsModule;
    exports.CardTabsService = CardTabsService;
    exports.CardTabsetComponent = CardTabsetComponent;
    exports.CardTabComponent = CardTabComponent;
    exports.CardTabContentDirective = CardTabContentDirective;
    exports.CheckboxModule = CheckboxModule;
    exports.CHECKBOX_VALUE_ACCESSOR = CHECKBOX_VALUE_ACCESSOR;
    exports.CheckboxComponent = CheckboxComponent;
    exports.ColorPickerComponent = ColorPickerComponent;
    exports.ColorPickerColor = ColorPickerColor;
    exports.ColorPickerModule = ColorPickerModule;
    exports.ColumnSortingModule = ColumnSortingModule;
    exports.ColumnSortingComponent = ColumnSortingComponent;
    exports.ColumnSortingDirective = ColumnSortingDirective;
    exports.ColumnSortingState = ColumnSortingState;
    exports.ConduitSubject = ConduitSubject;
    exports.ConduitZoneComponent = ConduitZoneComponent;
    exports.ConduitZone = ConduitZone;
    exports.ConduitComponent = ConduitComponent;
    exports.CONDUITS = CONDUITS;
    exports.Conduit = Conduit;
    exports.defaultConduitProps = defaultConduitProps;
    exports.DashboardModule = DashboardModule;
    exports.DashboardComponent = DashboardComponent;
    exports.DashboardService = DashboardService;
    exports.defaultOptions = defaultOptions;
    exports.ActionDirection = ActionDirection;
    exports.Rounding = Rounding;
    exports.DashboardDragHandleDirective = DashboardDragHandleDirective;
    exports.DashboardWidgetComponent = DashboardWidgetComponent;
    exports.DateTimePickerComponent = DateTimePickerComponent;
    exports.DateTimePickerConfig = DateTimePickerConfig;
    exports.DateTimePickerModule = DateTimePickerModule;
    exports.DateTimePickerService = DateTimePickerService;
    exports.DatePickerMode = DatePickerMode;
    exports.ModeDirection = ModeDirection;
    exports.DatePickerHeaderEvent = DatePickerHeaderEvent;
    exports.gridify = gridify;
    exports.range = range;
    exports.dateRange = dateRange;
    exports.compareDays = compareDays;
    exports.dateComparator = dateComparator;
    exports.timezoneComparator = timezoneComparator;
    exports.months = months;
    exports.monthsShort = monthsShort;
    exports.weekdays = weekdays;
    exports.weekdaysShort = weekdaysShort;
    exports.timezones = timezones;
    exports.EboxModule = EboxModule;
    exports.EboxComponent = EboxComponent;
    exports.EboxHeaderDirective = EboxHeaderDirective;
    exports.EboxContentDirective = EboxContentDirective;
    exports.FacetsModule = FacetsModule;
    exports.FacetContainerComponent = FacetContainerComponent;
    exports.FacetSelect = FacetSelect;
    exports.FacetDeselect = FacetDeselect;
    exports.FacetDeselectAll = FacetDeselectAll;
    exports.FacetHeaderComponent = FacetHeaderComponent;
    exports.FacetBaseComponent = FacetBaseComponent;
    exports.FacetCheckListComponent = FacetCheckListComponent;
    exports.FacetTypeaheadListComponent = FacetTypeaheadListComponent;
    exports.FacetTypeaheadHighlight = FacetTypeaheadHighlight;
    exports.Facet = Facet;
    exports.FilterAddEvent = FilterAddEvent;
    exports.FilterRemoveAllEvent = FilterRemoveAllEvent;
    exports.FilterRemoveEvent = FilterRemoveEvent;
    exports.FilterBaseComponent = FilterBaseComponent;
    exports.FilterContainerComponent = FilterContainerComponent;
    exports.FilterDropdownComponent = FilterDropdownComponent;
    exports.FilterDynamicComponent = FilterDynamicComponent;
    exports.FilterTypeaheadHighlight = FilterTypeaheadHighlight;
    exports.FilterModule = FilterModule;
    exports.FilterService = FilterService;
    exports.FlippableCardModule = FlippableCardModule;
    exports.FlippableCardComponent = FlippableCardComponent;
    exports.FlippableCardFrontDirective = FlippableCardFrontDirective;
    exports.FlippableCardBackDirective = FlippableCardBackDirective;
    exports.FloatingActionButtonsModule = FloatingActionButtonsModule;
    exports.FloatingActionButtonsComponent = FloatingActionButtonsComponent;
    exports.FloatingActionButtonComponent = FloatingActionButtonComponent;
    exports.HierarchyBarModule = HierarchyBarModule;
    exports.HierarchyBarService = HierarchyBarService;
    exports.HierarchyBarComponent = HierarchyBarComponent;
    exports.ItemDisplayPanelModule = ItemDisplayPanelModule;
    exports.ItemDisplayPanelContentDirective = ItemDisplayPanelContentDirective;
    exports.ItemDisplayPanelFooterDirective = ItemDisplayPanelFooterDirective;
    exports.ItemDisplayPanelComponent = ItemDisplayPanelComponent;
    exports.MarqueeWizardStepComponent = MarqueeWizardStepComponent;
    exports.MarqueeWizardComponent = MarqueeWizardComponent;
    exports.MarqueeWizardModule = MarqueeWizardModule;
    exports.MediaPlayerBaseExtensionDirective = MediaPlayerBaseExtensionDirective;
    exports.MediaPlayerControlsExtensionComponent = MediaPlayerControlsExtensionComponent;
    exports.MediaPlayerCustomControlDirective = MediaPlayerCustomControlDirective;
    exports.MediaPlayerTimelineExtensionComponent = MediaPlayerTimelineExtensionComponent;
    exports.MediaPlayerComponent = MediaPlayerComponent;
    exports.MediaPlayerModule = MediaPlayerModule;
    exports.NavigationModule = NavigationModule;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationService = NavigationService;
    exports.NavigationItemComponent = NavigationItemComponent;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NumberPickerModule = NumberPickerModule;
    exports.NUMBER_PICKER_VALUE_ACCESSOR = NUMBER_PICKER_VALUE_ACCESSOR;
    exports.NumberPickerComponent = NumberPickerComponent;
    exports.PageHeaderModule = PageHeaderModule;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageHeaderNavigationComponent = PageHeaderNavigationComponent;
    exports.PageHeaderIconMenuComponent = PageHeaderIconMenuComponent;
    exports.PageHeaderCustomMenuDirective = PageHeaderCustomMenuDirective;
    exports.PAGINATION_CONTROL_VALUE_ACCESSOR = PAGINATION_CONTROL_VALUE_ACCESSOR;
    exports.PaginationComponent = PaginationComponent;
    exports.PaginationModule = PaginationModule;
    exports.PopoverModule = PopoverModule;
    exports.PopoverComponent = PopoverComponent;
    exports.PopoverDirective = PopoverDirective;
    exports.ProgressBarModule = ProgressBarModule;
    exports.ProgressBarComponent = ProgressBarComponent;
    exports.RadioButtonModule = RadioButtonModule;
    exports.RADIOBUTTON_VALUE_ACCESSOR = RADIOBUTTON_VALUE_ACCESSOR;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.SearchBuilderFocusService = SearchBuilderFocusService;
    exports.SearchBuilderGroupComponent = SearchBuilderGroupComponent;
    exports.SearchBuilderGroupService = SearchBuilderGroupService;
    exports.SearchBuilderOutletDirective = SearchBuilderOutletDirective;
    exports.SearchBuilderComponent = SearchBuilderComponent;
    exports.SearchBuilderModule = SearchBuilderModule;
    exports.SearchBuilderService = SearchBuilderService;
    exports.BaseSearchComponent = BaseSearchComponent;
    exports.SearchDateRangeComponent = SearchDateRangeComponent;
    exports.SearchDateComponent = SearchDateComponent;
    exports.SearchSelectComponent = SearchSelectComponent;
    exports.SearchTextComponent = SearchTextComponent;
    exports.SelectListItemComponent = SelectListItemComponent;
    exports.SelectListComponent = SelectListComponent;
    exports.SelectListModule = SelectListModule;
    exports.SELECT_VALUE_ACCESSOR = SELECT_VALUE_ACCESSOR;
    exports.SelectComponent = SelectComponent;
    exports.SelectModule = SelectModule;
    exports.SidePanelComponent = SidePanelComponent;
    exports.SidePanelCloseDirective = SidePanelCloseDirective;
    exports.SidePanelModule = SidePanelModule;
    exports.SliderModule = SliderModule;
    exports.SliderComponent = SliderComponent;
    exports.SliderType = SliderType;
    exports.SliderStyle = SliderStyle;
    exports.SliderSize = SliderSize;
    exports.SliderCalloutTrigger = SliderCalloutTrigger;
    exports.SliderSnap = SliderSnap;
    exports.SliderTickType = SliderTickType;
    exports.SliderThumbEvent = SliderThumbEvent;
    exports.SliderThumb = SliderThumb;
    exports.SparkModule = SparkModule;
    exports.SparkComponent = SparkComponent;
    exports.SpinButtonModule = SpinButtonModule;
    exports.SPIN_BUTTON_VALUE_ACCESSOR = SPIN_BUTTON_VALUE_ACCESSOR;
    exports.SpinButtonComponent = SpinButtonComponent;
    exports.ResizableTableCellDirective = ResizableTableCellDirective;
    exports.ResizableTableColumnComponent = ResizableTableColumnComponent;
    exports.ResizableTableDirective = ResizableTableDirective;
    exports.TableModule = TableModule;
    exports.TabsetModule = TabsetModule;
    exports.TabsetComponent = TabsetComponent;
    exports.TabsetService = TabsetService;
    exports.TabComponent = TabComponent;
    exports.TabHeadingDirective = TabHeadingDirective;
    exports.TabFocusDirective = TabFocusDirective;
    exports.TagInputEvent = TagInputEvent;
    exports.TagInputComponent = TagInputComponent;
    exports.TagInputModule = TagInputModule;
    exports.TimePickerModule = TimePickerModule;
    exports.TIME_PICKER_VALUE_ACCESSOR = TIME_PICKER_VALUE_ACCESSOR;
    exports.TimePickerComponent = TimePickerComponent;
    exports.TimeFormatPipe = TimeFormatPipe;
    exports.TimelineModule = TimelineModule;
    exports.TimelineComponent = TimelineComponent;
    exports.TimelineEventComponent = TimelineEventComponent;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.ToolbarSearchModule = ToolbarSearchModule;
    exports.ToolbarSearchComponent = ToolbarSearchComponent;
    exports.ToolbarSearchFieldDirective = ToolbarSearchFieldDirective;
    exports.ToolbarSearchButtonDirective = ToolbarSearchButtonDirective;
    exports.TooltipModule = TooltipModule;
    exports.TooltipComponent = TooltipComponent;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipService = TooltipService;
    exports.TypeaheadOptionEvent = TypeaheadOptionEvent;
    exports.TypeaheadKeyService = TypeaheadKeyService;
    exports.TypeaheadComponent = TypeaheadComponent;
    exports.TypeaheadModule = TypeaheadModule;
    exports.VirtualScrollModule = VirtualScrollModule;
    exports.VirtualScrollComponent = VirtualScrollComponent;
    exports.VirtualScrollLoadingDirective = VirtualScrollLoadingDirective;
    exports.VirtualScrollLoadButtonDirective = VirtualScrollLoadButtonDirective;
    exports.VirtualScrollCellDirective = VirtualScrollCellDirective;
    exports.WizardModule = WizardModule;
    exports.WizardComponent = WizardComponent;
    exports.StepChangingEvent = StepChangingEvent;
    exports.WizardStepComponent = WizardStepComponent;
    exports.AccessibilityModule = AccessibilityModule;
    exports.FocusWithinDirective = FocusWithinDirective;
    exports.SplitterAccessibilityDirective = SplitterAccessibilityDirective;
    exports.TabbableListItemDirective = TabbableListItemDirective;
    exports.TabbableListDirective = TabbableListDirective;
    exports.TabbableListService = TabbableListService;
    exports.AutoGrowModule = AutoGrowModule;
    exports.AutoGrowDirective = AutoGrowDirective;
    exports.ClickOutsideModule = ClickOutsideModule;
    exports.ClickOutsideDirective = ClickOutsideDirective;
    exports.DragDirective = DragDirective;
    exports.DragModule = DragModule;
    exports.DragService = DragService;
    exports.DropDirective = DropDirective;
    exports.FixedHeaderTableModule = FixedHeaderTableModule;
    exports.FixedHeaderTableDirective = FixedHeaderTableDirective;
    exports.FloatLabelDirective = FloatLabelDirective;
    exports.FloatLabelModule = FloatLabelModule;
    exports.FocusIfDirective = FocusIfDirective;
    exports.FocusIfModule = FocusIfModule;
    exports.HelpCenterModule = HelpCenterModule;
    exports.HelpCenterService = HelpCenterService;
    exports.HelpCenterItemDirective = HelpCenterItemDirective;
    exports.HoverActionModule = HoverActionModule;
    exports.HoverActionContainerDirective = HoverActionContainerDirective;
    exports.HoverActionDirective = HoverActionDirective;
    exports.InfiniteScrollDirective = InfiniteScrollDirective;
    exports.InfiniteScrollLoadingEvent = InfiniteScrollLoadingEvent;
    exports.InfiniteScrollLoadedEvent = InfiniteScrollLoadedEvent;
    exports.InfiniteScrollLoadErrorEvent = InfiniteScrollLoadErrorEvent;
    exports.InfiniteScrollLoadButtonDirective = InfiniteScrollLoadButtonDirective;
    exports.InfiniteScrollLoadingDirective = InfiniteScrollLoadingDirective;
    exports.InfiniteScrollModule = InfiniteScrollModule;
    exports.LayoutSwitcherModule = LayoutSwitcherModule;
    exports.LayoutSwitcherDirective = LayoutSwitcherDirective;
    exports.LayoutSwitcherItemDirective = LayoutSwitcherItemDirective;
    exports.MenuNavigationItemDirective = MenuNavigationItemDirective;
    exports.MenuNavigationDirective = MenuNavigationDirective;
    exports.MenuNavigationModule = MenuNavigationModule;
    exports.ObserversModule = ObserversModule;
    exports.OverflowDirective = OverflowDirective;
    exports.ReorderableModule = ReorderableModule;
    exports.ReorderableDirective = ReorderableDirective;
    exports.ReorderableHandleDirective = ReorderableHandleDirective;
    exports.ReorderableModelDirective = ReorderableModelDirective;
    exports.ReorderableService = ReorderableService;
    exports.ReorderableGroup = ReorderableGroup;
    exports.ResizeService = ResizeService;
    exports.ResizeDirective = ResizeDirective;
    exports.ResizeModule = ResizeModule;
    exports.ScrollIntoViewIfModule = ScrollModule;
    exports.ScrollIntoViewIfDirective = ScrollIntoViewIfDirective;
    exports.ScrollIntoViewDirective = ScrollIntoViewDirective;
    exports.ScrollIntoViewService = ScrollIntoViewService;
    exports.ScrollModule = ScrollModule;
    exports.SelectionItemDirective = SelectionItemDirective;
    exports.SelectionDirective = SelectionDirective;
    exports.SelectionModule = SelectionModule;
    exports.SelectionService = SelectionService;
    exports.SelectionStrategy = SelectionStrategy;
    exports.TreeGridIndentDirective = TreeGridIndentDirective;
    exports.TreeGridState = TreeGridState;
    exports.TreeGridDirective = TreeGridDirective;
    exports.TreeGridModule = TreeGridModule;
    exports.ContactsNg1Component = ContactsNg1Component;
    exports.ExpandInputNg1Component = ExpandInputNg1Component;
    exports.FloatingActionButtonNg1Component = FloatingActionButtonNg1Component;
    exports.FlotNg1Component = FlotNg1Component;
    exports.GridNg1Component = GridNg1Component;
    exports.HierarchyBarNg1Component = HierarchyBarNg1Component;
    exports.MarqueeWizardNg1Component = MarqueeWizardNg1Component;
    exports.NestedDonutNg1Component = NestedDonutNg1Component;
    exports.OrganizationChartNg1Component = OrganizationChartNg1Component;
    exports.PartitionMapNg1Component = PartitionMapNg1Component;
    exports.PeityBarChartNg1Component = PeityBarChartNg1Component;
    exports.PeityLineChartNg1Component = PeityLineChartNg1Component;
    exports.PeityPieChartNg1Component = PeityPieChartNg1Component;
    exports.PeityUpdatingLineChartNg1Component = PeityUpdatingLineChartNg1Component;
    exports.SankeyNg1Component = SankeyNg1Component;
    exports.SearchToolbarNg1Component = SearchToolbarNg1Component;
    exports.SelectTableNg1Component = SelectTableNg1Component;
    exports.SLIDER_CHART_VALUE_ACCESSOR = SLIDER_CHART_VALUE_ACCESSOR;
    exports.SliderChartNg1Component = SliderChartNg1Component;
    exports.SocialChartNg1Component = SocialChartNg1Component;
    exports.SortDirectionToggleNg1Component = SortDirectionToggleNg1Component;
    exports.TreeGridNg1Component = TreeGridNg1Component;
    exports.ThumbnailNg1Component = ThumbnailNg1Component;
    exports.NavigationMenuService = NavigationMenuService;
    exports.navigationMenuServiceFactory = navigationMenuServiceFactory;
    exports.navigationMenuServiceProvider = navigationMenuServiceProvider;
    exports.PdfService = PdfService;
    exports.pdfServiceFactory = pdfServiceFactory;
    exports.pdfServiceProvider = pdfServiceProvider;
    exports.TimeAgoService = TimeAgoService;
    exports.timeAgoServiceFactory = timeAgoServiceFactory;
    exports.timeAgoServiceProvider = timeAgoServiceProvider;
    exports.HybridModule = HybridModule;
    exports.DurationPipeModule = DurationPipeModule;
    exports.DurationPipe = DurationPipe;
    exports.FileSizePipeModule = FileSizePipeModule;
    exports.FileSizePipe = FileSizePipe;
    exports.StringFilterPipe = StringFilterPipe;
    exports.StringFilterModule = StringFilterModule;
    exports.AudioServiceModule = AudioServiceModule;
    exports.AudioService = AudioService;
    exports.ColorServiceModule = ColorServiceModule;
    exports.ColorService = ColorService;
    exports.ThemeColor = ThemeColor;
    exports.colorSets = colorSets;
    exports.FrameExtractionModule = FrameExtractionModule;
    exports.FrameExtractionService = FrameExtractionService;
    exports.PersistentDataModule = PersistentDataModule;
    exports.PersistentDataService = PersistentDataService;
    exports.PersistentDataStorageType = PersistentDataStorageType;
    exports.StorageAdapter = StorageAdapter;
    exports.CookieAdapter = CookieAdapter;
    exports.LocalStorageAdapter = LocalStorageAdapter;
    exports.SessionStorageAdapter = SessionStorageAdapter;
    exports.d = DayViewComponent;
    exports.e = DayViewService;
    exports.c = HeaderComponent;
    exports.f = MonthViewComponent;
    exports.g = MonthViewService;
    exports.j = TimeViewComponent;
    exports.h = YearViewComponent;
    exports.i = YearViewService;
    exports.m = FacetCheckListItemComponent;
    exports.n = FacetTypeaheadListItemComponent;
    exports.q = FloatingActionButtonsService;
    exports.s = MarqueeWizardService;
    exports.t = MediaPlayerService;
    exports.u = NavigationLinkDirective;
    exports.x = PageHeaderNavigationDropdownItemComponent;
    exports.w = PageHeaderNavigationItemComponent;
    exports.y = PageHeaderNavigationSecondaryItemDirective;
    exports.v = PageHeaderService;
    exports.r = SidePanelService;
    exports.z = ResizableTableService;
    exports.l = TypeaheadHighlightDirective;
    exports.k = TypeaheadService;
    exports.ba = HoverActionService;
    exports.p = MenuNavigationToggleDirective;
    exports.o = MenuNavigationService;
    exports.bb = TreeGridRowDirective;
    exports.bc = TreeGridService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXgtYXNwZWN0cy11eC1hc3BlY3RzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24tcGFuZWwvYWNjb3JkaW9uLXBhbmVsLWhlYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi1wYW5lbC9hY2NvcmRpb24tcGFuZWwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLm1vZHVsZS50cyIsbnVsbCwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZXNpemUvcmVzaXplLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi1jb250ZW50LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYnMuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jYXJkLXRhYnMvY2FyZC10YWJzZXQvY2FyZC10YWJzZXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY2FyZC10YWJzL2NhcmQtdGFicy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvY29sb3IvY29sb3Iuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbG9yLXBpY2tlci9jb2xvci1waWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS9mb2N1cy13aXRoaW4vZm9jdXMtd2l0aGluLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvc3BsaXR0ZXIvc3BsaXR0ZXItYWNjZXNzaWJpbGl0eS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tbW9uL29wZXJhdG9ycy90aWNrLm9wZXJhdG9yLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS90YWJiYWJsZS1saXN0L3RhYmJhYmxlLWxpc3Quc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvdGFiYmFibGUtbGlzdC90YWJiYWJsZS1saXN0LWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS90YWJiYWJsZS1saXN0L3RhYmJhYmxlLWxpc3QuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS9hY2Nlc3NpYmlsaXR5Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL251bWJlci1waWNrZXIvbnVtYmVyLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9udW1iZXItcGlja2VyL251bWJlci1waWNrZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2xvci1waWNrZXIvY29sb3ItcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbHVtbi1zb3J0aW5nL2NvbHVtbi1zb3J0aW5nLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbHVtbi1zb3J0aW5nL2NvbHVtbi1zb3J0aW5nLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbHVtbi1zb3J0aW5nL2NvbHVtbi1zb3J0aW5nLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC1zdWJqZWN0LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LXV0aWxzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LXpvbmUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQtem9uZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2ludGVyZmFjZXMvY29uZHVpdC1wcm9wZXJ0aWVzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LmRlY29yYXRvci50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGFzaGJvYXJkL3dpZGdldC9kYXNoYm9hcmQtd2lkZ2V0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2RyYWcvZHJhZy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvZHJhZy9kcmFnLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2RyYWcvZHJvcC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9kcmFnL2RyYWcubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2RyYWctaGFuZGxlL2RyYWctaGFuZGxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXRlLXRpbWUtcGlja2VyLnV0aWxzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXRlLXRpbWUtcGlja2VyLmNvbmZpZy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXRlLXRpbWUtcGlja2VyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RpbWUtcGlja2VyL3RpbWUtZm9ybWF0LnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RheS12aWV3L2RheS12aWV3LnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RheS12aWV3L2RheS12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvaGVhZGVyL2hlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL21vbnRoLXZpZXcvbW9udGgtdmlldy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9tb250aC12aWV3L21vbnRoLXZpZXcuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci90aW1lLXZpZXcvdGltZS12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIveWVhci12aWV3L3llYXItdmlldy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci95ZWFyLXZpZXcveWVhci12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2ZvY3VzLWlmL2ZvY3VzLWlmLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2ZvY3VzLWlmL2ZvY3VzLWlmLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9lYm94L2Vib3guY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZWJveC9lYm94Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLWtleS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2Nyb2xsL3Njcm9sbC1pbnRvLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LWlmLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC1oaWdobGlnaHQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS1oYW5kbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvcmVvcmRlcmFibGUtbW9kZWwuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvZHJhZ3VsYS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtZXZlbnRzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2Jhc2UvZmFjZXQtaGVhZGVyL2ZhY2V0LWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtY2hlY2stbGlzdC9jaGVjay1saXN0LWl0ZW0vZmFjZXQtY2hlY2stbGlzdC1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZhY2V0cy9mYWNldC1jaGVjay1saXN0L2ZhY2V0LWNoZWNrLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LXR5cGVhaGVhZC1saXN0L3R5cGVhaGVhZC1saXN0LWl0ZW0vZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtdHlwZWFoZWFkLWxpc3QvZmFjZXQtdHlwZWFoZWFkLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0cy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvbW9kZWxzL2ZhY2V0LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9ldmVudHMvZmlsdGVyLWFkZC1ldmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZXZlbnRzL2ZpbHRlci1yZW1vdmUtYWxsLWV2ZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9ldmVudHMvZmlsdGVyLXJlbW92ZS1ldmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1kcm9wZG93bi9maWx0ZXItZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXItZHluYW1pYy9maWx0ZXItZHluYW1pYy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1keW5hbWljL2ZpbHRlci10eXBlYWhlYWQtaGlnaGxpZ2h0LnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZsaXBwYWJsZS1jYXJkL2ZsaXBwYWJsZS1jYXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZsaXBwYWJsZS1jYXJkL2ZsaXBwYWJsZS1jYXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvY2xpY2stb3V0c2lkZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlL2NsaWNrLW91dHNpZGUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcG9wb3Zlci9wb3BvdmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BvcG92ZXIvcG9wb3Zlci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wb3BvdmVyL3BvcG92ZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9oaWVyYXJjaHktYmFyL2hpZXJhcmNoeS1iYXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2l0ZW0tZGlzcGxheS1wYW5lbC9pdGVtLWRpc3BsYXktcGFuZWwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaXRlbS1kaXNwbGF5LXBhbmVsL2l0ZW0tZGlzcGxheS1wYW5lbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy93aXphcmQvd2l6YXJkLXN0ZXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvd2l6YXJkL3dpemFyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy93aXphcmQvd2l6YXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC1zdGVwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL2V4dGVuc2lvbnMvYmFzZS1leHRlbnNpb24uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL2NvbG9yL2NvbG9yLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy9jb250cm9scy9jb250cm9scy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy9jb250cm9scy9jdXN0b20tY29udHJvbC9jdXN0b20tY29udHJvbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy90aW1lbGluZS90aW1lbGluZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvYXVkaW8vYXVkaW8uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9hdWRpby9hdWRpby5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvbWVkaWEtcGxheWVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9kdXJhdGlvbi9kdXJhdGlvbi5waXBlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL2R1cmF0aW9uL2R1cmF0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9maWxlLXNpemUvZmlsZS1zaXplLnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZmlsZS1zaXplL2ZpbGUtc2l6ZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvbWVkaWEtcGxheWVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25hdmlnYXRpb24vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25hdmlnYXRpb24vbmF2aWdhdGlvbi1saW5rL25hdmlnYXRpb24tbGluay5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24tbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL2N1c3RvbS1tZW51L2N1c3RvbS1tZW51LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9pY29uLW1lbnUvaWNvbi1tZW51LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL25hdmlnYXRpb24vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9uYXZpZ2F0aW9uL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLXNlY29uZGFyeS1pdGVtL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWJzZXQuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWIvdGFiLWZvY3VzLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWIvdGFiLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWIvdGFiLWhlYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYnNldC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJzZXQvdGFic2V0Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdpbmF0aW9uL3BhZ2luYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcHJvZ3Jlc3MtYmFyL3Byb2dyZXNzLWJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3JhZGlvYnV0dG9uL3JhZGlvYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3JhZGlvYnV0dG9uL3JhZGlvYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLWZvY3VzLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItZ3JvdXAvc2VhcmNoLWJ1aWxkZXItZ3JvdXAuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLWdyb3VwL3NlYXJjaC1idWlsZGVyLWdyb3VwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLW91dGxldC9zZWFyY2gtYnVpbGRlci1vdXRsZXQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWctaW5wdXQvdGFnLWlucHV0LWV2ZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFnLWlucHV0L3RhZy1pbnB1dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWctaW5wdXQvdGFnLWlucHV0Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWNvbXBvbmVudHMvYmFzZS1zZWFyY2guY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWNvbXBvbmVudHMvZGF0ZS1yYW5nZS9kYXRlLXJhbmdlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL2RhdGUvZGF0ZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL3RleHQvdGV4dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9yb3ctc2VsZWN0aW9uLnN0cmF0ZWd5LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3N0cmF0ZWdpZXMvcm93LWFsdC1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9zaW1wbGUtc2VsZWN0aW9uLnN0cmF0ZWd5LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0LWxpc3Qvc2VsZWN0LWxpc3QtaXRlbS9zZWxlY3QtbGlzdC1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlbGVjdC1saXN0L211bHRpcGxlLXNlbGVjdC1saXN0LnN0cmF0ZWd5LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0LWxpc3Qvc2luZ2xlLXNlbGVjdC1saXN0LnN0cmF0ZWd5LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0LWxpc3Qvc2VsZWN0LWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0LWxpc3Qvc2VsZWN0LWxpc3QubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLWNsb3NlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zcGFyay9zcGFyay5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zcGFyay9zcGFyay5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJsZS90YWJsZS1jb2x1bW4tcmVzaXplL3Jlc2l6YWJsZS10YWJsZS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFibGUvdGFibGUtY29sdW1uLXJlc2l6ZS9yZXNpemFibGUtdGFibGUtY2VsbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJsZS90YWJsZS1jb2x1bW4tcmVzaXplL3Jlc2l6YWJsZS10YWJsZS1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFibGUvdGFibGUtY29sdW1uLXJlc2l6ZS9yZXNpemFibGUtdGFibGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFibGUvdGFibGUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUtZXZlbnQvdGltZWxpbmUtZXZlbnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9nZ2xlc3dpdGNoL3RvZ2dsZXN3aXRjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b2dnbGVzd2l0Y2gvdG9nZ2xlc3dpdGNoLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLWJ1dHRvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC1maWVsZC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvZGlyZWN0aXZlcy92aXJ0dWFsLXNjcm9sbC1sb2FkLWJ1dHRvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvdmlydHVhbC1zY3JvbGwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvdmlydHVhbC1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYXV0by1ncm93L2F1dG8tZ3Jvdy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9hdXRvLWdyb3cvYXV0by1ncm93Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2ZpeGVkLWhlYWRlci10YWJsZS9maXhlZC1oZWFkZXItdGFibGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvZml4ZWQtaGVhZGVyLXRhYmxlL2ZpeGVkLWhlYWRlci10YWJsZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mbG9hdC1sYWJlbC9mbG9hdC1sYWJlbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mbG9hdC1sYWJlbC9mbG9hdC1sYWJlbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvaGVscC1jZW50ZXIvaGVscC1jZW50ZXItaXRlbS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLWNvbnRhaW5lci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2xheW91dC1zd2l0Y2hlci9sYXlvdXQtc3dpdGNoZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9vYnNlcnZlcnMvb3ZlcmZsb3cvb3ZlcmZsb3ctb2JzZXJ2ZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvb2JzZXJ2ZXJzL29ic2VydmVycy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3RyZWUtZ3JpZC90cmVlLWdyaWQtc3RhdGUuY2xhc3MudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLXJvdy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLWluZGVudC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3RyZWUtZ3JpZC90cmVlLWdyaWQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2NvbnRhY3RzL2NvbnRhY3RzLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9leHBhbmQtaW5wdXQvZXhwYW5kLWlucHV0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9uL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2Zsb3QvZmxvdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvZ3JpZC9ncmlkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9oaWVyYXJjaHktYmFyL2hpZXJhcmNoeS1iYXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9uZXN0ZWQtZG9udXQvbmVzdGVkLWRvbnV0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9vcmdhbml6YXRpb24tY2hhcnQvb3JnYW5pemF0aW9uLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wYXJ0aXRpb24tbWFwL3BhcnRpdGlvbi1tYXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LWJhci1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktbGluZS1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktcGllLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS11cGRhdGluZy1saW5lLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zYW5rZXktY2hhcnQvc2Fua2V5LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zZWFyY2gtdG9vbGJhci9zZWFyY2gtdG9vbGJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2VsZWN0LXRhYmxlL3NlbGVjdC10YWJsZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2xpZGVyLWNoYXJ0L3NsaWRlci1jaGFydC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc29jaWFsLWNoYXJ0L3NvY2lhbC1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc29ydC1kaXJlY3Rpb24tdG9nZ2xlL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvdGh1bWJuYWlsL3RodW1ibmFpbC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL3NlcnZpY2VzL25hdmlnYXRpb24tbWVudS9uYXZpZ2F0aW9uLW1lbnUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvc2VydmljZXMvcGRmL3BkZi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9zZXJ2aWNlcy90aW1lLWFnby90aW1lLWFnby5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9oeWJyaWQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL3N0cmluZy1maWx0ZXIvc3RyaW5nLWZpbHRlci5waXBlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL3N0cmluZy1maWx0ZXIvc3RyaW5nLWZpbHRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL2FkYXB0ZXJzL2Nvb2tpZS1hZGFwdGVyLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9hZGFwdGVycy9sb2NhbC1zdG9yYWdlLWFkYXB0ZXIudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL2FkYXB0ZXJzL3Nlc3Npb24tc3RvcmFnZS1hZGFwdGVyLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9wZXJzaXN0ZW50LWRhdGEuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvcGVyc2lzdGVudC1kYXRhLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvYWRhcHRlcnMvc3RvcmFnZS1hZGFwdGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICd1eC1hY2NvcmRpb24tcGFuZWwtaGVhZGVyJ1xufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25QYW5lbEhlYWRpbmdEaXJlY3RpdmUge1xuXG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25TZXJ2aWNlIHtcblxuICAgIGNvbGxhcHNlT3RoZXJzOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29sbGFwc2UgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29sbGFwc2VBbGwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29sbGFwc2UubmV4dCgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjY29yZGlvblNlcnZpY2UgfSBmcm9tICcuLi9hY2NvcmRpb24uc2VydmljZSc7XG5cbmxldCB1bmlxdWVJZDogbnVtYmVyID0gMTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1hY2NvcmRpb24tcGFuZWwnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9hY2NvcmRpb24tcGFuZWwuY29tcG9uZW50Lmh0bWwnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnLFxuICAgICAgICAncm9sZSc6ICd0YWInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25QYW5lbENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBwYW5lbElkOiBzdHJpbmcgPSBgdXgtYWNjb3JkaW9uLXBhbmVsLSR7dW5pcXVlSWQrK31gO1xuICAgIEBJbnB1dCgpIGhlYWRpbmdJZDogc3RyaW5nID0gYCR7dGhpcy5wYW5lbElkfS1oZWFkaW5nYDtcblxuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaGVhZGluZzogc3RyaW5nO1xuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnY2xhc3MucGFuZWwtb3BlbicpIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgYWNjb3JkaW9uOiBBY2NvcmRpb25TZXJ2aWNlKSB7XG4gICAgICAgIGFjY29yZGlvbi5jb2xsYXBzZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb2xsYXBzZSgpKTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBvdGhlcnNcbiAgICAgICAgaWYgKHRoaXMuYWNjb3JkaW9uLmNvbGxhcHNlT3RoZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5jb2xsYXBzZUFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG5ldyBleHBhbmRlZCBzdGF0ZVxuICAgICAgICB0aGlzLmV4cGFuZCgpO1xuICAgIH1cblxuICAgIGV4cGFuZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgPT09IGZhbHNlICYmIHRoaXMuZXhwYW5kZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UubmV4dCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbGxhcHNlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgdGhpcy5leHBhbmRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5uZXh0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjY29yZGlvblNlcnZpY2UgfSBmcm9tICcuL2FjY29yZGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1hY2NvcmRpb24nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9hY2NvcmRpb24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogWyBBY2NvcmRpb25TZXJ2aWNlIF0sXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAncGFuZWwtZ3JvdXAnLFxuICAgICAgICAncm9sZSc6ICd0YWJsaXN0JyxcbiAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogJ3RydWUnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25Db21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc2V0IGNvbGxhcHNlT3RoZXJzKGNvbGxhcHNlT3RoZXJzOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2FjY29yZGlvbi5jb2xsYXBzZU90aGVycyA9IGNvbGxhcHNlT3RoZXJzO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2FjY29yZGlvbjogQWNjb3JkaW9uU2VydmljZSkgeyB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY2NvcmRpb25QYW5lbEhlYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2FjY29yZGlvbi1wYW5lbC9hY2NvcmRpb24tcGFuZWwtaGVhZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQWNjb3JkaW9uUGFuZWxDb21wb25lbnQgfSBmcm9tICcuL2FjY29yZGlvbi1wYW5lbC9hY2NvcmRpb24tcGFuZWwuY29tcG9uZW50JztcbmltcG9ydCB7IEFjY29yZGlvbkNvbXBvbmVudCB9IGZyb20gJy4vYWNjb3JkaW9uLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBBY2NvcmRpb25Db21wb25lbnQsXG4gICAgICAgIEFjY29yZGlvblBhbmVsQ29tcG9uZW50LFxuICAgICAgICBBY2NvcmRpb25QYW5lbEhlYWRpbmdEaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQWNjb3JkaW9uQ29tcG9uZW50LFxuICAgICAgICBBY2NvcmRpb25QYW5lbENvbXBvbmVudCxcbiAgICAgICAgQWNjb3JkaW9uUGFuZWxIZWFkaW5nRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25Nb2R1bGUgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWJyZWFkY3J1bWJzJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2JyZWFkY3J1bWJzLmNvbXBvbmVudC5odG1sJ1xufSlcblxuZXhwb3J0IGNsYXNzIEJyZWFkY3J1bWJzQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGNydW1iczogQnJlYWRjcnVtYltdO1xuXG4gICAgY2xpY2tDcnVtYihldmVudDogTW91c2VFdmVudCwgY3J1bWI6IEJyZWFkY3J1bWIpIHtcbiAgICAgICAgaWYgKGNydW1iLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIGNydW1iLm9uQ2xpY2suY2FsbChudWxsLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJlYWRjcnVtYiB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICByb3V0ZXJMaW5rPzogc3RyaW5nO1xuICAgIGZyYWdtZW50Pzogc3RyaW5nO1xuICAgIHF1ZXJ5UGFyYW1zPzogYW55O1xuICAgIG9uQ2xpY2s/OiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQ7XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQnJlYWRjcnVtYnNDb21wb25lbnQgfSBmcm9tICcuL2JyZWFkY3J1bWJzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSwgXG4gICAgICAgIFJvdXRlck1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW0JyZWFkY3J1bWJzQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtCcmVhZGNydW1ic0NvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYnNNb2R1bGUgeyB9XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMvUmVwbGF5U3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZXNpemVTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuZWxlbWVudERpZFJlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICBwcml2YXRlIF90YXJnZXRzID0gbmV3IFdlYWtNYXA8SFRNTEVsZW1lbnQsIFJlcGxheVN1YmplY3Q8UmVzaXplRGltZW5zaW9ucz4+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF96b25lOiBOZ1pvbmUpIHt9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGFkZFJlc2l6ZUxpc3RlbmVyKHRhcmdldDogSFRNTEVsZW1lbnQpOiBSZXBsYXlTdWJqZWN0PFJlc2l6ZURpbWVuc2lvbnM+IHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRhcmdldCkpO1xuXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRzLmhhcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cy5nZXQodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgUmVwbGF5U3ViamVjdDxSZXNpemVEaW1lbnNpb25zPigpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0cy5zZXQodGFyZ2V0LCBlbWl0dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlUmVzaXplTGlzdGVuZXIodGFyZ2V0OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci51bm9ic2VydmUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGVsZW1lbnREaWRSZXNpemUoZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRzLmhhcyhlbnRyeS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzLl90YXJnZXRzLmdldChlbnRyeS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLm5leHQoeyB3aWR0aDogKGVudHJ5LnRhcmdldCBhcyBIVE1MRWxlbWVudCkub2Zmc2V0V2lkdGgsIGhlaWdodDogKGVudHJ5LnRhcmdldCBhcyBIVE1MRWxlbWVudCkub2Zmc2V0SGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2l6ZURpbWVuc2lvbnMge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFJlc2l6ZURpbWVuc2lvbnMsIFJlc2l6ZVNlcnZpY2UgfSBmcm9tICcuL3Jlc2l6ZS5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhSZXNpemVdJyxcbiAgICBwcm92aWRlcnM6IFtSZXNpemVTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBSZXNpemVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB0aHJvdHRsZTogbnVtYmVyID0gMDtcbiAgICBAT3V0cHV0KCkgdXhSZXNpemU6IEV2ZW50RW1pdHRlcjxSZXNpemVEaW1lbnNpb25zPiA9IG5ldyBFdmVudEVtaXR0ZXI8UmVzaXplRGltZW5zaW9ucz4oKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3Jlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KVxuICAgICAgICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKHRoaXMudGhyb3R0bGUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IFJlc2l6ZURpbWVuc2lvbnMpID0+IHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy51eFJlc2l6ZS5lbWl0KGV2ZW50KSkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBSZXNpemVEaXJlY3RpdmUgfSBmcm9tICcuL3Jlc2l6ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4vcmVzaXplLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtSZXNpemVEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW1Jlc2l6ZURpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbUmVzaXplU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgUmVzaXplTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eENhcmRUYWJDb250ZW50XSdcbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFiL2NhcmQtdGFiLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDYXJkVGFic1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHRhYiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PENhcmRUYWJDb21wb25lbnQ+KG51bGwpO1xuICB0YWJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Q2FyZFRhYkNvbXBvbmVudFtdPihbXSk7XG4gIHBvc2l0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPigndG9wJyk7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAvLyB3aGVuIGEgdGFiIGlzIGFkZGVkIG9yIHJlbW92ZWQgZW5zdXJlIHdlIGFsd2F5cyBzZWxlY3Qgb25lIGlmIGFueSBhcmUgYXZhaWxhYmxlXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy50YWJzJC5waXBlKFxuICAgICAgZmlsdGVyKHRhYnMgPT4gIXRoaXMudGFiJC52YWx1ZSB8fCAhdGFicy5maW5kKHRhYiA9PiB0YWIgPT09IHRoaXMudGFiJC52YWx1ZSkpLFxuICAgICkuc3Vic2NyaWJlKHRhYnMgPT4gdGhpcy50YWIkLm5leHQodGFicy5sZW5ndGggPiAwID8gdGFic1swXSA6IG51bGwpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRhYiB0byB0aGUgbGlzdCBvZiB0YWJzXG4gICAqL1xuICBhZGRUYWIodGFiOiBDYXJkVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy50YWJzJC5uZXh0KFsuLi50aGlzLnRhYnMkLnZhbHVlLCB0YWJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWIgZnJvbSB0aGUgbGlzdFxuICAgKi9cbiAgcmVtb3ZlVGFiKHRhYjogQ2FyZFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgIHRoaXMudGFicyQubmV4dCh0aGlzLnRhYnMkLnZhbHVlLmZpbHRlcihfdGFiID0+IF90YWIgIT09IHRhYikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgdGFiXG4gICAqL1xuICBzZWxlY3QodGFiOiBDYXJkVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy50YWIkLm5leHQodGFiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YWIgY29udGVudFxuICAgKi9cbiAgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24kLm5leHQocG9zaXRpb24pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FyZFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi4vY2FyZC10YWJzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmUgfSBmcm9tICcuL2NhcmQtdGFiLWNvbnRlbnQuZGlyZWN0aXZlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtY2FyZC10YWInLFxuICB0ZW1wbGF0ZVVybDogJy4vY2FyZC10YWIuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDYXJkVGFiQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBhY3RpdmUkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5fdGFiU2VydmljZS50YWIkLnBpcGUobWFwKHRhYiA9PiB0YWIgPT09IHRoaXMpKTtcbiAgQENvbnRlbnRDaGlsZChDYXJkVGFiQ29udGVudERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBjb250ZW50OiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYlNlcnZpY2U6IENhcmRUYWJzU2VydmljZSkge1xuICAgIHRoaXMuX3RhYlNlcnZpY2UuYWRkVGFiKHRoaXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fdGFiU2VydmljZS5yZW1vdmVUYWIodGhpcyk7XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplRGltZW5zaW9ucyB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplJztcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuLi9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ2FyZFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi4vY2FyZC10YWJzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1jYXJkLXRhYnNldCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9jYXJkLXRhYnNldC5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW0NhcmRUYWJzU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFRhYnNldENvbXBvbmVudCB7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIEBJbnB1dCgpIHNldCBwb3NpdGlvbihkaXJlY3Rpb246IHN0cmluZykge1xuICAgIHRoaXMudGFiU2VydmljZS5zZXRQb3NpdGlvbihkaXJlY3Rpb24pO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudGFiU2VydmljZS5wb3NpdGlvbiQuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ3RhYmxpc3QnKSB0YWJsaXN0OiBFbGVtZW50UmVmO1xuXG4gIG9mZnNldDogbnVtYmVyID0gMDtcbiAgYm91bmRzOiBDYXJkVGFic0JvdW5kcyA9IHsgbG93ZXI6IDAsIHVwcGVyOiAwIH07XG5cbiAgcHJpdmF0ZSBfd2lkdGg6IG51bWJlcjtcbiAgcHJpdmF0ZSBfaW5uZXJXaWR0aDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWJTZXJ2aWNlOiBDYXJkVGFic1NlcnZpY2UpIHt9XG5cbiAgc2VsZWN0KHRhYjogQ2FyZFRhYkNvbXBvbmVudCwgZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAvLyBzZWxlY3QgdGhlIHRhYlxuICAgIHRoaXMudGFiU2VydmljZS5zZWxlY3QodGFiKTtcblxuICAgIC8vIGVuc3VyZSB0aGUgdGFiIGlzIG1vdmVkIGludG8gdmlldyBpZiByZXF1aXJlZFxuICAgIHRoaXMubW92ZUludG9WaWV3KGVsZW1lbnQpO1xuICB9XG5cbiAgcmVzaXplKGRpbWVuc2lvbnM6IFJlc2l6ZURpbWVuc2lvbnMpOiB2b2lkIHtcbiAgICB0aGlzLl93aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgdGhpcy5faW5uZXJXaWR0aCA9IHRoaXMudGFibGlzdC5uYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoO1xuXG4gICAgdGhpcy5ib3VuZHMubG93ZXIgPSAwO1xuICAgIHRoaXMuYm91bmRzLnVwcGVyID0gLSh0aGlzLl9pbm5lcldpZHRoIC0gdGhpcy5fd2lkdGgpO1xuICB9XG5cbiAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5fd2lkdGg7XG5cbiAgICAvLyBlbnN1cmUgaXQgcmVtYWlucyB3aXRoaW4gdGhlIGFsbG93ZWQgYm91bmRzXG4gICAgdGhpcy5vZmZzZXQgPSBNYXRoLm1pbih0aGlzLm9mZnNldCwgdGhpcy5ib3VuZHMubG93ZXIpO1xuICB9XG5cbiAgbmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLm9mZnNldCAtPSB0aGlzLl93aWR0aDtcblxuICAgIC8vIGVuc3VyZSBpdCByZW1haW5zIHdpdGhpbiB0aGUgYWxsb3dlZCBib3VuZHNcbiAgICB0aGlzLm9mZnNldCA9IE1hdGgubWF4KHRoaXMub2Zmc2V0LCB0aGlzLmJvdW5kcy51cHBlcik7XG4gIH1cblxuICBwcml2YXRlIG1vdmVJbnRvVmlldyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuXG4gICAgLy8gaWYgd2UgZG9udCBoYXZlIHRoZSBkaW1lbnNpb25zIHdlIGNhbnQgY2hlY2tcbiAgICBpZiAoIXRoaXMuX3dpZHRoIHx8ICF0aGlzLl9pbm5lcldpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBjdXJyZW50IGVsZW1lbnQgYm91bmRzXG4gICAgY29uc3QgeyBvZmZzZXRMZWZ0LCBvZmZzZXRXaWR0aCB9ID0gZWxlbWVudDtcbiAgICBjb25zdCB7IG1hcmdpbkxlZnQsIG1hcmdpblJpZ2h0IH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB2aXNpYmxlIGFyZWFcbiAgICBjb25zdCB2aWV3cG9ydFN0YXJ0ID0gTWF0aC5hYnModGhpcy5vZmZzZXQpO1xuICAgIGNvbnN0IHZpZXdwb3J0RW5kID0gdmlld3BvcnRTdGFydCArIHRoaXMuX3dpZHRoO1xuICAgIGNvbnN0IGNhcmRXaWR0aCA9IHBhcnNlRmxvYXQobWFyZ2luTGVmdCkgKyBvZmZzZXRXaWR0aCArIHBhcnNlRmxvYXQobWFyZ2luUmlnaHQpO1xuXG4gICAgLy8gaWYgd2UgbmVlZCB0byBtb3ZlIHRvIHRoZSBsZWZ0IC0gZmlndXJlIG91dCBob3cgbXVjaFxuICAgIGlmIChvZmZzZXRMZWZ0IDwgdmlld3BvcnRTdGFydCkge1xuICAgICAgdGhpcy5vZmZzZXQgLT0gKG9mZnNldExlZnQgLSBwYXJzZUZsb2F0KG1hcmdpbkxlZnQpKSAtIHZpZXdwb3J0U3RhcnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIGlmIHdlIG5lZWQgdG8gbW92ZSB0byB0aGUgcmlnaHQgLSBmaWd1cmUgb3V0IGhvdyBtdWNoXG4gICAgaWYgKChvZmZzZXRMZWZ0ICsgY2FyZFdpZHRoKSA+IHZpZXdwb3J0RW5kKSB7XG4gICAgICB0aGlzLm9mZnNldCAtPSAob2Zmc2V0TGVmdCArIGNhcmRXaWR0aCkgLSB2aWV3cG9ydEVuZDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXJkVGFic0JvdW5kcyB7XG4gIGxvd2VyOiBudW1iZXI7XG4gIHVwcGVyOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XHJcbmltcG9ydCB7IENhcmRUYWJDb250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi9jYXJkLXRhYi9jYXJkLXRhYi1jb250ZW50LmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFiL2NhcmQtdGFiLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IENhcmRUYWJzZXRDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFic2V0L2NhcmQtdGFic2V0LmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIENvbW1vbk1vZHVsZSxcclxuICAgIFJlc2l6ZU1vZHVsZVxyXG4gIF0sXHJcbiAgZGVjbGFyYXRpb25zOiBbQ2FyZFRhYnNldENvbXBvbmVudCwgQ2FyZFRhYkNvbXBvbmVudCwgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmVdLFxyXG4gIGV4cG9ydHM6IFtDYXJkVGFic2V0Q29tcG9uZW50LCBDYXJkVGFiQ29tcG9uZW50LCBDYXJkVGFiQ29udGVudERpcmVjdGl2ZV1cclxufSlcclxuZXhwb3J0IGNsYXNzIENhcmRUYWJzTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja2JveENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbmxldCB1bmlxdWVDaGVja2JveElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1jaGVja2JveCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NoZWNrYm94LmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBwcml2YXRlIF9jaGVja2JveElkOiBzdHJpbmcgPSBgdXgtY2hlY2tib3gtJHsrK3VuaXF1ZUNoZWNrYm94SWR9YDtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl9jaGVja2JveElkO1xuICAgIEBJbnB1dCgpIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgY2xpY2thYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzaW1wbGlmaWVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaW5kZXRlcm1pbmF0ZVZhbHVlOiBhbnkgPSAtMTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nID0gbnVsbDtcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgaXQgaXMgaW4gdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGVcbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gdGhpcy5fdmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gdGhpcy5pbmRldGVybWluYXRlID8gJ21peGVkJyA6IHRoaXMuX3ZhbHVlO1xuXG4gICAgICAgIC8vIGludm9rZSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRJZCgpOiBzdHJpbmcgeyBcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fY2hlY2tib3hJZH0taW5wdXRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnkgPSBmYWxzZTtcblxuICAgIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhcmlhQ2hlY2tlZDogYm9vbGVhbiB8IHN0cmluZztcbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLnZhbHVlID0gIXRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25zIHJlcXVpcmVkIHRvIHVwZGF0ZSBuZ01vZGVsXG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2hlY2tib3hDb21wb25lbnQgfSBmcm9tICcuL2NoZWNrYm94LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlXSxcbiAgICBleHBvcnRzOiBbQ2hlY2tib3hDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0NoZWNrYm94Q29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja2JveE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yQ2xhc3NTZXQsIENvbG9yVmFsdWVTZXQgfSBmcm9tICcuL2NvbG9yLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29sb3JTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX2h0bWw6IHN0cmluZztcbiAgICBwcml2YXRlIF9lbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9jb2xvcnM6IFRoZW1lQ29sb3JzO1xuICAgIHByaXZhdGUgX2NvbG9yU2V0OiBhbnkgPSBjb2xvclNldHMua2VwcGVsO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnNba2V5XSA9IHRoaXMuZ2V0Q29sb3JWYWx1ZUJ5SGV4KHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENvbG9ycygpIHtcblxuICAgICAgICB0aGlzLl9odG1sID0gJyc7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0bWwgKz0gJzxkaXYgY2xhc3M9XCInICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtrZXldICsgJy1jb2xvclwiPjwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lID0gJ2NvbG9yLWNoYXJ0JztcbiAgICAgICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9odG1sO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXRba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlQnlIZXgoY29sb3I6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCBoZXggPSBjb2xvci5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHIsIGcsIGIsICcxJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlKGNvbG9yOiBDb2xvcklkZW50aWZpZXIpOiBUaGVtZUNvbG9yIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtjb2xvcl0gKyAnLWNvbG9yJyk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHJnYmEgPSBjb2xvclZhbHVlLm1hdGNoKC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvKTtcblxuICAgICAgICByZXR1cm4gbmV3IFRoZW1lQ29sb3IocmdiYVsxXSwgcmdiYVsyXSwgcmdiYVszXSwgcmdiYVs0XSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3IoY29sb3I6IENvbG9ySWRlbnRpZmllcik6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCB0aGVtZUNvbG9yID0gdGhpcy5fY29sb3JzW3RoaXMucmVzb2x2ZUNvbG9yTmFtZShjb2xvcildO1xuICAgICAgICBpZiAoIXRoZW1lQ29sb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sb3Igbm90IGZvdW5kOiAnICsgY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHRoZW1lQ29sb3IuZ2V0UmVkKCksIHRoZW1lQ29sb3IuZ2V0R3JlZW4oKSwgdGhlbWVDb2xvci5nZXRCbHVlKCksIHRoZW1lQ29sb3IuZ2V0QWxwaGEoKSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3JTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvclNldDtcbiAgICB9XG5cbiAgICBzZXRDb2xvclNldChjb2xvclNldDogQ29sb3JTZXQpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTZXQgPSBjb2xvclNldDtcbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlQnlIZXgodGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9yTmFtZSA9IHRoaXMucmVzb2x2ZUNvbG9yTmFtZSh2YWx1ZSk7XG5cbiAgICAgICAgZm9yIChsZXQgY29sb3IgaW4gdGhpcy5fY29sb3JzKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lID09PSBjb2xvci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sb3IoY29sb3JOYW1lKS50b1JnYmEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlQ29sb3JOYW1lKHZhbHVlOiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHMrL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUaGVtZUNvbG9yIHtcblxuICAgIHByaXZhdGUgX3I6IHN0cmluZztcbiAgICBwcml2YXRlIF9nOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfYjogc3RyaW5nO1xuICAgIHByaXZhdGUgX2E6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHI6IHN0cmluZywgZzogc3RyaW5nLCBiOiBzdHJpbmcsIGE6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yID0gcjtcbiAgICAgICAgdGhpcy5fZyA9IGc7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9hID0gYSA9PT0gdW5kZWZpbmVkID8gJzEnIDogYTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2UodmFsdWU6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBsZXQgciwgZywgYiwgYSA9ICcxJztcblxuICAgICAgICBjb25zdCByZ2JhUGF0dGVybiA9IC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvO1xuICAgICAgICBjb25zdCBzaG9ydEhleFBhdHRlcm4gPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICAgICAgICBjb25zdCBsb25nSGV4UGF0dGVybiA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7XG5cbiAgICAgICAgY29uc3QgcmdiYU1hdGNoID0gdmFsdWUubWF0Y2gocmdiYVBhdHRlcm4pO1xuICAgICAgICBjb25zdCBzaG9ydEhleE1hdGNoID0gdmFsdWUubWF0Y2goc2hvcnRIZXhQYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgbG9uZ0hleE1hdGNoID0gdmFsdWUubWF0Y2gobG9uZ0hleFBhdHRlcm4pO1xuXG4gICAgICAgIGlmIChyZ2JhTWF0Y2gpIHtcbiAgICAgICAgICAgIHIgPSByZ2JhTWF0Y2hbMV07XG4gICAgICAgICAgICBnID0gcmdiYU1hdGNoWzJdO1xuICAgICAgICAgICAgYiA9IHJnYmFNYXRjaFszXTtcbiAgICAgICAgICAgIGEgPSByZ2JhTWF0Y2hbNF0gPyByZ2JhTWF0Y2hbNF0gOiAnMSc7XG4gICAgICAgIH0gZWxzZSBpZiAobG9uZ0hleE1hdGNoKSB7XG4gICAgICAgICAgICByID0gcGFyc2VJbnQobG9uZ0hleE1hdGNoWzFdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChsb25nSGV4TWF0Y2hbMl0sIDE2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgYiA9IHBhcnNlSW50KGxvbmdIZXhNYXRjaFszXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvcnRIZXhNYXRjaCkge1xuICAgICAgICAgICAgciA9IHBhcnNlSW50KHNob3J0SGV4TWF0Y2hbMV0gKyBzaG9ydEhleE1hdGNoWzFdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChzaG9ydEhleE1hdGNoWzJdICsgc2hvcnRIZXhNYXRjaFsyXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoc2hvcnRIZXhNYXRjaFszXSArIHNob3J0SGV4TWF0Y2hbM10sIDE2KS50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgY29sb3IgLSAke3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBjb2xvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRoZW1lQ29sb3IociwgZywgYiwgYSk7XG4gICAgfVxuXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIGxldCByZWQgPSBwYXJzZUludCh0aGlzLl9yKS50b1N0cmluZygxNik7XG4gICAgICAgIGxldCBncmVlbiA9IHBhcnNlSW50KHRoaXMuX2cpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgbGV0IGJsdWUgPSBwYXJzZUludCh0aGlzLl9iKS50b1N0cmluZygxNik7XG5cbiAgICAgICAgaWYgKHJlZC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZWQgPSAnMCcgKyByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyZWVuLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGdyZWVuID0gJzAnICsgZ3JlZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsdWUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgYmx1ZSA9ICcwJyArIGJsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyMnICsgcmVkICsgZ3JlZW4gKyBibHVlO1xuICAgIH1cblxuICAgIHRvUmdiKCkge1xuICAgICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5fciArICcsICcgKyB0aGlzLl9nICsgJywgJyArIHRoaXMuX2IgKyAnKSc7XG4gICAgfVxuXG4gICAgdG9SZ2JhKCkge1xuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHRoaXMuX3IgKyAnLCAnICsgdGhpcy5fZyArICcsICcgKyB0aGlzLl9iICsgJywgJyArIHRoaXMuX2EgKyAnKSc7XG4gICAgfVxuXG4gICAgZ2V0UmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcjtcbiAgICB9XG5cbiAgICBnZXRHcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2c7XG4gICAgfVxuXG4gICAgZ2V0Qmx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgfVxuXG4gICAgZ2V0QWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgIH1cblxuICAgIHNldFJlZChyZWQ6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yID0gcmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRHcmVlbihncmVlbjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2cgPSBncmVlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0Qmx1ZShibHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fYiA9IGJsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldEFscGhhKGFscGhhOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fYSA9IGFscGhhLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbG9yU2V0cyA9IHtcbiAgICBrZXBwZWw6IHtcbiAgICAgICAgY29sb3JDbGFzc1NldDoge1xuICAgICAgICAgICAgJ3ByaW1hcnknOiAncHJpbWFyeScsXG4gICAgICAgICAgICAnYWNjZW50JzogJ2FjY2VudCcsXG4gICAgICAgICAgICAnc2Vjb25kYXJ5JzogJ3NlY29uZGFyeScsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMSc6ICdhbHRlcm5hdGUxJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUyJzogJ2FsdGVybmF0ZTInLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTMnOiAnYWx0ZXJuYXRlMycsXG4gICAgICAgICAgICAndmlicmFudDEnOiAndmlicmFudDEnLFxuICAgICAgICAgICAgJ3ZpYnJhbnQyJzogJ3ZpYnJhbnQyJyxcbiAgICAgICAgICAgICdncmV5MSc6ICdncmV5MScsXG4gICAgICAgICAgICAnZ3JleTInOiAnZ3JleTInLFxuICAgICAgICAgICAgJ2dyZXkzJzogJ2dyZXkzJyxcbiAgICAgICAgICAgICdncmV5NCc6ICdncmV5NCcsXG4gICAgICAgICAgICAnZ3JleTUnOiAnZ3JleTUnLFxuICAgICAgICAgICAgJ2dyZXk2JzogJ2dyZXk2JyxcbiAgICAgICAgICAgICdncmV5Nyc6ICdncmV5NycsXG4gICAgICAgICAgICAnZ3JleTgnOiAnZ3JleTgnLFxuICAgICAgICAgICAgJ2NoYXJ0MSc6ICdjaGFydDEnLFxuICAgICAgICAgICAgJ2NoYXJ0Mic6ICdjaGFydDInLFxuICAgICAgICAgICAgJ2NoYXJ0Myc6ICdjaGFydDMnLFxuICAgICAgICAgICAgJ2NoYXJ0NCc6ICdjaGFydDQnLFxuICAgICAgICAgICAgJ2NoYXJ0NSc6ICdjaGFydDUnLFxuICAgICAgICAgICAgJ2NoYXJ0Nic6ICdjaGFydDYnLFxuICAgICAgICAgICAgJ29rJzogJ29rJyxcbiAgICAgICAgICAgICd3YXJuaW5nJzogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgJ2NyaXRpY2FsJzogJ2NyaXRpY2FsJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xJzogJ3BhcnRpdGlvbjEnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjknOiAncGFydGl0aW9uOScsXG4gICAgICAgICAgICAncGFydGl0aW9uMTAnOiAncGFydGl0aW9uMTAnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjExJzogJ3BhcnRpdGlvbjExJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMic6ICdwYXJ0aXRpb24xMicsXG4gICAgICAgICAgICAncGFydGl0aW9uMTMnOiAncGFydGl0aW9uMTMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjE0JzogJ3BhcnRpdGlvbjE0JyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtbm9kZSc6ICdzb2NpYWwtY2hhcnQtbm9kZScsXG4gICAgICAgICAgICAnc29jaWFsLWNoYXJ0LWVkZ2UnOiAnc29jaWFsLWNoYXJ0LWVkZ2UnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1pY3JvRm9jdXM6IHtcbiAgICAgICAgJ2NvbG9yVmFsdWVTZXQnOiB7XG4gICAgICAgICAgICAnY2VydWxlYW4nOiAnIzE2NjhjMScsXG4gICAgICAgICAgICAnYXF1YSc6ICcjMjljZWZmJyxcbiAgICAgICAgICAgICdhcXVhbWFyaW5lJzogJyMyZmQ2YzMnLFxuICAgICAgICAgICAgJ2Z1Y2hzaWEnOiAnI2M2MTc5ZCcsXG4gICAgICAgICAgICAnaW5kaWdvJzogJyM3NDI1YWQnLFxuICAgICAgICAgICAgJ2RhcmstYmx1ZSc6ICcjMjMxY2E1JyxcbiAgICAgICAgICAgICd3aGl0ZSc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdzbGlnaHRseS1ncmF5JzogJyNmNWY3ZjgnLFxuICAgICAgICAgICAgJ2JyaWdodC1ncmF5JzogJyNmMWYyZjMnLFxuICAgICAgICAgICAgJ2dyYXknOiAnI2RjZGVkZicsXG4gICAgICAgICAgICAnc2lsdmVyJzogJyNiZGJlYzAnLFxuICAgICAgICAgICAgJ2RpbS1ncmF5JzogJyM2NTY2NjgnLFxuICAgICAgICAgICAgJ2RhcmstZ3JheSc6ICcjMzIzNDM1JyxcbiAgICAgICAgICAgICdibGFjayc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICdjcmltc29uLW5lZ2F0aXZlJzogJyNlNTAwNGMnLFxuICAgICAgICAgICAgJ2Fwcmljb3QnOiAnI2Y0OGIzNCcsXG4gICAgICAgICAgICAneWVsbG93JzogJyNmY2RiMWYnLFxuICAgICAgICAgICAgJ2dyZWVuLXBvc2l0aXZlJzogJyMxYWFjNjAnLFxuICAgICAgICAgICAgJ3VsdHJhbWFyaW5lJzogJyMzOTM5YzYnLFxuICAgICAgICAgICAgJ3NreWJsdWUnOiAnIzAwYWJmMycsXG4gICAgICAgICAgICAncGFsZS1hcXVhJzogJyM0M2U0ZmYnLFxuICAgICAgICAgICAgJ3BhbGUtZ3JlZW4nOiAnIzFmZmJiYScsXG4gICAgICAgICAgICAnbGltZSc6ICcjNzVkYTRkJyxcbiAgICAgICAgICAgICdvcmFuZ2UnOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnbWFnZW50YSc6ICcjZWIyM2MyJyxcbiAgICAgICAgICAgICdwYWxlLXB1cnBsZSc6ICcjYmE0N2UyJyxcbiAgICAgICAgICAgICdkYXJrLXVsdHJhbWFyaW5lJzogJyMyNzE3ODInLFxuICAgICAgICAgICAgJ3N0ZWVsYmx1ZSc6ICcjMDE0MjcyJyxcbiAgICAgICAgICAgICdhcmN0aWMtYmx1ZSc6ICcjMGI4ZWFjJyxcbiAgICAgICAgICAgICdlbWVyYWxkJzogJyMwMGE5ODknLFxuICAgICAgICAgICAgJ29saXZlJzogJyM1YmJhMzYnLFxuICAgICAgICAgICAgJ2dvbGRlbnJvZCc6ICcjZmZiMDAwJyxcbiAgICAgICAgICAgICdwdXJwbGUnOiAnIzliMWU4MycsXG4gICAgICAgICAgICAncGFsZS1lZ2dwbGFudCc6ICcjNTIxNmFjJyxcbiAgICAgICAgICAgICdyZWQnOiAnI2ZmNDU0ZicsXG4gICAgICAgICAgICAncGFsZS1hbWJlcic6ICcjZmZiMjRkJyxcbiAgICAgICAgICAgICdwYWxlLWxlbW9uJzogJyNmZGUxNTknLFxuICAgICAgICAgICAgJ3BhbGUtZW1lcmFsZCc6ICcjMzNjMTgwJyxcbiAgICAgICAgICAgICdwbHVtJzogJyNiMjE2NDYnLFxuICAgICAgICAgICAgJ2NvcHBlcic6ICcjZTU3ODI4JyxcbiAgICAgICAgICAgICdhbWJlcic6ICcjZmZjMDAyJyxcbiAgICAgICAgICAgICdsZWFmLWdyZWVuJzogJyMxMThjNGYnLFxuICAgICAgICAgICAgJ2ZvcmVzdC1ncmVlbic6ICcjMDA2NDVhJyxcbiAgICAgICAgICAgICdwcmltYXJ5JzogJyMwMDczZTcnLFxuICAgICAgICAgICAgJ2FjY2VudCc6ICcjNzQyNWFkJyxcbiAgICAgICAgICAgICdzZWNvbmRhcnknOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMSc6ICcjMjljZWZmJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUyJzogJyMyZmQ2YzMnLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTMnOiAnI2M2MTc5ZCcsXG4gICAgICAgICAgICAndmlicmFudDEnOiAnIzQzZTRmZicsXG4gICAgICAgICAgICAndmlicmFudDInOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnZ3JleTEnOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAnZ3JleTInOiAnIzMyMzQzNScsXG4gICAgICAgICAgICAnZ3JleTMnOiAnIzY1NjY2OCcsXG4gICAgICAgICAgICAnZ3JleTQnOiAnI2JkYmVjMCcsXG4gICAgICAgICAgICAnZ3JleTUnOiAnI2RjZGVkZicsXG4gICAgICAgICAgICAnZ3JleTYnOiAnI2YxZjJmMycsXG4gICAgICAgICAgICAnZ3JleTcnOiAnI2Y1ZjdmOCcsXG4gICAgICAgICAgICAnZ3JleTgnOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAnY2hhcnQxJzogJyMzOTM5YzYnLFxuICAgICAgICAgICAgJ2NoYXJ0Mic6ICcjMDBhYmYzJyxcbiAgICAgICAgICAgICdjaGFydDMnOiAnIzc1ZGE0ZCcsXG4gICAgICAgICAgICAnY2hhcnQ0JzogJyNmZmNlMDAnLFxuICAgICAgICAgICAgJ2NoYXJ0NSc6ICcjZWIyM2MyJyxcbiAgICAgICAgICAgICdjaGFydDYnOiAnI2JhNDdlMicsXG4gICAgICAgICAgICAnb2snOiAnIzFhYWM2MCcsXG4gICAgICAgICAgICAnd2FybmluZyc6ICcjZjQ4YjM0JyxcbiAgICAgICAgICAgICdjcml0aWNhbCc6ICdlNTAwNGMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEnOiAnIzc0MjVhZCcsXG4gICAgICAgICAgICAncGFydGl0aW9uOSc6ICcjNTIxNmFjJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMCc6ICcjNWJiYTM2JyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMSc6ICcjMDE0MjcyJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMic6ICcjZmZiMDAwJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMyc6ICcjYmRiZWMwJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xNCc6ICcjMjcxNzgyJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtbm9kZSc6ICcjZmYwMGZmJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtZWRnZSc6ICcjZmYwMGZmJ1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBUaGVtZUNvbG9ycyB7XG4gICAgW25hbWU6IHN0cmluZ106IFRoZW1lQ29sb3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JTZXQge1xuICAgIGNvbG9yQ2xhc3NTZXQ/OiBDb2xvckNsYXNzU2V0O1xuICAgIGNvbG9yVmFsdWVTZXQ/OiBDb2xvclZhbHVlU2V0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yQ2xhc3NTZXQge1xuICAgIFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JWYWx1ZVNldCB7XG4gICAgW25hbWU6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgQ29sb3JJZGVudGlmaWVyID0gc3RyaW5nO1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcbmltcG9ydCB7IHBhaXJ3aXNlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFRoZW1lQ29sb3IgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9jb2xvci5zZXJ2aWNlJztcblxuLy8gVmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gc3R5bGVzaGVldFxuY29uc3QgQlVUVE9OX01BUkdJTiA9IDg7XG5jb25zdCBCVVRUT05fV0lEVEhTID0ge1xuICAgICdzbSc6IDI2LFxuICAgICdtZCc6IDMyLFxuICAgICdsZyc6IDQwXG59O1xuXG5sZXQgdW5pcXVlSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWNvbG9yLXBpY2tlcicsXG4gICAgZXhwb3J0QXM6ICd1eC1jb2xvci1waWNrZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnY29sb3ItcGlja2VyLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBDb2xvclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBpZDogc3RyaW5nID0gYHV4LWNvbG9yLXBpY2tlci0ke3VuaXF1ZUlkKyt9YDtcblxuICAgIEBJbnB1dCgnY29sb3JzJylcbiAgICBzZXQgaW5wdXRDb2xvcnMoY29sb3JzOiBDb2xvclBpY2tlcklucHV0Q29sb3JzW10gfCBDb2xvclBpY2tlcklucHV0Q29sb3JzW11bXSkge1xuXG4gICAgICAgIGxldCBub3JtYWxpemVkQ29sb3JzOiBDb2xvclBpY2tlcklucHV0Q29sb3JzW11bXTtcblxuICAgICAgICAvLyBJZiBpdCdzIGEgMWQgYXJyYXksIGNvbnZlcnQgaXQgdG8gMmRcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDAgfHwgIUFycmF5LmlzQXJyYXkoY29sb3JzWzBdKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZENvbG9ycyA9IFs8Q29sb3JQaWNrZXJJbnB1dENvbG9yc1tdPmNvbG9yc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVkQ29sb3JzID0gPENvbG9yUGlja2VySW5wdXRDb2xvcnNbXVtdPmNvbG9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgYW55IHN0cmluZyBjb2xvcnMgdG8gQ29sb3JQaWNrZXJDb2xvclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5vcm1hbGl6ZWRDb2xvcnMubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcm93Lm1hcChjb2xvciA9PiBjb2xvciBpbnN0YW5jZW9mIENvbG9yUGlja2VyQ29sb3IgPyBjb2xvciA6IG5ldyBDb2xvclBpY2tlckNvbG9yKGNvbG9yLCBjb2xvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzZWxlY3RlZChzZWxlY3RlZDogQ29sb3JQaWNrZXJDb2xvcikge1xuICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KHNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBjb2x1bW5zKGNvbHVtbnM6IG51bWJlcikge1xuICAgICAgICB0aGlzLmNvbHVtbnMkLm5leHQoY29sdW1ucyk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBidXR0b25TdHlsZTogQ29sb3JQaWNrZXJCdXR0b25TdHlsZSA9ICdjaXJjbGUnO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgYnV0dG9uU2l6ZShidXR0b25TaXplOiBDb2xvclBpY2tlckJ1dHRvblNpemUpIHtcbiAgICAgICAgdGhpcy5idXR0b25TaXplJC5uZXh0KGJ1dHRvblNpemUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2hvd1Rvb2x0aXBzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIHNob3dJbnB1dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBpbnB1dE1vZGU6IENvbG9yUGlja2VySW5wdXRNb2RlID0gJ2hleCc7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Q29sb3JQaWNrZXJDb2xvcj4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGlucHV0U3VibWl0ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aCcpXG4gICAgY3NzV2lkdGggPSAnYXV0byc7XG5cbiAgICBjb2xvcnM6IENvbG9yUGlja2VyQ29sb3JbXVtdID0gW107XG4gICAgc2VsZWN0ZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDb2xvclBpY2tlckNvbG9yPihudWxsKTtcbiAgICBjb2x1bW5zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPigtMSk7XG4gICAgYnV0dG9uU2l6ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PENvbG9yUGlja2VyQnV0dG9uU2l6ZT4oJ21kJyk7XG4gICAgaW5wdXRQYXR0ZXJucyA9IHtcbiAgICAgICAgJ2hleCc6IC9eIyg/OltcXGRhLWZBLUZdezN9KXsxLDJ9JC8sXG4gICAgICAgICdyZ2JhJzogL14oPzpyZ2JcXChcXGR7MSwzfSxcXHMqXFxkezEsM30sXFxzKlxcZHsxLDN9XFwpKXwoPzpyZ2JhXFwoXFxkezEsM30sXFxzKlxcZHsxLDN9LFxccypcXGR7MSwzfSxcXHMqXFxkKFxcLlxcZCspP1xcKSkkL1xuICAgIH07XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gU2tpcCBlbWl0dGluZyB0aGUgaW5pdGlhbCBzZWxlY3RlZENoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdGVkJC5waXBlKHBhaXJ3aXNlKCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKFtwcmV2LCBjdXJyXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCB0aGUgd2lkdGggYmFzZWQgb24gY29sdW1uIGNvdW50IGFuZCBidXR0b24gc2l6ZVxuICAgICAgICBjb21iaW5lTGF0ZXN0KHRoaXMuY29sdW1ucyQsIHRoaXMuYnV0dG9uU2l6ZSQpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKFtjb2x1bW5zLCBidXR0b25TaXplXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gY29sdW1ucyAqIChCVVRUT05fV0lEVEhTW2J1dHRvblNpemVdICsgKDIgKiBCVVRUT05fTUFSR0lOKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzV2lkdGggPSBgJHt3fXB4YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzc1dpZHRoID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVDb2xvclZhbHVlKGlucHV0OiBzdHJpbmcsIG1vZGU6IENvbG9yUGlja2VySW5wdXRNb2RlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0UGF0dGVybnNbbW9kZV0udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQobmV3IENvbG9yUGlja2VyQ29sb3IoJ0N1c3RvbScsIGlucHV0LCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGVDb2xvckVudHJ5VHlwZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbnB1dE1vZGUgPSAodGhpcy5pbnB1dE1vZGUgPT09ICdoZXgnKSA/ICdyZ2JhJyA6ICdoZXgnO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgQ29sb3JQaWNrZXJJbnB1dENvbG9ycyA9IENvbG9yUGlja2VyQ29sb3IgfCBzdHJpbmc7XG5leHBvcnQgdHlwZSBDb2xvclBpY2tlckJ1dHRvblN0eWxlID0gJ3NxdWFyZScgfCAnY2lyY2xlJztcbmV4cG9ydCB0eXBlIENvbG9yUGlja2VyQnV0dG9uU2l6ZSA9ICdzbScgfCAnbWQnIHwgJ2xnJztcbmV4cG9ydCB0eXBlIENvbG9yUGlja2VySW5wdXRNb2RlID0gJ2hleCcgfCAncmdiYSc7XG5cbi8qKlxuICogVHlwZSByZXByZXNlbnRpbmcgYSBjb2xvciwgaW5jbHVkaW5nIGl0cyBkZXNjcmlwdGl2ZSBuYW1lLlxuICovXG5leHBvcnQgY2xhc3MgQ29sb3JQaWNrZXJDb2xvciB7XG5cbiAgICAvKipcbiAgICAgKiBIdW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2xvci5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBIZXggdmFsdWUgb2YgdGhlIGNvbG9yLCBlLmcuIGAjZmZmZmZmYC5cbiAgICAgKi9cbiAgICBnZXQgaGV4KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbEhleFZhbHVlID8gdGhpcy5fb3JpZ2luYWxIZXhWYWx1ZSA6IHRoaXMuX2NvbG9yLnRvSGV4KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUkdCQSB2YWx1ZSBvZiB0aGUgY29sb3IsIGUuZy4gYHJnYmEoMjU1LCAyNTUsIDI1NSwgMSlgLlxuICAgICAqL1xuICAgIGdldCByZ2JhKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFJnYmFWYWx1ZSA/IHRoaXMuX29yaWdpbmFsUmdiYVZhbHVlIDogdGhpcy5fY29sb3IudG9SZ2JhKCk7XG4gICAgfVxuXG4gICAgZ2V0IHIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2NvbG9yLmdldFJlZCgpKTtcbiAgICB9XG5cbiAgICBnZXQgZygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5fY29sb3IuZ2V0R3JlZW4oKSk7XG4gICAgfVxuXG4gICAgZ2V0IGIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2NvbG9yLmdldEJsdWUoKSk7XG4gICAgfVxuXG4gICAgZ2V0IGEoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5fY29sb3IuZ2V0QWxwaGEoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29sb3I6IFRoZW1lQ29sb3I7XG4gICAgcHJpdmF0ZSBfb3JpZ2luYWxIZXhWYWx1ZTogc3RyaW5nO1xuICAgIHByaXZhdGUgX29yaWdpbmFsUmdiYVZhbHVlOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGlucHV0TW9kZT86IENvbG9yUGlja2VySW5wdXRNb2RlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gVGhlbWVDb2xvci5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gUHJlc2VydmUgdGhlIGZvcm1hdCBlbnRlcmVkIGJ5IHRoZSB1c2VyIGlmIGl0J3MgdmFsaWRcbiAgICAgICAgaWYgKGlucHV0TW9kZSA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsSGV4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dE1vZGUgPT09ICdyZ2JhJykge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSZ2JhVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvci50b1JnYmEoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRm9jdXNNb25pdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhGb2N1c1dpdGhpbl0sW3V4Qmx1cldpdGhpbl0nLFxufSlcbmV4cG9ydCBjbGFzcyBGb2N1c1dpdGhpbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBAT3V0cHV0KCkgdXhGb2N1c1dpdGhpbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgdXhCbHVyV2l0aGluID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsIG5nWm9uZTogTmdab25lKSB7XG4gICAgICAgIF9mb2N1c01vbml0b3IubW9uaXRvcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRydWUpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKG9yaWdpbiA9PiBuZ1pvbmUucnVuKCgpID0+IG9yaWdpbiA/IHRoaXMudXhGb2N1c1dpdGhpbi5lbWl0KCkgOiB0aGlzLnV4Qmx1cldpdGhpbi5lbWl0KCkpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNNb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUExBVEZPUk1fSUQsIFF1ZXJ5TGlzdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTcGxpdEFyZWFEaXJlY3RpdmUsIFNwbGl0Q29tcG9uZW50IH0gZnJvbSAnYW5ndWxhci1zcGxpdCc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzcGxpdCdcbn0pXG5leHBvcnQgY2xhc3MgU3BsaXR0ZXJBY2Nlc3NpYmlsaXR5RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKiBFbWl0IGFuIGV2ZW50IHdoZW5ldmVyIHRoZSBndXR0ZXIgaXMgbW92ZWQgdXNpbmcgdGhlIGtleWJvYXJkICovXG4gICAgQE91dHB1dCgpIGd1dHRlcktleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgICAvKiogRmluZCBhbGwgdGhlIHNwbGl0IGFyZWFzICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihTcGxpdEFyZWFEaXJlY3RpdmUpIGFyZWFzOiBRdWVyeUxpc3Q8U3BsaXRBcmVhRGlyZWN0aXZlPjtcblxuICAgIC8qKiBTdG9yZSBhbGwgdGhlIGd1dHRlciBlbGVtZW50cyAqL1xuICAgIHByaXZhdGUgX2d1dHRlcnM6IEhUTUxFbGVtZW50W10gPSBbXTtcblxuICAgIC8qKiBXYXRjaCBmb3IgZ3V0dGVycyBiZWluZyBhZGRlZCBvciByZW1vdmVkICovXG4gICAgcHJpdmF0ZSBfb2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgICAvKiogVGVhcmRvd24gb3VyIG9ic2VydmFibGVzIG9uIGRlc3Ryb3kgKi9cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtOiBzdHJpbmcsXG4gICAgICAgIHByaXZhdGUgX3NwbGl0dGVyOiBTcGxpdENvbXBvbmVudFxuICAgICkge1xuICAgICAgICAvLyB1cGRhdGUgYXJpYSB2YWx1ZXMgd2hlbiB0aGUgYSBndXR0ZXIgaXMgZHJhZ2dlZFxuICAgICAgICBfc3BsaXR0ZXIuZHJhZ1Byb2dyZXNzXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVHdXR0ZXJBdHRyaWJ1dGVzKCkpO1xuICAgIH1cblxuICAgIC8qKiBPbmNlIGluaXRpYWxpc2VkIG1ha2UgdGhlIGd1dHRlcnMgYWNjZXNzaWJsZSAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgZ3V0dGVyc1xuICAgICAgICB0aGlzLm9uR3V0dGVyQ2hhbmdlKCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIG51bWJlciBvZiBzcGxpdCBhcmVhcyBjaGFuZ2UgdGhlbiB1cGRhdGUgdGhlIGd1dHRlcnMgYW5kIGFwcGx5IGFyaWEgcHJvcGVydGllc1xuICAgICAgICB0aGlzLmFyZWFzLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMub25HdXR0ZXJDaGFuZ2UoKSk7XG5cbiAgICAgICAgLy8gd2UgY2FuJ3Qga25vdyB3aGVuIGFkZGl0aW9uYWwgc3BsaXQtZ3V0dGVycyBhcHBlYXIgdXNpbmcgQ29udGVudENoaWxkcmVuIGFzIHRoZSBkaXJlY3RpdmUgY2xhc3MgaXMgbm90IGV4cG9ydGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IHdvcmsgLSB1c2UgbXV0YXRpb24gb2JzZXJ2ZXIgaW5zdGVhZFxuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm0pKSB7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbXV0YXRpb24gb2JzZXJ2ZXJcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gdGhpcy5vbkd1dHRlckNoYW5nZSgpKTtcblxuICAgICAgICAgICAgLy8gYmVnaW4gb2JzZXJ2aW5nIHRoZSBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3kgYWxsIG9ic2VydmFibGVzIGFuZCBvYnNlcnZlcnMgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKiBXZSBzaG91bGQgZm9jdXMgdGhlIGd1dHRlciB3aGVuIGl0IGlzIGNsaWNrZWQgKi9cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgb25DbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc1NwbGl0dGVyR3V0dGVyKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgIChldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRmluZCBhbGwgdGhlIGd1dHRlcnMgYW5kIHNldCB0aGVpciBhdHRyaWJ1dGVzICovXG4gICAgcHJpdmF0ZSBvbkd1dHRlckNoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZ3V0dGVycyA9IHRoaXMuZ2V0R3V0dGVycygpO1xuICAgICAgICB0aGlzLnNldEd1dHRlckF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IGFsbCB0aGUgZ3V0dGVyIGVsZW1lbnRzICovXG4gICAgcHJpdmF0ZSBnZXRHdXR0ZXJzKCk6IEhUTUxFbGVtZW50W10ge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgRE9NIGFjY2Vzc2luZyBwcm9wZXJ0aWVzIC0gd2hpY2ggd29uJ3Qgd29yayBpZiBzZXJ2ZXIgc2lkZSByZW5kZXJlZFxuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm0pKSB7XG4gICAgICAgICAgICBjb25zdCBndXR0ZXJzOiBIVE1MRWxlbWVudFtdID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5pdGVtKGlkeCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NwbGl0dGVyR3V0dGVyKG5vZGUgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcnMucHVzaChub2RlIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBndXR0ZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKiBTZXQgdGhlIGFwcHJvcHJpYXRlIGF0dHJpYnV0ZXMgb24gdGhlIGd1dHRlciBlbGVtZW50cyAqL1xuICAgIHByaXZhdGUgc2V0R3V0dGVyQXR0cmlidXRlcygpOiB2b2lkIHtcbiAgICAgICAgLy8gYXBwbHkgYXR0cmlidXRlIHRvIGV2ZXJ5IGd1dHRlclxuICAgICAgICB0aGlzLl9ndXR0ZXJzLmZvckVhY2goZ3V0dGVyID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBzZXBhcmF0b3Igcm9sZVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGd1dHRlciwgJ3JvbGUnLCAnc2VwYXJhdG9yJyk7XG5cbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIGd1dHRlcnMgdGFiYmFibGVcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShndXR0ZXIsICd0YWJpbmRleCcsICcwJyk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgdmFsdWUgbm93IGFyaWEgcHJvcGVydHlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR3V0dGVyQXR0cmlidXRlcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQXBwbHkgdGhlIGFyaWEgYXR0cmlidXRlIHZhbHVlcyAqL1xuICAgIHByaXZhdGUgdXBkYXRlR3V0dGVyQXR0cmlidXRlcygpOiB2b2lkIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBub3cgcHJvcGVydGllcyBvZiBlYWNoIGd1dHRlclxuICAgICAgICB0aGlzLl9ndXR0ZXJzLmZvckVhY2goKGd1dHRlciwgaWR4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEd1dHRlclZhbHVlTm93KGd1dHRlciwgaWR4KTtcbiAgICAgICAgICAgIHRoaXMuc2V0R3V0dGVyVmFsdWVNaW4oZ3V0dGVyLCBpZHgpO1xuICAgICAgICAgICAgdGhpcy5zZXRHdXR0ZXJWYWx1ZU1heChndXR0ZXIsIGlkeCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBBcHBseSB0aGUgdmFsdWUgbm93IGFyaWEgYXR0cmlidXRlICovXG4gICAgcHJpdmF0ZSBzZXRHdXR0ZXJWYWx1ZU5vdyhndXR0ZXI6IEhUTUxFbGVtZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIGdldCB0aGUgbWF0Y2hpbmcgc3BsaXQgYXJlYVxuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5fc3BsaXR0ZXIuZGlzcGxheWVkQXJlYXNbaW5kZXhdO1xuXG4gICAgICAgIC8vIGluZGljYXRlIHRoZSBzaXplXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShndXR0ZXIsICdhcmlhLXZhbHVlbm93JywgYCR7TWF0aC5yb3VuZChhcmVhLnNpemUgKiAxMDApfWApO1xuICAgIH1cblxuICAgIC8qKiBBcHBseSB0aGUgdmFsdWUgbWluIGFyaWEgYXR0cmlidXRlICovXG4gICAgcHJpdmF0ZSBzZXRHdXR0ZXJWYWx1ZU1pbihndXR0ZXI6IEhUTUxFbGVtZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIGdldCB0aGUgbWF0Y2hpbmcgc3BsaXQgYXJlYVxuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5hcmVhcy50b0FycmF5KClbaW5kZXhdO1xuXG4gICAgICAgIC8vIGluZGljYXRlIHRoZSBtaW5pbXVtIHNpemVcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGd1dHRlciwgJ2FyaWEtdmFsdWVtaW4nLCBgJHtNYXRoLnJvdW5kKGFyZWEubWluU2l6ZSAqIDEwMCl9YCk7XG4gICAgfVxuXG4gICAgLyoqIEFwcGx5IHRoZSB2YWx1ZSBtYXggYXJpYSBhdHRyaWJ1dGUgKi9cbiAgICBwcml2YXRlIHNldEd1dHRlclZhbHVlTWF4KGd1dHRlcjogSFRNTEVsZW1lbnQsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gZ2V0IGV2ZXJ5IG90aGVyIHNwbGl0dGVyIGFyZWFcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlU2l6ZSA9IHRoaXMuYXJlYXNcbiAgICAgICAgICAgIC5maWx0ZXIoKF9hcmVhLCBpZHgpID0+IGluZGV4ICE9PSBpZHgpXG4gICAgICAgICAgICAucmVkdWNlPG51bWJlcj4oKHRvdGFsLCBhcmVhKSA9PiB0b3RhbCArIGFyZWEubWluU2l6ZSwgMCk7XG5cbiAgICAgICAgLy8gaW5kaWNhdGUgdGhlIG1pbmltdW0gc2l6ZVxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZ3V0dGVyLCAnYXJpYS12YWx1ZW1heCcsIGAkezEwMCAtIE1hdGgucm91bmQoYXZhaWxhYmxlU2l6ZSAqIDEwMCl9YCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzU3BsaXR0ZXJHdXR0ZXIoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5ndXR0ZXJLZXlkb3duLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5BcnJvd0Rvd24nLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uQXJyb3dSaWdodCcsIFsnJGV2ZW50J10pXG4gICAgb25JbmNyZWFzZUtleShldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYSBtb3ZlIGlmIGEgZ3V0dGVyIGlzIGZvY3VzZWRcbiAgICAgICAgaWYgKHRoaXMuaXNTcGxpdHRlckd1dHRlcihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEd1dHRlclBvc2l0aW9uKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgLTAuMDEpO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5BcnJvd1VwJywgWyckZXZlbnQnXSlcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkFycm93TGVmdCcsIFsnJGV2ZW50J10pXG4gICAgb25EZWNyZWFzZUtleShldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYSBtb3ZlIGlmIGEgZ3V0dGVyIGlzIGZvY3VzZWRcbiAgICAgICAgaWYgKHRoaXMuaXNTcGxpdHRlckd1dHRlcihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEd1dHRlclBvc2l0aW9uKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgMC4wMSk7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkhvbWUnLCBbJyRldmVudCddKVxuICAgIG9uSG9tZUtleShldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc1NwbGl0dGVyR3V0dGVyKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgYWZmZWN0ZWQgcGFuZWxzXG4gICAgICAgICAgICBjb25zdCBhcmVhcyA9IHRoaXMuZ2V0QXJlYXNGcm9tR3V0dGVyKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgcHJldmlvdXMgYXJlYSB0byBpdCdzIG1pbmltdW0gc2l6ZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBhcmVhcy5wcmV2aW91cy5zaXplIC0gYXJlYXMucHJldmlvdXMuY29tcC5taW5TaXplO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNpemVzIGFjY29yZGluZ2x5XG4gICAgICAgICAgICB0aGlzLnNldEd1dHRlclBvc2l0aW9uKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgZGVsdGEpO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5FbmQnLCBbJyRldmVudCddKVxuICAgIG9uRW5kS2V5KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzU3BsaXR0ZXJHdXR0ZXIoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBhZmZlY3RlZCBwYW5lbHNcbiAgICAgICAgICAgIGNvbnN0IGFyZWFzID0gdGhpcy5nZXRBcmVhc0Zyb21HdXR0ZXIoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBuZXh0IGFyZWEgdG8gaXQncyBtaW5pbXVtIHNpemVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYXJlYXMubmV4dC5zaXplIC0gYXJlYXMubmV4dC5jb21wLm1pblNpemU7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2l6ZXMgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIHRoaXMuc2V0R3V0dGVyUG9zaXRpb24oZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCAtZGVsdGEpO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIGEgZ3V0dGVyICovXG4gICAgcHJpdmF0ZSBpc1NwbGl0dGVyR3V0dGVyKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09ICdTUExJVC1HVVRURVInO1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhlIGd1dHRlciBwb3NpdGlvbiAqL1xuICAgIHByaXZhdGUgc2V0R3V0dGVyUG9zaXRpb24oZ3V0dGVyOiBIVE1MRWxlbWVudCwgZGVsdGE6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBnZXQgdGhlIGFmZmVjdGVkIHBhbmVsc1xuICAgICAgICBjb25zdCBhcmVhcyA9IHRoaXMuZ2V0QXJlYXNGcm9tR3V0dGVyKGd1dHRlcik7XG5cbiAgICAgICAgLy8gZW5zdXJlIHdlIGNhbiBwZXJmb3JtIHRoZSByZXNpemVcbiAgICAgICAgaWYgKGFyZWFzLnByZXZpb3VzLnNpemUgLSBkZWx0YSA8IGFyZWFzLnByZXZpb3VzLmNvbXAubWluU2l6ZSB8fCBhcmVhcy5uZXh0LnNpemUgKyBkZWx0YSA8IGFyZWFzLm5leHQuY29tcC5taW5TaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHRoZSByZXNpemVcbiAgICAgICAgYXJlYXMucHJldmlvdXMuc2l6ZSAtPSBkZWx0YTtcbiAgICAgICAgYXJlYXMubmV4dC5zaXplICs9IGRlbHRhO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3BsaXR0ZXIgLSB0aGlzIGlzIGEgcHJpdmF0ZSBtZXRob2QgYnV0IHdlIG5lZWQgdG8gY2FsbCBpdFxuICAgICAgICAodGhpcy5fc3BsaXR0ZXIgYXMgYW55KS5yZWZyZXNoU3R5bGVTaXplcygpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZ3V0dGVyIGFyaWEgdmFsdWVzXG4gICAgICAgIHRoaXMudXBkYXRlR3V0dGVyQXR0cmlidXRlcygpO1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGhlIHNwbGl0IGFyZWFzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGd1dHRlciAqL1xuICAgIHByaXZhdGUgZ2V0QXJlYXNGcm9tR3V0dGVyKGd1dHRlcjogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9ndXR0ZXJzLmluZGV4T2YoZ3V0dGVyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuX3NwbGl0dGVyLmRpc3BsYXllZEFyZWFzW2luZGV4XSxcbiAgICAgICAgICAgIG5leHQ6IHRoaXMuX3NwbGl0dGVyLmRpc3BsYXllZEFyZWFzW2luZGV4ICsgMV1cbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcblxuLyoqXG4gKiBUaGlzIGlzIGEgc2ltcGxlIFJ4SlMgb3BlcmF0b3IgdG8gYWxsb3cgdXMgdG8gYXZvaWQgdGhlXG4gKiBcImV4cHJlc3Npb24gaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWQgaXNzdWVcIlxuICogYnkgbWFraW5nIHRoZSBzdWJzY3JpcHRpb24gYXN5bmNocm9ub3VzLiBXZSBjb3VsZCBqdXN0IHVzZSBhXG4gKiBkZWxheSBvcGVyYXRvciBidXQgdGhpcyB1c2VzIGEgdGltZW91dCB3aGljaCBpcyBzaWduaWZpY2FudGx5XG4gKiBzbG93ZXIgdGhhbiB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gKi9cbmV4cG9ydCBjb25zdCB0aWNrID0gPFQ+KCkgPT4gKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gbmV3IE9ic2VydmFibGU8VD4oKHN1YnNjcmliZXIpID0+IHtcbiAgICBzb3VyY2Uuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCh2YWx1ZTogVCkgeyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc3Vic2NyaWJlci5uZXh0KHZhbHVlKSk7IH0sXG4gICAgICAgIGVycm9yKGVycjogYW55KSB7IHN1YnNjcmliZXIuZXJyb3IoZXJyKTsgfSxcbiAgICAgICAgY29tcGxldGUoKSB7IHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSxcbiAgICB9KTtcbn0pOyIsImltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IERPV05fQVJST1csIEVORCwgSE9NRSwgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFVQX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL3RhYmJhYmxlLWxpc3QtaXRlbS5kaXJlY3RpdmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGFiYmFibGVMaXN0U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBoaWVyYXJjaHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhbGxvd0FsdE1vZGlmaWVyOiBib29sZWFuID0gdHJ1ZTtcbiAgICBhbGxvd0N0cmxNb2RpZmllcjogYm9vbGVhbiA9IHRydWU7XG4gICAgYWxsb3dCb3VuZGFyeUtleXM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBmb2N1c0tleU1hbmFnZXI6IEZvY3VzS2V5TWFuYWdlcjxUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlPjtcblxuICAgIHByaXZhdGUgX2l0ZW1zOiBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT47XG4gICAgcHJpdmF0ZSBfZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnO1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZShpdGVtczogUXVlcnlMaXN0PFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmU+LCBkaXJlY3Rpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcsIHdyYXA6IGJvb2xlYW4pOiB2b2lkIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgaXRlbXNcbiAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBmb2N1cyBrZXkgbWFuYWdlclxuICAgICAgICB0aGlzLmZvY3VzS2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIoaXRlbXMpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaXN0XG4gICAgICAgIGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHRoaXMuZm9jdXNLZXlNYW5hZ2VyLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKCkgOiB0aGlzLmZvY3VzS2V5TWFuYWdlci53aXRoSG9yaXpvbnRhbE9yaWVudGF0aW9uKCdsdHInKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGVuYWJsZSB3cmFwcGluZyBpZiByZXF1aXJlZFxuICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0tleU1hbmFnZXIud2l0aFdyYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdCBpcyB0YWJiYWJsZVxuICAgICAgICB0aGlzLnNldEZpcnN0SXRlbVRhYmJhYmxlKCk7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgaW5pdCBmdW5jdGlvbiBvbiBlYWNoIGl0ZW1cbiAgICAgICAgdGhpcy5faXRlbXMuZm9yRWFjaChpdGVtID0+IGl0ZW0ub25Jbml0KCkpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBsaXN0IGNoYW5nZXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlcmUgaXMgYWx3YXlzIGF0IGxlYXN0IG9uZSB0YWJiYWJsZSBpdGVtXG4gICAgICAgIHRoaXMuX2l0ZW1zLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHtcblxuICAgICAgICAgICAgLy8gY2FsbCB0aGUgb24gaW5pdCBmdW5jdGlvbiBvbiBhbnkgbmV3IGl0ZW1zXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5maWx0ZXIoaXRlbSA9PiAhaXRlbS5pbml0aWFsaXplZCkuZm9yRWFjaChpdGVtID0+IGl0ZW0ub25Jbml0KCkpO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGl0ZW0gdGFiYmFibGUgYXQgYWxsIHRpbWVzXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVRhYmJhYmxlSXRlbSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZShpdGVtOiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGl0ZW0gaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pdGVtcy50b0FycmF5KCkuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAvLyBhY3RpdmUgdGhlIGl0ZW0gaWYgaXQgaXMgbm90IGFscmVhZHkgYWN0aXZlXG4gICAgICAgIGlmICh0aGlzLmZvY3VzS2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzS2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzSXRlbUFjdGl2ZShpdGVtOiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzS2V5TWFuYWdlci5hY3RpdmVJdGVtLmlkID09PSBpdGVtLmlkO1xuICAgIH1cblxuICAgIHNldEZpcnN0SXRlbVRhYmJhYmxlKCk6IHZvaWQge1xuICAgICAgICAvLyBkZWxheSB0byBwcmV2ZW50IGV4cHJlc3Npb24gY2hhbmdlZCBhZnRlciBjaGVjayBlcnJvclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgaXRlbSB0aGF0IGlzIG5vdCBkaXNhYmxlZFxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLl9pdGVtcy5maW5kKGl0ZW0gPT4gIWl0ZW0uZGlzYWJsZWQpO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICBmaXJzdC50YWJpbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuc3VyZVRhYmJhYmxlSXRlbSgpOiB2b2lkIHtcbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGFueSBpdGVtIGlzIHRhYmJhYmxlXG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2l0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnRhYmluZGV4ID09PSAwKTtcblxuICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRGaXJzdEl0ZW1UYWJiYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNUYWJiYWJsZUl0ZW0oKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgaXRlbSBpbiB0aGUgbGlzdCB3aXRoIGEgdGFiIGluZGV4XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faXRlbXMudG9BcnJheSgpLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udGFiaW5kZXggPT09IDApO1xuXG4gICAgICAgIC8vIGlmIGFuIGl0ZW0gd2FzIGZvdW5kIHRoZW4gZm9jdXMgaXRcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG9uS2V5ZG93bihzb3VyY2U6IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUsIGV2ZW50OiBLZXlib2FyZEV2ZW50KTogYW55IHtcblxuICAgICAgICAvLyBwcmV2ZW50IGFueXRoaW5nIGhhcHBlbmluZyB3aGVuIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQgaWYgdGhleSBoYXZlIGJlZW4gZGlzYWJsZWRcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93QWx0TW9kaWZpZXIgJiYgZXZlbnQuYWx0S2V5IHx8ICF0aGlzLmFsbG93Q3RybE1vZGlmaWVyICYmIGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9jdXNLZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIGtleSBpcyBhIGJvdW5kYXJ5IGtleSBhbmQgYm91bmRhcnkga2V5cyBhcmUgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5hbGxvd0JvdW5kYXJ5S2V5cykge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC53aGljaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgSE9NRTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1c0tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNLZXlNYW5hZ2VyLnNldExhc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5fZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgZXZlbnQua2V5Q29kZSA9PT0gRE9XTl9BUlJPVykgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5fZGlyZWN0aW9uID09PSAndmVydGljYWwnICYmIGV2ZW50LmtleUNvZGUgPT09IFJJR0hUX0FSUk9XKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5rZXlib2FyZEV4cGFuZGVkJC5uZXh0KHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodGhpcy5fZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgZXZlbnQua2V5Q29kZSA9PT0gVVBfQVJST1cpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiBldmVudC5rZXlDb2RlID09PSBMRUZUX0FSUk9XKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIHNvdXJjZS5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uua2V5Ym9hcmRFeHBhbmRlZCQubmV4dChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5wYXJlbnQua2V5Ym9hcmRFeHBhbmRlZCQubmV4dChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc29ydEl0ZW1zQnlIaWVyYXJjaHkobGlzdDogUXVlcnlMaXN0PFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmU+KTogVGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZVtdIHtcblxuICAgICAgICBjb25zdCB0b3BMZXZlbDogVGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZVtdID0gW107XG5cbiAgICAgICAgLy8gUG9wdWxhdGluZyBjaGlsZHJlbiAtIGNsZWFyIHByZXZpb3VzbHkgZ2VuZXJhdGVkIGNvbGxlY3Rpb25cbiAgICAgICAgbGlzdC5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jaGlsZHJlbiA9IFtdKTtcblxuICAgICAgICAvLyBQb3B1bGF0aW5nIGNoaWxkcmVuIC0gbWFwIGZyb20gY2hpbGQgLT4gcGFyZW50IHJlbGF0aW9uc2hpcFxuICAgICAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnBhcmVudC5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGbGF0dGVuIHRoZSB0cmVlIHRvIHByb2R1Y2UgdGhlIGN1cnNvciBrZXkgb3JkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbkhpZXJhcmNoeSh0b3BMZXZlbCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmbGF0dGVuSGllcmFyY2h5KGl0ZW1zOiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlW10pOiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlW10ge1xuICAgICAgICBjb25zdCBmbGF0TGlzdDogVGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZVtdID0gW107XG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmNoaWxkcmVuLnNvcnQoKGEsIGIpID0+IGEucmFuayAtIGIucmFuayk7XG4gICAgICAgICAgICBmbGF0TGlzdC5wdXNoKGl0ZW0sIC4uLnRoaXMuZmxhdHRlbkhpZXJhcmNoeShpdGVtLmNoaWxkcmVuKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxhdExpc3Q7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRm9jdXNhYmxlT3B0aW9uLCBGb2N1c01vbml0b3IgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgdGljayB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9pbmRleCc7XG5pbXBvcnQgeyBUYWJiYWJsZUxpc3RTZXJ2aWNlIH0gZnJvbSAnLi90YWJiYWJsZS1saXN0LnNlcnZpY2UnO1xuXG5sZXQgbmV4dElkID0gMDtcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhUYWJiYWJsZUxpc3RJdGVtXScsXG4gICAgZXhwb3J0QXM6ICd1eC10YWJiYWJsZS1saXN0LWl0ZW0nXG59KVxuZXhwb3J0IGNsYXNzIFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBGb2N1c2FibGVPcHRpb24sIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBwYXJlbnQ6IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmU7XG5cbiAgICBASW5wdXQoKSByYW5rOiBudW1iZXIgPSAwO1xuXG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBASG9zdEJpbmRpbmcoKSB0YWJpbmRleDogbnVtYmVyID0gLTE7XG5cbiAgICBpZDogbnVtYmVyID0gbmV4dElkKys7XG5cbiAgICBpbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY2hpbGRyZW46IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmVbXSA9IFtdO1xuXG4gICAga2V5Ym9hcmRFeHBhbmRlZCQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYmJhYmxlTGlzdDogVGFiYmFibGVMaXN0U2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IpIHtcblxuICAgICAgICB0aGlzLmtleWJvYXJkRXhwYW5kZWQkLnBpcGUodGljaygpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGV4cGFuZGVkID0+IHtcblxuICAgICAgICAgICAgLy8gRW1pdCBldmVudCB3aGljaCBtYXkgYWx0ZXIgdGhlIERPTVxuICAgICAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KGV4cGFuZGVkKTtcblxuICAgICAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGFwcHJvcHJpYXRlIGl0ZW1cbiAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFiYmFibGVMaXN0LmFjdGl2YXRlKHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFiYmFibGVMaXN0LmFjdGl2YXRlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgY2xhc3NlcyB0byBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBmb2N1cyBldmVudFxuICAgICAgICBmb2N1c01vbml0b3IubW9uaXRvcihfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBmYWxzZSkucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgb25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl90YWJiYWJsZUxpc3QuZm9jdXNLZXlNYW5hZ2VyLmNoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIG1hcCgoKSA9PiB0aGlzLl90YWJiYWJsZUxpc3QuaXNJdGVtQWN0aXZlKHRoaXMpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoYWN0aXZlID0+IHRoaXMudGFiaW5kZXggPSBhY3RpdmUgPyAwIDogLTEpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGl0ZW0gLSBpZiBzbyB3ZSBuZWVkIHRvIG1ha2UgYW5vdGhlciBpdGVtIHRhYmJhYmxlXG4gICAgICAgIGlmICh0aGlzLnRhYmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJiYWJsZUxpc3Quc2V0Rmlyc3RJdGVtVGFiYmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgICBmb2N1cygpOiB2b2lkIHtcblxuICAgICAgICAvLyBhcHBseSBmb2N1cyB0byB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGZvY3VzIGtleSBtYW5hZ2VyIHVwZGF0ZXMgdGhlIGFjdGl2ZSBpdGVtIGNvcnJlY3RseVxuICAgICAgICB0aGlzLl90YWJiYWJsZUxpc3QuYWN0aXZhdGUodGhpcyk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5vbktleWRvd24odGhpcywgZXZlbnQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBGb2N1c0tleU1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJiYWJsZS1saXN0LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFRhYmJhYmxlTGlzdFNlcnZpY2UgfSBmcm9tICcuL3RhYmJhYmxlLWxpc3Quc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VGFiYmFibGVMaXN0XScsXG4gICAgZXhwb3J0QXM6ICd1eC10YWJiYWJsZS1saXN0JyxcbiAgICBwcm92aWRlcnM6IFtUYWJiYWJsZUxpc3RTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBUYWJiYWJsZUxpc3REaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIERldGVybWluZSB3aGV0aGVyIHRoZSB1cC9kb3duIGFycm93cyBzaG91bGQgYmUgdXNlZCBvciB0aGUgbGVmdC9yaWdodCBhcnJvd3MgKi9cbiAgICBASW5wdXQoKSBkaXJlY3Rpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgPSAndmVydGljYWwnO1xuXG4gICAgLyoqIEluZGljYXRlIHdoZXRoZXIgb3Igbm90IGZvY3VzIHNob3VsZCBsb29wIGJhY2sgdG8gdGhlIGZpcnN0IGVsZW1lbnQgYWZ0ZXIgdGhlIGxhc3QgKi9cbiAgICBASW5wdXQoKSB3cmFwOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBJbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgZmlyc3QgaXRlbSBzaG91bGQgcmVjZWl2ZSBmb2N1cyBvbiBzaG93IC0gdXNlZnVsIGZvciBtb2RhbHMgYW5kIHBvcG92ZXJzICovXG4gICAgQElucHV0KCkgZm9jdXNPblNob3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBJbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCBmb2N1cyBzaG91bGQgYmUgcmV0dXJuZWQgdG8gdGhlIHByZXZpb3VzIGVsZW1lbnQgKG9ubHkgYXBwbGljYWJsZSB3aGVuIHVzaW5nIGZvY3VzT25TaG93KSAqL1xuICAgIEBJbnB1dCgpIHJldHVybkZvY3VzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogRW5hYmxpbmcgaGFuZGxpbmcgb2YgaGllcmFyY2hpY2FsIGxpc3RzIHZpYSB1c2Ugb2YgdGhlIGBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlLnBhcmVudGAgcHJvcGVydHkuICovXG4gICAgQElucHV0KCkgc2V0IGhpZXJhcmNoeSh2YWx1ZTogYm9vbGVhbikgeyB0aGlzLl90YWJiYWJsZUxpc3QuaGllcmFyY2h5ID0gdmFsdWU7IH1cblxuICAgIC8qKiBQcmV2ZW50IGtleWJvYXJkIGludGVyYWN0aW9uIHdoZW4gYWx0IG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkICovXG4gICAgQElucHV0KCkgc2V0IGFsbG93QWx0TW9kaWZpZXIodmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fdGFiYmFibGVMaXN0LmFsbG93QWx0TW9kaWZpZXIgPSB2YWx1ZTsgfVxuXG4gICAgLyoqIFByZXZlbnQga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2hlbiBjdHJsIG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkICovXG4gICAgQElucHV0KCkgc2V0IGFsbG93Q3RybE1vZGlmaWVyKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX3RhYmJhYmxlTGlzdC5hbGxvd0N0cmxNb2RpZmllciA9IHZhbHVlOyB9XG5cbiAgICAvKiogRm9jdXMgdGhlIGZpcnN0IG9yIGxhc3QgaXRlbSB3aGVuIEhvbWUgb3IgRW5kIGtleXMgYXJlIHByZXNzZWQgKi9cbiAgICBASW5wdXQoKSBzZXQgYWxsb3dCb3VuZGFyeUtleXModmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fdGFiYmFibGVMaXN0LmFsbG93Qm91bmRhcnlLZXlzID0gdmFsdWU7IH1cblxuICAgIC8qKiBGaW5kIGFsbCB0YWJiYWJsZSBsaXN0IGl0ZW1zICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pIGl0ZW1zOiBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT47XG5cbiAgICBwcml2YXRlIF9mb2N1c2VkRWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBfb3JkZXJlZEl0ZW1zOiBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT47XG5cbiAgICBnZXQgZm9jdXNLZXlNYW5hZ2VyKCk6IEZvY3VzS2V5TWFuYWdlcjxUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJiYWJsZUxpc3QuZm9jdXNLZXlNYW5hZ2VyO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYmJhYmxlTGlzdDogVGFiYmFibGVMaXN0U2VydmljZSkgeyB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIGlmICh0aGlzLl90YWJiYWJsZUxpc3QuaGllcmFyY2h5KSB7XG5cbiAgICAgICAgICAgIC8vIFNvcnQgaXRlbXMgaW4gYSBoaWVyYXJjaHlcbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWRJdGVtcyA9IG5ldyBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT4oKTtcbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWRJdGVtcy5yZXNldCh0aGlzLl90YWJiYWJsZUxpc3Quc29ydEl0ZW1zQnlIaWVyYXJjaHkodGhpcy5pdGVtcykpO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2hpbGQgaXRlbXMgcmVtYWluIHNvcnRlZFxuICAgICAgICAgICAgdGhpcy5pdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JkZXJlZEl0ZW1zLnJlc2V0KHRoaXMuX3RhYmJhYmxlTGlzdC5zb3J0SXRlbXNCeUhpZXJhcmNoeSh0aGlzLml0ZW1zKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JkZXJlZEl0ZW1zLm5vdGlmeU9uQ2hhbmdlcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSXRlbXMgYXJlIGFscmVhZHkgaW4gb3JkZXJcbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWRJdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGZvY3VzIG1vbml0b3JpbmdcbiAgICAgICAgdGhpcy5fdGFiYmFibGVMaXN0LmluaXRpYWxpemUodGhpcy5fb3JkZXJlZEl0ZW1zLCB0aGlzLmRpcmVjdGlvbiwgdGhpcy53cmFwKTtcblxuICAgICAgICAvLyBmb2N1cyB0aGUgZmlyc3QgZWxlbWVudCBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNPblNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5mb2N1c0tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucmV0dXJuRm9jdXMgJiYgdGhpcy5fZm9jdXNlZEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9mb2N1c2VkRWxlbWVudC5mb2N1cygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fdGFiYmFibGVMaXN0LmZvY3VzS2V5TWFuYWdlciAmJiB0aGlzLl90YWJiYWJsZUxpc3QuZm9jdXNLZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5mb2N1c0tleU1hbmFnZXIuYWN0aXZlSXRlbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNUYWJiYWJsZUl0ZW0oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5mb2N1c1RhYmJhYmxlSXRlbSgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEExMXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9jdXNXaXRoaW5EaXJlY3RpdmUgfSBmcm9tICcuL2ZvY3VzLXdpdGhpbi9mb2N1cy13aXRoaW4uZGlyZWN0aXZlJztcbmltcG9ydCB7IFNwbGl0dGVyQWNjZXNzaWJpbGl0eURpcmVjdGl2ZSB9IGZyb20gJy4vc3BsaXR0ZXIvc3BsaXR0ZXItYWNjZXNzaWJpbGl0eS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vdGFiYmFibGUtbGlzdC90YWJiYWJsZS1saXN0LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFRhYmJhYmxlTGlzdERpcmVjdGl2ZSB9IGZyb20gJy4vdGFiYmFibGUtbGlzdC90YWJiYWJsZS1saXN0LmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEZvY3VzV2l0aGluRGlyZWN0aXZlLFxuICAgICAgICBUYWJiYWJsZUxpc3REaXJlY3RpdmUsXG4gICAgICAgIFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIFNwbGl0dGVyQWNjZXNzaWJpbGl0eURpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBBMTF5TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEZvY3VzV2l0aGluRGlyZWN0aXZlLFxuICAgICAgICBUYWJiYWJsZUxpc3REaXJlY3RpdmUsXG4gICAgICAgIFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIFNwbGl0dGVyQWNjZXNzaWJpbGl0eURpcmVjdGl2ZSxcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFjY2Vzc2liaWxpdHlNb2R1bGUge30iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgTlVNQkVSX1BJQ0tFUl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE51bWJlclBpY2tlckNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbnVtYmVyLXBpY2tlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL251bWJlci1waWNrZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW05VTUJFUl9QSUNLRVJfVkFMVUVfQUNDRVNTT1JdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5oYXMtZXJyb3JdJzogJyFpc1ZhbGlkKCknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBOdW1iZXJQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBwcml2YXRlIF9taW46IG51bWJlciA9IC1JbmZpbml0eTtcbiAgICBwcml2YXRlIF9tYXg6IG51bWJlciA9IEluZmluaXR5O1xuICAgIHByaXZhdGUgX3N0ZXA6IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF92YWx1ZTogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIF9wcm9wYWdhdGVDaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG5cbiAgICBASW5wdXQoKSB2YWxpZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBASW5wdXQoJ3ZhbHVlJylcbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2UodmFsdWUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IG1pbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgIH1cbiAgICBzZXQgbWluKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21pbiA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IG1heCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cbiAgICBzZXQgbWF4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21heCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHN0ZXAoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gICAgfVxuICAgIHNldCBzdGVwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0ZXAgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2Rpc2FibGVkJykgfHwgdmFsdWUgPT09IHRydWU7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50KGV2ZW50OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMudmFsdWUgKyB0aGlzLnN0ZXAsIHRoaXMubWF4KSwgdGhpcy5taW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVjcmVtZW50KGV2ZW50OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMudmFsdWUgLSB0aGlzLnN0ZXAsIHRoaXMubWluKSwgdGhpcy5tYXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNWYWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPCB0aGlzLm1pbiB8fCB0aGlzLnZhbHVlID4gdGhpcy5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkO1xuICAgIH1cblxuICAgIG9uU2Nyb2xsKGV2ZW50OiBXaGVlbEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgbGV0IHNjcm9sbFZhbHVlID0gZXZlbnQuZGVsdGFZIHx8IGV2ZW50LndoZWVsRGVsdGE7XG5cbiAgICAgICAgaWYgKHNjcm9sbFZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWNyZW1lbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZUNoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHsgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IE51bWJlclBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vbnVtYmVyLXBpY2tlci5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW051bWJlclBpY2tlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbTnVtYmVyUGlja2VyQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBOdW1iZXJQaWNrZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgVGVtcGxhdGVSZWYsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5jaG9yUGxhY2VtZW50IH0gZnJvbSAnLi90b29sdGlwLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxubGV0IHVuaXF1ZVRvb2x0aXBJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXRvb2x0aXAnLFxuICB0ZW1wbGF0ZVVybDogJy4vdG9vbHRpcC5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFRvb2x0aXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIC8qKiBEZWZpbmUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdG9vbHRpcCAqL1xuICBpZDogc3RyaW5nID0gYHV4LXRvb2x0aXAtJHsrK3VuaXF1ZVRvb2x0aXBJZH1gO1xuXG4gIC8qKiBEZWZpbmUgdGhlIHRvb2x0aXAgcm9sZSAqL1xuICByb2xlOiBzdHJpbmcgPSAndG9vbHRpcCc7XG5cbiAgLyoqIFRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwLCBlaXRoZXIgYSBzdHJpbmcgb3IgYSBUZW1wbGF0ZVJlZiBmb3IgZnVydGhlciBjdXN0b21pemF0aW9uICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIEFsbG93IHRoZSB1c2VyIHRvIHN1cHBseSBhIGNvbnRleHQgZm9yIHRoZSB0b29sdGlwIFRlbXBsYXRlUmVmICovXG4gIGNvbnRleHQ6IGFueTtcblxuICAvKiogVGhlIHBvc2l0aW9uIHRoZSB0b29sdGlwIHNob3VsZCBkaXNwbGF5IHJlbGF0aXZlIHRvIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgKi9cbiAgcGxhY2VtZW50OiBBbmNob3JQbGFjZW1lbnQ7XG5cbiAgLyoqIEFsbG93IGEgY3VzdG9tIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSB0b29sdGlwIHRvIGFsbG93IGN1c3RvbSBzdHlsaW5nICovXG4gIGN1c3RvbUNsYXNzOiBzdHJpbmcgPSAnJztcblxuICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBjb250ZW50IGlzIGEgc3RyaW5nIG9yIGEgVGVtcGxhdGVSZWYgKi9cbiAgaXNUZW1wbGF0ZVJlZjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBFbWl0IHdoZW4gdGhlIHRvb2x0aXAgbmVlZCB0byB1cGRhdGUgaXQncyBwb3NpdGlvbiAqL1xuICByZXBvc2l0aW9uJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHt9XG5cbiAgLyoqIENsZWFudXAgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXBvc2l0aW9uJC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqIEluZm9ybSB0aGUgcGFyZW50IGRpcmVjdGl2ZSB0aGF0IGl0IG5lZWRzIHRvIHJlY2FsdWxhdGUgdGhlIHBvc2l0aW9uICovXG4gIHJlcG9zaXRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5yZXBvc2l0aW9uJC5uZXh0KCk7XG4gIH1cblxuICAvKiogVGhpcyB3aWxsIHVwZGF0ZSB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uICovXG4gIHNldENvbnRlbnQoY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pik6IHZvaWQge1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5pc1RlbXBsYXRlUmVmID0gY29udGVudCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHRvb2x0aXAgcGxhY2VtZW50IGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gKi9cbiAgc2V0UGxhY2VtZW50KHBsYWNlbWVudDogQW5jaG9yUGxhY2VtZW50KSB7XG5cbiAgICBpZiAoIXBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFRoaXMgd2lsbCBzZXQgYSBjdXN0b20gY2xhc3Mgb24gdGhlIHRvb2x0aXAgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRDbGFzcyhjdXN0b21DbGFzczogc3RyaW5nKTogdm9pZCB7XG5cbiAgICBpZiAoIWN1c3RvbUNsYXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXN0b21DbGFzcyA9IGN1c3RvbUNsYXNzO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFVwZGF0ZXMgdGhlIGNvbnRleHQgdXNlZCBieSB0aGUgVGVtcGxhdGVSZWYgKi9cbiAgc2V0Q29udGV4dChjb250ZXh0OiBhbnkpOiB2b2lkIHtcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogU3BlY2lmeSB0aGUgdG9vbHRpcCByb2xlIGF0dHJpYnV0ZSAqL1xuICBzZXRSb2xlKHJvbGU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgaWYgKCFyb2xlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRvb2x0aXBDb21wb25lbnQgfSBmcm9tICcuL3Rvb2x0aXAuY29tcG9uZW50JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVG9vbHRpcFNlcnZpY2Uge1xuICAgIHNob3duJCA9IG5ldyBTdWJqZWN0PFRvb2x0aXBDb21wb25lbnQ+KCk7XG59IiwiaW1wb3J0IHsgT3JpZ2luQ29ubmVjdGlvblBvc2l0aW9uLCBPdmVybGF5LCBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uLCBPdmVybGF5UmVmLCBTY3JvbGxEaXNwYXRjaGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tcG9uZW50UG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFJlbmRlcmVyMiwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRvb2x0aXBDb21wb25lbnQgfSBmcm9tICcuL3Rvb2x0aXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBTZXJ2aWNlIH0gZnJvbSAnLi90b29sdGlwLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRvb2x0aXBdJyxcbiAgICBleHBvcnRBczogJ3V4LXRvb2x0aXAnXG59KVxuZXhwb3J0IGNsYXNzIFRvb2x0aXBEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIC8qKiBDb250YWlucyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBvciBhIFRlbXBsYXRlUmVmIGZvciBtb3JlIGRldGFpbGVkIGNvbnRlbnQgKi9cbiAgICBASW5wdXQoJ3V4VG9vbHRpcCcpIGNvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKiogQWxsb3cgdGhlIHRvb2x0aXAgdG8gYmUgY29uZGl0aW9uYWxseSBkaXNhYmxlZCAqL1xuICAgIEBJbnB1dCgndG9vbHRpcERpc2FibGVkJykgZGlzYWJsZWQ6IGJvb2xlYW47XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIGN1c3RvbSBjbGFzcyB0byB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgndG9vbHRpcENsYXNzJykgY3VzdG9tQ2xhc3M6IHN0cmluZyA9ICcnO1xuXG4gICAgLyoqIEFsbCB0aGUgdXNlciB0byBhZGQgYSByb2xlIHRvIHRoZSB0b29sdGlwIC0gZGVmYXVsdCBpcyB0b29sdGlwICovXG4gICAgQElucHV0KCd0b29sdGlwUm9sZScpIHJvbGU6IHN0cmluZyA9ICd0b29sdGlwJztcblxuICAgIC8qKiBQcm92aWRlIHRoZSBUZW1wbGF0ZVJlZiBhIGNvbnRleHQgb2JqZWN0ICovXG4gICAgQElucHV0KCd0b29sdGlwQ29udGV4dCcpIGNvbnRleHQ6IGFueSA9IHt9O1xuXG4gICAgLyoqIERlbGF5IHRoZSBzaG93aW5nIG9mIHRoZSB0b29sdGlwIGJ5IGEgbnVtYmVyIG9mIG1pbGlzZWNvbmRzICovXG4gICAgQElucHV0KCd0b29sdGlwRGVsYXknKSBkZWxheTogbnVtYmVyID0gMDtcblxuICAgIC8qKiBQcm9ncmFtbWF0aWNhbGx5IHNob3cgYW5kIGhpZGUgdGhlIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoKSBpc09wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBDdXN0b21pemUgaG93IHRoZSB0b29sdGlwIHNob3VsZCBiZSBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50ICovXG4gICAgQElucHV0KCkgcGxhY2VtZW50OiBBbmNob3JQbGFjZW1lbnQgPSAndG9wJztcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgc2hvdyB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgpIHNob3dUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXTtcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgaGlkZSB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgpIGhpZGVUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ21vdXNlbGVhdmUnLCAnYmx1ciddO1xuXG4gICAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHRvb2x0aXAgaXMgc2hvd24gKi9cbiAgICBAT3V0cHV0KCkgc2hvd24gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdHMgYSBldmVudCB3aGVuIHRoZSB0b29sdGlwIGlzIGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKSBoaWRkZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogQWxsb3cgdHdvIHdheSBiaW5kaW5nIHRvIHRyYWNrIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB0b29sdGlwICovXG4gICAgQE91dHB1dCgpIGlzT3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBLZWVwIHRyYWNrIG9mIHRoZSB0b29sdGlwIHZpc2liaWxpdHkgKi9cbiAgICBpc1Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgQ0RLIHBvcnRhbCBjb250YWluaW5nIHRoZSBvdmVybGF5ICovXG4gICAgcHJvdGVjdGVkIF9wb3J0YWw6IENvbXBvbmVudFBvcnRhbDxUb29sdGlwQ29tcG9uZW50PjtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSB0aGUgdG9vbHRpcCB3aWxsIGJlIGluc2VydGVkIGludG8gKi9cbiAgICBwcm90ZWN0ZWQgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSB0b29sdGlwIGNvbXBvbmVudCB3aGVuIGNyZWF0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX2luc3RhbmNlOiBUb29sdGlwQ29tcG9uZW50O1xuXG4gICAgLyoqIFRoaXMgd2lsbCBlbWl0IHdoZW4gdGhlIGRpcmVjdGl2ZSBpcyBkZXN0cm95ZWQgYWxsb3dpbmcgdXMgdG8gdW5zdWJzY3JpYmUgYWxsIHN1YnNjcmlwdGlvbnMgYXV0b21hdGljYWxseSAqL1xuICAgIHByb3RlY3RlZCBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBTdG9yZSB0aGUgdGltZW91dCBpbnRlcnZhbCBmb3IgY2FuY2VsYXRpb24gKi9cbiAgICBwcml2YXRlIF9zaG93VGltZW91dElkOiBudW1iZXI7XG5cbiAgICAvKiogSW50ZXJuYWxseSBzdG9yZSB0aGUgdHlwZSBvZiB0aGlzIGNvbXBvbmVudCAtIHVzdWFsIGZvciBkaXN0aW5jdGlvbnMgd2hlbiBleHRlbmRpbmcgdGhpcyBjbGFzcyAqL1xuICAgIHByb3RlY3RlZCBfdHlwZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByb3RlY3RlZCBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJvdGVjdGVkIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgICAgIHByb3RlY3RlZCBfc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcixcbiAgICAgICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBwcml2YXRlIF90b29sdGlwU2VydmljZTogVG9vbHRpcFNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgLyoqIFNldCB1cCB0aGUgdHJpZ2dlcnMgYW5kIGJpbmQgdG8gdGhlIHNob3cvaGlkZSBldmVudHMgdG8ga2VlcCB2aXNpYmlsaXR5IGluIHN5bmMgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzZXQgdXAgc2hvdyBhbmQgaGlkZSBldmVudCB0cmlnZ2Vyc1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2xpY2snKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VlbnRlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uTW91c2VFbnRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlbGVhdmUnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdibHVyJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25CbHVyLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIHdoZW4gYW55IG90aGVyIHRvb2x0aXBzIG9wZW4gaGlkZSB0aGlzIG9uZVxuICAgICAgICB0aGlzLl90b29sdGlwU2VydmljZS5zaG93biQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl90eXBlID09PSAndG9vbHRpcCcpLFxuICAgICAgICAgICAgZmlsdGVyKHRvb2x0aXAgPT4gdG9vbHRpcCAhPT0gdGhpcy5faW5zdGFuY2UpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgKS5zdWJzY3JpYmUodGhpcy5oaWRlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b29sdGlwIHNob3VsZCBiZSBpbml0aWFsbHkgdmlzaWJsZSB0aGVuIG9wZW4gaXRcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gc2VuZCBpbnB1dCBjaGFuZ2VzIHRvIHRoZSB0b29sdGlwIGNvbXBvbmVudFxuICAgICAqIFdlIGNhbid0IHVzZSBzZXR0ZXJzIGFzIHRoZXkgbWF5IHRyaWdnZXIgYmVmb3JlIHRvb2x0aXAgaW5pdGlhbGlzZWQgYW5kIGNhbid0IHJlc2VuZCBvbmNlIGluaXRpYWxpc2VkXG4gICAgICoqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcblxuICAgICAgICAvLyB3ZSBjYW4gaWdub3JlIHRoZSBmaXJzdCBjaGFuZ2UgYXMgaXQncyBoYW5kbGVkIGluIG5nT25Jbml0XG4gICAgICAgIGlmIChjaGFuZ2VzLmlzT3BlbiAmJiAhY2hhbmdlcy5pc09wZW4uZmlyc3RDaGFuZ2UgJiYgY2hhbmdlcy5pc09wZW4uY3VycmVudFZhbHVlICE9PSB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgY2hhbmdlcy5pc09wZW4uY3VycmVudFZhbHVlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgdGhlIG92ZXJsYXkgcmVmIHNvIGEgbmV3IGNvcnJlY3RseSBwb3NpdGlvbmVkIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZCBuZXh0IHRpbWVcbiAgICAgICAgaWYgKGNoYW5nZXMucGxhY2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lPdmVybGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldFBsYWNlbWVudChjaGFuZ2VzLnBsYWNlbWVudC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMuY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0Q29udGVudChjaGFuZ2VzLmNvbnRlbnQuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLmN1c3RvbUNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDbGFzcyhjaGFuZ2VzLmN1c3RvbUNsYXNzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDb250ZXh0KGNoYW5nZXMuY29udGV4dC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMucm9sZSkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0Q29udGV4dChjaGFuZ2VzLnJvbGUuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBFbnN1cmUgd2UgY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZW5zdXJlIHdlIGNsb3NlIHRoZSB0b29sdGlwIHdoZW4gdGhlIGhvc3QgaXMgZGVzdHJveWVkXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhpcyBldmVudCB0byBhdXRvbWF0aWNhbGx5IHVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIE1ha2UgdGhlIHRvb2x0aXAgb3BlbiAqL1xuICAgIHNob3coKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvb2x0aXAgaXMgZGlzYWJsZWQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMuaXNWaXNpYmxlIHx8IHRoaXMuX3Nob3dUaW1lb3V0SWQgfHwgIXRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVsYXkgdGhlIHNob3cgYnkgdGhlIGRlbGF5IGFtb3VudFxuICAgICAgICB0aGlzLl9zaG93VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHRvb2x0aXAgYW5kIGdldCB0aGUgb3ZlcmxheSByZWZcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBwb3J0YWwgdG8gY3JlYXRlIHRoZSB0b29sdGlwIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5fcG9ydGFsID0gdGhpcy5jcmVhdGVQb3J0YWwoKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gdGhpcy5jcmVhdGVJbnN0YW5jZShvdmVybGF5UmVmKTtcblxuICAgICAgICAgICAgLy8gd2F0Y2ggZm9yIGFueSBjaGFuZ2VzIHRvIHRoZSBjb250ZW50XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5yZXBvc2l0aW9uJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5yZXBvc2l0aW9uLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgdmlzaWJsZSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIG92ZXJsYXkgaGFzIHRoZSBjb3JyZWN0IGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgICAgIHRoaXMucmVwb3NpdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBzaG93IGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5zaG93bi5lbWl0KCk7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbkNoYW5nZS5uZXh0KHRydWUpO1xuXG4gICAgICAgICAgICAvLyBjbGVhciB0aGUgaW50ZXJ2YWwgaWRcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBzaG93IGV2ZW50IHRvIGNsb3NlIGFueSBvdGhlciB0b29sdGlwc1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFNlcnZpY2Uuc2hvd24kLm5leHQodGhpcy5faW5zdGFuY2UpO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgY2hhbmdlIGRldGVjdGlvbiBpcyBydW5cbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSwgdGhpcy5kZWxheSk7XG5cbiAgICB9XG5cbiAgICAvKiogSWYgYSB0b29sdGlwIGV4aXN0cyBhbmQgaXMgdmlzaWJsZSwgaGlkZSBpdCAqL1xuICAgIGhpZGUoKSB7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHdhaXRpbmcgdG8gc2hvdyBhIHRvb2x0aXAgdGhlbiBjYW5jZWwgdGhlIHBlbmRpbmcgdGltZW91dFxuICAgICAgICBpZiAodGhpcy5fc2hvd1RpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZiAmJiB0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEFyaWFEZXNjcmliZWRCeShudWxsKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSB2aXNpYmxlIHN0YXRlXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgaGlkZSBldmVudHNcbiAgICAgICAgdGhpcy5oaWRkZW4uZW1pdCgpO1xuICAgICAgICB0aGlzLmlzT3BlbkNoYW5nZS5uZXh0KGZhbHNlKTtcblxuICAgICAgICAvLyBlbnN1cmUgY2hhbmdlIGRldGVjdGlvbiBpcyBydW5cbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXAgKi9cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICAvKiogUmVjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyICovXG4gICAgcmVwb3NpdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW4gaW5zdGFuY2UgZnJvbSB0aGUgb3ZlcmxheSByZWYgLSBhbGxvd3Mgb3ZlcnJpZGluZyBhbmQgYWRkaXRpb25hbCBsb2dpYyBoZXJlICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluc3RhbmNlKG92ZXJsYXlSZWY6IE92ZXJsYXlSZWYpOiBUb29sdGlwQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBvdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9wb3J0YWwpLmluc3RhbmNlIGFzIFRvb2x0aXBDb21wb25lbnQ7XG5cbiAgICAgICAgLy8gc3VwcGx5IHRoZSB0b29sdGlwIHdpdGggdGhlIGNvcnJlY3QgcHJvcGVydGllc1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldFBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldENsYXNzKHRoaXMuY3VzdG9tQ2xhc3MpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIGluc3RhbmNlLnNldFJvbGUodGhpcy5yb2xlKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuc2V0QXJpYURlc2NyaWJlZEJ5KGluc3RhbmNlLmlkKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSB0aGUgY29tcG9uZW50IHBvcnRhbCAtIGFsbG93cyBvdmVycmlkaW5nIHRvIGFsbG93IG90aGVyIHBvcnRhbHMgZWcuIHBvcG92ZXJzICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVBvcnRhbCgpOiBDb21wb25lbnRQb3J0YWw8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0YWwgfHwgbmV3IENvbXBvbmVudFBvcnRhbChUb29sdGlwQ29tcG9uZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIHRoZSBvdmVybGF5IGFuZCBzZXQgdXAgdGhlIHNjcm9sbCBoYW5kbGluZyBiZWhhdmlvciAqL1xuICAgIHByaXZhdGUgY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgdGhlbiBqdXN0IHJldHVybiB0aGUgZXhpc3RpbmcgaW5zdGFuY2VcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uZmlndXJlIHRoZSB0b29sdGlwXG4gICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudFJlZiwgdGhpcy5nZXRPcmlnaW4oKSwgdGhpcy5nZXRPdmVybGF5UG9zaXRpb24oKSk7XG5cbiAgICAgICAgLy8gY29ycmVjdGx5IGhhbmRsZSBzY3JvbGxpbmdcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9ycyA9IHRoaXMuX3Njcm9sbERpc3BhdGNoZXJcbiAgICAgICAgICAgIC5nZXRBbmNlc3RvclNjcm9sbENvbnRhaW5lcnModGhpcy5fZWxlbWVudFJlZik7XG5cbiAgICAgICAgc3RyYXRlZ3kud2l0aFNjcm9sbGFibGVDb250YWluZXJzKHNjcm9sbGFibGVBbmNlc3RvcnMpO1xuXG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZSh7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiBzdHJhdGVneSxcbiAgICAgICAgICAgIHBhbmVsQ2xhc3M6ICd1eC1vdmVybGF5LXBhbmUnLFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKHsgc2Nyb2xsVGhyb3R0bGU6IDAgfSksXG4gICAgICAgICAgICBoYXNCYWNrZHJvcDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gICAgfVxuXG4gICAgLyoqIFJlY3JlYXRlIHRoZSBvdmVybGF5IHJlZiB1c2luZyB0aGUgdXBkYXRlZCBvcmlnaW4gYW5kIG92ZXJsYXkgcG9zaXRpb25zICovXG4gICAgcHJpdmF0ZSBkZXN0cm95T3ZlcmxheSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBkZXN0cm95IHRoZSBleGlzdGluZyBvdmVybGF5XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmICYmIHRoaXMuX292ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBvcmlnaW4gcG9zaXRpb24gYmFzZWQgb24gdGhlIHNwZWNpZmllZCB0b29sdGlwIHBsYWNlbWVudCAqL1xuICAgIHByaXZhdGUgZ2V0T3JpZ2luKCk6IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiB7XG5cbiAgICAgICAgLy8gZW5zdXJlIHBsYWNlbWVudCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMucGxhY2VtZW50ID0gdGhpcy5wbGFjZW1lbnQgfHwgJ3RvcCc7XG5cbiAgICAgICAgaWYgKHRoaXMucGxhY2VtZW50ID09ICd0b3AnIHx8IHRoaXMucGxhY2VtZW50ID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogdGhpcy5wbGFjZW1lbnQgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2FsY3VsYXRlIHRoZSBvdmVybGF5IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgdG9vbHRpcCBwbGFjZW1lbnQgKi9cbiAgICBwcml2YXRlIGdldE92ZXJsYXlQb3NpdGlvbigpOiBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uIHtcblxuICAgICAgICAvLyBlbnN1cmUgcGxhY2VtZW50IGlzIGRlZmluZWRcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSB0aGlzLnBsYWNlbWVudCB8fCAndG9wJztcblxuICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICdib3R0b20nIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICd0b3AnIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxhY2VtZW50ID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSB1dGlsaXR5IG1ldGhvZCAtIGJlY2F1c2UgSUUgZG9lc24ndCBzdXBwb3J0IGFycmF5LmluY2x1ZGVzXG4gICAgICogQW5kIGl0IGlzbid0IGluY2x1ZGVkIGluIHRoZSBjb3JlLWpzL2VzNiBwb2x5ZmlsbHMgd2hpY2ggYXJlIHRoZVxuICAgICAqIG9ubHkgb25lcyByZXF1aXJlZCBieSBBbmd1bGFyIGFuZCBndWFyYW50ZWVkIHRvIGJlIHRoZXJlXG4gICAgICoqL1xuICAgIHByb3RlY3RlZCBpbmNsdWRlczxUPihhcnJheTogQXJyYXk8VD4sIHZhbHVlOiBUKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5KSAmJiAhIWFycmF5LmZpbmQoaXRlbSA9PiBpdGVtID09PSB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgY2xpY2sgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25DbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIGl0cyBub3QgdmlzaWJsZSBhbmQgY2xpY2sgaXMgYSBzaG93IHRyaWdnZXIgb3BlbiBpdFxuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlICYmIHRoaXMuaW5jbHVkZXModGhpcy5zaG93VHJpZ2dlcnMsICdjbGljaycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdHMgdmlzaWJsZSBhbmQgY2xpY2sgaXMgYSBoaWRlIHRyaWdnZXIgY2xvc2UgaXRcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIHRoaXMuaW5jbHVkZXModGhpcy5oaWRlVHJpZ2dlcnMsICdjbGljaycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIG1vdXNlIGVudGVyIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uTW91c2VFbnRlcihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYW4gc2hvdyBvbmx5IHRyaWdnZXIgLSBpZiBhbHJlYWR5IG9wZW4gb3IgaXQgaXNuJ3QgYSB0cmlnZ2VyIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmluY2x1ZGVzKHRoaXMuc2hvd1RyaWdnZXJzLCAnbW91c2VlbnRlcicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugb3BlbiB0aGUgdG9vbHRpcFxuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBtb3VzZSBsZWF2ZSBldmVudCAtIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseSAqL1xuICAgIHByb3RlY3RlZCBvbk1vdXNlTGVhdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGFuIGhpZGUgb25seSB0cmlnZ2VyIC0gaWYgbm90IG9wZW4gb3IgaXQgaXNuJ3QgYSB0cmlnZ2VyIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSB8fCAhdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ21vdXNlbGVhdmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNsb3NlIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIGZvY3VzIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uRm9jdXMoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhbiBzaG93IG9ubHkgdHJpZ2dlciAtIGlmIGFscmVhZHkgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgfHwgIXRoaXMuaW5jbHVkZXModGhpcy5zaG93VHJpZ2dlcnMsICdmb2N1cycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugb3BlbiB0aGUgdG9vbHRpcFxuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBibHVyIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uQmx1cihldmVudDogRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGFuIGhpZGUgb25seSB0cmlnZ2VyIC0gaWYgbm90IG9wZW4gb3IgaXQgaXNuJ3QgYSB0cmlnZ2VyIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSB8fCAhdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ2JsdXInKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNsb3NlIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmUgaWYgdGhlIHRyaWdnZXIgZWxlbWVudCBpcyBmb2N1c2VkICovXG4gICAgcHJpdmF0ZSBpc0ZvY3VzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgdXBkYXRlIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5ICovXG4gICAgcHJvdGVjdGVkIHNldEFyaWFEZXNjcmliZWRCeShpZDogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYXJpYS1kZXNjcmliZWRieScsIGlkKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgdHlwZSBBbmNob3JQbGFjZW1lbnQgPSAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JzsiLCJpbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi90b29sdGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUb29sdGlwRGlyZWN0aXZlIH0gZnJvbSAnLi90b29sdGlwLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBPYnNlcnZlcnNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb2JzZXJ2ZXJzJztcbmltcG9ydCB7IFRvb2x0aXBTZXJ2aWNlIH0gZnJvbSAnLi90b29sdGlwLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgT2JzZXJ2ZXJzTW9kdWxlXG4gIF0sXG4gIGV4cG9ydHM6IFtUb29sdGlwRGlyZWN0aXZlXSxcbiAgZGVjbGFyYXRpb25zOiBbVG9vbHRpcENvbXBvbmVudCwgVG9vbHRpcERpcmVjdGl2ZV0sXG4gIHByb3ZpZGVyczogW1Rvb2x0aXBTZXJ2aWNlXSxcbiAgZW50cnlDb21wb25lbnRzOiBbVG9vbHRpcENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5TW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9hY2Nlc3NpYmlsaXR5L2luZGV4JztcbmltcG9ydCB7IE51bWJlclBpY2tlck1vZHVsZSB9IGZyb20gJy4uL251bWJlci1waWNrZXIvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgQ29sb3JQaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL2NvbG9yLXBpY2tlci5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQWNjZXNzaWJpbGl0eU1vZHVsZSxcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgTnVtYmVyUGlja2VyTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgIF0sXG4gICAgZXhwb3J0czogW0NvbG9yUGlja2VyQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtDb2xvclBpY2tlckNvbXBvbmVudF0sXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JQaWNrZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eENvbHVtblNvcnRpbmddJ1xufSlcbmV4cG9ydCBjbGFzcyBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHNpbmdsZVNvcnQ6IGJvb2xlYW47XG4gICAgZXZlbnRzID0gbmV3IFN1YmplY3Q8Q29sdW1uU29ydGluZ09yZGVyW10+KCk7XG4gICAgb3JkZXI6IENvbHVtblNvcnRpbmdPcmRlcltdID0gW107XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ldmVudHMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVDb2x1bW4oc29ydGluZzogQ29sdW1uU29ydGluZ09yZGVyKTogQ29sdW1uU29ydGluZ09yZGVyW10ge1xuXG4gICAgICAgIC8vIGFwcGx5IHNvcnRpbmcgYmFzZWQgb24gdGhlIHNpbmdsZSBvciBtdWx0aXBsZSBzb3J0XG4gICAgICAgIHRoaXMub3JkZXIgPSB0aGlzLnNpbmdsZVNvcnQgPyB0aGlzLnRvZ2dsZVNpbmdsZUNvbHVtbihzb3J0aW5nKSA6IHRoaXMudG9nZ2xlTXVsdGlwbGVDb2x1bW4oc29ydGluZyk7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgbGF0ZXN0IG9yZGVyXG4gICAgICAgIHRoaXMuZXZlbnRzLm5leHQodGhpcy5vcmRlcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVTaW5nbGVDb2x1bW4oc29ydGluZzogQ29sdW1uU29ydGluZ09yZGVyKTogQ29sdW1uU29ydGluZ09yZGVyW10ge1xuICAgICAgICByZXR1cm4gc29ydGluZy5zdGF0ZSA9PT0gQ29sdW1uU29ydGluZ1N0YXRlLk5vU29ydCA/IFtdIDogW3sga2V5OiBzb3J0aW5nLmtleSwgc3RhdGU6IHNvcnRpbmcuc3RhdGUgfV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVNdWx0aXBsZUNvbHVtbihzb3J0aW5nOiBDb2x1bW5Tb3J0aW5nT3JkZXIpOiBDb2x1bW5Tb3J0aW5nT3JkZXJbXSB7XG4gICAgICAgIC8vIHJlb3JkZXIgY29sdW1ucyBoZXJlXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMub3JkZXIuZmluZEluZGV4KGNvbHVtbiA9PiBjb2x1bW4ua2V5ID09PSBzb3J0aW5nLmtleSk7XG5cbiAgICAgICAgLy8gaWYgd2FzbnQgcHJldmlvdXNseSBzZWxlY3RlZCBhZGQgdG8gbGlzdFxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLm9yZGVyLCB7IGtleTogc29ydGluZy5rZXksIHN0YXRlOiBzb3J0aW5nLnN0YXRlIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHNvcnRpbmcgaXQgY2hhbmdlIHRoZSBzb3J0aW5nIG9yZGVyXG4gICAgICAgIGlmIChzb3J0aW5nLnN0YXRlID09PSBDb2x1bW5Tb3J0aW5nU3RhdGUuQXNjZW5kaW5nIHx8IHNvcnRpbmcuc3RhdGUgPT09IENvbHVtblNvcnRpbmdTdGF0ZS5EZXNjZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMub3JkZXIuZmlsdGVyKF9jb2x1bW4gPT4gX2NvbHVtbi5rZXkgIT09IHNvcnRpbmcua2V5KSwgeyBrZXk6IHNvcnRpbmcua2V5LCBzdGF0ZTogc29ydGluZy5zdGF0ZSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSByZW1vdmUgdGhlIGl0ZW1cbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXIuZmlsdGVyKF9jb2x1bW4gPT4gX2NvbHVtbi5rZXkgIT09IHNvcnRpbmcua2V5KTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uU29ydGluZ09yZGVyIHtcbiAgICBrZXk6IHN0cmluZztcbiAgICBzdGF0ZTogQ29sdW1uU29ydGluZ1N0YXRlO1xufVxuXG5leHBvcnQgZW51bSBDb2x1bW5Tb3J0aW5nU3RhdGUge1xuICAgIEFzY2VuZGluZyA9ICdhc2NlbmRpbmcnLFxuICAgIERlc2NlbmRpbmcgPSAnZGVzY2VuZGluZycsXG4gICAgTm9Tb3J0ID0gJ25vbmUnXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlLCBDb2x1bW5Tb3J0aW5nT3JkZXIsIENvbHVtblNvcnRpbmdTdGF0ZSB9IGZyb20gJy4vY29sdW1uLXNvcnRpbmcuZGlyZWN0aXZlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1jb2x1bW4tc29ydGluZycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NvbHVtbi1zb3J0aW5nLmNvbXBvbmVudC5odG1sJyxcbiAgICBleHBvcnRBczogJ3V4LWNvbHVtbi1zb3J0aW5nJ1xufSlcbmV4cG9ydCBjbGFzcyBDb2x1bW5Tb3J0aW5nQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHN0YXRlOiBDb2x1bW5Tb3J0aW5nU3RhdGU7XG4gICAgQElucHV0KCkga2V5OiBzdHJpbmc7XG4gICAgQE91dHB1dCgpIHN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDb2x1bW5Tb3J0aW5nU3RhdGU+KCk7XG5cbiAgICBvcmRlcjogbnVtYmVyO1xuICAgIGNvbHVtblNvcnRpbmdTdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZTtcblxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb2x1bW5Tb3J0ZXI6IENvbHVtblNvcnRpbmdEaXJlY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fY29sdW1uU29ydGVyLmV2ZW50cy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgc29ydGluZyB0aGlzIGNvbHVtbiB0aGVuIGZpbmQgdGhlIG1hdGNoaW5nIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbklkeCA9IGV2ZW50LmZpbmRJbmRleChfY29sdW1uID0+IF9jb2x1bW4ua2V5ID09PSB0aGlzLmtleSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgc29ydGluZyB0aGlzIGNvbHVtbiB0aGVuIG1hcmsgaXQgYXMgTm9Tb3J0XG4gICAgICAgICAgICBpZiAoY29sdW1uSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbmx5IHN0b3JlIHRoZSBudW1iZXIgaWYgd2UgaGF2ZSAyIG9yIG1vcmUgY29sdW1ucyBiZWluZyBzb3J0ZWRcbiAgICAgICAgICAgIHRoaXMub3JkZXIgPSBldmVudC5sZW5ndGggPCAyIHx8IGNvbHVtbklkeCA9PT0gLTEgPyBudWxsIDogY29sdW1uSWR4ICsgMTtcblxuICAgICAgICAgICAgLy8gRW1pdCB0aGUgbGF0ZXN0IGNoYW5nZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZS5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgY2hhbmdlU3RhdGUoKTogQ29sdW1uU29ydGluZ09yZGVyW10ge1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlIENvbHVtblNvcnRpbmdTdGF0ZS5Bc2NlbmRpbmc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZS5EZXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbHVtblNvcnRpbmdTdGF0ZS5EZXNjZW5kaW5nOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGUuQXNjZW5kaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5mb3JtIHBhcmVudFxuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uU29ydGVyLnRvZ2dsZUNvbHVtbih7IGtleTogdGhpcy5rZXksIHN0YXRlOiB0aGlzLnN0YXRlIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb2x1bW5Tb3J0aW5nQ29tcG9uZW50IH0gZnJvbSAnLi9jb2x1bW4tc29ydGluZy5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9jb2x1bW4tc29ydGluZy5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtDb2x1bW5Tb3J0aW5nQ29tcG9uZW50LCBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtDb2x1bW5Tb3J0aW5nQ29tcG9uZW50LCBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBDb2x1bW5Tb3J0aW5nTW9kdWxlIHsgfSIsImltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQ29uZHVpdFpvbmUgfSBmcm9tICcuL2NvbmR1aXQtem9uZS5zZXJ2aWNlJztcbmltcG9ydCB7IENvbmR1aXRFdmVudCB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LWV2ZW50JztcbmltcG9ydCB7IENvbmR1aXRNZXRhZGF0YSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LW1ldGFkYXRhJztcblxuZXhwb3J0IGNsYXNzIENvbmR1aXRTdWJqZWN0IHtcblxuICAgIHByaXZhdGUgX3N1YmplY3Q6IFN1YmplY3Q8YW55PjtcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSwgcHJpdmF0ZSBfem9uZTogQ29uZHVpdFpvbmUsIHB1YmxpYyB6b25lSWQ6IHN0cmluZykge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSB0YXJnZXQgc3ViamVjdCBvYmplY3RcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IGNvbmR1aXQuc3ViamVjdDtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGNvbmR1aXRzIHRoYXQgaGF2ZSBzdXBwbGllZCBhbiBpbml0aWFsIHZhbHVlXG4gICAgICAgIHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gdGhlIHNvdXJjZSBzdWJqZWN0XG4gICAgICAgIHRoaXMuX3N1YmplY3QucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZChjb25kdWl0LmNoYW5nZURldGVjdGlvbiksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLm9uT3V0cHV0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byB0aGUgem9uZSBldmVudHMgYW5kIHJvb3Qgem9uZSBldmVudHNcbiAgICAgICAgX3pvbmUuZ2V0RXZlbnRzKCkucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQuY29uZHVpdC5pZCA9PT0gY29uZHVpdC5pZCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKiBDaGVjayBhbGwgYWxsb3cgaW5wdXRzIHRvIHNlZSBpZiB0aGVyZSBpcyBhIHZhbHVlIHdlIHNob3VsZCBpbml0aWFsbHkgc2V0IHRoZSBjb25kdWl0IHRvICovXG4gICAgZ2V0SW5pdGlhbFZhbHVlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHdlIGRvIG5vdCBhY2NlcHQgaW5wdXRzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBhbGwgc3ViamVjdHMgdGhhdCBhcmUgMSkgTm90IGl0c2VsZiAyKSBJbiBhIHpvbmUgdGhhdCBpcyBsaXN0ZWQgaW4gYWNjZXB0c0lucHV0IDMpIEhhdmUgYSBjdXJyZW50VmFsdWUgc2V0XG4gICAgICAgIGNvbnN0IHN1YmplY3RzID0gdGhpcy5fem9uZS5nZXRTdWJqZWN0cygpLmZpbHRlcihzdWJqZWN0ID0+IHtcblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBpdHNlbGYgb3IgaWYgaXQgaGFzIG5vdCB2YWx1ZSB0byBnaXZlIHVzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICAgICAgaWYgKHN1YmplY3QgPT09IHRoaXMgfHwgc3ViamVjdC5jb25kdWl0LmlkICE9PSB0aGlzLmNvbmR1aXQuaWQgfHwgIXN1YmplY3QuY29uZHVpdC5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudFZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGFjY2VwdHNJbnB1dCBpcyB0cnVlIHRoZW4gd2UgcmV0dXJuIGV2ZXJ5IHRpbWVcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQuaW5kZXhPZihzdWJqZWN0LnpvbmVJZCkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWF0Y2hlcyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHN1YmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNvcnQgYnkgdGhlIGxhc3QgbW9kaWZpZWQgZmllbGRcbiAgICAgICAgc3ViamVjdHMuc29ydCgoc3ViamVjdE9uZSwgc3ViamVjdFR3bykgPT4gc3ViamVjdE9uZS5jb25kdWl0Lmxhc3RNb2RpZmllZC5nZXRUaW1lKCkgPCBzdWJqZWN0VHdvLmNvbmR1aXQubGFzdE1vZGlmaWVkLmdldFRpbWUoKSA/IDEgOiAtMSk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBtb3N0IHJlY2VudCB2YWx1ZVxuICAgICAgICB0aGlzLl9zdWJqZWN0Lm5leHQoc3ViamVjdHNbMF0uY29uZHVpdC5jdXJyZW50VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKiBUaGlzIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gYSBjb25kdWl0cyB2YWx1ZSBoYXMgY2hhbmdlZCAqL1xuICAgIG9uSW5wdXQoZXZlbnQ6IENvbmR1aXRFdmVudCk6IHZvaWQge1xuICAgICAgICAvLyBpZiB3ZSBkb250IGFjY2VwdCBpbnB1dCBvciB3ZSBlbWl0dGVkIHRoaXMgdmFsdWUgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0ID09PSBmYWxzZSB8fCBldmVudC5jb25kdWl0ID09PSB0aGlzLmNvbmR1aXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjb25kdWl0IHByb2R1Y2VzIG91dHB1dCAtIGlmIG5vdCB3ZSBvbmx5IGRvIHNvbWV0aGluZyBpZiB3ZSBhcmUgaW4gdGhlIHNhbWUgem9uZVxuICAgICAgICBpZiAoZXZlbnQuY29uZHVpdC5wcm9kdWNlc091dHB1dCA9PT0gZmFsc2UgJiYgZXZlbnQuem9uZUlkICE9PSB0aGlzLnpvbmVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugb25seSBhY2NlcHQgaW5wdXRzIGZyb20gc3BlY2lmaWMgem9uZXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBldmVudCBjYW1lIGZyb20gYW4gYWNjZXB0YWJsZSB6b25lXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQuZmluZCh6b25lID0+IHpvbmUgPT09IGV2ZW50LnpvbmVJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiByZXF1aXJlZCB0cmFuc2Zvcm0gdGhlIHZhbHVlXG4gICAgICAgIGNvbnN0IG91dHB1dFZhbHVlID0gdGhpcy5jb25kdWl0Lm1hcCA/IHRoaXMuY29uZHVpdC5tYXAoZXZlbnQudmFsdWUpIDogZXZlbnQudmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdWJqZWN0XG4gICAgICAgIHRoaXMuX3N1YmplY3QubmV4dChvdXRwdXRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIFRoaXMgd2lsbCBiZSBmaXJlZCB3aGVuIHRoaXMgY29uZHVpdCBlbWl0cyBhIG5ldyB2YWx1ZSAqL1xuICAgIG9uT3V0cHV0KHZhbHVlOiBhbnkpOiB2b2lkIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbW9zdCByZWNlbnQgdmFsdWUgYW5kIHdoZW4gaXQgd2FzIG1vZGlmaWVkIC0gY2FuIGJlIHVzZWQgZm9yIGFueSBuZXcgY29uZHVpdHMgdG8gbG9va3VwIGEgdmFsdWVcbiAgICAgICAgdGhpcy5jb25kdWl0LmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmR1aXQubGFzdE1vZGlmaWVkID0gbmV3IERhdGUoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHNob3VsZCBwcm9kdWNlIG91dHB1dFxuICAgICAgICBpZiAodGhpcy5jb25kdWl0LnByb2R1Y2VzT3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLmVtaXQoeyBjb25kdWl0OiB0aGlzLmNvbmR1aXQsIHpvbmVJZDogdGhpcy56b25lSWQsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFVuc3Vic2NyaWJlIG9uY2UgdGhpcyBzdWJqZWN0IGlzIGRlc3Ryb3llZCAqL1xuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbiIsIi8qKiBUaGlzIHV0aWxpdHkgaXMgdG8gZW5zdXJlIGEgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhcmUgY2FsbGVkIGluIGFsbCBzdXBlciBjbGFzc2VzICovXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlU3VwZXJGdW5jdGlvbih0YXJnZXQ6IG9iamVjdCwgZnVuY3Rpb25OYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBnZXQgYWxsIGluc3RhbmNlcyBvZiB0aGUgZnVuY3Rpb25cbiAgICBjb25zdCBmdW5jdGlvbkxpc3Q6IEZ1bmN0aW9uW10gPSBbXTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IHByb3RvdHlwZSB3ZSBhcmUgY2hlY2tpbmdcbiAgICBsZXQgcHJvdG90eXBlOiBhbnkgPSB0YXJnZXQ7XG5cbiAgICAvLyBsb29rIHRocm91Z2ggZXZlcnkgYmFzZSBjbGFzcyBhbmQgY2hlY2sgaXRcbiAgICBkbyB7XG4gICAgICAgIGlmIChwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25MaXN0LnB1c2gocHJvdG90eXBlW2Z1bmN0aW9uTmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG90eXBlID0gcHJvdG90eXBlLl9fcHJvdG9fXztcbiAgICB9IHdoaWxlIChwcm90b3R5cGUuX19wcm90b19fKTtcblxuICAgIC8vIGF1Z21lbnQgdGhlIHRvcCBsZXZlbCBmdW5jdGlvbiB0byBjYWxsIGFsbCB0aGUgZnVuY3Rpb25zXG4gICAgdGFyZ2V0W2Z1bmN0aW9uTmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgZnVuY3Rpb25MaXN0LmZvckVhY2goZnVuYyA9PiBmdW5jLmNhbGwodGFyZ2V0LCAuLi5hcmdzKSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBDb25kdWl0U3ViamVjdCB9IGZyb20gJy4vY29uZHVpdC1zdWJqZWN0JztcbmltcG9ydCB7IENvbmR1aXRFdmVudCB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LWV2ZW50JztcbmltcG9ydCB7IENvbmR1aXRNZXRhZGF0YSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LW1ldGFkYXRhJztcbmltcG9ydCB7IENvbmR1aXRQcm9wZXJ0aWVzIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb25kdWl0Wm9uZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogQ3JlYXRlIGEgZ2xvYmFsIHN1YmplY3Qgc3RvcmUgKi9cbiAgICBzdGF0aWMgc3ViamVjdHM6IENvbmR1aXRTdWJqZWN0W10gPSBbXTtcblxuICAgIC8qKiBFeHBvc2UgYW4gZXZlbnQgc3RyZWFtIG9mIG5ldyB2YWx1ZXMgKi9cbiAgICBzdGF0aWMgZXZlbnRzID0gbmV3IFN1YmplY3Q8Q29uZHVpdEV2ZW50PigpO1xuXG4gICAgLyoqIFN0b3JlIHRoZSB6b25lIG5hbWUgKi9cbiAgICBwcml2YXRlIF96b25lSWQ6IHN0cmluZztcblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIGFsbCBjb25kdWl0IHN1YmplY3RzIHRoYXQgYXJlIHBhcnQgb2YgdGhpcyB6b25lXG4gICAgICAgIENvbmR1aXRab25lLnN1YmplY3RzLmZpbHRlcihfc3ViamVjdCA9PiBfc3ViamVjdC56b25lSWQgPT09IHRoaXMuX3pvbmVJZClcbiAgICAgICAgICAgIC5mb3JFYWNoKF9zdWJqZWN0ID0+IHRoaXMudW5yZWdpc3RlckNvbmR1aXQoX3N1YmplY3QuY29uZHVpdCkpO1xuICAgIH1cblxuICAgIC8qKiBTdG9yZSByZWZlcmVuY2UgdG8gdGhlIHJlcG9zaXRvcnkgYW5kIGJlZ2luIHdhdGNoaW5nIGZvciBhbmQgZW1pdHRpbmcgY2hhbmdlcyAqL1xuICAgIHJlZ2lzdGVyQ29uZHVpdChjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEpOiB2b2lkIHtcbiAgICAgICAgQ29uZHVpdFpvbmUuc3ViamVjdHMucHVzaChuZXcgQ29uZHVpdFN1YmplY3QoY29uZHVpdCwgdGhpcywgdGhpcy5fem9uZUlkKSk7XG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3kgYSBjb25kdWl0ICovXG4gICAgdW5yZWdpc3RlckNvbmR1aXQoY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLmdldENvbmR1aXRTdWJqZWN0KGNvbmR1aXQuc3ViamVjdCk7XG5cbiAgICAgICAgaWYgKHN1YmplY3QpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc3ViamVjdCBmcm9tIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGNvbmR1aXQgc3ViamVjdHNcbiAgICAgICAgICAgIENvbmR1aXRab25lLnN1YmplY3RzID0gQ29uZHVpdFpvbmUuc3ViamVjdHMuZmlsdGVyKF9zdWJqZWN0ID0+IF9zdWJqZWN0ICE9PSBzdWJqZWN0KTtcblxuICAgICAgICAgICAgLy8gcGVyZm9ybSBhbGwgdW5zdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBzdWJqZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQcm92aWRlIHRoZSB6b25lIHdpdGggYW4gSUQgKi9cbiAgICBzZXRab25lSWQoem9uZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZUlkID0gem9uZUlkO1xuICAgIH1cblxuICAgIC8qKiBFbWl0IGEgdmFsdWUgdG8gYWxsIHpvbmVzIGZvciBjaGVja2luZyAqL1xuICAgIGVtaXQoZXZlbnQ6IENvbmR1aXRFdmVudCk6IHZvaWQge1xuICAgICAgICBDb25kdWl0Wm9uZS5ldmVudHMubmV4dChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqIFJldHJpZXZlIGEgY29uZHVpdCBzdWJzamVjdCBvYmplY3QgZnJvbSB0aGUgcnhqcyBzdWJqZWN0ICovXG4gICAgZ2V0Q29uZHVpdFN1YmplY3Qoc3ViamVjdDogU3ViamVjdDxhbnk+KTogQ29uZHVpdFN1YmplY3QgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIENvbmR1aXRab25lLnN1YmplY3RzLmZpbmQoX3N1YmplY3QgPT4gX3N1YmplY3QuY29uZHVpdC5zdWJqZWN0ID09PSBzdWJqZWN0KTtcbiAgICB9XG5cbiAgICAvKiogR2V0IGFsbCBzdWJqZWN0cyBmcm9tIGFsbCB6b25lcyAqL1xuICAgIGdldFN1YmplY3RzKCk6IENvbmR1aXRTdWJqZWN0W10ge1xuICAgICAgICByZXR1cm4gQ29uZHVpdFpvbmUuc3ViamVjdHM7XG4gICAgfVxuXG4gICAgLyoqIEFsdGVyIHRoZSBwcm9wZXJ0aWVzIG9mIGEgY29uZHVpdCBkeW5hbWljYWxseSAqL1xuICAgIHNldENvbmR1aXRQcm9wZXJ0aWVzKHN1YmplY3Q6IFN1YmplY3Q8YW55PiwgcHJvcGVydGllczogUGFydGlhbDxDb25kdWl0UHJvcGVydGllcz4pOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIHRoZSBjb25kdWl0IHdpdGggdGhlIG1hdGNoaW5nIHN1YmplY3RcbiAgICAgICAgY29uc3QgY29uZHVpdFN1YmplY3QgPSB0aGlzLmdldFN1YmplY3RzKCkuZmluZChfY29uZHVpdCA9PiBfY29uZHVpdC5jb25kdWl0LnN1YmplY3QgPT09IHN1YmplY3QpO1xuXG4gICAgICAgIC8vIGlmIGEgbWF0Y2ggd2FzIGZvdW5kIHVwZGF0ZSB0aGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoY29uZHVpdFN1YmplY3QpIHtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGVhY2ggc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbmR1aXRTdWJqZWN0LmNvbmR1aXRbcHJvcF0gPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29uZHVpdCBhdCBydW50aW1lICovXG4gICAgY3JlYXRlQ29uZHVpdChzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IENvbmR1aXRQcm9wZXJ0aWVzKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGNvbmR1aXQgd2l0aCB0aGUgem9uZVxuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29uZHVpdCh7IC4uLnByb3BlcnRpZXMsIHN1YmplY3QgfSk7XG4gICAgfVxuXG4gICAgLyoqIFJlZ2lzdGVyIGFsbCBjb25kdWl0cyBpbiBhIGNvbXBvbmVudCAqL1xuICAgIHJlZ2lzdGVyQ29uZHVpdHMoY29tcG9uZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tcG9uZW50Ll9jb25kdWl0cykpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fY29uZHVpdHMuZm9yRWFjaCgoY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhKSA9PiB0aGlzLnJlZ2lzdGVyQ29uZHVpdCh7IC4uLmNvbmR1aXQsIHN1YmplY3Q6IGNvbXBvbmVudFtjb25kdWl0LnByb3BlcnR5S2V5XSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmVnaXN0ZXIgYWxsIGNvbmR1aXRzIGluIGEgY29tcG9uZW50ICovXG4gICAgdW5yZWdpc3RlckNvbmR1aXRzKGNvbXBvbmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudC5fY29uZHVpdHMpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuX2NvbmR1aXRzLmZvckVhY2goKGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSkgPT4gdGhpcy51bnJlZ2lzdGVyQ29uZHVpdChjb25kdWl0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIHRoZSBnbG9iYWwgZXZlbnQgc3RyZWFtICovXG4gICAgZ2V0RXZlbnRzKCk6IFN1YmplY3Q8Q29uZHVpdEV2ZW50PiB7XG4gICAgICAgIHJldHVybiBDb25kdWl0Wm9uZS5ldmVudHM7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgT25EZXN0cm95LCBPbkluaXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IGludm9rZVN1cGVyRnVuY3Rpb24gfSBmcm9tICcuL2NvbmR1aXQtdXRpbHMnO1xuaW1wb3J0IHsgQ29uZHVpdFpvbmUgfSBmcm9tICcuL2NvbmR1aXQtem9uZS5zZXJ2aWNlJztcbmltcG9ydCB7IENvbmR1aXRQcm9wZXJ0aWVzIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcyc7XG5cbmV4cG9ydCBjbGFzcyBDb25kdWl0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIF96b25lOiBDb25kdWl0Wm9uZSkge1xuICAgICAgICAvLyB3ZSB3YW50IHRvIGVuc3VyZSB0aGVzZSBmdW5jdGlvbnMgZ2V0IGNhbGxlZCBldmVuIGlmIGEgY2xhc3Mgb3ZlcnJpZGVzIHRoZW1cbiAgICAgICAgaW52b2tlU3VwZXJGdW5jdGlvbih0aGlzLCAnbmdPbkluaXQnKTtcbiAgICAgICAgaW52b2tlU3VwZXJGdW5jdGlvbih0aGlzLCAnbmdPbkRlc3Ryb3knKTtcbiAgICB9XG5cbiAgICAvKiogV2UgbmVlZCB0byByZWdpc3RlciB0aGUgY29uZHVpdHMgd2l0aCB0aGUgem9uZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGlzZWQgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGNvbmR1aXQgaW4gdGhlIHpvbmUgYW5kIGVuc3VyZSBpdCBnZXRzIHRoZSBjb3JyZWN0IGluc3RhbmNlIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgdGhpcy5fem9uZS5yZWdpc3RlckNvbmR1aXRzKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKiBXZSBuZWVkIHRvIHVucmVnaXN0ZXIgdGhlIGNvbmR1aXRzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS51bnJlZ2lzdGVyQ29uZHVpdHModGhpcyk7XG4gICAgfVxuXG4gICAgLyoqIEFsdGVyIHRoZSBwcm9wZXJ0aWVzIG9mIGEgY29uZHVpdCBkeW5hbWljYWxseSAqL1xuICAgIHNldENvbmR1aXRQcm9wZXJ0aWVzKHN1YmplY3Q6IFN1YmplY3Q8YW55PiwgcHJvcGVydGllczogUGFydGlhbDxDb25kdWl0UHJvcGVydGllcz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS5zZXRDb25kdWl0UHJvcGVydGllcyhzdWJqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb25kdWl0IGF0IHJ1bnRpbWUgKi9cbiAgICBjcmVhdGVDb25kdWl0KHN1YmplY3Q6IFN1YmplY3Q8YW55PiwgcHJvcGVydGllczogQ29uZHVpdFByb3BlcnRpZXMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS5jcmVhdGVDb25kdWl0KHN1YmplY3QsIHByb3BlcnRpZXMpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25kdWl0Q29tcG9uZW50IH0gZnJvbSAnLi9jb25kdWl0LmNvbXBvbmVudCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb25kdWl0Wm9uZUNvbXBvbmVudCBleHRlbmRzIENvbmR1aXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIGFic3RyYWN0IHpvbmVJZDogc3RyaW5nO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUuc2V0Wm9uZUlkKHRoaXMuem9uZUlkKTtcbiAgICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIENvbmR1aXRQcm9wZXJ0aWVzIHtcbiAgICBpZDogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGFjY2VwdHNJbnB1dD86IGJvb2xlYW4gfCBzdHJpbmdbXTtcbiAgICBwcm9kdWNlc091dHB1dD86IGJvb2xlYW47XG4gICAgY2hhbmdlRGV0ZWN0aW9uPzogKHg6IGFueSwgeTogYW55KSA9PiBib29sZWFuO1xuICAgIG1hcD86IGFueTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRDb25kdWl0UHJvcHM6IFBhcnRpYWw8Q29uZHVpdFByb3BlcnRpZXM+ID0ge1xuICAgIGFjY2VwdHNJbnB1dDogdHJ1ZSxcbiAgICBwcm9kdWNlc091dHB1dDogdHJ1ZSxcbn07XG4iLCJpbXBvcnQgeyBDb25kdWl0TWV0YWRhdGEgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1tZXRhZGF0YSc7XG5pbXBvcnQgeyBDb25kdWl0UHJvcGVydGllcywgZGVmYXVsdENvbmR1aXRQcm9wcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LXByb3BlcnRpZXMnO1xuXG4vKiogRXhwb3NlIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbmR1aXRzIHdpbGwgYmUgc3RvcmVkIGluICovXG5leHBvcnQgY29uc3QgQ09ORFVJVFMgPSAnX2NvbmR1aXRzJztcblxuLyoqIENyZWF0ZSB0aGUgY29uZHVpdCBwcm9wZXJ0eSBkZWNvcmF0b3IgKi9cbmV4cG9ydCBmdW5jdGlvbiBDb25kdWl0KHByb3BlcnRpZXM6IENvbmR1aXRQcm9wZXJ0aWVzIHwgRnVuY3Rpb24pOiBQcm9wZXJ0eURlY29yYXRvciB7XG4gICAgcmV0dXJuICh0YXJnZXQ6IE9iamVjdCwgcHJvcGVydHlLZXk6IHN0cmluZykgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMuY2FsbChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZG9lcyBub3QgYWxyZWFkeSBoYXZlIGEgY29uZHVpdCBsaXN0IHRoZW4gY3JlYXRlIG9uZVxuICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShDT05EVUlUUykpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIENPTkRVSVRTLCB7IHZhbHVlOiBbXSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgY29uZHVpdCB0byB0aGUgbGlzdCBlbnN1cmluZyBhbGwgcmVxdWlyZWQgcHJvcGVydGllcyBhcmUgcHJvdmlkZWRcbiAgICAgICAgdGFyZ2V0W0NPTkRVSVRTXS5wdXNoKHsgLi4uZGVmYXVsdENvbmR1aXRQcm9wcywgLi4ucHJvcGVydGllcywgdGFyZ2V0LCBwcm9wZXJ0eUtleSB9IGFzIENvbmR1aXRNZXRhZGF0YSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZGVsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRGFzaGJvYXJkT3B0aW9ucyB9IGZyb20gJy4vZGFzaGJvYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgfSBmcm9tICcuL3dpZGdldC9kYXNoYm9hcmQtd2lkZ2V0LmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX3dpZGdldE9yaWdpbjogeyBjb2x1bW4/OiBudW1iZXIsIHJvdz86IG51bWJlciwgY29sdW1uU3Bhbj86IG51bWJlciwgcm93U3Bhbj86IG51bWJlciB9O1xuICAgIHByaXZhdGUgX2FjdGlvbldpZGdldDogRGFzaGJvYXJkQWN0aW9uO1xuICAgIHByaXZhdGUgX3Jvd0hlaWdodDogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIF9jYWNoZTogRGFzaGJvYXJkQ2FjaGVbXTtcbiAgICBwcml2YXRlIF9tb3VzZUV2ZW50OiBNb3VzZUV2ZW50O1xuXG4gICAgd2lkZ2V0cyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZFdpZGdldENvbXBvbmVudFtdPihbXSk7XG4gICAgb3B0aW9ucyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZE9wdGlvbnM+KGRlZmF1bHRPcHRpb25zKTtcbiAgICBkaW1lbnNpb25zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGFzaGJvYXJkRGltZW5zaW9ucz4oe30pO1xuICAgIGhlaWdodCQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMuZGltZW5zaW9ucyQucGlwZShkZWxheSgwKSwgbWFwKChkaW1lbnNpb25zOiBEYXNoYm9hcmREaW1lbnNpb25zKSA9PiBkaW1lbnNpb25zLmhlaWdodCksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgIHBsYWNlaG9sZGVyJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGFzaGJvYXJkUGxhY2Vob2xkZXI+KHsgdmlzaWJsZTogZmFsc2UsIHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgbGF5b3V0JCA9IG5ldyBTdWJqZWN0PERhc2hib2FyZExheW91dERhdGFbXT4oKTtcbiAgICBzdGFja2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHdpZGdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHN0YWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrZWQkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGNvbHVtbldpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zLndpZHRoIC8gdGhpcy5vcHRpb25zLmNvbHVtbnM7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0JC5zdWJzY3JpYmUodGhpcy5zZXRMYXlvdXREYXRhLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN0YWNrZWQkLnBpcGUoZmlsdGVyKHN0YWNrZWQgPT4gc3RhY2tlZCA9PT0gdHJ1ZSkpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVdoZW5TdGFja2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLndpZGdldHMkLnBpcGUoZGVsYXkoMCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlbmRlckRhc2hib2FyZCgpKTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zJC5waXBlKGRlbGF5KDApKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZW5kZXJEYXNoYm9hcmQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgd2lkZ2V0IHRvIHRoZSBkYXNoYm9hcmRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgY29tcG9uZW50IHRvIGFkZCB0byB0aGUgZGFzaGJvYXJkXG4gICAgICovXG4gICAgYWRkV2lkZ2V0KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMud2lkZ2V0cyQubmV4dChbLi4udGhpcy53aWRnZXRzJC5nZXRWYWx1ZSgpLCB3aWRnZXRdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB3aWRnZXQgZnJvbSB0aGUgZGFzaGJvYXJkXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZVdpZGdldCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLndpZGdldHMkLm5leHQodGhpcy53aWRnZXRzJC5nZXRWYWx1ZSgpLmZpbHRlcihfd2lkZ2V0ID0+IF93aWRnZXQgIT09IHdpZGdldCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHRoYXQgdGhlIGRhc2hib2FyZCBlbGVtZW50IGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBkYXNoYm9hcmQgZWxlbWVudCBpbiBweFxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgZGFzaGJvYXJkIGVsZW1lbnQgaW4gcHhcbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zKHdpZHRoOiBudW1iZXIgPSB0aGlzLmRpbWVuc2lvbnMud2lkdGgsIGhlaWdodDogbnVtYmVyID0gdGhpcy5kaW1lbnNpb25zLmhlaWdodCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaW1lbnNpb25zLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucyQubmV4dCh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgcmVxdWlyZWQgbGF5b3V0IGRhdGEuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBleHBvcnRpbmcvc2F2aW5nIGEgbGF5b3V0XG4gICAgICovXG4gICAgZ2V0TGF5b3V0RGF0YSgpOiBEYXNoYm9hcmRMYXlvdXREYXRhW10ge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLm1hcCh3aWRnZXQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IHdpZGdldC5pZCwgY29sOiB3aWRnZXQuZ2V0Q29sdW1uKCksIHJvdzogd2lkZ2V0LmdldFJvdygpLCBjb2xTcGFuOiB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCByb3dTcGFuOiB3aWRnZXQuZ2V0Um93U3BhbigpIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHdpZGdldHMgcHJvZ3JhbWF0aWNhbGx5XG4gICAgICovXG4gICAgc2V0TGF5b3V0RGF0YSh3aWRnZXRzOiBEYXNoYm9hcmRMYXlvdXREYXRhW10pOiB2b2lkIHtcblxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFjaCB3aWRnZXQgZGF0YSBhbmQgZmluZCBhIG1hdGNoXG4gICAgICAgIHdpZGdldHMuZm9yRWFjaCh3aWRnZXQgPT4ge1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBtYXRjaGluZyB3aWRnZXRcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMud2lkZ2V0cy5maW5kKF93aWRnZXQgPT4gX3dpZGdldC5pZCA9PT0gd2lkZ2V0LmlkKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRDb2x1bW4od2lkZ2V0LmNvbCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFJvdyh3aWRnZXQucm93KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0Q29sdW1uU3Bhbih3aWRnZXQuY29sU3Bhbik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFJvd1NwYW4od2lkZ2V0LnJvd1NwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9ucyBhbmQgc2l6ZXMgb2YgdGhlIHdpZGdldHNcbiAgICAgKi9cbiAgICByZW5kZXJEYXNoYm9hcmQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkYXNoYm9hcmRcbiAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gdGhpcy5vcHRpb25zLnJvd0hlaWdodCB8fCB0aGlzLmNvbHVtbldpZHRoO1xuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgY29sdW1uIHdpZHRoIGlzIG5vdCBiZWxvdyB0aGUgbWluIHdpZHRoc1xuICAgICAgICB0aGlzLnN0YWNrZWQkLm5leHQodGhpcy5jb2x1bW5XaWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSByb3cgaGVpZ2h0IGlzIG5vdCBiZWxvdyB0aGUgbWluIHdpZHRoc1xuICAgICAgICBpZiAodGhpcy5fcm93SGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWluV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldERhc2hib2FyZExheW91dCgpO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHdpZGdldCBhbmQgc2V0IHRoZSBzaXplIC0gZXhjZXB0IHRoZSBvbmUgYmVpbmcgcmVzaXplZFxuICAgICAgICB0aGlzLndpZGdldHMuZmlsdGVyKHdpZGdldCA9PiAhdGhpcy5fYWN0aW9uV2lkZ2V0IHx8IHdpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldClcbiAgICAgICAgICAgIC5mb3JFYWNoKHdpZGdldCA9PiB3aWRnZXQucmVuZGVyKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGVyZSB3aWRnZXRzIHNob3VsZCBiZSBwb3NpdGlvbmVkIGJhc2VkIG9uIHRoZWlyIHBvc2l0aW9ucywgd2lkdGggYW5kIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXJcbiAgICAgKi9cbiAgICBzZXREYXNoYm9hcmRMYXlvdXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCBhbnkgd2lkZ2V0cyB0aGF0IGRvIG5vdCBjdXJyZW50bHkgaGF2ZSBhIHBvc2l0aW9uIHNldFxuICAgICAgICB0aGlzLndpZGdldHMuZmlsdGVyKHdpZGdldCA9PiB3aWRnZXQuZ2V0Q29sdW1uKCkgPT09IHVuZGVmaW5lZCB8fCB3aWRnZXQuZ2V0Um93KCkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5mb3JFYWNoKHdpZGdldCA9PiB0aGlzLnNldFdpZGdldFBvc2l0aW9uKHdpZGdldCkpO1xuXG4gICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkSGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlV2hlblN0YWNrZWQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggd2lkZ2V0IHNldCBpdCdzIHN0YWNrZWQgc3RhdGUgYW5kXG4gICAgICAgIHRoaXMuZ2V0V2lkZ2V0c0J5T3JkZXIoKS5mb3JFYWNoKCh3aWRnZXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbigwKTtcbiAgICAgICAgICAgIHdpZGdldC5zZXRSb3coaWR4KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBnZXRXaWRnZXRzQnlPcmRlcigpOiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMuc29ydCgodzEsIHcyKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHcxUG9zaXRpb24gPSB3MS5nZXRDb2x1bW4oKSAqIHcxLmdldFJvdygpO1xuICAgICAgICAgICAgY29uc3QgdzJQb3NpdGlvbiA9IHcyLmdldENvbHVtbigpICogdzIuZ2V0Um93KCk7XG5cbiAgICAgICAgICAgIGlmICh3MVBvc2l0aW9uIDwgdzJQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHcxUG9zaXRpb24gPiB3MlBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgcG9zaXRpb24gdGhhdCBhIHdpZGdldCBjYW4gZml0IGluIHRoZSBkYXNoYm9hcmRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gdHJ5IGFuZCBwb3NpdGlvblxuICAgICAqL1xuICAgIHNldFdpZGdldFBvc2l0aW9uKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCBhIHBvc2l0aW9uIGZvciB0aGUgd2lkZ2V0XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG5cbiAgICAgICAgLy8gcmVwZWF0IHVudGlsIGEgc3BhY2UgaXMgZm91bmRcbiAgICAgICAgd2hpbGUgKCFzdWNjZXNzKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBhIHBvc2l0aW9uIHRvIHRyeVxuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gcG9zaXRpb24gJSB0aGlzLm9wdGlvbnMuY29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IocG9zaXRpb24gLyB0aGlzLm9wdGlvbnMuY29sdW1ucyk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQb3NpdGlvbkF2YWlsYWJsZShjb2x1bW4sIHJvdywgd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgd2lkZ2V0LmdldFJvd1NwYW4oKSkpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgd2lkZ2V0LnNldFJvdyhyb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbHVtbiA9PT0gMCAmJiB3aWRnZXQuY29sU3BhbiA+IHRoaXMub3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXNoYm9hcmQgd2lkZ2V0cyBoYXZlIGEgY29sU3BhbiBncmVhdGVyIHRoYW4gdGhlIG1heCBudW1iZXIgb2YgZGFzaGJvYXJkIGNvbHVtbnMhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHBvc2l0aW9uIGluIHRoZSBkYXNoYm9hcmQgaXMgdmFjYW50IG9yIG5vdFxuICAgICAqL1xuICAgIGdldFBvc2l0aW9uQXZhaWxhYmxlKGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlciwgY29sdW1uU3BhbjogbnVtYmVyLCByb3dTcGFuOiBudW1iZXIsIGlnbm9yZVdpZGdldD86IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgZ3JpZCBzcGFjZXMgdGhhdCBhcmUgcG9wdWxhdGVkXG4gICAgICAgIGNvbnN0IHNwYWNlcyA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgYmxvY2sgd291bGQgc3RpbGwgYmUgaW4gYm91bmRzXG4gICAgICAgIGlmIChjb2x1bW4gKyBjb2x1bW5TcGFuID4gdGhpcy5vcHRpb25zLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGVhY2ggcmVxdWlyZWQgcG9zaXRpb25cbiAgICAgICAgZm9yIChsZXQgeCA9IGNvbHVtbjsgeCA8IGNvbHVtbiArIGNvbHVtblNwYW47IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHJvdzsgeSA8IHJvdyArIHJvd1NwYW47IHkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZXMuZmluZChibG9jayA9PiBibG9jay5jb2x1bW4gPT09IHggJiYgYmxvY2sucm93ID09PSB5ICYmIGJsb2NrLndpZGdldCAhPT0gaWdub3JlV2lkZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZ2V0T2NjdXBpZWRTcGFjZXMoKTogRGFzaGJvYXJkU3BhY2VbXSB7XG5cbiAgICAgICAgLy8gZmluZCBhbGwgc3BhY2VzIHRoYXQgYXJlIGN1cnJlbnRseSBvY2N1cGllZFxuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gd2lkZ2V0LmdldENvbHVtbigpICE9PSB1bmRlZmluZWQgJiYgd2lkZ2V0LmdldFJvdygpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAucmVkdWNlKCh2YWx1ZSwgd2lkZ2V0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2hCbG9jayh3aWRnZXQsIChjb2x1bW4sIHJvdykgPT4gdmFsdWUucHVzaCh7IHdpZGdldDogd2lkZ2V0LCBjb2x1bW46IGNvbHVtbiwgcm93OiByb3cgfSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJlZ2luIHJlc2l6aW5nIGEgd2lkZ2V0XG4gICAgICogQHBhcmFtIGFjdGlvbiBUaGUgdGhlIHdpZGdldCB0byByZXNpemVcbiAgICAgKi9cbiAgICBvblJlc2l6ZVN0YXJ0KGFjdGlvbjogRGFzaGJvYXJkQWN0aW9uKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG1vdXNlIGV2ZW50XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBhY3Rpb24uZXZlbnQ7XG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldCA9IGFjdGlvbjtcblxuICAgICAgICAvLyBicmluZyB0aGUgd2lkZ2V0IHRvIHRoZSBmb250XG4gICAgICAgIHRoaXMuYnJpbmdUb0Zyb250KGFjdGlvbi53aWRnZXQpO1xuICAgIH1cblxuICAgIG9uUmVzaXplRHJhZyhhY3Rpb246IERhc2hib2FyZEFjdGlvbik6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IG1vdXNlUG9zWCA9IHRoaXMuX21vdXNlRXZlbnQucGFnZVggLSBwYWdlWE9mZnNldDtcbiAgICAgICAgY29uc3QgbW91c2VQb3NZID0gdGhpcy5fbW91c2VFdmVudC5wYWdlWSAtIHBhZ2VZT2Zmc2V0O1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBtb3ZlbWVudCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKGFjdGlvbi5ldmVudC54ID09PSBtb3VzZVBvc1ggJiYgYWN0aW9uLmV2ZW50LnkgPT09IG1vdXNlUG9zWSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdG9yZWQgbW91c2UgZXZlbnRcbiAgICAgICAgdGhpcy5fbW91c2VFdmVudCA9IGFjdGlvbi5ldmVudDtcblxuICAgICAgICAvLyBnZXQgaGFuZGxlIGZvciBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgeyBoYW5kbGUgfSA9IGFjdGlvbjtcblxuICAgICAgICAvLyBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgaGFuZGxlXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGNlbnRlciBvZiB0aGUgaGFuZGxlXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBib3VuZHMubGVmdCArIChib3VuZHMud2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IGJvdW5kcy50b3AgKyAoYm91bmRzLmhlaWdodCAvIDIpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuICAgICAgICBjb25zdCBtb3VzZVggPSBtb3VzZVBvc1ggLSBjZW50ZXJYO1xuICAgICAgICBjb25zdCBtb3VzZVkgPSBtb3VzZVBvc1kgLSBjZW50ZXJZO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBuZXcgcHJvcG9zZWQgZGltZW5zaW9ucyBmb3IgdGhlIHdpZGdldFxuICAgICAgICBjb25zdCBkaW1lbnNpb25zOiBEYXNoYm9hcmRXaWRnZXREaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgeDogYWN0aW9uLndpZGdldC54LFxuICAgICAgICAgICAgeTogYWN0aW9uLndpZGdldC55LFxuICAgICAgICAgICAgd2lkdGg6IGFjdGlvbi53aWRnZXQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGFjdGlvbi53aWRnZXQuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdXBkYXRlIHdpZGdldCBiYXNlZCBvbiB0aGUgaGFuZGxlIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgc3dpdGNoIChhY3Rpb24uZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCAtPSBtb3VzZVg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbldpZHRoIC0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy54IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tOlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uVG9wOlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgLT0gbW91c2VZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQgcmVzaXppbmcgb24gbXVsdGlwbGUgYXhpcyBzaW11bHRhbmVvdXNseVxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdDpcblxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCAtPSBtb3VzZVg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbldpZHRoIC0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy54IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0IC09IG1vdXNlWTtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy55IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0IC09IG1vdXNlWTtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy55IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggLT0gbW91c2VYO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5XaWR0aCAtIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21SaWdodDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSBhY3Rpb24ud2lkZ2V0LnggKyBhY3Rpb24ud2lkZ2V0LndpZHRoO1xuICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gYWN0aW9uLndpZGdldC55ICsgYWN0aW9uLndpZGdldC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gZW5zdXJlIHZhbHVlcyBhcmUgd2l0aGluIHRoZSBkYXNoYm9hcmQgYm91bmRzXG4gICAgICAgIGlmIChkaW1lbnNpb25zLnggPCAwKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnggPSAwO1xuICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaW1lbnNpb25zLnkgPCAwKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnkgPSAwO1xuICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgPSBjdXJyZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChkaW1lbnNpb25zLnggKyBkaW1lbnNpb25zLndpZHRoKSA+IHRoaXMuZGltZW5zaW9ucy53aWR0aCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCA9IHRoaXMuZGltZW5zaW9ucy53aWR0aCAtIGRpbWVuc2lvbnMueDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwcm9wb3NlZCB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gYWxsb3dlZCB0aGVuIHJlc2V0IHdpZHRoIHRvIG1pbmltdW0gYW5kIGlnbm9yZSB4IGNoYW5nZXNcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMueCA9IGFjdGlvbi53aWRnZXQueDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggPSB0aGlzLm9wdGlvbnMubWluV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcHJvcG9zZWQgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBhbGxvd2VkIHRoZW4gcmVzZXQgaGVpZ2h0IHRvIG1pbmltdW0gYW5kIGlnbm9yZSB5IGNoYW5nZXNcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy55ID0gYWN0aW9uLndpZGdldC55O1xuICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB3aWRnZXQgYWN0dWFsIHZhbHVlc1xuICAgICAgICBhY3Rpb24ud2lkZ2V0LnNldEJvdW5kcyhkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwbGFjZWhvbGRlciBwb3NpdGlvbiBhbmQgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlckJvdW5kcyh0cnVlLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHNob3cgdGhlIHdpZGdldCBwb3NpdGlvbnMgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb25zIGFuZCBzaXplcyB3ZXJlIHRvIHBlcnNpc3RcbiAgICAgICAgdGhpcy51cGRhdGVXaWRnZXRQb3NpdGlvbnMoYWN0aW9uLndpZGdldCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVFbmQoKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNvbW1pdCByZXNpemUgY2hhbmdlc1xuICAgICAgICB0aGlzLmNvbW1pdFdpZGdldENoYW5nZXMoKTtcblxuICAgICAgICAvLyBoaWRlIHBsYWNlaG9sZGVyXG4gICAgICAgIHBsYWNlaG9sZGVyLnZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIkLm5leHQocGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBudWxsO1xuXG4gICAgICAgIC8vIGVuc3VyZSBhbnkgdmFjYW50IHVwcGVyIHNwYWNlcyBhcmUgZmlsbGVkIHdoZXJlIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuc2hpZnRXaWRnZXRzVXAoKTtcblxuICAgICAgICAvLyB1cGRhdGUgZGFzaGJvYXJkIGhlaWdodFxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuXG4gICAgICAgIC8vIGVtaXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxheW91dFxuICAgICAgICB0aGlzLmxheW91dCQubmV4dCh0aGlzLmdldExheW91dERhdGEoKSk7XG4gICAgfVxuXG4gICAgb25EcmFnU3RhcnQoYWN0aW9uOiBEYXNoYm9hcmRBY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZVN0YXJ0KGFjdGlvbik7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHN0YXJ0aW5nIHBsYWNlaG9sZGVyIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuc2V0V2lkZ2V0T3JpZ2luKCk7XG5cbiAgICAgICAgdGhpcy5jYWNoZVdpZGdldHMoKTtcbiAgICB9XG5cbiAgICBvbkRyYWdFbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25SZXNpemVFbmQoKTtcblxuICAgICAgICB0aGlzLl93aWRnZXRPcmlnaW4gPSB7fTtcbiAgICB9XG5cbiAgICBvbkRyYWcoYWN0aW9uOiBEYXNoYm9hcmRBY3Rpb24pOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgbm8gbW92ZW1lbnQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmIChhY3Rpb24uZXZlbnQucGFnZVggPT09IHRoaXMuX21vdXNlRXZlbnQucGFnZVggJiYgYWN0aW9uLmV2ZW50LnBhZ2VZID09PSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgICAgICAgY29uc3QgbW91c2VYID0gYWN0aW9uLmV2ZW50LnBhZ2VYIC0gdGhpcy5fbW91c2VFdmVudC5wYWdlWDtcbiAgICAgICAgY29uc3QgbW91c2VZID0gYWN0aW9uLmV2ZW50LnBhZ2VZIC0gdGhpcy5fbW91c2VFdmVudC5wYWdlWTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbGF0ZXN0IGV2ZW50XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBhY3Rpb24uZXZlbnQ7XG5cbiAgICAgICAgY29uc3QgZGltZW5zaW9uczogRGFzaGJvYXJkV2lkZ2V0RGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHg6IGFjdGlvbi53aWRnZXQueCArIG1vdXNlWCxcbiAgICAgICAgICAgIHk6IGFjdGlvbi53aWRnZXQueSArIG1vdXNlWSxcbiAgICAgICAgICAgIHdpZHRoOiBhY3Rpb24ud2lkZ2V0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBhY3Rpb24ud2lkZ2V0LmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzdG9yZVdpZGdldHModHJ1ZSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHdpZGdldCBwb3NpdGlvblxuICAgICAgICBhY3Rpb24ud2lkZ2V0LnNldEJvdW5kcyhkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwbGFjZWhvbGRlciBwb3NpdGlvbiBhbmQgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlckJvdW5kcyh0cnVlLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHNob3cgdGhlIHdpZGdldCBwb3NpdGlvbnMgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb25zIGFuZCBzaXplcyB3ZXJlIHRvIHBlcnNpc3RcbiAgICAgICAgdGhpcy5zaGlmdFdpZGdldHMoKTtcblxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuICAgIH1cblxuICAgIGdldFJvd0hlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93SGVpZ2h0O1xuICAgIH1cblxuICAgIGNhY2hlV2lkZ2V0cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLndpZGdldHMubWFwKHdpZGdldCA9PiAoeyBpZDogd2lkZ2V0LmlkLCBjb2x1bW46IHdpZGdldC5nZXRDb2x1bW4oKSwgcm93OiB3aWRnZXQuZ2V0Um93KCkgfSkpO1xuICAgIH1cblxuICAgIHJlc3RvcmVXaWRnZXRzKGlnbm9yZUFjdGlvbldpZGdldDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NhY2hlLmZpbHRlcih3aWRnZXQgPT4gIWlnbm9yZUFjdGlvbldpZGdldCB8fCB3aWRnZXQuaWQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuaWQpLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLndpZGdldHMuZmluZCh3Z3QgPT4gd2d0LmlkID09PSB3aWRnZXQuaWQpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBtYXRjaC5zZXRDb2x1bW4od2lkZ2V0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgbWF0Y2guc2V0Um93KHdpZGdldC5yb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRyYWdnaW5nIGFueSB3aWRnZXRzIHRoYXQgbmVlZCB0byBiZSBtb3ZlZCBzaG91bGQgYmUgbW92ZWQgdG8gYW4gYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzaGlmdFdpZGdldHMoKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IHdpZGdldHNUb01vdmU6IERhc2hib2FyZFdpZGdldENvbXBvbmVudFtdID0gW107XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgd2lkZ2V0cyB1bmRlciB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgZm9yIChsZXQgcm93ID0gcGxhY2Vob2xkZXIucm93OyByb3cgPCBwbGFjZWhvbGRlci5yb3cgKyBwbGFjZWhvbGRlci5yb3dTcGFuOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uID0gcGxhY2Vob2xkZXIuY29sdW1uOyBjb2x1bW4gPCBwbGFjZWhvbGRlci5jb2x1bW4gKyBwbGFjZWhvbGRlci5jb2x1bW5TcGFuOyBjb2x1bW4rKykge1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIGFueSB3aWRnZXRzIHRoYXQgbmVlZCBtb3ZlZFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNwYWNlID0+IHNwYWNlLmNvbHVtbiA9PT0gY29sdW1uICYmIHNwYWNlLnJvdyA9PT0gcm93ICYmIHNwYWNlLndpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldClcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goc3BhY2UgPT4gd2lkZ2V0c1RvTW92ZS5wdXNoKHNwYWNlLndpZGdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFueSBkdXBsaWNhdGVzXG4gICAgICAgIHdpZGdldHNUb01vdmUgPSB3aWRnZXRzVG9Nb3ZlLmZpbHRlcigod2lkZ2V0LCBpZHgsIGFycmF5KSA9PiBhcnJheS5pbmRleE9mKHdpZGdldCkgPT09IGlkeCk7XG5cbiAgICAgICAgLy8gaWYgbm8gd2lkZ2V0cyBuZWVkIG1vdmVkIHRoZW4gd2UgY2FuIHN0b3AgaGVyZVxuICAgICAgICBpZiAod2lkZ2V0c1RvTW92ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGR1cGxpY2F0ZSB3ZSBjYW4gdXNlIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggaGF2ZSBiZWVuIG1vdmVkXG4gICAgICAgIGNvbnN0IHVubW92ZWRXaWRnZXRzID0gd2lkZ2V0c1RvTW92ZS5zbGljZSgpO1xuXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gbW92ZSBhbnkgd2lkZ2V0cyB0byB0aGUgcHJldmlvdXMgd2lkZ2V0IHBvc2l0aW9uXG4gICAgICAgIHdpZGdldHNUb01vdmUuZm9yRWFjaCh3aWRnZXQgPT4ge1xuXG4gICAgICAgICAgICAvLyBnZXQgYSBncmlkIG9mZiBhbGwgb2NjdXBpZWQgc3BhY2VzIC0gdGFraW5nIGludG8gYWNjb3VudCB0aGUgcGxhY2Vob2xkZXIgYW5kIGlnbm9yaW5nIHdpZGdldHMgdGhhdCBuZWVkIG1vdmVkXG4gICAgICAgICAgICBjb25zdCBncmlkID0gdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpLmZpbHRlcihzcGFjZSA9PiAhdW5tb3ZlZFdpZGdldHMuZmluZCh3Z3QgPT4gd2d0ID09PSBzcGFjZS53aWRnZXQpKTtcblxuICAgICAgICAgICAgLy8gaXRlcmF0ZSBlYWNoIGZyZWUgYmxvY2tcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IHRoaXMuX3dpZGdldE9yaWdpbi5yb3c7IHJvdyA8IHRoaXMuX3dpZGdldE9yaWdpbi5yb3cgKyB0aGlzLl93aWRnZXRPcmlnaW4ucm93U3Bhbjsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSB0aGlzLl93aWRnZXRPcmlnaW4uY29sdW1uOyBjb2x1bW4gPCB0aGlzLl93aWRnZXRPcmlnaW4uY29sdW1uICsgdGhpcy5fd2lkZ2V0T3JpZ2luLmNvbHVtblNwYW47IGNvbHVtbisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSBibG9jayBjYW4gZml0IGluIHRoaXMgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcXVpcmVkU3BhY2VzID0gdGhpcy5nZXRSZXF1aXJlZFNwYWNlc0Zyb21Qb2ludCh3aWRnZXQsIGNvbHVtbiwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3aWRnZXQgd291bGQgZml0IGluIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdmFpbGFibGUgPSByZXF1aXJlZFNwYWNlcy5ldmVyeShzcGFjZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWdyaWQuZmluZChncmlkU3BhY2UgPT4gZ3JpZFNwYWNlLmNvbHVtbiA9PT0gc3BhY2UuY29sdW1uICYmIGdyaWRTcGFjZS5yb3cgPT09IHNwYWNlLnJvdykgJiYgc3BhY2UuY29sdW1uIDwgdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Um93KHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1vdmVkV2lkZ2V0cy5zcGxpY2UodW5tb3ZlZFdpZGdldHMuZmluZEluZGV4KHdndCA9PiB3Z3QgPT09IHdpZGdldCksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBnZXQgdG8gaGVyZSB0aGVuIHdlIGNhbid0IHNpbXBseSBzd2FwIHRoZSBwb3NpdGlvbnMgLSBuZXh0IHRyeSBtb3ZpbmcgcmlnaHRcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbldpZGdldE1vdmVSaWdodCh3aWRnZXQsIHRydWUpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2hpZnQgY2hlY2sgaWYgcGxhY2Vob2xkZXIgcG9zaXRpb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihBY3Rpb25EaXJlY3Rpb24uUmlnaHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbmV4dCB0cnkgbW92aW5nIGxlZnRcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbldpZGdldE1vdmVMZWZ0KHdpZGdldCwgdHJ1ZSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBzaGlmdCBjaGVjayBpZiBwbGFjZWhvbGRlciBwb3NpdGlvbiBpcyBzdGlsbCB2YWxpZFxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQbGFjZWhvbGRlclBvc2l0aW9uKEFjdGlvbkRpcmVjdGlvbi5MZWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZGlzdGFuY2UgdGhhdCB0aGUgd2lkZ2V0IG5lZWRzIHRvIGJlIG1vdmVkIGRvd25cbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9ICh0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvdygpIC0gd2lkZ2V0LmdldFJvdygpKSArIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Um93U3BhbigpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0IG1vdmUgdGhlIHdpZGdldCBkb3dud2FyZHNcbiAgICAgICAgICAgIHRoaXMubW92ZVdpZGdldERvd24od2lkZ2V0LCBkaXN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIHNoaWZ0cyBoYXZlIHRha2VuIHBsYWNlIHdlIHNob3VsZCB2ZXJpZnkgdGhlIHBsYWNlIGhvbGRlciBwb3NpdGlvbiBpcyBzdGlsbCB2YWxpZFxuICAgICAqIEBwYXJhbSBzaGlmdERpcmVjdGlvbiAtIHRoZSBwb3NpdGlvbiB3aWRnZXRzIHdlcmUgc2hpZnRlZFxuICAgICAqL1xuICAgIHZhbGlkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihzaGlmdERpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uKSB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwbGFjZWhvbGRlciBpcyBvdmVyIGEgd2lkZ2V0XG4gICAgICAgIGlmICh0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHBsYWNlaG9sZGVyLmNvbHVtbiwgcGxhY2Vob2xkZXIucm93LCB0cnVlKS5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIHBsYWNlaG9sZGVyIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIHN3aXRjaCAoc2hpZnREaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHMocGxhY2Vob2xkZXIudmlzaWJsZSwgcGxhY2Vob2xkZXIueCArIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSwgcGxhY2Vob2xkZXIueSwgcGxhY2Vob2xkZXIud2lkdGgsIHBsYWNlaG9sZGVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHMocGxhY2Vob2xkZXIudmlzaWJsZSwgcGxhY2Vob2xkZXIueCAtIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSwgcGxhY2Vob2xkZXIueSwgcGxhY2Vob2xkZXIud2lkdGgsIHBsYWNlaG9sZGVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSB0aGlzIG5ldyBwb3NpdGlvbiBhZ2FpblxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24oc2hpZnREaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGEgd2lkZ2V0IGNhbiBiZSBtb3ZlZCBsZWZ0IC0gb3IgaWYgaXQgY2FuIG1vdmUgdGhlIHdpZGdldHMgdG8gdGhlIHJpZ2h0IHRvIG1ha2Ugc3BhY2UgZm9yIHRoZSB3aWRnZXRcbiAgICAgKi9cbiAgICBjYW5XaWRnZXRNb3ZlTGVmdCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgcGVyZm9ybU1vdmU6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB3aWRnZXQgaXMgdGhlIGFjdGlvbiB3aWRnZXQgb3Igb2NjdXBpZXMgdGhlIGZpcnN0IGNvbHVtblxuICAgICAgICBpZiAod2lkZ2V0ID09PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0IHx8IHdpZGdldC5nZXRDb2x1bW4oKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcG9zaXRpb25zIHJlcXVpcmVkXG4gICAgICAgIGNvbnN0IHRhcmdldFNwYWNlcyA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKS5maWx0ZXIoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0ID09PSB3aWRnZXQpLm1hcChzcGFjZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2x1bW46IHNwYWNlLmNvbHVtbiAtIHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIHJvdzogc3BhY2Uucm93LCB3aWRnZXQ6IHNwYWNlLndpZGdldCB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgd2lkZ2V0IGluIHRoZSByZXF1aXJlZCBwb3NpdGlvbnMgYW5kIGlmIHNvLCBjYW4gdGhleSBtb3ZlIHJpZ2h0P1xuICAgICAgICBjb25zdCBtb3ZlYWJsZSA9IHRhcmdldFNwYWNlcy5ldmVyeShzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5ldmVyeSh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlTGVmdCh3Z3QpKSk7XG5cbiAgICAgICAgaWYgKHBlcmZvcm1Nb3ZlICYmIG1vdmVhYmxlKSB7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgYWxsIHdpZGdldHMgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB0YXJnZXRTcGFjZXMuZm9yRWFjaChzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5mb3JFYWNoKHdndCA9PiB0aGlzLmNhbldpZGdldE1vdmVMZWZ0KHdndCwgdHJ1ZSkpKTtcblxuICAgICAgICAgICAgLy8gbW92ZSBjdXJyZW50IHdpZGdldCB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIHdpZGdldC5zZXRDb2x1bW4od2lkZ2V0LmdldENvbHVtbigpIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGEgd2lkZ2V0IGNhbiBiZSBtb3ZlZCByaWdodCAtIG9yIGlmIGl0IGNhbiBtb3ZlIHRoZSB3aWRnZXRzIHRvIHRoZSByaWdodCB0byBtYWtlIHNwYWNlIGZvciB0aGUgd2lkZ2V0XG4gICAgICovXG4gICAgY2FuV2lkZ2V0TW92ZVJpZ2h0KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBwZXJmb3JtTW92ZTogYm9vbGVhbiA9IGZhbHNlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHdpZGdldCBpcyB0aGUgZHJhZ2dpbmcgd2lkZ2V0IG9yIHRoZSB3aWRnZXQgb2NjdXBpZXMgdGhlIGZpbmFsIGNvbHVtblxuICAgICAgICBpZiAod2lkZ2V0ID09PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0IHx8IHdpZGdldC5nZXRDb2x1bW4oKSArIHdpZGdldC5nZXRDb2x1bW5TcGFuKCkgPT09IHRoaXMub3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBwb3NpdGlvbnMgcmVxdWlyZWRcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BhY2VzID0gdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpLmZpbHRlcihzcGFjZSA9PiBzcGFjZS53aWRnZXQgPT09IHdpZGdldCkubWFwKHNwYWNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbHVtbjogc3BhY2UuY29sdW1uICsgd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgcm93OiBzcGFjZS5yb3csIHdpZGdldDogc3BhY2Uud2lkZ2V0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSB3aWRnZXQgaW4gdGhlIHJlcXVpcmVkIHBvc2l0aW9ucyBhbmQgaWYgc28sIGNhbiB0aGV5IG1vdmUgcmlnaHQ/XG4gICAgICAgIGNvbnN0IG1vdmVhYmxlID0gdGFyZ2V0U3BhY2VzLmV2ZXJ5KHNwYWNlID0+IHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oc3BhY2UuY29sdW1uLCBzcGFjZS5yb3cpLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSBzcGFjZS53aWRnZXQpLmV2ZXJ5KHdndCA9PiB0aGlzLmNhbldpZGdldE1vdmVSaWdodCh3Z3QpKSk7XG5cbiAgICAgICAgaWYgKHBlcmZvcm1Nb3ZlICYmIG1vdmVhYmxlKSB7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgYWxsIHdpZGdldHMgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB0YXJnZXRTcGFjZXMuZm9yRWFjaChzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5mb3JFYWNoKHdndCA9PiB0aGlzLmNhbldpZGdldE1vdmVSaWdodCh3Z3QsIHRydWUpKSk7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgY3VycmVudCB3aWRnZXQgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKHdpZGdldC5nZXRDb2x1bW4oKSArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSB3aWRnZXQgYmVpbmcgZHJhZ2dlZFxuICAgICAqL1xuICAgIHNldFdpZGdldE9yaWdpbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fd2lkZ2V0T3JpZ2luID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldENvbHVtbigpLFxuICAgICAgICAgICAgcm93OiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvdygpLFxuICAgICAgICAgICAgY29sdW1uU3BhbjogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRDb2x1bW5TcGFuKCksXG4gICAgICAgICAgICByb3dTcGFuOiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvd1NwYW4oKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhbGwgdGhlIHJlcXVpcmVkIHBvc2l0aW9ucyBpcyBhIHdpZGdldCB3YXMgdG8gYmUgcG9zaXRpb25lZCBhdCBhIHBhcnRpY3VsYXIgcG9pbnRcbiAgICAgKi9cbiAgICBnZXRSZXF1aXJlZFNwYWNlc0Zyb21Qb2ludCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyKTogRGFzaGJvYXJkU3BhY2VbXSB7XG4gICAgICAgIGNvbnN0IHNwYWNlczogRGFzaGJvYXJkU3BhY2VbXSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IHkgPSByb3c7IHkgPCByb3cgKyB3aWRnZXQuZ2V0Um93U3BhbigpOyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBjb2x1bW47IHggPCBjb2x1bW4gKyB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpOyB4KyspIHtcbiAgICAgICAgICAgICAgICBzcGFjZXMucHVzaCh7IGNvbHVtbjogeCwgcm93OiB5LCB3aWRnZXQ6IHdpZGdldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gd2lkZ2V0cyBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYWNlaG9sZGVyIC0gdGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgY29uZmlybWVkXG4gICAgICovXG4gICAgdXBkYXRlV2lkZ2V0UG9zaXRpb25zKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KSB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGFsbCBzcGFjZXMgdGhlIHBsYWNlaG9sZGVyIHdpbGwgb2NjdXB5IGFuZCBtb3ZlIGFueSB3aWRnZXQgY3VycmVudGx5IGluIHRoZW0gZG93blxuICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSBwbGFjZWhvbGRlci5jb2x1bW47IGNvbHVtbiA8IHBsYWNlaG9sZGVyLmNvbHVtbiArIHBsYWNlaG9sZGVyLmNvbHVtblNwYW47IGNvbHVtbisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSBwbGFjZWhvbGRlci5yb3c7IHJvdyA8IHBsYWNlaG9sZGVyLnJvdyArIHBsYWNlaG9sZGVyLnJvd1NwYW47IHJvdysrKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKGNvbHVtbiwgcm93LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2god2d0ID0+IHRoaXMubW92ZVdpZGdldERvd24od2d0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlaWdodCBvZiB0aGUgZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkSGVpZ2h0KCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgdGhlIHRvcCBoYW5kbGUgdGhlbiBmaWxsIHNwYWNlc1xuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zaGlmdFdpZGdldHNVcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGEgd2lkZ2V0IGlzIG9jY3VweWluZyBhIHNwZWNpZmljIHJvdyBhbmQgY29sdW1uXG4gICAgICogQHBhcmFtIGNvbHVtbiBUaGUgY29sdW1ucyB0byBjaGVjayBpZiBvY2N1cGllZFxuICAgICAqIEBwYXJhbSByb3cgVGhlIHJvdyB0byBjaGVjayBpZiBvY2N1cGllZFxuICAgICAqIEBwYXJhbSBpZ25vcmVSZXNpemluZyBXaGV0aGVyIG9yIG5vdCB0byBpZ25vcmUgdGhlIHdpZGdldCBjdXJyZW50bHkgYmVpbmcgcmVzaXplZFxuICAgICAqL1xuICAgIGdldFdpZGdldHNBdFBvc2l0aW9uKGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlciwgaWdub3JlUmVzaXppbmc6IGJvb2xlYW4gPSBmYWxzZSk6IERhc2hib2FyZFdpZGdldENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKVxuICAgICAgICAgICAgLmZpbHRlcihzcGFjZSA9PiBzcGFjZS5jb2x1bW4gPT09IGNvbHVtbiAmJiBzcGFjZS5yb3cgPT09IHJvdylcbiAgICAgICAgICAgIC5maWx0ZXIoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0ICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0IHx8ICFpZ25vcmVSZXNpemluZylcbiAgICAgICAgICAgIC5tYXAoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBsYWNlaG9sZGVyIHZpc2liaWxpdHksIHBvc2l0aW9uIGFuZCBzaXplXG4gICAgICovXG4gICAgc2V0UGxhY2Vob2xkZXJCb3VuZHModmlzaWJsZTogYm9vbGVhbiwgeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGNvbnN0IHJvdW5kaW5nID0gdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiA9PT0gQWN0aW9uRGlyZWN0aW9uLkxlZnQgfHxcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gPT09IEFjdGlvbkRpcmVjdGlvbi5Ub3AgPyBSb3VuZGluZy5Sb3VuZERvd25CZWxvd0hhbGYgOiBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGY7XG5cbiAgICAgICAgcGxhY2Vob2xkZXIudmlzaWJsZSA9IHZpc2libGU7XG5cbiAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uID0gdGhpcy5nZXRQbGFjZWhvbGRlckNvbHVtbih4LCB3aWR0aCk7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvdyA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJSb3coeSwgaGVpZ2h0KTtcbiAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uU3BhbiA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJDb2x1bW5TcGFuKHdpZHRoKTtcbiAgICAgICAgcGxhY2Vob2xkZXIucm93U3BhbiA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJSb3dTcGFuKGhlaWdodCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzXG4gICAgICAgIGNvbnN0IHJvd0NvdW50ID0gdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gd2lkZ2V0ICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0KVxuICAgICAgICAgICAgLnJlZHVjZSgocHJldmlvdXMsIHdpZGdldCkgPT4gTWF0aC5tYXgod2lkZ2V0LmdldFJvdygpICsgd2lkZ2V0LmdldFJvd1NwYW4oKSwgcHJldmlvdXMpLCAwKTtcblxuICAgICAgICAvLyBjb25zdHJhaW4gbWF4aW11bSBwbGFjZWhvbGRlciByb3dcbiAgICAgICAgcGxhY2Vob2xkZXIucm93ID0gTWF0aC5taW4ocGxhY2Vob2xkZXIucm93LCByb3dDb3VudCk7XG5cbiAgICAgICAgcGxhY2Vob2xkZXIueCA9IChwbGFjZWhvbGRlci5jb2x1bW4gKiB0aGlzLmdldENvbHVtbldpZHRoKCkpICsgdGhpcy5vcHRpb25zLnBhZGRpbmc7XG4gICAgICAgIHBsYWNlaG9sZGVyLnkgPSAocGxhY2Vob2xkZXIucm93ICogdGhpcy5fcm93SGVpZ2h0KSArIHRoaXMub3B0aW9ucy5wYWRkaW5nO1xuICAgICAgICBwbGFjZWhvbGRlci53aWR0aCA9IChwbGFjZWhvbGRlci5jb2x1bW5TcGFuICogdGhpcy5nZXRDb2x1bW5XaWR0aCgpKSAtICh0aGlzLm9wdGlvbnMucGFkZGluZyAqIDIpO1xuICAgICAgICBwbGFjZWhvbGRlci5oZWlnaHQgPSAocGxhY2Vob2xkZXIucm93U3BhbiAqIHRoaXMuX3Jvd0hlaWdodCkgLSAodGhpcy5vcHRpb25zLnBhZGRpbmcgKiAyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlcyBvZiB0aGUgd2lkZ2V0IHRvIG1hdGNoIHRoZSB2YWx1ZXMgb2YgdGhlIHBsYWNlaG9sZGVyIC0gaG93ZXZlciBkbyBub3QgcmVuZGVyIHRoZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Q29sdW1uKHBsYWNlaG9sZGVyLmNvbHVtbiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldFJvdyhwbGFjZWhvbGRlci5yb3csIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRDb2x1bW5TcGFuKHBsYWNlaG9sZGVyLmNvbHVtblNwYW4sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRSb3dTcGFuKHBsYWNlaG9sZGVyLnJvd1NwYW4sIGZhbHNlKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIkLm5leHQocGxhY2Vob2xkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGxhY2Vob2xkZXIgY29sdW1uIHBvc2l0aW9uXG4gICAgICovXG4gICAgZ2V0UGxhY2Vob2xkZXJDb2x1bW4oeDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkZyb21QeCh4LCB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uID09PSBBY3Rpb25EaXJlY3Rpb24uTW92ZSA/IFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZiA6IFJvdW5kaW5nLlJvdW5kRG93bik7XG4gICAgICAgIGNvbnN0IGNvbHVtblNwYW4gPSBNYXRoLmZsb29yKHdpZHRoIC8gdGhpcy5nZXRDb2x1bW5XaWR0aCgpKTtcbiAgICAgICAgY29uc3QgdXBwZXJMaW1pdCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIGNvbHVtblNwYW47XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgbGVmdCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBjb2x1bW5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5MZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbUxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihjb2x1bW4sIHVwcGVyTGltaXQpLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB3aWR0aCAlIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKTtcblxuICAgICAgICByZXR1cm4gKHggPD0gMCB8fCBvdmVyZmxvdyA9PT0gMCB8fCBjb2x1bW5TcGFuID09PSAwIHx8IG92ZXJmbG93ID4gKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSAvIDIpKSA/XG4gICAgICAgICAgICBNYXRoLm1heChNYXRoLm1pbihjb2x1bW4sIHVwcGVyTGltaXQpLCAwKSA6XG4gICAgICAgICAgICBNYXRoLm1heChNYXRoLm1pbihjb2x1bW4gKyAxLCB1cHBlckxpbWl0KSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb2x1bW4gc3BhbiBvZiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgKi9cbiAgICBnZXRQbGFjZWhvbGRlckNvbHVtblNwYW4od2lkdGg6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgY29sdW1uU3BhbiA9IHRoaXMuZ2V0Q29sdW1uRnJvbVB4KHdpZHRoKTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmVudCBkcmFnZ2luZyByaWdodCBvciBsZWZ0IHRoZW4ganVzdCByZXR1cm4gdGhlIGNvbHVtbiBzcGFuXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uUmlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbVJpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoY29sdW1uU3BhbiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgY29sdW1uIHNwYW4gYW5kIGFueSBvdmVyZmxvd1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IHdpZHRoICUgdGhpcy5nZXRDb2x1bW5XaWR0aCgpO1xuXG4gICAgICAgIHJldHVybiAoY29sdW1uU3BhbiA+IDAgJiYgb3ZlcmZsb3cgPiAodGhpcy5nZXRDb2x1bW5XaWR0aCgpIC8gMikpID8gTWF0aC5tYXgoY29sdW1uU3BhbiArIDEsIDEpIDogTWF0aC5tYXgoY29sdW1uU3BhbiwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb3cgcG9zaXRpb24gb2YgdGhlIHBsYWNlaG9sZGVyXG4gICAgICovXG4gICAgZ2V0UGxhY2Vob2xkZXJSb3coeTogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dGcm9tUHgoeSwgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiA9PT0gQWN0aW9uRGlyZWN0aW9uLk1vdmUgPyBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGYgOiBSb3VuZGluZy5Sb3VuZERvd24pO1xuICAgICAgICBjb25zdCByb3dTcGFuID0gTWF0aC5jZWlsKGhlaWdodCAvIHRoaXMuX3Jvd0hlaWdodCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgdXAgdGhlbiBqdXN0IHJldHVybiB0aGUgcm93XG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcFJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgbGV0IG92ZXJmbG93ID0gaGVpZ2h0IDwgdGhpcy5fcm93SGVpZ2h0ID8gMCA6IGhlaWdodCAlIHRoaXMuX3Jvd0hlaWdodDtcblxuICAgICAgICByZXR1cm4gKHkgPD0gMCB8fCByb3dTcGFuID09PSAwIHx8IG92ZXJmbG93ID09PSAwIHx8IG92ZXJmbG93ID4gKHRoaXMuX3Jvd0hlaWdodCAvIDIpKSA/IE1hdGgubWF4KHJvdywgMCkgOiBNYXRoLm1heChyb3cgKyAxLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvdyBzcGFuIG9mIHRoZSBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGdldFBsYWNlaG9sZGVyUm93U3BhbihoZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3Qgcm93U3BhbiA9IHRoaXMuZ2V0Um93RnJvbVB4KGhlaWdodCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgdXAgb3IgZG93biB0aGVuIGp1c3QgcmV0dXJuIHRoZSBjb2x1bW4gc3BhblxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbSAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbUxlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21SaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd1NwYW4sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGNvbHVtbiBzcGFuIGFuZCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBoZWlnaHQgJSB0aGlzLl9yb3dIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIChvdmVyZmxvdyA+ICh0aGlzLl9yb3dIZWlnaHQgLyAyKSkgPyBNYXRoLm1heChyb3dTcGFuICsgMSwgMSkgOiBNYXRoLm1heChyb3dTcGFuLCAxKTtcbiAgICB9XG5cbiAgICBnZXRDb2x1bW5Gcm9tUHgoeDogbnVtYmVyLCByb3VuZGluZzogUm91bmRpbmcgPSBSb3VuZGluZy5Sb3VuZERvd24pOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IE1hdGguZmxvb3IoeCAvIE1hdGguZmxvb3IodGhpcy5nZXRDb2x1bW5XaWR0aCgpKSk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gKHggJSBNYXRoLmZsb29yKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSkpO1xuICAgICAgICBjb25zdCBoYWxmID0gdGhpcy5nZXRDb2x1bW5XaWR0aCgpIC8gMjtcblxuICAgICAgICBzd2l0Y2ggKHJvdW5kaW5nKSB7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW47XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duQmVsb3dIYWxmOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA8IGhhbGYgPyBjb2x1bW4gOiBjb2x1bW4gKyAxO1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiBoYWxmID8gY29sdW1uICsgMSA6IGNvbHVtbjtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA+IDAgPyBjb2x1bW4gKyAxIDogY29sdW1uO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZXRSb3dGcm9tUHgoeTogbnVtYmVyLCByb3VuZGluZzogUm91bmRpbmcgPSBSb3VuZGluZy5Sb3VuZERvd24pOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoeSAvIE1hdGguZmxvb3IodGhpcy5fcm93SGVpZ2h0KSk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gKHkgJSBNYXRoLmZsb29yKHRoaXMuX3Jvd0hlaWdodCkpO1xuICAgICAgICBjb25zdCBoYWxmID0gdGhpcy5fcm93SGVpZ2h0IC8gMjtcblxuICAgICAgICBzd2l0Y2ggKHJvdW5kaW5nKSB7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiByb3c7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duQmVsb3dIYWxmOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA8IGhhbGYgPyByb3cgOiByb3cgKyAxO1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiBoYWxmID8gcm93ICsgMSA6IHJvdztcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA+IDAgPyByb3cgKyAxIDogcm93O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tbWl0V2lkZ2V0Q2hhbmdlcygpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgdGhhdCB3ZSBoYXZlIGFsbCB0aGUgdmFsdWVzIHdlIG5lZWRcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyLmNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IHBsYWNlaG9sZGVyLnJvdyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5jb2x1bW5TcGFuID09PSB1bmRlZmluZWQgfHwgcGxhY2Vob2xkZXIucm93U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldENvbHVtbihwbGFjZWhvbGRlci5jb2x1bW4pO1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRSb3cocGxhY2Vob2xkZXIucm93KTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Q29sdW1uU3BhbihwbGFjZWhvbGRlci5jb2x1bW5TcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Um93U3BhbihwbGFjZWhvbGRlci5yb3dTcGFuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IGFsbCBwbGFjZWhvbGRlciB2YWx1ZXNcbiAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uID0gdW5kZWZpbmVkO1xuICAgICAgICBwbGFjZWhvbGRlci5yb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtblNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvd1NwYW4gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgbmV3IHBsYWNlaG9sZGVyIHZhbHVlc1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyJC5uZXh0KHBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29sdW1uIHdpZHRoXG4gICAgICovXG4gICAgZ2V0Q29sdW1uV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5jb2x1bW5XaWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyBwb3B1bGF0ZWQgd2l0aCB3aWRnZXRzXG4gICAgICovXG4gICAgZ2V0Um93Q291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5yZWR1Y2UoKHByZXZpb3VzLCB3aWRnZXQpID0+IE1hdGgubWF4KHdpZGdldC5nZXRSb3coKSArIHdpZGdldC5nZXRSb3dTcGFuKCksIHByZXZpb3VzKSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGRhc2hib2FyZCBjb250YWluZXIgZWxlbWVudFxuICAgICAqL1xuICAgIHNldERhc2hib2FyZEhlaWdodCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzaXplIHRoZSBkYXNoYm9hcmQgY29udGFpbmVyIHRvIGVuc3VyZSBhbGwgcm93cyBmaXRcbiAgICAgICAgbGV0IHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIC8vIGlmIHdlIHNob3VsZCBzaG93IGFuIGVtcHR5IHJvdyBpbmNyZW1lbnQgdGhlIHJvdyBjb3VudCBieSAxXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW1wdHlSb3cpIHtcbiAgICAgICAgICAgIHJvd0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnModW5kZWZpbmVkLCByb3dDb3VudCAqIHRoaXMuX3Jvd0hlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JkZXJzIHRoZSB6LWluZGV4IG9mIGFsbCB3aWRnZXRzIHRvIG1vdmUgdGhlIGFjdGl2ZSBvbmUgdG8gdGhlIGZyb250XG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRoYXQgc2hvdWxkIGJlIGJyb3VnaHQgdG8gdGhlIGZyb250XG4gICAgICovXG4gICAgYnJpbmdUb0Zyb250KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKF93aWRnZXQgPT4gX3dpZGdldCA9PT0gd2lkZ2V0ID8gX3dpZGdldC5icmluZ1RvRnJvbnQoKSA6IF93aWRnZXQuc2VuZFRvQmFjaygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgd2lkZ2V0IGRvd24gLSBpZiB3aWRnZXRzIGFyZSBpbiB0aGUgcG9zaXRpb24gYmVsb3csIHRoZW4gbW92ZSB0aGVtIGRvd24gZnVydGhlclxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byBtb3ZlIGRvd253YXJkc1xuICAgICAqL1xuICAgIG1vdmVXaWRnZXREb3duKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBkaXN0YW5jZTogbnVtYmVyID0gMSk6IHZvaWQge1xuXG4gICAgICAgIC8vIG1vdmUgdGhlIHdpZGdldCBkb3duIG9uZSBwb3NpdGlvblxuICAgICAgICB3aWRnZXQuc2V0Um93KHdpZGdldC5nZXRSb3coKSArIGRpc3RhbmNlKTtcblxuICAgICAgICAvLyBjaGVjayBldmVyeSBzcGFjZSB0aGUgd2lkZ2V0IG9jY3VwaWVzIGZvciBjb2xsaXNpb25zXG4gICAgICAgIHRoaXMuZm9yRWFjaEJsb2NrKHdpZGdldCwgKGNvbHVtbiwgcm93KSA9PlxuICAgICAgICAgICAgdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihjb2x1bW4sIHJvdywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHdpZGdldClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCh3Z3QgPT4gdGhpcy5tb3ZlV2lkZ2V0RG93bih3Z3QsIGRpc3RhbmNlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpZGdldHMgc2hvdWxkIG5vdCBiZSBhbGxvd2VkIHRvIGhhdmUgYSB2YWNhbnQgc3BhY2UgYWJvdmUgdGhlbSAtIGlmIHRoZXJlIGlzIG9uZSB0aGV5IHNob3VsZCBtb3ZlIHVwd2FyZHMgdG8gZmlsbCBpdFxuICAgICAqL1xuICAgIHNoaWZ0V2lkZ2V0c1VwKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgb3Igbm90IGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgLSBpZiBzbyB3ZSBuZWVkIHRvIHJlcGVhdCB1bnRpbCBzdGFibGVcbiAgICAgICAgbGV0IHN0YWJsZSA9IHRydWU7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBlYWNoIHdpZGdldCBhbmRcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgLy8gaWYgd2lkZ2V0IGlzIGFscmVhZHkgb24gdGhlIHRvcCByb3cgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgICAgICBpZiAod2lkZ2V0LmdldFJvdygpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgY3VycmVudGx5IGRyYWdnaW5nIGFuZCB0aGlzIGlzIHRoZSBkcmFnZ2luZyB3aWRnZXQgdGhlbiBza2lwXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0ICYmIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQgPT09IHdpZGdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UG9zaXRpb25BdmFpbGFibGUod2lkZ2V0LmdldENvbHVtbigpLCB3aWRnZXQuZ2V0Um93KCkgLSAxLCB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCAxKSkge1xuICAgICAgICAgICAgICAgIHdpZGdldC5zZXRSb3cod2lkZ2V0LmdldFJvdygpIC0gMSk7XG4gICAgICAgICAgICAgICAgc3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGNoYW5nZXMgb2NjdXJyZWQgdGhlbiB3ZSBzaG91bGQgcmVwZWF0IHRoZSBwcm9jZXNzXG4gICAgICAgIGlmICghc3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0V2lkZ2V0c1VwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBzcGFjZSBhIHdpZGdldCBvY2N1cGllZFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byBkZXRlcm1pbmUgc3BhY2VzXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggc3BhY2UsIHNob3VsZCBleHBlY3QgYSBjb2x1bW4gYW5kIHJvdyBhcmd1bWVudCB3aXRodCBoZSBjb250ZXh0IGJlaW5nIHRoZSB3aWRnZXRcbiAgICAgKi9cbiAgICBmb3JFYWNoQmxvY2sod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIGNhbGxiYWNrOiAoY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IHdpZGdldC5nZXRSb3coKTsgcm93IDwgd2lkZ2V0LmdldFJvdygpICsgd2lkZ2V0LmdldFJvd1NwYW4oKTsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiA9IHdpZGdldC5nZXRDb2x1bW4oKTsgY29sdW1uIDwgd2lkZ2V0LmdldENvbHVtbigpICsgd2lkZ2V0LmdldENvbHVtblNwYW4oKTsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHdpZGdldCwgY29sdW1uLCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tlZCA/IDEgOiB0aGlzLm9wdGlvbnMuY29sdW1ucztcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0T3B0aW9uczogRGFzaGJvYXJkT3B0aW9ucyA9IHsgY29sdW1uczogNSwgcGFkZGluZzogNSwgbWluV2lkdGg6IDEwMCwgbWluSGVpZ2h0OiAxMDAsIGVtcHR5Um93OiB0cnVlIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkRGltZW5zaW9ucyB7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgaGVpZ2h0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZFdpZGdldERpbWVuc2lvbnMge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRBY3Rpb24ge1xuICAgIHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50O1xuICAgIGRpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uO1xuICAgIGV2ZW50OiBNb3VzZUV2ZW50O1xuICAgIGhhbmRsZT86IEhUTUxFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZFNwYWNlIHtcbiAgICB3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudDtcbiAgICBjb2x1bW46IG51bWJlcjtcbiAgICByb3c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRQbGFjZWhvbGRlciB7XG4gICAgdmlzaWJsZTogYm9vbGVhbjtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgY29sdW1uPzogbnVtYmVyO1xuICAgIHJvdz86IG51bWJlcjtcbiAgICBjb2x1bW5TcGFuPzogbnVtYmVyO1xuICAgIHJvd1NwYW4/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkQ2FjaGUge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgY29sdW1uOiBudW1iZXI7XG4gICAgcm93OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkTGF5b3V0RGF0YSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBjb2w6IG51bWJlcjtcbiAgICByb3c6IG51bWJlcjtcbiAgICBjb2xTcGFuOiBudW1iZXI7XG4gICAgcm93U3BhbjogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBBY3Rpb25EaXJlY3Rpb24ge1xuICAgIFRvcCA9IDAsXG4gICAgVG9wUmlnaHQgPSAxLFxuICAgIFJpZ2h0ID0gMixcbiAgICBCb3R0b21SaWdodCA9IDMsXG4gICAgQm90dG9tID0gNCxcbiAgICBCb3R0b21MZWZ0ID0gNSxcbiAgICBMZWZ0ID0gNixcbiAgICBUb3BMZWZ0ID0gNyxcbiAgICBNb3ZlID0gOFxufVxuXG5leHBvcnQgZW51bSBSb3VuZGluZyB7XG4gICAgUm91bmREb3duLFxuICAgIFJvdW5kRG93bkJlbG93SGFsZixcbiAgICBSb3VuZFVwLFxuICAgIFJvdW5kVXBPdmVySGFsZlxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVEaW1lbnNpb25zIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvcmVzaXplLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGFzaGJvYXJkTGF5b3V0RGF0YSwgRGFzaGJvYXJkU2VydmljZSwgZGVmYXVsdE9wdGlvbnMgfSBmcm9tICcuL2Rhc2hib2FyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXNoYm9hcmQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kYXNoYm9hcmQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW0Rhc2hib2FyZFNlcnZpY2VdLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgQElucHV0KCkgc2V0IGxheW91dChsYXlvdXQ6IERhc2hib2FyZExheW91dERhdGFbXSkge1xuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2UubGF5b3V0JC5uZXh0KGxheW91dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASW5wdXQoKSBzZXQgb3B0aW9ucyhvcHRpb25zOiBEYXNoYm9hcmRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5vcHRpb25zJC5uZXh0KHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIGxheW91dENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RGFzaGJvYXJkTGF5b3V0RGF0YVtdPigpO1xuXG4gICAgQFZpZXdDaGlsZCgnZGFzaGJvYXJkJykgZGFzaGJvYXJkRWxlbWVudDogRWxlbWVudFJlZjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXNoYm9hcmRTZXJ2aWNlOiBEYXNoYm9hcmRTZXJ2aWNlKSB7XG4gICAgICAgIGRhc2hib2FyZFNlcnZpY2UubGF5b3V0JC5zdWJzY3JpYmUobGF5b3V0ID0+IHRoaXMubGF5b3V0Q2hhbmdlLmVtaXQobGF5b3V0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpbml0aWFsIGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5zZXREaW1lbnNpb25zKHRoaXMuZGFzaGJvYXJkRWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoLCB0aGlzLmRhc2hib2FyZEVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQpO1xuICAgIH1cblxuICAgIG9uUmVzaXplKGV2ZW50OiBSZXNpemVEaW1lbnNpb25zKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5zZXREaW1lbnNpb25zKGV2ZW50LndpZHRoLCBldmVudC5oZWlnaHQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRPcHRpb25zIHtcbiAgICBjb2x1bW5zPzogbnVtYmVyO1xuICAgIHBhZGRpbmc/OiBudW1iZXI7XG4gICAgbWluV2lkdGg/OiBudW1iZXI7XG4gICAgbWluSGVpZ2h0PzogbnVtYmVyO1xuICAgIHJvd0hlaWdodD86IG51bWJlcjtcbiAgICBlbXB0eVJvdz86IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBPbkRlc3Ryb3ksIEhvc3RCaW5kaW5nLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXNoYm9hcmRTZXJ2aWNlLCBBY3Rpb25EaXJlY3Rpb24gfSBmcm9tICcuLi9kYXNoYm9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGFzaGJvYXJkLXdpZGdldCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2Rhc2hib2FyZC13aWRnZXQuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZFdpZGdldENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY29sOiBudW1iZXI7XG4gICAgQElucHV0KCkgcm93OiBudW1iZXI7XG4gICAgQElucHV0KCkgY29sU3BhbjogbnVtYmVyID0gMTtcbiAgICBASW5wdXQoKSByb3dTcGFuOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIHJlc2l6YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5sZWZ0LnB4JykgeDogbnVtYmVyID0gMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnRvcC5weCcpIHk6IG51bWJlciA9IDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aC5weCcpIHdpZHRoOiBudW1iZXIgPSAxMDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5oZWlnaHQucHgnKSBoZWlnaHQ6IG51bWJlciA9IDEwMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnBhZGRpbmcucHgnKSBwYWRkaW5nOiBudW1iZXIgPSAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuei1pbmRleCcpIHpJbmRleDogbnVtYmVyID0gMDtcblxuICAgIHByaXZhdGUgX2NvbHVtbjogU3RhY2thYmxlVmFsdWUgPSB7IHJlZ3VsYXI6IHVuZGVmaW5lZCwgc3RhY2tlZDogdW5kZWZpbmVkIH07XG4gICAgcHJpdmF0ZSBfcm93OiBTdGFja2FibGVWYWx1ZSA9IHsgcmVndWxhcjogdW5kZWZpbmVkLCBzdGFja2VkOiB1bmRlZmluZWQgfTtcbiAgICBwcml2YXRlIF9jb2x1bW5TcGFuOiBTdGFja2FibGVWYWx1ZSA9IHsgcmVndWxhcjogMSwgc3RhY2tlZDogMSB9O1xuICAgIHByaXZhdGUgX3Jvd1NwYW46IFN0YWNrYWJsZVZhbHVlID0geyByZWd1bGFyOiAxLCBzdGFja2VkOiAxIH07XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGFzaGJvYXJkU2VydmljZTogRGFzaGJvYXJkU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBkYXNoYm9hcmRTZXJ2aWNlLm9wdGlvbnMkLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZSgpKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLl9jb2x1bW5TcGFuLnJlZ3VsYXIgPSB0aGlzLmNvbFNwYW47XG4gICAgICAgIHRoaXMuX3Jvd1NwYW4ucmVndWxhciA9IHRoaXMucm93U3BhbjtcblxuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGFzaGJvYXJkIFdpZGdldCBpcyBtaXNzaW5nIGFuIElELicpO1xuXG4gICAgICAgICAgICAvLyBzZXQgcmFuZG9tIGlkIC0ga2VlcHMgdGhpbmdzIHdvcmtpbmcgYnV0IHByZXZlbnRzIGV4cG9ydGluZyBvZiBwb3NpdGlvbnNcbiAgICAgICAgICAgIHRoaXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIGFkZCB0aGUgd2lkZ2V0IHRvIHRoZSBkYXNoYm9hcmRcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmFkZFdpZGdldCh0aGlzKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgY29tcG9uZW50IGlzIHJlbW92ZWQsIHRoZW4gdW5yZWdpc3RlciBpdCBmcm9tIHRoZSBzZXJ2aWNlXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2UucmVtb3ZlV2lkZ2V0KHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBjdXJyZW50IGRhc2hib2FyZCBvcHRpb25zXG4gICAgICovXG4gICAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBvcHRpb25zIGF0IHRoZSB0aW1lIFxuICAgICAgICBjb25zdCB7IHBhZGRpbmcsIGNvbHVtbnMgfSA9IHRoaXMuZGFzaGJvYXJkU2VydmljZS5vcHRpb25zO1xuXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHRoaXMuX2NvbHVtblNwYW4uc3RhY2tlZCA9IGNvbHVtbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhY3R1YWwgcG9zaXRpb24gYW5kIHNpemUgdmFsdWVzXG4gICAgICovXG4gICAgcmVuZGVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnggPSB0aGlzLmdldENvbHVtbigpICogdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmdldENvbHVtbldpZHRoKCk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMuZ2V0Um93KCkgKiB0aGlzLmRhc2hib2FyZFNlcnZpY2UuZ2V0Um93SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmdldENvbHVtblNwYW4oKSAqIHRoaXMuZGFzaGJvYXJkU2VydmljZS5nZXRDb2x1bW5XaWR0aCgpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuZ2V0Um93U3BhbigpICogdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmdldFJvd0hlaWdodCgpO1xuICAgIH1cblxuICAgIGdldENvbHVtbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW4pO1xuICAgIH1cblxuICAgIGdldFJvdygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9yb3cpO1xuICAgIH1cblxuICAgIHNldENvbHVtbihjb2x1bW46IG51bWJlciwgcmVuZGVyOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFN0YWNrYWJsZVZhbHVlKHRoaXMuX2NvbHVtbiwgY29sdW1uKTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Um93KHJvdzogbnVtYmVyLCByZW5kZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93LCByb3cpO1xuXG4gICAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb2x1bW5TcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrYWJsZVZhbHVlKHRoaXMuX2NvbHVtblNwYW4pO1xuICAgIH1cblxuICAgIGdldFJvd1NwYW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93U3Bhbik7XG4gICAgfVxuXG4gICAgc2V0Q29sdW1uU3Bhbihjb2x1bW5TcGFuOiBudW1iZXIsIHJlbmRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW5TcGFuLCBjb2x1bW5TcGFuKTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Um93U3Bhbihyb3dTcGFuOiBudW1iZXIsIHJlbmRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9yb3dTcGFuLCByb3dTcGFuKTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnJpbmdUb0Zyb250KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnpJbmRleCA9IDE7XG4gICAgfVxuXG4gICAgc2VuZFRvQmFjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy56SW5kZXggPSAwO1xuICAgIH1cblxuICAgIHNldEJvdW5kcyh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICBkcmFnc3RhcnQoaGFuZGxlOiBIVE1MRWxlbWVudCwgZXZlbnQ6IE1vdXNlRXZlbnQsIGRpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5vblJlc2l6ZVN0YXJ0KHsgd2lkZ2V0OiB0aGlzLCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgZXZlbnQ6IGV2ZW50LCBoYW5kbGU6IGhhbmRsZSB9KTtcbiAgICB9XG5cbiAgICBkcmFnKGhhbmRsZTogSFRNTEVsZW1lbnQsIGV2ZW50OiBNb3VzZUV2ZW50LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub25SZXNpemVEcmFnKHsgd2lkZ2V0OiB0aGlzLCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgZXZlbnQ6IGV2ZW50LCBoYW5kbGU6IGhhbmRsZSB9KTtcbiAgICB9XG5cbiAgICBkcmFnZW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub25SZXNpemVFbmQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgYXV0b21hdGljIHNldHRpbmcgb2Ygc3RhY2thYmxlIHZhbHVlXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBjdXJyZW50IFN0YWNrYWJsZVZhbHVlIG9iamVjdFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGluIHRoZSBhcHByb3ByaWF0ZSBmaWVsZFxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0U3RhY2thYmxlVmFsdWUocHJvcGVydHk6IFN0YWNrYWJsZVZhbHVlLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuZGFzaGJvYXJkU2VydmljZS5zdGFja2VkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eS5zdGFja2VkID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0eS5yZWd1bGFyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlIGZyb20gYSBzdGFja2FibGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgVGhlIFN0YWNrYWJsZSB2YWx1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFN0YWNrYWJsZVZhbHVlKHByb3BlcnR5OiBTdGFja2FibGVWYWx1ZSk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCA/IHByb3BlcnR5LnN0YWNrZWQgOiBwcm9wZXJ0eS5yZWd1bGFyO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFja2FibGVWYWx1ZSB7XG4gICAgcmVndWxhcjogbnVtYmVyO1xuICAgIHN0YWNrZWQ6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRHJhZ1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIEVtaXQgd2hlbiBkcmFnZ2luZyBiZWdpbnMgKi9cbiAgICBvbkRyYWdTdGFydCA9IG5ldyBTdWJqZWN0PFV4RHJhZ0V2ZW50PigpO1xuXG4gICAgLyoqIEVtaXQgd2hlbiBkcmFnZ2luZyBtb3ZlcyAqL1xuICAgIG9uRHJhZyA9IG5ldyBTdWJqZWN0PFV4RHJhZ0V2ZW50PigpO1xuXG4gICAgLyoqIEVtaXQgd2hlbiBkcmFnZ2luZyBlbmRzICovXG4gICAgb25EcmFnRW5kID0gbmV3IFN1YmplY3Q8VXhEcmFnRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIHRoZSB1c2VyIGlzIGRyYWdnaW5nIG92ZXIgdGhlIGRyb3AgYXJlYSAqL1xuICAgIG9uRHJvcEVudGVyID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0IHdoZW4gdGhlIHVzZXIgaXMgZHJhZ2dpbmcgb3V0IG9mIHRoZSBkcm9wIGFyZWEgKi9cbiAgICBvbkRyb3BMZWF2ZSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIGEgZHJvcCBvY2N1cnMgKi9cbiAgICBvbkRyb3AgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICAvKiogRGVzdHJveSBhbGwgb2JzZXJ2YWJsZXMgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkRyYWdTdGFydC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLm9uRHJhZy5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLm9uRHJhZ0VuZC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLm9uRHJvcC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLm9uRHJvcEVudGVyLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMub25Ecm9wTGVhdmUuY29tcGxldGUoKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHR5cGUgVXhEcmFnRXZlbnQgPSB7IGdyb3VwPzogc3RyaW5nLCBldmVudD86IE1vdXNlRXZlbnQsIGRhdGE/OiBhbnkgfTsiLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE5nWm9uZSwgT25EZXN0cm95LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRHJhZ1NlcnZpY2UgfSBmcm9tICcuL2RyYWcuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4RHJhZ10nXG59KVxuZXhwb3J0IGNsYXNzIERyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIERldGVtaW5lIGlmIHdlIHNob3VsZCBzaG93IGEgY2xvbmUgd2hlbiBkcmFnZ2luZyAqL1xuICAgIEBJbnB1dCgpIGNsb25lOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogRGVmaW5lIHRoZSBncm91cCB0aGUgZHJhZyBldmVudCBiZWxvbmdzIHRvICovXG4gICAgQElucHV0KCkgZ3JvdXA6IHN0cmluZztcblxuICAgIC8qKiBBc3NvY2lhdGUgc29tZSBkYXRhIHdpdGggdGhlIGRyYWcgZXZlbnQgKi9cbiAgICBASW5wdXQoKSBtb2RlbDogYW55O1xuXG4gICAgLyoqIEFsbG93IHRoZSBkcmFnZ2luZyB0byBiZSBlbmFibGVkL2Rpc2FibGVkICovXG4gICAgQElucHV0KCkgZHJhZ2dhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBFbWl0IGFuIGV2ZW50IHdoZW4gZHJhZ2dpbmcgc3RhcnRzICovXG4gICAgQE91dHB1dCgpIG9uRHJhZ1N0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqIEVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgbW91c2UgbW92ZXMgd2hpbGUgZHJhZ2dpbmcgKi9cbiAgICBAT3V0cHV0KCkgb25EcmFnID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqIEVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgZHJhZ2dpbmcgZmluaXNoZXMgKi9cbiAgICBAT3V0cHV0KCkgb25EcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEVtaXQgd2hlbiB0aGUgdXNlciBkcm9wcyBhbiBpdGVtIGluIGEgZHJvcCBhcmVhICovXG4gICAgQE91dHB1dCgpIG9uRHJvcCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEVtaXQgd2hlbiB0aGUgdXNlciBkcmFncyBvdmVyIGEgZHJvcCBhcmVhICovXG4gICAgQE91dHB1dCgpIG9uRHJvcEVudGVyID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEVtaXQgd2hlbiB0aGUgdXNlciBkcmFncyBvdXQgb2YgYSBkcm9wIGFyZWEgKi9cbiAgICBAT3V0cHV0KCkgb25Ecm9wTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogU3RvcmUgdGhlIGVsZW1lbnQgd2UgaGF2ZSBjbG9uZWQgKi9cbiAgICBwcml2YXRlIF9jbG9uZTogRWxlbWVudDtcblxuICAgIC8qKiBTdG9yZSB0aGUgZHJhZ2dpbmcgc3RhdGUgKi9cbiAgICBwcml2YXRlIF9pc0RyYWdnaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogU3RvcmUgdGhlIG1vdXNlIG9mZnNldCBmb3IgdGhlIGNsb25lZCBlbGVtZW50IHBvc2l0aW9uICovXG4gICAgcHJpdmF0ZSBfb2Zmc2V0OiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH07XG5cbiAgICAvKiogQ3JlYXRlIGFuIG9ic2VydmFibGUgZnJvbSB0aGUgbW91c2UgZG93biBldmVudCAqL1xuICAgIHByaXZhdGUgX21vdXNlZG93biQgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2Vkb3duJyk7XG5cbiAgICAvKiogQ3JlYXRlIGFuIG9ic2VydmFibGUgZnJvbSB0aGUgbW91c2UgbW92ZSBldmVudCAqL1xuICAgIHByaXZhdGUgX21vdXNlbW92ZSQgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4oZG9jdW1lbnQsICdtb3VzZW1vdmUnKTtcblxuICAgIC8qKiBDcmVhdGUgYW4gb2JzZXJ2YWJsZSBmcm9tIHRoZSBtb3VzZSB1cCBldmVudCAqL1xuICAgIHByaXZhdGUgX21vdXNldXAkID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KGRvY3VtZW50LCAnbW91c2V1cCcpO1xuXG4gICAgLyoqIFVzZSBhbiBvYnNlcnZhYmxlIHRvIHVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnMgKi9cbiAgICBwcm90ZWN0ZWQgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfZHJhZzogRHJhZ1NlcnZpY2UpIHtcblxuICAgICAgICAvLyBlbnN1cmUgYWxsIG1vdXNlIGRvd24gZXZlbnRzIG9uIHRoZSBvYmplY3QgYXJlIGNhcHR1cmVkXG4gICAgICAgIHRoaXMuX21vdXNlZG93biQucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5kcmFnZ2FibGUpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMuZHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIG91dHB1dHMgd2hlbiBkcmFnIGV2ZW50cyBvY2N1clxuICAgICAgICBfZHJhZy5vbkRyYWdTdGFydC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLCBmaWx0ZXIoKCkgPT4gdGhpcy5faXNEcmFnZ2luZykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRyYWdFdmVudCA9PiB0aGlzLm9uRHJhZ1N0YXJ0LmVtaXQoZHJhZ0V2ZW50LmV2ZW50KSk7XG5cbiAgICAgICAgX2RyYWcub25EcmFnLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcigoKSA9PiB0aGlzLl9pc0RyYWdnaW5nKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZHJhZ0V2ZW50ID0+IHRoaXMub25EcmFnLmVtaXQoZHJhZ0V2ZW50LmV2ZW50KSk7XG5cbiAgICAgICAgX2RyYWcub25EcmFnRW5kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcigoKSA9PiB0aGlzLl9pc0RyYWdnaW5nKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkRyYWdFbmQuZW1pdCgpKTtcblxuICAgICAgICBfZHJhZy5vbkRyb3AucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZmlsdGVyKCgpID0+IHRoaXMuX2lzRHJhZ2dpbmcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiB0aGlzLm9uRHJvcC5lbWl0KGV2ZW50KSk7XG5cbiAgICAgICAgX2RyYWcub25Ecm9wRW50ZXIucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZmlsdGVyKCgpID0+IHRoaXMuX2lzRHJhZ2dpbmcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uRHJvcEVudGVyLmVtaXQoKSk7XG5cbiAgICAgICAgX2RyYWcub25Ecm9wTGVhdmUucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZmlsdGVyKCgpID0+IHRoaXMuX2lzRHJhZ2dpbmcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uRHJvcExlYXZlLmVtaXQoKSk7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgZXZlbnRzIGFuZCBjcmVhdGUgY2xvbmUgd2hlbiBkcmFnIHN0YXJ0cyAqL1xuICAgIGRyYWdTdGFydChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNsb25lKSB7XG4gICAgICAgICAgICAvLyBjbG9uZSB0aGUgbm9kZVxuICAgICAgICAgICAgdGhpcy5jbG9uZU5vZGUoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYSBjbGFzcyB0byB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWRyYWctZHJhZ2dpbmcnKTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgZHJhZ2dpbmcgc3RhdGVcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgZHJhZyBzdGFydCBldmVudFxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2RyYWcub25EcmFnU3RhcnQubmV4dCh7IGV2ZW50LCBncm91cDogdGhpcy5ncm91cCwgZGF0YTogdGhpcy5tb2RlbCB9KSk7XG5cbiAgICAgICAgdGhpcy5fbW91c2Vtb3ZlJC5waXBlKHRha2VVbnRpbCh0aGlzLl9tb3VzZXVwJCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmRyYWdNb3ZlLmJpbmQodGhpcyksIG51bGwsIHRoaXMuZHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKiogRW1pdCBldmVudCBhbmQgdXBkYXRlIGNsb25lIHBvc2l0aW9uIHdoZW4gZHJhZ2dpbmcgbW92ZXMgKi9cbiAgICBkcmFnTW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jbG9uZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgZHJhZyBzdGFydCBldmVudFxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2RyYWcub25EcmFnLm5leHQoeyBldmVudCwgZ3JvdXA6IHRoaXMuZ3JvdXAsIGRhdGE6IHRoaXMubW9kZWwgfSkpO1xuICAgIH1cblxuICAgIC8qKiBFbWl0IGV2ZW50IGFuZCBkZXN0cm95IGNsb25lIHdoZW4gZHJhZ2dpbmcgZW5kcyAqL1xuICAgIGRyYWdFbmQoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIGNsb25lLCByZW1vdmUgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Nsb25lKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDaGlsZChkb2N1bWVudC5ib2R5LCB0aGlzLl9jbG9uZSk7XG4gICAgICAgICAgICB0aGlzLl9jbG9uZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIGRyYWdnaW5nIGNsYXNzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWRyYWctZHJhZ2dpbmcnKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBvbiBkcmFnIGVuZCBvdXRwdXRcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLl9kcmFnLm9uRHJhZ0VuZC5uZXh0KHsgZ3JvdXA6IHRoaXMuZ3JvdXAsIGRhdGE6IHRoaXMubW9kZWwgfSkpO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBkcmFnZ2luZyBzdGF0ZVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbiBleGFjdCBjbG9uZSBvZiBhbiBlbGVtZW50ICovXG4gICAgY2xvbmVOb2RlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZHVwbGljYXRlIHRoZSBub2RlXG4gICAgICAgIHRoaXMuX2Nsb25lID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSBkcmFnZ2FibGUgZWxlbWVudFxuICAgICAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGggfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0geyB4OiBldmVudC5jbGllbnRYIC0gbGVmdCwgeTogZXZlbnQuY2xpZW50WSAtIHRvcCB9O1xuXG4gICAgICAgIC8vIGlubGluZSBhbGwgc3R5bGVzIHNvIGl0IGxvb2tzIGlkZW50aWNhbCByZWdhcmRsZXNzIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgRE9NXG4gICAgICAgIHRoaXMuaW5saW5lU3R5bGVzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fY2xvbmUpO1xuXG4gICAgICAgIC8vIElFIGRvZXNuJ3QgYWx3YXlzIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB3aWR0aCB2YWx1ZSB1c2luZyBnZXRDb21wdXRlZFN0eWxlcy4uLiB1c2UgYm91bmRpbmcgY2xpZW50IHZhbHVlIGluc3RlYWRcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICd3aWR0aCcsIHdpZHRoICsgJ3B4Jyk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHdlIGNhbiBlYXNpbHkgcG9zaXRpb24gdGhlIG5vZGUgYW4gaXQgaXMgYWJvdmUgYWxsIG90aGVyIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLl9jbG9uZSwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9jbG9uZSwgJ3otaW5kZXgnLCAnOTk5OTknKTtcblxuICAgICAgICAvLyBhcHBseSBhIGNsYXNzIHRvIGFsbG93IGN1c3RvbSBzdHlsaW5nXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2Nsb25lLCAndXgtZHJhZy1kcmFnZ2luZy1jbG9uZScpO1xuXG4gICAgICAgIC8vIGluc2VydCB0aGUgY2xvbmVkIGVsZW1lbnRcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuYm9keSwgdGhpcy5fY2xvbmUpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgY2xvbmVkIGVsZW1lbnQgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgICB0aGlzLnVwZGF0ZU5vZGVQb3NpdGlvbihldmVudCk7XG4gICAgfVxuXG4gICAgLyoqIFBvc2l0aW9uIHRoZSBjbG9uZSByZWxhdGl2ZSB0byB0aGUgbW91c2UgKi9cbiAgICB1cGRhdGVOb2RlUG9zaXRpb24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICdsZWZ0JywgKGV2ZW50LnBhZ2VYIC0gdGhpcy5fb2Zmc2V0LngpICsgJ3B4Jyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2Nsb25lLCAndG9wJywgKGV2ZW50LnBhZ2VZIC0gdGhpcy5fb2Zmc2V0LnkpICsgJ3B4Jyk7XG4gICAgfVxuXG4gICAgLyoqIElubGluZSBhbGwgc3R5bGVzIHRvIGVuc3VyZSBzdHlsaW5nIGlzIGNvbnNpc3RlbnQgcmVnYXJkbGVzcyBvZiBpdHMgcG9zaXRpb24gaW4gdGhlIGRvbSAqL1xuICAgIGlubGluZVN0eWxlcyhzb3VyY2U6IEVsZW1lbnQsIHRhcmdldDogRWxlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBnZXQgYWxsIHRoZSBjb21wdXRlZCBzdHlsZXMgZnJvbSB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzb3VyY2UpO1xuXG4gICAgICAgIC8vIGlubGluZSBldmVyeSBzcGVjaWZpZWQgc3R5bGVcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc3R5bGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzLml0ZW0oaWR4KTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0YXJnZXQsIHN0eWxlc1tpZHhdLCBzdHlsZXNbc3R5bGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBkb250IGNhcHR1cmUgYW55IG1vdmUgZXZlbnRzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRhcmdldCwgJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuICAgICAgICAvLyBkbyB0aGUgc2FtZSBmb3IgYWxsIHRoZSBjaGlsZCBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVTdHlsZXMoc291cmNlLmNoaWxkcmVuW2lkeF0sIHRhcmdldC5jaGlsZHJlbltpZHhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBVbnN1YnNjcmliZSBmcm9tIGFsbCBzdWJzY3JpcHRpb25zICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBEcmFnU2VydmljZSwgVXhEcmFnRXZlbnQgfSBmcm9tICcuL2RyYWcuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4RHJvcF0nLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy51eC1kcm9wLWhvdmVyXSc6ICdpc01vdXNlT3ZlciAmJiBpc0RyYWdnaW5nJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgRHJvcERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogRGVmaW5lIGEgc3BlY2lmaWMgZ3JvdXAgb2YgZHJhZ2dlZCBpdGVtcyB0byBsaXN0ZW4gdG8gKi9cbiAgICBASW5wdXQoKSBncm91cDogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICAvKiogRW1pdCB0aGUgbW9kZWwgb2YgdGhlIGl0ZW0gZHJvcHBlZCAqL1xuICAgIEBPdXRwdXQoKSBvbkRyb3AgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgZHJvcCByZWdpb24gKi9cbiAgICBpc01vdXNlT3ZlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB3ZSBhcmUgY3VycmVudGx5IGRyYWdnaW5nIGFuIGl0ZW0gKi9cbiAgICBpc0RyYWdnaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogU3RvcmUgdGhlIGdyb3VwIG9mIHRoZSBkcmFnZ2VkIGl0ZW0gKi9cbiAgICBwcml2YXRlIF9ncm91cDogc3RyaW5nO1xuXG4gICAgLyoqIEVuc3VyZSB3ZSBkZXN0cm95IGFsbCBzdWJzY3JpcHRpb25zICovXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RyYWdTZXJ2aWNlOiBEcmFnU2VydmljZSkge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gZHJhZyBldmVudHNcbiAgICAgICAgX2RyYWdTZXJ2aWNlLm9uRHJhZ1N0YXJ0LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcihldmVudCA9PiB0aGlzLmlzR3JvdXBBbGxvd2VkKGV2ZW50Lmdyb3VwKSkpLnN1YnNjcmliZSh0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICAgICAgICBfZHJhZ1NlcnZpY2Uub25EcmFnRW5kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcihldmVudCA9PiB0aGlzLmlzR3JvdXBBbGxvd2VkKGV2ZW50Lmdyb3VwKSkpLnN1YnNjcmliZSh0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0aGUgbW91c2Ugb3ZlciBzdGF0ZSAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKVxuICAgIG9uTW91c2VPdmVyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc0dyb3VwQWxsb3dlZCh0aGlzLl9ncm91cCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3VzZU92ZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoYXQgd2UgYXJlIG92ZXIgYSBkcm9wIGFyZWFcbiAgICAgICAgICAgIHRoaXMuX2RyYWdTZXJ2aWNlLm9uRHJvcEVudGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhlIG1vdXNlIG92ZXIgc3RhdGUgKi9cbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJylcbiAgICBvbk1vdXNlTGVhdmUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gYWx3YXlzIGVuc3VyZSB0aGlzIHZhbHVlIGlzIHJlc2V0XG4gICAgICAgIHRoaXMuaXNNb3VzZU92ZXIgPSBmYWxzZTtcblxuICAgICAgICAvLyBvbmx5IGVtaXQgdGhlIGRyb3BkIGxlYXZlIGV2ZW50IHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgaWYgKHRoaXMuaXNHcm91cEFsbG93ZWQodGhpcy5fZ3JvdXApKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnU2VydmljZS5vbkRyb3BMZWF2ZS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIHRoZSBkcmFnZ2luZyBzdGF0ZSAqL1xuICAgIG9uRHJhZ1N0YXJ0KGV2ZW50OiBVeERyYWdFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9ncm91cCA9IGV2ZW50Lmdyb3VwO1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhlIGRyYWdnaW5nIHN0YXRlICovXG4gICAgb25EcmFnRW5kKGV2ZW50OiBVeERyYWdFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZHJhZ2dpbmcgc3RhdGVcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNhY2hlZCBncm91cFxuICAgICAgICB0aGlzLl9ncm91cCA9IG51bGw7XG5cbiAgICAgICAgLy8gaWYgdGhlIG1vdXNlIGlzIG92ZXIgYW5kIGl0IGlzIGluIGFuIGFsbG93ZWQgZ3JvdXAgZW1pdCB0aGUgZG9wIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLmlzTW91c2VPdmVyICYmIHRoaXMuaXNHcm91cEFsbG93ZWQoZXZlbnQuZ3JvdXApKSB7XG4gICAgICAgICAgICB0aGlzLm9uRHJvcC5lbWl0KGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ1NlcnZpY2Uub25Ecm9wLm5leHQoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSBldmVudCBpcyBwYXJ0IG9mIHRoZSBzcGVjaWZpZWQgZ3JvdXBzICovXG4gICAgcHJpdmF0ZSBpc0dyb3VwQWxsb3dlZChncm91cDogc3RyaW5nKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gaWYgbm8gZ3JvdXAgc3BlY2lmaWVkIGFsbG93IGFsbCBncm91cHNcbiAgICAgICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IHRoZW4gZW5zdXJlIGl0IGlzIGFsbG93ZWRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ncm91cCkpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ3JvdXAuZmluZChfZ3JvdXAgPT4gX2dyb3VwID09PSBncm91cCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cCA9PT0gZ3JvdXA7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEcmFnRGlyZWN0aXZlIH0gZnJvbSAnLi9kcmFnLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEcmFnU2VydmljZSB9IGZyb20gJy4vZHJhZy5zZXJ2aWNlJztcbmltcG9ydCB7IERyb3BEaXJlY3RpdmUgfSBmcm9tICcuL2Ryb3AuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiAgICAgIFtEcmFnRGlyZWN0aXZlLCBEcm9wRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtEcmFnRGlyZWN0aXZlLCBEcm9wRGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6ICAgIFtEcmFnU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgRHJhZ01vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgTmdab25lLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERyYWdEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi8uLi9kaXJlY3RpdmVzL2RyYWcvZHJhZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRHJhZ1NlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuaW1wb3J0IHsgQWN0aW9uRGlyZWN0aW9uLCBEYXNoYm9hcmRTZXJ2aWNlIH0gZnJvbSAnLi4vZGFzaGJvYXJkLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50IH0gZnJvbSAnLi4vd2lkZ2V0L2Rhc2hib2FyZC13aWRnZXQuY29tcG9uZW50JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhEYXNoYm9hcmRXaWRnZXREcmFnSGFuZGxlXSwgW3V4LWRhc2hib2FyZC13aWRnZXQtZHJhZy1oYW5kbGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmREcmFnSGFuZGxlRGlyZWN0aXZlIGV4dGVuZHMgRHJhZ0RpcmVjdGl2ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgZGFzaGJvYXJkU2VydmljZTogRGFzaGJvYXJkU2VydmljZSwgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgbmdab25lOiBOZ1pvbmUsIHJlbmRlcmVyOiBSZW5kZXJlcjIsIGRyYWc6IERyYWdTZXJ2aWNlKSB7XG5cbiAgICAgICAgc3VwZXIoZWxlbWVudFJlZiwgbmdab25lLCByZW5kZXJlciwgZHJhZyk7XG5cbiAgICAgICAgdGhpcy5vbkRyYWdTdGFydC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IGRhc2hib2FyZFNlcnZpY2Uub25EcmFnU3RhcnQoeyB3aWRnZXQ6IHdpZGdldCwgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24uTW92ZSwgZXZlbnQ6IGV2ZW50IH0pKTtcblxuICAgICAgICB0aGlzLm9uRHJhZy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IGRhc2hib2FyZFNlcnZpY2Uub25EcmFnKHsgd2lkZ2V0OiB3aWRnZXQsIGRpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uLk1vdmUsIGV2ZW50OiBldmVudCB9KSk7XG5cbiAgICAgICAgdGhpcy5vbkRyYWdFbmQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gZGFzaGJvYXJkU2VydmljZS5vbkRyYWdFbmQoKSk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRGFzaGJvYXJkQ29tcG9uZW50IH0gZnJvbSAnLi9kYXNoYm9hcmQuY29tcG9uZW50JztcbmltcG9ydCB7IERhc2hib2FyZFdpZGdldENvbXBvbmVudCB9IGZyb20gJy4vd2lkZ2V0L2Rhc2hib2FyZC13aWRnZXQuY29tcG9uZW50JztcbmltcG9ydCB7IERhc2hib2FyZFNlcnZpY2UgfSBmcm9tICcuL2Rhc2hib2FyZC5zZXJ2aWNlJztcbmltcG9ydCB7IERhc2hib2FyZERyYWdIYW5kbGVEaXJlY3RpdmUgfSBmcm9tICcuL2RyYWctaGFuZGxlL2RyYWctaGFuZGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBEcmFnTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9kcmFnL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TOiBhbnlbXSA9IFtcbiAgICBEYXNoYm9hcmRDb21wb25lbnQsXG4gICAgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LFxuICAgIERhc2hib2FyZERyYWdIYW5kbGVEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJlc2l6ZU1vZHVsZSxcbiAgICAgICAgRHJhZ01vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TLFxuICAgIHByb3ZpZGVyczogW0Rhc2hib2FyZFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRNb2R1bGUgeyB9XG4iLCIvKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgZGltZW5zaW9uIGFycmF5IHRvIGEgZG91YmxlIGRpbWVuc2lvbiBhcnJheVxuICogQHBhcmFtIGl0ZW1zIHRoZSBzaW5nbGUgZGltZW5zaW9uIGFycmF5IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSBjb2x1bW5zIHRoZSBudW1iZXIgb2YgaXRlbXMgZWFjaCBhcnJheSBzaG91bGQgaGF2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JpZGlmeTxUPihpdGVtczogVFtdLCBjb2x1bW5zOiBudW1iZXIpOiBUW11bXSB7XG5cbiAgICAvLyBjcmVhdGUgYSBjb3B5IG9mIGFycmF5IHNvIG5vdCB0byBlZmZlY3QgdGhlIG9yaWdpbmFsXG4gICAgaXRlbXMgPSBpdGVtcy5zbGljZSgwKTtcblxuICAgIGNvbnN0IGdyaWQ6IFRbXVtdID0gW107XG5cbiAgICB3aGlsZSAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGdyaWQucHVzaChpdGVtcy5zcGxpY2UoMCwgY29sdW1ucykpO1xuICAgIH1cblxuICAgIHJldHVybiBncmlkO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBudW1iZXJzIGJldHdlZW4gdHdvIGxpbWl0c1xuICogQHBhcmFtIHN0YXJ0IHRoZSBsb3dlciBsaW1pdFxuICogQHBhcmFtIGVuZCB0aGUgdXBwZXIgbGltaXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGxpc3Q6IG51bWJlcltdID0gW107XG5cbiAgICBmb3IgKGxldCBpZHggPSBzdGFydDsgaWR4IDw9IGVuZDsgaWR4KyspIHtcbiAgICAgICAgbGlzdC5wdXNoKGlkeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIGRhdGVzIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHN0YXJ0IHRoZSBkYXRlIHRvIHN0YXJ0IHRoZSBhcnJheVxuICogQHBhcmFtIGVuZCB0aGUgZGF0ZSB0byBlbmQgdGhlIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlUmFuZ2Uoc3RhcnQ6IERhdGUsIGVuZDogRGF0ZSk6IERhdGVbXSB7XG5cbiAgICBsZXQgZGF0ZXM6IERhdGVbXSA9IFtdO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCB0aGUgZGF5cyBiZXR3ZWVuIHRoZSBkYXRlIHJhbmdlXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuXG4gICAgICAgIC8vIGFkZCB0aGUgZGF0ZSB0byB0aGUgYXJyYXlcbiAgICAgICAgZGF0ZXMucHVzaChuZXcgRGF0ZShzdGFydCkpO1xuXG4gICAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgZGF5XG4gICAgICAgIHN0YXJ0LnNldERhdGUoc3RhcnQuZ2V0RGF0ZSgpICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGVzO1xufVxuXG4vKipcbiAqIENvbXBhcmUgdHdvIGRhdGVzIHRvIHNlZSBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBkYXlcbiAqIEBwYXJhbSBkYXkxIHRoZSBmaXJzdCBkYXRlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBkYXkyIHRoZSBzZWNvbmQgZGF0ZSB0byBjb21wYXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlRGF5cyhkYXkxOiBEYXRlLCBkYXkyOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRheTEuZ2V0RGF0ZSgpID09PSBkYXkyLmdldERhdGUoKSAmJlxuICAgICAgICBkYXkxLmdldE1vbnRoKCkgPT09IGRheTIuZ2V0TW9udGgoKSAmJlxuICAgICAgICBkYXkxLmdldEZ1bGxZZWFyKCkgPT09IGRheTIuZ2V0RnVsbFllYXIoKTtcbn1cblxuLyoqXG4gKiBEYXRlIGNvbXBhcmlzb24gZm9yIHVzZSBwcmltYXJpbHkgd2l0aCBkaXN0aW5jdFVudGlsQ2hhbmdlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZUNvbXBhcmF0b3IoZGF0ZU9uZTogRGF0ZSwgZGF0ZVR3bzogRGF0ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkYXRlT25lLmdldFRpbWUoKSA9PT0gZGF0ZVR3by5nZXRUaW1lKCk7XG59XG5cbi8qKlxuICogVGltZXpvbmUgY29tcGFyaXNvbiBmb3IgdXNlIHByaW1hcmlseSB3aXRoIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lem9uZUNvbXBhcmF0b3Ioem9uZU9uZTogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSwgem9uZVR3bzogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB6b25lT25lLm5hbWUgPT09IHpvbmVUd28ubmFtZSAmJiB6b25lT25lLm9mZnNldCA9PT0gem9uZVR3by5vZmZzZXQ7XG59XG5cbi8qKlxuICogRXhwb3J0IGFuIGFycmF5IG9mIGFsbCB0aGUgYXZhaWxhYmxlIG1vbnRoc1xuICovXG5leHBvcnQgY29uc3QgbW9udGhzID0gWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ107XG5leHBvcnQgY29uc3QgbW9udGhzU2hvcnQgPSBtb250aHMubWFwKG1vbnRoID0+IG1vbnRoLnN1YnN0cmluZygwLCAzKSk7XG5cbi8qKlxuICogRXhwb3J0IGFuIGFycmF5IG9mIGFsbCB0aGUgYXZhaWxhYmxlIGRheXMgb2YgdGhlIHdlZWtcbiAqL1xuZXhwb3J0IGNvbnN0IHdlZWtkYXlzID0gWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddO1xuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSB3ZWVrZGF5cy5tYXAod2Vla2RheSA9PiB3ZWVrZGF5LnN1YnN0cmluZygwLCAzKSk7XG5cbi8qKiBFeHBvcnQgdGhlIGRlZmF1bHQgc2V0IG9mIHRpbWUgem9uZSAqL1xuZXhwb3J0IGNvbnN0IHRpbWV6b25lczogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdID0gW1xuICAgIHsgbmFtZTogJ0dNVC0xMScsIG9mZnNldDogNjYwIH0sXG4gICAgeyBuYW1lOiAnR01ULTEwJywgb2Zmc2V0OiA2MDAgfSxcbiAgICB7IG5hbWU6ICdHTVQtOScsIG9mZnNldDogNTQwIH0sXG4gICAgeyBuYW1lOiAnR01ULTgnLCBvZmZzZXQ6IDQ4MCB9LFxuICAgIHsgbmFtZTogJ0dNVC03Jywgb2Zmc2V0OiA0MjAgfSxcbiAgICB7IG5hbWU6ICdHTVQtNicsIG9mZnNldDogMzYwIH0sXG4gICAgeyBuYW1lOiAnR01ULTUnLCBvZmZzZXQ6IDMwMCB9LFxuICAgIHsgbmFtZTogJ0dNVC00Jywgb2Zmc2V0OiAyNDAgfSxcbiAgICB7IG5hbWU6ICdHTVQtMycsIG9mZnNldDogMTgwIH0sXG4gICAgeyBuYW1lOiAnR01ULTInLCBvZmZzZXQ6IDEyMCB9LFxuICAgIHsgbmFtZTogJ0dNVC0xJywgb2Zmc2V0OiA2MCB9LFxuICAgIHsgbmFtZTogJ0dNVCcsIG9mZnNldDogMCB9LFxuICAgIHsgbmFtZTogJ0dNVCsxJywgb2Zmc2V0OiAtNjAgfSxcbiAgICB7IG5hbWU6ICdHTVQrMicsIG9mZnNldDogLTEyMCB9LFxuICAgIHsgbmFtZTogJ0dNVCszJywgb2Zmc2V0OiAtMTgwIH0sXG4gICAgeyBuYW1lOiAnR01UKzQnLCBvZmZzZXQ6IC0yNDAgfSxcbiAgICB7IG5hbWU6ICdHTVQrNScsIG9mZnNldDogLTMwMCB9LFxuICAgIHsgbmFtZTogJ0dNVCs2Jywgb2Zmc2V0OiAtMzYwIH0sXG4gICAgeyBuYW1lOiAnR01UKzcnLCBvZmZzZXQ6IC00MjAgfSxcbiAgICB7IG5hbWU6ICdHTVQrOCcsIG9mZnNldDogLTQ4MCB9LFxuICAgIHsgbmFtZTogJ0dNVCs5Jywgb2Zmc2V0OiAtNTQwIH0sXG4gICAgeyBuYW1lOiAnR01UKzEwJywgb2Zmc2V0OiAtNjAwIH0sXG4gICAgeyBuYW1lOiAnR01UKzExJywgb2Zmc2V0OiAtNjYwIH0sXG4gICAgeyBuYW1lOiAnR01UKzEyJywgb2Zmc2V0OiAtNzIwIH1cbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG9mZnNldDogbnVtYmVyO1xufSIsIi8qKlxuICogQWRkIGEgY29uZmlnIHNlcnZpY2UgdG8gYWxsb3cgYW4gYXBwbGljYXRpb25cbiAqIHRvIGN1c3RvbWl6ZSB0aGUgZGF0ZSB0aW1lIHBpY2tlciBkZWZhdWx0IHNldHRpbmdzXG4gKiBhY3Jvc3MgdGhlIGVudGlyZSBhcHBsaWNhdGlvblxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHdlZWtkYXlzU2hvcnQsIHRpbWV6b25lcywgbW9udGhzLCBEYXRlVGltZVBpY2tlclRpbWV6b25lLCBtb250aHNTaG9ydCB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlckNvbmZpZyB7XG5cbiAgICBzaG93RGF0ZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1RpbWU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dUaW1lem9uZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1NlY29uZHM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG93TWVyaWRpYW46IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dTcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG4gICAgd2Vla2RheXM6IHN0cmluZ1tdID0gd2Vla2RheXNTaG9ydDtcbiAgICBub3dCdG5UZXh0OiBzdHJpbmcgPSAnVG9kYXknO1xuICAgIHRpbWV6b25lczogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdID0gdGltZXpvbmVzO1xuICAgIG1vbnRoczogc3RyaW5nW10gPSBtb250aHM7XG4gICAgbW9udGhzU2hvcnQ6IHN0cmluZ1tdID0gbW9udGhzU2hvcnQ7XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlckNvbmZpZyB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5jb25maWcnO1xuaW1wb3J0IHsgZGF0ZUNvbXBhcmF0b3IsIHdlZWtkYXlzU2hvcnQsIHRpbWV6b25lcywgRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSwgbW9udGhzLCBtb250aHNTaG9ydCB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlclNlcnZpY2Uge1xuXG4gICAgbW9kZSQ6IEJlaGF2aW9yU3ViamVjdDxEYXRlUGlja2VyTW9kZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGVQaWNrZXJNb2RlPihEYXRlUGlja2VyTW9kZS5EYXkpO1xuICAgIGRhdGUkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuICAgIHRpbWV6b25lJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4odGhpcy5nZXRDdXJyZW50VGltZXpvbmUoKSk7XG4gICAgc2VsZWN0ZWQkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuXG4gICAgLy8gdGhlIG1vbnRoIGFuZCB5ZWFyIHRvIGRpc3BsYXkgaW4gdGhlIHZpZXdwb3J0XG4gICAgbW9udGgkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldE1vbnRoKCkpO1xuICAgIHllYXIkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpO1xuXG4gICAgc2hvd0RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcgPyB0aGlzLl9jb25maWcuc2hvd0RhdGUgOiB0cnVlKTtcbiAgICBzaG93VGltZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZyA/IHRoaXMuX2NvbmZpZy5zaG93VGltZSA6IHRydWUpO1xuICAgIHNob3dUaW1lem9uZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZyA/IHRoaXMuX2NvbmZpZy5zaG93VGltZXpvbmUgOiB0cnVlKTtcbiAgICBzaG93U2Vjb25kcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZyA/IHRoaXMuX2NvbmZpZy5zaG93U2Vjb25kcyA6IGZhbHNlKTtcbiAgICBzaG93TWVyaWRpYW4kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcgPyB0aGlzLl9jb25maWcuc2hvd01lcmlkaWFuIDogdHJ1ZSk7XG4gICAgc2hvd1NwaW5uZXJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnID8gdGhpcy5fY29uZmlnLnNob3dTcGlubmVycyA6IHRydWUpO1xuICAgIHdlZWtkYXlzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nW10+KHRoaXMuX2NvbmZpZyA/IHRoaXMuX2NvbmZpZy53ZWVrZGF5cyA6IHdlZWtkYXlzU2hvcnQpO1xuICAgIG5vd0J0blRleHQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KHRoaXMuX2NvbmZpZyA/IHRoaXMuX2NvbmZpZy5ub3dCdG5UZXh0IDogJ1RvZGF5Jyk7XG4gICAgdGltZXpvbmVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdPih0aGlzLl9jb25maWcgPyB0aGlzLl9jb25maWcudGltZXpvbmVzIDogdGltZXpvbmVzKTtcblxuICAgIGhlYWRlciQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4obnVsbCk7XG4gICAgaGVhZGVyRXZlbnQkID0gbmV3IFN1YmplY3Q8RGF0ZVBpY2tlckhlYWRlckV2ZW50PigpO1xuICAgIG1vZGVEaXJlY3Rpb246IE1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLk5vbmU7XG5cbiAgICBtb250aHM6IHN0cmluZ1tdID0gdGhpcy5fY29uZmlnID8gdGhpcy5fY29uZmlnLm1vbnRocyA6IG1vbnRocztcbiAgICBtb250aHNTaG9ydDogc3RyaW5nW10gPSB0aGlzLl9jb25maWcgPyB0aGlzLl9jb25maWcubW9udGhzU2hvcnQgOiBtb250aHNTaG9ydDtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSBfY29uZmlnOiBEYXRlVGltZVBpY2tlckNvbmZpZykge1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGFjdGl2ZSBkYXRlIGNoYW5nZXMgc2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZVxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLnNlbGVjdGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKGRhdGVDb21wYXJhdG9yKSkuc3Vic2NyaWJlKGRhdGUgPT4ge1xuXG4gICAgICAgICAgICAvLyB0aGUgbW9udGggYW5kIHllYXIgZGlzcGxheWVkIGluIHRoZSB2aWV3cG9ydCBzaG91bGQgcmVmbGVjdCB0aGUgbmV3bHkgc2VsZWN0ZWQgaXRlbXNcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnRNb250aChkYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgbmV3IGRhdGUgdG8gdGhlIGNvbXBvbmVudCBob3N0XG4gICAgICAgICAgICB0aGlzLmRhdGUkLm5leHQoZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXRWaWV3cG9ydE1vbnRoKG1vbnRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKG1vbnRoIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5tb250aCQubmV4dCgxMSk7XG4gICAgICAgICAgICB0aGlzLnllYXIkLm5leHQodGhpcy55ZWFyJC52YWx1ZSAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQoMCk7XG4gICAgICAgICAgICB0aGlzLnllYXIkLm5leHQodGhpcy55ZWFyJC52YWx1ZSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb250aCQubmV4dChtb250aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRWaWV3cG9ydFllYXIoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMueWVhciQubmV4dCh5ZWFyKTtcbiAgICB9XG5cbiAgICBzZXREYXRlKGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuc2VsZWN0ZWQkLnZhbHVlKTtcblxuICAgICAgICBkYXRlLnNldERhdGUoZGF5KTtcbiAgICAgICAgZGF0ZS5zZXRNb250aChtb250aCk7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhcik7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZCQubmV4dChkYXRlKTtcbiAgICB9XG5cbiAgICBzZXREYXRlVG9Ob3coKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQobmV3IERhdGUoKSk7XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRNb2RlKG1vZGU6IERhdGVQaWNrZXJNb2RlKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW9kZSQubmV4dChtb2RlKTtcbiAgICB9XG5cbiAgICBnb1RvQ2hpbGRNb2RlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLkRlc2NlbmQ7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUkLnZhbHVlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuTW9udGgpO1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0TW9kZShEYXRlUGlja2VyTW9kZS5EYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub1BhcmVudE1vZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW9kZURpcmVjdGlvbiA9IE1vZGVEaXJlY3Rpb24uQXNjZW5kO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlJC52YWx1ZSkge1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuTW9udGgpO1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0TW9kZShEYXRlUGlja2VyTW9kZS5ZZWFyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9OZXh0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYWRlckV2ZW50JC5uZXh0KERhdGVQaWNrZXJIZWFkZXJFdmVudC5OZXh0KTtcbiAgICB9XG5cbiAgICBnb1RvUHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGVhZGVyRXZlbnQkLm5leHQoRGF0ZVBpY2tlckhlYWRlckV2ZW50LlByZXZpb3VzKTtcbiAgICB9XG5cbiAgICBzZXRIZWFkZXIoaGVhZGVyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oZWFkZXIkLm5leHQoaGVhZGVyKTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50VGltZXpvbmUoKTogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgY29uc3Qgem9uZXMgPSB0aGlzLl9jb25maWcgPyB0aGlzLl9jb25maWcudGltZXpvbmVzIDogdGltZXpvbmVzO1xuICAgICAgICByZXR1cm4gem9uZXMuZmluZCh0aW1lem9uZSA9PiB0aW1lem9uZS5vZmZzZXQgPT09IG9mZnNldCk7XG4gICAgfVxuXG4gICAgc2V0VGltZXpvbmUodGltZXpvbmU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aW1lem9uZSQubmV4dCh0aW1lem9uZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBEYXRlUGlja2VyTW9kZSB7XG4gICAgRGF5LFxuICAgIE1vbnRoLFxuICAgIFllYXJcbn1cblxuZXhwb3J0IGVudW0gTW9kZURpcmVjdGlvbiB7XG4gICAgTm9uZSxcbiAgICBBc2NlbmQsXG4gICAgRGVzY2VuZFxufVxuXG5leHBvcnQgZW51bSBEYXRlUGlja2VySGVhZGVyRXZlbnQge1xuICAgIFByZXZpb3VzLFxuICAgIE5leHRcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRGF0ZVBpY2tlck1vZGUsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IGRhdGVDb21wYXJhdG9yLCBEYXRlVGltZVBpY2tlclRpbWV6b25lLCB0aW1lem9uZUNvbXBhcmF0b3IgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIudXRpbHMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGUtdGltZS1waWNrZXIuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtEYXRlVGltZVBpY2tlclNlcnZpY2VdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KCkgc2V0IHNob3dEYXRlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnNob3dEYXRlJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93VGltZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93VGltZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2hvd1RpbWV6b25lKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnNob3dUaW1lem9uZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2hvd1NlY29uZHModmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1NlY29uZHMkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dNZXJpZGlhbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93TWVyaWRpYW4kLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dTcGlubmVycyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93U3Bpbm5lcnMkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHdlZWtkYXlzKHZhbHVlOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuZGF0ZXBpY2tlci53ZWVrZGF5cyQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbW9udGhzKG1vbnRoczogc3RyaW5nW10pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIubW9udGhzID0gbW9udGhzO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IG1vbnRoc1Nob3J0KG1vbnRoczogc3RyaW5nW10pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIubW9udGhzU2hvcnQgPSBtb250aHM7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbm93QnRuVGV4dCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLm5vd0J0blRleHQkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHRpbWV6b25lcyh2YWx1ZTogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lcyQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBAT3V0cHV0KCkgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuICBAT3V0cHV0KCkgdGltZXpvbmVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRlVGltZVBpY2tlclRpbWV6b25lPiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4oKTtcblxuICBASW5wdXQoKVxuICBzZXQgZGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGlmICghZGF0ZUNvbXBhcmF0b3IodmFsdWUsIHRoaXMuZGF0ZXBpY2tlci5zZWxlY3RlZCQudmFsdWUpKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXIuc2VsZWN0ZWQkLm5leHQobmV3IERhdGUodmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgdGltZXpvbmUodmFsdWU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgLy8gZXhwb3NlIGVudW0gdG8gdmlld1xuICBEYXRlUGlja2VyTW9kZSA9IERhdGVQaWNrZXJNb2RlO1xuXG4gIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGRhdGVwaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSkge1xuICAgIGRhdGVwaWNrZXIuc2VsZWN0ZWQkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGRhdGVDb21wYXJhdG9yKSlcbiAgICAgIC5zdWJzY3JpYmUoZGF0ZSA9PiB0aGlzLmRhdGVDaGFuZ2UuZW1pdChkYXRlKSk7XG5cbiAgICBkYXRlcGlja2VyLnRpbWV6b25lJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCh0aW1lem9uZUNvbXBhcmF0b3IpKVxuICAgICAgLnN1YnNjcmliZSgodGltZXpvbmU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpID0+IHRoaXMudGltZXpvbmVDaGFuZ2UuZW1pdCh0aW1lem9uZSkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGRhdGUgdG8gdGhlIGN1cnJlbnQgZGF0ZSBhbmQgdGltZVxuICAgKi9cbiAgc2V0VG9Ob3coKTogdm9pZCB7XG5cbiAgICAvLyBzZXQgdGhlIGRhdGUgdG8gdGhlIGN1cnJlbnQgbW9tZW50XG4gICAgdGhpcy5kYXRlcGlja2VyLnNldERhdGVUb05vdygpO1xuICB9XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgU1BJTl9CVVRUT05fVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTcGluQnV0dG9uQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zcGluLWJ1dHRvbicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NwaW4tYnV0dG9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1NQSU5fQlVUVE9OX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBTcGluQnV0dG9uQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgQElucHV0KCkgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KCkgdHlwZTogc3RyaW5nID0gJ3RleHQnO1xuICAgIEBJbnB1dCgpIG1pbjogbnVtYmVyO1xuICAgIEBJbnB1dCgpIG1heDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIHBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnJztcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNwaW5uZXJzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSByZWFkT25seTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2Nyb2xsaW5nOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBhcnJvd2tleXM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KCkgaW5jcmVtZW50QXJpYUxhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaW5wdXRBcmlhTGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSBkZWNyZW1lbnRBcmlhTGFiZWw6IHN0cmluZztcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgQE91dHB1dCgpIGluY3JlbWVudCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgZGVjcmVtZW50ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnk7XG5cbiAgICBzY3JvbGwoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVsdGFZID4gMCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRGVjcmVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJJbmNyZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdHJpZ2dlckluY3JlbWVudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmlnZ2VyRGVjcmVtZW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50LmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTcGluQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9zcGluLWJ1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1NwaW5CdXR0b25Db21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NwaW5CdXR0b25Db21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFNwaW5CdXR0b25Nb2R1bGUgeyB9IiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ3RpbWVGb3JtYXQnXG59KVxuZXhwb3J0IGNsYXNzIFRpbWVGb3JtYXRQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgdHJhbnNmb3JtKHZhbHVlOiBudW1iZXIsIHBhZDogYm9vbGVhbik6IHN0cmluZyB8IG51bWJlciB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDEwICYmIHBhZCA/ICcwJyArIHZhbHVlIDogdmFsdWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5cbmV4cG9ydCBjb25zdCBUSU1FX1BJQ0tFUl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRpbWVQaWNrZXJDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRpbWUtcGlja2VyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGltZS1waWNrZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbVElNRV9QSUNLRVJfVkFMVUVfQUNDRVNTT1JdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2FyaWEtbGFiZWwnOiAnVGltZSBQaWNrZXInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBUaW1lUGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBhcnJvd2tleXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIG1vdXNld2hlZWw6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgcmVhZE9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpIHNob3dNZXJpZGlhbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNob3dIb3VyczogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2hvd01pbnV0ZXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNob3dTZWNvbmRzOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgc2hvd1NwaW5uZXJzOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIEBJbnB1dCgpIGhvdXJTdGVwOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIG1pbnV0ZVN0ZXA6IG51bWJlciA9IDE7XG4gICAgQElucHV0KCkgc2Vjb25kU3RlcDogbnVtYmVyID0gMTtcblxuICAgIEBJbnB1dCgpIG1pbjogRGF0ZTtcbiAgICBASW5wdXQoKSBtYXg6IERhdGU7XG4gICAgQElucHV0KCkgbWVyaWRpYW5zOiBzdHJpbmdbXSA9IFsnQU0nLCAnUE0nXTtcblxuICAgIEBJbnB1dCgpIHNldCB2YWx1ZSh2YWx1ZTogRGF0ZSkge1xuICAgICAgICB0aGlzLnZhbHVlJC5uZXh0KG5ldyBEYXRlKHZhbHVlKSk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlJC52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMudmFsdWUkLnZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWUkLnZhbHVlKTtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG4gICAgQE91dHB1dCgpIGlzVmFsaWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogRGF0ZSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHZhbHVlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZT4obmV3IERhdGUoKSk7XG5cbiAgICAvLyBjcmVhdGUgb2JzZXJ2YWJsZXMgdGhhdCBhcmUgZGVyaXZlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVcbiAgICBob3VyJDogT2JzZXJ2YWJsZTxudW1iZXI+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldEhvdXJzKCkpLCBtYXAoaG91ciA9PiB0aGlzLnNob3dNZXJpZGlhbiA/IHRoaXMuZ2V0TWVyaWRpYW5UaW1lKGhvdXIpIDogaG91cikpO1xuICAgIG1pbnV0ZSQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMudmFsdWUkLnBpcGUobWFwKGRhdGUgPT4gZGF0ZS5nZXRNaW51dGVzKCkpKTtcbiAgICBzZWNvbmQkOiBPYnNlcnZhYmxlPG51bWJlcj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IGRhdGUuZ2V0U2Vjb25kcygpKSk7XG4gICAgbWVyaWRpYW4kOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IGRhdGUuZ2V0SG91cnMoKSA8IDEyID8gdGhpcy5tZXJpZGlhbnNbMF0gOiB0aGlzLm1lcmlkaWFuc1sxXSkpO1xuICAgIHZhbGlkJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IHRoaXMudmFsdWUkLnBpcGUobWFwKGRhdGUgPT4gdGhpcy5jaGVja1ZhbGlkaXR5KGRhdGUpKSk7XG5cbiAgICBwcml2YXRlIF9tZXJpZGlhbjogc3RyaW5nID0gdGhpcy5tZXJpZGlhbnNbMF07XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy52YWxpZCQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUodmFsaWQgPT4gdGhpcy5pc1ZhbGlkLmVtaXQodmFsaWQpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogRGF0ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IERhdGUpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG5cbiAgICBnZXRNZXJpZGlhblRpbWUoaG91cjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGhvdXIgPiAxMiA/IGhvdXIgLSAxMiA6IGhvdXI7XG4gICAgfVxuXG4gICAgc2V0SG91cihob3VyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoaG91ciA/IGhvdXIgOiAwKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICB9XG5cbiAgICBzZXRNaW51dGUobWludXRlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhtaW51dGUgPyBtaW51dGUgOiAwKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICB9XG5cbiAgICBzZXRTZWNvbmRzKHNlY29uZHM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKHNlY29uZHMgPyBzZWNvbmRzIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50SG91cihhcnJvd2tleTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGFycm93a2V5ICYmICF0aGlzLmFycm93a2V5cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRIb3VyKHRoaXMudmFsdWUuZ2V0SG91cnMoKSArIHRoaXMuaG91clN0ZXApO1xuICAgIH1cblxuICAgIGRlY3JlbWVudEhvdXIoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0SG91cih0aGlzLnZhbHVlLmdldEhvdXJzKCkgLSB0aGlzLmhvdXJTdGVwKTtcbiAgICB9XG5cbiAgICBpbmNyZW1lbnRNaW51dGUoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TWludXRlKHRoaXMudmFsdWUuZ2V0TWludXRlcygpICsgdGhpcy5taW51dGVTdGVwKTtcbiAgICB9XG5cbiAgICBkZWNyZW1lbnRNaW51dGUoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TWludXRlKHRoaXMudmFsdWUuZ2V0TWludXRlcygpIC0gdGhpcy5taW51dGVTdGVwKTtcbiAgICB9XG5cbiAgICBpbmNyZW1lbnRTZWNvbmQoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U2Vjb25kcyh0aGlzLnZhbHVlLmdldFNlY29uZHMoKSArIHRoaXMuc2Vjb25kU3RlcCk7XG4gICAgfVxuXG4gICAgZGVjcmVtZW50U2Vjb25kKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFNlY29uZHModGhpcy52YWx1ZS5nZXRTZWNvbmRzKCkgLSB0aGlzLnNlY29uZFN0ZXApO1xuICAgIH1cblxuICAgIHNlbGVjdE1lcmlkaWFuKG1lcmlkaWFuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWVyaWRpYW4gPSBtZXJpZGlhbjtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICBjb25zdCBob3VyID0gdGhpcy52YWx1ZS5nZXRIb3VycygpO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc2VsZWN0ZWQgQU1cbiAgICAgICAgaWYgKG1lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1swXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPj0gMTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhvdXIoaG91ciAtIDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc2VsZWN0ZWQgUE1cbiAgICAgICAgaWYgKG1lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1sxXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SG91cihob3VyICsgMTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tWYWxpZGl0eShkYXRlOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWluICYmIGRhdGUuZ2V0VGltZSgpIDw9IHRoaXMubWluLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBkYXRlLmdldFRpbWUoKSA+PSB0aGlzLm1heC5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuXG4gICAgaG91ckNoYW5nZSh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG5cbiAgICAgICAgLy8gY29udmVydCB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyXG4gICAgICAgIGxldCBob3VyID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICBsZXQgY3VycmVudEhvdXIgPSB0aGlzLnZhbHVlLmdldEhvdXJzKCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChob3VyID09PSBjdXJyZW50SG91cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBob3VycyBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzTmFOKGhvdXIpKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDApIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhvdXIgPiAodGhpcy5zaG93TWVyaWRpYW4gPyAxMiA6IDIzKSkge1xuICAgICAgICAgICAgICAgIGhvdXIgPSB0aGlzLnNob3dNZXJpZGlhbiA/IDEyIDogMjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBob3VyID0gaXNOYU4oaG91cikgPyBjdXJyZW50SG91ciA6IGhvdXI7XG5cbiAgICAgICAgLy8gaWYgdGhlIG51bWJlciBpcyBpbnZhbGlkIHRoZW4gcmVzdG9yZSBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgaWYgKHRoaXMuX21lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1swXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPj0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyIC09IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBzZWxlY3RlZCBQTVxuICAgICAgICBpZiAodGhpcy5fbWVyaWRpYW4gPT09IHRoaXMubWVyaWRpYW5zWzFdKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0SG91cihob3VyKTtcbiAgICB9XG5cbiAgICBtaW51dGVDaGFuZ2UodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlclxuICAgICAgICBsZXQgbWludXRlID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICBsZXQgY3VycmVudE1pbnV0ZSA9IHRoaXMudmFsdWUuZ2V0TWludXRlcygpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgZG8gbm90aGluZ1xuICAgICAgICBpZiAobWludXRlID09PSBjdXJyZW50TWludXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGhvdXJzIGlzIHZhbGlkXG4gICAgICAgIGlmICghaXNOYU4obWludXRlKSkge1xuICAgICAgICAgICAgaWYgKG1pbnV0ZSA8IDApIHtcbiAgICAgICAgICAgICAgICBtaW51dGUgPSA1OTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbnV0ZSA+IDU5KSB7XG4gICAgICAgICAgICAgICAgbWludXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgaW52YWxpZCB0aGVuIHJlc3RvcmUgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0TWludXRlKGlzTmFOKG1pbnV0ZSkgPyBjdXJyZW50TWludXRlIDogbWludXRlKTtcbiAgICB9XG5cbiAgICBzZWNvbmRDaGFuZ2UodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXJcbiAgICAgICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRTZWNvbmQgPSB0aGlzLnZhbHVlLmdldFNlY29uZHMoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHNlY29uZCA9PT0gY3VycmVudFNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBob3VycyBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzTmFOKHNlY29uZCkpIHtcbiAgICAgICAgICAgIGlmIChzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlY29uZCA+IDU5KSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gNTk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQgdGhlbiByZXN0b3JlIGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICB0aGlzLnNldFNlY29uZHMoaXNOYU4oc2Vjb25kKSA/IGN1cnJlbnRTZWNvbmQgOiBzZWNvbmQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3BpbkJ1dHRvbk1vZHVsZSB9IGZyb20gJy4uL3NwaW4tYnV0dG9uL2luZGV4JztcbmltcG9ydCB7IFRpbWVGb3JtYXRQaXBlIH0gZnJvbSAnLi90aW1lLWZvcm1hdC5waXBlJztcbmltcG9ydCB7IFRpbWVQaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL3RpbWUtcGlja2VyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBTcGluQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVGltZVBpY2tlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbVGltZVBpY2tlckNvbXBvbmVudCwgVGltZUZvcm1hdFBpcGVdLFxufSlcbmV4cG9ydCBjbGFzcyBUaW1lUGlja2VyTW9kdWxlIHsgfSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyU2VydmljZSwgTW9kZURpcmVjdGlvbiB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBjb21wYXJlRGF5cywgZGF0ZVJhbmdlLCBncmlkaWZ5IH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXlWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF5Vmlld0l0ZW1bXVtdPihbW11dKTtcbiAgICBmb2N1c2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Rm9jdXNlZERheUl0ZW0+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gY29tYmluZUxhdGVzdChfZGF0ZXBpY2tlci5tb250aCQsIF9kYXRlcGlja2VyLnllYXIkKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoW21vbnRoLCB5ZWFyXSkgPT4gdGhpcy5jcmVhdGVEYXlHcmlkKG1vbnRoLCB5ZWFyKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEZvY3VzKGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkJC5uZXh0KHsgZGF5OiBkYXksIG1vbnRoOiBtb250aCwgeWVhcjogeWVhciB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGRhdGUgcGlja2VyIHRvIHNob3cgdGhlIHJlcXVpcmVkIG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHllYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlRGF5R3JpZChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlclxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldEhlYWRlcih0aGlzLl9kYXRlcGlja2VyLm1vbnRoc1ttb250aF0gKyAnICcgKyB5ZWFyKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmRhcmllc1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAwKTtcblxuICAgICAgICAvLyB3ZSBhbHdheXMgd2FudCB0byBzaG93IGZyb20gdGhlIHN1bmRheSAtIHRoaXMgbWF5IGluY2x1ZGUgc2hvd2luZyBzb21lIGRhdGVzIGZyb20gdGhlIHByZXZpb3VzIG1vbnRoXG4gICAgICAgIHN0YXJ0LnNldERhdGUoc3RhcnQuZ2V0RGF0ZSgpIC0gc3RhcnQuZ2V0RGF5KCkpO1xuXG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcmFuZ2UgZW5kcyBvbiBhIHNhdHVyZGF5XG4gICAgICAgIGVuZC5zZXREYXRlKGVuZC5nZXREYXRlKCkgKyAoNiAtIGVuZC5nZXREYXkoKSkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhbGwgdGhlIGRheXMgdG8gZGlzcGxheVxuICAgICAgICBjb25zdCBkYXRlczogRGF5Vmlld0l0ZW1bXSA9IGRhdGVSYW5nZShzdGFydCwgZW5kKS5tYXAoZGF0ZSA9PiAoe1xuICAgICAgICAgICAgZGF5OiBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIG1vbnRoOiBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgaXNUb2RheTogdGhpcy5pc1RvZGF5KGRhdGUpLFxuICAgICAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNBY3RpdmUoZGF0ZSksXG4gICAgICAgICAgICBpc0N1cnJlbnRNb250aDogZGF0ZS5nZXRNb250aCgpID09PSBtb250aFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gdHVybiB0aGUgZGF0ZXMgaW50byBhIGdyaWRcbiAgICAgICAgY29uc3QgaXRlbXM6IERheVZpZXdJdGVtW11bXSA9IGdyaWRpZnkoZGF0ZXMsIDcpO1xuXG4gICAgICAgIHRoaXMuZ3JpZCQubmV4dChpdGVtcyk7XG5cbiAgICAgICAgLy8gaWYgbm8gaXRlbSBoYXMgeWV0IGJlZW4gZm9jdXNlZCB0aGVuIGZvY3VzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgIGlmICgodGhpcy5fZGF0ZXBpY2tlci5tb2RlRGlyZWN0aW9uID09PSBNb2RlRGlyZWN0aW9uLk5vbmUgfHwgdGhpcy5fZGF0ZXBpY2tlci5tb2RlRGlyZWN0aW9uID09PSBNb2RlRGlyZWN0aW9uLkRlc2NlbmQpICYmIHRoaXMuZm9jdXNlZCQudmFsdWUgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNlbGVjdGVkIGl0ZW0gaXMgdmlzaWJsZVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWREYXkgPSBkYXRlcy5maW5kKGRheSA9PiBkYXkuaXNDdXJyZW50TW9udGggJiYgZGF5LmlzQWN0aXZlKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb2N1cyhzZWxlY3RlZERheS5kYXksIHNlbGVjdGVkRGF5Lm1vbnRoLCBzZWxlY3RlZERheS55ZWFyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRlcy5maW5kKGRhdGUgPT4gZGF0ZS5kYXkgPT09IDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9jdXMgdGhlIGRhdGVcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvY3VzKGZpcnN0LmRheSwgZmlyc3QubW9udGgsIGZpcnN0LnllYXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgc3BlY2lmaWMgZGF0ZSBpcyB0b2RheVxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBjaGVja1xuICAgKi9cbiAgICBwcml2YXRlIGlzVG9kYXkoZGF0ZTogRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gY29tcGFyZURheXMobmV3IERhdGUoKSwgZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBhIHNwZWNpZmljIGRhdGUgaXMgdGhlIHNlbGVjdGVkIG9uZVxuICAgICAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGNoZWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0FjdGl2ZShkYXRlOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBjb21wYXJlRGF5cyh0aGlzLl9kYXRlcGlja2VyLnNlbGVjdGVkJC52YWx1ZSwgZGF0ZSk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheVZpZXdJdGVtIHtcbiAgICBkYXk6IG51bWJlcjtcbiAgICBtb250aDogbnVtYmVyO1xuICAgIHllYXI6IG51bWJlcjtcbiAgICBkYXRlOiBEYXRlO1xuICAgIGlzVG9kYXk6IGJvb2xlYW47XG4gICAgaXNBY3RpdmU6IGJvb2xlYW47XG4gICAgaXNDdXJyZW50TW9udGg6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9jdXNlZERheUl0ZW0ge1xuICAgIGRheTogbnVtYmVyO1xuICAgIG1vbnRoOiBudW1iZXI7XG4gICAgeWVhcjogbnVtYmVyO1xufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRGF0ZVBpY2tlckhlYWRlckV2ZW50LCBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF5Vmlld0l0ZW0sIERheVZpZXdTZXJ2aWNlIH0gZnJvbSAnLi9kYXktdmlldy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci1kYXktdmlldycsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXktdmlldy5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW0RheVZpZXdTZXJ2aWNlXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGF5Vmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IocHVibGljIGRhdGVQaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSwgcHVibGljIGRheVNlcnZpY2U6IERheVZpZXdTZXJ2aWNlKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gZGF0ZVBpY2tlci5oZWFkZXJFdmVudCRcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4gZXZlbnQgPT09IERhdGVQaWNrZXJIZWFkZXJFdmVudC5OZXh0ID8gdGhpcy5uZXh0KCkgOiB0aGlzLnByZXZpb3VzKCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHBhZ2Ugb2YgZGF0ZXNcbiAgICovXG4gIHByZXZpb3VzKCk6IHZvaWQge1xuICAgIHRoaXMuZGF0ZVBpY2tlci5zZXRWaWV3cG9ydE1vbnRoKHRoaXMuZGF0ZVBpY2tlci5tb250aCQudmFsdWUgLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgbmV4dCBwYWdlIG9mIGRhdGVzXG4gICAqL1xuICBuZXh0KCk6IHZvaWQge1xuICAgIHRoaXMuZGF0ZVBpY2tlci5zZXRWaWV3cG9ydE1vbnRoKHRoaXMuZGF0ZVBpY2tlci5tb250aCQudmFsdWUgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBwYXJ0aWN1bGFyIGRhdGVcbiAgICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gc2VsZWN0XG4gICAqL1xuICBzZWxlY3QoZGF0ZTogRGF0ZSk6IHZvaWQge1xuICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBkYXRlIG9iamVjdFxuICAgIHRoaXMuZGF0ZVBpY2tlci5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RnVsbFllYXIoKSk7XG5cbiAgICAvLyBmb2N1cyB0aGUgbmV3bHkgc2VsZWN0ZWQgZGF0ZVxuICAgIHRoaXMuZGF5U2VydmljZS5zZXRGb2N1cyhkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICB9XG5cbiAgdHJhY2tXZWVrQnlGbihpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICB0cmFja0RheUJ5Rm4oX2luZGV4OiBudW1iZXIsIGl0ZW06IERheVZpZXdJdGVtKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7IGl0ZW0uZGF5IH0gJHsgaXRlbS5tb250aCB9ICR7IGl0ZW0ueWVhciB9YDtcbiAgfVxuXG4gIGZvY3VzRGF0ZShpdGVtOiBEYXlWaWV3SXRlbSwgZGF5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSB0aGUgZGF0ZSBvZiB0aGUgZGF5XG4gICAgY29uc3QgdGFyZ2V0ID0gbmV3IERhdGUoaXRlbS5kYXRlLnNldERhdGUoaXRlbS5kYXRlLmdldERhdGUoKSArIGRheU9mZnNldCkpO1xuXG4gICAgLy8gaWRlbnRpZnkgd2hpY2ggZGF0ZSBzaG91bGQgYmUgZm9jdXNlZFxuICAgIHRoaXMuZGF5U2VydmljZS5zZXRGb2N1cyh0YXJnZXQuZ2V0RGF0ZSgpLCB0YXJnZXQuZ2V0TW9udGgoKSwgdGFyZ2V0LmdldEZ1bGxZZWFyKCkpO1xuICB9XG5cbiAgZ2V0VGFiYmFibGUoaXRlbTogRGF5Vmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5kYXlTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLmRheVNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIGZvY3VzZWQgbW9udGggY2hlY2sgaWYgdGhpcyBpcyBpdFxuICAgIGlmIChmb2N1c2VkKSB7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBmb2N1c2VkIGRheSBpcyB2aXNpYmxlXG4gICAgICBjb25zdCBpc0ZvY3VzZWREYXlWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0uZGF5ID09PSBmb2N1c2VkLmRheSAmJiBfaXRlbS5tb250aCA9PT0gZm9jdXNlZC5tb250aCAmJiBfaXRlbS55ZWFyID09PSBmb2N1c2VkLnllYXIpKTtcblxuICAgICAgaWYgKGlzRm9jdXNlZERheVZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZvY3VzZWQuZGF5ID09PSBpdGVtLmRheSAmJiBmb2N1c2VkLm1vbnRoID09PSBpdGVtLm1vbnRoICYmIGZvY3VzZWQueWVhciA9PT0gaXRlbS55ZWFyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSBkYXkgdGhlbiBjaGVjayBpZiB0aGVyZSBpcyBhIHNlbGVjdGVkIGRheVxuICAgIGNvbnN0IGlzU2VsZWN0ZWREYXlWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoZGF5ID0+IGRheS5pc0FjdGl2ZSkpO1xuXG4gICAgaWYgKGlzU2VsZWN0ZWREYXlWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlzQWN0aXZlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBkYXkgdGFiYmFibGVcbiAgICByZXR1cm4gaXRlbS5kYXkgPT09IDE7XG4gIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGF0ZVBpY2tlck1vZGUsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci1oZWFkZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9oZWFkZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIEhlYWRlckNvbXBvbmVudCB7XG5cbiAgICBjYW5Bc2NlbmQkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5kYXRlcGlja2VyLm1vZGUkLnBpcGUobWFwKG1vZGUgPT4gbW9kZSAhPT0gRGF0ZVBpY2tlck1vZGUuWWVhcikpO1xuICAgIFxuICAgIG1vZGUkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdEYXknO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01vbnRoJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1llYXInO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgaGVhZGVyQXJpYSQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1N3aXRjaCB0byBzaG93IG1vbnRocyBpbiB0aGUgeWVhcic7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiAnU3dpdGNoIHRvIHNob3cgeWVhcnMgaW4gdGhlIGRlY2FkZSc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgcHJldmlvdXNBcmlhJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5kYXRlcGlja2VyLm1vZGUkLnBpcGUobWFwKG1vZGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuRGF5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnUHJldmlvdXMgbW9udGgnO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1ByZXZpb3VzIHllYXInO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5ZZWFyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnUHJldmlvdXMgZGVjYWRlJztcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIG5leHRBcmlhJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5kYXRlcGlja2VyLm1vZGUkLnBpcGUobWFwKG1vZGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuRGF5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnTmV4dCBtb250aCc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiAnTmV4dCB5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05leHQgZGVjYWRlJztcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHsgfVxuXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlci5nb1RvUHJldmlvdXMoKTtcbiAgICB9XG5cbiAgICBhc2NlbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlci5nb1RvUGFyZW50TW9kZSgpO1xuICAgIH1cblxuICAgIG5leHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlci5nb1RvTmV4dCgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyU2VydmljZSwgTW9kZURpcmVjdGlvbiB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBncmlkaWZ5LCByYW5nZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIudXRpbHMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTW9udGhWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TW9udGhWaWV3SXRlbVtdW10+KFtbXV0pO1xuICAgIGZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxGb2N1c2VkTW9udGhJdGVtPihudWxsKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9kYXRlcGlja2VyLnllYXIkLnN1YnNjcmliZSh5ZWFyID0+IHRoaXMuY3JlYXRlTW9udGhHcmlkKHllYXIpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMobW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCQubmV4dCh7IG1vbnRoOiBtb250aCwgeWVhcjogeWVhciB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZpZXdwb3J0IHRvIGVuc3VyZSBmb2N1c2VkIG1vbnRoIGlzIHZpc2libGVcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRWaWV3cG9ydFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVNb250aEdyaWQoeWVhcjogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWFkZXJcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRIZWFkZXIoeWVhci50b1N0cmluZygpKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgeWVhciBhbmQgbW9udGhcbiAgICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBtb250aFxuICAgICAgICBjb25zdCBhY3RpdmVNb250aCA9IHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVllYXIgPSB0aGlzLl9kYXRlcGlja2VyLnNlbGVjdGVkJC52YWx1ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIDR4MyBncmlkIG9mIG1vbnRoIG51bWJlcnNcbiAgICAgICAgY29uc3QgbW9udGhzOiBNb250aFZpZXdJdGVtW10gPSByYW5nZSgwLCAxMSkubWFwKG1vbnRoID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fZGF0ZXBpY2tlci5tb250aHNTaG9ydFttb250aF0sXG4gICAgICAgICAgICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IHllYXIgPT09IGN1cnJlbnRZZWFyICYmIG1vbnRoID09PSBjdXJyZW50TW9udGgsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmVNb250aDogeWVhciA9PT0gYWN0aXZlWWVhciAmJiBtb250aCA9PT0gYWN0aXZlTW9udGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1hcCB0aGVzZSB0byB0aGUgYXBwcm9wcmlhdGUgZm9ybWF0XG4gICAgICAgIGNvbnN0IGl0ZW1zOiBNb250aFZpZXdJdGVtW11bXSA9IGdyaWRpZnkobW9udGhzLCA0KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkJC5uZXh0KGl0ZW1zKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmb2N1c2VkIG1vbnRoIHNlbGVjdCB0aGUgZmlyc3Qgb25lXG4gICAgICAgIGlmICh0aGlzLl9kYXRlcGlja2VyLm1vZGVEaXJlY3Rpb24gPT09IE1vZGVEaXJlY3Rpb24uRGVzY2VuZCAmJiB0aGlzLmZvY3VzZWQkLnZhbHVlID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWxlY3RlZCBtb250aCBpcyBpbiB2aWV3XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE1vbnRoID0gbW9udGhzLmZpbmQobW9udGggPT4gbW9udGguaXNBY3RpdmVNb250aCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoc2VsZWN0ZWRNb250aCA/IHNlbGVjdGVkTW9udGgubW9udGggOiAwLCB5ZWFyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb250aFZpZXdJdGVtIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG4gICAgaXNDdXJyZW50TW9udGg6IGJvb2xlYW47XG4gICAgaXNBY3RpdmVNb250aDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb2N1c2VkTW9udGhJdGVtIHtcbiAgICBtb250aDogbnVtYmVyO1xuICAgIHllYXI6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IERhdGVQaWNrZXJIZWFkZXJFdmVudCwgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IE1vbnRoVmlld0l0ZW0sIE1vbnRoVmlld1NlcnZpY2UgfSBmcm9tICcuL21vbnRoLXZpZXcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci1tb250aC12aWV3JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbW9udGgtdmlldy5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbTW9udGhWaWV3U2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTW9udGhWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZVBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBwdWJsaWMgbW9udGhTZXJ2aWNlOiBNb250aFZpZXdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9kYXRlUGlja2VyLmhlYWRlckV2ZW50JFxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiBldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLm5leHQoKSA6IHRoaXMucHJldmlvdXMoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdvIHRvIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHRoaXMuX2RhdGVQaWNrZXIueWVhciQudmFsdWUgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHbyB0byB0aGUgbmV4dCB5ZWFyXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydFllYXIodGhpcy5fZGF0ZVBpY2tlci55ZWFyJC52YWx1ZSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIG1vbnRoIGluIHRoZSBjYWxlbmRhclxuICAgICAqIEBwYXJhbSBtb250aCB0aGUgaW5kZXggb2YgdGhlIG1vbnRoIHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgZGF5IHBpY2tlclxuICAgICAgICB0aGlzLl9kYXRlUGlja2VyLmdvVG9DaGlsZE1vZGUoKTtcbiAgICB9XG5cbiAgICBmb2N1c01vbnRoKGl0ZW06IE1vbnRoVmlld0l0ZW0sIG1vbnRoT2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRhcmdldE1vbnRoID0gaXRlbS5tb250aCArIG1vbnRoT2Zmc2V0O1xuICAgICAgICBsZXQgdGFyZ2V0WWVhciA9IGl0ZW0ueWVhcjtcblxuICAgICAgICBpZiAodGFyZ2V0TW9udGggPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRNb250aCArPSAxMjtcbiAgICAgICAgICAgIHRhcmdldFllYXIgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRNb250aCA+PSAxMikge1xuICAgICAgICAgICAgdGFyZ2V0TW9udGggLT0gMTI7XG4gICAgICAgICAgICB0YXJnZXRZZWFyICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vbnRoU2VydmljZS5zZXRGb2N1cyh0YXJnZXRNb250aCwgdGFyZ2V0WWVhcik7XG4gICAgfVxuXG4gICAgdHJhY2tSb3dCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgdHJhY2tNb250aEJ5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogTW9udGhWaWV3SXRlbSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtpdGVtLm1vbnRofSAke2l0ZW0ueWVhcn1gO1xuICAgIH1cblxuICAgIGdldFRhYmJhYmxlKGl0ZW06IE1vbnRoVmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMubW9udGhTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5tb250aFNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBmb2N1c2VkIG1vbnRoIGNoZWNrIGlmIHRoaXMgaXMgaXRcbiAgICAgICAgaWYgKGZvY3VzZWQpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZvY3VzZWQgbW9udGggaXMgdmlzaWJsZVxuICAgICAgICAgICAgY29uc3QgaXNGb2N1c2VkTW9udGhWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0ubW9udGggPT09IGZvY3VzZWQubW9udGggJiYgX2l0ZW0ueWVhciA9PT0gZm9jdXNlZC55ZWFyKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpc0ZvY3VzZWRNb250aFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXNlZC5tb250aCA9PT0gaXRlbS5tb250aCAmJiBmb2N1c2VkLnllYXIgPT09IGl0ZW0ueWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSBtb250aCB0aGVuIGNoZWNrIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgbW9udGhcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKG1vbnRoID0+IG1vbnRoLmlzQWN0aXZlTW9udGgpKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaXNBY3RpdmVNb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBtb250aCB0YWJiYWJsZVxuICAgICAgICByZXR1cm4gaXRlbS5tb250aCA9PT0gMDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLXRpbWUtdmlldycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RpbWUtdmlldy5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVGltZVZpZXdDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGVwaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSkgeyB9XG5cbiAgICBzZWxlY3RUaW1lem9uZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmVzID0gdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lcyQudmFsdWU7XG4gICAgICAgIFxuICAgICAgICAvLyBmaW5kIG1hdGNoaW5nIHRpbWV6b25lXG4gICAgICAgIGNvbnN0IHRpbWV6b25lID0gdGltZXpvbmVzLmZpbmQoX3RpbWV6b25lID0+IF90aW1lem9uZS5uYW1lID09PSBuYW1lKTtcblxuICAgICAgICBpZiAodGltZXpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXBpY2tlci5zZXRUaW1lem9uZSh0aW1lem9uZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmNyZW1lbnRUaW1lem9uZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLnZhbHVlO1xuICAgICAgICBjb25zdCB0aW1lem9uZXMgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmVzJC52YWx1ZTtcblxuICAgICAgICBjb25zdCBjdXJyZW50Wm9uZSA9IHRpbWV6b25lcy5maW5kSW5kZXgoem9uZSA9PiB6b25lLm5hbWUgPT09IHRpbWV6b25lLm5hbWUgJiYgem9uZS5vZmZzZXQgPT09IHRpbWV6b25lLm9mZnNldCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcHJldmlvdXMgem9uZVxuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuc2V0VGltZXpvbmUodGltZXpvbmVzW2N1cnJlbnRab25lICsgMV0gPyB0aW1lem9uZXNbY3VycmVudFpvbmUgKyAxXSA6IHRpbWV6b25lc1tjdXJyZW50Wm9uZV0pO1xuICAgIH1cblxuICAgIGRlY3JlbWVudFRpbWV6b25lKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB0aW1lem9uZSA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZSQudmFsdWU7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lcyA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLnZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab25lID0gdGltZXpvbmVzLmZpbmRJbmRleCh6b25lID0+IHpvbmUubmFtZSA9PT0gdGltZXpvbmUubmFtZSAmJiB6b25lLm9mZnNldCA9PT0gdGltZXpvbmUub2Zmc2V0KTtcblxuICAgICAgICAvLyB0cnkgdG8gZ2V0IHRoZSBwcmV2aW91cyB6b25lXG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlci5zZXRUaW1lem9uZSh0aW1lem9uZXNbY3VycmVudFpvbmUgLSAxXSA/IHRpbWV6b25lc1tjdXJyZW50Wm9uZSAtIDFdIDogdGltZXpvbmVzW2N1cnJlbnRab25lXSk7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRGF0ZVBpY2tlckhlYWRlckV2ZW50LCBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ3JpZGlmeSwgcmFuZ2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFllYXJWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8WWVhclZpZXdJdGVtW11bXT4oW1tdXSk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PG51bWJlcj4obnVsbCk7XG5cbiAgICBwcml2YXRlIF95ZWFyOiBudW1iZXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgY29uc3QgeWVhciA9IF9kYXRlcGlja2VyLnllYXIkLnN1YnNjcmliZShfeWVhciA9PiB0aGlzLmNyZWF0ZVllYXJHcmlkKF95ZWFyKSk7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZGF0ZXBpY2tlci5oZWFkZXJFdmVudCRcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoX2V2ZW50ID0+IF9ldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLmdvVG9OZXh0RGVjYWRlKCkgOiB0aGlzLmdvVG9QcmV2aW91c0RlY2FkZSgpKTtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHllYXIpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKGV2ZW50KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCQubmV4dCh5ZWFyKTtcbiAgICAgICAgdGhpcy5jcmVhdGVZZWFyR3JpZCh5ZWFyKTtcbiAgICB9XG5cbiAgICBnb1RvUHJldmlvdXNEZWNhZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3JlYXRlWWVhckdyaWQodGhpcy5feWVhciAtIDEwKTtcbiAgICB9XG5cbiAgICBnb1RvTmV4dERlY2FkZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jcmVhdGVZZWFyR3JpZCh0aGlzLl95ZWFyICsgMTApO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlWWVhckdyaWQoeWVhcjogbnVtYmVyID0gdGhpcy5feWVhcik6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuX3llYXIgPSB5ZWFyO1xuXG4gICAgICAgIC8vIGdldCB0aGUgeWVhcnMgdG8gZGlzcGxheVxuICAgICAgICBjb25zdCBkZWNhZGUgPSB0aGlzLmdldERlY2FkZSh5ZWFyKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAvLyBwcm9kdWNlIGl0ZW1zIGluIHRoZSBjb3JyZWN0IGZvcm1hdFxuICAgICAgICBjb25zdCBpdGVtczogWWVhclZpZXdJdGVtW10gPSBkZWNhZGUucmFuZ2UubWFwKF95ZWFyID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeWVhcjogX3llYXIsXG4gICAgICAgICAgICAgICAgaXNDdXJyZW50WWVhcjogX3llYXIgPT09IGN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlWWVhcjogX3llYXIgPT09IHRoaXMuX2RhdGVwaWNrZXIueWVhciQudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVhZGVyIHRleHRcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRIZWFkZXIoZGVjYWRlLnN0YXJ0ICsgJyAtICcgKyBkZWNhZGUuZW5kKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkJC5uZXh0KGdyaWRpZnkoaXRlbXMsIDQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHllYXJzIGluIHRoZSBjdXJyZW50IGRlY2FkZSB0byBkaXNwbGF5XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXREZWNhZGUoeWVhcjogbnVtYmVyKTogWWVhclJhbmdlIHtcblxuICAgICAgICAvLyBmaWd1cmUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKHllYXIgLSAoeWVhciAlIDEwKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgOTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIG51bWJlcnMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgcmFuZ2U6IHJhbmdlKHN0YXJ0LCBlbmQpIH07XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgWWVhclJhbmdlIHtcbiAgICBzdGFydDogbnVtYmVyO1xuICAgIGVuZDogbnVtYmVyO1xuICAgIHJhbmdlOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBZZWFyVmlld0l0ZW0ge1xuICAgIHllYXI6IG51bWJlcjtcbiAgICBpc0N1cnJlbnRZZWFyOiBib29sZWFuO1xuICAgIGlzQWN0aXZlWWVhcjogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgWWVhclZpZXdJdGVtLCBZZWFyVmlld1NlcnZpY2UgfSBmcm9tICcuL3llYXItdmlldy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci15ZWFyLXZpZXcnLFxuICB0ZW1wbGF0ZVVybDogJy4veWVhci12aWV3LmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbWWVhclZpZXdTZXJ2aWNlXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgWWVhclZpZXdDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RhdGVQaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSwgcHVibGljIHllYXJTZXJ2aWNlOiBZZWFyVmlld1NlcnZpY2UpIHt9XG5cbiAgc2VsZWN0KHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHllYXIpO1xuXG4gICAgLy8gc2hvdyB0aGUgbW9udGggcGlja2VyXG4gICAgdGhpcy5fZGF0ZVBpY2tlci5nb1RvQ2hpbGRNb2RlKCk7XG4gIH1cblxuICBmb2N1c1llYXIoaXRlbTogWWVhclZpZXdJdGVtLCB5ZWFyT2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnllYXJTZXJ2aWNlLnNldEZvY3VzKGl0ZW0ueWVhciArIHllYXJPZmZzZXQpO1xuICB9XG5cbiAgdHJhY2tSb3dCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHRyYWNrWWVhckJ5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogWWVhclZpZXdJdGVtKTogbnVtYmVyIHtcbiAgICByZXR1cm4gaXRlbS55ZWFyO1xuICB9XG5cbiAgZ2V0VGFiYmFibGUoaXRlbTogWWVhclZpZXdJdGVtKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZm9jdXNlZCA9IHRoaXMueWVhclNlcnZpY2UuZm9jdXNlZCQudmFsdWU7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMueWVhclNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIGZvY3VzZWQgeWVhciBjaGVjayBpZiB0aGlzIGlzIGl0XG4gICAgaWYgKGZvY3VzZWQpIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZm9jdXNlZCB5ZWFyIGlzIHZpc2libGVcbiAgICAgICAgY29uc3QgaXNGb2N1c2VkWWVhclZpc2libGUgPSAhIWdyaWQuZmluZChyb3cgPT4gISFyb3cuZmluZChfaXRlbSA9PiBfaXRlbS55ZWFyID09PSBmb2N1c2VkKSk7XG5cbiAgICAgICAgaWYgKGlzRm9jdXNlZFllYXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZCA9PT0gaXRlbS55ZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZm9jdXNhYmxlIHllYXIgdGhlbiBjaGVjayBpZiB0aGVyZSBpcyBhIHNlbGVjdGVkIHllYXJcbiAgICBjb25zdCBpc1NlbGVjdGVkWWVhclZpc2libGUgPSAhIWdyaWQuZmluZChyb3cgPT4gISFyb3cuZmluZCh5ZWFyID0+IHllYXIuaXNBY3RpdmVZZWFyKSk7XG5cbiAgICBpZiAoaXNTZWxlY3RlZFllYXJWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlzQWN0aXZlWWVhcjtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgbWFrZSB0aGUgZmlyc3QgbW9udGggdGFiYmFibGVcbiAgICByZXR1cm4gZ3JpZFswXVswXS55ZWFyID09PSBpdGVtLnllYXI7XG59XG5cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZm9jdXNJZl0nXG59KVxuZXhwb3J0IGNsYXNzIEZvY3VzSWZEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCkgZm9jdXNJZkRlbGF5OiBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIGZvY3VzSWZTY3JvbGw6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgZm9jdXNJZihmb2N1czogYm9vbGVhbikge1xuXG4gICAgICAgIC8vIGlmIGEgdGltZW91dCBpcyBwZW5kaW5nIHRoZW4gY2FuY2VsIGl0XG4gICAgICAgIGlmICghZm9jdXMgJiYgdGhpcy5fdGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9jdXMgJiYgdGhpcy5fdGltZW91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiAhdGhpcy5mb2N1c0lmU2Nyb2xsIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcy5mb2N1c0lmRGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdGltZW91dDogbnVtYmVyID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c0lmRGlyZWN0aXZlIH0gZnJvbSAnLi9mb2N1cy1pZi5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZvY3VzSWZEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZvY3VzSWZEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIEZvY3VzSWZNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3BpbkJ1dHRvbk1vZHVsZSB9IGZyb20gJy4uL3NwaW4tYnV0dG9uL2luZGV4JztcbmltcG9ydCB7IFRpbWVQaWNrZXJNb2R1bGUgfSBmcm9tICcuLi90aW1lLXBpY2tlci9pbmRleCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJDb25maWcgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuY29uZmlnJztcbmltcG9ydCB7IERheVZpZXdDb21wb25lbnQgfSBmcm9tICcuL2RheS12aWV3L2RheS12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2hlYWRlci9oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IE1vbnRoVmlld0NvbXBvbmVudCB9IGZyb20gJy4vbW9udGgtdmlldy9tb250aC12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaW1lVmlld0NvbXBvbmVudCB9IGZyb20gJy4vdGltZS12aWV3L3RpbWUtdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgWWVhclZpZXdDb21wb25lbnQgfSBmcm9tICcuL3llYXItdmlldy95ZWFyLXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IE1vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFRpbWVQaWNrZXJNb2R1bGUsXG4gICAgICAgIFNwaW5CdXR0b25Nb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtEYXRlVGltZVBpY2tlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQsIEhlYWRlckNvbXBvbmVudCwgRGF5Vmlld0NvbXBvbmVudCwgTW9udGhWaWV3Q29tcG9uZW50LCBZZWFyVmlld0NvbXBvbmVudCwgVGltZVZpZXdDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIERhdGVUaW1lUGlja2VyTW9kdWxlIHtcbiAgICBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBEYXRlVGltZVBpY2tlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIERhdGVUaW1lUGlja2VyQ29uZmlnXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZWJveCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2Vib3guY29tcG9uZW50Lmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIEVib3hDb21wb25lbnQgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZWJveC1oZWFkZXInXG59KVxuZXhwb3J0IGNsYXNzIEVib3hIZWFkZXJEaXJlY3RpdmUgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZWJveC1jb250ZW50J1xufSlcbmV4cG9ydCBjbGFzcyBFYm94Q29udGVudERpcmVjdGl2ZSB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEVib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlIH0gZnJvbSAnLi9lYm94LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0Vib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtFYm94Q29tcG9uZW50LCBFYm94Q29udGVudERpcmVjdGl2ZSwgRWJveEhlYWRlckRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRWJveE1vZHVsZSB7IH1cbiIsImV4cG9ydCBjbGFzcyBUeXBlYWhlYWRPcHRpb25FdmVudCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIG9wdGlvbjogYW55KSB7fVxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFR5cGVhaGVhZENvbXBvbmVudCB9IGZyb20gJy4vdHlwZWFoZWFkLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUeXBlYWhlYWRLZXlTZXJ2aWNlIHtcblxuICAgIGhhbmRsZUtleShldmVudDogS2V5Ym9hcmRFdmVudCwgdHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVhaGVhZCkge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICBjYXNlICdVcCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWFoZWFkLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5tb3ZlSGlnaGxpZ2h0KC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0Rvd24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVhaGVhZC5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQubW92ZUhpZ2hsaWdodCgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0VzYyc6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZWFoZWFkLnNlbGVjdE9uRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5zZWxlY3RIaWdobGlnaHRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBUeXBlYWhlYWRTZXJ2aWNlIHtcclxuXHJcbiAgICBvcGVuJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAgIGhpZ2hsaWdodGVkRWxlbWVudCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhUTUxFbGVtZW50PihudWxsKTtcclxufSIsImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcclxuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4vdHlwZWFoZWFkLWV2ZW50JztcclxuaW1wb3J0IHsgVHlwZWFoZWFkU2VydmljZSB9IGZyb20gJy4vdHlwZWFoZWFkLnNlcnZpY2UnO1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10eXBlYWhlYWQnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0eXBlYWhlYWQuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgcHJvdmlkZXJzOiBbVHlwZWFoZWFkU2VydmljZV0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ3JvbGUnOiAnbGlzdGJveCcsXHJcbiAgICAgICAgJ1tjbGFzcy5vcGVuXSc6ICdvcGVuJyxcclxuICAgICAgICAnW2NsYXNzLmRyb3AtdXBdJzogJ2Ryb3BEaXJlY3Rpb24gPT09IFwidXBcIicsXHJcbiAgICAgICAgJ1tzdHlsZS5tYXhIZWlnaHRdJzogJ21heEhlaWdodCdcclxuICAgIH1cclxufSlcclxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcclxuXHJcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKSBpZDogc3RyaW5nID0gYHV4LXR5cGVhaGVhZC0keysrdW5pcXVlSWR9YDtcclxuXHJcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xyXG4gICAgQElucHV0KCkgZmlsdGVyOiBzdHJpbmc7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIGdldCBvcGVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlLm9wZW4kLmdldFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBzZXQgb3Blbih2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX3NlcnZpY2Uub3BlbiQubmV4dCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQE91dHB1dCgpIG9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gICAgQElucHV0KCkgZGlzcGxheTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBrZXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkgZGlzYWJsZWRPcHRpb25zOiBhbnlbXTtcclxuICAgIEBJbnB1dCgpIGRyb3BEaXJlY3Rpb246ICd1cCcgfCAnZG93bicgPSAnZG93bic7XHJcbiAgICBASW5wdXQoKSBtYXhIZWlnaHQ6IHN0cmluZyA9ICcyNTBweCc7XHJcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGUnKSBtdWx0aXNlbGVjdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIG9wZW5PbkZpbHRlckNoYW5nZTogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBASW5wdXQoKSBwYWdlU2l6ZTogbnVtYmVyID0gMjA7XHJcbiAgICBASW5wdXQoKSBzZWxlY3RGaXJzdDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBASW5wdXQoKSBzZWxlY3RPbkVudGVyOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBsb2FkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgQElucHV0KCkgbG9hZGluZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgQElucHV0KCkgb3B0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBub09wdGlvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgICBAT3V0cHV0KCkgb3B0aW9uU2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFR5cGVhaGVhZE9wdGlvbkV2ZW50PigpO1xyXG5cclxuICAgIEBPdXRwdXQoKSBoaWdobGlnaHRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgQE91dHB1dCgpIGhpZ2hsaWdodGVkRWxlbWVudENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SFRNTEVsZW1lbnQ+KCk7XHJcblxyXG4gICAgbG9hZE9wdGlvbnNDYWxsYmFjazogSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb247XHJcbiAgICB2aXNpYmxlT3B0aW9ucyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFR5cGVhaGVhZFZpc2libGVPcHRpb25bXT4oW10pO1xyXG4gICAgY2xpY2tpbmcgPSBmYWxzZTtcclxuICAgIGhpZ2hsaWdodGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHlwZWFoZWFkVmlzaWJsZU9wdGlvbj4obnVsbCk7XHJcbiAgICBoaWdobGlnaHRlZEtleTogc3RyaW5nID0gbnVsbDtcclxuXHJcbiAgICBnZXQgaGlnaGxpZ2h0ZWQoKTogYW55IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaGlnaGxpZ2h0ZWQkLmdldFZhbHVlKCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUudmFsdWUgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XHJcblxyXG4gICAgb3B0aW9uQXBpOiBUeXBlYWhlYWRPcHRpb25BcGkgPSB7XHJcbiAgICAgICAgZ2V0S2V5OiB0aGlzLmdldEtleS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIGdldERpc3BsYXk6IHRoaXMuZ2V0RGlzcGxheS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIGdldERpc3BsYXlIdG1sOiB0aGlzLmdldERpc3BsYXlIdG1sLmJpbmQodGhpcylcclxuICAgIH07XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHVibGljIHR5cGVhaGVhZEVsZW1lbnQ6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgICAgIHByaXZhdGUgX3NlcnZpY2U6IFR5cGVhaGVhZFNlcnZpY2VcclxuICAgICkge1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRPcHRpb25zQ2FsbGJhY2sgPSAocGFnZU51bTogbnVtYmVyLCBwYWdlU2l6ZTogbnVtYmVyLCBmaWx0ZXI6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgd2hpY2ggbWF5IHJldHVybiBhbiBhcnJheSBvciBhIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheU9yUHJvbWlzZSA9IHRoaXMub3B0aW9ucyhwYWdlTnVtLCBwYWdlU2l6ZSwgZmlsdGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXAgdGhlIHJlc3VsdHMgdG8gYW4gYXJyYXkgb2YgVHlwZWFoZWFkVmlzaWJsZU9wdGlvbi5cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXJyYXlPclByb21pc2UpLnRoZW4obmV3T3B0aW9ucyA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShuZXdPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3T3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdPcHRpb25zLm1hcCgob3B0aW9uOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZ2V0S2V5KG9wdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX3NlcnZpY2Uub3BlbiQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKChuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KG5leHQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKG5leHQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEtleSA9IG5leHQgPyBuZXh0LmtleSA6IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRDaGFuZ2UuZW1pdChuZXh0ID8gbmV4dC52YWx1ZSA6IG51bGwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb21iaW5lTGF0ZXN0KHRoaXMuX3NlcnZpY2Uub3BlbiQsIHRoaXMuX3NlcnZpY2UuaGlnaGxpZ2h0ZWRFbGVtZW50JCwgdGhpcy52aXNpYmxlT3B0aW9ucyQpXHJcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChbb3BlbiwgaGlnaGxpZ2h0ZWRFbGVtZW50LCB2aXNpYmxlT3B0aW9uc10pID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRFbGVtZW50Q2hhbmdlLmVtaXQob3BlbiAmJiB2aXNpYmxlT3B0aW9ucy5sZW5ndGggPiAwID8gaGlnaGxpZ2h0ZWRFbGVtZW50IDogbnVsbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICAvLyBPcGVuIHRoZSBkcm9wZG93biBpZiB0aGUgZmlsdGVyIHZhbHVlIHVwZGF0ZXNcclxuICAgICAgICBpZiAoY2hhbmdlcy5maWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3Blbk9uRmlsdGVyQ2hhbmdlICYmIGNoYW5nZXMuZmlsdGVyLmN1cnJlbnRWYWx1ZSAmJiBjaGFuZ2VzLmZpbHRlci5jdXJyZW50VmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmUtZmlsdGVyIHZpc2libGVPcHRpb25zXHJcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nKVxyXG4gICAgbW91c2Vkb3duSGFuZGxlcigpIHtcclxuICAgICAgICB0aGlzLmNsaWNraW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZXVwJylcclxuICAgIG1vdXNldXBIYW5kbGVyKCkge1xyXG4gICAgICAgIHRoaXMuY2xpY2tpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25Nb3VzZWRvd25IYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgLy8gV29ya2Fyb3VuZCB0byBwcmV2ZW50IGZvY3VzIGNoYW5naW5nIHdoZW4gYW4gb3B0aW9uIGlzIGNsaWNrZWRcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbkNsaWNrSGFuZGxlcihldmVudDogTW91c2VFdmVudCwgb3B0aW9uOiBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Qob3B0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVuaXF1ZSBrZXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0S2V5KG9wdGlvbjogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleShvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5ID09PSAnc3RyaW5nJyAmJiBvcHRpb24gJiYgb3B0aW9uLmhhc093blByb3BlcnR5KHRoaXMua2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uWzxzdHJpbmc+dGhpcy5rZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXNwbGF5KG9wdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldERpc3BsYXkob3B0aW9uOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdzdHJpbmcnICYmIG9wdGlvbiAmJiBvcHRpb24uaGFzT3duUHJvcGVydHkodGhpcy5kaXNwbGF5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uWzxzdHJpbmc+dGhpcy5kaXNwbGF5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbiB3aXRoIEhUTUwgbWFya3VwIGFkZGVkIHRvIGhpZ2hsaWdodCB0aGUgcGFydCB3aGljaCBtYXRjaGVzIHRoZSBjdXJyZW50IGZpbHRlciB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheUh0bWwob3B0aW9uOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBkaXNwbGF5VGV4dCA9IHRoaXMuZ2V0RGlzcGxheShvcHRpb24pLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcclxuICAgICAgICBsZXQgZGlzcGxheUh0bWwgPSBkaXNwbGF5VGV4dDtcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5maWx0ZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaEluZGV4ID0gZGlzcGxheVRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuZmlsdGVyLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gYDxzcGFuIGNsYXNzPVwidXgtZmlsdGVyLW1hdGNoXCI+JHtkaXNwbGF5VGV4dC5zdWJzdHIobWF0Y2hJbmRleCwgbGVuZ3RoKX08L3NwYW4+YDtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlIdG1sID0gZGlzcGxheVRleHQuc3Vic3RyKDAsIG1hdGNoSW5kZXgpICsgaGlnaGxpZ2h0ICsgZGlzcGxheVRleHQuc3Vic3RyKG1hdGNoSW5kZXggKyBsZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaXNwbGF5SHRtbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5maW5pdGUgc2Nyb2xsIGNvbXBvbmVudCBzaG91bGQgbG9hZFxyXG4gICAgICovXHJcbiAgICBpc0luZmluaXRlU2Nyb2xsKCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5vcHRpb25zID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gb3B0aW9uLCBlbWl0dGluZyB0aGUgb3B0aW9uU2VsZWN0ZWQgZXZlbnQgYW5kIGNsb3NpbmcgdGhlIGRyb3Bkb3duLlxyXG4gICAgICovXHJcbiAgICBzZWxlY3Qob3B0aW9uOiBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQob3B0aW9uKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvblNlbGVjdGVkLmVtaXQobmV3IFR5cGVhaGVhZE9wdGlvbkV2ZW50KG9wdGlvbi52YWx1ZSkpO1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkJC5uZXh0KG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9wdGlvbiBpcyBwYXJ0IG9mIHRoZSBkaXNhYmxlZE9wdGlvbnMgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGlzRGlzYWJsZWQob3B0aW9uOiBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZGlzYWJsZWRPcHRpb25zLmZpbmQoKHNlbGVjdGVkT3B0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoc2VsZWN0ZWRPcHRpb24pID09PSBvcHRpb24ua2V5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGdpdmVuIG9wdGlvbiBhcyB0aGUgY3VycmVudCBoaWdobGlnaHRlZCBvcHRpb24sIGF2YWlsYWJsZSBpbiB0aGUgaGlnaGxpZ2h0ZWRPcHRpb24gcGFyYW1ldGVyLlxyXG4gICAgICovXHJcbiAgICBoaWdobGlnaHQob3B0aW9uOiBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQob3B0aW9uKSkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkJC5uZXh0KG9wdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBoaWdobGlnaHRlZCBvcHRpb24gaW4gdGhlIGxpc3QuIERpc2FibGVkIG9wdGlvbnMgYXJlIHNraXBwZWQuXHJcbiAgICAgKiBAcGFyYW0gZCBWYWx1ZSB0byBiZSBhZGRlZCB0byB0aGUgaW5kZXggb2YgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbiwgaS5lLiAtMSB0byBtb3ZlIGJhY2t3YXJkcywgKzEgdG8gbW92ZSBmb3J3YXJkcy5cclxuICAgICAqL1xyXG4gICAgbW92ZUhpZ2hsaWdodChkOiBudW1iZXIpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IHZpc2libGVPcHRpb25zID0gdGhpcy52aXNpYmxlT3B0aW9ucyQuZ2V0VmFsdWUoKTtcclxuICAgICAgICBjb25zdCBoaWdobGlnaHRJbmRleCA9IHRoaXMuaW5kZXhPZlZpc2libGVPcHRpb24odGhpcy5oaWdobGlnaHRlZCk7XHJcbiAgICAgICAgbGV0IG5ld0luZGV4ID0gaGlnaGxpZ2h0SW5kZXg7XHJcbiAgICAgICAgbGV0IGRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaW5Cb3VuZHMgPSB0cnVlO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIGQ7XHJcbiAgICAgICAgICAgIGluQm91bmRzID0gKG5ld0luZGV4ID49IDAgJiYgbmV3SW5kZXggPCB2aXNpYmxlT3B0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBkaXNhYmxlZCA9IGluQm91bmRzICYmIHRoaXMuaXNEaXNhYmxlZCh2aXNpYmxlT3B0aW9uc1tuZXdJbmRleF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaW5Cb3VuZHMgJiYgZGlzYWJsZWQpO1xyXG5cclxuICAgICAgICBpZiAoIWRpc2FibGVkICYmIGluQm91bmRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0KHZpc2libGVPcHRpb25zW25ld0luZGV4XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdobGlnaHRlZDtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RIaWdobGlnaHRlZCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh7IHZhbHVlOiB0aGlzLmhpZ2hsaWdodGVkLCBrZXk6IHRoaXMuZ2V0S2V5KHRoaXMuaGlnaGxpZ2h0ZWQpfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHVwIHRoZSBvcHRpb25zIGJlZm9yZSB0aGUgZHJvcGRvd24gaXMgZGlzcGxheWVkLlxyXG4gICAgICovXHJcbiAgICBpbml0T3B0aW9ucygpIHtcclxuICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBoaWdobGlnaHRcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkJC5uZXh0KG51bGwpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdEZpcnN0KSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBoaWdobGlnaHQgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24uXHJcbiAgICAgICAgICAgIHRoaXMubW92ZUhpZ2hsaWdodCgxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHZpc2libGVPcHRpb25zIGFycmF5IHdpdGggdGhlIGN1cnJlbnQgZmlsdGVyLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVPcHRpb25zKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpc2VkSW5wdXQgPSAodGhpcy5maWx0ZXIgfHwgJycpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVPcHRpb25zID0gdGhpcy5vcHRpb25zXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREaXNwbGF5KG9wdGlvbikudG9Mb3dlckNhc2UoKS5pbmRleE9mKG5vcm1hbGlzZWRJbnB1dCkgPj0gMDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmdldEtleSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZU9wdGlvbnMkLm5leHQodmlzaWJsZU9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbml0T3B0aW9ucygpO1xyXG5cclxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBvcHRpb24gaW4gdGhlIHZpc2libGVPcHRpb25zIGFycmF5LiBSZXR1cm5zIC0xIGlmIHRoZSBvcHRpb24gaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGluZGV4T2ZWaXNpYmxlT3B0aW9uKG9wdGlvbjogYW55KTogbnVtYmVyIHtcclxuICAgICAgICBpZiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbktleSA9IHRoaXMuZ2V0S2V5KG9wdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGVPcHRpb25zJC5nZXRWYWx1ZSgpLmZpbmRJbmRleCgoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5rZXkgPT09IG9wdGlvbktleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgQVBJIGF2YWlsYWJsZSB0byBvcHRpb24gdGVtcGxhdGVzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUeXBlYWhlYWRPcHRpb25BcGkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGtleSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXRLZXkob3B0aW9uOiBhbnkpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldERpc3BsYXkob3B0aW9uOiBhbnkpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24gd2l0aCBIVE1MIG1hcmt1cCBhZGRlZCB0byBoaWdobGlnaHQgdGhlIHBhcnQgd2hpY2ggbWF0Y2hlcyB0aGUgY3VycmVudCBmaWx0ZXIgdmFsdWUuIE92ZXJyaWRlIHRoZSB1eC1maWx0ZXItbWF0Y2ggY2xhc3MgaW4gQ1NTIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBhcHBlYXJhbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5SHRtbChvcHRpb246IGFueSk6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uIHtcclxuICAgIHZhbHVlOiBhbnk7XHJcbiAgICBrZXk6IHN0cmluZztcclxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE91dHB1dCwgUmVuZGVyZXIyLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25dJ1xufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCd1eEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbicpXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgICBzZXQgdmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRlbXBsYXRlIGNvbnRlbnQgZm9sbG93cyB0aGUgZWxlbWVudFJlZiwgd2hpY2ggaXMgYSBjb21tZW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrVGFyZ2V0ID0gdGhpcy5nZXROZXh0RWxlbWVudFNpYmxpbmcodGhpcy5fdGVtcGxhdGUuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4oY2xpY2tUYXJnZXQsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIEBPdXRwdXQoKSBsb2FkOiBPYnNlcnZhYmxlPEV2ZW50PjtcblxuICAgIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9sb2FkID0gbmV3IFN1YmplY3QoKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF90ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuXG4gICAgICAgIHRoaXMubG9hZCA9IHRoaXMuX2xvYWQuYXNPYnNlcnZhYmxlKCkgYXMgT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2xvYWQubmV4dChldmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXROZXh0RWxlbWVudFNpYmxpbmcoZWxlbWVudDogYW55KTogRWxlbWVudCB7XG4gICAgICAgIHZhciBuZXh0ID0gZWxlbWVudDtcbiAgICAgICAgd2hpbGUgKG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SW5maW5pdGVTY3JvbGxMb2FkaW5nXSdcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgndXhJbmZpbml0ZVNjcm9sbExvYWRpbmcnKVxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG4gICAgc2V0IHZpc2libGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF90ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZikgeyB9XG59XG4iLCJcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb20nO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgeyBhdWRpdFRpbWUsIGNvbWJpbmVMYXRlc3QsIGZpbHRlciBhcyBmaWx0ZXJPcGVyYXRvciwgZmlyc3QsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJbmZpbml0ZVNjcm9sbF0nLFxuICAgIGV4cG9ydEFzOiAndXhJbmZpbml0ZVNjcm9sbCdcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgndXhJbmZpbml0ZVNjcm9sbCcpIGxvYWQ6IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xuXG4gICAgQElucHV0KCdjb2xsZWN0aW9uJykgX2NvbGxlY3Rpb246IGFueVtdID0gW107XG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgY29sbGVjdGlvbih2YWx1ZTogYW55W10pIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gdmFsdWU7XG4gICAgfVxuXG5cbiAgICBASW5wdXQoKSBzZXQgc2Nyb2xsRWxlbWVudChlbGVtZW50OiBFbGVtZW50UmVmIHwgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50UmVmID8gZWxlbWVudCA6IG5ldyBFbGVtZW50UmVmKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIGVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGZpbHRlcjogYW55O1xuICAgIEBJbnB1dCgpIGxvYWRPbkluaXQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGxvYWRPblNjcm9sbDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgcGFnZVNpemU6IG51bWJlciA9IDIwO1xuXG4gICAgQE91dHB1dCgpIGNvbGxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuXG4gICAgQE91dHB1dCgnbG9hZGluZycpXG4gICAgbG9hZGluZ0V2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxJbmZpbml0ZVNjcm9sbExvYWRpbmdFdmVudD4oKTtcblxuICAgIEBPdXRwdXQoJ2xvYWRlZCcpXG4gICAgbG9hZGVkRXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPEluZmluaXRlU2Nyb2xsTG9hZGVkRXZlbnQ+KCk7XG5cbiAgICBAT3V0cHV0KCdsb2FkRXJyb3InKVxuICAgIGxvYWRFcnJvckV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxJbmZpbml0ZVNjcm9sbExvYWRFcnJvckV2ZW50PigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUpXG4gICAgcHJpdmF0ZSBfbG9hZEJ1dHRvblF1ZXJ5OiBRdWVyeUxpc3Q8SW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlPjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlKVxuICAgIHByaXZhdGUgX2xvYWRpbmdJbmRpY2F0b3JRdWVyeTogUXVlcnlMaXN0PEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZT47XG5cbiAgICBwcml2YXRlIF9wYWdlczogYW55W11bXTtcbiAgICBwcml2YXRlIF9uZXh0UGFnZU51bSA9IDA7XG4gICAgcHJpdmF0ZSBfZG9tT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgcHJpdmF0ZSBfc2Nyb2xsRXZlbnRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF91cGRhdGVSZXF1ZXN0cyA9IG5ldyBTdWJqZWN0PEluZmluaXRlU2Nyb2xsUmVxdWVzdD4oKTtcblxuICAgIHByaXZhdGUgX2lzTG9hZGluZyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHByaXZhdGUgX2lzRXhoYXVzdGVkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcHJpdmF0ZSBfbG9hZEJ1dHRvbkVuYWJsZWQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBwcml2YXRlIF9jYW5Mb2FkTWFudWFsbHk6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgICBwcml2YXRlIF9zY3JvbGxFbGVtZW50OiBFbGVtZW50UmVmO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gICAgcHJpdmF0ZSBfbG9hZEJ1dHRvblN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fY2FuTG9hZE1hbnVhbGx5ID0gdGhpcy5faXNMb2FkaW5nLnBpcGUoY29tYmluZUxhdGVzdChcbiAgICAgICAgICAgIHRoaXMuX2lzRXhoYXVzdGVkLFxuICAgICAgICAgICAgdGhpcy5fbG9hZEJ1dHRvbkVuYWJsZWQsXG4gICAgICAgICAgICAoaXNMb2FkaW5nLCBpc0V4aGF1c3RlZCwgbG9hZEJ1dHRvbkVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTG9hZGluZyAmJiAhaXNFeGhhdXN0ZWQgJiYgbG9hZEJ1dHRvbkVuYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9hZEJ1dHRvbkVuYWJsZWQubmV4dCghdGhpcy5sb2FkT25TY3JvbGwpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcblxuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIGtpbmRzIG9mIHVwZGF0ZSByZXF1ZXN0czogY2hlY2sgYW5kIGxvYWQuXG4gICAgICAgIC8vIENoZWNrIHJlcXVlc3RzIGFyZSB0aHJvdHRsZWQgYW5kIHdpbGwgb25seSBjYXVzZSBhbiB1cGRhdGUgaWYgbW9yZSBkYXRhIGlzIHJlcXVpcmVkXG4gICAgICAgIC8vIHRvIGZpbGwgdGhlIHNjcm9sbGluZyB2aWV3LCBhbmQgaXQgaXNuJ3QgYWxyZWFkeSBsb2FkaW5nIHNvbWUuXG4gICAgICAgIC8vIExvYWQgcmVxdWVzdHMgYXJlIG5vdCB0aHJvdHRsZWQgYW5kIGFsd2F5cyByZXF1ZXN0IGEgcGFnZSBvZiBkYXRhLlxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5waXBlKGZpbHRlck9wZXJhdG9yKHJlcXVlc3QgPT4gcmVxdWVzdC5jaGVjayksIGF1ZGl0VGltZSgyMDApLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMuZG9SZXF1ZXN0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5waXBlKGZpbHRlck9wZXJhdG9yKHJlcXVlc3QgPT4gIXJlcXVlc3QuY2hlY2spLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMuZG9SZXF1ZXN0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byBzY3JvbGwgZXZlbnRzIGFuZCBET00gY2hhbmdlcy5cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgTG9hZCBNb3JlIGJ1dHRvbiB2aXNpYmxlIHN0YXRlLlxuICAgICAgICB0aGlzLl9jYW5Mb2FkTWFudWFsbHkucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGNhbkxvYWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9hZEJ1dHRvblF1ZXJ5LmZvckVhY2gobG9hZEJ1dHRvbiA9PiB7XG4gICAgICAgICAgICAgICAgbG9hZEJ1dHRvbi52aXNpYmxlID0gY2FuTG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb25uZWN0IHRoZSBsb2FkaW5nIGluZGljYXRvciB2aXNpYmxlIHN0YXRlLlxuICAgICAgICB0aGlzLl9pc0xvYWRpbmcucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGlzTG9hZGluZyA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nSW5kaWNhdG9yUXVlcnkuZm9yRWFjaChsb2FkaW5nID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nLnZpc2libGUgPSBpc0xvYWRpbmc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGluayB0aGUgTG9hZCBNb3JlIGJ1dHRvbiBjbGljayBldmVudCB0byB0cmlnZ2VyIGFuIHVwZGF0ZS5cbiAgICAgICAgdGhpcy5hdHRhY2hMb2FkQnV0dG9uRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX2xvYWRCdXR0b25RdWVyeS5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaExvYWRCdXR0b25FdmVudHMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbCB1cGRhdGUuXG4gICAgICAgIGlmICh0aGlzLmxvYWRPbkluaXQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZE5leHRQYWdlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGxldCBjaGVjayA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNoYW5nZXMuZW5hYmxlZCAmJiBjaGFuZ2VzLmVuYWJsZWQuY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmVuYWJsZWQucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuZW5hYmxlZC5jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5maWx0ZXIgJiYgY2hhbmdlcy5maWx0ZXIuY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmZpbHRlci5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxvYWRPblNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRCdXR0b25FbmFibGVkLm5leHQoXG4gICAgICAgICAgICAgICAgICAgICFjaGFuZ2VzLmxvYWRPblNjcm9sbC5jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5wYWdlU2l6ZSAmJiBjaGFuZ2VzLnBhZ2VTaXplLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5wYWdlU2l6ZS5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgICAgIGNoZWNrOiBjaGVjayxcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyOiB0aGlzLl9uZXh0UGFnZU51bSxcbiAgICAgICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRldGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhbiBhZGRpdGlvbmFsIHBhZ2Ugb2YgZGF0YS5cbiAgICAgKi9cbiAgICBsb2FkTmV4dFBhZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5uZXh0KHtcbiAgICAgICAgICAgIGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHRoaXMuX25leHRQYWdlTnVtLFxuICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSBjaGVjayBmb3Igd2hldGhlciBhbiBhZGRpdGlvbmFsIHBhZ2Ugb2YgZGF0YSBpcyByZXF1aXJlZC4gVGhpcyBpcyB0aHJvdHRsZWQuXG4gICAgICovXG4gICAgY2hlY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5uZXh0KHtcbiAgICAgICAgICAgIGNoZWNrOiB0cnVlLFxuICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5fbmV4dFBhZ2VOdW0sXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNvbGxlY3Rpb24uIEZ1dHVyZSByZXF1ZXN0cyB3aWxsIGxvYWQgZnJvbSBwYWdlIDAuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB0aGUgcGFnZSBjb3VudGVyLlxuICAgICAgICB0aGlzLl9uZXh0UGFnZU51bSA9IDA7XG5cbiAgICAgICAgdGhpcy5fcGFnZXMgPSBbXTtcblxuICAgICAgICAvLyBDbGVhciB0aGUgY29sbGVjdGlvbiAod2l0aG91dCBjaGFuZ2luZyB0aGUgcmVmZXJlbmNlKS5cbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB0aGUgZXhoYXVzdGVkIGZsYWcsIGFsbG93aW5nIHRoZSBMb2FkIE1vcmUgYnV0dG9uIHRvIGFwcGVhci5cbiAgICAgICAgdGhpcy5faXNFeGhhdXN0ZWQubmV4dChmYWxzZSk7XG5cbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2gocmVxdWVzdCA9PiByZXF1ZXN0LnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsb2FkIHRoZSBkYXRhIHdpdGhvdXQgY2xlYXJpbmcgdGhlIHZpZXcuXG4gICAgICovXG4gICAgcmVsb2FkKCkge1xuICAgICAgICB0aGlzLl9wYWdlcy5mb3JFYWNoKChwYWdlLCBpKSA9PiB0aGlzLnJlbG9hZFBhZ2UoaSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbG9hZCB0aGUgZGF0YSBpbiBhIHNwZWNpZmljIHBhZ2Ugd2l0aG91dCBjbGVhcmluZyB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0gcGFnZU51bSBQYWdlIG51bWJlclxuICAgICAqL1xuICAgIHJlbG9hZFBhZ2UocGFnZU51bTogbnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5uZXh0KHtcbiAgICAgICAgICAgIGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW0sXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICByZWxvYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIHNjcm9sbCBldmVudCBoYW5kbGVyIGFuZCBET00gb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhdHRhY2hFdmVudEhhbmRsZXJzKCkge1xuXG4gICAgICAgIC8vIGlmIHRoZSBzY3JvbGxFbGVtZW50IGlzIGRvY3VtZW50RWxlbWVudCB3ZSBtdXN0IHdhdGNoIGZvciBhIHNjcm9sbCBldmVudCBvbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fc2Nyb2xsRWxlbWVudC5uYXRpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEh0bWxFbGVtZW50ID8gZG9jdW1lbnQgOiB0aGlzLl9zY3JvbGxFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzY3JvbGwgZXZlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICB0aGlzLl9zY3JvbGxFdmVudFN1YiA9IGZyb21FdmVudCh0YXJnZXQsICdzY3JvbGwnKS5zdWJzY3JpYmUodGhpcy5jaGVjay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2hpbGQgRE9NIGNoYW5nZXMuIFRoZSBtYWluIGVmZmVjdCBvZiB0aGlzIGlzIHRvIGNoZWNrIHdoZXRoZXIgZXZlbiBtb3JlIGRhdGEgaXNcbiAgICAgICAgLy8gcmVxdWlyZWQgYWZ0ZXIgdGhlIGluaXRpYWwgbG9hZC5cbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmNoZWNrLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Njcm9sbEVsZW1lbnQubmF0aXZlRWxlbWVudCwge1xuICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggc2Nyb2xsIGV2ZW50IGhhbmRsZXIgYW5kIERPTSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGRldGFjaEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxFdmVudFN1Yikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEV2ZW50U3ViID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9kb21PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFueSBleGlzdGluZyBldmVudCBzdWJzY3JpcHRpb25zIGZvciB0aGUgbG9hZCBidXR0b24gYGxvYWRgIGV2ZW50LCB0aGVuIGF0dGFjaCBzdWJzY3JpcHRpb25zXG4gICAgICogZm9yIGFueSBpbiB0aGUgcXVlcnkuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhdHRhY2hMb2FkQnV0dG9uRXZlbnRzKCkge1xuICAgICAgICB0aGlzLl9sb2FkQnV0dG9uU3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgdGhpcy5fbG9hZEJ1dHRvblN1YnNjcmlwdGlvbnMgPSB0aGlzLl9sb2FkQnV0dG9uUXVlcnkubWFwKFxuICAgICAgICAgICAgbG9hZEJ1dHRvbiA9PiBsb2FkQnV0dG9uLmxvYWQuc3Vic2NyaWJlKHRoaXMubG9hZE5leHRQYWdlLmJpbmQodGhpcykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSBsb2FkcyBhIHBhZ2UgaW50byB0aGUgY29sbGVjdGlvbiBiYXNlZCBvbiBkaXJlY3RpdmUgc3RhdGUgYW5kIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGRvUmVxdWVzdChyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QpIHtcblxuICAgICAgICAvLyBMb2FkIGEgbmV3IHBhZ2UgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBiZXlvbmQgdGhlIHRocmVzaGhvbGQgYW5kIGlmIHRoZSBjbGllbnQgY29kZSBkaWQgbm90XG4gICAgICAgIC8vIGNhbmNlbC5cbiAgICAgICAgaWYgKHRoaXMubmVlZHNEYXRhKHJlcXVlc3QpICYmIHRoaXMuYmVnaW5Mb2FkaW5nKHJlcXVlc3QpKSB7XG5cbiAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgbG9hZCBmdW5jdGlvbiwgd2hpY2ggcmV0dXJucyBhIHByb21vc2Ugb3IgcGxhaW4gZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IGxvYWRSZXN1bHQgPSB0aGlzLmxvYWQocmVxdWVzdC5wYWdlTnVtYmVyLCByZXF1ZXN0LnBhZ2VTaXplLCByZXF1ZXN0LmZpbHRlcik7XG5cbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGUgPSBBcnJheS5pc0FycmF5KGxvYWRSZXN1bHQpID8gb2YobG9hZFJlc3VsdCkgOiBmcm9tPGFueVtdPihsb2FkUmVzdWx0KTtcblxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICBpdGVtcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwYXJhbWV0ZXJzIGhhdmUgbm90IGNoYW5nZWQgc2luY2UgdGhlIGxvYWQgc3RhcnRlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGRpc2NhcmQgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmZpbHRlciA9PT0gdGhpcy5maWx0ZXIgJiYgcmVxdWVzdC5wYWdlU2l6ZSA9PT0gdGhpcy5wYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFnZUl0ZW1zKHJlcXVlc3QucGFnZU51bWJlciwgaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IHRoZSBsb2FkZWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kTG9hZGluZyhyZXF1ZXN0LCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGxvYWRFcnJvciBldmVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZExvYWRpbmdXaXRoRXJyb3IocmVxdWVzdCwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgcmVxdWVzdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zLmZpbHRlcihzID0+IHMgIT09IHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzdWJzY3JpcHRpb24gdG8gdGhlIGxpc3Qgb2YgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IHNob3VsZCBiZSBmdWxmaWxsZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBuZWVkc0RhdGEocmVxdWVzdDogSW5maW5pdGVTY3JvbGxSZXF1ZXN0KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHdheXMgbG9hZCBmb3IgYSBsb2FkIHJlcXVlc3RcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElnbm9yZSBhIGNoZWNrIHJlcXVlc3Qgd2hlbiB0aGUgZW5kIG9mIGRhdGEgaGFzIGJlZW4gZGV0ZWN0ZWQsIG9yIGlmIGRhdGEgaXMgY3VycmVudGx5IGxvYWRpbmcuXG4gICAgICAgIGlmICh0aGlzLl9pc0V4aGF1c3RlZC5nZXRWYWx1ZSgpIHx8IHRoaXMuX2lzTG9hZGluZy5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2FkIGlmIHRoZSByZW1haW5pbmcgc2Nyb2xsIGFyZWEgaXMgPD0gdGhlIGVsZW1lbnQgaGVpZ2h0LlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsRWxlbWVudCAmJiB0aGlzLmxvYWRPblNjcm9sbCkge1xuXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gPEhUTUxFbGVtZW50PnRoaXMuX3Njcm9sbEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1Njcm9sbCA9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIChlbGVtZW50LnNjcm9sbFRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZ1Njcm9sbCA8PSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHN0YXRlIGZvciB0aGUgYmVnaW5uaW5nIG9mIGEgbG9hZC4gUmV0dXJucyBmYWxzZSBpZiB0aGUgYGxvYWRpbmdgIGV2ZW50IHdhcyBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBiZWdpbkxvYWRpbmcocmVxdWVzdDogSW5maW5pdGVTY3JvbGxSZXF1ZXN0KTogYm9vbGVhbiB7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgSW5maW5pdGVTY3JvbGxMb2FkaW5nRXZlbnQoXG4gICAgICAgICAgICByZXF1ZXN0LnBhZ2VOdW1iZXIsXG4gICAgICAgICAgICByZXF1ZXN0LnBhZ2VTaXplLFxuICAgICAgICAgICAgcmVxdWVzdC5maWx0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2FkaW5nRXZlbnQuZW1pdChldmVudCk7XG5cbiAgICAgICAgdGhpcy5faXNMb2FkaW5nLm5leHQoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQoKSk7XG5cbiAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRQYWdlSXRlbXMocGFnZU51bTogbnVtYmVyLCBpdGVtczogYW55W10pIHtcbiAgICAgICAgdGhpcy5fcGFnZXNbcGFnZU51bV0gPSBpdGVtcztcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5fcGFnZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gcHJldmlvdXMuY29uY2F0KGN1cnJlbnQpLCBbXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzdGF0ZSBmcm9tIGEgc3VjY2Vzc2Z1bCBsb2FkLiBSYWlzZXMgdGhlIGBsb2FkZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGUgZW5kTG9hZGluZyhyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QsIGRhdGE/OiBhbnkpIHtcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nLm5leHQoZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IGlzRXhoYXVzdGVkID0gISEoZGF0YSAmJiBkYXRhLmxlbmd0aCA8IHRoaXMucGFnZVNpemUpO1xuICAgICAgICB0aGlzLl9pc0V4aGF1c3RlZC5uZXh0KGlzRXhoYXVzdGVkKTtcblxuICAgICAgICB0aGlzLmxvYWRlZEV2ZW50LmVtaXQoXG4gICAgICAgICAgICBuZXcgSW5maW5pdGVTY3JvbGxMb2FkZWRFdmVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhZ2VOdW1iZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmZpbHRlcixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGlzRXhoYXVzdGVkXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXF1ZXN0LnJlbG9hZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dFBhZ2VOdW0gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3RhdGUgZnJvbSBhIGZhaWxlZCBsb2FkLiBSYWlzZXMgdGhlIGBsb2FkRXJyb3JgIGV2ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGUgZW5kTG9hZGluZ1dpdGhFcnJvcihyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QsIGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nLm5leHQoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMubG9hZEVycm9yRXZlbnQuZW1pdChcbiAgICAgICAgICAgIG5ldyBJbmZpbml0ZVNjcm9sbExvYWRFcnJvckV2ZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFnZU51bWJlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZmlsdGVyLFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBpbnRlcm5hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGxvYWQvY2hlY2sgcmVxdWVzdC5cbiAqL1xuY2xhc3MgSW5maW5pdGVTY3JvbGxSZXF1ZXN0IHtcbiAgICBjaGVjazogYm9vbGVhbjtcbiAgICBwYWdlTnVtYmVyOiBudW1iZXI7XG4gICAgcGFnZVNpemU6IG51bWJlcjtcbiAgICBmaWx0ZXI6IGFueTtcbiAgICByZWxvYWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbiA9IChcbiAgICBwYWdlTnVtOiBudW1iZXIsXG4gICAgcGFnZVNpemU6IG51bWJlcixcbiAgICBmaWx0ZXI6IGFueVxuKSA9PiBhbnkgfCBQcm9taXNlPGFueT47XG5cbi8qKlxuICogRXZlbnQgcmFpc2VkIGJlZm9yZSB0aGUgYGxvYWRpbmdgIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZGluZ0V2ZW50IHtcbiAgICBwcml2YXRlIF9kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgcmVxdWVzdGVkIHBhZ2UsIHN0YXJ0aW5nIGZyb20gMC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlU2l6ZTogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpbHRlciBkZXRhaWxzIGFzIHByb3ZpZGVkIHZpYSB0aGUgYGZpbHRlcmAgYmluZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBmaWx0ZXI6IGFueVxuICAgICkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhlIGBsb2FkaW5nYCBldmVudCAobG9hZGluZyBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQpLlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZWZhdWx0UHJldmVudGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogRXZlbnQgcmFpc2VkIHdoZW4gdGhlIGxvYWRpbmcgZnVuY3Rpb24gcmVzdWx0IGhhcyBiZWVuIHJlc29sdmVkIGFuZCBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZGVkRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSByZXF1ZXN0ZWQgcGFnZSwgc3RhcnRpbmcgZnJvbSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VOdW1iZXI6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmlsdGVyIGRldGFpbHMgYXMgcHJvdmlkZWQgdmlhIHRoZSBgZmlsdGVyYCBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGZpbHRlcjogYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSByZXR1cm5lZCBmcm9tIHRoZSBsb2FkaW5nIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGRhdGE6IGFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaWYgdGhlIGRhdGEgaXMgY29uc2lkZXJlZCBleGhhdXN0ZWQgKG51bWJlciBvZiBpdGVtcyByZXR1cm5lZCBsZXNzIHRoYW4gYHBhZ2VTaXplYCkuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZXhoYXVzdGVkOiBib29sZWFuXG4gICAgKSB7IH1cbn1cblxuLyoqXG4gKiBFdmVudCByYWlzZWQgaWYgdGhlIGxvYWRpbmcgZnVuY3Rpb24gcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRFcnJvckV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgcmVxdWVzdGVkIHBhZ2UsIHN0YXJ0aW5nIGZyb20gMC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlU2l6ZTogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpbHRlciBkZXRhaWxzIGFzIHByb3ZpZGVkIHZpYSB0aGUgYGZpbHRlcmAgYmluZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBmaWx0ZXI6IGFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvYmplY3QgcHJvdmlkZWQgd2hlbiByZWplY3RpbmcgdGhlIHByb21pc2UuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZXJyb3I6IGFueVxuICAgICkgeyB9XG59XG4iLCJpbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1sb2FkLWJ1dHRvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEluZmluaXRlU2Nyb2xsRGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEluZmluaXRlU2Nyb2xsRGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTY3JvbGxJbnRvVmlld1NlcnZpY2Uge1xuXG4gICAgc2Nyb2xsSW50b1ZpZXcoZWxlbTogSFRNTEVsZW1lbnQsIHNjcm9sbFBhcmVudDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gKGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCkgLSBzY3JvbGxQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICBpZiAob2Zmc2V0VG9wIDwgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA9IG9mZnNldFRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJvdHRvbSA9IG9mZnNldFRvcCArIGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKG9mZnNldEJvdHRvbSA+IChzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICsgc2Nyb2xsUGFyZW50LmNsaWVudEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gb2Zmc2V0Qm90dG9tIC0gc2Nyb2xsUGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNjcm9sbEludG9WaWV3U2VydmljZSB9IGZyb20gJy4vc2Nyb2xsLWludG8tdmlldy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhTY3JvbGxJbnRvVmlld0lmXScsXG4gICAgcHJvdmlkZXJzOiBbU2Nyb2xsSW50b1ZpZXdTZXJ2aWNlXVxuIH0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsSW50b1ZpZXdJZkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgICBASW5wdXQoJ3V4U2Nyb2xsSW50b1ZpZXdJZicpIGNvbmRpdGlvbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNjcm9sbFBhcmVudDogSFRNTEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF9zY3JvbGxJbnRvVmlld1NlcnZpY2U6IFNjcm9sbEludG9WaWV3U2VydmljZSkge31cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb24pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2Nyb2xsSW50b1ZpZXdTZXJ2aWNlLnNjcm9sbEludG9WaWV3KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5zY3JvbGxQYXJlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2Nyb2xsSW50b1ZpZXddJ1xufSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxJbnRvVmlld0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgLyoqIEFsbG93IGEgY29uZGl0aW9uIGFyb3VuZCB3aGV0aGVyIG9yIG5vdCB0aGlzIHNob3VsZCBzY3JvbGwgaW50byB2aWV3ICovXG4gICAgQElucHV0KCkgdXhTY3JvbGxJbnRvVmlldzogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogQWxsb3cgdXNlciB0byBwcm92aWRlIHRoZSBicm93c2VyIHN1cHBvcnRlZCBvcHRpb25zICovXG4gICAgQElucHV0KCkgc2Nyb2xsSW50b1ZpZXdPcHRpb25zOiBTY3JvbGxJbnRvVmlld09wdGlvbnMgfCBib29sZWFuID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy51eFNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcodGhpcy5zY3JvbGxJbnRvVmlld09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTY3JvbGxJbnRvVmlld0lmRGlyZWN0aXZlIH0gZnJvbSAnLi9zY3JvbGwtaW50by12aWV3LWlmLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTY3JvbGxJbnRvVmlld0RpcmVjdGl2ZSB9IGZyb20gJy4vc2Nyb2xsLWludG8tdmlldy5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW1Njcm9sbEludG9WaWV3SWZEaXJlY3RpdmUsIFNjcm9sbEludG9WaWV3RGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTY3JvbGxJbnRvVmlld0lmRGlyZWN0aXZlLCBTY3JvbGxJbnRvVmlld0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsTW9kdWxlIHsgfSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVHlwZWFoZWFkU2VydmljZSB9IGZyb20gJy4vdHlwZWFoZWFkLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFR5cGVhaGVhZEhpZ2hsaWdodF0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUeXBlYWhlYWRIaWdobGlnaHREaXJlY3RpdmUge1xyXG5cclxuICAgIEBJbnB1dCgndXhUeXBlYWhlYWRIaWdobGlnaHQnKVxyXG4gICAgc2V0IGhpZ2hsaWdodCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmhpZ2hsaWdodGVkRWxlbWVudCQubmV4dCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZXJ2aWNlOiBUeXBlYWhlYWRTZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxyXG59XHJcbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmRleCc7XG5pbXBvcnQgeyBTY3JvbGxNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Njcm9sbC9pbmRleCc7XG5pbXBvcnQgeyBUeXBlYWhlYWRIaWdobGlnaHREaXJlY3RpdmUgfSBmcm9tICcuL3R5cGVhaGVhZC1oaWdobGlnaHQuZGlyZWN0aXZlJztcbmltcG9ydCB7IFR5cGVhaGVhZEtleVNlcnZpY2UgfSBmcm9tICcuL3R5cGVhaGVhZC1rZXkuc2VydmljZSc7XG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQgfSBmcm9tICcuL3R5cGVhaGVhZC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbE1vZHVsZSxcbiAgICAgICAgU2Nyb2xsTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVHlwZWFoZWFkQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEhpZ2hsaWdodERpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbVHlwZWFoZWFkS2V5U2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFJlb3JkZXJhYmxlSGFuZGxlXSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlIHsgfVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3V4UmVvcmRlcmFibGVNb2RlbF0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlIHtcclxuXHJcbiAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBzcGVjaWZ5IGEgbW9kZWwgZm9yIHRoZSBpdGVtIC0gYWxsb3dzIHVzZSB3aXRoIG5nRm9yXHJcbiAgICBASW5wdXQoKSB1eFJlb3JkZXJhYmxlTW9kZWw6IGFueTtcclxuXHJcbiAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHdoaWNoIGluc3RhbmNlIG9mIHRoZSBkaXJlY3RpdmUgcmVsYXRlcyB0byB3aGljaCBlbGVtZW50XHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XHJcbn1cclxuIiwiLy8gV09SS0FST1VORDogbmctcGFja2FnciBpc3N1ZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kaGVyZ2VzL25nLXBhY2thZ3IvaXNzdWVzLzE2M1xuaW1wb3J0IHsgRHJha2UgfSBmcm9tICdkcmFndWxhJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIGRyYWd1bGFOYW1lc3BhY2UgZnJvbSAnZHJhZ3VsYS9kaXN0L2RyYWd1bGEnO1xuXG5leHBvcnQgY29uc3QgZHJhZ3VsYTogKGNvbnRhaW5lcnM/OiBhbnksIG9wdGlvbnM/OiBhbnkpID0+IERyYWtlID0gKGRyYWd1bGFOYW1lc3BhY2UgYXMgYW55KS5kZWZhdWx0IHx8IGRyYWd1bGFOYW1lc3BhY2U7XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERyYWtlLCBEcmFndWxhT3B0aW9ucyB9IGZyb20gJ2RyYWd1bGEnO1xuaW1wb3J0IHsgZHJhZ3VsYSB9IGZyb20gJy4vZHJhZ3VsYSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZVNlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBfZ3JvdXBzOiB7IFtrOiBzdHJpbmddOiBSZW9yZGVyYWJsZUdyb3VwIH0gPSB7fTtcbiAgICBwcml2YXRlIF91bmlxdWVHcm91cElkID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1bmlxdWUgc3RyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGEgZ3JvdXAgbmFtZSBpZiBvbmUgd2FzIG5vdCBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGdldFVuaXF1ZUdyb3VwTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ191eFJlb3JkZXJhYmxlXycgKyB0aGlzLl91bmlxdWVHcm91cElkKys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgY29udGFpbmVyIHRvIHRoZSBuYW1lZCBncm91cC5cbiAgICAgKi9cbiAgICByZWdpc3Rlcihncm91cE5hbWU6IHN0cmluZywgY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcik6IFJlb3JkZXJhYmxlR3JvdXAge1xuXG4gICAgICAgIGlmICghdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdID0gbmV3IFJlb3JkZXJhYmxlR3JvdXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRhaW5lciBmcm9tIHRoZSBuYW1lZCBncm91cC4gSWYgaXQgd2FzIHRoZSBsYXN0IGNvbnRhaW5lciBpbiB0aGUgZ3JvdXAsIGRlc3Ryb3lzIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGdyb3VwTmFtZTogc3RyaW5nLCBjb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcblxuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwLnVucmVnaXN0ZXIoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGRyYWd1bGEgaW5zdGFuY2Ugd2l0aCB0aGUgY3VycmVudCBjb25maWcgYW5kIGF0dGFjaGVzIHRoZSBldmVudHMsIGlmIG5vdCBhbHJlYWR5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZShncm91cE5hbWU6IHN0cmluZyk6IFJlb3JkZXJhYmxlR3JvdXAge1xuXG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV07XG5cbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBncm91cC5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ3JvdXAgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBnZXRHcm91cChncm91cDogc3RyaW5nKTogUmVvcmRlcmFibGVHcm91cCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cHNbZ3JvdXBdO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZUNvbnRhaW5lciB7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICBnZXRNb2RlbEZyb21FbGVtZW50OiAoZWxlbWVudDogRWxlbWVudCkgPT4gYW55O1xuICAgIGNhbk1vdmU6IChlbGVtZW50OiBFbGVtZW50LCBjb250YWluZXI6IEVsZW1lbnQsIGhhbmRsZTogRWxlbWVudCkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZURyYWdFdmVudCB7XG4gICAgbW9kZWw6IGFueTtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIHNvdXJjZTogRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZURyYWdFbmRFdmVudCB7XG4gICAgbW9kZWw6IGFueTtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlRHJvcEV2ZW50IHtcbiAgICBtb2RlbDogYW55O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgdGFyZ2V0OiBFbGVtZW50O1xuICAgIHNvdXJjZTogRWxlbWVudDtcbiAgICBzaWJsaW5nOiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlQ2FuY2VsRXZlbnQge1xuICAgIG1vZGVsOiBhbnk7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZUNsb25lZEV2ZW50IHtcbiAgICBjbG9uZTogRWxlbWVudDtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIHR5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBkcmFnLWFuZC1kcm9wIGNvbnRhaW5lcnMgKHV4UmVvcmRlcmFibGUpIHRoYXQgaXRlbXMgY2FuIGJlIGRyYWdnZWQgYmV0d2Vlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlR3JvdXAge1xuXG4gICAgZHJhZyA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVEcmFnRXZlbnQ+KCk7XG4gICAgZHJhZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVEcmFnRW5kRXZlbnQ+KCk7XG4gICAgZHJvcCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVEcm9wRXZlbnQ+KCk7XG4gICAgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZUNhbmNlbEV2ZW50PigpO1xuICAgIGNsb25lZCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVDbG9uZWRFdmVudD4oKTtcblxuICAgIHByaXZhdGUgX2luc3RhbmNlOiBEcmFrZTtcbiAgICBwcml2YXRlIF9jb250YWluZXJzOiBSZW9yZGVyYWJsZUNvbnRhaW5lcltdID0gW107XG5cbiAgICBwcml2YXRlIF9jb25maWc6IERyYWd1bGFPcHRpb25zID0ge1xuICAgICAgICBtb3ZlczogdGhpcy5jYW5Nb3ZlLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyBjb250YWluZXJzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcnMubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZGVsIG9iamVjdCAodXhSZW9yZGVyYWJsZU1vZGVsKSBmb3IgYW4gZWxlbWVudHMgaW4gb25lIG9mIHRoZSBjb250YWluZXJzIGluIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICBnZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IGFueSB7XG4gICAgICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuX2NvbnRhaW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gY29udGFpbmVyLmdldE1vZGVsRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBjb250YWluZXIgdG8gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVycy5wdXNoKGNvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5jb250YWluZXJzID0gdGhpcy5fY29udGFpbmVycy5tYXAoKGMpID0+IGMuZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5taXJyb3JDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5taXJyb3JDb250YWluZXIgPSBjb250YWluZXIuZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRhaW5lciBmcm9tIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGNvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9jb250YWluZXJzLmluZGV4T2YoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmNvbnRhaW5lcnMgPSB0aGlzLl9jb250YWluZXJzLm1hcCgoYykgPT4gYy5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGRyYWd1bGEgaW5zdGFuY2Ugd2l0aCB0aGUgY3VycmVudCBjb25maWcgYW5kIGF0dGFjaGVzIHRoZSBldmVudHMsIGlmIG5vdCBhbHJlYWR5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gZHJhZ3VsYSh0aGlzLl9jb250YWluZXJzLm1hcCgoYykgPT4gYy5lbGVtZW50KSwgdGhpcy5fY29uZmlnKTtcblxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignZHJhZycsIChlbGVtZW50OiBFbGVtZW50LCBzb3VyY2U6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZy5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignZHJhZ2VuZCcsIChlbGVtZW50OiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxGb3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2Ryb3AnLCAoZWxlbWVudDogRWxlbWVudCwgdGFyZ2V0OiBFbGVtZW50LCBzb3VyY2U6IEVsZW1lbnQsIHNpYmxpbmc6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJvcC5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICBzaWJsaW5nOiBzaWJsaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdjYW5jZWwnLCAoZWxlbWVudDogRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwuZW1pdCh7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxGb3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2Nsb25lZCcsIChjbG9uZTogRWxlbWVudCwgZWxlbWVudDogRWxlbWVudCwgdHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsb25lZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGRyYWd1bGEgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgY29udGFpbmVyIGZvciB0aGUgY29udGFpbmVyRWxlbWVudCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBvZiBjYW5Nb3ZlLlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FuTW92ZShlbGVtZW50OiBFbGVtZW50LCBjb250YWluZXJFbGVtZW50OiBFbGVtZW50LCBoYW5kbGU6IEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgICAgZm9yIChsZXQgY29udGFpbmVyIG9mIHRoaXMuX2NvbnRhaW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZWxlbWVudC5pc1NhbWVOb2RlKGNvbnRhaW5lckVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jYW5Nb3ZlKGVsZW1lbnQsIGNvbnRhaW5lckVsZW1lbnQsIGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUtaGFuZGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS1tb2RlbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVDYW5jZWxFdmVudCwgUmVvcmRlcmFibGVDbG9uZWRFdmVudCwgUmVvcmRlcmFibGVDb250YWluZXIsIFJlb3JkZXJhYmxlRHJhZ0VuZEV2ZW50LCBSZW9yZGVyYWJsZURyYWdFdmVudCwgUmVvcmRlcmFibGVEcm9wRXZlbnQsIFJlb3JkZXJhYmxlU2VydmljZSB9IGZyb20gJy4vcmVvcmRlcmFibGUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4UmVvcmRlcmFibGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHJlb3JkZXJhYmxlTW9kZWw6IEFycmF5PGFueT47XG4gICAgQElucHV0KCkgcmVvcmRlcmFibGVHcm91cDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHJlb3JkZXJpbmdEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyYWJsZU1vZGVsQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxBcnJheTxhbnk+PigpO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJFdmVudD4oKTtcbiAgICBAT3V0cHV0KCkgcmVvcmRlckNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlckV2ZW50PigpO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyRXZlbnQ+KCk7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIGRlc2NlbmRhbnRzOiB0cnVlIH0pIGhhbmRsZXM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcbiAgICBAQ29udGVudENoaWxkcmVuKFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUpIG1vZGVsczogUXVlcnlMaXN0PFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmU+O1xuXG4gICAgcHJpdmF0ZSBfY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcjtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MudXgtcmVvcmRlcmFibGUtY29udGFpbmVyLW1vdmluZycpIGRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIHByaXZhdGUgX3NlcnZpY2U6IFJlb3JkZXJhYmxlU2VydmljZVxuICAgICkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIGRyYWd1bGEgYW5kIGJpbmQgdG8gYWxsIHRoZSByZXF1aXJlZCBldmVudHNcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBJZiBubyBncm91cCBuYW1lIHRoZW4gZ2VuZXJhdGUgYSB1bmlxdWUgb25lIGZvciB0aGlzIGluc3RhbmNlIG9ubHlcbiAgICAgICAgaWYgKCF0aGlzLnJlb3JkZXJhYmxlR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVHcm91cCA9IHRoaXMuX3NlcnZpY2UuZ2V0VW5pcXVlR3JvdXBOYW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICBnZXRNb2RlbEZyb21FbGVtZW50OiB0aGlzLmdldE1vZGVsRnJvbUVsZW1lbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNhbk1vdmU6IHRoaXMuY2FuTW92ZS5iaW5kKHRoaXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgZm9yIGRyYWcgZXZlbnRzIG9uIHRoaXMgZWxlbWVudFxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMuX3NlcnZpY2UucmVnaXN0ZXIodGhpcy5yZW9yZGVyYWJsZUdyb3VwLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5kcmFnLnN1YnNjcmliZSh0aGlzLm9uRHJhZy5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmRyYWdFbmQuc3Vic2NyaWJlKHRoaXMub25EcmFnRW5kLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuZHJvcC5zdWJzY3JpYmUodGhpcy5vbkRyb3AuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5jYW5jZWwuc3Vic2NyaWJlKChldmVudDogUmVvcmRlcmFibGVDYW5jZWxFdmVudCkgPT4gdGhpcy5yZW9yZGVyQ2FuY2VsLmVtaXQoeyBlbGVtZW50OiBldmVudC5lbGVtZW50LCBtb2RlbDogZXZlbnQubW9kZWwgfSkpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuY2xvbmVkLnN1YnNjcmliZSh0aGlzLm9uQ2xvbmUuYmluZCh0aGlzKSkpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2VydmljZS5pbml0aWFsaXplKHRoaXMucmVvcmRlcmFibGVHcm91cCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBkZXN0cm95IHRoZSBkcmFndWxhIGluc3RhbmNlIG9uIGNvbXBvbmVudCBkZXN0cm95XG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UudW5yZWdpc3Rlcih0aGlzLnJlb3JkZXJhYmxlR3JvdXAsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBvbkRyYWcoZXZlbnQ6IFJlb3JkZXJhYmxlRHJhZ0V2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5yZW9yZGVyU3RhcnQuZW1pdCh7IGVsZW1lbnQ6IGV2ZW50LmVsZW1lbnQsIG1vZGVsOiBldmVudC5tb2RlbCB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGZpcmVkIHdoZW4gaXRlbXMgZ2V0IHJlb3JkZXJlZCAtIHdlIG5lZWQgdG8gZW1pdCB0aGUgbmV3IG9yZGVyIG9mIHRoZSBtb2RlbHNcbiAgICAgKi9cbiAgICBvbkRyb3AoZXZlbnQ6IFJlb3JkZXJhYmxlRHJvcEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gcHJvdmlkZWQgbW9kdWxlIHdlIGNhbiBza2lwIHRoaXNcbiAgICAgICAgaWYgKCF0aGlzLnJlb3JkZXJhYmxlTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZS5pc1NhbWVOb2RlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpIHtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgbW9kZWwgZnJvbSB0aGUgbGlzdCBvZiBtb2RlbHNcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZW9yZGVyYWJsZU1vZGVsLmluZGV4T2YoZXZlbnQubW9kZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQuaXNTYW1lTm9kZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgcG9zaXRpb24gb2Ygc2libGluZyBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LnNpYmxpbmcgJiYgIWV2ZW50LnNpYmxpbmcuY2xhc3NMaXN0LmNvbnRhaW5zKCdndS1taXJyb3InKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZU1vZGVsLmluZGV4T2YodGhpcy5nZXRNb2RlbEZyb21FbGVtZW50KGV2ZW50LnNpYmxpbmcpKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZU1vZGVsLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBtb2RlbCBhdCBpdHMgbmV3IGxvY2F0aW9uXG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuc3BsaWNlKGluZGV4LCAwLCBldmVudC5tb2RlbCk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVtaXQgZXZlbnQgaWYgYW55IGNoYW5nZXMgd2VyZSBtYWRlXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWxDaGFuZ2UuZW1pdCh0aGlzLnJlb3JkZXJhYmxlTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtb2RlbCBhc3NjaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAgICAgKiBUaGlzIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgaXRlbXMgaGF2ZSB0aGUgZHJhZ2dhYmxlIG1vZGVsIGRpcmVjdGl2ZSBhcHBsaWVkXG4gICAgICovXG4gICAgZ2V0TW9kZWxGcm9tRWxlbWVudChlbGVtZW50OiBFbGVtZW50KTogYW55IHtcblxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWxzLmZpbmQoX21vZGVsID0+IF9tb2RlbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsLnV4UmVvcmRlcmFibGVNb2RlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGZpbmlzaCBkcmFnZ2luZyByZW1vdmUgdGhlIHV0aWxsaXR5IGNsYXNzIGZyb20gdGhlIGVsZW1lbnQgYmVpbmcgbW92ZWRcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZXZlbnQ6IFJlb3JkZXJhYmxlRHJhZ0VuZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQuZWxlbWVudCkpIHtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZXZlbnQuZWxlbWVudCwgJ3V4LXJlb3JkZXJhYmxlLW1vdmluZycpO1xuXG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZXZlbnQuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBtb2RlbDogZXZlbnQubW9kZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byBlbnN1cmUgdGhhdCB0aGUgY2xvbmVkIGVsZW1lbnQgaXMgaWRlbnRpY2FsXG4gICAgICogdG8gdGhlIG9yaWdpbmFsLCByZWdhcmRsZXNzIG9mIGl0J3MgbG9jYXRpb24gaW4gdGhlIERPTSB0cmVlXG4gICAgICovXG4gICAgb25DbG9uZShldmVudDogUmVvcmRlcmFibGVDbG9uZWRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQuZWxlbWVudCkpIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZUNlbGxXaWR0aHMoZXZlbnQuZWxlbWVudCwgZXZlbnQuY2xvbmUpO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzZXMoZXZlbnQuZWxlbWVudCwgZXZlbnQuY2xvbmUpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhldmVudC5lbGVtZW50LCAndXgtcmVvcmRlcmFibGUtbW92aW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBlbGVtZW50cyBjb250YWluIGhhbmRsZXMgdGhlbiBvbmx5IGRyYWcgd2hlbiB0aGUgaGFuZGxlIGlzIGRyYWdnZWRcbiAgICAgKiBvdGhlcndpc2UgZHJhZyB3aGVuZXZlciBhbiBpbW1lZGlhdGUgY2hpbGQgaXMgc3BlY2lmaWVkXG4gICAgICovXG4gICAgY2FuTW92ZShlbGVtZW50OiBFbGVtZW50LCBjb250YWluZXI6IEVsZW1lbnQsIGhhbmRsZTogRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5yZW9yZGVyaW5nRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVzLmxlbmd0aCA9PT0gMCA/IHRydWUgOiAhIXRoaXMuaGFuZGxlcy5maW5kKF9oYW5kbGUgPT4gX2hhbmRsZS5uYXRpdmVFbGVtZW50ID09PSBoYW5kbGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VGFibGVDZWxsV2lkdGhzKHNvdXJjZTogRWxlbWVudCwgdGFyZ2V0OiBFbGVtZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgbm90IGEgdGFibGUgcm93IHRoZW4gc2tpcCB0aGlzXG4gICAgICAgIGlmIChzb3VyY2UudGFnTmFtZSAhPT0gJ1RSJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBhbnkgaW1tZWRpYXRlIHRkIGNoaWxkcmVuIGFuZCBmaXggdGhlaXIgd2lkdGhcbiAgICAgICAgY29uc3Qgc291cmNlQ2VsbHMgPSBBcnJheS5mcm9tKHNvdXJjZS5jaGlsZHJlbikgYXMgSFRNTFRhYmxlQ2VsbEVsZW1lbnRbXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2VsbHMgPSBBcnJheS5mcm9tKHRhcmdldC5jaGlsZHJlbikgYXMgSFRNTFRhYmxlQ2VsbEVsZW1lbnRbXTtcblxuICAgICAgICAvLyBmaXggdGhlIHdpZHRoIG9mIHRoZXNlIGNlbGxzXG4gICAgICAgIHNvdXJjZUNlbGxzLmZvckVhY2goKGNlbGwsIGlkeCkgPT4gdGFyZ2V0Q2VsbHNbaWR4XS5zdHlsZS5taW5XaWR0aCA9IGdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYXB0dXJlQ2FudmFzZXMoc291cmNlOiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIGFsbCBjaGlsZCBjYW52YXMgZWxlbWVudHNcbiAgICAgICAgY29uc3Qgc291cmNlQ2FudmFzZXMgPSBBcnJheS5mcm9tKHNvdXJjZS5xdWVyeVNlbGVjdG9yQWxsKCdjYW52YXMnKSk7XG4gICAgICAgIGNvbnN0IHRhcmdldENhbnZhc2VzID0gQXJyYXkuZnJvbSh0YXJnZXQucXVlcnlTZWxlY3RvckFsbCgnY2FudmFzJykpO1xuXG4gICAgICAgIC8vIHJlcGxpY2F0ZSB0aGUgY2FudmFzIGNvbnRlbnRcbiAgICAgICAgdGFyZ2V0Q2FudmFzZXMubWFwKGNhbnZhcyA9PiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChjb250ZXh0LCBpZHgpID0+IGNvbnRleHQuZHJhd0ltYWdlKHNvdXJjZUNhbnZhc2VzW2lkeF0sIDAsIDApKTtcblxuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJFdmVudCB7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICBtb2RlbDogYW55O1xufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZURpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLW1vZGVsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZVNlcnZpY2UgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmVvcmRlcmFibGVEaXJlY3RpdmUsXG4gICAgICAgIFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlLFxuICAgICAgICBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJlb3JkZXJhYmxlRGlyZWN0aXZlLFxuICAgICAgICBSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSxcbiAgICAgICAgUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJlb3JkZXJhYmxlU2VydmljZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBGYWNldCB9IGZyb20gJy4vbW9kZWxzL2ZhY2V0JztcblxuZXhwb3J0IGNsYXNzIEZhY2V0U2VsZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFjZXQ6IEZhY2V0KSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRmFjZXREZXNlbGVjdCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGZhY2V0OiBGYWNldCkge31cbn1cblxuZXhwb3J0IGNsYXNzIEZhY2V0RGVzZWxlY3RBbGwge1xuICAgIGNvbnN0cnVjdG9yKCkge31cbn1cblxuZXhwb3J0IHR5cGUgRmFjZXRFdmVudCA9IEZhY2V0U2VsZWN0IHwgRmFjZXREZXNlbGVjdCB8IEZhY2V0RGVzZWxlY3RBbGw7IiwiaW1wb3J0IHsgTGl2ZUFubm91bmNlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJlb3JkZXJFdmVudCB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvaW5kZXgnO1xuaW1wb3J0IHsgRmFjZXREZXNlbGVjdCwgRmFjZXREZXNlbGVjdEFsbCwgRmFjZXRFdmVudCwgRmFjZXRTZWxlY3QgfSBmcm9tICcuL2ZhY2V0LWV2ZW50cyc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4vbW9kZWxzL2ZhY2V0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1jb250YWluZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mYWNldC1jb250YWluZXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0Q29udGFpbmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nID0gJ1NlbGVjdGVkOic7XG4gICAgQElucHV0KCkgY2xlYXJUb29sdGlwOiBzdHJpbmcgPSAnQ2xlYXIgQWxsJztcbiAgICBASW5wdXQoKSBlbXB0eVRleHQ6IHN0cmluZyA9ICdObyBJdGVtcyc7XG4gICAgQElucHV0KCkgZmFjZXRzOiBGYWNldFtdID0gW107XG4gICAgQElucHV0KCkgZmFjZXRzUmVvcmRlcmFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKSBmYWNldHNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGYWNldFtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXRbXT4oKTtcbiAgICBAT3V0cHV0KCkgZXZlbnRzOiBFdmVudEVtaXR0ZXI8RmFjZXRFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPEZhY2V0RXZlbnQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9hbm5vdW5jZXI6IExpdmVBbm5vdW5jZXIpIHsgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXZlbnRzLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0RmFjZXQoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG4gICAgICAgIC8vIHB1c2ggdGhlIGZhY2V0IG9uIHRvIHRoZSBsaXN0XG4gICAgICAgIHRoaXMuZmFjZXRzLnB1c2goZmFjZXQpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdHdvIHdheSBiaW5kaW5nXG4gICAgICAgIHRoaXMuZmFjZXRzQ2hhbmdlLmVtaXQodGhpcy5mYWNldHMpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0U2VsZWN0KGZhY2V0KSk7XG4gICAgfVxuXG4gICAgZGVzZWxlY3RGYWNldChmYWNldDogRmFjZXQsIHRhZz86IEhUTUxFbGVtZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gaW4gdGhlIHNlbGVjdGVkIGFycmF5XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZmFjZXRzLmZpbmRJbmRleChzZWxlY3RlZEZhY2V0ID0+IGZhY2V0ID09PSBzZWxlY3RlZEZhY2V0KTtcblxuICAgICAgICAvLyBpZiBtYXRjaCB0aGVyZSB3YXMgbm8gbWF0Y2ggdGhlbiBmaW5pc2hcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbGFzdCBpdGVtXG4gICAgICAgIHRoaXMuZmFjZXRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdHdvIHdheSBiaW5kaW5nXG4gICAgICAgIHRoaXMuZmFjZXRzQ2hhbmdlLmVtaXQodGhpcy5mYWNldHMpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0RGVzZWxlY3QoZmFjZXQpKTtcblxuICAgICAgICAvLyBhbm5vdW5jZSB0aGUgZmFjZXQgcmVtb3ZhbFxuICAgICAgICB0aGlzLl9hbm5vdW5jZXIuYW5ub3VuY2UoYE9wdGlvbiAke2ZhY2V0LnRpdGxlfSBkZXNlbGVjdGVkLmAsICdhc3NlcnRpdmUnKTtcblxuICAgICAgICAvLyBmb2N1cyBhbm90aGVyIHRhZyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHRhZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIHx8IHRhZy5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2libGluZyB0aGVuIGZvY3VzIGl0XG4gICAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgICAgIChzaWJsaW5nIGFzIEhUTUxFbGVtZW50KS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3RBbGxGYWNldHMoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZW1wdHkgdGhlIHNlbGVjdGVkIGFycmF5XG4gICAgICAgIHRoaXMuZmFjZXRzID0gW107XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0d28gd2F5IGJpbmRpbmdcbiAgICAgICAgdGhpcy5mYWNldHNDaGFuZ2UuZW1pdCh0aGlzLmZhY2V0cyk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudFxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXREZXNlbGVjdEFsbCgpKTtcblxuICAgICAgICAvLyBhbm5vdW5jZSB0aGUgZmFjZXQgcmVtb3ZhbFxuICAgICAgICB0aGlzLl9hbm5vdW5jZXIuYW5ub3VuY2UoYEFsbCBvcHRpb25zIGRlc2VsZWN0ZWQuYCwgJ2Fzc2VydGl2ZScpO1xuICAgIH1cblxuICAgIHRyYWNrQnkoX2luZGV4OiBudW1iZXIsIGZhY2V0OiBGYWNldCk6IHN0cmluZyB8IG51bWJlciB7XG4gICAgICAgIHJldHVybiBmYWNldC5pZCB8fCBmYWNldC50aXRsZTtcbiAgICB9XG5cbiAgICBzaGlmdFJpZ2h0KGZhY2V0OiBGYWNldCwgZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gb25seSBtb3ZlIHRoZSBpdGVtIGlmIHJlb3JkZXJpbmcgaXMgYWxsb3dlZFxuICAgICAgICBpZiAodGhpcy5mYWNldHNSZW9yZGVyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIG1vdmVtZW50XG4gICAgICAgIHRoaXMuc2hpZnRGYWNldChmYWNldCwgMSk7XG5cbiAgICAgICAgLy8gdGhlIGl0ZW0gbWF5IGJlY29tZSB1bmZvY3VzZWQgZHVyaW5nIHRoZSByZW9yZGVyIHNvIHdlIHNob3VsZCByZWZvY3VzIGl0XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBlbGVtZW50LmZvY3VzKCkpO1xuXG4gICAgICAgIC8vIGFubm91bmNlIHRoZSBtb3ZlXG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgT3B0aW9uICR7ZmFjZXQudGl0bGV9IG1vdmVkIGRvd24uYCk7XG4gICAgfVxuXG4gICAgc2hpZnRMZWZ0KGZhY2V0OiBGYWNldCwgZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gb25seSBtb3ZlIHRoZSBpdGVtIGlmIHJlb3JkZXJpbmcgaXMgYWxsb3dlZFxuICAgICAgICBpZiAodGhpcy5mYWNldHNSZW9yZGVyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIG1vdmVtZW50XG4gICAgICAgIHRoaXMuc2hpZnRGYWNldChmYWNldCwgLTEpO1xuXG4gICAgICAgIC8vIHRoZSBpdGVtIG1heSBiZWNvbWUgdW5mb2N1c2VkIGR1cmluZyB0aGUgcmVvcmRlciBzbyB3ZSBzaG91bGQgcmVmb2N1cyBpdFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZWxlbWVudC5mb2N1cygpKTtcblxuICAgICAgICAvLyBhbm5vdW5jZSB0aGUgbW92ZVxuICAgICAgICB0aGlzLl9hbm5vdW5jZXIuYW5ub3VuY2UoYE9wdGlvbiAke2ZhY2V0LnRpdGxlfSBtb3ZlZCB1cC5gKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNoaWZ0RmFjZXQoZmFjZXQ6IEZhY2V0LCBkaXN0YW5jZTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5mYWNldHMuaW5kZXhPZihmYWNldCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGluZGV4ICsgZGlzdGFuY2U7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBtb3ZlIGlzIHZhbGlkXG4gICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHRhcmdldCA9PT0gdGhpcy5mYWNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBtb3ZlXG4gICAgICAgIHRoaXMuZmFjZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuZmFjZXRzLnNwbGljZSh0YXJnZXQsIDAsIGZhY2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRyaWdnZXJFdmVudChldmVudDogRmFjZXRFdmVudCkge1xuICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KGV2ZW50KTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmFjZXRSZW9yZGVyRXZlbnQgZXh0ZW5kcyBSZW9yZGVyRXZlbnQge1xuICAgIGluZGV4OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3QsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRmFjZXRDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuLi8uLi9mYWNldC1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0RGVzZWxlY3QsIEZhY2V0RGVzZWxlY3RBbGwsIEZhY2V0RXZlbnQsIEZhY2V0U2VsZWN0IH0gZnJvbSAnLi4vLi4vZmFjZXQtZXZlbnRzJztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2ZhY2V0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1iYXNlJyxcbiAgICB0ZW1wbGF0ZTogJycsXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBGYWNldFtdID0gW107XG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmFjZXRbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZhY2V0W10+KCk7XG4gICAgQE91dHB1dCgpIGV2ZW50czogU3ViamVjdDxGYWNldEV2ZW50PiA9IG5ldyBTdWJqZWN0PEZhY2V0RXZlbnQ+KCk7XG5cbiAgICBwcm90ZWN0ZWQgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvciggQEhvc3QoKSBwcml2YXRlIGZhY2V0Q29udGFpbmVyOiBGYWNldENvbnRhaW5lckNvbXBvbmVudCwgcHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG5cbiAgICAgICAgaWYgKGZhY2V0Q29udGFpbmVyKSB7XG5cbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBhbnkgZGVzZWxlY3QgZXZlbnRzIGZyb20gdGhlIGZhY2V0IGNvbnRhaW5lclxuICAgICAgICAgICAgZmFjZXRDb250YWluZXIuZXZlbnRzLnBpcGUoXG4gICAgICAgICAgICAgICAgZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgRmFjZXREZXNlbGVjdCksXG4gICAgICAgICAgICAgICAgZmlsdGVyKChldmVudDogRmFjZXREZXNlbGVjdCkgPT4gISF0aGlzLnNlbGVjdGVkLmZpbmQoZmFjZXQgPT4gZmFjZXQgPT09IGV2ZW50LmZhY2V0KSksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgICAgICkuc3Vic2NyaWJlKChldmVudDogRmFjZXREZXNlbGVjdCkgPT4gdGhpcy5kZXNlbGVjdEZhY2V0KGV2ZW50LmZhY2V0KSk7XG5cbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBhbnkgZGVzZWxlY3QgYWxsIGV2ZW50cyBmcm9tIGZhY2V0IGNvbnRhaW5lclxuICAgICAgICAgICAgZmFjZXRDb250YWluZXIuZXZlbnRzLnBpcGUoXG4gICAgICAgICAgICAgICAgZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgRmFjZXREZXNlbGVjdEFsbCksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgICAgICkuc3Vic2NyaWJlKF8gPT4gdGhpcy5kZXNlbGVjdEFsbCgpKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIHNob3VsZCBiZSBhbnkgZmFjZXRzIGluaXRpYWxseSBzZWxlY3RlZFxuICAgICAgICBpZiAodGhpcy5mYWNldENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5mb3JFYWNoKGZhY2V0ID0+IHRoaXMuZmFjZXRDb250YWluZXIuc2VsZWN0RmFjZXQoZmFjZXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RGYWNldChmYWNldDogRmFjZXQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGUgZmFjZXQgaXMgZGlzYWJsZWQgaXQgc2hvdWxkIG5vdCBiZSBzZWxlY3RlZFxuICAgICAgICBpZiAoZmFjZXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgZmFjZXQgdG8gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgZmFjZXRzXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQucHVzaChmYWNldCk7XG5cbiAgICAgICAgLy8gc2VuZCB0aGUgbmV3IHZhbHVlIHRvIHRoZSBldmVudCBlbWl0dGVyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkKTtcblxuICAgICAgICAvLyBmaXJlIHRoZSBldmVudCB0byB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXRTZWxlY3QoZmFjZXQpKTtcblxuICAgICAgICAvLyB0ZWxsIHRoZSBmYWNldCBjb250YWluZXIgYWJvdXQgdGhlIHNlbGVjdGVkIGZhY2V0XG4gICAgICAgIGlmICh0aGlzLmZhY2V0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmZhY2V0Q29udGFpbmVyLnNlbGVjdEZhY2V0KGZhY2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc2VsZWN0RmFjZXQoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCBmYWNldCB0byByZW1vdmVcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnNlbGVjdGVkLmZpbmRJbmRleChzZWxlY3RlZEZhY2V0ID0+IHNlbGVjdGVkRmFjZXQgPT09IGZhY2V0KTtcblxuICAgICAgICAvLyBvbmx5IGNvbnRpbnVlIGlmIGZhY2V0IGlzIGZvdW5kXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBmYWNldCBmcm9tIHRoZSBzZWxlY3RlZCBsaXN0XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZXMgdG8gc2VsZWN0ZWQgZXZlbnQgZW1pdHRlclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHRoZSBldmVudCB0byB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0RGVzZWxlY3QoZmFjZXQpKTtcblxuICAgICAgICAgICAgLy8gZGVzZWxlY3QgdGhlIGZhY2V0IGluIHRoZSBmYWNldCBjb250YWluZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmZhY2V0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWNldENvbnRhaW5lci5kZXNlbGVjdEZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgc2VsZWN0ZWQgZmFjZXRzXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBbXTtcblxuICAgICAgICAvLyBmaXJlIHRoZSBldmVudCB0byB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXREZXNlbGVjdEFsbCgpKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBjaGFuZ2VzIHRvIHRoZSBzZWxlY3RlZCBldmVudCBlbWl0dGVyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICB0b2dnbGVGYWNldFNlbGVjdGlvbihmYWNldDogRmFjZXQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGUgZmFjZXQgaXMgc2VsZWN0ZWQgdGhlbiBkZXNlbGVjdCAtIG90aGVyd2lzZSBzZWxlY3QgaXRcbiAgICAgICAgaWYgKHRoaXMuaXNGYWNldFNlbGVjdGVkKGZhY2V0KSkge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEZhY2V0KGZhY2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpc0ZhY2V0U2VsZWN0ZWQoZmFjZXQ6IEZhY2V0KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIGRldGVybWluZSBpZiBhIGZhY2V0IGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgICAgICByZXR1cm4gISF0aGlzLnNlbGVjdGVkLmZpbmQoc2VsZWN0ZWRGYWNldCA9PiBzZWxlY3RlZEZhY2V0ID09PSBmYWNldCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRXZlbnQoZXZlbnQ6IEZhY2V0RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dChldmVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmFjZXQtaGVhZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdyb2xlJzogJ2J1dHRvbicsXG4gICAgICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAgICAgJyhjbGljayknOiAndG9nZ2xlRXhwYW5kKCknLFxuICAgICAgICAnKGtleXVwLmVudGVyKSc6ICd0b2dnbGVFeHBhbmQoKScsXG4gICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdleHBhbmRlZCcsXG4gICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdoZWFkZXIgKyBcXCcgRmFjZXQ6IEFjdGl2YXRlIHRvIFxcJyArIChleHBhbmRlZCA/IFxcJ2NvbGxhcHNlXFwnIDogXFwnZXhwYW5kXFwnKSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0SGVhZGVyQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGNhbkV4cGFuZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZXhwYW5kZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBPdXRwdXQoKSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgdG9nZ2xlRXhwYW5kKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIG5vdCBleHBhbmRhYmxlIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5jYW5FeHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBGb2N1c2FibGVPcHRpb24gfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWNoZWNrLWxpc3QtaXRlbScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZhY2V0LWNoZWNrLWxpc3QtaXRlbS5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRDaGVja0xpc3RJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgRm9jdXNhYmxlT3B0aW9uIHtcblxuICAgIEBJbnB1dCgpIGZhY2V0OiBGYWNldCA9IG51bGw7XG4gICAgQElucHV0KCkgc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSB0YWJiYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXQ+KCk7XG4gICAgQE91dHB1dCgpIGl0ZW1Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgaXRlbUJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQFZpZXdDaGlsZCgnb3B0aW9uJykgb3B0aW9uOiBFbGVtZW50UmVmO1xuXG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWNldCAmJiB0aGlzLmZhY2V0LmRpc2FibGVkO1xuICAgIH1cblxuICAgIGdldExhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0ID8gdGhpcy5mYWNldC50aXRsZSA6ICcnO1xuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wdGlvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRm9jdXNLZXlNYW5hZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBJbnB1dCwgUXVlcnlMaXN0LCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEZhY2V0QmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2UvZmFjZXQtYmFzZS9mYWNldC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uL21vZGVscy9mYWNldCc7XG5pbXBvcnQgeyBGYWNldENoZWNrTGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2NoZWNrLWxpc3QtaXRlbS9mYWNldC1jaGVjay1saXN0LWl0ZW0uY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1jaGVjay1saXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmFjZXQtY2hlY2stbGlzdC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRDaGVja0xpc3RDb21wb25lbnQgZXh0ZW5kcyBGYWNldEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIEBJbnB1dCgpIGZhY2V0czogRmFjZXRbXSA9IFtdO1xuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNjcm9sbGJhcjogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZXhwYW5kZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQFZpZXdDaGlsZHJlbihGYWNldENoZWNrTGlzdEl0ZW1Db21wb25lbnQpIG9wdGlvbnM6IFF1ZXJ5TGlzdDxGYWNldENoZWNrTGlzdEl0ZW1Db21wb25lbnQ+O1xuXG4gICAgaXNGb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgYWN0aXZlSW5kZXg6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIF9mb2N1c0tleU1hbmFnZXI6IEZvY3VzS2V5TWFuYWdlcjxGYWNldENoZWNrTGlzdEl0ZW1Db21wb25lbnQ+O1xuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIgPSBuZXcgRm9jdXNLZXlNYW5hZ2VyKHRoaXMub3B0aW9ucylcbiAgICAgICAgICAgIC53aXRoVmVydGljYWxPcmllbnRhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5jaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMuYWN0aXZlSW5kZXggPSBpbmRleCk7XG4gICAgfVxuXG4gICAgb25Gb2N1cyhpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c0tleU1hbmFnZXIuYWN0aXZlSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0oaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgIH1cblxuICAgIHRvZ2dsZUZhY2V0KGluZGV4OiBudW1iZXIsIGZhY2V0OiBGYWNldCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRvZ2dsZUZhY2V0U2VsZWN0aW9uKGZhY2V0KTtcbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0oaW5kZXgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBGb2N1c2FibGVPcHRpb24gfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LXR5cGVhaGVhZC1saXN0LWl0ZW0nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mYWNldC10eXBlYWhlYWQtbGlzdC1pdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldFR5cGVhaGVhZExpc3RJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgRm9jdXNhYmxlT3B0aW9uIHtcblxuICAgIEBJbnB1dCgpIGZhY2V0OiBGYWNldDtcbiAgICBASW5wdXQoKSBzZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNpbXBsaWZpZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSB0YWJiYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQE91dHB1dCgpIGl0ZW1Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEZhY2V0PigpO1xuXG4gICAgQFZpZXdDaGlsZCgnb3B0aW9uJykgb3B0aW9uOiBFbGVtZW50UmVmO1xuXG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWNldCAmJiB0aGlzLmZhY2V0LmRpc2FibGVkO1xuICAgIH1cblxuICAgIGdldExhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0ID8gdGhpcy5mYWNldC50aXRsZSA6IG51bGw7XG4gICAgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3B0aW9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBGb2N1c0tleU1hbmFnZXIsIExpdmVBbm5vdW5jZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBQaXBlLCBQaXBlVHJhbnNmb3JtLCBRdWVyeUxpc3QsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgeyBtYXAsIG1lcmdlTWFwLCB0YWtlVW50aWwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFR5cGVhaGVhZEtleVNlcnZpY2UsIFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IEZhY2V0QmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2UvZmFjZXQtYmFzZS9mYWNldC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldENvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4uL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi9tb2RlbHMvZmFjZXQnO1xuaW1wb3J0IHsgRmFjZXRUeXBlYWhlYWRMaXN0SXRlbUNvbXBvbmVudCB9IGZyb20gJy4vdHlwZWFoZWFkLWxpc3QtaXRlbS9mYWNldC10eXBlYWhlYWQtbGlzdC1pdGVtLmNvbXBvbmVudCc7XG5cbmxldCB1bmlxdWVJZCA9IDE7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtdHlwZWFoZWFkLWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mYWNldC10eXBlYWhlYWQtbGlzdC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRUeXBlYWhlYWRMaXN0Q29tcG9uZW50IGV4dGVuZHMgRmFjZXRCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBASW5wdXQoKSBmYWNldHM6IEZhY2V0W10gfCBPYnNlcnZhYmxlPEZhY2V0W10+O1xuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzdWdnZXN0aW9uczogRmFjZXRbXSA9IFtdO1xuICAgIEBJbnB1dCgpIHNpbXBsaWZpZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgdHlwZWFoZWFkQ29uZmlnKGNvbmZpZzogRmFjZXRUeXBlYWhlYWRMaXN0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHsgcGxhY2Vob2xkZXI6ICcnLCBtYXhSZXN1bHRzOiA1MCwgbWluQ2hhcmFjdGVyczogMSwgLi4uY29uZmlnIH07XG4gICAgfVxuXG4gICAgZ2V0IHR5cGVhaGVhZENvbmZpZygpOiBGYWNldFR5cGVhaGVhZExpc3RDb25maWcge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICAgIH1cblxuICAgIEBWaWV3Q2hpbGRyZW4oRmFjZXRUeXBlYWhlYWRMaXN0SXRlbUNvbXBvbmVudCkgb3B0aW9uczogUXVlcnlMaXN0PEZhY2V0VHlwZWFoZWFkTGlzdEl0ZW1Db21wb25lbnQ+O1xuXG4gICAgcXVlcnkkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KCcnKTtcbiAgICBsb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gICAgYWN0aXZlSW5kZXg6IG51bWJlciA9IDA7XG4gICAgdHlwZWFoZWFkSWQ6IHN0cmluZyA9IGB1eC1mYWNldC10eXBlYWhlYWQtJHt1bmlxdWVJZCsrfWA7XG4gICAgdHlwZWFoZWFkT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHR5cGVhaGVhZE9wdGlvbnM6IEZhY2V0W10gPSBbXTtcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBGYWNldFR5cGVhaGVhZExpc3RDb25maWcgPSB7IHBsYWNlaG9sZGVyOiAnJywgbWF4UmVzdWx0czogNTAsIG1pbkNoYXJhY3RlcnM6IDEgfTtcbiAgICBwcml2YXRlIF9mb2N1c0tleU1hbmFnZXI6IEZvY3VzS2V5TWFuYWdlcjxGYWNldFR5cGVhaGVhZExpc3RJdGVtQ29tcG9uZW50PjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0eXBlYWhlYWRLZXlTZXJ2aWNlOiBUeXBlYWhlYWRLZXlTZXJ2aWNlLCBmYWNldENvbnRhaW5lcjogRmFjZXRDb250YWluZXJDb21wb25lbnQsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX2Fubm91bmNlcjogTGl2ZUFubm91bmNlcikge1xuICAgICAgICBzdXBlcihmYWNldENvbnRhaW5lciwgZWxlbWVudFJlZik7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHNldCB1cCBzZWFyY2ggcXVlcnkgc3Vic2NyaXB0aW9uXG4gICAgICAgIHRoaXMucXVlcnkkLnBpcGUoXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSxcbiAgICAgICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVhaGVhZE9wdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWVyZ2VNYXAoKCkgPT4gdGhpcy5nZXRGYWNldE9ic2VydmFibGUoKS5waXBlKG1hcChmYWNldHMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWNldHMuZmlsdGVyKGZhY2V0ID0+ICFmYWNldC5kaXNhYmxlZCAmJiAhdGhpcy5zZWxlY3RlZC5maW5kKHNlbGVjdGVkRmFjZXQgPT4gc2VsZWN0ZWRGYWNldCA9PT0gZmFjZXQpKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgdGhpcy5fY29uZmlnLm1heFJlc3VsdHMpO1xuICAgICAgICAgICAgfSkpKVxuICAgICAgICApLnN1YnNjcmliZShmYWNldHMgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnR5cGVhaGVhZE9wdGlvbnMgPSBmYWNldHM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIodGhpcy5vcHRpb25zKS53aXRoVmVydGljYWxPcmllbnRhdGlvbigpO1xuICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIuY2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShpbmRleCA9PiB0aGlzLmFjdGl2ZUluZGV4ID0gaW5kZXgpO1xuICAgIH1cblxuICAgIG9uS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICB9XG5cbiAgICBvbkZvY3VzKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGVGYWNldChpbmRleDogbnVtYmVyLCBmYWNldDogRmFjZXQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50b2dnbGVGYWNldFNlbGVjdGlvbihmYWNldCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICB9XG5cbiAgICAvKiogT25seSBzaG93IHR5cGVhaGVhZCBpZiB3ZSBoYXZlIGVub3VnaCBjaGFyYWN0ZXJzICovXG4gICAgdXBkYXRlVHlwZWFoZWFkKHF1ZXJ5OiBzdHJpbmcgPSAnJyk6IHZvaWQge1xuICAgICAgICB0aGlzLnR5cGVhaGVhZE9wZW4gPSBxdWVyeS5sZW5ndGggPj0gdGhpcy5fY29uZmlnLm1pbkNoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgZ2V0RmFjZXRPYnNlcnZhYmxlKCk6IE9ic2VydmFibGU8RmFjZXRbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWNldHMgaW5zdGFuY2VvZiBPYnNlcnZhYmxlID8gdGhpcy5mYWNldHMgOiBvZih0aGlzLmZhY2V0cyk7XG4gICAgfVxuXG4gICAgc2VsZWN0KGV2ZW50OiBUeXBlYWhlYWRPcHRpb25FdmVudCkge1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBpdGVtIGlzIG5vdCBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuZmluZChmYWNldCA9PiBmYWNldCA9PT0gZXZlbnQub3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VsZWN0IHRoZSBmYWNldFxuICAgICAgICB0aGlzLnNlbGVjdEZhY2V0KGV2ZW50Lm9wdGlvbik7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHR5cGVhaGVhZFxuICAgICAgICB0aGlzLnF1ZXJ5JC5uZXh0KCcnKTtcblxuICAgICAgICAvLyBhbm5vdW5jZSB0aGUgc2VsZWN0ZWQgZmFjZXRcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VyLmFubm91bmNlKGAkeyhldmVudC5vcHRpb24gYXMgRmFjZXQpLnRpdGxlfSBzZWxlY3RlZC5gKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmFjZXRUeXBlYWhlYWRMaXN0Q29uZmlnIHtcbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICBtaW5DaGFyYWN0ZXJzPzogbnVtYmVyO1xuICAgIG1heFJlc3VsdHM/OiBudW1iZXI7XG4gICAgZGVsYXk/OiBudW1iZXI7XG59XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnZmFjZXRUeXBlYWhlYWRIaWdobGlnaHQnXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0IGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcsIHNlYXJjaFF1ZXJ5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKHNlYXJjaFF1ZXJ5LCAnaScpO1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWdleCwgYDxiIGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWhpZ2hsaWdodGVkXCI+JHt2YWx1ZS5tYXRjaChyZWdleCl9PC9iPmApO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBBMTF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENoZWNrYm94TW9kdWxlIH0gZnJvbSAnLi4vY2hlY2tib3gvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgVHlwZWFoZWFkTW9kdWxlIH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IFJlb3JkZXJhYmxlTW9kdWxlIH0gZnJvbSAnLi8uLi8uLi9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLm1vZHVsZSc7XG5pbXBvcnQgeyBGYWNldEJhc2VDb21wb25lbnQgfSBmcm9tICcuL2Jhc2UvZmFjZXQtYmFzZS9mYWNldC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldEhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vYmFzZS9mYWNldC1oZWFkZXIvZmFjZXQtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldENoZWNrTGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2ZhY2V0LWNoZWNrLWxpc3QvY2hlY2stbGlzdC1pdGVtL2ZhY2V0LWNoZWNrLWxpc3QtaXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXRDaGVja0xpc3RDb21wb25lbnQgfSBmcm9tICcuL2ZhY2V0LWNoZWNrLWxpc3QvZmFjZXQtY2hlY2stbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXRDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXRUeXBlYWhlYWRIaWdobGlnaHQsIEZhY2V0VHlwZWFoZWFkTGlzdENvbXBvbmVudCB9IGZyb20gJy4vZmFjZXQtdHlwZWFoZWFkLWxpc3QvZmFjZXQtdHlwZWFoZWFkLWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0VHlwZWFoZWFkTGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2ZhY2V0LXR5cGVhaGVhZC1saXN0L3R5cGVhaGVhZC1saXN0LWl0ZW0vZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbS5jb21wb25lbnQnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgRmFjZXRDb250YWluZXJDb21wb25lbnQsXG4gICAgRmFjZXRIZWFkZXJDb21wb25lbnQsXG4gICAgRmFjZXRCYXNlQ29tcG9uZW50LFxuICAgIEZhY2V0Q2hlY2tMaXN0Q29tcG9uZW50LFxuICAgIEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudCxcbiAgICBGYWNldFR5cGVhaGVhZExpc3RDb21wb25lbnQsXG4gICAgRmFjZXRUeXBlYWhlYWRMaXN0SXRlbUNvbXBvbmVudCxcbiAgICBGYWNldFR5cGVhaGVhZEhpZ2hsaWdodFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIENoZWNrYm94TW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgICAgICBSZW9yZGVyYWJsZU1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRzTW9kdWxlIHsgfVxuIiwiZXhwb3J0IGNsYXNzIEZhY2V0IHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIHRpdGxlOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBkYXRhOiBhbnkgPSB7fSxcbiAgICAgICAgcHVibGljIGNvdW50PzogbnVtYmVyLFxuICAgICAgICBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgcHVibGljIGlkPzogc3RyaW5nIHwgbnVtYmVyXG4gICAgKSB7IH1cbn0iLCJpbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ZpbHRlci5pbnRlcmZhY2UnO1xuXG5leHBvcnQgY2xhc3MgRmlsdGVyQWRkRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEZpbHRlcikge31cbn0iLCJleHBvcnQgY2xhc3MgRmlsdGVyUmVtb3ZlQWxsRXZlbnQge30iLCJpbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ZpbHRlci5pbnRlcmZhY2UnO1xuXG5leHBvcnQgY2xhc3MgRmlsdGVyUmVtb3ZlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEZpbHRlcikge31cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IEZpbHRlckFkZEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvZmlsdGVyLWFkZC1ldmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJFdmVudCB9IGZyb20gJy4vZXZlbnRzL2ZpbHRlci1ldmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJSZW1vdmVBbGxFdmVudCB9IGZyb20gJy4vZXZlbnRzL2ZpbHRlci1yZW1vdmUtYWxsLWV2ZW50JztcbmltcG9ydCB7IEZpbHRlclJlbW92ZUV2ZW50IH0gZnJvbSAnLi9ldmVudHMvZmlsdGVyLXJlbW92ZS1ldmVudCc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGaWx0ZXJTZXJ2aWNlIHtcblxuICAgIC8qKiBUaGUgbGlzdCBvZiBhY3RpdmUgZmlsdGVycyAqL1xuICAgIGZpbHRlcnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxGaWx0ZXJbXT4oW10pO1xuXG4gICAgLyoqIEVtaXQgYWxsIHRoZSBldmVudHMgd2hlbiB0aGV5IG9jY3VyICovXG4gICAgZXZlbnRzJCA9IG5ldyBTdWJqZWN0PEZpbHRlckV2ZW50PigpO1xuXG4gICAgYWRkKGZpbHRlcjogRmlsdGVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGZpbHRlciBpcyBhbHJlYWR5IHNlbGVjdGVkIG9yIGl0IGlzIHRoZSBpbnRpYWwgZmlsdGVyIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKGZpbHRlcikgfHwgZmlsdGVyLmluaXRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbGlzdCBvZiBhY3RpdmUgZmlsdGVyc1xuICAgICAgICB0aGlzLmZpbHRlcnMkLm5leHQoWy4uLnRoaXMuZmlsdGVycyQudmFsdWUsIGZpbHRlcl0pO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGV2ZW50XG4gICAgICAgIHRoaXMuZXZlbnRzJC5uZXh0KG5ldyBGaWx0ZXJBZGRFdmVudChmaWx0ZXIpKTtcbiAgICB9XG5cbiAgICByZW1vdmUoZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGUgZmlsdGVyIGlzIG5vdCBzZWxlY3RlZCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQoZmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBsaXN0IG9mIGFjdGl2ZSBmaWx0ZXJzXG4gICAgICAgIHRoaXMuZmlsdGVycyQubmV4dCh0aGlzLmZpbHRlcnMkLnZhbHVlLmZpbHRlcihfZmlsdGVyID0+IF9maWx0ZXIgIT09IGZpbHRlcikpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGV2ZW50XG4gICAgICAgIHRoaXMuZXZlbnRzJC5uZXh0KG5ldyBGaWx0ZXJSZW1vdmVFdmVudChmaWx0ZXIpKTtcbiAgICB9XG5cbiAgICByZW1vdmVBbGwoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZW1wdHkgdGhlIGxpc3Qgb2YgYWN0aXZlIGZpbHRlcnNcbiAgICAgICAgdGhpcy5maWx0ZXJzJC5uZXh0KFtdKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBldmVudFxuICAgICAgICB0aGlzLmV2ZW50cyQubmV4dChuZXcgRmlsdGVyUmVtb3ZlQWxsRXZlbnQoKSk7XG4gICAgfVxuXG4gICAgaXNTZWxlY3RlZChmaWx0ZXI6IEZpbHRlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzJC52YWx1ZS5pbmRleE9mKGZpbHRlcikgPiAtMTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRmlsdGVyRXZlbnQgfSBmcm9tICcuL2V2ZW50cy9maWx0ZXItZXZlbnQnO1xuaW1wb3J0IHsgRmlsdGVyU2VydmljZSB9IGZyb20gJy4vZmlsdGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2ZpbHRlci5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZpbHRlci1jb250YWluZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9maWx0ZXItY29udGFpbmVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFsgRmlsdGVyU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogQWxsb3cgZmlsdGVycyB0byBzZXQgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQgKi9cbiAgICBASW5wdXQoKSBzZXQgZmlsdGVycyhmaWx0ZXJzOiBGaWx0ZXJbXSkgeyB0aGlzLmZpbHRlclNlcnZpY2UuZmlsdGVycyQubmV4dChmaWx0ZXJzKTsgfVxuXG4gICAgLyoqIERlZmluZSB0aGUgdG9vbHRpcCB0ZXh0ICovXG4gICAgQElucHV0KCkgY2xlYXJUb29sdGlwOiBzdHJpbmc7XG5cbiAgICAvKiogRW1pdCB3aGVuIHRoZSBhY3RpdmUgZmlsdGVycyBjaGFuY2UgKi9cbiAgICBAT3V0cHV0KCkgZmlsdGVyc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RmlsdGVyW10+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIGEgc3BlY2lmaWMgZXZlbnQgb2NjdXJzICovXG4gICAgQE91dHB1dCgpIGV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXI8RmlsdGVyRXZlbnQ+KCk7XG5cbiAgICAvKiogVW5zdWJzY3JpYmUgZnJvbSB0aGUgc3Vic2NyaXB0aW9ucyBvbiBkZXN0cm95ICovXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXJTZXJ2aWNlOiBGaWx0ZXJTZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gdGhlIGFjdGl2ZSBmaWx0ZXJzXG4gICAgICAgIGZpbHRlclNlcnZpY2UuZmlsdGVycyQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZmlsdGVycyA9PiB0aGlzLmZpbHRlcnNDaGFuZ2UuZW1pdChmaWx0ZXJzKSk7XG5cbiAgICAgICAgLy8gcmVsYXkgYW55IGV2ZW50cyB0byB0aGUgZXZlbnQgZW1pdHRlclxuICAgICAgICB0aGlzLmZpbHRlclNlcnZpY2UuZXZlbnRzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiB0aGlzLmV2ZW50cy5lbWl0KGV2ZW50KSk7XG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3kgYWxsIHN1YnNjcmlwdGlvbnMgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxufSIsImltcG9ydCB7IExpdmVBbm5vdW5jZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3QsIElucHV0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IEZpbHRlclJlbW92ZUFsbEV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzL2ZpbHRlci1yZW1vdmUtYWxsLWV2ZW50JztcbmltcG9ydCB7IEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4uL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIFRoaXMgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFzIHdlIG5vdyBoYXZlIHRoZSBGaWx0ZXJTZXJ2aWNlXG4gKiB3aGljaCBpcyBlYXNpZXIgdG8gdXNlIHRoYW4gdGhpcyBiYXNlIGNvbXBvbmVudC5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1maWx0ZXItYmFzZSdcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBmaWx0ZXJzOiBGaWx0ZXJbXTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoQEhvc3QoKSBwcml2YXRlIGZpbHRlcnNDb250YWluZXI6IEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCwgcHJpdmF0ZSBfYW5ub3VuY2VyOiBMaXZlQW5ub3VuY2VyKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IGZpbHRlcnNDb250YWluZXIuZXZlbnRzLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgRmlsdGVyUmVtb3ZlQWxsRXZlbnQpKS5zdWJzY3JpYmUodGhpcy5yZW1vdmVGaWx0ZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGFkZEZpbHRlcihfZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFfZmlsdGVyLmluaXRpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc0NvbnRhaW5lci5maWx0ZXJTZXJ2aWNlLmFkZChfZmlsdGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgRmlsdGVyICR7X2ZpbHRlci5uYW1lfSBzZWxlY3RlZC5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUZpbHRlcihfZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFfZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbHRlcnNDb250YWluZXIuZmlsdGVyU2VydmljZS5yZW1vdmUoX2ZpbHRlcik7XG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgRmlsdGVyICR7X2ZpbHRlci5uYW1lfSBkZXNlbGVjdGVkLmApO1xuICAgIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaWx0ZXIgYXMgcnhGaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRmlsdGVyUmVtb3ZlQWxsRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvZmlsdGVyLXJlbW92ZS1hbGwtZXZlbnQnO1xuaW1wb3J0IHsgRmlsdGVyU2VydmljZSB9IGZyb20gJy4uL2ZpbHRlci5zZXJ2aWNlJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmlsdGVyLWRyb3Bkb3duJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmlsdGVyLWRyb3Bkb3duLmNvbXBvbmVudC5odG1sJyxcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyRHJvcGRvd25Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogVGhlIGxpc3Qgb2YgaXRlbXMgdG8gZGlzcGxheSBpbiB0aGUgZHJvcGRvd24gKi9cbiAgICBASW5wdXQoKSBmaWx0ZXJzOiBGaWx0ZXJbXSA9IFtdO1xuXG4gICAgLyoqIERlZmluZSBhbiBpbml0aWFsIGl0ZW0gdG8gc2VsZWN0ICovXG4gICAgQElucHV0KCkgaW5pdGlhbDogRmlsdGVyO1xuXG4gICAgc2VsZWN0ZWQ6IEZpbHRlcjtcblxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9maWx0ZXJTZXJ2aWNlOiBGaWx0ZXJTZXJ2aWNlKSB7XG4gICAgICAgIF9maWx0ZXJTZXJ2aWNlLmV2ZW50cyQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgcnhGaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBGaWx0ZXJSZW1vdmVBbGxFdmVudCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVtb3ZlRmlsdGVyKCkpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBjdXJyZW50IHNlbGVjdGVkIGZpbHRlciBpcyBzdGlsbCBzZWxlY3RlZCB3aGVuIHRoZSBhY3RpdmUgZmlsdGVycyBjaGFuZ2VcbiAgICAgICAgX2ZpbHRlclNlcnZpY2UuZmlsdGVycyQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGZpbHRlcnMgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgZmlsdGVycy5pbmRleE9mKHRoaXMuc2VsZWN0ZWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRmlsdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5pbml0aWFsO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBhbnkgb2YgdGhlIGZpbHRlcnMgaGF2ZSBiZWVuIHByZXNlbGVjdGVkIG9yIGNoYW5nZXMgdG8gc2VsZWN0ZWQgZmlsdGVyc1xuICAgICAgICB0aGlzLl9maWx0ZXJTZXJ2aWNlLmZpbHRlcnMkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShmaWx0ZXJzID0+IHtcbiAgICAgICAgICAgIGZpbHRlcnMuZm9yRWFjaChmaWx0ZXIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihmaWx0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmlsdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0RmlsdGVyKGZpbHRlcjogRmlsdGVyLCBldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmlsdGVyO1xuICAgICAgICB0aGlzLl9maWx0ZXJTZXJ2aWNlLmFkZCh0aGlzLnNlbGVjdGVkKTtcblxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICByZW1vdmVGaWx0ZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNlcnZpY2UucmVtb3ZlKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5pbml0aWFsO1xuICAgIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJzRHJvcGRvd25EaXJlY3RpdmUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2Ryb3Bkb3duJztcbmltcG9ydCB7IFR5cGVhaGVhZE1hdGNoIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC90eXBlYWhlYWQnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgZmlsdGVyIGFzIHJ4RmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFR5cGVhaGVhZEtleVNlcnZpY2UsIFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IEZpbHRlclJlbW92ZUFsbEV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzL2ZpbHRlci1yZW1vdmUtYWxsLWV2ZW50JztcbmltcG9ydCB7IEZpbHRlclNlcnZpY2UgfSBmcm9tICcuLi9maWx0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLWR5bmFtaWMtbGlzdC1jb25maWcuaW50ZXJmYWNlJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5cbmxldCB1bmlxdWVJZCA9IDE7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmlsdGVyLWR5bmFtaWMnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9maWx0ZXItZHluYW1pYy5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyRHluYW1pY0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogVGhlIGxpc3Qgb2YgcG9zc2libGUgZmlsdGVyIG9wdGlvbnMgKi9cbiAgICBASW5wdXQoKSBmaWx0ZXJzOiBGaWx0ZXJbXSA9IFtdO1xuXG4gICAgLyoqIFNwZWNpZnkgaWYgdGhlcmUgc2hvdWxkIGJlIGFuIGluaXRpYWxseSBzZWxlY3RlZCBmaWx0ZXIgKi9cbiAgICBASW5wdXQoKSBpbml0aWFsOiBGaWx0ZXI7XG5cbiAgICAvKiogU3BlY2lmeSB0aGUgdHlwZWFoZWFkIG9wdGlvbnMgKi9cbiAgICBASW5wdXQoKSBzZXQgb3B0aW9ucyhvcHRpb25zOiBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZykgeyB0aGlzLl9vcHRpb25zID0gb3B0aW9uczsgfVxuXG4gICAgLyoqIEdldCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0cyBmb3IgYW55IG1pc3Npbmcgb3B0aW9ucyAqL1xuICAgIGdldCBvcHRpb25zKCk6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uIHRoaXMuX2RlZmF1bHRPcHRpb25zLCAuLi50aGlzLl9vcHRpb25zIH07XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgZHJvcGRvd24gZGlyZWN0aXZlICovXG4gICAgQFZpZXdDaGlsZChCc0Ryb3Bkb3duRGlyZWN0aXZlKSBkcm9wZG93bjogQnNEcm9wZG93bkRpcmVjdGl2ZTtcblxuICAgIC8qKiBHZW5lcmF0ZSBhIHVuaXF1ZSBpZCBmb3IgdGhlIHR5cGVhaGVhZCAqL1xuICAgIHR5cGVhaGVhZElkOiBzdHJpbmcgPSBgdXgtZmlsdGVyLWR5bmFtaWMtdHlwZWFoZWFkLSR7dW5pcXVlSWQrK31gO1xuXG4gICAgLyoqIFN0b3JlIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeSAqL1xuICAgIHF1ZXJ5JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XG5cbiAgICAvKiogU3RvcmUgdGhlIHNlbGVjdGVkIGZpbHRlciAqL1xuICAgIHNlbGVjdGVkOiBGaWx0ZXI7XG5cbiAgICAvKiogSW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIHR5cGVhaGVhZCBzaG91bGQgYmUgc2hvd24gKi9cbiAgICBzaG93VHlwZWFoZWFkOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBTdG9yZSB0aGUgaXRlbXMgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIGluIHRoZSB0eXBlYWhlYWQgKi9cbiAgICB0eXBlYWhlYWRJdGVtczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8qKiBTdG9yZSB0aGUgY3VycmVudGx5IGhpZ2hsaWdodGVkIGVsZW1lbnQgKi9cbiAgICBoaWdobGlnaHRlZEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuXG4gICAgLyoqIFN0b3JlIHRoZSBvcGVuIHN0YXRlIG9mIHRoZSB0eXBlYWhlYWQgKi9cbiAgICB0eXBlYWhlYWRPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogVGhlIGRlZmF1bHQgb3B0aW9ucyAqL1xuICAgIHByaXZhdGUgX2RlZmF1bHRPcHRpb25zOiBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZyA9IHsgcGxhY2Vob2xkZXI6ICcnLCBtaW5DaGFyYWN0ZXJzOiAzLCBtYXhSZXN1bHRzOiBJbmZpbml0eSB9O1xuXG4gICAgLyoqIFN0b3JlIHRoZSB1c2VyIHNwZWNpZmllZCB0eXBlYWhlYWQgb3B0aW9ucyAqL1xuICAgIHByaXZhdGUgX29wdGlvbnM6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnID0geyAuLi50aGlzLl9kZWZhdWx0T3B0aW9ucyB9O1xuXG4gICAgLyoqIFVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnMgKi9cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHR5cGVhaGVhZEtleVNlcnZpY2U6IFR5cGVhaGVhZEtleVNlcnZpY2UsIHByaXZhdGUgX2ZpbHRlclNlcnZpY2U6IEZpbHRlclNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgLy8gbGlzdGVuIGZvciByZW1vdmUgYWxsIGV2ZW50cyBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkZXNlbGVjdCBldmVudCBpbml0aWFsIGZpbHRlcnNcbiAgICAgICAgX2ZpbHRlclNlcnZpY2UuZXZlbnRzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLCByeEZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEZpbHRlclJlbW92ZUFsbEV2ZW50KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZW1vdmVGaWx0ZXIoKSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgZmlsdGVyIGlzIHN0aWxsIHNlbGVjdGVkIHdoZW4gdGhlIGFjdGl2ZSBmaWx0ZXJzIGNoYW5nZVxuICAgICAgICBfZmlsdGVyU2VydmljZS5maWx0ZXJzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZmlsdGVycyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCAmJiBmaWx0ZXJzLmluZGV4T2YodGhpcy5zZWxlY3RlZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFNldCB1cCB0aGUgaW5pdGlhbCBjb25kaXRpb25zICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gVGhlIGluaXRpYWxseSBzZWxlY3RlZCBpdGVtIHNob3VsZCBiZSBzZXQgdGhlIHRoZSBzcGVjaWZpZWQgaW5pdGlhbCBpdGVtXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIHNlbGVjdGVkIGZpbHRlcnNcbiAgICAgICAgdGhpcy5fZmlsdGVyU2VydmljZS5maWx0ZXJzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZmlsdGVycyA9PiB7XG4gICAgICAgICAgICBmaWx0ZXJzLmZvckVhY2goZmlsdGVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzLmluZGV4T2YoZmlsdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZpbHRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBpdGVtcyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHR5cGVhaGVhZFxuICAgICAgICB0aGlzLnR5cGVhaGVhZEl0ZW1zID0gdGhpcy5nZXRJdGVtcygpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB3ZSBzaG91bGQgc2hvdyB0aGUgdHlwZWFoZWFkIGNvbnRyb2xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubWF4SW5kaXZpZHVhbEl0ZW1zICYmIHRoaXMub3B0aW9ucy5tYXhJbmRpdmlkdWFsSXRlbXMgKyAxID49IHRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1R5cGVhaGVhZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENsZWFudXAgYWxsIHN1YnNjcmlwdGlvbnMgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgaXRlbXMgdG8gZGlzcGxheSBpbiB0aGUgdHlwZWFoZWFkIGJhc2VkIG9uIHRoZSBzZWFyY2ggcXVlcnkgKi9cbiAgICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSQudmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMuaW5pdGlhbCAmJiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHF1ZXJ5KSAhPT0gLTEpXG4gICAgICAgICAgICAubWFwKGl0ZW0gPT4gaXRlbS5uYW1lKVxuICAgICAgICAgICAgLnNsaWNlKDAsIHRoaXMuX29wdGlvbnMubWF4UmVzdWx0cyk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSBzZWxlY3Rpb24gb2YgYSB0eXBlYWhlYWQgb3B0aW9ucyAqL1xuICAgIHNlbGVjdE9wdGlvbih0eXBlYWhlYWRPcHRpb246IFR5cGVhaGVhZE1hdGNoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFueSBjdXJyZW50IGZpbHRlcnNcbiAgICAgICAgdGhpcy5yZW1vdmVGaWx0ZXIoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBmaWx0ZXIgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5maWx0ZXJzLmZpbmQoX2ZpbHRlciA9PiBfZmlsdGVyLm5hbWUgPT09IHR5cGVhaGVhZE9wdGlvbi52YWx1ZSk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHNlbGVjdGlvbiBpbiB0aGUgc2VydmljZVxuICAgICAgICB0aGlzLl9maWx0ZXJTZXJ2aWNlLmFkZCh0aGlzLnNlbGVjdGVkKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgc2VhcmNoIHF1ZXJ5XG4gICAgICAgIHRoaXMucXVlcnkkLm5leHQoJycpO1xuXG4gICAgICAgIC8vIGhpZGUgdGhlIGRyb3Bkb3duXG4gICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgIH1cblxuICAgIC8qKiBJZiBhIGNsaWNrIG9jY3VycmVkIHRoYXQgd2FzIG91dHNpZGUgdGhlIGRyb3Bkb3duIHRoZW4gY2xvc2UgdGhlIGRyb3Bkb3duICovXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcbiAgICBjbGlja09mZih0YXJnZXQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGNsaWNrIHdhcyBvdXRzaWRlIHRoZSBkcm9wZG93biB0aGVuIGNsb3NlIGl0XG4gICAgICAgIGlmICghKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSQubmV4dCgnJyk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBJZiBhIGZpbHRlciBuZWVkcyByZW1vdmVkLCBhbmQgaXMgbm90IHRoZSBpbml0aWFsIGZpbHRlciB0aGVuIHJlbW92ZSBpdCAqL1xuICAgIHJlbW92ZUZpbHRlcigpOiB2b2lkIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZmlsdGVyIHdlIHdhbnQgdG8gcmVtb3ZlIGlzIHRoZSBpbml0aWFsIGZpbHRlclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCAhPT0gdGhpcy5pbml0aWFsKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJTZXJ2aWNlLnJlbW92ZSh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciB0aGUgc2VhcmNoIHF1ZXJ5XG4gICAgICAgIHRoaXMucXVlcnkkLm5leHQoJycpO1xuICAgIH1cblxuICAgIC8qKiBTZWxlY3QgYSBzcGVjaWZpYyBmaWx0ZXIgKi9cbiAgICBzZWxlY3RGaWx0ZXIoZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyBjbGVhciBhbnkgY3VycmVudCBmaWx0ZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlRmlsdGVyKCk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG5ld2x5IHNlbGVjdGVkIGZpbHRlclxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmlsdGVyO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBmaWx0ZXIgaW4gdGhlIHNlcnZpY2VcbiAgICAgICAgdGhpcy5fZmlsdGVyU2VydmljZS5hZGQodGhpcy5zZWxlY3RlZCk7XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0eXBlYWhlYWQgaXRlbXMgYW5kIHZpc2liaWxpdHkgKi9cbiAgICB1cGRhdGVUeXBlYWhlYWQocXVlcnk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnR5cGVhaGVhZE9wZW4gPSBxdWVyeS5sZW5ndGggPj0gdGhpcy5fb3B0aW9ucy5taW5DaGFyYWN0ZXJzO1xuICAgICAgICB0aGlzLnR5cGVhaGVhZEl0ZW1zID0gdGhpcy5nZXRJdGVtcygpO1xuICAgIH1cblxuICAgIC8qKiBTZWxlY3QgYSBmaWx0ZXIgZnJvbSBhIHR5cGVhaGVhZCBpdGVtICovXG4gICAgc2VsZWN0KGV2ZW50OiBUeXBlYWhlYWRPcHRpb25FdmVudCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIHRoZSBmaWx0ZXIgd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLmZpbHRlcnMuZmluZChfZmlsdGVyID0+IF9maWx0ZXIubmFtZSA9PT0gZXZlbnQub3B0aW9uKTtcblxuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEZpbHRlcihmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2ZpbHRlclR5cGVhaGVhZEhpZ2hsaWdodCdcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyVHlwZWFoZWFkSGlnaGxpZ2h0IGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcsIHNlYXJjaFF1ZXJ5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoc2VhcmNoUXVlcnksICdpJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlZ2V4LCBgPGIgY2xhc3M9XCJmaWx0ZXItdHlwZWFoZWFkLWhpZ2hsaWdodGVkXCI+JHt2YWx1ZS5tYXRjaChyZWdleCl9PC9iPmApO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNZW51TmF2aWdhdGlvblNlcnZpY2Uge1xuXG4gICAgYWN0aXZlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlPihudWxsKTtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eE1lbnVOYXZpZ2F0aW9uSXRlbV0nXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBAT3V0cHV0KCkgYWN0aXZhdGVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlOiBNZW51TmF2aWdhdGlvblNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gc2VydmljZS5hY3RpdmUkLnBpcGUoZmlsdGVyKGl0ZW0gPT4gaXRlbSA9PT0gdGhpcykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2V0QWN0aXZlKCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXRBY3RpdmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZC5lbWl0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IERPV05fQVJST1csIEVORCwgRVNDQVBFLCBIT01FLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eE1lbnVOYXZpZ2F0aW9uXScsXG4gICAgZXhwb3J0QXM6ICd1eE1lbnVOYXZpZ2F0aW9uJyxcbiAgICBwcm92aWRlcnM6IFtNZW51TmF2aWdhdGlvblNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KClcbiAgICB0b2dnbGVCdXR0b246IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuXG4gICAgQElucHV0KClcbiAgICB0b2dnbGVCdXR0b25Qb3NpdGlvbjogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCcgPSAndG9wJztcblxuICAgIEBPdXRwdXQoKVxuICAgIG5hdmlnYXRlZE91dCA9IG5ldyBFdmVudEVtaXR0ZXI8S2V5Ym9hcmRFdmVudD4oKTtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gICAgaXRlbXM6IFF1ZXJ5TGlzdDxNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmU+O1xuXG4gICAgZ2V0IGFjdGl2ZUluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc09yZGVyZWQuaW5kZXhPZih0aGlzLl9zZXJ2aWNlLmFjdGl2ZSQudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2l0ZW1zT3JkZXJlZDogTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlW107XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9zZXJ2aWNlOiBNZW51TmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnlcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVCdXR0b24ua2V5RW50ZXIucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuZm9jdXNGaXJzdCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLml0ZW1zLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5faXRlbXNPcmRlcmVkID0gdGhpcy5pdGVtcy50b0FycmF5KCkpO1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zT3JkZXJlZCA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBmb2N1c0ZpcnN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vdmVGaXJzdCgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmtleWRvd24nLCBbJyRldmVudCddKVxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gT25seSBoYW5kbGUgZXZlbnRzIHdoZW4gZm9jdXMgaW4gd2l0aGluIHRoZSBsaXN0IG9mIG1lbnUgaXRlbXNcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC53aGljaCkge1xuXG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVByZXZpb3VzKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZU5leHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uUG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b25Qb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIT01FOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUZpcnN0KCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRU5EOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUxhc3QoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFU0NBUEU6XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZWRPdXQuZW1pdChldmVudCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlTmV4dChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlcmUncyBubyBhY3RpdmUgbWVudSBpdGVtIHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmFjdGl2ZUluZGV4ICsgMTtcbiAgICAgICAgaWYgKG5leHRJbmRleCA8IHRoaXMuX2l0ZW1zT3JkZXJlZC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgLy8gQWN0aXZhdGUgdGhlIG5leHQgbWVudSBpdGVtXG4gICAgICAgICAgICAvLyAodXhNZW51TmF2aWdhdGlvbkl0ZW0gc3Vic2NyaWJlcyB0byB0aGlzIGFuZCBhcHBsaWVzIGZvY3VzIGlmIGl0IG1hdGNoZXMpXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmFjdGl2ZSQubmV4dCh0aGlzLl9pdGVtc09yZGVyZWRbbmV4dEluZGV4XSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZm9jdXMgd2VudCBvdXQgb2YgYm91bmRzIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG9yaWdpbiB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b25Qb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVQcmV2aW91cyhldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlcmUncyBubyBhY3RpdmUgbWVudSBpdGVtIHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmFjdGl2ZUluZGV4IC0gMTtcbiAgICAgICAgaWYgKG5leHRJbmRleCA+PSAwKSB7XG5cbiAgICAgICAgICAgIC8vIEFjdGl2YXRlIHRoZSBwcmV2aW91cyBtZW51IGl0ZW1cbiAgICAgICAgICAgIC8vICh1eE1lbnVOYXZpZ2F0aW9uSXRlbSBzdWJzY3JpYmVzIHRvIHRoaXMgYW5kIGFwcGxpZXMgZm9jdXMgaWYgaXQgbWF0Y2hlcylcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFtuZXh0SW5kZXhdKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmb2N1cyB3ZW50IG91dCBvZiBib3VuZHMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZUZpcnN0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faXRlbXNPcmRlcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVMYXN0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faXRlbXNPcmRlcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFt0aGlzLl9pdGVtc09yZGVyZWQubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbi5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVCdXR0b24ubWVudU9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmF2aWdhdGVkT3V0LmVtaXQoZXZlbnQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBFTlRFUiwgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFNQQUNFLCBVUF9BUlJPVyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TWVudU5hdmlnYXRpb25Ub2dnbGVdJyxcbiAgICBleHBvcnRBczogJ3V4TWVudU5hdmlnYXRpb25Ub2dnbGUnXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IG1lbnVPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVudU9wZW47XG4gICAgfVxuXG4gICAgc2V0IG1lbnVPcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lbnVPcGVuID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWVudU9wZW5DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBtZW51UG9zaXRpb246ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnID0gJ2JvdHRvbSc7XG5cbiAgICBAT3V0cHV0KClcbiAgICBtZW51T3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGtleUVudGVyID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgcHJpdmF0ZSBfbWVudU9wZW46IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmlzS2V5TWF0Y2goZXZlbnQud2hpY2gpKSB7XG5cbiAgICAgICAgICAgIC8vIE9wZW4gdGhlIG1lbnVcbiAgICAgICAgICAgIHRoaXMubWVudU9wZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgbWVudSB0byBpbml0LCB0aGVuIHNlbmQgdGhlIGV2ZW50IHRvIGdpdmUgaXQgZm9jdXNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5rZXlFbnRlci5lbWl0KCkpO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlzS2V5TWF0Y2goa2V5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgICAgICBjYXNlIFNQQUNFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ3RvcCc7XG5cbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZW51UG9zaXRpb24gPT09ICdib3R0b20nO1xuXG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudVBvc2l0aW9uID09PSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudVBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuXG5jb25zdCBFWFBPUlRTID0gW1xuICAgIE1lbnVOYXZpZ2F0aW9uRGlyZWN0aXZlLFxuICAgIE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZSxcbiAgICBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBleHBvcnRzOiBFWFBPUlRTLFxuICAgIGRlY2xhcmF0aW9uczogRVhQT1JUUyxcbn0pXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBBMTF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEJzRHJvcGRvd25Nb2R1bGUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2Ryb3Bkb3duJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgVHlwZWFoZWFkTW9kdWxlIH0gZnJvbSAnLi4vdHlwZWFoZWFkL3R5cGVhaGVhZC5tb2R1bGUnO1xuaW1wb3J0IHsgRmlsdGVyQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyLWJhc2UvZmlsdGVyLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyRHJvcGRvd25Db21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1kcm9wZG93bi9maWx0ZXItZHJvcGRvd24uY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlckR5bmFtaWNDb21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1keW5hbWljL2ZpbHRlci1keW5hbWljLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJUeXBlYWhlYWRIaWdobGlnaHQgfSBmcm9tICcuL2ZpbHRlci1keW5hbWljL2ZpbHRlci10eXBlYWhlYWQtaGlnaGxpZ2h0LnBpcGUnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgRmlsdGVyQmFzZUNvbXBvbmVudCxcbiAgICBGaWx0ZXJDb250YWluZXJDb21wb25lbnQsXG4gICAgRmlsdGVyRHJvcGRvd25Db21wb25lbnQsXG4gICAgRmlsdGVyRHluYW1pY0NvbXBvbmVudCxcbiAgICBGaWx0ZXJUeXBlYWhlYWRIaWdobGlnaHRcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBCc0Ryb3Bkb3duTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIE1lbnVOYXZpZ2F0aW9uTW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFR5cGVhaGVhZE1vZHVsZSxcbiAgICAgICAgQTExeU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsaXBwYWJsZS1jYXJkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmxpcHBhYmxlLWNhcmQuY29tcG9uZW50Lmh0bWwnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgICAgICAnW2NsYXNzLmhvcml6b250YWxdJzogJ2RpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCInLFxuICAgICAgICAnW2NsYXNzLnZlcnRpY2FsXSc6ICdkaXJlY3Rpb24gPT09IFwidmVydGljYWxcIidcbiAgICB9LFxuICAgIGV4cG9ydEFzOiAndXgtZmxpcHBhYmxlLWNhcmQnXG59KVxuZXhwb3J0IGNsYXNzIEZsaXBwYWJsZUNhcmRDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuICAgIEBJbnB1dCgpIHRyaWdnZXI6ICdjbGljaycgfCAnaG92ZXInIHwgJ21hbnVhbCcgPSAnaG92ZXInO1xuICAgIEBJbnB1dCgpIHdpZHRoOiBudW1iZXIgPSAyODA7XG4gICAgQElucHV0KCkgaGVpZ2h0OiBudW1iZXIgPSAyMDA7XG4gICAgQElucHV0KCkgZmxpcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBPdXRwdXQoKSBmbGlwcGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBzZXRGbGlwcGVkKHN0YXRlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmxpcHBlZCA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZsaXBwZWRDaGFuZ2UuZW1pdCh0aGlzLmZsaXBwZWQpO1xuICAgIH1cblxuICAgIHRvZ2dsZUZsaXBwZWQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0RmxpcHBlZCghdGhpcy5mbGlwcGVkKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgY2xpY2tUcmlnZ2VyKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgY2FyZCBoYXMgYmVlbiBmbGlwcGVkXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRmxpcHBlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpXG4gICAgaG92ZXJFbnRlcigpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgdGhlIHRyaWdnZXIgaXMgaG92ZXIgdGhlbiBiZWdpbiB0byBmbGlwXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmxpcHBlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICAgIGhvdmVyRXhpdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgdGhpcy5zZXRGbGlwcGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uZW50ZXInLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uc3BhY2UnLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uc3BhY2ViYXInLCBbJyRldmVudCddKSAvLyBJRSB1c2VzIGRpZmZlcmVudCBuYW1pbmdcbiAgICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlciAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRmxpcHBlZCgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbGlwcGFibGUtY2FyZC1mcm9udCdcbn0pXG5leHBvcnQgY2xhc3MgRmxpcHBhYmxlQ2FyZEZyb250RGlyZWN0aXZlIHsgfVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsaXBwYWJsZS1jYXJkLWJhY2snXG59KVxuZXhwb3J0IGNsYXNzIEZsaXBwYWJsZUNhcmRCYWNrRGlyZWN0aXZlIHsgfSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZsaXBwYWJsZUNhcmRDb21wb25lbnQsIEZsaXBwYWJsZUNhcmRCYWNrRGlyZWN0aXZlLCBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmUgfSBmcm9tICcuL2ZsaXBwYWJsZS1jYXJkLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZsaXBwYWJsZUNhcmRDb21wb25lbnQsIEZsaXBwYWJsZUNhcmRCYWNrRGlyZWN0aXZlLCBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZsaXBwYWJsZUNhcmRDb21wb25lbnQsIEZsaXBwYWJsZUNhcmRCYWNrRGlyZWN0aXZlLCBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIEZsaXBwYWJsZUNhcmRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlIHtcblxuICAgIG9wZW4kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgZGlyZWN0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RmxvYXRpbmdBY3Rpb25CdXR0b25EaXJlY3Rpb24+KCd0b3AnKTtcblxuICAgIHByaXZhdGUgX2J1dHRvbnM6IFF1ZXJ5TGlzdDxGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudD47XG5cbiAgICBvcGVuKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQoIXRoaXMub3BlbiQuZ2V0VmFsdWUoKSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dChmYWxzZSk7XG5cbiAgICAgICAgLy8gbWFrZSB0aGUgZmlyc3QgYnV0dG9uIHRhYmJhYmxlIGFnYWluXG4gICAgICAgIHRoaXMuc2V0UHJpbWFyeUJ1dHRvbkZvY3VzYWJsZSgpO1xuICAgIH1cblxuICAgIGlzSG9yaXpvbnRhbCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uJC52YWx1ZSA9PT0gJ2xlZnQnIHx8IHRoaXMuZGlyZWN0aW9uJC52YWx1ZSA9PT0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBpc1ZlcnRpY2FsKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24kLnZhbHVlID09PSAndG9wJyB8fCB0aGlzLmRpcmVjdGlvbiQudmFsdWUgPT09ICdib3R0b20nO1xuICAgIH1cblxuICAgIHNldEJ1dHRvbnMoYnV0dG9uczogUXVlcnlMaXN0PEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50Pik6IHZvaWQge1xuICAgICAgICB0aGlzLl9idXR0b25zID0gYnV0dG9ucztcblxuICAgICAgICAvLyBtYWtlIHRoZSBmaXJzdCBidXR0b24gdGFiYmFibGVcbiAgICAgICAgdGhpcy5zZXRQcmltYXJ5QnV0dG9uRm9jdXNhYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqIE1ha2Ugb25seSB0aGUgZmlyc3QgYnV0dG9uIHRhYmJhYmxlICovXG4gICAgc2V0UHJpbWFyeUJ1dHRvbkZvY3VzYWJsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYnV0dG9ucy5mb3JFYWNoKGJ0biA9PiBidG4udGFiaW5kZXgkLm5leHQoYnRuLnByaW1hcnkgPyAwIDogLTEpKTtcbiAgICB9XG5cbiAgICBmb2N1c1ByaW1hcnlCdXR0b24oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXModGhpcy5fYnV0dG9ucy5maW5kKGJ0biA9PiBidG4ucHJpbWFyeSkpO1xuICAgIH1cblxuICAgIGZvY3VzKGJ1dHRvbjogRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGUgYnV0dG9uIGlzIG5vdCBkZWZpbmVkIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBidXR0b24gdGFiIGluZGV4XG4gICAgICAgIHRoaXMuX2J1dHRvbnMuZm9yRWFjaChidG4gPT4gYnRuLnRhYmluZGV4JC5uZXh0KGJ1dHRvbiA9PT0gYnRuID8gMCA6IC0xKSk7XG5cbiAgICAgICAgLy8gYXBwbHkgdGhlIGZvY3VzXG4gICAgICAgIGJ1dHRvbi5mb2N1cygpO1xuICAgIH1cblxuICAgIGZvY3VzU2libGluZyhuZXh0OiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGJ1dHRvbnMgYXJlIG5vdCB2aXNpYmxlIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5vcGVuJC52YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBmb2N1c2VkIGl0ZW1cbiAgICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy5nZXRGb2N1c2VkQnV0dG9uKCk7XG5cbiAgICAgICAgaWYgKG5leHQgJiYgYnV0dG9uID09PSB0aGlzLl9idXR0b25zLmxhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzKHRoaXMuX2J1dHRvbnMuZmlyc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXh0ICYmIGJ1dHRvbiA9PT0gdGhpcy5fYnV0dG9ucy5maXJzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXModGhpcy5fYnV0dG9ucy5sYXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIHNpYmxpbmcgYnV0dG9uXG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSB0aGlzLl9idXR0b25zLnRvQXJyYXkoKVt0aGlzLmdldEJ1dHRvbkluZGV4KGJ1dHRvbikgKyAobmV4dCA/IDEgOiAtMSldO1xuXG4gICAgICAgIC8vIGZvY3VzIHRoZSBuZXh0IGJ1dHRvblxuICAgICAgICB0aGlzLmZvY3VzKHNpYmxpbmcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Rm9jdXNlZEJ1dHRvbigpOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zLmZpbmQoYnRuID0+IGJ0bi50YWJpbmRleCQudmFsdWUgPT09IDApO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QnV0dG9uSW5kZXgoYnV0dG9uOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zLnRvQXJyYXkoKS5maW5kSW5kZXgoYnRuID0+IGJ0biA9PT0gYnV0dG9uKTtcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIEZsb2F0aW5nQWN0aW9uQnV0dG9uRGlyZWN0aW9uID0gJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCc7XG4iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBFTlRFUiwgRVNDQVBFLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQXR0cmlidXRlLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBUb29sdGlwRGlyZWN0aXZlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgaWNvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nO1xuICAgIEBWaWV3Q2hpbGQoJ2J1dHRvbicpIGJ1dHRvbjogRWxlbWVudFJlZjtcblxuICAgIHByaW1hcnk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICB0YWJpbmRleCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PG51bWJlcj4oLTEpO1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKEBBdHRyaWJ1dGUoJ2ZhYi1wcmltYXJ5JykgcHJpbWFyeTogc3RyaW5nLCBwdWJsaWMgZmFiOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlLCBAT3B0aW9uYWwoKSBwcml2YXRlIF90b29sdGlwOiBUb29sdGlwRGlyZWN0aXZlKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeSA9IHByaW1hcnkgIT09IG51bGw7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSB0b29sdGlwIGdldHMgaGlkZGVuIHdoZW4gdGhlIGJ1dHRvbiBpcyBoaWRkZW5cbiAgICAgICAgICAgIHRoaXMuZmFiLm9wZW4kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcihpc09wZW4gPT4gIWlzT3BlbiAmJiAhdGhpcy5wcmltYXJ5KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3Rvb2x0aXAuaGlkZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5idXR0b24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIG9uRm9jdXMoKTogdm9pZCB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGUgdG9vbHRpcCBnZXRzIHNob3duXG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQmx1cigpOiB2b2lkIHtcbiAgICAgICAgLy8gZW5zdXJlIHRoZSB0b29sdGlwIGdldHMgaGlkZGVuXG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZhYi5jbG9zZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIG9uS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcblxuICAgICAgICAgICAgY2FzZSBVUF9BUlJPVzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mYWIuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFiLmZvY3VzU2libGluZyh0aGlzLmZhYi5kaXJlY3Rpb24kLnZhbHVlICE9PSAnYm90dG9tJyk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFiLmlzVmVydGljYWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhYi5mb2N1c1NpYmxpbmcodGhpcy5mYWIuZGlyZWN0aW9uJC52YWx1ZSA9PT0gJ2JvdHRvbScpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZhYi5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhYi5mb2N1c1NpYmxpbmcodGhpcy5mYWIuZGlyZWN0aW9uJC52YWx1ZSAhPT0gJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZhYi5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhYi5mb2N1c1NpYmxpbmcodGhpcy5mYWIuZGlyZWN0aW9uJC52YWx1ZSA9PT0gJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICAgIHRoaXMuZmFiLmZvY3VzUHJpbWFyeUJ1dHRvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgICAgICAgICB0aGlzLmZhYi5mb2N1c1ByaW1hcnlCdXR0b24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgIH1cbn0iLCJpbXBvcnQgeyBhbmltYXRlLCBxdWVyeSwgc3RhZ2dlciwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmxvYXRpbmdBY3Rpb25CdXR0b25EaXJlY3Rpb24sIEZsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsb2F0aW5nLWFjdGlvbi1idXR0b25zJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW0Zsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2VdLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcignZmFiQW5pbWF0aW9uJywgW1xuICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiB0cnVlJywgW1xuICAgICAgICAgICAgICAgIHF1ZXJ5KCd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKSxcbiAgICAgICAgICAgICAgICBxdWVyeSgndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbicsIHN0YWdnZXIoNTAsIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpKSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdHJhbnNpdGlvbigndHJ1ZSA9PiB2b2lkJywgW1xuICAgICAgICAgICAgICAgIHF1ZXJ5KCd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJywgc3RhZ2dlcigtNTAsIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIFNwZWNpZnkgdGhlIGRpcmVjdGlvbiB0aGF0IHRoZSBGQUIgc2hvdWxkIGRpc3BsYXkgKi9cbiAgICBASW5wdXQoKSBzZXQgZGlyZWN0aW9uKGRpcmVjdGlvbjogRmxvYXRpbmdBY3Rpb25CdXR0b25EaXJlY3Rpb24pIHsgdGhpcy5mYWIuZGlyZWN0aW9uJC5uZXh0KGRpcmVjdGlvbik7IH1cblxuICAgIC8qKiBFbWl0IHdoZW5ldmVyIHRoZSBvcGVuIHN0YXRlIGNoYW5nZXMgKi9cbiAgICBAT3V0cHV0KCkgb3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBHZXQgYWxsIGNoaWxkIEZBQiBidXR0b25zICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCkgYnV0dG9uczogUXVlcnlMaXN0PEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50PjtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGZhYjogRmxvYXRpbmdBY3Rpb25CdXR0b25zU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHRoaXMuZmFiLm9wZW4kLnN1YnNjcmliZSh2YWx1ZSA9PiB0aGlzLm9wZW5DaGFuZ2UuZW1pdCh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmFiLnNldEJ1dHRvbnModGhpcy5idXR0b25zKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEZXRlY3QgYW55IGNsaWNrcyB0byB0cmlnZ2VyIGNsb3NlIG9mIHRoZSBtZW51XG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudC50YXJnZXQnXSkgY2xvc2UodGFyZ2V0OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmZhYi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQgfSBmcm9tICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uc0NvbXBvbmVudCxcbiAgICAgICAgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQsXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhDbGlja091dHNpZGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBDbGlja091dHNpZGVEaXJlY3RpdmUge1xuXG4gICAgQE91dHB1dCgpIHV4Q2xpY2tPdXRzaWRlID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqIE9mdGVuIGEgY2xpY2sgZXZlbnQgbWFrZXMgdGhlIGVsZW1lbnQgYXBwZWFyIC0gaWYgc28gd2UgY2FuIGVuZCB1cCBjbG9zaW5nIGl0IGltbWVkaWF0ZWx5ICovXG4gICAgcHJpdmF0ZSBfaW5pdGlhbGlzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9pbml0aWFsaXNlZCA9IHRydWUpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgICBjbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGlzZWQgJiYgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiYgIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLnV4Q2xpY2tPdXRzaWRlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVEaXJlY3RpdmUgfSBmcm9tICcuL2NsaWNrLW91dHNpZGUuZGlyZWN0aXZlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtDbGlja091dHNpZGVEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0NsaWNrT3V0c2lkZURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2xpY2tPdXRzaWRlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5cbmxldCB1bmlxdWVQb3BvdmVySWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1wb3BvdmVyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3BvcG92ZXIuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBQb3BvdmVyQ29tcG9uZW50IGV4dGVuZHMgVG9vbHRpcENvbXBvbmVudCB7XG5cbiAgLyoqIERlZmluZSBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBwb3BvdmVyICovXG4gIGlkOiBzdHJpbmcgPSBgdXgtcG9wb3Zlci0keysrdW5pcXVlUG9wb3ZlcklkfWA7XG5cbiAgLyoqIElmIHNwZWNpZmllZCBhbGxvd3MgdGhlIHBvcG92ZXIgdG8gc2hvdyBhIHRpdGxlICovXG4gIHRpdGxlOiBzdHJpbmc7XG5cbiAgLyoqIFRoaXMgd2lsbCBlbWl0IGFuIGV2ZW50IGFueSB0aW1lIHRoZSB1c2VyIGNsaWNrcyBvdXRzaWRlIHRoZSBwb3BvdmVyICovXG4gIGNsaWNrT3V0c2lkZSQgPSBuZXcgU3ViamVjdDxNb3VzZUV2ZW50PigpO1xuXG4gIC8qKiBUaGlzIHdpbGwgdXBkYXRlIHRoZSB0aXRsZSBvZiB0aGUgcG9wb3ZlciBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uICovXG4gIHNldFRpdGxlKHRpdGxlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbn0iLCJpbXBvcnQgeyBFU0NBUEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgT3ZlcmxheVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0QmluZGluZywgSW5wdXQsIE9uQ2hhbmdlcywgT25Jbml0LCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUb29sdGlwRGlyZWN0aXZlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5pbXBvcnQgeyBQb3BvdmVyQ29tcG9uZW50IH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4UG9wb3Zlcl0nLFxuICAgIGV4cG9ydEFzOiAndXgtcG9wb3Zlcidcbn0pXG5leHBvcnQgY2xhc3MgUG9wb3ZlckRpcmVjdGl2ZSBleHRlbmRzIFRvb2x0aXBEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG5cbiAgICAvKiogQ29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcG92ZXIgb3IgYSBUZW1wbGF0ZVJlZiBmb3IgbW9yZSBkZXRhaWxlZCBjb250ZW50ICovXG4gICAgQElucHV0KCd1eFBvcG92ZXInKSBjb250ZW50OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqIE9wdGlvbmFsbHkgZGlzcGxheSBhIHRpdGxlIGluIHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCdwb3BvdmVyVGl0bGUnKSB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqIEFsbG93IHRoZSBwb3BvdmVyIHRvIGJlIGNvbmRpdGlvbmFsbHkgZGlzYWJsZWQgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJEaXNhYmxlZCcpIGRpc2FibGVkOiBib29sZWFuO1xuXG4gICAgLyoqIEFsbCB0aGUgdXNlciB0byBhZGQgYSBjdXN0b20gY2xhc3MgdG8gdGhlIHBvcG92ZXIgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJDbGFzcycpIGN1c3RvbUNsYXNzOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKiBBbGwgdGhlIHVzZXIgdG8gYWRkIGEgcm9sZSB0byB0aGUgcG9wb3ZlciAtIGRlZmF1bHQgaXMgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgncG9wb3ZlclJvbGUnKSByb2xlOiBzdHJpbmcgPSAndG9vbHRpcCc7XG5cbiAgICAvKiogUHJvdmlkZSB0aGUgVGVtcGxhdGVSZWYgYSBjb250ZXh0IG9iamVjdCAqL1xuICAgIEBJbnB1dCgncG9wb3ZlckNvbnRleHQnKSBjb250ZXh0OiBhbnkgPSB7fTtcblxuICAgIC8qKiBEZWxheSB0aGUgc2hvd2luZyBvZiB0aGUgcG9wb3ZlciBieSBhIG51bWJlciBvZiBtaWxpc2Vjb25kcyAqL1xuICAgIEBJbnB1dCgncG9wb3ZlckRlbGF5JykgZGVsYXk6IG51bWJlciA9IDA7XG5cbiAgICAvKiogU3BlY2lmeSB3aGljaCBldmVudHMgc2hvdWxkIHNob3cgdGhlIHBvcG92ZXIgKi9cbiAgICBASW5wdXQoKSBzaG93VHJpZ2dlcnM6IHN0cmluZ1tdID0gWydjbGljayddO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBoaWRlIHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCkgaGlkZVRyaWdnZXJzOiBzdHJpbmdbXSA9IFsnY2xpY2snLCAnY2xpY2tvdXRzaWRlJywgJ2VzY2FwZSddO1xuXG4gICAgLyoqIEtlZXAgdHJhY2sgb2YgdGhlIHRvb2x0aXAgdmlzaWJpbGl0eSBhbmQgdXBkYXRlIGFyaWEtZXhwYW5kZWQgYXR0cmlidXRlICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZXhwYW5kZWQnKSBpc1Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgQ0RLIHBvcnRhbCBjb250YWluaW5nIHRoZSBvdmVybGF5ICovXG4gICAgcHJvdGVjdGVkIF9wb3J0YWw6IENvbXBvbmVudFBvcnRhbDxQb3BvdmVyQ29tcG9uZW50PjtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgdGhlIHBvcG92ZXIgY29tcG9uZW50IHdoZW4gY3JlYXRlZCAqL1xuICAgIHByb3RlY3RlZCBfaW5zdGFuY2U6IFBvcG92ZXJDb21wb25lbnQ7XG5cbiAgICAvKiogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIGFyaWEtZGVzY3JpYmVkYnkgcHJvcGVydHkgb3JpZ2luYWxseSBleGlzdGVkIG9uIHRoZSBlbGVtZW50ICovXG4gICAgcHJpdmF0ZSBfYXJpYURlc2NyaWJlZEJ5OiBib29sZWFuO1xuXG4gICAgLyoqIEludGVybmFsbHkgc3RvcmUgdGhlIHR5cGUgb2YgdGhpcyBjb21wb25lbnQgLSB1c3VhbCBmb3IgZGlzdGluY3Rpb25zIHdoZW4gZXh0ZW5kaW5nIHRoZSB0b29sdGlwIGNsYXNzICovXG4gICAgcHJvdGVjdGVkIF90eXBlOiBzdHJpbmcgPSAncG9wb3Zlcic7XG5cbiAgICAvKiogU2V0IHVwIHRoZSB0cmlnZ2VycyBhbmQgYmluZCB0byB0aGUgc2hvdy9oaWRlIGV2ZW50cyB0byBrZWVwIHZpc2liaWxpdHkgaW4gc3luYyAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgZXZlbnQgdHJpZ2dlcnNcbiAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhbiBhcmlhLWRlc2NyaWJlZCBieSBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5fYXJpYURlc2NyaWJlZEJ5ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgZGVmYXVsdCBldmVudCB0cmlnZ2Vyc1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gc2VuZCBpbnB1dCBjaGFuZ2VzIHRvIHRoZSBwb3BvdmVyIGNvbXBvbmVudFxuICAgICAqIFdlIGNhbid0IHVzZSBzZXR0ZXJzIGFzIHRoZXkgbWF5IHRyaWdnZXIgYmVmb3JlIHBvcG92ZXIgaW5pdGlhbGlzZWQgYW5kIGNhbid0IHJlc2VuZCBvbmNlIGluaXRpYWxpc2VkXG4gICAgICoqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMudGl0bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldFRpdGxlKGNoYW5nZXMudGl0bGUuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBjcmVhdGVJbnN0YW5jZShvdmVybGF5UmVmOiBPdmVybGF5UmVmKTogUG9wb3ZlckNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gb3ZlcmxheVJlZi5hdHRhY2godGhpcy5fcG9ydGFsKS5pbnN0YW5jZSBhcyBQb3BvdmVyQ29tcG9uZW50O1xuXG4gICAgICAgIC8vIHN1cHBseSB0aGUgdG9vbHRpcCB3aXRoIHRoZSBjb3JyZWN0IHByb3BlcnRpZXNcbiAgICAgICAgaW5zdGFuY2Uuc2V0VGl0bGUodGhpcy50aXRsZSk7XG4gICAgICAgIGluc3RhbmNlLnNldENvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGxhY2VtZW50KHRoaXMucGxhY2VtZW50KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q2xhc3ModGhpcy5jdXN0b21DbGFzcyk7XG4gICAgICAgIGluc3RhbmNlLnNldENvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Um9sZSh0aGlzLnJvbGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYXJpYS1kZXNjcmliZWRieSBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5zZXRBcmlhRGVzY3JpYmVkQnkoaW5zdGFuY2UuaWQpO1xuXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byB0aGUgb3V0c2lkZSBjbGljayBldmVudFxuICAgICAgICBpbnN0YW5jZS5jbGlja091dHNpZGUkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uQ2xpY2tPdXRzaWRlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlUG9ydGFsKCk6IENvbXBvbmVudFBvcnRhbDxQb3BvdmVyQ29tcG9uZW50PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0YWwgfHwgbmV3IENvbXBvbmVudFBvcnRhbChQb3BvdmVyQ29tcG9uZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHZpc2libGUgYW5kIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWQgYW5kIGl0IGlzIG9uZSBvZiB0aGUgaGlkZSB0cmlnZ2Vyc1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFICYmIHRoaXMuaW5jbHVkZXModGhpcy5oaWRlVHJpZ2dlcnMsICdlc2NhcGUnKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2xpY2tPdXRzaWRlKCk6IHZvaWQge1xuICAgICAgICAvLyBpZiB2aXNpYmxlIGFuZCBpdCBpcyBvbmUgb2YgdGhlIGhpZGUgdHJpZ2dlcnNcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIHRoaXMuaW5jbHVkZXModGhpcy5oaWRlVHJpZ2dlcnMsICdjbGlja291dHNpZGUnKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSB1cGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgcHJvcGVydHkgKi9cbiAgICBwcm90ZWN0ZWQgc2V0QXJpYURlc2NyaWJlZEJ5KGlkOiBzdHJpbmcgfCBudWxsKTogdm9pZCB7XG5cbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHNldCB0aGUgYXJpYS1kZXNjcmliZWRieSBhdHRyIHdoZW4gdGhlIGNvbnRlbnQgaXMgYSBzdHJpbmcgYW5kIHRoZXJlIHdhcyBubyB1c2VyIGRlZmluZWQgYXR0cmlidXRlIGFscmVhZHlcbiAgICAgICAgaWYgKHRoaXMuX2FyaWFEZXNjcmliZWRCeSA9PT0gZmFsc2UgJiYgdHlwZW9mIHRoaXMuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN1cGVyLnNldEFyaWFEZXNjcmliZWRCeShpZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBPYnNlcnZlcnNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb2JzZXJ2ZXJzJztcbmltcG9ydCB7IE92ZXJsYXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsaWNrT3V0c2lkZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvY2xpY2stb3V0c2lkZS9pbmRleCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5pbXBvcnQgeyBQb3BvdmVyQ29tcG9uZW50IH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQb3BvdmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9wb3BvdmVyLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgT3ZlcmxheU1vZHVsZSxcbiAgICBPYnNlcnZlcnNNb2R1bGUsXG4gICAgQ2xpY2tPdXRzaWRlTW9kdWxlLFxuICAgIFRvb2x0aXBNb2R1bGVcbiAgXSxcbiAgZXhwb3J0czogW1BvcG92ZXJEaXJlY3RpdmVdLFxuICBkZWNsYXJhdGlvbnM6IFtQb3BvdmVyQ29tcG9uZW50LCBQb3BvdmVyRGlyZWN0aXZlXSxcbiAgZW50cnlDb21wb25lbnRzOiBbUG9wb3ZlckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgUG9wb3Zlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzL09ic2VydmVyJztcclxuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xyXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhclNlcnZpY2Uge1xyXG5cclxuICAgIG5vZGVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SGllcmFyY2h5QmFyTm9kZVtdPihbXSk7XHJcblxyXG4gICAgcHJpdmF0ZSBfcm9vdDogSGllcmFyY2h5QmFyTm9kZTtcclxuICAgIHByaXZhdGUgX25vZGVzOiBIaWVyYXJjaHlCYXJOb2RlW10gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlIHRoZSByb290IG5vZGUgb2YgdGhlIGhpZXJhcmNoeSB0cmVlXHJcbiAgICAgKi9cclxuICAgIHNldFJvb3ROb2RlKHJvb3Q6IEhpZXJhcmNoeUJhck5vZGUpIHtcclxuXHJcbiAgICAgICAgLy8gc3RvcmUgdGhlIHJvb3Qgbm9kZVxyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYSBmbGF0IHN0cnVjdHVyZSBvZiBub2Rlc1xyXG4gICAgICAgIHRoaXMuX25vZGVzID0gdGhpcy5nZXROb2RlTGlzdChyb290KTtcclxuXHJcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgYXJyYXkgLSBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgbm9kZVxyXG4gICAgICAgIHRoaXMubm9kZXMkLm5leHQodGhpcy5nZXRTZWxlY3RlZENoaWxkcmVuKHJvb3QpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCBhIG5vZGUuIFRoaXMgY2F1c2VzIGFsbCBub2RlcyB0byBiZVxyXG4gICAgICogZGVzZWxlY3RlZCBhbmQgdGhlIHBhdGggdG8gdGhlIHNlbGVjdGVkIG5vZGVcclxuICAgICAqIHRvIGJlIHNlbGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdE5vZGUobm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IHZvaWQge1xyXG5cclxuICAgICAgICAvLyBkZXNlbGVjdCBhbGwgbm9kZXNcclxuICAgICAgICB0aGlzLmRlc2VsZWN0QWxsKCk7XHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgY3VycmVudCBub2RlIGlzIHNlbGVjdGVkIGFuZCBpdHMgcGFyZW50c1xyXG4gICAgICAgIHRoaXMuc2VsZWN0KG5vZGUpO1xyXG5cclxuICAgICAgICAvLyBlbWl0IGEgbmV3IG5vZGUgbGlzdCB0byB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb25cclxuICAgICAgICB0aGlzLm5vZGVzJC5uZXh0KHRoaXMuZ2V0U2VsZWN0ZWRDaGlsZHJlbih0aGlzLl9yb290KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGdldHRpbmcgY2hpbGRyZW4gd2l0aCBzdXBwb3J0IGZvciBib3RoIGFycmF5cyBhbmQgb2JzZXJ2YWJsZXNcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hpbGRyZW4obm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IE9ic2VydmFibGU8SGllcmFyY2h5QmFyTm9kZUNoaWxkcmVuPiB7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvZih7IGxvYWRpbmc6IGZhbHNlLCBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbiB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuJDogT2JzZXJ2YWJsZTxIaWVyYXJjaHlCYXJOb2RlW10+ID0gbm9kZS5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gb2JzZXJ2YWJsZSB0aGVuIGhhbmRsZSBsb2FkaW5nXHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8SGllcmFyY2h5QmFyTm9kZUNoaWxkcmVuPikgPT4ge1xyXG4gICAgICAgICAgICAvLyBlbWl0IGluaXRpYWwgdmFsdWVcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7IGxvYWRpbmc6IHRydWUsIGNoaWxkcmVuOiBbXSB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIG5vdyB3YWl0IHVudGlsIHRoZSBjaGlsZHJlbiBvYnNlcnZhYmxlIGNvbXBsZXRlc1xyXG4gICAgICAgICAgICBjaGlsZHJlbiQucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoY2hpbGRyZW4gPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIG9ic2VydmFibGUgd2l0aCBhbiBhcnJheSBmb3IgZnV0dXJlIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZWJ1aWxkIHRoZSBub2RlIHRyZWVcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um9vdE5vZGUodGhpcy5fcm9vdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZW1pdCB0aGUgbGF0ZXN0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHsgbG9hZGluZzogZmFsc2UsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgb2JzZXJ2YWJsZSBzdHJlYW1cclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFsbCB0aGUgcGFyZW50cyB0byBlbnN1cmUgdGhleSBhcmUgc2VsZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZWxlY3Qobm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IHZvaWQge1xyXG4gICAgICAgIG5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Qobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc2VsZWN0cyBhbGwgbm9kZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS5zZWxlY3RlZCA9IGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIHRoZSBub2RlcyBpbiB0aGUgdHJlZSBhcyBhIGZsYXQgYXJyYXkuXHJcbiAgICAgKiBJdCBhbHNvIHN0b3JlcyB0aGUgcGFyZW50IG5vZGUgaW4gYSBwYXJlbnQgcHJvcGVydHlcclxuICAgICAqIG9uIHRoZSBub2RlIGZvciBlYXN5IHRyYXZlcnNhbCBpbiBib3RoIGRpcmVjdGlvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXROb2RlTGlzdChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogSGllcmFyY2h5QmFyTm9kZVtdIHtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGNoaWxkcmVuIHRoZW4gcmV0dXJuIG9ubHkgaXRzZWxmXHJcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGRyZW4gaW5zdGFuY2VvZiBPYnNlcnZhYmxlIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbm9kZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzdG9yZSB0aGUgcGFyZW50IHByb3BlcnR5XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnBhcmVudCA9IG5vZGUpO1xyXG5cclxuICAgICAgICAvLyBnZXQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoaXMgbm9kZVxyXG4gICAgICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gbm9kZS5jaGlsZHJlbi5yZWR1Y2U8SGllcmFyY2h5QmFyTm9kZVtdPigobm9kZXMsIGN1cnJlbnQpID0+IFsuLi5ub2RlcywgLi4udGhpcy5nZXROb2RlTGlzdChjdXJyZW50KV0sIFtdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtub2RlLCAuLi5kZXNjZW5kYW50c107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBzZWxlY3RlZCBub2RlcyBmcm9tIHRoZSBwYXJlbnQgbm9kZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRTZWxlY3RlZENoaWxkcmVuKG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiBIaWVyYXJjaHlCYXJOb2RlW10ge1xyXG5cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGdldCB0aGUgY2hpbGRyZW4gLSBhbmQgYWNjb3VudCBmb3Igd2hlbiB0aGVyZSBpcyBub25lXHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuIHx8IFtdO1xyXG5cclxuICAgICAgICAvLyBjaGVjayBpZiBhbnkgY2hpbGQgaXMgc2VsZWN0ZWRcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuLmZpbmQoX2NoaWxkID0+IF9jaGlsZC5zZWxlY3RlZCk7XHJcblxyXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmVtYWluaW5nIGNoYWluIG9mIHNlbGVjdGVkIGl0ZW1zXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkID8gW25vZGUsIC4uLnRoaXMuZ2V0U2VsZWN0ZWRDaGlsZHJlbihjaGlsZCldIDogW25vZGVdO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhpZXJhcmNoeUJhck5vZGUge1xyXG4gICAgaWNvbj86IHN0cmluZztcclxuICAgIHRpdGxlOiBzdHJpbmc7XHJcbiAgICBzZWxlY3RlZD86IGJvb2xlYW47XHJcbiAgICBwYXJlbnQ/OiBIaWVyYXJjaHlCYXJOb2RlO1xyXG4gICAgY2hpbGRyZW4/OiBIaWVyYXJjaHlCYXJOb2RlW10gfCBPYnNlcnZhYmxlPEhpZXJhcmNoeUJhck5vZGVbXT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGllcmFyY2h5QmFyTm9kZUNoaWxkcmVuIHtcclxuICAgIGxvYWRpbmc6IGJvb2xlYW47XHJcbiAgICBjaGlsZHJlbjogSGllcmFyY2h5QmFyTm9kZVtdO1xyXG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xyXG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IEhpZXJhcmNoeUJhck5vZGUsIEhpZXJhcmNoeUJhclNlcnZpY2UgfSBmcm9tICcuL2hpZXJhcmNoeS1iYXIuc2VydmljZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtaGllcmFyY2h5LWJhcicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vaGllcmFyY2h5LWJhci5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgIHZpZXdQcm92aWRlcnM6IFtIaWVyYXJjaHlCYXJTZXJ2aWNlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgSGllcmFyY2h5QmFyQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuXHJcbiAgICBASW5wdXQoKSBzZXQgcm9vdChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKSB7XHJcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlCYXIuc2V0Um9vdE5vZGUobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KCkgc2V0IHNlbGVjdGVkKG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpIHtcclxuICAgICAgICB0aGlzLmhpZXJhcmNoeUJhci5zZWxlY3ROb2RlKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpIGxvYWRpbmdJbmRpY2F0b3I6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxIaWVyYXJjaHlCYXJOb2RlPigpO1xyXG4gICAgQFZpZXdDaGlsZCgnbm9kZWxpc3QnKSBub2RlbGlzdDogRWxlbWVudFJlZjtcclxuICAgIEBWaWV3Q2hpbGRyZW4oJ25vZGVFbGVtZW50Jykgbm9kZXM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcclxuXHJcbiAgICBvdmVyZmxvdyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcclxuICAgIG92ZXJmbG93Tm9kZXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxIaWVyYXJjaHlCYXJOb2RlW10+KFtdKTtcclxuXHJcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHVibGljIGhpZXJhcmNoeUJhcjogSGllcmFyY2h5QmFyU2VydmljZSkge1xyXG5cclxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgc2VsZWN0ZWQgbm9kZVxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gaGllcmFyY2h5QmFyLm5vZGVzJC5zdWJzY3JpYmUobm9kZXMgPT4gdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KG5vZGVzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSkpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSBoaWVyYXJjaHlCYXIubm9kZXMkLnBpcGUoZGVib3VuY2VUaW1lKDApKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zY3JvbGxJbnRvVmlldygpKTtcclxuXHJcbiAgICAgICAgLy8gc3RvcmUgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoc2VsZWN0ZWQpO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoY2hhbmdlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRoZXJlIGlzIG92ZXJmbG93IGVuc3VyZSB0aGF0IHRoZSByaWdodG1vc3RcclxuICAgICAqIG5vZGUgcmVtYWlucyBpbiB2aWV3IGF0IGFsbCB0aW1lcy4gVGhlIG5vZGVzIG5vIGxvbmdlclxyXG4gICAgICogdmlzaWJsZSBiZSBiZSBkaXNwbGF5ZWQgaW4gYSBwb3BvdmVyIGF2YWlsYWJsZSBvbiB0aGVcclxuICAgICAqIG92ZXJmbG93IGluZGljYXRvclxyXG4gICAgICovXHJcbiAgICBzY3JvbGxJbnRvVmlldygpOiB2b2lkIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLm5vZGVsaXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGdldCB0aGUgbmF0aXZlIGVsZW1lbnRcclxuICAgICAgICBjb25zdCB7IG5hdGl2ZUVsZW1lbnQgfSA9IHRoaXMubm9kZWxpc3Q7XHJcblxyXG4gICAgICAgIC8vIGVtaXQgd2hldGhlciBvciBub3QgdGhlcmUgaXMgb3ZlcmZsb3dcclxuICAgICAgICB0aGlzLm92ZXJmbG93JC5uZXh0KG5hdGl2ZUVsZW1lbnQuc2Nyb2xsV2lkdGggPiBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoKTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGhpZXJhcmNoeSBiYXIgY29udGVudHMgZG8gbm90IG92ZXJmbG93IHRoZW4gZG8gbm90aGluZ1xyXG4gICAgICAgIGlmIChuYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoID4gbmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCkge1xyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2Ygb3ZlcmZsb3dcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3dBbW91bnQgPSBuYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoIC0gbmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGljaCBub2RlcyBhcmUgbm90IGZ1bGx5IHZpc2libGVcclxuICAgICAgICAgICAgdGhpcy5vdmVyZmxvd05vZGVzJC5uZXh0KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLm5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdCA8IG92ZXJmbG93QW1vdW50KVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKG5vZGUsIGluZGV4KSA9PiB0aGlzLmhpZXJhcmNoeUJhci5ub2RlcyQudmFsdWVbaW5kZXhdKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gbW92ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIGFsd2F5cyBzaG93IHRoZSBsYXN0IGl0bWVcclxuICAgICAgICAgICAgdGhpcy5ub2RlbGlzdC5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSBvdmVyZmxvd0Ftb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjY2Vzc2liaWxpdHlNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvaW5kZXgnO1xuaW1wb3J0IHsgRm9jdXNJZk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9jdXMtaWYvaW5kZXgnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL3BvcG92ZXIvaW5kZXgnO1xuaW1wb3J0IHsgSGllcmFyY2h5QmFyQ29tcG9uZW50IH0gZnJvbSAnLi9oaWVyYXJjaHktYmFyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJlc2l6ZU1vZHVsZSxcbiAgICAgICAgRm9jdXNJZk1vZHVsZSxcbiAgICAgICAgUG9wb3Zlck1vZHVsZSxcbiAgICAgICAgQWNjZXNzaWJpbGl0eU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW0hpZXJhcmNoeUJhckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbSGllcmFyY2h5QmFyQ29tcG9uZW50XSxcbn0pXG5leHBvcnQgY2xhc3MgSGllcmFyY2h5QmFyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2lkZVBhbmVsU2VydmljZSB7XG5cbiAgICBvcGVuJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgb3BlbigpIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQoZmFsc2UpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU2lkZVBhbmVsU2VydmljZSB9IGZyb20gJy4vc2lkZS1wYW5lbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zaWRlLXBhbmVsJyxcbiAgICBleHBvcnRBczogJ3V4LXNpZGUtcGFuZWwnLFxuICAgIHRlbXBsYXRlVXJsOiAnc2lkZS1wYW5lbC5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbU2lkZVBhbmVsU2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndXgtc2lkZS1wYW5lbCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5vcGVuJylcbiAgICBnZXQgb3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5vcGVuJC52YWx1ZTtcbiAgICB9XG5cbiAgICBzZXQgb3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnNlcnZpY2Uub3BlbiQubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlubGluZScpXG4gICAgaW5saW5lID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGF0dGFjaFRvOiAnd2luZG93JyB8ICdjb250YWluZXInID0gJ3dpbmRvdyc7XG5cbiAgICBASW5wdXQoKVxuICAgIHdpZHRoOiBzdHJpbmcgfCBudW1iZXIgPSAnNTAlJztcblxuICAgIEBJbnB1dCgpXG4gICAgdG9wOiBzdHJpbmcgfCBudW1iZXIgPSAnMCc7XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW1vZGFsJylcbiAgICBtb2RhbCA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmFuaW1hdGUnKVxuICAgIGFuaW1hdGUgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgY2xvc2VPbkV4dGVybmFsQ2xpY2sgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgZm9jdXNPblNob3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKVxuICAgIG9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICdzdGF0aWMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaFRvID09PSAnY29udGFpbmVyJykge1xuICAgICAgICAgICAgcmV0dXJuICdhYnNvbHV0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdmaXhlZCc7XG4gICAgfVxuXG4gICAgZ2V0IGNzc1dpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy53aWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSAwID8gJzAnIDogdGhpcy53aWR0aCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0IGNzc1RvcCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wID09PSAwID8gJzAnIDogdGhpcy50b3AgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvcDtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLndpZHRoJylcbiAgICBnZXQgY29tcG9uZW50V2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5jc3NXaWR0aCA6ICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgaG9zdFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmxpbmUgPyAnMTAwJScgOiB0aGlzLmNzc1dpZHRoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcm90ZWN0ZWQgc2VydmljZTogU2lkZVBhbmVsU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZlxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLm9wZW4kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShpc09wZW4gPT4gdGhpcy5vcGVuQ2hhbmdlLmVtaXQoaXNPcGVuKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIG9wZW5QYW5lbCgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLm9wZW4oKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDprZXl1cC5lc2NhcGUnKVxuICAgIGNsb3NlUGFuZWwoKSB7XG4gICAgICAgIHRoaXMuc2VydmljZS5jbG9zZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgICBjbGlja0hhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW4gfHwgIXRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcblxuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpIHx8XG4gICAgICAgICAgICAodGFyZ2V0ICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21vZGFsLWJhY2tkcm9wJykpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU2lkZVBhbmVsQ29tcG9uZW50IH0gZnJvbSAnLi4vc2lkZS1wYW5lbC9zaWRlLXBhbmVsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTaWRlUGFuZWxTZXJ2aWNlIH0gZnJvbSAnLi4vc2lkZS1wYW5lbC9zaWRlLXBhbmVsLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEl0ZW1EaXNwbGF5UGFuZWxDb250ZW50XSdcbn0pXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbENvbnRlbnREaXJlY3RpdmUgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SXRlbURpc3BsYXlQYW5lbEZvb3Rlcl0nXG59KVxuZXhwb3J0IGNsYXNzIEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmUgeyB9XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtaXRlbS1kaXNwbGF5LXBhbmVsJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vaXRlbS1kaXNwbGF5LXBhbmVsLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtTaWRlUGFuZWxTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd1eC1zaWRlLXBhbmVsIHV4LWl0ZW0tZGlzcGxheS1wYW5lbCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEl0ZW1EaXNwbGF5UGFuZWxDb21wb25lbnQgZXh0ZW5kcyBTaWRlUGFuZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG5cbiAgICBASW5wdXQoKSBib3hTaGFkb3c6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KCkgY2xvc2VWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGdldCBwcmV2ZW50Q2xvc2UoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljaztcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBwcmV2ZW50Q2xvc2UodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayA9ICF2YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzaGFkb3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKSB2aXNpYmxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBAQ29udGVudENoaWxkKEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmUpIGZvb3RlcjogSXRlbURpc3BsYXlQYW5lbEZvb3RlckRpcmVjdGl2ZTtcbiAgICBAVmlld0NoaWxkKCdwYW5lbCcpIHBhbmVsOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBUaXRsZSB1c2VkIGZvciBhZGRpbmcgdG9vbHRpcHMgYW5kIHNob3VsZG4ndCBiZSB1c2VkIGFzIGFuIGlucHV0XG4gICAgICogaW5zdGVhZCBoZWFkZXIgd2lsbCBiZSB1c2VkLiBUaGlzIGlzIGhlcmUgdG8gc3VwcG9ydCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9ubHlcbiAgICAgKiB0aGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCB0aXRsZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXI7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgdmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW47XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc2VydmljZTogU2lkZVBhbmVsU2VydmljZSwgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcihzZXJ2aWNlLCBlbGVtZW50UmVmKTtcblxuICAgICAgICB0aGlzLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayA9IHRydWU7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2VydmljZS5vcGVuJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoaXNWaXNpYmxlID0+IHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KGlzVmlzaWJsZSkpO1xuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5wYW5lbCkge1xuICAgICAgICAgICAgdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c0lmTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb2N1cy1pZi9mb2N1cy1pZi5tb2R1bGUnO1xuaW1wb3J0IHsgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCwgSXRlbURpc3BsYXlQYW5lbENvbnRlbnREaXJlY3RpdmUsIEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmUgfSBmcm9tICcuL2l0ZW0tZGlzcGxheS1wYW5lbC5jb21wb25lbnQnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCxcbiAgICBJdGVtRGlzcGxheVBhbmVsQ29udGVudERpcmVjdGl2ZSxcbiAgICBJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb2N1c0lmTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbE1vZHVsZSB7fSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEV2ZW50RW1pdHRlciwgSG9zdCwgSG9zdEJpbmRpbmcsIEluamVjdCwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXdpemFyZC1zdGVwJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vd2l6YXJkLXN0ZXAuY29tcG9uZW50Lmh0bWwnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxuICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdpZCArIFwiLWxhYmVsXCInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRTdGVwQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSB2aXNpdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgcHJpdmF0ZSBfYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdmlzaXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgdmlzaXRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0ZWQ7XG4gICAgfVxuXG4gICAgc2V0IHZpc2l0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmlzaXRlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZpc2l0ZWRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgc2V0IGFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHN0ZXBcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIHRydWUgdGhlbiB0aGUgc3RlcCBzaG91bGQgYWxzbyBiZSBtYXJrZWQgYXMgdmlzaXRlZFxuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1leHBhbmRlZCcpXG4gICAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2lkJykgaWQ6IHN0cmluZztcbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi93aXphcmQtc3RlcC5jb21wb25lbnQnO1xuXG5sZXQgdW5pcXVlSWQ6IG51bWJlciA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtd2l6YXJkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vd2l6YXJkLmNvbXBvbmVudC5odG1sJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3NdJzogJ29yaWVudGF0aW9uJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuXG4gICAgQElucHV0KCkgbmV4dFRleHQ6IHN0cmluZyA9ICdOZXh0JztcbiAgICBASW5wdXQoKSBwcmV2aW91c1RleHQ6IHN0cmluZyA9ICdQcmV2aW91cyc7XG4gICAgQElucHV0KCkgY2FuY2VsVGV4dDogc3RyaW5nID0gJ0NhbmNlbCc7XG4gICAgQElucHV0KCkgZmluaXNoVGV4dDogc3RyaW5nID0gJ0ZpbmlzaCc7XG5cbiAgICBASW5wdXQoKSBuZXh0VG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBuZXh0IHN0ZXAnO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBwcmV2aW91cyBzdGVwJztcbiAgICBASW5wdXQoKSBjYW5jZWxUb29sdGlwOiBzdHJpbmcgPSAnQ2FuY2VsIHRoZSB3aXphcmQnO1xuICAgIEBJbnB1dCgpIGZpbmlzaFRvb2x0aXA6IHN0cmluZyA9ICdGaW5pc2ggdGhlIHdpemFyZCc7XG5cbiAgICBASW5wdXQoKSBuZXh0QXJpYUxhYmVsOiBzdHJpbmcgPSAnR28gdG8gdGhlIG5leHQgc3RlcCc7XG4gICAgQElucHV0KCkgcHJldmlvdXNBcmlhTGFiZWw6IHN0cmluZyA9ICdHbyB0byB0aGUgcHJldmlvdXMgc3RlcCc7XG4gICAgQElucHV0KCkgY2FuY2VsQXJpYUxhYmVsOiBzdHJpbmcgPSAnQ2FuY2VsIHRoZSB3aXphcmQnO1xuICAgIEBJbnB1dCgpIGZpbmlzaEFyaWFMYWJlbDogc3RyaW5nID0gJ0ZpbmlzaCB0aGUgd2l6YXJkJztcblxuICAgIEBJbnB1dCgpIG5leHREaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBjYW5jZWxEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGZpbmlzaERpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBuZXh0VmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgcHJldmlvdXNWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBjYW5jZWxWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBmaW5pc2hWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBjYW5jZWxBbHdheXNWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgZmluaXNoQWx3YXlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQE91dHB1dCgpIG9uTmV4dCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICAgIEBPdXRwdXQoKSBvblByZXZpb3VzID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG4gICAgQE91dHB1dCgpIG9uQ2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBvbkZpbmlzaGluZyA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgb25GaW5pc2ggPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIHN0ZXBDaGFuZ2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8U3RlcENoYW5naW5nRXZlbnQ+KCk7XG4gICAgQE91dHB1dCgpIHN0ZXBDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgICBAT3V0cHV0KCkgc3RlcEVycm9yID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKFdpemFyZFN0ZXBDb21wb25lbnQpIHN0ZXBzID0gbmV3IFF1ZXJ5TGlzdDxXaXphcmRTdGVwQ29tcG9uZW50PigpO1xuXG4gICAgaWQ6IHN0cmluZyA9IGB1eC13aXphcmQtJHt1bmlxdWVJZCsrfWA7XG4gICAgaW52YWxpZEluZGljYXRvcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgc3RlcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gICAgfVxuICAgIHNldCBzdGVwKHZhbHVlOiBudW1iZXIpIHtcblxuICAgICAgICAvLyBvbmx5IGFjY2VwdCBudW1iZXJzIGFzIHZhbGlkIG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGFjdGl2ZSBzdGVwXG4gICAgICAgICAgICB0aGlzLl9zdGVwID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB3aGljaCBzdGVwcyBzaG91bGQgYmUgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuc3RlcENoYW5nZS5uZXh0KHRoaXMuc3RlcCk7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBpbnZhbGlkIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmludmFsaWRJbmRpY2F0b3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX3N0ZXA6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpbml0aWFsbHkgc2V0IHRoZSBjb3JyZWN0IHZpc2liaWxpdHkgb2YgdGhlIHN0ZXBzXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gaW5pdGlhbGx5IHNldCB0aGUgaWRzIGZvciBlYWNoIHN0ZXBcbiAgICAgICAgdGhpcy5zZXRXaXphcmRTdGVwSWRzKCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHN0ZXBzIGNoYW5nZSB0aGVuIHVwZGF0ZSB0aGUgaWRzXG4gICAgICAgIHRoaXMuc3RlcHMuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zZXRXaXphcmRTdGVwSWRzKCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogU2V0IGlkcyBmb3IgZWFjaCBvZiB0aGUgd2l6YXJkIHN0ZXBzICovXG4gICAgc2V0V2l6YXJkU3RlcElkcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwLCBpZHgpID0+IHN0ZXAuaWQgPSBgJHt0aGlzLmlkfS1zdGVwLSR7aWR4fWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIHRvIHRoZSBuZXh0IHN0ZXBcbiAgICAgKi9cbiAgICBuZXh0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuc3RlcENoYW5naW5nLm5leHQobmV3IFN0ZXBDaGFuZ2luZ0V2ZW50KHRoaXMuc3RlcCwgdGhpcy5zdGVwICsgMSkpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgc3RlcCBpcyBpbnZhbGlkXG4gICAgICAgIGlmICghdGhpcy5nZXRDdXJyZW50U3RlcCgpLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRJbmRpY2F0b3IgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGVwRXJyb3IubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiB0aGUgbGFzdCBzdGVwXG4gICAgICAgIGlmICgodGhpcy5zdGVwICsgMSkgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwKys7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGN1cnJlbnQgc3RlcFxuICAgICAgICAgICAgdGhpcy5vbk5leHQubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgKi9cbiAgICBwcmV2aW91cygpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLnN0ZXBDaGFuZ2luZy5uZXh0KG5ldyBTdGVwQ2hhbmdpbmdFdmVudCh0aGlzLnN0ZXAsIHRoaXMuc3RlcCAtIDEpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIHRoZSBsYXN0IHN0ZXBcbiAgICAgICAgaWYgKHRoaXMuc3RlcCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcC0tO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgICAgIHRoaXMub25QcmV2aW91cy5uZXh0KHRoaXMuc3RlcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFjdGlvbnMgd2hlbiB0aGUgZmluaXNoIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICovXG4gICAgZmluaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgICAgIC8vIGZpcmVzIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZCBhbHdheXNcbiAgICAgICAgdGhpcy5vbkZpbmlzaGluZy5uZXh0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSB3ZSBuZWVkIHRvIGVuc3VyZSBjaGFuZ2UgZGV0ZWN0aW9uIGhhcyBydW5cbiAgICAgICAgICogdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHdlIGhhdmUgdGhlIGxhdGVzdCB2YWx1ZSBmb3IgdGhlICd2YWxpZCcgaW5wdXRcbiAgICAgICAgICogb24gdGhlIGN1cnJlbnQgc3RlcC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndCB1c2UgQ2hhbmdlRGV0ZWN0b3JSZWYgYXMgd2UgYXJlIGxvb2tpbmcgdG8gcnVuXG4gICAgICAgICAqIG9uIGNvbnRlbnQgY2hpbGRyZW4sIGFuZCB3ZSBjYW50IHVzZSBBcHBsaWNhdGlvblJlZi50aWNrKCkgYXMgdGhpcyBkb2VzIG5vdCB3b3JrIGluIGEgaHlicmlkIGFwcCwgZWcuIG91ciBkb2NzXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZmlyZXMgd2hlbiB0aGUgZmluaXNoIGJ1dHRvbiBpcyBjbGlja2VkIGFuZCB0aGUgc3RlcCBpcyB2YWxpZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldEN1cnJlbnRTdGVwKCkudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZpbmlzaC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVwRXJyb3IubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFjdGlvbnMgd2hlbiB0aGUgY2FuY2VsIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICovXG4gICAgY2FuY2VsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2FuY2VsLm5leHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGFjdGl2ZSBzdGF0ZSBvZiBlYWNoIHN0ZXBcbiAgICAgKi9cbiAgICB1cGRhdGUoKTogdm9pZCB7XG4gICAgICAgIC8vIHVwZGF0ZSB3aGljaCBzdGVwcyBzaG91bGQgYmUgYWN0aXZlXG4gICAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcCwgaWR4KSA9PiBzdGVwLmFjdGl2ZSA9IGlkeCA9PT0gdGhpcy5zdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKdW1wIHRvIGEgc3BlY2lmaWMgc3RlcCBvbmx5IGlmIHRoZSBzdGVwIGhhcyBwcmV2aW91c2x5IGJlZW4gdmlzaXRlZFxuICAgICAqL1xuICAgIGdvdG9TdGVwKHN0ZXA6IFdpemFyZFN0ZXBDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHN0ZXAudmlzaXRlZCkge1xuXG4gICAgICAgICAgICBjb25zdCBzdGVwSW5kZXggPSB0aGlzLnN0ZXBzLnRvQXJyYXkoKS5maW5kSW5kZXgoc3RwID0+IHN0cCA9PT0gc3RlcCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RlcENoYW5naW5nLm5leHQobmV3IFN0ZXBDaGFuZ2luZ0V2ZW50KHRoaXMuc3RlcCwgc3RlcEluZGV4KSk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RlcCA9IHN0ZXBJbmRleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgY3VycmVudCBzdGVwIGlzIHRoZSBsYXN0IHN0ZXBcbiAgICAgKi9cbiAgICBpc0xhc3RTdGVwKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwID09PSAodGhpcy5zdGVwcy5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgd2l6YXJkIC0gZ29lcyB0byBmaXJzdCBzdGVwIGFuZCByZXNldHMgdmlzaXRlZCBzdGF0ZVxuICAgICAqL1xuICAgIHJlc2V0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIG1hcmsgYWxsIHN0ZXBzIGFzIG5vdCB2aXNpdGVkXG4gICAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaChzdGVwID0+IHN0ZXAudmlzaXRlZCA9IGZhbHNlKTtcblxuICAgICAgICAvLyBnbyB0byB0aGUgZmlyc3Qgc3RlcFxuICAgICAgICB0aGlzLnN0ZXAgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RlcCBhdCB0aGUgY3VycmVudCBpbmRleFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRTdGVwKCk6IFdpemFyZFN0ZXBDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGVwQXRJbmRleCh0aGlzLnN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0ZXAgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAqL1xuICAgIGdldFN0ZXBBdEluZGV4KGluZGV4OiBudW1iZXIpOiBXaXphcmRTdGVwQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMudG9BcnJheSgpW2luZGV4XTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdGVwQ2hhbmdpbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGZyb206IG51bWJlciwgcHVibGljIHRvOiBudW1iZXIpIHsgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgV2l6YXJkQ29tcG9uZW50IH0gZnJvbSAnLi93aXphcmQuY29tcG9uZW50JztcbmltcG9ydCB7IFdpemFyZFN0ZXBDb21wb25lbnQgfSBmcm9tICcuL3dpemFyZC1zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5TW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9hY2Nlc3NpYmlsaXR5L2FjY2Vzc2liaWxpdHkubW9kdWxlJztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFdpemFyZENvbXBvbmVudCxcbiAgICBXaXphcmRTdGVwQ29tcG9uZW50XG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgICAgICBBY2Nlc3NpYmlsaXR5TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBpcyByZXF1aXJlZCB0byBwcm92aWRlIGEgZm9ybSBvZiBjb21tdW5pY2F0aW9uXG4gKiBiZXR3ZWVuIHRoZSBtYXJxdWVlIHdpemFyZCBzdGVwcyBhbmQgdGhlIGNvbnRhaW5pbmcgbWFycXVlZSB3aXphcmQuXG4gKiBXZSBjYW5ub3QgaW5qZWN0IHRoZSBIb3N0IGR1ZSB0byB0aGUgc3RlcHMgYmVpbmcgY29udGVudCBjaGlsZHJlbiBcbiAqIHJhdGhlciB0aGFuIHZpZXcgY2hpbGRyZW4uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkU2VydmljZSB7XG4gICAgdmFsaWQkID0gbmV3IFN1YmplY3Q8TWFycXVlZVdpemFyZFZhbGlkRXZlbnQ+KCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFZhbGlkRXZlbnQge1xuICAgIHN0ZXA6IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50O1xuICAgIHZhbGlkOiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTZXJ2aWNlIH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tYXJxdWVlLXdpemFyZC1zdGVwJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQgZXh0ZW5kcyBXaXphcmRTdGVwQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGljb246IHN0cmluZztcbiAgICBASW5wdXQoKSBjb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBAT3V0cHV0KCkgY29tcGxldGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuICAgIFxuICAgIGdldCB2YWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgIH1cblxuICAgIHNldCB2YWxpZCh2YWxpZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWxpZCA9IHZhbGlkO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXJxdWVlV2l6YXJkU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFycXVlZVdpemFyZFNlcnZpY2UudmFsaWQkLm5leHQoeyBzdGVwOiB0aGlzLCB2YWxpZDogdmFsaWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWxpZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXJxdWVlV2l6YXJkU2VydmljZTogTWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNvbXBsZXRlZCBzdGF0ZSBhbmQgZW1pdCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICogQHBhcmFtIGNvbXBsZXRlZCB3aGV0aGVyIG9yIG5vdCB0aGUgc3RlcCBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBzZXRDb21wbGV0ZWQoY29tcGxldGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gY29tcGxldGVkO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZENoYW5nZS5lbWl0KGNvbXBsZXRlZCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgV2l6YXJkQ29tcG9uZW50IH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC1zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU2VydmljZSwgTWFycXVlZVdpemFyZFZhbGlkRXZlbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LW1hcnF1ZWUtd2l6YXJkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbWFycXVlZS13aXphcmQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogWyBNYXJxdWVlV2l6YXJkU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRDb21wb25lbnQgZXh0ZW5kcyBXaXphcmRDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGVzY3JpcHRpb246IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG4gICAgQENvbnRlbnRDaGlsZHJlbihNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCkgc3RlcHMgPSBuZXcgUXVlcnlMaXN0PE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50PigpO1xuXG4gICAgZ2V0IGlzVGVtcGxhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uICYmIHRoaXMuZGVzY3JpcHRpb24gaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihtYXJxdWVlV2l6YXJkU2VydmljZTogTWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBtYXJxdWVlV2l6YXJkU2VydmljZS52YWxpZCQucGlwZShmaWx0ZXIoKGV2ZW50OiBNYXJxdWVlV2l6YXJkVmFsaWRFdmVudCkgPT4gIWV2ZW50LnZhbGlkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy52YWxpZENoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgY3VycmVudCBzdGVwIGlzIHZhbGlkLCBtYXJrIGl0IGFzXG4gICAgICogY29tcGxldGUgYW5kIGdvIHRvIHRoZSBuZXh0IHN0ZXBcbiAgICAgKi9cbiAgICBuZXh0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBzdGVwXG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCkgYXMgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQ7XG5cbiAgICAgICAgaWYgKHN0ZXAudmFsaWQpIHtcbiAgICAgICAgICAgIHN1cGVyLm5leHQoKTtcblxuICAgICAgICAgICAgLy8gbWFyayB0aGlzIHN0ZXAgYXMgY29tcGxldGVkXG4gICAgICAgICAgICBzdGVwLnNldENvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcEVycm9yLm5leHQodGhpcy5zdGVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIG9uRmluaXNoaW5nIGV2ZW50IGFuZCBpZiB2YWxpZCB0aGUgb25GaW5pc2ggZXZlbnQuXG4gICAgICogQWxzbyBtYXJrIHRoZSBmaW5hbCBzdGVwIGFzIGNvbXBsZXRlZCBpZiBpdCBpcyB2YWxpZFxuICAgICAqL1xuICAgIGZpbmlzaCgpOiBQcm9taXNlPHZvaWQ+IHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc3RlcFxuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpIGFzIE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50O1xuXG4gICAgICAgIC8vIGNhbGwgdGhlIG9yaWdpbmFsIGZpbmlzaCBmdW5jdGlvblxuICAgICAgICByZXR1cm4gc3VwZXIuZmluaXNoKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3RlcCBpcyB2YWxpZCBpbmRpY2F0ZSB0aGF0IGl0IGlzIG5vdyBjb21wbGV0ZVxuICAgICAgICAgICAgaWYgKHN0ZXAudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBzdGVwLnNldENvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwRXJyb3IubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBhIHN0ZXAgaW4gdGhlIHdpemFyZCBiZWNvbWVzIGludmFsaWQsIGFsbCBzdGVwcyBzZXF1ZW50aWFsbHkgYWZ0ZXJcbiAgICAgKiBpdCwgc2hvdWxkIGJlY29tZSB1bnZpc2l0ZWQgYW5kIGluY29tcGxldGVcbiAgICAgKi9cbiAgICB2YWxpZENoYW5nZShzdGF0ZTogTWFycXVlZVdpemFyZFZhbGlkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBzdGVwcyA9IHRoaXMuc3RlcHMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gc3RlcHMuZmluZEluZGV4KHN0ZXAgPT4gc3RlcCA9PT0gc3RhdGUuc3RlcCk7XG4gICAgICAgIGNvbnN0IGFmZmVjdGVkID0gc3RlcHMuc2xpY2UoY3VycmVudCk7XG5cbiAgICAgICAgYWZmZWN0ZWQuZm9yRWFjaChzdGVwID0+IHtcblxuICAgICAgICAgICAgLy8gdGhlIHN0ZXAgc2hvdWxkIG5vIGxvbmdlciBiZSBjb21wbGV0ZWRcbiAgICAgICAgICAgIHN0ZXAuY29tcGxldGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGVwIGlzIG5vdCB0aGUgY3VycmVudCBzdGVwIHRoZW4gYWxzbyBtYXJrIGl0IGFzIHVudmlzaXRlZFxuICAgICAgICAgICAgaWYgKHN0ZXAgIT09IHN0YXRlLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBzdGVwLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFdpemFyZE1vZHVsZSB9IGZyb20gJy4uL3dpemFyZC9pbmRleCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IEFjY2Vzc2liaWxpdHlNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBXaXphcmRNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGUsXG4gICAgICAgIEFjY2Vzc2liaWxpdHlNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTWFycXVlZVdpemFyZENvbXBvbmVudCxcbiAgICAgICAgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBNYXJxdWVlV2l6YXJkQ29tcG9uZW50LFxuICAgICAgICBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgTWFycXVlZVdpemFyZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgY29uY2F0IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2NvbmNhdCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgY3JlYXRlVmlkZW9QbGF5ZXIoc291cmNlOiBzdHJpbmcpOiBIVE1MVmlkZW9FbGVtZW50IHtcbiAgICAgICAgbGV0IHZpZGVvUGxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdmlkZW9QbGF5ZXIucHJlbG9hZCA9ICdhdXRvJztcbiAgICAgICAgdmlkZW9QbGF5ZXIuc3JjID0gc291cmNlO1xuICAgICAgICByZXR1cm4gdmlkZW9QbGF5ZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDYW52YXMod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnb1RvRnJhbWUodmlkZW9QbGF5ZXI6IEhUTUxWaWRlb0VsZW1lbnQsIHRpbWU6IG51bWJlcik6IE9ic2VydmFibGU8RXZlbnQ+IHtcbiAgICAgICAgdmlkZW9QbGF5ZXIuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50KHZpZGVvUGxheWVyLCB0aW1lID09PSAwID8gJ2xvYWRlZGRhdGEnIDogJ3NlZWtlZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyOiBIVE1MVmlkZW9FbGVtZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB0aW1lOiBudW1iZXIsIHdpZHRoOiBudW1iZXIgPSAxNjAsIGhlaWdodDogbnVtYmVyID0gOTApOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RXh0cmFjdGVkRnJhbWU+KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIGdvIHRvIHNwZWNpZmllZCBmcmFtZVxuICAgICAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHRoaXMuZ29Ub0ZyYW1lKHZpZGVvUGxheWVyLCB0aW1lKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpbWFnZSBmcm9tIGN1cnJlbnQgZnJhbWVcbiAgICAgICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodmlkZW9QbGF5ZXIsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyBpbWFnZTogY2FudmFzLnRvRGF0YVVSTCgpLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCB0aW1lOiB0aW1lIH0pO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0RnJhbWVUaHVtYm5haWwoc291cmNlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0aW1lOiBudW1iZXIpOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlcXVpcmVkIGVsZW1lbnRzXG4gICAgICAgIGxldCB2aWRlb1BsYXllciA9IHRoaXMuY3JlYXRlVmlkZW9QbGF5ZXIoc291cmNlKTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGxldCBmcmFtZVN1YnNjcmlwdGlvbiA9IHRoaXMuZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyLCBjYW52YXMsIHRpbWUsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSByZWxlYXNlIG1lbW9yeSBhZnRlciB3ZSBhcmUgZmluaXNoZWRcbiAgICAgICAgZnJhbWVTdWJzY3JpcHRpb24uc3Vic2NyaWJlKG51bGwsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmcmFtZVN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBnZXRGcmFtZVRodW1ibmFpbHMoc291cmNlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2tpcDogbnVtYmVyID0gNSk6IE9ic2VydmFibGU8RXh0cmFjdGVkRnJhbWU+IHtcblxuICAgICAgICAvLyBjcmVhdGUgcmVxdWlyZWQgZWxlbWVudHNcbiAgICAgICAgbGV0IHZpZGVvUGxheWVyID0gdGhpcy5jcmVhdGVWaWRlb1BsYXllcihzb3VyY2UpO1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RXh0cmFjdGVkRnJhbWU+KSA9PiB7XG5cbiAgICAgICAgICAgIGZyb21FdmVudCh2aWRlb1BsYXllciwgJ2xvYWRlZG1ldGFkYXRhJykuc3Vic2NyaWJlKCgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZnJhbWVzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gc3RhcnQ7IGlkeCA8IGVuZDsgaWR4ICs9IHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVzLnB1c2godGhpcy5nZXRUaHVtYm5haWwodmlkZW9QbGF5ZXIsIGNhbnZhcywgaWR4LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uY2F0KC4uLmZyYW1lcykuc3Vic2NyaWJlKChmcmFtZTogRXh0cmFjdGVkRnJhbWUpID0+IG9ic2VydmVyLm5leHQoZnJhbWUpLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RlZEZyYW1lIHtcbiAgICBpbWFnZTogc3RyaW5nO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgdGltZTogbnVtYmVyO1xufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZyYW1lRXh0cmFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2ZyYW1lLWV4dHJhY3Rpb24uc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgcHJvdmlkZXJzOiBbRnJhbWVFeHRyYWN0aW9uU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIEZyYW1lRXh0cmFjdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcy9SZXBsYXlTdWJqZWN0JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRXh0cmFjdGVkRnJhbWUsIEZyYW1lRXh0cmFjdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2luZGV4JztcbmltcG9ydCB7IE1lZGlhUGxheWVyVHlwZSB9IGZyb20gJy4vbWVkaWEtcGxheWVyLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllclNlcnZpY2Uge1xuXG4gICAgc291cmNlOiBzdHJpbmc7XG4gICAgdHlwZTogTWVkaWFQbGF5ZXJUeXBlID0gJ3ZpZGVvJztcbiAgICBsb2FkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qXG4gICAgICAgIENyZWF0ZSBvYnNlcnZhYmxlcyBmb3IgbWVkaWEgcGxheWVyIGV2ZW50c1xuICAgICovXG4gICAgcGxheWluZzogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgaW5pdEV2ZW50OiBSZXBsYXlTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICBhYm9ydEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBjYW5QbGF5RXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGNhblBsYXlUaHJvdWdoRXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGR1cmF0aW9uQ2hhbmdlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBlbmRlZEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBlcnJvckV2ZW50OiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgbG9hZGVkRGF0YUV2ZW50OiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgbG9hZGVkTWV0YWRhdGFFdmVudDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgIGxvYWRTdGFydEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwYXVzZUV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwbGF5RXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHBsYXlpbmdFdmVudDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcmF0ZUNoYW5nZUV2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgc2Vla2VkRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBzZWVraW5nRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBzdGFsbGVkRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHN1c3BlbmRFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgdGltZVVwZGF0ZUV2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgdm9sdW1lQ2hhbmdlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICB3YWl0aW5nRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIG1lZGlhQ2xpY2tFdmVudDogU3ViamVjdDxNb3VzZUV2ZW50PiA9IG5ldyBTdWJqZWN0PE1vdXNlRXZlbnQ+KCk7XG4gICAgZnVsbHNjcmVlbkV2ZW50OiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBxdWlldE1vZGVFdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcHJvZ3Jlc3NFdmVudDogT2JzZXJ2YWJsZTxUaW1lUmFuZ2VzPiA9IE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VGltZVJhbmdlcz4pID0+IHtcblxuICAgICAgICAvLyByZXBlYXQgdW50aWwgdGhlIHdob2xlIHZpZGVvIGhhcyBmdWxseSBsb2FkZWRcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy5fbWVkaWFQbGF5ZXIuYnVmZmVyZWQgYXMgVGltZVJhbmdlcztcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoYnVmZmVyZWQpO1xuXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID09PSAxICYmIGJ1ZmZlcmVkLnN0YXJ0KDApID09PSAwICYmIGJ1ZmZlcmVkLmVuZCgwKSA9PT0gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH0pO1xuXG4gICAgcHJpdmF0ZSBfbWVkaWFQbGF5ZXI6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBfaG9zdEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgX2Z1bGxzY3JlZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9xdWlldE1vZGU6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9mcmFtZUV4dHJhY3Rpb25TZXJ2aWNlOiBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlKSB7IH1cblxuICAgIC8qXG4gICAgICAgIENyZWF0ZSBhbGwgdGhlIGdldHRlcnMgYW5kIHNldHRlcnMgdGhlIGNhbiBiZSB1c2VkIGJ5IG1lZGlhIHBsYXllciBleHRlbnNpb25zXG4gICAgKi9cbiAgICBnZXQgbWVkaWFQbGF5ZXIoKTogSFRNTE1lZGlhRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllcjtcbiAgICB9XG5cbiAgICBnZXQgcXVpZXRNb2RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVpZXRNb2RlO1xuICAgIH1cblxuICAgIHNldCBxdWlldE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcblxuICAgICAgICAvLyBxdWlldCBtb2RlIGNhbm5vdCBiZSBlbmFibGVkIG9uIGF1ZGlvIHBsYXllclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcXVpZXRNb2RlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucXVpZXRNb2RlRXZlbnQubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IG1lZGlhUGxheWVyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIub2Zmc2V0V2lkdGggOiAwO1xuICAgIH1cblxuICAgIGdldCBtZWRpYVBsYXllckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5vZmZzZXRIZWlnaHQgOiAwO1xuICAgIH1cblxuICAgIGdldCBhdWRpb1RyYWNrcygpOiBBdWRpb1RyYWNrTGlzdCB8IEFycmF5PGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5hdWRpb1RyYWNrcyA6IFtdO1xuICAgIH1cblxuICAgIGdldCBhdXRvcGxheSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuYXV0b3BsYXkgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGF1dG9wbGF5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmF1dG9wbGF5ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGJ1ZmZlcmVkKCk6IFRpbWVSYW5nZXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5idWZmZXJlZCA6IG5ldyBUaW1lUmFuZ2VzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGNyb3NzT3JpZ2luKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmNyb3NzT3JpZ2luIDogbnVsbDtcbiAgICB9XG4gICAgc2V0IGNyb3NzT3JpZ2luKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFNyYygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5jdXJyZW50U3JjIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFRpbWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuY3VycmVudFRpbWUgOiAwO1xuICAgIH1cbiAgICBzZXQgY3VycmVudFRpbWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZWZhdWx0TXV0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRNdXRlZCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdE11dGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRNdXRlZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZWZhdWx0UGxheWJhY2tSYXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRQbGF5YmFja1JhdGUgOiAxO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdFBsYXliYWNrUmF0ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRQbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZHVyYXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuZHVyYXRpb24gOiAwO1xuICAgIH1cblxuICAgIGdldCBlbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuZW5kZWQgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgbG9vcCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIubG9vcCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgbG9vcCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5sb29wID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IG11dGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5tdXRlZCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgbXV0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIubXV0ZWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgbmV0d29ya1N0YXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllci5uZXR3b3JrU3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IHBhdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIucGF1c2VkIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXQgcGxheWJhY2tSYXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnBsYXliYWNrUmF0ZSA6IDE7XG4gICAgfVxuICAgIHNldCBwbGF5YmFja1JhdGUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcGxheWVkKCk6IFRpbWVSYW5nZXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5wbGF5ZWQgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBwcmVsb2FkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnByZWxvYWQgOiAnYXV0byc7XG4gICAgfVxuICAgIHNldCBwcmVsb2FkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucHJlbG9hZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCByZWFkeVN0YXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnJlYWR5U3RhdGUgOiAwO1xuICAgIH1cblxuICAgIGdldCBzZWVrYWJsZSgpOiBUaW1lUmFuZ2VzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuc2Vla2FibGUgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBzZWVraW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5zZWVraW5nIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IHNyYygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5zcmMgOiAnJztcbiAgICB9XG4gICAgc2V0IHNyYyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnNyYyA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0ZXh0VHJhY2tzKCk6IEFycmF5PFRleHRUcmFjaz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyBBcnJheS5mcm9tKHRoaXMuX21lZGlhUGxheWVyLnRleHRUcmFja3MpIDogW107XG4gICAgfVxuXG4gICAgZ2V0IHZpZGVvVHJhY2tzKCk6IEFycmF5PFZpZGVvVHJhY2s+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gQXJyYXkuZnJvbSh0aGlzLl9tZWRpYVBsYXllci52aWRlb1RyYWNrcykgOiBbXTtcbiAgICB9XG5cbiAgICBnZXQgdm9sdW1lKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnZvbHVtZSA6IDE7XG4gICAgfVxuICAgIHNldCB2b2x1bWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fbWVkaWFQbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnZvbHVtZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZ1bGxzY3JlZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX2Z1bGxzY3JlZW4gOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGZ1bGxzY3JlZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZnVsbHNjcmVlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5FdmVudC5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXRNZWRpYVBsYXllcihob3N0RWxlbWVudDogSFRNTEVsZW1lbnQsIG1lZGlhUGxheWVyOiBIVE1MTWVkaWFFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyID0gbWVkaWFQbGF5ZXI7XG5cbiAgICAgICAgdGhpcy5pbml0RXZlbnQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgcGxheWluZyBzdGF0ZVxuICAgICAqL1xuICAgIHRvZ2dsZVBsYXkoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcHJldmVudCBhbnkgYWN0aW9uIGlzIG5vdCBsb2FkZWRcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBwbGF5aW5nIHRoZSBhdWRpby92aWRlb1xuICAgICAqL1xuICAgIHBsYXkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnBsYXkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGF1ZGlvL3ZpZGVvXG4gICAgICovXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmUtbG9hZHMgdGhlIGF1ZGlvL3ZpZGVvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBsb2FkKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5sb2FkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIGNhbiBwbGF5IHRoZSBzcGVjaWZpZWQgYXVkaW8vdmlkZW8gdHlwZVxuICAgICAqL1xuICAgIGNhblBsYXlUeXBlKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllci5jYW5QbGF5VHlwZSh0eXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHRleHQgdHJhY2sgdG8gdGhlIGF1ZGlvL3ZpZGVvXG4gICAgICovXG4gICAgYWRkVGV4dFRyYWNrKGtpbmQ6ICdzdWJ0aXRsZXMnIHwgJ2NhcHRpb25zJyB8ICdkZXNjcmlwdGlvbnMnIHwgJ2NoYXB0ZXJzJyB8ICdtZXRhZGF0YScsIGxhYmVsOiBzdHJpbmcsIGxhbmd1YWdlOiBzdHJpbmcpOiBUZXh0VHJhY2sge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBkaXNwbGF5IG1lZGlhIGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIHJlcXVlc3RGdWxsc2NyZWVuKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLl9ob3N0RWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ob3N0RWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+dGhpcy5faG9zdEVsZW1lbnQpLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhpdCBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICovXG4gICAgZXhpdEZ1bGxzY3JlZW4oKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5leGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT5kb2N1bWVudCkubXNFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+ZG9jdW1lbnQpLm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT5kb2N1bWVudCkubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+ZG9jdW1lbnQpLm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9ICg8YW55PmRvY3VtZW50KS5mdWxsc2NyZWVuIHx8IGRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlbiB8fCAoPGFueT5kb2N1bWVudCkubW96RnVsbFNjcmVlbiB8fCAoPGFueT5kb2N1bWVudCkubXNGdWxsc2NyZWVuRWxlbWVudCAhPT0gbnVsbCAmJiAoPGFueT5kb2N1bWVudCkubXNGdWxsc2NyZWVuRWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5FdmVudC5uZXh0KHRoaXMuZnVsbHNjcmVlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIEZ1bGxzY3JlZW4gU3RhdGVcbiAgICAgKi9cbiAgICB0b2dnbGVGdWxsc2NyZWVuKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5mdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBmcmFtZXMgZnJvbSB0aGUgdmlkZW9cbiAgICAgKi9cbiAgICBnZXRGcmFtZXMod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHNraXA6IG51bWJlcik6IE9ic2VydmFibGU8RXh0cmFjdGVkRnJhbWU+IHtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVFeHRyYWN0aW9uU2VydmljZS5nZXRGcmFtZVRodW1ibmFpbHModGhpcy5zb3VyY2UsIHdpZHRoLCBoZWlnaHQsIDAsIHRoaXMuZHVyYXRpb24sIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcm9tKFtdKTtcbiAgICB9XG5cbiAgICBoaWRlU3VidGl0bGVUcmFja3MoKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnRleHRUcmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRUcmFja3NbaW5kZXhdLm1vZGUgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1lZGlhUGxheWVyU2VydmljZSB9IGZyb20gJy4uL21lZGlhLXBsYXllci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uXSdcbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbWVkaWFQbGF5ZXJTZXJ2aWNlOiBNZWRpYVBsYXllclNlcnZpY2UpIHsgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuL2NvbG9yLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIHByb3ZpZGVyczogW0NvbG9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENvbG9yU2VydmljZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBEb0NoZWNrLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2xpZGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2xpZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIERvQ2hlY2sge1xuXG4gICAgQElucHV0KCkgdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBTbGlkZXJPcHRpb25zO1xuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPFNsaWRlclZhbHVlIHwgbnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8U2xpZGVyVmFsdWUgfCBudW1iZXI+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdsb3dlclRvb2x0aXAnKSBsb3dlclRvb2x0aXA6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndXBwZXJUb29sdGlwJykgdXBwZXJUb29sdGlwOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3RyYWNrJykgdHJhY2s6IEVsZW1lbnRSZWY7XG5cbiAgICAvLyBzdG9yZSBjdXJyZW50IHZhbHVlcyBmb3IgZGVlcCBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgcHJpdmF0ZSBfdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyO1xuXG4gICAgLy8gZXhwb3NlIGVudW1zIHRvIEFuZ3VsYXIgdmlld1xuICAgIHNsaWRlclR5cGUgPSBTbGlkZXJUeXBlO1xuICAgIHNsaWRlclN0eWxlID0gU2xpZGVyU3R5bGU7XG4gICAgc2xpZGVyU2l6ZSA9IFNsaWRlclNpemU7XG4gICAgc2xpZGVyU25hcCA9IFNsaWRlclNuYXA7XG4gICAgc2xpZGVyVGh1bWIgPSBTbGlkZXJUaHVtYjtcbiAgICBzbGlkZXJUaWNrVHlwZSA9IFNsaWRlclRpY2tUeXBlO1xuICAgIHNsaWRlclRodW1iRXZlbnQgPSBTbGlkZXJUaHVtYkV2ZW50O1xuICAgIHNsaWRlckNhbGxvdXRUcmlnZ2VyID0gU2xpZGVyQ2FsbG91dFRyaWdnZXI7XG5cbiAgICB0cmFja3MgPSB7XG4gICAgICAgIGxvd2VyOiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRvb2x0aXBzID0ge1xuICAgICAgICBsb3dlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRodW1icyA9IHtcbiAgICAgICAgbG93ZXI6IHtcbiAgICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWc6IGZhbHNlLFxuICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICBvcmRlcjogMTAwLFxuICAgICAgICAgICAgdmFsdWU6IG51bGwgYXMgbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyOiB7XG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICBkcmFnOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgb3JkZXI6IDEwMSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsIGFzIG51bWJlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0b3JlIGFsbCB0aGUgdGlja3MgdG8gZGlzcGxheVxuICAgIHRpY2tzOiBTbGlkZXJUaWNrW10gPSBbXTtcbiAgICBkZWZhdWx0T3B0aW9uczogU2xpZGVyT3B0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKGNvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlLCBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcblxuICAgICAgICAvLyBzZXR1cCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFNsaWRlclR5cGUuVmFsdWUsXG4gICAgICAgICAgICBoYW5kbGVzOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IFNsaWRlclN0eWxlLkJ1dHRvbixcbiAgICAgICAgICAgICAgICBjYWxsb3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IFNsaWRlckNhbGxvdXRUcmlnZ2VyLk5vbmUsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTInKS50b0hleCgpLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXlib2FyZDoge1xuICAgICAgICAgICAgICAgICAgICBtYWpvcjogNSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyaWE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWI6ICdTbGlkZXIgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICBsb3dlclRodW1iOiAnU2xpZGVyIGxvd2VyIHZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJUaHVtYjogJ1NsaWRlciB1cHBlciB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFNsaWRlclNpemUuV2lkZSxcbiAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc25hcDogU2xpZGVyU25hcC5Ob25lLFxuICAgICAgICAgICAgICAgICAgICBtYWpvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgfCBudW1iZXIgPT4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwczogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogY29sb3JTZXJ2aWNlLmdldENvbG9yKCdncmV5NicpLnRvSGV4KCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjb2xvclNlcnZpY2UuZ2V0Q29sb3IoJ2FjY2VudCcpLnNldEFscGhhKDAuNzUpLnRvUmdiYSgpLFxuICAgICAgICAgICAgICAgICAgICBoaWdoZXI6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTYnKS50b0hleCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlcygpO1xuXG4gICAgICAgIHRoaXMuc2V0VGh1bWJTdGF0ZShTbGlkZXJUaHVtYi5Mb3dlciwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKFNsaWRlclRodW1iLlVwcGVyLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGluaXRpYWwgdmFsdWVcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5uZXh0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCB0aGlzLl92YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHBlcnNpc3RlbnQgdG9vbHRpcHMgd2lsbCBuZWVkIHBvc2l0aW9uZWQgY29ycmVjdGx5IGF0IHRoaXMgc3RhZ2VcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5Mb3dlcik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgICAgIC8vIG1hcmsgYXMgZGlydHlcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzbmFwVG9OZWFyZXN0VGljayh0aHVtYjogU2xpZGVyVGh1bWIsIHNuYXBUYXJnZXQ6IFNsaWRlclNuYXAsIGZvcndhcmRzOiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSBmb3IgdGhlIHRodW1iXG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tzIC0gcmVtb3ZlIGFueSB0aWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gaXRcbiAgICAgICAgY29uc3QgY2xvc2VzdCA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHNuYXBUYXJnZXQpXG4gICAgICAgICAgICAuZmlsdGVyKHRpY2sgPT4gdGljay52YWx1ZSAhPT0gdmFsdWUpXG4gICAgICAgICAgICAuZmluZCh0aWNrID0+IGZvcndhcmRzID8gdGljay52YWx1ZSA+IHZhbHVlIDogdGljay52YWx1ZSA8IHZhbHVlKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIHRpY2tzIHRoZW4gbW92ZSBieSBhIHByZWRlZmluZWQgYW1vdW50XG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIGNsb3Nlc3QudmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzbmFwVGFyZ2V0ID09PSBTbGlkZXJTbmFwLk1ham9yID8gdGhpcy5vcHRpb25zLmhhbmRsZXMua2V5Ym9hcmQubWFqb3IgOiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5rZXlib2FyZC5taW5vcjtcblxuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgdmFsdWUgKyAoZm9yd2FyZHMgPyBzdGVwIDogLXN0ZXApKSk7XG5cbiAgICB9XG5cbiAgICBzbmFwVG9FbmQodGh1bWI6IFNsaWRlclRodW1iLCBmb3J3YXJkczogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgZm9yd2FyZHMgPyB0aGlzLm9wdGlvbnMudHJhY2subWF4IDogdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpO1xuICAgIH1cblxuICAgIGdldFRodW1iVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuZm9ybWF0dGVyKHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJTdGF0ZSh0aHVtYjogU2xpZGVyVGh1bWIpIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMudGh1bWJzLmxvd2VyIDogdGhpcy50aHVtYnMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlN0YXRlKHRodW1iOiBTbGlkZXJUaHVtYiwgaG92ZXI6IGJvb2xlYW4sIGRyYWc6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy5sb3dlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMubG93ZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy51cHBlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMudXBwZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXBzXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcHModGh1bWIpO1xuICAgIH1cblxuICAgIHRodW1iRXZlbnQodGh1bWI6IFNsaWRlclRodW1iLCBldmVudDogU2xpZGVyVGh1bWJFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCB0aHVtYiBzdGF0ZVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJhc2VkIHVwb24gZXZlbnRcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ1N0YXJ0OlxuICAgICAgICAgICAgICAgIHN0YXRlLmRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ0VuZDpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXI6XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTW91c2VMZWF2ZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTm9uZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgc3RhdGVcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKHRodW1iLCBzdGF0ZS5ob3Zlciwgc3RhdGUuZHJhZyk7XG4gICAgfVxuXG4gICAgZ2V0QXJpYVZhbHVlVGV4dCh0aHVtYjogU2xpZGVyVGh1bWIpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdGh1bWIgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFRodW1iVmFsdWUodGh1bWIpO1xuXG4gICAgICAgIC8vIGdldCBhbGwgdGhlIHRpY2tzXG4gICAgICAgIGNvbnN0IHRpY2sgPSB0aGlzLnRpY2tzLmZpbmQoX3RpY2sgPT4gX3RpY2sudmFsdWUgPT09IHZhbHVlKTtcblxuICAgICAgICBpZiAodGljayAmJiB0aWNrLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGljay5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBzaW1wbHkgZGlzcGxheSB0aGUgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZvcm1hdHRlZFZhbHVlKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBzKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlcikge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlckNhbGxvdXRUcmlnZ2VyLlBlcnNpc3RlbnQ6XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyQ2FsbG91dFRyaWdnZXIuRHJhZzpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5Ib3ZlcjpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuaG92ZXIgfHwgc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5EeW5hbWljOlxuICAgICAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgdGh1bWJcbiAgICAgICAgdGhpcy5nZXRUb29sdGlwKHRodW1iKS52aXNpYmxlID0gdmlzaWJsZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgdGV4dFxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFBvc2l0aW9uKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iOiBTbGlkZXJUaHVtYikge1xuXG4gICAgICAgIC8vIGdldCB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmdldFRvb2x0aXAodGh1bWIpO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBmb3JtYXR0ZWQgbGFiZWxcbiAgICAgICAgdG9vbHRpcC5sYWJlbCA9IHRoaXMuZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWIpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwRWxlbWVudCh0aHVtYjogU2xpZGVyVGh1bWIpOiBFbGVtZW50UmVmIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMubG93ZXJUb29sdGlwIDogdGhpcy51cHBlclRvb2x0aXA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwKHRodW1iOiBTbGlkZXJUaHVtYikge1xuICAgICAgICByZXR1cm4gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gdGhpcy50b29sdGlwcy5sb3dlciA6IHRoaXMudG9vbHRpcHMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUb29sdGlwUG9zaXRpb24odGh1bWI6IFNsaWRlclRodW1iKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuZ2V0VG9vbHRpcCh0aHVtYik7XG5cbiAgICAgICAgLy8gaWYgdG9vbHRpcCBpcyBub3QgdmlzaWJsZSB0aGVuIHN0b3AgaGVyZVxuICAgICAgICBpZiAodG9vbHRpcC52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRvb2x0aXBFbGVtZW50ID0gdGhpcy5nZXRUb29sdGlwRWxlbWVudCh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50IHdpZHRoc1xuICAgICAgICBsZXQgdGh1bWJXaWR0aDogbnVtYmVyO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gU2xpZGVyU3R5bGUuQnV0dG9uKSB7XG4gICAgICAgICAgICB0aHVtYldpZHRoID0gdGhpcy5vcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gU2xpZGVyU2l6ZS5OYXJyb3cgPyAxNiA6IDI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGh1bWJXaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9vbHRpcFdpZHRoID0gdG9vbHRpcEVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvb2x0aXBzIG5ldyBwb3NpdGlvblxuICAgICAgICBsZXQgdG9vbHRpcFBvc2l0aW9uID0gTWF0aC5jZWlsKCh0b29sdGlwV2lkdGggLSB0aHVtYldpZHRoKSAvIDIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uXG4gICAgICAgIHRvb2x0aXAucG9zaXRpb24gPSAtdG9vbHRpcFBvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5SYW5nZSAmJiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IFNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFRvb2x0aXBPdmVybGFwKHRvb2x0aXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmV2ZW50VG9vbHRpcE92ZXJsYXAodG9vbHRpcDogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy5sb3dlci5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdXBwZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy51cHBlci5wb3NpdGlvbjtcblxuICAgICAgICBjb25zdCBsb3dlcldpZHRoID0gdGhpcy5sb3dlclRvb2x0aXAubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHVwcGVyV2lkdGggPSB0aGlzLnVwcGVyVG9vbHRpcC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcblxuICAgICAgICBjb25zdCBkaWZmID0gKGxvd2VyICsgbG93ZXJXaWR0aCkgLSAodXBwZXIgLSB1cHBlcldpZHRoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcHMgYXJlIGNsb3NlciB0aGFuIDE2cHggdGhlbiBhZGp1c3Qgc28gdGhlIGRvbnQgbW92ZSBhbnkgY2xvc2VcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy5sb3dlciAmJiB0aGlzLnRodW1icy5sb3dlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gLT0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy51cHBlciAmJiB0aGlzLnRodW1icy51cHBlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gKz0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRodW1iUG9zaXRpb24oZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCB0aHVtYjogU2xpZGVyVGh1bWIpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgZXZlbnQgcG9zaXRpb24gLSBlaXRoZXIgbW91c2Ugb3IgdG91Y2hcbiAgICAgICAgbGV0IGV2ZW50UG9zaXRpb24gPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDAgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBudWxsO1xuXG4gICAgICAgIC8vIGlmIGV2ZW50IHBvc2l0aW9uIGlzIG51bGwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoZXZlbnRQb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGxldCBtb3VzZVggPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBldmVudFBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGdldCB0cmFjayBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICBsZXQgdHJhY2tCb3VuZHMgPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gcmVzdHJpY3QgdGhlIHZhbHVlIHdpdGhpbiB0aGUgcmFuZ2Ugc2l6ZVxuICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLmNsYW1wKG1vdXNlWCAtIHRyYWNrQm91bmRzLmxlZnQsIDAsIHRyYWNrQm91bmRzLndpZHRoKTtcblxuICAgICAgICAvLyBnZXQgZnJhY3Rpb24gcmVwcmVzZW50YXRpb24gb2YgbG9jYXRpb24gd2l0aGluIHRoZSB0cmFja1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSAocG9zaXRpb24gLyB0cmFja0JvdW5kcy53aWR0aCk7XG5cbiAgICAgICAgLy8gY29udmVydCB0byB2YWx1ZSB3aXRoaW4gdGhlIHJhbmdlXG4gICAgICAgIGxldCB2YWx1ZSA9ICgodGhpcy5vcHRpb25zLnRyYWNrLm1heCAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pICogZnJhY3Rpb24pICsgdGhpcy5vcHRpb25zLnRyYWNrLm1pbjtcblxuICAgICAgICAvLyBlbnN1cmUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIHZhbHVlKTtcblxuICAgICAgICAvLyBzbmFwIHRvIGEgdGljayBpZiByZXF1aXJlZFxuICAgICAgICB2YWx1ZSA9IHRoaXMuc25hcFRvVGljayh2YWx1ZSwgdGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVPcmRlcih0aHVtYik7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRvb2x0aXAgdGV4dCAmIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQodGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYWxsIHZpc2libGUgdG9vbHRpcHNcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwUG9zaXRpb24oU2xpZGVyVGh1bWIuTG93ZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgLy8gbWFyayBhcyBkaXJ0eSBmb3IgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU9yZGVyKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCBsb3dlciA9IHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IDEwMSA6IDEwMDtcbiAgICAgICAgbGV0IHVwcGVyID0gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gMTAwIDogMTAxO1xuXG4gICAgICAgIC8vIFRoZSBtb3N0IHJlY2VudGx5IHVzZWQgdGh1bWIgc2hvdWxkIGJlIGFib3ZlXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLm9yZGVyID0gbG93ZXI7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLm9yZGVyID0gdXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaWNrRGlzdGFuY2VzKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYiwgc25hcFRhcmdldDogU2xpZGVyU25hcCk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gaWYgc25hcCB0YXJnZXQgaXMgbm9uZSB0aGVuIHJldHVybiBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICBpZiAoc25hcFRhcmdldCA9PT0gU2xpZGVyU25hcC5Ob25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZmlsdGVyZWQgdGlja3NcbiAgICAgICAgbGV0IHRpY2tzOiBTbGlkZXJUaWNrW107XG5cbiAgICAgICAgc3dpdGNoIChzbmFwVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NaW5vcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NaW5vcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NYWpvcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBsaW1pdFxuICAgICAgICBsZXQgbG93ZXJMaW1pdCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCB1cHBlckxpbWl0ID0gdGhpcy5vcHRpb25zLnRyYWNrLm1heDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy50aHVtYnMudXBwZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLlVwcGVyKSB7XG4gICAgICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy50aHVtYnMubG93ZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHRpY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWNrcy5maWx0ZXIodGljayA9PiB0aWNrLnZhbHVlID49IGxvd2VyTGltaXQgJiYgdGljay52YWx1ZSA8PSB1cHBlckxpbWl0KTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY2xvc2UgdGlja3MgaW4gdGhlIHZhbGlkIHJhbmdlIHRoZW4gZG9udCBzbmFwXG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZS5zb3J0KCh0aWNrT25lLCB0aWNrVHdvKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRpY2tPbmVEZWx0YSA9IE1hdGgubWF4KHRpY2tPbmUudmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tPbmUudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tUd29EZWx0YSA9IE1hdGgubWF4KHRpY2tUd28udmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tUd28udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRpY2tPbmVEZWx0YSAtIHRpY2tUd29EZWx0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzbmFwVG9UaWNrKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgdGlja0Rpc3RhbmNlcyA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5zbmFwKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdGlja3MgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGlmICh0aWNrRGlzdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tcbiAgICAgICAgcmV0dXJuIHRpY2tEaXN0YW5jZXNbMF0udmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgLy8gaWYgc2xpZGVyIGlzIG5vdCBhIHJhbmdlIHZhbHVlIGlzIGFsd2F5cyB2YWxpZCBwcm92aWRpbmcgaXQgaXMgd2l0aGluIHRoZSBjaGFydCBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBTbGlkZXJUeXBlLlZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIHRoaXMub3B0aW9ucy50cmFjay5tYXgpLCB0aGlzLm9wdGlvbnMudHJhY2subWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIHdpdGggY2hhcnQgcmFuZ2VzXG4gICAgICAgIGlmICh2YWx1ZSA+IHRoaXMub3B0aW9ucy50cmFjay5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIgPyBNYXRoLm1pbih0aGlzLm9wdGlvbnMudHJhY2subWF4LCB0aGlzLnRodW1icy51cHBlci52YWx1ZSkgOiB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5vcHRpb25zLnRyYWNrLm1pbikge1xuICAgICAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5VcHBlciA/IE1hdGgubWF4KHRoaXMub3B0aW9ucy50cmFjay5taW4sIHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlKSA6IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayB0byBtYWtlIHN1cmUgbG93ZXIgdGh1bWIgY2Fubm90IGdvIGFib3ZlIGhpZ2hlciBhbmQgdmljZSB2ZXJzYVxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRodW1icy51cHBlci52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID8gdmFsdWUgOiB0aGlzLnRodW1icy51cHBlci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aHVtYiA9PT0gU2xpZGVyVGh1bWIuVXBwZXIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPyB2YWx1ZSA6IHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVPcHRpb25zKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFkZCBpbiB0aGUgZGVmYXVsdCBvcHRpb25zIHRoYXQgdXNlciBoYXNuJ3Qgc3BlY2lmaWVkXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuZGVlcE1lcmdlKHRoaXMub3B0aW9ucyB8fCB7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFja0NvbG9ycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpY2tzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVWYWx1ZXMoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb3dlclZhbHVlID0gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUubG93O1xuICAgICAgICBsZXQgdXBwZXJWYWx1ZSA9IHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJyA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmhpZ2g7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdmFsdWVzXG4gICAgICAgIGxvd2VyVmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUoU2xpZGVyVGh1bWIuTG93ZXIsIE51bWJlcihsb3dlclZhbHVlLnRvRml4ZWQoNCkpKTtcbiAgICAgICAgdXBwZXJWYWx1ZSA9IHRoaXMudmFsaWRhdGVWYWx1ZShTbGlkZXJUaHVtYi5VcHBlciwgTnVtYmVyKHVwcGVyVmFsdWUudG9GaXhlZCg0KSkpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGFzIHBlcmNlbnRhZ2VzXG4gICAgICAgIGxldCBsb3dlclBvc2l0aW9uID0gKCgobG93ZXJWYWx1ZSAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pIC8gKHRoaXMub3B0aW9ucy50cmFjay5tYXggLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSkgKiAxMDApO1xuICAgICAgICBsZXQgdXBwZXJQb3NpdGlvbiA9ICgoKHVwcGVyVmFsdWUgLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSAvICh0aGlzLm9wdGlvbnMudHJhY2subWF4IC0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpICogMTAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGh1bWIgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLnBvc2l0aW9uID0gbG93ZXJQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50aHVtYnMudXBwZXIucG9zaXRpb24gPSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhY2sgc2l6ZXNcbiAgICAgICAgdGhpcy50cmFja3MubG93ZXIuc2l6ZSA9IGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLm1pZGRsZS5zaXplID0gdXBwZXJQb3NpdGlvbiAtIGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLnVwcGVyLnNpemUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IDEwMCAtIGxvd2VyUG9zaXRpb24gOiAxMDAgLSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgaW5wdXRcbiAgICAgICAgdGhpcy5zZXRWYWx1ZShsb3dlclZhbHVlLCB1cHBlclZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFZhbHVlKGxvdzogbnVtYmVyLCBoaWdoPzogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPSBsb3c7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID0gaGlnaDtcblxuICAgICAgICBsZXQgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY2xvbmUodGhpcy5fdmFsdWUpO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IGxvdyA6IHsgbG93OiBsb3csIGhpZ2g6IGhpZ2ggfTtcblxuICAgICAgICAvLyBjYWxsIHRoZSBldmVudCBlbWl0dGVyIGlmIGNoYW5nZXMgb2NjdXJlZFxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCBwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KFNsaWRlclRodW1iLkxvd2VyKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQoU2xpZGVyVGh1bWIuVXBwZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIGZvcndhcmQgdGhlc2UgY2hhbmdlcyB0byB0aGUgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnRodW1icy5sb3dlci52YWx1ZSwgdGhpcy50aHVtYnMudXBwZXIudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVGlja3MoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRpY2sgb3B0aW9uc1xuICAgICAgICBjb25zdCBtYWpvck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudHJhY2sudGlja3MubWFqb3I7XG4gICAgICAgIGNvbnN0IG1pbm9yT3B0aW9ucyA9IHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5taW5vcjtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzaG91bGQgc2hvdyB0aWNrc1xuICAgICAgICBpZiAobWFqb3JPcHRpb25zLnNob3cgPT09IGZhbHNlICYmIG1pbm9yT3B0aW9ucy5zaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2tzIGZvciBib3RoIG1ham9yIGFuZCBtaW5vciAtIG9ubHkgZ2V0IHRoZSBvbmVzIHRvIGJlIHNob3duXG4gICAgICAgIGNvbnN0IG1ham9yVGlja3MgPSB0aGlzLmdldFRpY2tzKG1ham9yT3B0aW9ucywgU2xpZGVyVGlja1R5cGUuTWFqb3IpLmZpbHRlcih0aWNrID0+IHRpY2suc2hvd1RpY2tzKTtcbiAgICAgICAgY29uc3QgbWlub3JUaWNrcyA9IHRoaXMuZ2V0VGlja3MobWlub3JPcHRpb25zLCBTbGlkZXJUaWNrVHlwZS5NaW5vcikuZmlsdGVyKHRpY2sgPT4gdGljay5zaG93VGlja3MpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgbWlub3IgdGlja3MgdGhhdCBhcmUgb24gYSBtYWpvciBpbnRlcnZhbFxuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy51bmlvblRpY2tzKG1ham9yVGlja3MsIG1pbm9yVGlja3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVHJhY2tDb2xvcnMoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IGNvbG9ycyBmb3IgZWFjaCBwYXJ0IG9mIHRoZSB0cmFja1xuICAgICAgICBjb25zdCB7IGxvd2VyLCByYW5nZSwgaGlnaGVyIH0gPSB0aGlzLm9wdGlvbnMudHJhY2suY29sb3JzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29udHJvbGxlciB2YWx1ZVxuICAgICAgICB0aGlzLnRyYWNrcy5sb3dlci5jb2xvciA9IHR5cGVvZiBsb3dlciA9PT0gJ3N0cmluZycgPyBsb3dlciA6IGBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICR7bG93ZXIuam9pbignLCAnKX0pYDtcbiAgICAgICAgdGhpcy50cmFja3MubWlkZGxlLmNvbG9yID0gdHlwZW9mIHJhbmdlID09PSAnc3RyaW5nJyA/IHJhbmdlIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtyYW5nZS5qb2luKCcsICcpfSlgO1xuICAgICAgICB0aGlzLnRyYWNrcy51cHBlci5jb2xvciA9IHR5cGVvZiBoaWdoZXIgPT09ICdzdHJpbmcnID8gaGlnaGVyIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtoaWdoZXIuam9pbignLCAnKX0pYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFN0ZXBzKHN0ZXBzOiBudW1iZXIgfCBudW1iZXJbXSk6IG51bWJlcltdIHtcblxuICAgICAgICAvLyBpZiB0aGV5IGFyZSBhbHJlYWR5IGFuIGFycmF5IGp1c3QgcmV0dXJuIGl0XG4gICAgICAgIGlmIChzdGVwcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIHN0ZXBzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47IGlkeCA8PSB0aGlzLm9wdGlvbnMudHJhY2subWF4OyBpZHggKz0gc3RlcHMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGlja3Mob3B0aW9uczogU2xpZGVyVGlja09wdGlvbnMsIHR5cGU6IFNsaWRlclRpY2tUeXBlKTogU2xpZGVyVGlja1tdIHtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgdGhlIHRpY2tzIGFuZCBzdGVwIHBvaW50c1xuICAgICAgICBsZXQgc3RlcHMgPSB0aGlzLmdldFN0ZXBzKG9wdGlvbnMuc3RlcHMpO1xuXG4gICAgICAgIC8vIGdldCBzb21lIGNoYXJ0IG9wdGlvbnNcbiAgICAgICAgbGV0IG1pbiA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCBtYXggPSB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBzdGVwIHRvIGEgc2xpZGVyIHRpY2sgYW5kIHJlbW92ZSBpbnZhbGlkIHRpY2tzXG4gICAgICAgIHJldHVybiBzdGVwcy5tYXAoc3RlcCA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNob3dUaWNrczogb3B0aW9ucy5zaG93LFxuICAgICAgICAgICAgICAgIHNob3dMYWJlbHM6IG9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICgoc3RlcCAtIG1pbikgLyAobWF4IC0gbWluKSkgKiAxMDAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0ZXAsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbnMuZm9ybWF0dGVyKHN0ZXApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIodGljayA9PiB0aWNrLnBvc2l0aW9uID49IDAgJiYgdGljay5wb3NpdGlvbiA8PSAxMDApO1xuICAgIH1cblxuICAgIHByaXZhdGUgdW5pb25UaWNrcyhtYWpvclRpY2tzOiBTbGlkZXJUaWNrW10sIG1pbm9yVGlja3M6IFNsaWRlclRpY2tbXSk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCB0aWNrcyBjb21iaW5lZCByZW1vdmluZyBhbnkgbWlub3IgdGlja3Mgd2l0aCB0aGUgc2FtZSB2YWx1ZSBhcyBtYWpvciB0aWNrc1xuICAgICAgICByZXR1cm4gbWFqb3JUaWNrcy5jb25jYXQobWlub3JUaWNrcylcbiAgICAgICAgICAgIC5maWx0ZXIoKHRpY2ssIGluZGV4LCBhcnJheSkgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciB8fCAhYXJyYXkuZmluZCh0ayA9PiB0ay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciAmJiB0ay5wb3NpdGlvbiA9PT0gdGljay5wb3NpdGlvbikpXG4gICAgICAgICAgICAuc29ydCgodDEsIHQyKSA9PiB0MS52YWx1ZSAtIHQyLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlZXBNZXJnZTxUPihkZXN0aW5hdGlvbjogVCwgc291cmNlOiBUKTogVCB7XG5cbiAgICAgICAgLy8gbG9vcCB0aG91Z2ggYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHByb3BlcnR5IGFjcm9zc1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGFuZCBpcyBub3QgYW4gb2JqZWN0IHRoZW4gc2tpcFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltwcm9wXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgcHJvcGVydHkgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbltwcm9wXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIG9iamVjdCB0aGVuIHBlcmZvcm0gYSByZWN1cnNpdmUgY2hlY2tcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gdGhpcy5kZWVwTWVyZ2UoZGVzdGluYXRpb25bcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZXRlY3RWYWx1ZUNoYW5nZSh2YWx1ZTE6IG51bWJlciB8IFNsaWRlclZhbHVlLCB2YWx1ZTI6IG51bWJlciB8IFNsaWRlclZhbHVlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY29tcGFyZSB0d28gc2xpZGVyIHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMSkgJiYgdGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMikpIHtcblxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0cyBpbiB0aGUgY29ycmVjdCB0eXBlc1xuICAgICAgICAgICAgY29uc3Qgb2JqMSA9IHZhbHVlMSBhcyBTbGlkZXJWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9iajIgPSB2YWx1ZTIgYXMgU2xpZGVyVmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBvYmoxLmxvdyAhPT0gb2JqMi5sb3cgfHwgb2JqMS5oaWdoICE9PSBvYmoyLmhpZ2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3QgYSBzbGlkZXIgdmFsdWUgLSBzaG91bGQgYmUgbnVtYmVyIG9mIG51bGxhYmxlIHR5cGUgLSBjb21wYXJlIG5vcm1hbGx5XG4gICAgICAgIHJldHVybiB2YWx1ZTEgIT09IHZhbHVlMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb25mb3JtcyB0byB0aGVcbiAgICAgKiBTbGlkZXJWYWx1ZSBpbnRlcmZhY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG9iamVjdCB0byBjaGVjayAtIHRoaXMgbXVzdCBiZSB0eXBlIGFueVxuICAgICAqL1xuICAgIHByaXZhdGUgaXNTbGlkZXJWYWx1ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IGNoZWNrIGlmIGl0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgICAgICByZXR1cm4gJ2xvdycgaW4gdmFsdWUgJiYgJ2hpZ2gnIGluIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xvbmUodmFsdWU6IG51bWJlciB8IFNsaWRlclZhbHVlKTogbnVtYmVyIHwgU2xpZGVyVmFsdWUge1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIG5vdCBhbiBvYmplY3Qgc2ltcGx5IHJldHVybiB0aGUgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0geyAuLi52YWx1ZSB9O1xuXG4gICAgICAgIC8vIGRlbGV0ZSByZW1vdmUgdGhlIHZhbHVlIGZyb20gdGhlIG9sZCBvYmplY3RcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBuZXcgaW5zdGFuY2Ugb2YgdGhlIG9iamVjdFxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUeXBlIHtcbiAgICBWYWx1ZSxcbiAgICBSYW5nZVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTdHlsZSB7XG4gICAgQnV0dG9uLFxuICAgIExpbmVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyU2l6ZSB7XG4gICAgTmFycm93LFxuICAgIFdpZGVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyQ2FsbG91dFRyaWdnZXIge1xuICAgIE5vbmUsXG4gICAgSG92ZXIsXG4gICAgRHJhZyxcbiAgICBQZXJzaXN0ZW50LFxuICAgIER5bmFtaWNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJWYWx1ZSB7XG4gICAgbG93OiBudW1iZXI7XG4gICAgaGlnaDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTbmFwIHtcbiAgICBOb25lLFxuICAgIE1pbm9yLFxuICAgIE1ham9yLFxuICAgIEFsbFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaWNrVHlwZSB7XG4gICAgTWlub3IsXG4gICAgTWFqb3Jcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJPcHRpb25zIHtcbiAgICB0eXBlPzogU2xpZGVyVHlwZTtcbiAgICBoYW5kbGVzPzogU2xpZGVySGFuZGxlT3B0aW9ucztcbiAgICB0cmFjaz86IFNsaWRlclRyYWNrT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJIYW5kbGVPcHRpb25zIHtcbiAgICBzdHlsZT86IFNsaWRlclN0eWxlO1xuICAgIGNhbGxvdXQ/OiBTbGlkZXJDYWxsb3V0O1xuICAgIGtleWJvYXJkPzogU2xpZGVyS2V5Ym9hcmRPcHRpb25zO1xuICAgIGFyaWE/OiBTbGlkZXJBcmlhT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJBcmlhT3B0aW9ucyB7XG4gICAgdGh1bWI/OiBzdHJpbmc7XG4gICAgbG93ZXJUaHVtYj86IHN0cmluZztcbiAgICB1cHBlclRodW1iPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlcktleWJvYXJkT3B0aW9ucyB7XG4gICAgbWFqb3I/OiBudW1iZXI7XG4gICAgbWlub3I/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVHJhY2tPcHRpb25zIHtcbiAgICBoZWlnaHQ/OiBTbGlkZXJTaXplO1xuICAgIG1pbj86IG51bWJlcjtcbiAgICBtYXg/OiBudW1iZXI7XG4gICAgdGlja3M/OiBTbGlkZXJUaWNrc09wdGlvbnM7XG4gICAgY29sb3JzPzogU2xpZGVyVHJhY2tDb2xvcnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja3NPcHRpb25zIHtcbiAgICBzbmFwPzogU2xpZGVyU25hcDtcbiAgICBtYWpvcj86IFNsaWRlclRpY2tPcHRpb25zO1xuICAgIG1pbm9yPzogU2xpZGVyVGlja09wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja09wdGlvbnMge1xuICAgIHNob3c/OiBib29sZWFuO1xuICAgIHN0ZXBzPzogbnVtYmVyIHwgbnVtYmVyW107XG4gICAgbGFiZWxzPzogYm9vbGVhbjtcbiAgICBmb3JtYXR0ZXI/OiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRpY2sge1xuICAgIHNob3dUaWNrczogYm9vbGVhbjtcbiAgICBzaG93TGFiZWxzOiBib29sZWFuO1xuICAgIHR5cGU6IFNsaWRlclRpY2tUeXBlO1xuICAgIHBvc2l0aW9uOiBudW1iZXI7XG4gICAgdmFsdWU6IG51bWJlcjtcbiAgICBsYWJlbDogc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRyYWNrQ29sb3JzIHtcbiAgICBsb3dlcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHJhbmdlPzogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgaGlnaGVyPzogc3RyaW5nIHwgc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyQ2FsbG91dCB7XG4gICAgdHJpZ2dlcj86IFNsaWRlckNhbGxvdXRUcmlnZ2VyO1xuICAgIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gICAgY29sb3I/OiBzdHJpbmc7XG4gICAgZm9ybWF0dGVyPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyVGh1bWJFdmVudCB7XG4gICAgTm9uZSxcbiAgICBNb3VzZU92ZXIsXG4gICAgTW91c2VMZWF2ZSxcbiAgICBEcmFnU3RhcnQsXG4gICAgRHJhZ0VuZFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaHVtYiB7XG4gICAgTG93ZXIsXG4gICAgVXBwZXJcbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcblxuaW1wb3J0IHsgU2xpZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGUsXG4gICAgICAgIERyYWdNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTbGlkZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NsaWRlckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyTW9kdWxlIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRpbWVyIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL3RpbWVyJztcbmltcG9ydCB7IHN3aXRjaE1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTbGlkZXJPcHRpb25zLCBTbGlkZXJTaXplIH0gZnJvbSAnLi4vLi4vLi4vc2xpZGVyL2luZGV4JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cbmxldCB1bmlxdWVJZDogbnVtYmVyID0gMTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXItY29udHJvbHMnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9jb250cm9scy5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLnF1aWV0XSc6ICdtZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlIHx8IG1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJDb250cm9sc0V4dGVuc2lvbkNvbXBvbmVudCBleHRlbmRzIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIHZvbHVtZUFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHZvbHVtZUZvY3VzOiBib29sZWFuID0gZmFsc2U7XG4gICAgcmV0dXJuRm9jdXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHN1YnRpdGxlc0lkOiBzdHJpbmcgPSBgdXgtbWVkaWEtcGxheWVyLXN1YnRpdGxlLXBvcG92ZXItJHt1bmlxdWVJZCsrfWA7XG4gICAgc3VidGl0bGVzT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG1vdXNlRW50ZXJWb2x1bWUgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIG1vdXNlTGVhdmVWb2x1bWUgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgb3B0aW9uczogU2xpZGVyT3B0aW9ucyA9IHtcbiAgICAgICAgaGFuZGxlczoge1xuICAgICAgICAgICAgYXJpYToge1xuICAgICAgICAgICAgICAgIHRodW1iOiAnVm9sdW1lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmFjazoge1xuICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgbG93ZXI6ICcjNjY2J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlaWdodDogU2xpZGVyU2l6ZS5OYXJyb3csXG4gICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgIG1ham9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtaW5vcjoge1xuICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIF92b2x1bWU6IG51bWJlciA9IDUwO1xuICAgIHByaXZhdGUgX3ByZXZpb3VzVm9sdW1lID0gNTA7XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcbiAgICB9XG5cbiAgICBzZXQgdm9sdW1lKHZhbHVlOiBudW1iZXIpIHtcblxuICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgdGhpcy5fdm9sdW1lICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1ZvbHVtZSA9IHRoaXMuX3ZvbHVtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMTAwKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2Uudm9sdW1lID0gdGhpcy5fdm9sdW1lIC8gMTAwO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS52b2x1bWVDaGFuZ2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodm9sdW1lID0+IHRoaXMudm9sdW1lID0gdm9sdW1lICogMTAwKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuaW5pdEV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnZvbHVtZSA9IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnZvbHVtZSAqIDEwMCk7XG5cbiAgICAgICAgdGhpcy5tb3VzZUVudGVyVm9sdW1lLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnZvbHVtZUFjdGl2ZSA9IHRydWUpO1xuICAgICAgICB0aGlzLm1vdXNlTGVhdmVWb2x1bWUucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0aW1lcigxNTAwKS5waXBlKHRha2VVbnRpbCh0aGlzLm1vdXNlRW50ZXJWb2x1bWUpKSksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMudm9sdW1lQWN0aXZlID0gZmFsc2UpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVNdXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMudm9sdW1lID09PSAwID8gdGhpcy5fcHJldmlvdXNWb2x1bWUgOiAwO1xuICAgIH1cblxuICAgIGdvVG9TdGFydCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIGdvVG9FbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb247XG4gICAgfVxuXG4gICAgaXNTdWJ0aXRsZUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGV4dFRyYWNrcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGV4dFRyYWNrc1tpZHhdLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNldFN1YnRpdGxlVHJhY2sodHJhY2s6IFRleHRUcmFjayk6IHZvaWQge1xuICAgICAgICAvLyBoaWRlIGFsbCB0cmFja3NcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuaGlkZVN1YnRpdGxlVHJhY2tzKCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VidGl0bGUgdHJhY2tcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdHJhY2suY3Vlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdWU6IGFueSA9IHRyYWNrLmN1ZXNbaWR4XTtcbiAgICAgICAgICAgIGN1ZS5saW5lID0gLTM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhY3RpdmF0ZSB0aGUgc2VsZWN0ZWQgb25lXG4gICAgICAgIHRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XG5cbiAgICB9XG5cbiAgICBnZXRTdWJ0aXRsZVRyYWNrKCk6IHN0cmluZyB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRleHRUcmFja3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRleHRUcmFja3NbaWR4XS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGV4dFRyYWNrc1tpZHhdLmxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdObyBzdWJ0aXRsZXMnO1xuICAgIH1cblxufSIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eE1lZGlhUGxheWVyQ3VzdG9tQ29udHJvbF0nLFxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllckN1c3RvbUNvbnRyb2xEaXJlY3RpdmUge30iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXItdGltZWxpbmUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90aW1lbGluZS5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGRvY3VtZW50Om1vdXNldXApJzogJ21vdXNlRG93biA9IGZhbHNlJyxcbiAgICAgICAgJ1tjbGFzcy5xdWlldF0nOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZSB8fCBtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyVGltZWxpbmVFeHRlbnNpb25Db21wb25lbnQgZXh0ZW5kcyBNZWRpYVBsYXllckJhc2VFeHRlbnNpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdwcm9ncmVzc1RodW1iJykgdGh1bWI6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndGltZWxpbmUnKSB0aW1lbGluZVJlZjogRWxlbWVudFJlZjtcblxuICAgIGN1cnJlbnQ6IG51bWJlciA9IDA7XG4gICAgcG9zaXRpb246IG51bWJlciA9IDA7XG4gICAgYnVmZmVyZWQ6IE1lZGlhUGxheWVyQnVmZmVyZWRbXSA9IFtdO1xuICAgIG1vdXNlRG93bjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHNjcnViID0geyB2aXNpYmxlOiBmYWxzZSwgcG9zaXRpb246IDAsIHRpbWU6IDAgfTtcblxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlcyB0byB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5FdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZnVsbHNjcmVlbiA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcnViLnBvc2l0aW9uID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGltZVVwZGF0ZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShjdXJyZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gKHRoaXMuY3VycmVudCAvIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uKSAqIDEwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucHJvZ3Jlc3NFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKGJ1ZmZlcmVkOiBUaW1lUmFuZ2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGJ1ZmZlcmVkLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogKGJ1ZmZlcmVkLnN0YXJ0KGlkeCkgLyB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbikgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogKGJ1ZmZlcmVkLmVuZChpZHgpIC8gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb24pICogMTAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbW91c2Vkb3duJCA9IGZyb21FdmVudCh0aGlzLnRodW1iLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWRvd24nKTtcbiAgICAgICAgY29uc3QgbW91c2Vtb3ZlJCA9IGZyb21FdmVudChkb2N1bWVudCwgJ21vdXNlbW92ZScpO1xuICAgICAgICBjb25zdCBtb3VzZXVwJCA9IGZyb21FdmVudChkb2N1bWVudCwgJ21vdXNldXAnKTtcblxuICAgICAgICBtb3VzZWRvd24kLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gbW91c2Vtb3ZlJC5waXBlKHRha2VVbnRpbChtb3VzZXVwJCkpKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2NydWIudmlzaWJsZSA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2NydWIoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21lZGlhLXByb2dyZXNzLWJhci10aHVtYicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmVSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGltZWxpbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdGhpcy5zY3J1Yi5wb3NpdGlvbiA9IGV2ZW50Lm9mZnNldFg7XG4gICAgICAgIHRoaXMuc2NydWIudGltZSA9IChldmVudC5vZmZzZXRYIC8gYm91bmRzLndpZHRoKSAqIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5zY3J1Yi50aW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFNraXAgYSBudW1iZXIgb2Ygc2Vjb25kcyBpbiBhbnkgZGlyZWN0aW9uICovXG4gICAgc2tpcChzZWNvbmRzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuY3VycmVudCArIHNlY29uZHM7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRhcmdldCBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgY2xpcFxuICAgICAgICBpZiAodGFyZ2V0IDwgMCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQgPiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbikge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5jdXJyZW50VGltZSA9IHRhcmdldDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVkaWFQbGF5ZXJCdWZmZXJlZCB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbn1cbiIsImltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBdWRpb1NlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBfYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyO1xuICAgIHByaXZhdGUgX2F1ZGlvQnVmZmVyU291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XG4gICAgcHJpdmF0ZSBfYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBfZ2Fpbk5vZGU6IEdhaW5Ob2RlO1xuICAgIHByaXZhdGUgX2FuYWx5c2VyTm9kZTogQW5hbHlzZXJOb2RlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaHR0cDogSHR0cENsaWVudCkgeyB9XG5cbiAgICBnZXRBdWRpb0ZpbGVNZXRhZGF0YShtZWRpYUVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9NZXRhZGF0YT4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAuZ2V0KG1lZGlhRWxlbWVudC5zcmMsIHsgcmVzcG9uc2VUeXBlOiAnYmxvYicgfSkuc3Vic2NyaWJlKHJlc3BvbnNlID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gbWVkaWFFbGVtZW50LnNyYy5zdWJzdHJpbmcobWVkaWFFbGVtZW50LnNyYy5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbWVkaWFFbGVtZW50LnNyYy5zdWJzdHJpbmcobWVkaWFFbGVtZW50LnNyYy5sYXN0SW5kZXhPZignLicpICsgMSkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbjtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdNUEVHIGF1ZGlvIGxheWVyIDMgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3bWEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnV2luZG93cyBtZWRpYSBhdWRpbyBmaWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdXQVZFIGF1ZGlvIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ09nZyBWb3JiaXMgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnQWR2YW5jZWQgYXVkaW8gY29kaW5nIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkaSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdNdXNpY2FsIGluc3RydW1lbnQgZGlnaXRhbCBpbnRlcmZhY2UgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnQXVkaW8gZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb246IGV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiByZXNwb25zZS5zaXplXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0V2F2ZWZvcm1Gcm9tVXJsKHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxGbG9hdDMyQXJyYXlbXT4ge1xuXG4gICAgICAgIC8vIGlmIGF1ZGlvIGNvbnRleHQgaXMgbm90IHN1cHBvcnQgcmV0dXJuIGEgc3RyZWFtIG9mIGVtcHR5IGRhdGFcbiAgICAgICAgaWYgKCEoPGFueT53aW5kb3cpLkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG9mPEZsb2F0MzJBcnJheVtdPihbbmV3IEZsb2F0MzJBcnJheSgwKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZvbHVtZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVBbmFseXNlck5vZGUoKTtcblxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxGbG9hdDMyQXJyYXlbXT4pID0+IHtcblxuICAgICAgICAgICAgLy8gbG9hZCB0aGUgbWVkaWEgZnJvbSB0aGUgVVJMIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLl9odHRwLmdldCh1cmwsIHsgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInIH0pLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBdWRpb0J1ZmZlcihyZXNwb25zZSkuc3Vic2NyaWJlKGF1ZGlvQnVmZmVyID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGJ1ZmZlciBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhUG9pbnRzOiBGbG9hdDMyQXJyYXlbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuX2F1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgZGF0YSBmcm9tIGVhY2ggY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFubmVsSWR4ID0gMDsgY2hhbm5lbElkeCA8IGNoYW5uZWxzOyBjaGFubmVsSWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQb2ludHNbY2hhbm5lbElkeF0gPSB0aGlzLl9hdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZGF0YVBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW51cCBhZnRlciBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgZGF0YVBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRXYXZlZm9ybVBvaW50cyhjaGFubmVsczogRmxvYXQzMkFycmF5W10gPSBbXSwgc2tpcDogbnVtYmVyID0gMTAwMCk6IFdhdmVmb3JtUG9pbnRbXSB7XG5cbiAgICAgICAgY29uc3Qgd2F2ZWZvcm06IFdhdmVmb3JtUG9pbnRbXSA9IFtdO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGNoYW5uZWxzLmxlbmd0aCA+IDAgPyBjaGFubmVsc1swXS5sZW5ndGggOiAwO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBjaGFubmVsIGRhdGEgdG8gYSBzZXJpZXMgb2Ygd2F2ZWZvcm0gcG9pbnRzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGR1cmF0aW9uOyBpZHggKz0gc2tpcCkge1xuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIHRoZSBjaGFubmVsIGRhdGEgZm9yIGEgc3BlY2lmaWMgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGNoYW5uZWxzLm1hcChjaGFubmVsID0+IGNoYW5uZWxbaWR4XSk7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gcG9pbnQgYW5kIG1heGltdW0gcG9pbnRzIGF0IGVhY2ggcG9zaXRpb24gYWNyb3NzIGFsbCBjaGFubmVsc1xuICAgICAgICAgICAgd2F2ZWZvcm0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluOiBwb2ludHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gY3VycmVudCA8IHByZXZpb3VzID8gY3VycmVudCA6IHByZXZpb3VzKSxcbiAgICAgICAgICAgICAgICBtYXg6IHBvaW50cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBjdXJyZW50ID4gcHJldmlvdXMgPyBjdXJyZW50IDogcHJldmlvdXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3YXZlZm9ybTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEF1ZGlvQnVmZmVyKGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlcik6IE9ic2VydmFibGU8QXVkaW9CdWZmZXI+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9CdWZmZXI+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldE9mZmxpbmVBdWRpb0NvbnRleHQoKS5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIsIChhdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9mZmxpbmVBdWRpb0NvbnRleHQoKTogT2ZmbGluZUF1ZGlvQ29udGV4dCB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAyLCB0aGlzLl9hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSB8fCA0NDEwMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpO1xuXG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICB0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLl9hdWRpb0J1ZmZlcjtcbiAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl9hbmFseXNlck5vZGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlVm9sdW1lTm9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB0aGlzLl9nYWluTm9kZS5jb25uZWN0KHRoaXMuX2F1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVBbmFseXNlck5vZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FuYWx5c2VyTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICB0aGlzLl9hbmFseXNlck5vZGUuY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkaXNjb25uZWN0U291cmNlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYXZlZm9ybVBvaW50IHtcbiAgICBtaW46IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb01ldGFkYXRhIHtcbiAgICBmaWxlbmFtZTogc3RyaW5nO1xuICAgIGV4dGVuc2lvbjogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc2l6ZTogbnVtYmVyO1xufSIsImltcG9ydCB7IEh0dHBDbGllbnRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXVkaW9TZXJ2aWNlIH0gZnJvbSAnLi9hdWRpby5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbIEh0dHBDbGllbnRNb2R1bGUgXSxcbiAgICBwcm92aWRlcnM6IFtBdWRpb1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIEF1ZGlvU2VydmljZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCB0YWtlVW50aWwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQXVkaW9NZXRhZGF0YSwgQXVkaW9TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYXVkaW8vaW5kZXgnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9tZWRpYS1wbGF5ZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbWVkaWEtcGxheWVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbWVkaWEtcGxheWVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtNZWRpYVBsYXllclNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJyhrZXlkb3duLlNwYWNlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UudG9nZ2xlUGxheSgpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKScsXG4gICAgICAgICdbY2xhc3Muc3RhbmRhcmRdJzogJyFtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbicsXG4gICAgICAgICdbY2xhc3MuZnVsbHNjcmVlbl0nOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW4nLFxuICAgICAgICAnW2NsYXNzLnF1aWV0XSc6ICdxdWlldE1vZGUgJiYgdHlwZSA9PT0gXCJ2aWRlb1wiIHx8IG1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuJyxcbiAgICAgICAgJ1tjbGFzcy5ob3Zlcl0nOiAnaG92ZXJpbmcgfHwgZm9jdXNlZCcsXG4gICAgICAgICdbY2xhc3MudmlkZW9dJzogJ3R5cGUgPT09IFwidmlkZW9cIicsXG4gICAgICAgICdbY2xhc3MuYXVkaW9dJzogJ3R5cGUgPT09IFwiYXVkaW9cIicsXG4gICAgICAgICcobW91c2VlbnRlciknOiAnaG92ZXJpbmcgPSB0cnVlJyxcbiAgICAgICAgJyhtb3VzZWxlYXZlKSc6ICdob3ZlcmluZyA9IGZhbHNlJyxcbiAgICAgICAgJyhkb2N1bWVudDp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgpJyxcbiAgICAgICAgJyhkb2N1bWVudDptb3pmdWxsc2NyZWVuY2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgpJyxcbiAgICAgICAgJyhkb2N1bWVudDpNU0Z1bGxzY3JlZW5DaGFuZ2UpJzogJ21lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuQ2hhbmdlKCknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdwbGF5ZXInKSBwcml2YXRlIF9wbGF5ZXJSZWY6IEVsZW1lbnRSZWY7XG5cbiAgICBob3ZlcmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhdWRpb01ldGFkYXRhOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+O1xuXG4gICAgQElucHV0KCkgY3Jvc3NvcmlnaW46ICd1c2UtY3JlZGVudGlhbHMnIHwgJ2Fub255bW91cycgPSAndXNlLWNyZWRlbnRpYWxzJztcblxuICAgIGdldCBzb3VyY2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnNvdXJjZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzb3VyY2UodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5zb3VyY2UgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpOiBNZWRpYVBsYXllclR5cGUge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudHlwZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB0eXBlKHZhbHVlOiBNZWRpYVBsYXllclR5cGUpIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudHlwZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBxdWlldE1vZGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5xdWlldE1vZGU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgcXVpZXRNb2RlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbWVkaWFQbGF5ZXJTZXJ2aWNlOiBNZWRpYVBsYXllclNlcnZpY2UsIHByaXZhdGUgX2F1ZGlvU2VydmljZTogQXVkaW9TZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG5cbiAgICAgICAgLy8gc2hvdyBjb250cm9scyB3aGVuIGhvdmVyaW5nIGFuZCBpbiBxdWlldCBtb2RlXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZW1vdmUnKS5waXBlKFxuICAgICAgICAgICAgdGFwKCgpID0+IHRoaXMuaG92ZXJpbmcgPSB0cnVlKSxcbiAgICAgICAgICAgIGRlYm91bmNlVGltZSgyMDAwKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuaG92ZXJpbmcgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5zZXRNZWRpYVBsYXllcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX3BsYXllclJlZi5uYXRpdmVFbGVtZW50KTtcblxuICAgICAgICB0aGlzLmF1ZGlvTWV0YWRhdGEgPSB0aGlzLl9hdWRpb1NlcnZpY2UuZ2V0QXVkaW9GaWxlTWV0YWRhdGEodGhpcy5fcGxheWVyUmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wbGF5aW5nRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmcubmV4dCh0cnVlKSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBhdXNlRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmcubmV4dChmYWxzZSkpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5tZWRpYUNsaWNrRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRvZ2dsZVBsYXkoKSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZE1ldGFkYXRhRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZCA9IHRydWUpO1xuXG4gICAgICAgIC8vIGluaXRpYWxseSBoaWRlIGFsbCB0ZXh0IHRyYWNrc1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5oaWRlU3VidGl0bGVUcmFja3MoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBNZWRpYVBsYXllclR5cGUgPSAndmlkZW8nIHwgJ2F1ZGlvJztcblxuZXhwb3J0IGludGVyZmFjZSBNZWRpYVBsYXllckJ1ZmZlciB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnZHVyYXRpb24nXG59KVxuZXhwb3J0IGNsYXNzIER1cmF0aW9uUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIFxuICAgIHRyYW5zZm9ybShzZWNvbmRzOiBudW1iZXIpOiBhbnkge1xuXG4gICAgICAgIGxldCBtaW51dGVzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGxldCBkYXlzID0gTWF0aC5mbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICBob3VycyA9IGhvdXJzIC0gKGRheXMgKiAyNCk7XG4gICAgICAgIG1pbnV0ZXMgPSBtaW51dGVzIC0gKGRheXMgKiAyNCAqIDYwKSAtIChob3VycyAqIDYwKTtcbiAgICAgICAgc2Vjb25kcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAtIChkYXlzICogMjQgKiA2MCAqIDYwKSAtIChob3VycyAqIDYwICogNjApIC0gKG1pbnV0ZXMgKiA2MCkpO1xuXG4gICAgICAgIGlmIChob3VycyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBhZChob3Vycyl9OiR7dGhpcy5wYWQobWludXRlcyl9OiR7dGhpcy5wYWQoc2Vjb25kcyl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBhZChtaW51dGVzKX06JHt0aGlzLnBhZChzZWNvbmRzKX1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFkKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZiAodmFsdWUgPCAxMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAwJHt2YWx1ZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER1cmF0aW9uUGlwZSB9IGZyb20gJy4vZHVyYXRpb24ucGlwZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0R1cmF0aW9uUGlwZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRHVyYXRpb25QaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBEdXJhdGlvblBpcGVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnZmlsZVNpemUnXG59KVxuZXhwb3J0IGNsYXNzIEZpbGVTaXplUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBudW1iZXIpOiBhbnkge1xuXG4gICAgICAgIC8vIGFsbG93IGZvciBhc3luYyB2YWx1ZXNcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgdW5pdHMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdoaWNoIHVuaXQgYnJhY2tldCB0aGUgdmFsdWVzIHNob3VsZCBiZSBhIHBhcnQgb2ZcbiAgICAgICAgbGV0IGlkeCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5sb2coMTAyNCkpO1xuICAgICAgICBsZXQgZm9ybWF0dGVkVmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwMjQsIGlkeCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVkVmFsdWUudG9GaXhlZCgyKX0gJHt1bml0c1tpZHhdfWA7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZpbGVTaXplUGlwZSB9IGZyb20gJy4vZmlsZS1zaXplLnBpcGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtGaWxlU2l6ZVBpcGVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZpbGVTaXplUGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgRmlsZVNpemVQaXBlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWNjZXNzaWJpbGl0eU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS9pbmRleCc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvaW5kZXgnO1xuaW1wb3J0IHsgRHVyYXRpb25QaXBlTW9kdWxlIH0gZnJvbSAnLi4vLi4vcGlwZXMvZHVyYXRpb24vaW5kZXgnO1xuaW1wb3J0IHsgRmlsZVNpemVQaXBlTW9kdWxlIH0gZnJvbSAnLi4vLi4vcGlwZXMvZmlsZS1zaXplL2luZGV4JztcbmltcG9ydCB7IEF1ZGlvU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2F1ZGlvL2luZGV4JztcbmltcG9ydCB7IEZyYW1lRXh0cmFjdGlvbk1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ZyYW1lLWV4dHJhY3Rpb24vZnJhbWUtZXh0cmFjdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHsgU2xpZGVyTW9kdWxlIH0gZnJvbSAnLi4vc2xpZGVyL2luZGV4JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4vZXh0ZW5zaW9ucy9iYXNlLWV4dGVuc2lvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJDb250cm9sc0V4dGVuc2lvbkNvbXBvbmVudCB9IGZyb20gJy4vZXh0ZW5zaW9ucy9jb250cm9scy9jb250cm9scy5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJDdXN0b21Db250cm9sRGlyZWN0aXZlIH0gZnJvbSAnLi9leHRlbnNpb25zL2NvbnRyb2xzL2N1c3RvbS1jb250cm9sL2N1c3RvbS1jb250cm9sLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclRpbWVsaW5lRXh0ZW5zaW9uQ29tcG9uZW50IH0gZnJvbSAnLi9leHRlbnNpb25zL3RpbWVsaW5lL3RpbWVsaW5lLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllckNvbXBvbmVudCB9IGZyb20gJy4vbWVkaWEtcGxheWVyLmNvbXBvbmVudCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBNZWRpYVBsYXllckNvbXBvbmVudCxcbiAgICBNZWRpYVBsYXllclRpbWVsaW5lRXh0ZW5zaW9uQ29tcG9uZW50LFxuICAgIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSxcbiAgICBNZWRpYVBsYXllckNvbnRyb2xzRXh0ZW5zaW9uQ29tcG9uZW50LFxuICAgIE1lZGlhUGxheWVyQ3VzdG9tQ29udHJvbERpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRnJhbWVFeHRyYWN0aW9uTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgICAgICBBdWRpb1NlcnZpY2VNb2R1bGUsXG4gICAgICAgIER1cmF0aW9uUGlwZU1vZHVsZSxcbiAgICAgICAgRmlsZVNpemVQaXBlTW9kdWxlLFxuICAgICAgICBTbGlkZXJNb2R1bGUsXG4gICAgICAgIEFjY2Vzc2liaWxpdHlNb2R1bGUsXG4gICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgIENsaWNrT3V0c2lkZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBRdWVyeUxpc3QsIFJlbmRlcmVyMiwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5hdmlnYXRpb25FbmQsIFJvdXRlciwgVXJsVHJlZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycy9maWx0ZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ1t1eC1uYXZpZ2F0aW9uLWl0ZW1dJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MuYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAnW2NsYXNzLnNlbGVjdGVkXSc6ICdleHBhbmRlZCcsXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaWNvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgbGluazogc3RyaW5nO1xuXG4gICAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMubGluaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlci5pc0FjdGl2ZSh0aGlzLmxpbmssIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV2ZWw6IG51bWJlciA9IDE7XG4gICAgaW5kZW50V2l0aG91dEFycm93OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX25hdmlnYXRpb25FbmQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9jaGlsZHJlbkNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBwcml2YXRlIF9jaGlsZHJlbjogUXVlcnlMaXN0PE5hdmlnYXRpb25JdGVtQ29tcG9uZW50PjtcblxuICAgIGdldCBjaGlsZHJlbigpOiBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBAT3B0aW9uYWwoKVxuICAgICAgICBAU2tpcFNlbGYoKVxuICAgICAgICBwcml2YXRlIF9wYXJlbnQ6IE5hdmlnYXRpb25JdGVtQ29tcG9uZW50LFxuICAgICAgICBwcml2YXRlIF9yb3V0ZXI6IFJvdXRlclxuICAgICkge1xuICAgICAgICB0aGlzLmxldmVsID0gX3BhcmVudCA/IF9wYXJlbnQubGV2ZWwgKyAxIDogMTtcblxuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uRW5kID0gX3JvdXRlci5ldmVudHMucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGlzIGNvbXBvbmVudCBpZiBpdCBvciBhIGRlc2NlbmRhbnQgaXMgYWN0aXZlLlxuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRoaXMuaGFzQWN0aXZlTGluayh0aGlzLmxpbmspO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIEFkZCBjbGFzc2VzIHRvIHBhcmVudCBmb3Igc3R5bGluZ1xuICAgICAgICBjb25zdCBwYXJlbnRMaXN0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAocGFyZW50TGlzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBsZXZlbENsYXNzOiBzdHJpbmcgPSB0aGlzLmdldExldmVsQ2xhc3MoKTtcbiAgICAgICAgICAgIGlmIChsZXZlbENsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhwYXJlbnRMaXN0RWxlbWVudCwgJ25hdicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHBhcmVudExpc3RFbGVtZW50LCBsZXZlbENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gU2V0ICdpbmRlbnRXaXRob3V0QXJyb3cnXG4gICAgICAgIHRoaXMuc2V0SW5kZW50V2l0aG91dEFycm93KCk7XG5cbiAgICAgICAgLy8gVXBkYXRlICdpbmRlbnRXaXRob3V0QXJyb3cnIGluIHJlc3BvbnNlIHRvIGNoYW5nZXMgdG8gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW5DaGFuZ2VzID0gdGhpcy5fY2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zZXRJbmRlbnRXaXRob3V0QXJyb3coKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3kgKCkge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uRW5kLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFzQWN0aXZlTGluayhsaW5rOiBzdHJpbmcgfCBVcmxUcmVlKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGhhcyBhIGxpbmssIGNoZWNrIGlmIGl0IGlzIGFjdGl2ZS5cbiAgICAgICAgaWYgKGxpbmsgJiYgdGhpcy5fcm91dGVyLmlzQWN0aXZlKGxpbmssIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGhhcyBjaGlsZHJlbiwgY2hlY2sgaWYgYW55IG9mIHRoZW0sIG9yIHRoZWlyIGRlc2NlbmRhbnRzLCBhcmUgYWN0aXZlLlxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKChpdGVtKSA9PiBpdGVtLmhhc0FjdGl2ZUxpbmsoaXRlbS5saW5rKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMZXZlbENsYXNzKCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LXNlY29uZC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtdGhpcmQtbGV2ZWwnO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LWZvdXJ0aC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtZmlmdGgtbGV2ZWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0SW5kZW50V2l0aG91dEFycm93KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IHdpbGwgYmUgaW5kZW50ZWQgYW5kIHdpbGwgaGF2ZSBhbiBhcnJvd1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgYSBwYXJlbnQsIGluZGVudCBpdCBpZiBhbnkgb2YgaXRzIHNpYmxpbmdzIGhhdmUgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMuaW5kZW50V2l0aG91dEFycm93ID0gIXRoaXMuX3BhcmVudC5jaGlsZHJlbi5ldmVyeSgoaXRlbSkgPT4gaXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVG9wLWxldmVsIGVsZW1lbnRzIHNob3VsZCBiZSBpbmRlbnRlZFxuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24taXRlbS5pbmZlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvblNlcnZpY2Uge1xuXG4gICAgaXRlbXM6IE5hdmlnYXRpb25JdGVtW107XG5cbiAgICBhdXRvQ29sbGFwc2U6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgc2V0RXhwYW5kZWQoc291cmNlOiBOYXZpZ2F0aW9uSXRlbSwgZXhwYW5kZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKGV4cGFuZGVkICYmIHRoaXMuYXV0b0NvbGxhcHNlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlU2libGluZ3Moc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY29sbGFwc2VTaWJsaW5ncyhzb3VyY2U6IE5hdmlnYXRpb25JdGVtKTogdm9pZCB7XG4gICAgICAgIGxldCBzaWJsaW5ncyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoc291cmNlLCBpdGVtKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChpdGVtICE9PSBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNlQWxsKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb2xsYXBzZUFsbChpdGVtOiBOYXZpZ2F0aW9uSXRlbSk6IHZvaWQge1xuICAgICAgICBpdGVtLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZUFsbChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFBhcmVudCh0YXJnZXQ6IE5hdmlnYXRpb25JdGVtLCBpdGVtOiBOYXZpZ2F0aW9uSXRlbSk6IE5hdmlnYXRpb25JdGVtIHtcbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59IiwiaW1wb3J0IHsgTG9jYXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRW5kLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IHRpY2sgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vaW5kZXgnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuLi9uYXZpZ2F0aW9uLWl0ZW0uaW5mZXJmYWNlJztcbmltcG9ydCB7IE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhOYXZpZ2F0aW9uTGlua10nLFxuICAgIGV4cG9ydEFzOiAndXhOYXZpZ2F0aW9uTGluaydcbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbkxpbmtEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpXG4gICAgbmF2aWdhdGlvbkl0ZW06IE5hdmlnYXRpb25JdGVtO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWQkLm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgY2FuRXhwYW5kOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmluZGVudCcpXG4gICAgaW5kZW50OiBib29sZWFuO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmhyZWYnKVxuICAgIGhyZWY6IHN0cmluZztcblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICByb2xlOiBzdHJpbmc7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1leHBhbmRlZCcpXG4gICAgYXJpYUV4cGFuZGVkOiBzdHJpbmcgPSAndW5kZWZpbmVkJztcblxuICAgIGlzQWN0aXZlOiBib29sZWFuO1xuXG4gICAgaW5kZW50Q2hpbGRyZW46IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9leHBhbmRlZCQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIsXG4gICAgICAgIHByaXZhdGUgX2xvY2F0aW9uU3RyYXRlZ3k6IExvY2F0aW9uU3RyYXRlZ3ksXG4gICAgICAgIHByaXZhdGUgX25hdmlnYXRpb25TZXJ2aWNlOiBOYXZpZ2F0aW9uU2VydmljZVxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLl9leHBhbmRlZCQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgdGljaygpKS5zdWJzY3JpYmUoZXhwYW5kZWQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2hpbGRyZW4gJiYgdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmlhRXhwYW5kZWQgPSBgJHtleHBhbmRlZH1gO1xuICAgICAgICAgICAgICAgIHRoaXMuX25hdmlnYXRpb25TZXJ2aWNlLnNldEV4cGFuZGVkKHRoaXMubmF2aWdhdGlvbkl0ZW0sIGV4cGFuZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLnVwZGF0ZU5hdmlnYXRpb25TdGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZU5hdmlnYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcygpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uZW50ZXInLCBbJyRldmVudCddKVxuICAgIGFjdGl2YXRlZChldmVudDogRXZlbnQpOiBib29sZWFuIHtcblxuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJMaW5rKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kcyA9IEFycmF5LmlzQXJyYXkodGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJMaW5rKSA/IHRoaXMubmF2aWdhdGlvbkl0ZW0ucm91dGVyTGluayA6IFt0aGlzLm5hdmlnYXRpb25JdGVtLnJvdXRlckxpbmtdO1xuICAgICAgICAgICAgdGhpcy5fcm91dGVyLm5hdmlnYXRlKGNvbW1hbmRzLCB0aGlzLm5hdmlnYXRpb25JdGVtLnJvdXRlckV4dHJhcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb2dnbGUgZXhwYW5kZWQgc3RhdGUgKHJlbGV2YW50IG9ubHkgaWYgaXQgaGFzIGNoaWxkcmVuKVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25JdGVtLmV4cGFuZGVkID0gIXRoaXMubmF2aWdhdGlvbkl0ZW0uZXhwYW5kZWQ7XG5cbiAgICAgICAgLy8gSW52b2tlIHRoZSBjdXN0b20gY2xpY2sgaGFuZGxlciBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkl0ZW0uY2xpY2soZXZlbnQsIHRoaXMubmF2aWdhdGlvbkl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlTmF2aWdhdGlvblN0YXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZUl0ZW0odGhpcy5uYXZpZ2F0aW9uSXRlbSk7XG5cbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUNoaWxkID0gdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbi5maW5kKGNoaWxkID0+IHRoaXMuaXNBY3RpdmVJdGVtKGNoaWxkKSk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25JdGVtLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQXR0cmlidXRlcygpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmhyZWYgPSB0aGlzLmdldEhyZWYoKTtcbiAgICAgICAgdGhpcy5yb2xlID0gKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2hpbGRyZW4gJiYgdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSA/ICdidXR0b24nIDogJ3RyZWVpdGVtJztcblxuICAgICAgICB0aGlzLmluZGVudENoaWxkcmVuID0gdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbiAmJiB0aGlzLm5hdmlnYXRpb25JdGVtLmNoaWxkcmVuLnNvbWUoaXRlbSA9PiBpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRIcmVmKCk6IHN0cmluZyB7XG5cbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0ucm91dGVyTGluaykge1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KHRoaXMubmF2aWdhdGlvbkl0ZW0ucm91dGVyTGluaykgPyB0aGlzLm5hdmlnYXRpb25JdGVtLnJvdXRlckxpbmsgOiBbdGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJMaW5rXTtcbiAgICAgICAgICAgIGNvbnN0IHVybFRyZWUgPSB0aGlzLl9yb3V0ZXIuY3JlYXRlVXJsVHJlZShjb21tYW5kcywgdGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJFeHRyYXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uU3RyYXRlZ3kucHJlcGFyZUV4dGVybmFsVXJsKHRoaXMuX3JvdXRlci5zZXJpYWxpemVVcmwodXJsVHJlZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0FjdGl2ZUl0ZW0oaXRlbTogTmF2aWdhdGlvbkl0ZW0pOiBib29sZWFuIHtcblxuICAgICAgICBpZiAoaXRlbS5yb3V0ZXJMaW5rKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kcyA9IEFycmF5LmlzQXJyYXkoaXRlbS5yb3V0ZXJMaW5rKSA/IGl0ZW0ucm91dGVyTGluayA6IFtpdGVtLnJvdXRlckxpbmtdO1xuICAgICAgICAgICAgY29uc3QgdXJsVHJlZSA9IHRoaXMuX3JvdXRlci5jcmVhdGVVcmxUcmVlKGNvbW1hbmRzLCBpdGVtLnJvdXRlckV4dHJhcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5wdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uSXRlbSB9IGZyb20gJy4vbmF2aWdhdGlvbi1pdGVtLmluZmVyZmFjZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1uYXZpZ2F0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbTmF2aWdhdGlvblNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Db21wb25lbnQge1xuXG4gICAgLyoqIFRoZSBuYXZpZ2F0aW9uIGl0ZW1zIHRvIHBvcHVsYXRlIHRoZSBtZW51IHdpdGguICovXG4gICAgQElucHV0KClcbiAgICBzZXQgaXRlbXMoaXRlbXM6IE5hdmlnYXRpb25JdGVtW10pIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvblNlcnZpY2UuaXRlbXMgPSBpdGVtcztcbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCk6IE5hdmlnYXRpb25JdGVtW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF2aWdhdGlvblNlcnZpY2UuaXRlbXM7XG4gICAgfVxuXG4gICAgLyoqIFdoZXRoZXIgdG8gcHJlc2VudCB0aGUgbWVudSBhcyBhIGhpZXJhcmNoaWNhbCB0cmVlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHJlZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogV2hldGhlciB0byBjb2xsYXBzZSBvdGhlciBtZW51IGl0ZW1zIHdoZW4gZXhwYW5kaW5nIGEgbWVudSBpdGVtLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGF1dG9Db2xsYXBzZShhdXRvQ29sbGFwc2U6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvblNlcnZpY2UuYXV0b0NvbGxhcHNlID0gYXV0b0NvbGxhcHNlO1xuICAgIH1cblxuICAgIEBDb250ZW50Q2hpbGQoJ3V4TmF2aWdhdGlvbkl0ZW0nKVxuICAgIG5hdmlnYXRpb25JdGVtVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBoaWVyYXJjaHlDbGFzc2VzID0gW1xuICAgICAgICAnJyxcbiAgICAgICAgJ25hdi1zZWNvbmQtbGV2ZWwnLFxuICAgICAgICAnbmF2LXRoaXJkLWxldmVsJyxcbiAgICAgICAgJ25hdi1mb3VydGgtbGV2ZWwnLFxuICAgICAgICAnbmF2LWZpZnRoLWxldmVsJyxcbiAgICBdO1xuXG4gICAgZ2V0IGRlcHRoTGltaXQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZSA/IHRoaXMuaGllcmFyY2h5Q2xhc3Nlcy5sZW5ndGggOiAyO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX25hdmlnYXRpb25TZXJ2aWNlOiBOYXZpZ2F0aW9uU2VydmljZSkgeyB9XG5cbiAgICBpdGVtQ2xpY2soaXRlbTogTmF2aWdhdGlvbkl0ZW0sIGV2ZW50OiBFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIFRvZ2dsZSBleHBhbmRlZCBzdGF0ZSAocmVsZXZhbnQgb25seSBpZiBpdCBoYXMgY2hpbGRyZW4pXG4gICAgICAgIGl0ZW0uZXhwYW5kZWQgPSAhaXRlbS5leHBhbmRlZDtcblxuICAgICAgICAvLyBJbnZva2UgdGhlIGN1c3RvbSBjbGljayBoYW5kbGVyIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAoaXRlbS5jbGljaykge1xuICAgICAgICAgICAgaXRlbS5jbGljayhldmVudCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNldHMgb2YgaXRlbXMgbmVlZHMgdG8gYmUgaW5kZW50ZWQgdG8gbWFrZSByb29tIGZvciBvbmUgb3IgbW9yZSBleHBhbmRlci5cbiAgICAgKi9cbiAgICBuZWVkc0luZGVudChpdGVtczogTmF2aWdhdGlvbkl0ZW1bXSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXRlbXMgJiYgaXRlbXMuc29tZShpdGVtID0+IGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5TW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9hY2Nlc3NpYmlsaXR5L2luZGV4JztcbmltcG9ydCB7IE5hdmlnYXRpb25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uLWl0ZW0vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uTGlua0RpcmVjdGl2ZSB9IGZyb20gJy4vbmF2aWdhdGlvbi1saW5rL25hdmlnYXRpb24tbGluay5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQWNjZXNzaWJpbGl0eU1vZHVsZSxcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgTmF2aWdhdGlvbkl0ZW1Db21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgICAgICBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCxcbiAgICAgICAgTmF2aWdhdGlvbkxpbmtEaXJlY3RpdmVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvblNlcnZpY2Uge1xyXG5cclxuICAgIC8vIHByb3ZpZGUgZGVmYXVsdCBvcHRpb25zXHJcbiAgICBvcHRpb25zOiBOb3RpZmljYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgIGR1cmF0aW9uOiA0LFxyXG4gICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgIHNwYWNpbmc6IDEwLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fY29sb3JTZXJ2aWNlLmdldENvbG9yKCdhY2NlbnQnKS50b0hleCgpLFxyXG4gICAgICAgIGljb25Db2xvcjogdGhpcy5fY29sb3JTZXJ2aWNlLmdldENvbG9yKCdhY2NlbnQnKS50b0hleCgpXHJcbiAgICB9O1xyXG5cclxuICAgIGRpcmVjdGlvbjogTm90aWZpY2F0aW9uTGlzdERpcmVjdGlvbiA9ICdhYm92ZSc7XHJcblxyXG4gICAgbm90aWZpY2F0aW9ucyQ6IEJlaGF2aW9yU3ViamVjdDxOb3RpZmljYXRpb25SZWZbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE5vdGlmaWNhdGlvblJlZltdPihbXSk7ICAgIFxyXG5cclxuICAgIHNob3codGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIG9wdGlvbnM6IE5vdGlmaWNhdGlvbk9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIGRhdGE6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSk6IE5vdGlmaWNhdGlvblJlZiB7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgICAgICBjb25zdCBub3RpZmljYXRpb25SZWY6IE5vdGlmaWNhdGlvblJlZiA9IHtcclxuICAgICAgICAgICAgdGVtcGxhdGVSZWY6IHRlbXBsYXRlUmVmLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcclxuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcclxuICAgICAgICAgICAgc3BhY2luZzogb3B0aW9ucy5zcGFjaW5nLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICBpY29uQ29sb3I6IG9wdGlvbnMuaWNvbkNvbG9yLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYWJvdmUnKSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMudW5zaGlmdChub3RpZmljYXRpb25SZWYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMucHVzaChub3RpZmljYXRpb25SZWYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zJC5uZXh0KG5vdGlmaWNhdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyByZW1vdmUgbm90aWZpY2F0aW9uIGFmdGVyIGRlbGF5XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IDApIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpc21pc3Mobm90aWZpY2F0aW9uUmVmKSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvblJlZjtcclxuICAgIH1cclxuXHJcbiAgICBnZXRIaXN0b3J5KCk6IE5vdGlmaWNhdGlvblJlZltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc21pc3Mobm90aWZpY2F0aW9uUmVmOiBOb3RpZmljYXRpb25SZWYpOiB2b2lkIHtcclxuICAgICAgICBub3RpZmljYXRpb25SZWYudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQubmV4dCh0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkaXNtaXNzQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKS5mb3JFYWNoKG5vdGlmaWNhdGlvblJlZiA9PiBub3RpZmljYXRpb25SZWYudmlzaWJsZSA9IGZhbHNlKTtcclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMkLm5leHQodGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpKTsgICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlKSB7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uUmVmIHtcclxuICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgZHVyYXRpb246IG51bWJlcjtcclxuICAgIGRhdGU6IERhdGU7XHJcbiAgICB2aXNpYmxlPzogYm9vbGVhbjtcclxuICAgIGhlaWdodD86IG51bWJlcjtcclxuICAgIHNwYWNpbmc/OiBudW1iZXI7XHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XHJcbiAgICBpY29uQ29sb3I/OiBzdHJpbmc7XHJcbiAgICBkYXRhOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlmaWNhdGlvbk9wdGlvbnMge1xyXG4gICAgZHVyYXRpb24/OiBudW1iZXI7XHJcbiAgICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgICBzcGFjaW5nPzogbnVtYmVyO1xyXG4gICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4gICAgaWNvbkNvbG9yPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOb3RpZmljYXRpb25MaXN0RGlyZWN0aW9uID0gJ2Fib3ZlJyB8ICdiZWxvdyc7IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlLCBOb3RpZmljYXRpb25SZWYsIE5vdGlmaWNhdGlvbkxpc3REaXJlY3Rpb24gfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IHRyaWdnZXIsIHN0YXRlLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbm90aWZpY2F0aW9uLWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9ub3RpZmljYXRpb24tbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgYW5pbWF0aW9uczogW1xuICAgICAgICB0cmlnZ2VyKCdub3RpZmljYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgIHN0YXRlKCdpbicsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKScsIG9wYWNpdHk6IDAuOSB9KSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MHB4KScsIG9wYWNpdHk6IDAgfSksXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDApXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDUwcHgpJywgb3BhY2l0eTogMCB9KSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25MaXN0Q29tcG9uZW50IHtcbiAgICBcbiAgICBASW5wdXQoKSBcbiAgICBzZXQgZGlyZWN0aW9uKGRpcmVjdGlvbjogTm90aWZpY2F0aW9uTGlzdERpcmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25TZXJ2aWNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2NsYXNzJykgcG9zaXRpb246IE5vdGlmaWNhdGlvbkxpc3RQb3N0aW9uID0gJ3RvcC1yaWdodCc7XG5cbiAgICBub3RpZmljYXRpb25zJDogT2JzZXJ2YWJsZTxOb3RpZmljYXRpb25SZWZbXT4gPSB0aGlzLl9ub3RpZmljYXRpb25TZXJ2aWNlLm5vdGlmaWNhdGlvbnMkLnBpcGUoXG4gICAgICAgIG1hcCgobm90aWZpY2F0aW9uUmVmczogTm90aWZpY2F0aW9uUmVmW10pID0+IG5vdGlmaWNhdGlvblJlZnMuZmlsdGVyKG5vdGlmaWNhdGlvblJlZiA9PiBub3RpZmljYXRpb25SZWYudmlzaWJsZSksXG4gICAgKSk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9ub3RpZmljYXRpb25TZXJ2aWNlOiBOb3RpZmljYXRpb25TZXJ2aWNlKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIE5vdGlmaWNhdGlvbkxpc3RQb3N0aW9uID0gJ3RvcC1sZWZ0JyB8ICd0b3AtcmlnaHQnIHwgJ2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tcmlnaHQnOyIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnQgfSBmcm9tICcuL25vdGlmaWNhdGlvbi1saXN0LmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvblNlcnZpY2UgfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGUsXHJcbiAgICAgICAgQ29sb3JTZXJ2aWNlTW9kdWxlXHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogW1xyXG4gICAgICAgIE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnRcclxuICAgIF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICBOb3RpZmljYXRpb25MaXN0Q29tcG9uZW50XHJcbiAgICBdLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgTm90aWZpY2F0aW9uU2VydmljZVxyXG4gICAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IFxuICAgIHNlbGVjdG9yOiAnW3V4UGFnZUhlYWRlckN1c3RvbU1lbnVdJyBcbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRW5kLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtLCBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlclNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIGl0ZW1zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10+KFtdKTtcbiAgICBzZWxlY3RlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4obnVsbCk7XG4gICAgc2VsZWN0ZWRSb290JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPihudWxsKTtcbiAgICBzZWNvbmRhcnkkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgYWN0aXZlSWNvbk1lbnUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVySWNvbk1lbnU+KG51bGwpO1xuICAgIHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0ID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIpIHtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkJFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIG1hcChzZWxlY3RlZCA9PiB0aGlzLmdldFJvb3Qoc2VsZWN0ZWQpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUocm9vdCA9PiB0aGlzLnNlbGVjdGVkUm9vdCQubmV4dChyb290KSk7XG5cbiAgICAgICAgdGhpcy5fcm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcihlID0+IGUgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy51cGRhdGVJdGVtc1dpdGhBY3RpdmVSb3V0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0KGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSk6IHZvaWQge1xuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0ucm91dGVyTGluaykge1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHJvdXRlciBuYXZpZ2F0aW9uXG4gICAgICAgICAgICBjb25zdCByb3V0ZXJMaW5rID0gQXJyYXkuaXNBcnJheShpdGVtLnJvdXRlckxpbmspID8gaXRlbS5yb3V0ZXJMaW5rIDogW2l0ZW0ucm91dGVyTGlua107XG4gICAgICAgICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGUocm91dGVyTGluaywgaXRlbS5yb3V0ZXJFeHRyYXMpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdCAmJiBpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGZpcnN0IGNoaWxkIGluIHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0IG1vZGVcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGl0ZW0uY2hpbGRyZW5bMF0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBpbiBzZWNvbmRhcnkgbmF2aWdhdGlvbiBtb2RlIGFuZCB3ZSBjbGljayBhIHBhcmVudCAtIGRvbnQgZGVzZWxlY3QgdGhlIGNoaWxkXG4gICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnkkLmdldFZhbHVlKCkgPT09IHRydWUgJiYgdGhpcy5pc1BhcmVudE9mKHRoaXMuc2VsZWN0ZWQkLmdldFZhbHVlKCksIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VsZWN0IHRoZSBnaXZlbiBpdGVtXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIHwgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0pOiB2b2lkIHtcbiAgICAgICAgLy8gZGVzZWxlY3QgdGhlIGN1cnJlbnQgaXRlbVxuICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBhbnkgY2hpbGRyZW4gYW5kIGRlc2VsZWN0IHRoZW1cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChfaXRlbSA9PiB0aGlzLmRlc2VsZWN0KF9pdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtcyQuZ2V0VmFsdWUoKS5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5kZXNlbGVjdChpdGVtKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlSXRlbShpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0sIHNlbGVjdGVkOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0pOiB2b2lkIHtcbiAgICAgICAgLy8gSXRlbSBpcyBzZWxlY3RlZCBpZiBpdCBpcyB0aGUgc2VsZWN0ZWQgaXRlbSwgb3Igb25lIG9mIHRoZSBzZWxlY3RlZCBpdGVtJ3MgYW5jZXN0b3JzLlxuICAgICAgICBpdGVtLnNlbGVjdGVkID0gaXRlbSA9PT0gc2VsZWN0ZWQgfHwgdGhpcy5pc1BhcmVudE9mKHNlbGVjdGVkLCBpdGVtKTtcblxuICAgICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIHNlbGVjdCBmdW5jdGlvbiBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdC5jYWxsKGl0ZW0sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXRlbXMoaXRlbXM6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbVtdID0gW10pOiB2b2lkIHtcbiAgICAgICAgLy8gaWRlbnRpZnkgYWxsIHBhcmVudCBlbGVtZW50c1xuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5zZXRQYXJlbnQoaXRlbSkpO1xuXG4gICAgICAgIHRoaXMuaXRlbXMkLm5leHQoaXRlbXMpO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgaW5pdGFsbHkgc2VsZWN0ZWQgaXRlbVxuICAgICAgICAvLyBJZiBub3RoaW5nIGlzIHNldCBhcyBzZWxlY3RlZCwgdXNpbmcgdGhlIGluaXRpYWwgcm91dGVcbiAgICAgICAgY29uc3QgaW5pdGlhbFNlbGVjdGVkSXRlbSA9IGl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnNlbGVjdGVkID09PSB0cnVlKTtcbiAgICAgICAgaWYgKGluaXRpYWxTZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGluaXRpYWxTZWxlY3RlZEl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJdGVtc1dpdGhBY3RpdmVSb3V0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U2Vjb25kYXJ5TmF2aWdhdGlvbihlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5JC5uZXh0KGVuYWJsZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Um9vdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5wYXJlbnQgPyB0aGlzLmdldFJvb3QoaXRlbS5wYXJlbnQpIDogaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBhcmVudChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb24gfCBudWxsKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwYXJlbnQgZmllbGRcbiAgICAgICAgaXRlbS5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgLy8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5IG9uIGFsbCBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaXRlbS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHRoaXMuc2V0UGFyZW50KGNoaWxkLCBpdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlzUGFyZW50T2Yobm9kZTogUGFnZUhlYWRlck5hdmlnYXRpb24sIHBhcmVudDogUGFnZUhlYWRlck5hdmlnYXRpb24pOiBib29sZWFuIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcGFyZW50cyByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBpcyB0aGUgbWF0Y2ggd2UgYXJlIGxvb2tpbmcgZm9yIHJldHVybiB0cnVlXG4gICAgICAgIGlmIChub2RlLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBwb3RlbnRpYWxseSBncmFuZHBhcmVudHMgdGhlbiBjaGVjayB0aGVtIHRvb1xuICAgICAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKG5vZGUucGFyZW50LCBwYXJlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlSXRlbXNXaXRoQWN0aXZlUm91dGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBuZXcgUGFnZUhlYWRlckFjdGl2ZU5hdmlnYXRpb25JdGVtKCk7XG4gICAgICAgIGZvciAodmFyIGl0ZW0gb2YgdGhpcy5pdGVtcyQuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kQWN0aXZlSXRlbShpdGVtLCBhY3RpdmVJdGVtKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVJdGVtLmV4YWN0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlSXRlbS5pdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KGFjdGl2ZUl0ZW0uaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmRBY3RpdmVJdGVtKGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSwgYWN0aXZlSXRlbTogUGFnZUhlYWRlckFjdGl2ZU5hdmlnYXRpb25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKGl0ZW0ucm91dGVyTGluaykge1xuXG4gICAgICAgICAgICBjb25zdCByb3V0ZXJMaW5rID0gQXJyYXkuaXNBcnJheShpdGVtLnJvdXRlckxpbmspID8gaXRlbS5yb3V0ZXJMaW5rIDogW2l0ZW0ucm91dGVyTGlua107XG4gICAgICAgICAgICBjb25zdCB1cmxUcmVlID0gdGhpcy5fcm91dGVyLmNyZWF0ZVVybFRyZWUocm91dGVyTGluaywgaXRlbS5yb3V0ZXJFeHRyYXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIHRydWUpICYmICFhY3RpdmVJdGVtLmV4YWN0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBpdGVtIHJvdXRlIGlzIGFuIGV4YWN0IG1hdGNoLCBubyBuZWVkIHRvIGxvb2sgYW55IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICBhY3RpdmVJdGVtLml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW0uZXhhY3QgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIGZhbHNlKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgYW4gaW5leGFjdCBtYXRjaCBhbmQgY29udGludWUgbG9va2luZ1xuICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW0uaXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgYWN0aXZlSXRlbS5leGFjdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkSXRlbSBvZiBpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kQWN0aXZlSXRlbShjaGlsZEl0ZW0sIGFjdGl2ZUl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVJdGVtLmV4YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uID0gUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIHwgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW07XG5cbmNsYXNzIFBhZ2VIZWFkZXJBY3RpdmVOYXZpZ2F0aW9uSXRlbSB7XG4gICAgaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtO1xuICAgIGV4YWN0OiBib29sZWFuO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51LCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0gfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcGFnZS1oZWFkZXItaWNvbi1tZW51JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vaWNvbi1tZW51LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVySWNvbk1lbnVDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgbWVudTogUGFnZUhlYWRlckljb25NZW51O1xuXG4gICAgZ2V0IGlzT3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcbiAgICB9XG5cbiAgICBzZXQgaXNPcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlSWNvbk1lbnUkLm5leHQodGhpcy5tZW51KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBWaWV3Q2hpbGQoJ21lbnVOYXZpZ2F0aW9uVG9nZ2xlJykgbWVudU5hdmlnYXRpb25Ub2dnbGU6IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuXG4gICAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gX3NlcnZpY2UuYWN0aXZlSWNvbk1lbnUkLnN1YnNjcmliZSgobmV4dCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2xvc2UgYWxsIGJ1dCB0aGUgbW9zdCByZWNlbnRseSBvcGVuZWQgbWVudVxuICAgICAgICAgICAgaWYgKG5leHQgIT09IHRoaXMubWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0KGl0ZW06IFBhZ2VIZWFkZXJJY29uTWVudSB8IFBhZ2VIZWFkZXJJY29uTWVudURyb3Bkb3duSXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5zZWxlY3QpIHtcbiAgICAgICAgICAgIGl0ZW0uc2VsZWN0LmNhbGwoaXRlbSwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlkb3duSGFuZGxlcihpdGVtOiBQYWdlSGVhZGVySWNvbk1lbnUgfCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0sIGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51TmF2aWdhdGlvblRvZ2dsZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtJyxcbiAgICBleHBvcnRBczogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbTtcblxuICAgIEBWaWV3Q2hpbGQoJ2J1dHRvbicpXG4gICAgYnV0dG9uOiBFbGVtZW50UmVmO1xuXG4gICAgZHJvcGRvd25PcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9ob3ZlciQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHN0cmVhbSB3aXRoIGEgZGVib3VuY2UgKGEgc21hbGwgZGVib3VuY2UgaXMgYWxsIHRoYXQgaXMgcmVxdWlyZWQpXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX2hvdmVyJC5waXBlKGRlYm91bmNlVGltZSgxKSkuc3Vic2NyaWJlKHZpc2libGUgPT4gdGhpcy5kcm9wZG93bk9wZW4gPSB2aXNpYmxlKTtcblxuICAgICAgICAvLyBDbG9zZSBzdWJtZW51cyB3aGVuIHNlbGVjdGVkIGl0ZW0gY2hhbmdlc1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgICAgICAgX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0pIHtcblxuICAgICAgICAvLyBjbGlja2luZyBvbiBhbiBpdGVtIHdpdGggY2hpbGRyZW4gdGhlbiByZXR1cm5cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gYW4gZXZlbnRcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0KGl0ZW0pO1xuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgaG92ZXJTdGFydCgpIHtcbiAgICAgICAgdGhpcy5faG92ZXIkLm5leHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgaG92ZXJMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5faG92ZXIkLm5leHQoZmFsc2UpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSk6IHZvaWQge1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBRdWVyeUxpc3QsIFZpZXdDaGlsZCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duRGlyZWN0aXZlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdidXR0b24nKSBidXR0b246IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGQoJ21lbnUnKSBtZW51OiBCc0Ryb3Bkb3duRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGRyZW4oUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1Db21wb25lbnQpIGRyb3Bkb3duczogUXVlcnlMaXN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50PjtcblxuICAgIEBJbnB1dCgpIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbTtcblxuICAgIHNlY29uZGFyeSQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlY29uZGFyeSQ7XG5cbiAgICBpc09wZW46IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0ZWQkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShuZXh0ID0+IHtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkIHN0YXRlIGZvciB0aGlzIGl0ZW1cbiAgICAgICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnVwZGF0ZUl0ZW0odGhpcy5pdGVtLCBuZXh0KTtcblxuICAgICAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgbWVudSB3YXMgY2xvc2VkLCBrZWVwIGZvY3VzIG9uIHRoZSB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgdGhpcy5tZW51Lm9uSGlkZGVuXG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyb3Bkb3ducy5mb3JFYWNoKGRyb3Bkb3duID0+IGRyb3Bkb3duLmNsb3NlKCkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaGFzIGNoaWxkcmVuIHRoZW4gZG8gbm90aGluZyBhdCB0aGlzIHN0YWdlXG4gICAgICAgIGlmICh0aGlzLml0ZW0uY2hpbGRyZW4gJiYgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNlbGVjdCB0aGUgY3VycmVudCBpdGVtXG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdCh0aGlzLml0ZW0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBkZWxheSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbV0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCd1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbScpXHJcbiAgICBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW07XHJcblxyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG5cclxuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQucGlwZShkZWxheSgwKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShuZXh0ID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3RlZCBzdGF0ZSBmb3IgdGhpcyBpdGVtXHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnVwZGF0ZUl0ZW0odGhpcy5pdGVtLCBuZXh0KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBRdWVyeUxpc3QsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkV4dHJhcyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFJlc2l6ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL25hdmlnYXRpb24uY29tcG9uZW50Lmh0bWwnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ3JvbGUnOiAnbWVudWJhcidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBWaWV3Q2hpbGRyZW4oUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50KSBtZW51SXRlbXM6IFF1ZXJ5TGlzdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQ+O1xuXG4gICAgaXRlbXMkOiBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10+ID0gdGhpcy5fcGFnZUhlYWRlclNlcnZpY2UuaXRlbXMkO1xuICAgIGluZGljYXRvclZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBpbmRpY2F0b3JYOiBudW1iZXIgPSAwO1xuICAgIGluZGljYXRvcldpZHRoOiBudW1iZXIgPSAwO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSwgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQocmVzaXplU2VydmljZS5hZGRSZXNpemVMaXN0ZW5lcihlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChfcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0ZWQkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKF9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnkkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IuYmluZCh0aGlzKSkpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZEluZGljYXRvcigpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTZWxlY3RlZEluZGljYXRvcigpOiB2b2lkIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBzZWxlY3RlZCBpdGVtXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMubWVudUl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLml0ZW0uc2VsZWN0ZWQpO1xuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gc2hvdyB0aGUgaW5kaWNhdG9yXG4gICAgICAgICAgICB0aGlzLmluZGljYXRvclZpc2libGUgPSAhIXNlbGVjdGVkO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHdpZHRoIG9mIHRoZSBpbmRpY2F0b3IgdG8gbWF0Y2ggdGhlIHdpZHRoIG9mIHRoZSBuYXZpZ2F0aW9uIGl0ZW1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc2VsZWN0ZWQuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yWCA9IHNlbGVjdGVkLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yV2lkdGggPSBwYXJzZUludChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB7XG4gICAgaWNvbj86IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgICByb3V0ZXJMaW5rPzogc3RyaW5nIHwgYW55W107XG4gICAgcm91dGVyRXh0cmFzPzogTmF2aWdhdGlvbkV4dHJhcztcbiAgICBzZWxlY3Q/OiAoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtKSA9PiB2b2lkO1xuICAgIGNoaWxkcmVuPzogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1bXTtcbiAgICBwYXJlbnQ/OiBQYWdlSGVhZGVyTmF2aWdhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBzZWxlY3RlZD86IGJvb2xlYW47XG4gICAgcm91dGVyTGluaz86IHN0cmluZyB8IGFueVtdO1xuICAgIHJvdXRlckV4dHJhcz86IE5hdmlnYXRpb25FeHRyYXM7XG4gICAgc2VsZWN0PzogKGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtKSA9PiB2b2lkO1xuICAgIGNoaWxkcmVuPzogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1bXTtcbiAgICBwYXJlbnQ/OiBQYWdlSGVhZGVyTmF2aWdhdGlvbjtcbn1cblxuLy8gVGhpcyBpcyBhbiBhbGlhcyBmb3IgTUYgdXNlIGFzIFwiRHJvcGRvd25JdGVtXCIgZG9lc24ndCBtYWtlIHNlbnNlIGluIGNvbnRleHQgd2l0aCBob3cgaXQgaXMgdXNlZFxuZXhwb3J0IGludGVyZmFjZSBQYWdlSGVhZGVyU2Vjb25kYXJ5TmF2aWdhdGlvbkl0ZW0gZXh0ZW5kcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSB7IH0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcbmltcG9ydCB7IEJyZWFkY3J1bWIgfSBmcm9tICcuLi9icmVhZGNydW1icy9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSB9IGZyb20gJy4vY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb24sIFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlcicsXG4gICAgZXhwb3J0QXM6ICd1eC1wYWdlLWhlYWRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdwYWdlLWhlYWRlci5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbIFBhZ2VIZWFkZXJTZXJ2aWNlIF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBsb2dvOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgdGl0bGU6IHN0cmluZztcbiAgICBASW5wdXQoKSBhbGlnbm1lbnQ6ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyA9ICdjZW50ZXInO1xuICAgIEBJbnB1dCgpIGNvbmRlbnNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGljb25NZW51czogUGFnZUhlYWRlckljb25NZW51W107XG4gICAgQElucHV0KCkgYmFja1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNlY29uZGFyeU5hdmlnYXRpb25BbGlnbm1lbnQ6ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyA9ICdjZW50ZXInO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdDtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBpdGVtcyhpdGVtczogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10pIHtcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2V0SXRlbXMoaXRlbXMpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHNlY29uZGFyeU5hdmlnYXRpb24oZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZXRTZWNvbmRhcnlOYXZpZ2F0aW9uKGVuYWJsZWQpO1xuICAgIH1cblxuICAgIGdldCBzZWNvbmRhcnlOYXZpZ2F0aW9uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGNydW1icyhjcnVtYnM6IEJyZWFkY3J1bWJbXSkge1xuICAgICAgICB0aGlzLl9jcnVtYnMgPSBjcnVtYnM7XG4gICAgfVxuXG4gICAgZ2V0IGNydW1icygpOiBCcmVhZGNydW1iW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kZW5zZWQgPyBbLi4udGhpcy5fY3J1bWJzLCB7IHRpdGxlOiB0aGlzLmhlYWRlciB9XSA6IHRoaXMuX2NydW1icztcbiAgICB9XG5cbiAgICBASW5wdXQoKSBjcnVtYnNTdHlsZTogJ3N0YW5kYXJkJyB8ICdzbWFsbCcgPSAnc3RhbmRhcmQnO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgbG9nb0JhY2tncm91bmQoY29sb3I6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9sb2dvQmFja2dyb3VuZCA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKGNvbG9yKTtcbiAgICB9XG5cbiAgICBnZXQgbG9nb0JhY2tncm91bmQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ29CYWNrZ3JvdW5kO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGxvZ29Gb3JlZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbG9nb0ZvcmVncm91bmQgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZShjb2xvcik7XG4gICAgfVxuXG4gICAgZ2V0IGxvZ29Gb3JlZ3JvdW5kKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dvRm9yZWdyb3VuZDtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmYW1pbHlCYWNrZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dvQmFja2dyb3VuZCA9IGNvbG9yO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGZhbWlseUZvcmVncm91bmQoY29sb3I6IHN0cmluZykge1xuICAgICAgICB0aGlzLmxvZ29Gb3JlZ3JvdW5kID0gY29sb3I7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIGJhY2tDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIEBDb250ZW50Q2hpbGQoJ3RpdGxlJykgdGl0bGVUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY3VzdG9tTWVudXM6IFF1ZXJ5TGlzdDxUZW1wbGF0ZVJlZjxhbnk+PjtcblxuICAgIHNlbGVjdGVkJDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQ7XG4gICAgc2VsZWN0ZWRSb290JDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZFJvb3QkO1xuXG4gICAgcHJpdmF0ZSBfY3J1bWJzOiBCcmVhZGNydW1iW10gPSBbXTtcbiAgICBwcml2YXRlIF9sb2dvQmFja2dyb3VuZDogc3RyaW5nO1xuICAgIHByaXZhdGUgX2xvZ29Gb3JlZ3JvdW5kOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb2xvclNlcnZpY2U6IENvbG9yU2VydmljZSwgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7IH1cblxuICAgIGdvQmFjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iYWNrQ2xpY2suZW1pdCgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3QoaXRlbSk7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiL3RhYi5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGFic2V0U2VydmljZSB7XG5cbiAgICB0YWJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VGFiQ29tcG9uZW50W10+KFtdKTtcbiAgICBhY3RpdmUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUYWJDb21wb25lbnQ+KG51bGwpO1xuICAgIGZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgaGlnaGxpZ2h0ZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUYWJDb21wb25lbnQ+KG51bGwpO1xuXG4gICAgYWRkKHRhYjogVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMudGFicyQubmV4dChbLi4udGhpcy50YWJzJC52YWx1ZSwgdGFiXSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyB0aGUgb25seSB0YWIuIElmIHNvIHNlbGVjdCB0aGlzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSQudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRhYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmUodGFiOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIHRhYlxuICAgICAgICB0aGlzLnRhYnMkLm5leHQodGhpcy50YWJzJC52YWx1ZS5maWx0ZXIoX3RhYiA9PiBfdGFiICE9PSB0YWIpKTtcbiAgICB9XG5cbiAgICBzZWxlY3QodGFiOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0YWIuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlJC5uZXh0KHRhYik7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkJC5uZXh0KHRhYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RBdEluZGV4KGluZGV4OiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdGFicyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMudGFicyQudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgaW5kZXggaXMgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0QXRJbmRleCh0aGlzLnRhYnMkLnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMudGFicyQudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RBdEluZGV4KDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YWJzJC52YWx1ZVtpbmRleF07XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdE5leHRUYWIoKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpbmRleFxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudGFicyQudmFsdWUuaW5kZXhPZih0aGlzLmFjdGl2ZSQudmFsdWUpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRoZSB0YWJzIGFmdGVyIHRoZSBhY3RpdmUgb25lIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IHNlbGVjdGFibGUgdGFic1xuICAgICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzJC52YWx1ZS5zbGljZShpbmRleCArIDEpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgdGFicyBhcmUgbm90IGRpc2FibGVkXG4gICAgICAgIGZvciAobGV0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgICAgICBpZiAoIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdCh0YWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgcmVhY2ggaGVyZSB0aGVuIG5vIHRhYiBjb3VsZCBiZSBzZWxlY3RlZCAtIHNlbGVjdCB0aGUgZmlyc3QgdGFiXG4gICAgICAgIHRoaXMuc2VsZWN0Rmlyc3RUYWIoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RQcmV2aW91c1RhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5pbmRleE9mKHRoaXMuYWN0aXZlJC52YWx1ZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgdGhlIHRhYnMgYmVmb3JlIHRoZSBhY3RpdmUgb25lIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IHNlbGVjdGFibGUgdGFic1xuICAgICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzJC52YWx1ZS5zbGljZSgwLCBpbmRleCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IG9mIHRoZSB0YWJzIGFyZSBub3QgZGlzYWJsZWRcbiAgICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICBpZiAoIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdCh0YWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgcmVhY2ggaGVyZSB0aGVuIG5vIHByZXZpb3VzIHRhYiBjb3VsZCBiZSBzZWxlY3RlZCAtIHNlbGVjdCB0aGUgbGFzdCB0YWJcbiAgICAgICAgdGhpcy5zZWxlY3RMYXN0VGFiKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0Rmlyc3RUYWIoKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgdGFiXG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5maW5kSW5kZXgodGFiID0+ICF0YWIuZGlzYWJsZWQpO1xuXG4gICAgICAgIGlmICh0YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QXRJbmRleCh0YWJJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RMYXN0VGFiKCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIHRhYlxuICAgICAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMudGFicyQudmFsdWUuc2xpY2UoKS5yZXZlcnNlKCkuZmluZEluZGV4KHRhYiA9PiAhdGFiLmRpc2FibGVkKTtcblxuICAgICAgICBpZiAodGFiSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEF0SW5kZXgoKHRoaXMudGFicyQudmFsdWUubGVuZ3RoIC0gMSkgLSB0YWJJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59ICIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUYWJzZXRTZXJ2aWNlIH0gZnJvbSAnLi4vdGFic2V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIuY29tcG9uZW50JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhUYWJGb2N1c10nXG59KVxuZXhwb3J0IGNsYXNzIFRhYkZvY3VzRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgdXhUYWJGb2N1czogVGFiQ29tcG9uZW50O1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90YWJzZXQ6IFRhYnNldFNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3RhYnNldC5oaWdobGlnaHRlZCQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl90YWJzZXQuZm9jdXNlZCQudmFsdWUgPT09IHRydWUpLFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3RhYnNldC5oaWdobGlnaHRlZCQudmFsdWUgPT09IHRoaXMudXhUYWJGb2N1cyksXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUYWJzZXRTZXJ2aWNlIH0gZnJvbSAnLi4vdGFic2V0LnNlcnZpY2UnO1xuXG5sZXQgdW5pcXVlVGFiSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRhYicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RhYi5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVGFiQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSBgdXgtdGFiLSR7Kyt1bmlxdWVUYWJJZH1gO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaGVhZGluZzogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGN1c3RvbUNsYXNzOiBzdHJpbmc7XG5cbiAgICBAT3V0cHV0KCkgc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBkZXNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIEBJbnB1dCgpIHNldCBhY3RpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJzZXQuc2VsZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGVhZGluZ1JlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBhY3RpdmUkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5fdGFic2V0LmFjdGl2ZSQucGlwZShtYXAoYWN0aXZlID0+IGFjdGl2ZSA9PT0gdGhpcykpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90YWJzZXQ6IFRhYnNldFNlcnZpY2UpIHtcbiAgICAgICAgX3RhYnNldC5hZGQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5hY3RpdmUkLnN1YnNjcmliZShhY3RpdmUgPT4gYWN0aXZlID8gdGhpcy5zZWxlY3QuZW1pdCgpIDogdGhpcy5kZXNlbGVjdC5lbWl0KCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl90YWJzZXQucmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRhYkhlYWRpbmddJ1xufSlcbmV4cG9ydCBjbGFzcyBUYWJIZWFkaW5nRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LCB0YWI6IFRhYkNvbXBvbmVudCkge1xuICAgICAgICB0YWIuaGVhZGluZ1JlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cblxufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi90YWIuY29tcG9uZW50JztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuL3RhYnNldC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10YWJzZXQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90YWJzZXQuY29tcG9uZW50Lmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1RhYnNldFNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy50YWJzLWxlZnRdJzogJ3N0YWNrZWQgPT09IFwibGVmdFwiJyxcbiAgICAgICAgJ1tjbGFzcy50YWJzLXJpZ2h0XSc6ICdzdGFja2VkID09PSBcInJpZ2h0XCInLFxuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVGFic2V0Q29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIG1pbmltYWw6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHN0YWNrZWQ6ICdsZWZ0JyB8ICdyaWdodCcgfCAnbm9uZScgPSAnbm9uZSc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFic2V0OiBUYWJzZXRTZXJ2aWNlKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93IG1hbnVhbCB0YWIgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxlY3QodGFiOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YWJzZXQuc2VsZWN0KHRhYik7XG4gICAgfVxuXG4gICAgc2VsZWN0UHJldmlvdXNUYWIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggYXJyb3cga2V5IGlzIHByZXNzZWRcbiAgICAgICAgY29uc3QgYXJyb3dMZWZ0ID0gZXZlbnQua2V5ID09PSAnQXJyb3dMZWZ0JyB8fCBldmVudC5rZXlDb2RlID09PSAzNztcbiAgICAgICAgY29uc3QgYXJyb3dVcCA9IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnIHx8IGV2ZW50LmtleUNvZGUgPT09IDM4O1xuXG4gICAgICAgIC8vIG9ubHkgcGVyZm9ybSBhY3Rpb24gaWYgdGhlIGFycm93IGtleSBtYXRjaGVzIHRoZSBvcmllbnRhdGlvblxuICAgICAgICBpZiAoYXJyb3dMZWZ0ICYmIHRoaXMuc3RhY2tlZCAhPT0gJ25vbmUnIHx8IGFycm93VXAgJiYgdGhpcy5zdGFja2VkID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gc2VsZWN0aW9uXG4gICAgICAgIHRoaXMudGFic2V0LnNlbGVjdFByZXZpb3VzVGFiKCk7XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBzZWxlY3ROZXh0VGFiKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGFycm93IGtleSBpcyBwcmVzc2VkXG4gICAgICAgIGNvbnN0IGFycm93UmlnaHQgPSBldmVudC5rZXkgPT09ICdBcnJvd1JpZ2h0JyB8fCBldmVudC5rZXlDb2RlID09PSAzOTtcbiAgICAgICAgY29uc3QgYXJyb3dEb3duID0gZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fCBldmVudC5rZXlDb2RlID09PSA0MDtcblxuICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWN0aW9uIGlmIHRoZSBhcnJvdyBrZXkgbWF0Y2hlcyB0aGUgb3JpZW50YXRpb25cbiAgICAgICAgaWYgKGFycm93UmlnaHQgJiYgdGhpcy5zdGFja2VkICE9PSAnbm9uZScgfHwgYXJyb3dEb3duICYmIHRoaXMuc3RhY2tlZCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnRhYnNldC5zZWxlY3ROZXh0VGFiKCk7XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJGb2N1c0RpcmVjdGl2ZSB9IGZyb20gJy4vdGFiL3RhYi1mb2N1cy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVGFiSGVhZGluZ0RpcmVjdGl2ZSB9IGZyb20gJy4vdGFiL3RhYi1oZWFkaW5nLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi90YWIuY29tcG9uZW50JztcbmltcG9ydCB7IFRhYnNldENvbXBvbmVudCB9IGZyb20gJy4vdGFic2V0LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtUYWJzZXRDb21wb25lbnQsIFRhYkNvbXBvbmVudCwgVGFiSGVhZGluZ0RpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbVGFic2V0Q29tcG9uZW50LCBUYWJDb21wb25lbnQsIFRhYkhlYWRpbmdEaXJlY3RpdmUsIFRhYkZvY3VzRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVGFic2V0TW9kdWxlIHsgfSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEJzRHJvcGRvd25Nb2R1bGUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2Ryb3Bkb3duJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vaW5kZXgnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgQnJlYWRjcnVtYnNNb2R1bGUgfSBmcm9tICcuLi9icmVhZGNydW1icy9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSB9IGZyb20gJy4vY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudUNvbXBvbmVudCB9IGZyb20gJy4vaWNvbi1tZW51L2ljb24tbWVudS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLXNlY29uZGFyeS1pdGVtL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUYWJzZXRNb2R1bGUgfSBmcm9tICcuLi90YWJzZXQvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQnJlYWRjcnVtYnNNb2R1bGUsXG4gICAgICAgIEJzRHJvcGRvd25Nb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGUsXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgTWVudU5hdmlnYXRpb25Nb2R1bGUsXG4gICAgICAgIFJlc2l6ZU1vZHVsZSxcbiAgICAgICAgUm91dGVyTW9kdWxlLFxuICAgICAgICBUYWJzZXRNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVySWNvbk1lbnVDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlLFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFBBR0lOQVRJT05fQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUGFnaW5hdGlvbkNvbXBvbmVudCksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1wYWdpbmF0aW9uJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3BhZ2luYXRpb24uY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtQQUdJTkFUSU9OX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2luYXRpb25Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAvKiogU3BlY2lmeSBpZiB3ZSBzaG91bGQgc2hvdyB0aGUgbmV4dCBhbmQgcHJldmlvdXMgYnV0dG9ucyAqL1xuICBASW5wdXQoKSBkaXJlY3Rpb25CdXR0b25zOiBib29sZWFuID0gdHJ1ZTtcblxuICAvKiogTGltaXQgdGhlIG51bWJlciBvZiBwYWdlcyBzaG93biBhdCBhbnkgZ2l2ZW4gdGltZSAqL1xuICBASW5wdXQoKSBtYXhTaXplOiBudW1iZXIgPSA1O1xuXG4gIC8qKiBTcGVjaWZ5IGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIGRpc2FibGVkICovXG4gIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEFwcGx5IGNsYXNzZXMgdG8gdGhlIGJvb3RzdHJhcCBwYWdpbmF0aW9uIGVsZW1lbnQgKi9cbiAgQElucHV0KCdjbGFzcycpIGNsYXNzZXM6IHN0cmluZztcblxuICAvKiogQWxsb3cgY3VzdG9tIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHBhZ2UgYnV0dG9ucyAqL1xuICBASW5wdXQoKSBwYWdlQnRuQ2xhc3M6IHN0cmluZztcblxuICAvKiogQXJpYSBMYWJlbCBmb3IgdGhlIGNvbXBvbmVudCBuYXZpZ2F0aW9uICovXG4gIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJ1BhZ2luYXRpb24gTmF2aWdhdGlvbic7XG5cbiAgLyoqIEFyaWEgbGFiZWwgZm9yIHRoZSBwcmV2aW91cyBidXR0b24gKi9cbiAgQElucHV0KCkgcHJldmlvdXNBcmlhTGFiZWw6IHN0cmluZyA9ICdOYXZpZ2F0ZSB0byB0aGUgcHJldmlvdXMgcGFnZSc7XG5cbiAgLyoqIEFyaWEgbGFiZWwgZm9yIHRoZSBuZXh0IGJ1dHRvbiAqL1xuICBASW5wdXQoKSBuZXh0QXJpYUxhYmVsOiBzdHJpbmcgPSAnTmF2aWdhdGUgdG8gdGhlIG5leHQgcGFnZSc7XG5cbiAgLyoqIFNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBhY3RpdmUgcGFnZSAqL1xuICBASW5wdXQoKSBzZXQgcGFnZShwYWdlOiBudW1iZXIpIHtcblxuICAgIC8vIGRvIG5vdGhpbmcgaWYgdGhlIHBhZ2UgaGFzIG5vdCBjaGFuZ2VkXG4gICAgaWYgKHBhZ2UgPT09IHRoaXMuX3BhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICB0aGlzLnBhZ2VzID0gdGhpcy5nZXRQYWdlcygpO1xuXG4gICAgLy8gbWFyayB0aGlzIGNvbXBvbmVudCBhcyBjaGFuZ2VkXG4gICAgdGhpcy5vbkNoYW5nZSh0aGlzLnBhZ2UpO1xuICB9XG5cbiAgZ2V0IHBhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKiBEZWZpbmUgYSBjdXN0b20gdGVtcGxhdGUgZm9yIHRoZSBwcmV2aW91cyBidXR0b24gKi9cbiAgQElucHV0KCkgcHJldmlvdXNCdG5UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogRGVmaW5lIGEgY3VzdG9tIHRlbXBsYXRlIGZvciB0aGUgbmV4dCBidXR0b24gKi9cbiAgQElucHV0KCkgbmV4dEJ0blRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKiBTcGVjaWZ5IHRoZSBwYWdlIHNpemUgKi9cbiAgQElucHV0KCkgc2V0IGl0ZW1zUGVyUGFnZShwYWdlc2l6ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fcGFnZXNpemUgPSBwYWdlc2l6ZTtcbiAgICB0aGlzLnBhZ2VzID0gdGhpcy5nZXRQYWdlcygpO1xuICB9XG5cbiAgLyoqIFNwZWNpZnkgaG93IG1hbnkgaXRlbXMgdGhlcmUgYXJlIGluIHRvdGFsICovXG4gIEBJbnB1dCgpIHNldCB0b3RhbEl0ZW1zKHRvdGFsOiBudW1iZXIpIHtcbiAgICB0aGlzLl90b3RhbCA9IHRvdGFsO1xuICAgIHRoaXMucGFnZXMgPSB0aGlzLmdldFBhZ2VzKCk7XG4gIH1cblxuICAvKiogRW1pdCB0aGUgY3VycmVudCBwYWdlIG51bWJlciAqL1xuICBAT3V0cHV0KCkgcGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIC8qKiBFbWl0IHRoZSB0b3RhbCBudW1iZXIgb2YgcGFnZXMgKi9cbiAgQE91dHB1dCgpIG51bVBhZ2VzID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgLyoqIFN0b3JlIGEgbGlzdCBvZiBwYWdlcyB0byBkaXNwbGF5IGluIHRoZSBVSSAqL1xuICBwYWdlczogUmVhZG9ubHlBcnJheTxQYWdlPiA9IFtdO1xuXG4gIC8qKiBDb250cm9sVmFsdWVBY2Nlc3NvciBmdW5jdGlvbnMgKi9cbiAgb25Ub3VjaGVkOiBGdW5jdGlvbiA9ICgpID0+IHt9O1xuICBvbkNoYW5nZTogRnVuY3Rpb24gPSAoKSA9PiB7fTtcblxuICBpc0tleWJvYXJkRXZlbnQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9wYWdlOiBudW1iZXIgPSAxO1xuICBwcml2YXRlIF90b3RhbDogbnVtYmVyID0gMTAwO1xuICBwcml2YXRlIF9wYWdlc2l6ZTogbnVtYmVyID0gMTA7XG5cbiAgZ2V0IHBhZ2VDb3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5fdG90YWwgLyB0aGlzLl9wYWdlc2l6ZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnBhZ2VzID0gdGhpcy5nZXRQYWdlcygpO1xuICB9XG5cbiAgc2VsZWN0KGluZGV4OiBudW1iZXIpOiB2b2lkIHtcblxuICAgIC8vIGZpbmQgdGhlIHBhZ2Ugd2Ugd2FudCB0byBnbyB0b1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMucGFnZXMuZmluZChwYWdlID0+IHBhZ2UuaW5kZXggPT09IGluZGV4KTtcblxuICAgIC8vIGlmIHRoZSBwYWdlIGlzIG91dCBvZiBib3VuZHMgdGhlbiBkbyBub3RoaW5nXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBtYXJrIHRoaXMgY29tcG9uZW50IGFzIHRvdWNoZWRcbiAgICB0aGlzLm9uVG91Y2hlZCgpO1xuXG4gICAgLy8gc2V0IHRoaXMgYXMgdGhlIGN1cnJlbnQgcGFnZVxuICAgIHRoaXMucGFnZSA9IHRhcmdldC5pbmRleDtcblxuICAgIC8vIHVwZGF0ZSB0aGUgdmlzaWJsZSBwYWdlc1xuICAgIHRoaXMucGFnZXMgPSB0aGlzLmdldFBhZ2VzKCk7XG5cbiAgICAvLyBlbWl0IHRoZSBjdXJyZW50IHBhZ2VcbiAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCh0aGlzLnBhZ2UpO1xuICB9XG5cbiAgdHJhY2tCeUZuKF9pbmRleDogbnVtYmVyLCBpdGVtOiBQYWdlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gaXRlbS5pbmRleDtcbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gIH1cblxuICB3cml0ZVZhbHVlKHBhZ2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gIH1cblxuICBwcml2YXRlIGdldFBhZ2VzKCk6IFBhZ2VbXSB7XG5cbiAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgdG8gc3RvcmUgdGhlIHBhZ2VzXG4gICAgY29uc3QgcGFnZXM6IFBhZ2VbXSA9IFtdO1xuXG4gICAgLy8gY3JlYXRlIGFsbCBwb3NzaWJsZSBwYWdlc1xuICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPD0gdGhpcy5wYWdlQ291bnQ7IGluZGV4KyspIHtcbiAgICAgIHBhZ2VzLnB1c2goeyBpbmRleCwgdmlzaWJsZTogdGhpcy5pc1BhZ2VWaXNpYmxlKGluZGV4KSB9KTtcbiAgICB9XG5cbiAgICAvLyBlbWl0IHRoZSBudW1iZXIgb2YgcGFnZXNcbiAgICB0aGlzLm51bVBhZ2VzLmVtaXQodGhpcy5wYWdlQ291bnQpO1xuXG4gICAgcmV0dXJuIHBhZ2VzO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1BhZ2VWaXNpYmxlKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcblxuICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGEgbWF4IHNpemUgc3BlY2lmaWVkIG9yIHRoZSBudW1iZXIgb2YgcGFnZXMgaXMgbGVzcyB0aGFuIHRoZSBtYXggc2l6ZSB0aGVuIGl0IGlzIGFsd2F5cyB2aXNpYmxlXG4gICAgaWYgKCF0aGlzLm1heFNpemUgfHwgdGhpcy5wYWdlQ291bnQgPD0gdGhpcy5tYXhTaXplKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBzdGFydGluZyBwb3NpdGlvblxuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aGlzLnBhZ2UgLSAodGhpcy5tYXhTaXplIC8gMikpKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIHRoaXMubWF4U2l6ZSwgdGhpcy5wYWdlQ291bnQgKyAxKTtcblxuICAgIC8vIGlmIHRoZSByYW5nZSBpcyBsZXNzIHRoYW4gdGhlIG1heCBzaXplIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBzdGFydGluZyBwb2ludFxuICAgIGNvbnN0IHJhbmdlID0gZW5kIC0gc3RhcnQ7XG5cbiAgICBpZiAocmFuZ2UgPCB0aGlzLm1heFNpemUpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgLSAodGhpcy5tYXhTaXplIC0gcmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBpdGVtIGVxdWFscyB0aGUgc3RhcnQgcG9zaXRpb24gb3IgaXMgbGVzcyB0aGFuIHRoZSBlbmQgcG9zaXRpb24gdGhlbiBzaG93IGl0XG4gICAgcmV0dXJuIGluZGV4ID49IHN0YXJ0ICYmIGluZGV4IDwgZW5kO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZSB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHZpc2libGU6IGJvb2xlYW47XG59XG4iLCJpbXBvcnQgeyBBMTF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5TW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9hY2Nlc3NpYmlsaXR5L2luZGV4JztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IFBhZ2luYXRpb25Db21wb25lbnQgfSBmcm9tICcuL3BhZ2luYXRpb24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBBMTF5TW9kdWxlLFxuICAgIEFjY2Vzc2liaWxpdHlNb2R1bGUsXG4gICAgRm9jdXNJZk1vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBQYWdpbmF0aW9uQ29tcG9uZW50XG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBQYWdpbmF0aW9uQ29tcG9uZW50XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnaW5hdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXByb2dyZXNzLWJhcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Byb2dyZXNzLWJhci5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgaG9zdDoge1xuICAgICAgICByb2xlOiAncHJvZ3Jlc3NiYXInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0JhckNvbXBvbmVudCB7XG4gICAgQElucHV0KCkgdmFsdWU6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtaW4nKSBtaW46IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtYXgnKSBtYXg6IG51bWJlciA9IDEwMDtcbiAgICBASW5wdXQoKSBpbmRldGVybWluYXRlOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgdHJhY2tDb2xvcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGJhckNvbG9yOiBzdHJpbmc7XG5cbiAgICAvKiogV2hlbiBpbmRldGVtaW5hdGUgd2Ugc2hvdWxkIG9taXQgdGhlIHZhbHVlbm93IGxhYmVsICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVub3cnKSBnZXQgdmFsdWVOb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGUgPyBudWxsIDogdGhpcy52YWx1ZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgUHJvZ3Jlc3NCYXJDb21wb25lbnQgfSBmcm9tICcuL3Byb2dyZXNzLWJhci5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbUHJvZ3Jlc3NCYXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1Byb2dyZXNzQmFyQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0Jhck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBSQURJT0JVVFRPTl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxubGV0IHVuaXF1ZVJhZGlvSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXJhZGlvLWJ1dHRvbicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3JhZGlvYnV0dG9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtSQURJT0JVVFRPTl9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgUmFkaW9CdXR0b25Db21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBwcml2YXRlIF9yYWRpb0J1dHRvbklkOiBzdHJpbmcgPSBgdXgtcmFkaW8tYnV0dG9uLSR7Kyt1bmlxdWVSYWRpb0lkfWA7XG5cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nID0gdGhpcy5fcmFkaW9CdXR0b25JZDtcbiAgICBASW5wdXQoKSBuYW1lOiBzdHJpbmcgfCBudWxsO1xuICAgIEBJbnB1dCgpIHJlcXVpcmVkOiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIGNsaWNrYWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzaW1wbGlmaWVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgb3B0aW9uOiBhbnk7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmcgPSAnJztcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmcgPSBudWxsO1xuICAgIEBJbnB1dCgnYXJpYS1kZXNjcmliZWRieScpIGFyaWFEZXNjcmliZWRieTogc3RyaW5nID0gbnVsbDtcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gaW52b2tlIGNoYW5nZSBldmVudFxuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy5fdmFsdWUpO1xuXG4gICAgICAgIC8vIGNhbGwgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpOyAgICAgICAgXG4gICAgfVxuXG4gICAgZ2V0IGlucHV0SWQoKTogc3RyaW5nIHsgXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkIHx8IHRoaXMuX3JhZGlvQnV0dG9uSWR9LWlucHV0YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWx1ZTogYW55ID0gZmFsc2U7XG5cbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHRvZ2dsZSgpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcHRpb247XG5cbiAgICAgICAgLy8gY2FsbCBjYWxsYmFja1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25zIHJlcXVpcmVkIHRvIHVwZGF0ZSBuZy1tb2RlbFxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgUmFkaW9CdXR0b25Db21wb25lbnQgfSBmcm9tICcuL3JhZGlvYnV0dG9uLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlXSxcbiAgICBleHBvcnRzOiBbUmFkaW9CdXR0b25Db21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1JhZGlvQnV0dG9uQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBSYWRpb0J1dHRvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuY29uc3QgVU5TRVRfRk9DVVM6IFNlYXJjaEJ1aWxkZXJGb2N1cyA9IHsgZ3JvdXBJZDogbnVsbCwgaW5kZXg6IC0xIH07XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlIHtcblxuICAgIGZvY3VzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8U2VhcmNoQnVpbGRlckZvY3VzPihVTlNFVF9GT0NVUyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZm9jdXMgb24gYSBzZWFyY2ggYnVpbGRlciBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGdyb3VwSWQgVGhlIGBpZGAgb2YgdGhlIGdyb3VwIGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlICh6ZXJvLWJhc2VkKSBpbmRleCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHNldEZvY3VzKGdyb3VwSWQ6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzJC5uZXh0KHsgZ3JvdXBJZDogZ3JvdXBJZCwgaW5kZXg6IGluZGV4IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZm9jdXMgZnJvbSBhbGwgY29tcG9uZW50cy4gSWYgZm9jdXMgaXMgbm90IG9uIGEgc2VhcmNoIGJ1aWxkZXIgY29tcG9uZW50LCB0aGlzIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBjbGVhckZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzJC5uZXh0KFVOU0VUX0ZPQ1VTKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoQnVpbGRlckZvY3VzIHtcbiAgICBncm91cElkOiBzdHJpbmc7XG4gICAgaW5kZXg6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbXBvbmVudC1kZWZpbml0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyUXVlcnkgfSBmcm9tICcuL2ludGVyZmFjZXMvcXVlcnkuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIHtcblxuICBxdWVyeTogU2VhcmNoQnVpbGRlclF1ZXJ5ID0ge307XG4gIHF1ZXJ5Q2hhbmdlOiBTdWJqZWN0PFNlYXJjaEJ1aWxkZXJRdWVyeT4gPSBuZXcgU3ViamVjdDxTZWFyY2hCdWlsZGVyUXVlcnk+KCk7XG4gIHZhbGlkYXRpb25DaGFuZ2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odHJ1ZSk7XG5cbiAgcHJpdmF0ZSBfY29tcG9uZW50SWQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX2NvbXBvbmVudHM6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBfdmFsaWRhdGlvbjogeyBba2V5OiBudW1iZXJdOiBib29sZWFuIH0gPSB7fTtcblxuICAvKipcbiAgICogQWRkIGEgY29tcG9uZW50IHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGNvbXBvbmVudHNcbiAgICovXG4gIHJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudDogU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb24pOiB2b2lkIHtcblxuICAgIC8vIGVuc3VyZSB0aGVyZSBhcmUgbm8gY29tcG9uZW50cyB3aXRoIGEgbWF0Y2hpbmcgbmFtZVxuICAgIGlmICh0aGlzLl9jb21wb25lbnRzLmZpbmQoY21wID0+IGNtcC5uYW1lID09PSBjb21wb25lbnQubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VhcmNoIGJ1aWxkZXIgY29tcG9uZW50cyBtdXN0IGhhdmUgYSB1bmlxdWUgbmFtZS4gVGhlIG5hbWUgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiB1c2VkLmApO1xuICAgIH1cblxuICAgIC8vIGlmIHVuaXF1ZSB0aGVuIGFkZCB0aGUgY29tcG9uZW50IHRvIHRoZSBsaXN0XG4gICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQnVsayByZWdpc3RyYXRpb24gb2YgY29tcG9uZW50c1xuICAgKiAoSnVzdCBhIGhlbHBlciBtZXRob2QpXG4gICAqL1xuICByZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50czogU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb25bXSk6IHZvaWQge1xuICAgIGNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4gdGhpcy5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWdpc3RlcmVkIGNvbXBvbmVudCBjbGFzc1xuICAgKi9cbiAgZ2V0Q29tcG9uZW50KG5hbWU6IHN0cmluZyk6IGFueSB7XG5cbiAgICAvLyBmaW5kIHRoZSBjb21wb25lbnRcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9jb21wb25lbnRzLmZpbmQoY21wID0+IGNtcC5uYW1lID09PSBuYW1lKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hdGNoIHRocm93IGFuIGV4Y2VwdGlvblxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlYXJjaCBidWlsZCBjb21wb25lbnQgd2l0aCB0aGUgbmFtZSAke25hbWV9IGV4aXN0c2ApO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBjb25maWcgaXMgZGVmaW5lZCAtIGF0IGxlYXN0IHRvIGFuIGVtcHR5IG9iamVjdFxuICAgIGNvbXBvbmVudC5jb25maWcgPSBjb21wb25lbnQuY29uZmlnIHx8IHt9O1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIHNlYXJjaCBxdWVyeSBzdGF0ZVxuICAgKiBub3RlIHRoYXQgdGhlIHF1ZXJ5IHdpbGwgYmUgaW1tdXRhYmxlXG4gICAqL1xuICBzZXRRdWVyeShxdWVyeTogU2VhcmNoQnVpbGRlclF1ZXJ5KTogdm9pZCB7XG4gICAgdGhpcy5xdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgcXVlcnkgc3RhdGVcbiAgICovXG4gIGdldFF1ZXJ5KCk6IFNlYXJjaEJ1aWxkZXJRdWVyeSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgb2JzZXJ2YWJsZSB0byBpbmRpY2F0ZSB0aGUgcXVlcnkgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgcXVlcnlIYXNDaGFuZ2VkKCk6IHZvaWQge1xuICAgIHRoaXMucXVlcnlDaGFuZ2UubmV4dCh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgdmFsaWRhdGlvbiBzdGF0ZSBvZiB0aGUgcXVlcnlcbiAgICovXG4gIHNldFZhbGlkKGlkOiBudW1iZXIsIHZhbGlkOiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAvLyBzdG9yZSB0aGUgc3RhdGUgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50XG4gICAgdGhpcy5fdmFsaWRhdGlvbltpZF0gPSB2YWxpZDtcblxuICAgIC8vIGV2YWx1YXRlIHRoZSBlbnRpcmUgdmFsaWRhdGlvbiBzdGF0ZVxuICAgIHRoaXMudmFsaWRhdGlvbkNoYW5nZS5uZXh0KCFPYmplY3Qua2V5cyh0aGlzLl92YWxpZGF0aW9uKS5zb21lKGtleSA9PiAhdGhpcy5fdmFsaWRhdGlvbltrZXldKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggY29tcG9uZW50XG4gICAqL1xuICBnZW5lcmF0ZUNvbXBvbmVudElkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudElkKys7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ncm91cC1xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckZvY3VzU2VydmljZSB9IGZyb20gJy4uL3NlYXJjaC1idWlsZGVyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2Uge1xuXG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlclNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2U6IFNlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2VcbiAgKSB7IH1cblxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgZ3JvdXAgYnkgZGVmaW5pbmcgYW4gaWRcbiAgICovXG4gIGluaXQoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIHN0b3JlIHRoZSBuYW1lIG9mIHRoZSBncm91cFxuICAgIHRoaXMuX2lkID0gaWQ7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGVudHJ5IGluIHRoZSBxdWVyeSBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdKSB7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VjdGlvblxuICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdID0gW107XG5cbiAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZXMgYWZ0ZXIgdGhlIGluaXRpYWwgc2V0dXBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlIYXNDaGFuZ2VkKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmaWVsZCBmcm9tIHRoZSBzZWFyY2ggYnVpbGRlciBxdWVyeSBhbmQgcmV0dXJuIGZvY3VzIHRvIHRoZSBwcmV2aW91cyBmaWVsZC5cbiAgICovXG4gIHJlbW92ZUF0SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuXG4gICAgLy8gZ2V0IHRoZSBxdWVyeSBmb3IgdGhpcyBncm91cFxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5nZXRRdWVyeSgpO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBmaWVsZCBmcm9tIHRoZSBhcnJheVxuICAgIHF1ZXJ5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyBGb2N1cyB0aGUgcHJldmlvdXMgaXRlbSBpZiBhdmFpbGFibGVcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlLnNldEZvY3VzKHRoaXMuX2lkLCBpbmRleCA8PSAwID8gMCA6IGluZGV4IC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWVyeSBmb3IgdGhpcyBzcGVjaWZpYyBzZWFyY2ggZ3JvdXBcbiAgICovXG4gIGdldFF1ZXJ5KCk6IFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5W10ge1xuICAgIHJldHVybiB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5xdWVyeVt0aGlzLl9pZF0gPyB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5xdWVyeVt0aGlzLl9pZF0gOiBbXTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3JvdXAtcXVlcnkuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLWdyb3VwLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtYnVpbGRlci1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9zZWFyY2gtYnVpbGRlci1ncm91cC5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW1NlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBpZDogc3RyaW5nO1xuICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgQElucHV0KCkgb3BlcmF0b3I6IFNlYXJjaEJ1aWxkZXJHcm91cE9wZXJhdG9yID0gJ2FuZCc7XG4gIEBJbnB1dCgpIGFkZFRleHQ6IHN0cmluZyA9ICdBZGQgYSBmaWVsZCc7XG4gIEBJbnB1dCgpIHBsYWNlaG9sZGVyOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBASW5wdXQoKSBzaG93UGxhY2Vob2xkZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBAT3V0cHV0KCkgYWRkOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG4gIEBPdXRwdXQoKSByZW1vdmU6IEV2ZW50RW1pdHRlcjxTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeT4gPSBuZXcgRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5PigpO1xuXG4gIGZvY3VzSW5kZXg6IG51bWJlciA9IC0xO1xuXG4gIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlckZvY3VzU2VydmljZTogU2VhcmNoQnVpbGRlckZvY3VzU2VydmljZVxuICApIHsgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgLy8gZW5zdXJlIHdlIGhhdmUgYSBuYW1lIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvclxuICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWFyY2ggYnVpbGRlciBncm91cCBtdXN0IGhhdmUgYW4gaWQgYXR0cmlidXRlLicpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSByZWdpc3RlciB0aGUgZ3JvdXBcbiAgICB0aGlzLnNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UuaW5pdCh0aGlzLmlkKTtcblxuICAgIC8vIFRyYWNrIGZvY3VzIGZvciBjaGlsZCBjb21wb25lbnRzXG4gICAgdGhpcy5fc2VhcmNoQnVpbGRlckZvY3VzU2VydmljZS5mb2N1cyQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGZvY3VzID0+IHtcbiAgICAgIHRoaXMuZm9jdXNJbmRleCA9IChmb2N1cy5ncm91cElkID09PSB0aGlzLmlkKSA/IGZvY3VzLmluZGV4IDogLTE7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICB9XG5cbiAgYWRkRmllbGQoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLmFkZC5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIHJlbW92ZUZpZWxkQXRJbmRleChpbmRleDogbnVtYmVyLCBmaWVsZDogU2VhcmNoQnVpbGRlckdyb3VwUXVlcnkpOiB2b2lkIHtcbiAgICB0aGlzLnNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UucmVtb3ZlQXRJbmRleChpbmRleCk7XG4gICAgdGhpcy5yZW1vdmUuZW1pdChmaWVsZCk7XG4gIH1cblxuICBzZXRGb2N1cyhpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5fc2VhcmNoQnVpbGRlckZvY3VzU2VydmljZS5zZXRGb2N1cyh0aGlzLmlkLCBpbmRleCk7XG4gIH1cblxuICBjbGVhckZvY3VzKCk6IHZvaWQge1xuICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2UuY2xlYXJGb2N1cygpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFNlYXJjaEJ1aWxkZXJHcm91cE9wZXJhdG9yID0gJ2FuZCcgfCAnb3InIHwgJ25vdCc7XG4iLCJpbXBvcnQgeyBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgRGlyZWN0aXZlLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRlbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4uL3NlYXJjaC1jb21wb25lbnRzL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2VhcmNoQnVpbGRlck91dGxldF0nXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoJ3V4U2VhcmNoQnVpbGRlck91dGxldCcpIG91dGxldDogc3RyaW5nO1xuICAgIEBJbnB1dCgndXhTZWFyY2hCdWlsZGVyT3V0bGV0Q29udGV4dCcpIGNvbnRleHQ6IGFueTtcbiAgICBASW5wdXQoJ3V4U2VhcmNoQnVpbGRlck91dGxldEdyb3VwSWQnKSBncm91cElkOiBzdHJpbmc7XG4gICAgQElucHV0KCd1eFNlYXJjaEJ1aWxkZXJPdXRsZXRJbmRleCcpIGluZGV4OiBudW1iZXI7XG5cbiAgICBwcml2YXRlIF9jb21wb25lbnRSZWY6IENvbXBvbmVudFJlZjxCYXNlU2VhcmNoQ29tcG9uZW50PjtcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByaXZhdGUgX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBwcml2YXRlIF9zZWFyY2hCdWlsZGVyU2VydmljZTogU2VhcmNoQnVpbGRlclNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2U6IFNlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbGFzcyBmcm9tIHRoZSB0eXBlXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudERlZmluaXRpb24gPSB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5nZXRDb21wb25lbnQodGhpcy5vdXRsZXQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgY29tcG9uZW50IGZhY3RvcnlcbiAgICAgICAgY29uc3QgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeTxCYXNlU2VhcmNoQ29tcG9uZW50Pihjb21wb25lbnREZWZpbml0aW9uLmNvbXBvbmVudCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSk7XG5cbiAgICAgICAgLy8gY29tYmluZSB0aGUgcHJlZGVmaW5lZCBjb25maWcgd2l0aCBhbnkgZHlubWFpYyBjb25maWdcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29tcG9uZW50RGVmaW5pdGlvbi5jb25maWcsIHRoaXMuY29udGV4dC5jb25maWcgfHwge30pO1xuXG4gICAgICAgIC8vIHNldCB0aGUgY29udGV4dCBhbmQgY29uZmlnIHByb3BlcnR5IG9uIHRoZSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZS5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlckZvY3VzU2VydmljZS5mb2N1cyRcbiAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIGRlbGF5KDApLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZm9jdXMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZS5mb2N1cyA9IChmb2N1cy5ncm91cElkID09PSB0aGlzLmdyb3VwSWQgJiYgZm9jdXMuaW5kZXggPT09IHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb24gfSBmcm9tICcuL2ludGVyZmFjZXMvY29tcG9uZW50LWRlZmluaXRpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJRdWVyeSB9IGZyb20gJy4vaW50ZXJmYWNlcy9xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtYnVpbGRlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9zZWFyY2gtYnVpbGRlci5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW1NlYXJjaEJ1aWxkZXJTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBASW5wdXQoKVxuICBzZXQgY29tcG9uZW50cyhjb21wb25lbnRzOiBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbltdKSB7XG4gICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucmVnaXN0ZXJDb21wb25lbnRzKGNvbXBvbmVudHMpO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IHF1ZXJ5KHZhbHVlOiBTZWFyY2hCdWlsZGVyUXVlcnkpIHtcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5zZXRRdWVyeSh2YWx1ZSk7XG4gIH1cblxuICBnZXQgcXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLmdldFF1ZXJ5KCk7XG4gIH1cblxuICBAT3V0cHV0KCkgcXVlcnlDaGFuZ2U6IEV2ZW50RW1pdHRlcjxTZWFyY2hCdWlsZGVyUXVlcnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxTZWFyY2hCdWlsZGVyUXVlcnk+KCk7XG4gIEBPdXRwdXQoKSB2YWxpZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBwcml2YXRlIF9xdWVyeVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIF92YWxpZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB0aGUgZGVmYXVsdCBzZWFyY2ggYnVpbGRlciBjb21wb25lbnRzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWFyY2hCdWlsZGVyU2VydmljZTogU2VhcmNoQnVpbGRlclNlcnZpY2UpIHtcblxuICAgIC8vIHdhdGNoIGZvciBhbnkgcXVlcnkgY2hhbmdlc1xuICAgIHRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uID0gX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5Q2hhbmdlLnN1YnNjcmliZShxdWVyeSA9PiB0aGlzLnF1ZXJ5Q2hhbmdlLmVtaXQocXVlcnkpKTtcblxuICAgIC8vIHdhdGNoIGZvciBhbnkgY2hhbmdlcyB0byB0aGUgdmFsaWRhdGlvblxuICAgIHRoaXMuX3ZhbGlkU3Vic2NyaXB0aW9uID0gX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnZhbGlkYXRpb25DaGFuZ2UucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUodmFsaWQgPT4gdGhpcy52YWxpZC5lbWl0KHZhbGlkKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFueSBzdWJzY3JpcHRpb25zIGFuZCBjbGVhbnVwXG4gICAqL1xuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9xdWVyeVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX3ZhbGlkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBTdGF0aWNQcm92aWRlciwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZGVsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIG1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb24gfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmRleCc7XHJcbmltcG9ydCB7IFRhZ0lucHV0Q29tcG9uZW50IH0gZnJvbSAnLi4vdGFnLWlucHV0L2luZGV4JztcclxuaW1wb3J0IHsgVHlwZWFoZWFkQ29tcG9uZW50LCBUeXBlYWhlYWRLZXlTZXJ2aWNlLCBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XHJcblxyXG5sZXQgdW5pcXVlSWQgPSAwO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNFTEVDVF9WQUxVRV9BQ0NFU1NPUjogU3RhdGljUHJvdmlkZXIgPSB7XHJcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNlbGVjdENvbXBvbmVudCksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXNlbGVjdCcsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3NlbGVjdC5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBwcm92aWRlcnM6IFtTRUxFQ1RfVkFMVUVfQUNDRVNTT1JdLFxyXG4gICAgaG9zdDoge1xyXG4gICAgICAgICd0YWJpbmRleCc6ICcwJ1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xyXG5cclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGlkOiBzdHJpbmcgPSBgdXgtc2VsZWN0LSR7Kyt1bmlxdWVJZH1gO1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlJC5uZXh0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUkLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBzZXQgaW5wdXQodmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2lucHV0JC5uZXh0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCBpbnB1dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXQkLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBzZXQgZHJvcGRvd25PcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fZHJvcGRvd25PcGVuID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5kcm9wZG93bk9wZW5DaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgZHJvcGRvd25PcGVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wZG93bk9wZW47XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KCkgb3B0aW9uczogYW55W10gfCBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcclxuICAgIEBJbnB1dCgpIGRpc3BsYXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkga2V5OiAob3B0aW9uOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGFsbG93TnVsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIGRyb3BEaXJlY3Rpb246ICd1cCcgfCAnZG93bicgPSAnZG93bic7XHJcbiAgICBASW5wdXQoKSBtYXhIZWlnaHQ6IHN0cmluZyA9ICcyNTBweCc7XHJcbiAgICBASW5wdXQoKSBtdWx0aXBsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgcGFnZVNpemU6IG51bWJlciA9IDIwO1xyXG4gICAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGF1dG9jb21wbGV0ZTogc3RyaW5nID0gJ29mZic7XHJcblxyXG4gICAgQElucHV0KCkgbG9hZGluZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgQElucHV0KCkgbm9PcHRpb25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBvcHRpb25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIEBPdXRwdXQoKSBpbnB1dENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xyXG4gICAgQE91dHB1dCgpIGRyb3Bkb3duT3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcclxuXHJcbiAgICBAVmlld0NoaWxkKCdzaW5nbGVJbnB1dCcpIHNpbmdsZUlucHV0OiBFbGVtZW50UmVmO1xyXG4gICAgQFZpZXdDaGlsZCgndGFnSW5wdXQnKSB0YWdJbnB1dDogVGFnSW5wdXRDb21wb25lbnQ7XHJcbiAgICBAVmlld0NoaWxkKCdtdWx0aXBsZVR5cGVhaGVhZCcpIG11bHRpcGxlVHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQ7XHJcbiAgICBAVmlld0NoaWxkKCdzaW5nbGVUeXBlYWhlYWQnKSBzaW5nbGVUeXBlYWhlYWQ6IFR5cGVhaGVhZENvbXBvbmVudDtcclxuXHJcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gICAgZmlsdGVyJDogT2JzZXJ2YWJsZTxzdHJpbmc+O1xyXG4gICAgcHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4geyB9O1xyXG5cclxuICAgIHByaXZhdGUgX3ZhbHVlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcclxuICAgIHByaXZhdGUgX2lucHV0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XHJcbiAgICBwcml2YXRlIF9kcm9wZG93bk9wZW46IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55LFxyXG4gICAgICAgIHByaXZhdGUgX3R5cGVhaGVhZEtleVNlcnZpY2U6IFR5cGVhaGVhZEtleVNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG5cclxuICAgICAgICAvLyBFbWl0IGNoYW5nZSBldmVudHNcclxuICAgICAgICB0aGlzLl92YWx1ZSQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLl9pbnB1dCQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZS5lbWl0KHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQ2hhbmdlcyB0byB0aGUgaW5wdXQgZmllbGRcclxuICAgICAgICB0aGlzLl9pbnB1dCQucGlwZShcclxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXHJcbiAgICAgICAgICAgIGZpbHRlcih2YWx1ZSA9PiB0aGlzLmFsbG93TnVsbCksXHJcbiAgICAgICAgICAgIGZpbHRlcih2YWx1ZSA9PiAhdGhpcy5tdWx0aXBsZSAmJiB2YWx1ZSAhPT0gdGhpcy5nZXREaXNwbGF5KHRoaXMudmFsdWUpKVxyXG4gICAgICAgICkuc3Vic2NyaWJlKHZhbHVlID0+IHRoaXMudmFsdWUgPSBudWxsKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHVwIGZpbHRlciBmcm9tIGlucHV0XHJcbiAgICAgICAgdGhpcy5maWx0ZXIkID0gdGhpcy5faW5wdXQkLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcChpbnB1dCA9PiAhdGhpcy5tdWx0aXBsZSAmJiBpbnB1dCA9PT0gdGhpcy5nZXREaXNwbGF5KHRoaXMudmFsdWUpID8gJycgOiBpbnB1dCksXHJcbiAgICAgICAgICAgIGRlYm91bmNlVGltZSgyMDApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gT3BlbiB0aGUgZHJvcGRvd24gd2hlbiBmaWx0ZXIgaXMgbm9uZW1wdHkuXHJcbiAgICAgICAgdGhpcy5maWx0ZXIkLnBpcGUoXHJcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxyXG4gICAgICAgICAgICBmaWx0ZXIodmFsdWUgPT4gdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMClcclxuICAgICAgICApLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyb3Bkb3duT3BlbiA9IHRydWUpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNpbmdsZS1zZWxlY3QgaW5wdXQgd2hlbiB0aGUgbW9kZWwgY2hhbmdlc1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlJC5waXBlKFxyXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSxcclxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgICAgICAgZGVsYXkoMCksXHJcbiAgICAgICAgICAgIGZpbHRlcih2YWx1ZSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiAhdGhpcy5tdWx0aXBsZSlcclxuICAgICAgICApLnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdldERpc3BsYXkodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoY2hhbmdlcy5tdWx0aXBsZSAmJiAhY2hhbmdlcy5tdWx0aXBsZS5maXJzdENoYW5nZSAmJiBjaGFuZ2VzLm11bHRpcGxlLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5tdWx0aXBsZS5wcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdmb2N1cycpXHJcbiAgICBvbmZvY3VzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZUlucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlSW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50YWdJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhZ0lucHV0LmZvY3VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQgeyB9XHJcblxyXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRDbGlja0hhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdElucHV0VGV4dCgpO1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpbnB1dEJsdXJIYW5kbGVyKGV2ZW50OiBFdmVudCkge1xyXG5cclxuICAgICAgICAvLyBJZiBhIGNsaWNrIG9uIHRoZSB0eXBlYWhlYWQgaXMgaW4gcHJvZ3Jlc3MsIGp1c3QgcmVmb2N1cyB0aGUgaW5wdXQuXHJcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgYW4gaXNzdWUgaW4gSUUgd2hlcmUgY2xpY2tpbmcgYSBzY3JvbGxiYXIgZHJvcHMgZm9jdXMuXHJcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlVHlwZWFoZWFkICYmIHRoaXMuc2luZ2xlVHlwZWFoZWFkLmNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlSW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbG9zZSBkcm9wZG93biBhbmQgcmVzZXQgdGV4dCBpbnB1dCBpZiBmb2N1cyBpcyBsb3N0XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZXkgaGFuZGxlciBmb3Igc2luZ2xlIHNlbGVjdCBvbmx5LiBNdWx0aXBsZSBzZWxlY3Qga2V5IGhhbmRsaW5nIGlzIGluIFRhZ0lucHV0Q29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBpbnB1dEtleUhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcclxuXHJcbiAgICAgICAgLy8gU3RhbmRhcmQga2V5cyBmb3IgdHlwZWFoZWFkICh1cC9kb3duL2VzYylcclxuICAgICAgICB0aGlzLl90eXBlYWhlYWRLZXlTZXJ2aWNlLmhhbmRsZUtleShldmVudCwgdGhpcy5zaW5nbGVUeXBlYWhlYWQpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xyXG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJvcGRvd25PcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBoaWdobGlnaHRlZCBvcHRpb24gYXMgdGhlIHZhbHVlIGFuZCBjbG9zZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNpbmdsZVR5cGVhaGVhZC5oaWdobGlnaHRlZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQuIElmIGRyb3Bkb3duIGlzbid0IG9wZW4gdGhlbiByZXNldCBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5nZXREaXNwbGF5KHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaW5nbGVPcHRpb25TZWxlY3RlZChldmVudDogVHlwZWFoZWFkT3B0aW9uRXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQub3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBldmVudC5vcHRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5KG9wdGlvbjogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheShvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycgJiYgb3B0aW9uLmhhc093blByb3BlcnR5KHRoaXMuZGlzcGxheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbls8c3RyaW5nPnRoaXMuZGlzcGxheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZWxlY3RJbnB1dFRleHQoKSB7XHJcbiAgICAgICAgdGhpcy5zaW5nbGVJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdCgpO1xyXG4gICAgfVxyXG59IiwiZXhwb3J0IGNsYXNzIFRhZ0lucHV0RXZlbnQge1xuXG4gICAgcHJpdmF0ZSBfZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHRhZzogYW55KSB7fVxuXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGRlZmF1bHRQcmV2ZW50ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBCQUNLU1BBQ0UsIERFTEVURSwgRU5URVIsIExFRlRfQVJST1csIFJJR0hUX0FSUk9XLCBTUEFDRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBRdWVyeUxpc3QsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTElEQVRPUlMsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IHRpY2sgfSBmcm9tICcuLi8uLi9jb21tb24vaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEtleVNlcnZpY2UgfSBmcm9tICcuLi90eXBlYWhlYWQvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRPcHRpb25FdmVudCB9IGZyb20gJy4uL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQnO1xyXG5pbXBvcnQgeyBUYWdJbnB1dEV2ZW50IH0gZnJvbSAnLi90YWctaW5wdXQtZXZlbnQnO1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbmNvbnN0IFRBR0lOUFVUX1ZBTFVFX0FDQ0VTU09SID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUYWdJbnB1dENvbXBvbmVudCksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5jb25zdCBUQUdJTlBVVF9WQUxJREFUT1IgPSB7XHJcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGFnSW5wdXRDb21wb25lbnQpLFxyXG4gICAgbXVsdGk6IHRydWVcclxufTtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10YWctaW5wdXQnLFxyXG4gICAgZXhwb3J0QXM6ICd1eC10YWctaW5wdXQnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0YWctaW5wdXQuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgcHJvdmlkZXJzOiBbVEFHSU5QVVRfVkFMVUVfQUNDRVNTT1IsIFRBR0lOUFVUX1ZBTElEQVRPUl0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxyXG4gICAgICAgICdbY2xhc3MuZm9jdXNdJzogJ2hhc0ZvY3VzKCknLFxyXG4gICAgICAgICdbY2xhc3MuaW52YWxpZF0nOiAnIXZhbGlkIHx8ICFpbnB1dFZhbGlkJ1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGFnSW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJykgaWQ6IHN0cmluZyA9IGB1eC10YWctaW5wdXQtJHsrK3VuaXF1ZUlkfWA7XHJcblxyXG4gICAgQElucHV0KCd0YWdzJylcclxuICAgIGdldCB0YWdzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdGFncykge1xyXG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWdzO1xyXG4gICAgfVxyXG4gICAgc2V0IHRhZ3ModmFsdWU6IGFueVtdKSB7XHJcbiAgICAgICAgdGhpcy5fdGFncyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlSGFuZGxlcih0aGlzLl90YWdzKTtcclxuICAgICAgICB0aGlzLnRhZ3NDaGFuZ2UuZW1pdCh0aGlzLl90YWdzKTtcclxuICAgIH1cclxuXHJcbiAgICBAT3V0cHV0KCkgdGFnc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XHJcblxyXG4gICAgQElucHV0KCdpbnB1dCcpXHJcbiAgICBnZXQgaW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0O1xyXG4gICAgfVxyXG4gICAgc2V0IGlucHV0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9pbnB1dCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaW5wdXRDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQE91dHB1dCgpIGlucHV0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XHJcblxyXG4gICAgQElucHV0KCkgZGlzcGxheTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBhZGRPblBhc3RlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBlbmZvcmNlVGFnTGltaXRzOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBmcmVlSW5wdXQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgQElucHV0KCkgbWF4VGFnczogbnVtYmVyID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIEBJbnB1dCgpIG1pblRhZ3M6IG51bWJlciA9IDA7XHJcbiAgICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nID0gJyc7XHJcbiAgICBASW5wdXQoKSBzaG93VHlwZWFoZWFkT25DbGljazogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgdGFnRGVsaW1pdGVyczogc3RyaW5nID0gJyc7XHJcbiAgICBASW5wdXQoKSB0YWdQYXR0ZXJuOiBSZWdFeHA7XHJcbiAgICBASW5wdXQoKSB0YWdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIHRhZ0NsYXNzOiBUYWdDbGFzc0Z1bmN0aW9uID0gKCkgPT4gdW5kZWZpbmVkO1xyXG4gICAgQElucHV0KCkgdmFsaWRhdGlvbkVycm9yczogYW55ID0ge307XHJcbiAgICBASW5wdXQoKSBhdXRvY29tcGxldGU6IHN0cmluZyA9ICdvZmYnO1xyXG4gICAgQElucHV0KCdjcmVhdGVUYWcnKSBjcmVhdGVUYWdIYW5kbGVyOiAodmFsdWU6IHN0cmluZykgPT4gYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIFdvcmthcm91bmQgZm9yIEVMLTMyMjQgLSBObyBsb25nZXIgbmVlZGVkXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHRyYWNrQXJpYURlc2NlbmRhbnQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIEBPdXRwdXQoKSB0YWdBZGRpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnQWRkZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnSW52YWxpZGF0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnUmVtb3ZpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnUmVtb3ZlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuXHJcbiAgICBAQ29udGVudENoaWxkcmVuKFR5cGVhaGVhZENvbXBvbmVudCkgdHlwZWFoZWFkUXVlcnk6IFF1ZXJ5TGlzdDxUeXBlYWhlYWRDb21wb25lbnQ+O1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ3RhZ0lucHV0JykgdGFnSW5wdXQ6IEVsZW1lbnRSZWY7XHJcblxyXG4gICAgQFZpZXdDaGlsZCgnZGVmYXVsdFRhZ1RlbXBsYXRlJykgcHJpdmF0ZSBfZGVmYXVsdFRhZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciA9IC0xO1xyXG5cclxuICAgIHRhZ0FwaTogVGFnQXBpID0ge1xyXG4gICAgICAgIGdldFRhZ0Rpc3BsYXk6IHRoaXMuZ2V0VGFnRGlzcGxheS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIHJlbW92ZVRhZ0F0OiB0aGlzLnJlbW92ZVRhZ0F0LmJpbmQodGhpcyksXHJcbiAgICAgICAgY2FuUmVtb3ZlVGFnQXQ6IHRoaXMuY2FuUmVtb3ZlVGFnQXQuYmluZCh0aGlzKVxyXG4gICAgfTtcclxuXHJcbiAgICB2YWxpZDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBpbnB1dFZhbGlkOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50O1xyXG4gICAgaGlnaGxpZ2h0ZWRFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBwcml2YXRlIF9pbnB1dDogc3RyaW5nID0gJyc7XHJcbiAgICBwcml2YXRlIF90YWdzOiBhbnlbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfb25DaGFuZ2VIYW5kbGVyOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xyXG4gICAgcHJpdmF0ZSBfb25Ub3VjaGVkSGFuZGxlcjogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcclxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICAgICAgcHJpdmF0ZSBfdHlwZWFoZWFkS2V5U2VydmljZTogVHlwZWFoZWFkS2V5U2VydmljZSkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRhZ1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnVGVtcGxhdGUgPSB0aGlzLl9kZWZhdWx0VGFnVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcclxuICAgICAgICAvLyBXYXRjaCBmb3Igb3B0aW9uYWwgY2hpbGQgdHlwZWFoZWFkIGNvbnRyb2xcclxuICAgICAgICB0aGlzLmNvbm5lY3RUeXBlYWhlYWQodGhpcy50eXBlYWhlYWRRdWVyeS5maXJzdCk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZWFoZWFkUXVlcnkuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChxdWVyeSkgPT4gdGhpcy5jb25uZWN0VHlwZWFoZWFkKHF1ZXJ5LmZpcnN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmIChjaGFuZ2VzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmRpc2FibGVkLmN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgc2VsZWN0aW9uIGFuZCBjbG9zZSBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlYWhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGVhaGVhZC5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB2YWxpZGF0aW9uIHN0YXR1c1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnlbXSk6IHZvaWQge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VIYW5kbGVyID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX29uVG91Y2hlZEhhbmRsZXIgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBmb2N1cyBvbiB0aGUgaW5wdXQgZmllbGQuXHJcbiAgICAgKi9cclxuICAgIGZvY3VzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0lucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnSW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCAodGFncyBwcm9wZXJ0eSkuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCB0YWdSYW5nZUVycm9yID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy50YWdzICYmICh0aGlzLnRhZ3MubGVuZ3RoIDwgdGhpcy5taW5UYWdzIHx8IHRoaXMudGFncy5sZW5ndGggPiB0aGlzLm1heFRhZ3MpKSB7XHJcbiAgICAgICAgICAgIHRhZ1JhbmdlRXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBnaXZlbjogdGhpcy50YWdzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5UYWdzLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heFRhZ3NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnNbJ3RhZ1JhbmdlRXJyb3InXSA9IHRhZ1JhbmdlRXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXHJcbiAgICBrZXlIYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGlucHV0IGZpZWxkIGN1cnNvciBsb2NhdGlvblxyXG4gICAgICAgIGNvbnN0IGlucHV0Q3Vyc29yUG9zID0gdGhpcy50YWdJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZpZWxkIGhhcyBhbnkgdGV4dCBzZWxlY3RlZFxyXG4gICAgICAgIGNvbnN0IGhhc1NlbGVjdGlvbiA9IHRoaXMudGFnSW5wdXQubmF0aXZlRWxlbWVudC5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy50YWdJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvbkVuZDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGEgdGFnIGhhcyBmb2N1c1xyXG4gICAgICAgIGNvbnN0IHRhZ1NlbGVjdGVkID0gdGhpcy5pc1ZhbGlkVGFnSW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5wdXRMZW5ndGggPSB0aGlzLmlucHV0ID8gdGhpcy5pbnB1dC5sZW5ndGggOiAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBhcnJvdyBrZXlzIGNhbiBtb3ZlIHRoZSBzZWxlY3Rpb24uIE90aGVyd2lzZSB0aGUgaW5wdXQgZmllbGQgdGFrZXMgdGhlIGV2ZW50LlxyXG4gICAgICAgIGNvbnN0IGNhbk5hdmlnYXRlTGVmdCA9IHRhZ1NlbGVjdGVkIHx8IChpbnB1dEN1cnNvclBvcyA8PSAwICYmICFoYXNTZWxlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGNhbk5hdmlnYXRlUmlnaHQgPSB0YWdTZWxlY3RlZCB8fCAoaW5wdXRDdXJzb3JQb3MgPj0gaW5wdXRMZW5ndGggJiYgIWhhc1NlbGVjdGlvbik7XHJcblxyXG4gICAgICAgIC8vIEZvcndhcmQga2V5IGV2ZW50cyB0byB0aGUgdHlwZWFoZWFkIGNvbXBvbmVudC5cclxuICAgICAgICB0aGlzLl90eXBlYWhlYWRLZXlTZXJ2aWNlLmhhbmRsZUtleShldmVudCwgdGhpcy50eXBlYWhlYWQpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRU5URVI6XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhIHR5cGVhaGVhZCBvcHRpb24gaXMgaGlnaGxpZ2h0ZWRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCAmJiB0aGlzLnR5cGVhaGVhZC5vcGVuICYmIHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB0eXBlYWhlYWQgb3B0aW9uIGFzIGEgdGFnLCBjbGVhciB0aGUgaW5wdXQsIGFuZCBjbG9zZSB0aGUgZHJvcGRvd25cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdFR5cGVhaGVhZCh0aGlzLnR5cGVhaGVhZC5oaWdobGlnaHRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSBhbmQgYWRkIHRoZSBpbnB1dCB0ZXh0IGFzIGEgdGFnLCBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0SW5wdXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQkFDS1NQQUNFOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja3NwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBERUxFVEU6XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ0F0KHRoaXMuc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcclxuICAgICAgICAgICAgICAgIGlmIChjYW5OYXZpZ2F0ZUxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuTmF2aWdhdGVSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigxKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3Iga2V5cyBpbiB0aGUgdGFnRGVsaW1pdGVyc1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0RlbGltaXRlcnMgJiYgdGhpcy50YWdEZWxpbWl0ZXJzLmluZGV4T2YodGhpcy5nZXRLZXlDaGFyKGV2ZW50KSkgPj0gMCkge1xyXG4gICAgICAgICAgICAvLyBDb21taXQgcHJldmlvdXMgdGV4dFxyXG4gICAgICAgICAgICB0aGlzLmNvbW1pdElucHV0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdmb2N1c291dCcpXHJcbiAgICBmb2N1c091dEhhbmRsZXIoKTogdm9pZCB7XHJcblxyXG4gICAgICAgIC8vIElmIGEgY2xpY2sgb24gdGhlIHR5cGVhaGVhZCBpcyBpbiBwcm9ncmVzcywgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgYW4gaXNzdWUgaW4gSUUgd2hlcmUgY2xpY2tpbmcgYSBzY3JvbGxiYXIgZHJvcHMgZm9jdXMuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMudHlwZWFoZWFkLmNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBvbiBibHVyXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFnQ2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50LCB0YWc6IGFueSwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gU2VuZCB0YWdDbGljayBldmVudFxyXG4gICAgICAgIGNvbnN0IHRhZ0NsaWNrRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgIHRoaXMudGFnQ2xpY2suZW1pdCh0YWdDbGlja0V2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBmb2N1cyBpZiBwcmV2ZW50RGVmYXVsdCgpIHdhcyBjYWxsZWRcclxuICAgICAgICBpZiAodGFnQ2xpY2tFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VsZWN0IHRoZSB0YWcgKGZvciBJRSB0aGF0IGRvZXNuJ3QgcHJvcGFnYXRlIGZvY3VzKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0VGFnQXQoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Q2xpY2tIYW5kbGVyKCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMuc2hvd1R5cGVhaGVhZE9uQ2xpY2spIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Rm9jdXNIYW5kbGVyKCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRQYXN0ZUhhbmRsZXIoZXZlbnQ6IENsaXBib2FyZEV2ZW50KTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hZGRPblBhc3RlKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0ZXh0IGZyb20gdGhlIGNsaXBib2FyZFxyXG4gICAgICAgICAgICBsZXQgaW5wdXQ6IHN0cmluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5jbGlwYm9hcmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCg8YW55PndpbmRvdykuY2xpcGJvYXJkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgb25seVxyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAoPGFueT53aW5kb3cpLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIGNsaXBib2FyZCB0ZXh0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1pdChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0eXBlYWhlYWRPcHRpb25TZWxlY3RlZEhhbmRsZXIoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSB0eXBlYWhlYWQgc2VuZHMgdGhlIG9wdGlvblNlbGVjdGVkIGV2ZW50LCBjb21taXQgdGhlIG9iamVjdCBkaXJlY3RseVxyXG4gICAgICAgIHRoaXMuY29tbWl0VHlwZWFoZWFkKGV2ZW50Lm9wdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21taXQgdGhlIGN1cnJlbnQgaW5wdXQgdmFsdWUgYW5kIGNsZWFyIHRoZSBpbnB1dCBmaWVsZCBpZiBzdWNjZXNzZnVsLlxyXG4gICAgICovXHJcbiAgICBjb21taXRJbnB1dCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5jb21taXQodGhpcy5pbnB1dCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBnaXZlbiB0YWcgb2JqZWN0IGFuZCBjbGVhciB0aGUgaW5wdXQgaWYgc3VjY2Vzc2Z1bC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0VHlwZWFoZWFkKHRhZzogYW55KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWRkVGFnKHRhZykpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgYXMgb25lIG9yIG1vcmUgdGFncywgaWYgdmFsaWRhdGlvbiBwYXNzZXMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnKHMpIHdlcmUgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0KGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoaW5wdXQgJiYgdGhpcy5mcmVlSW5wdXQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFNwbGl0IHRoZSB0YWdzIGJ5IHRoZSB0YWdEZWxpbWl0ZXJzIGlmIGNvbmZpZ3VyZWRcclxuICAgICAgICAgICAgY29uc3QgbmV3VGFncyA9IHRoaXMuc3BsaXRUYWdJbnB1dChpbnB1dCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB0YWcgdmFsaWRhdGlvbiBmb3IgYWxsIG9mIHRoZSBpbmRpdmlkdWFsIHZhbHVlc1xyXG4gICAgICAgICAgICBsZXQgYWxsVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuZXdUYWcgb2YgbmV3VGFncykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlVGFnKG5ld1RhZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSB0YWdzIGlmIGFsbCBhcmUgdmFsaWRcclxuICAgICAgICAgICAgaWYgKGFsbFZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuZXdUYWcgb2YgbmV3VGFncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRoaXMuY3JlYXRlVGFnKG5ld1RhZykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBubyB0YWcgaXMgc2VsZWN0ZWQsIHNlbGVjdCB0aGUgcmlnaHRtb3N0IHRhZy4gSWYgYSB0YWcgaXMgc2VsZWN0ZWQsIHJlbW92ZSBpdC5cclxuICAgICAqL1xyXG4gICAgYmFja3NwYWNlKCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhZ0luZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RUYWdBdCh0aGlzLnRhZ3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWdBdCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbiBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGhlIGxpc3QuIFdyYXBzIGF0IHRoZSBsaW1pdHMuXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgVmFsdWUgdG8gYmUgYWRkZWQgdG8gdGhlIHNlbGVjdGVkIGluZGV4LCBpLmUuIC0xIHRvIG1vdmUgYmFja3dhcmRzLCArMSB0byBtb3ZlIGZvcndhcmRzLlxyXG4gICAgICovXHJcbiAgICBtb3ZlU2VsZWN0aW9uKGRlbHRhOiBudW1iZXIpOiB2b2lkIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRTZWxlY3RJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCArPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvIHdyYXBwaW5nIG9mIHNlbGVjdGlvbiB3aGVuIG91dCBvZiBib3VuZHNcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMudGFncy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID4gdGhpcy50YWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2YWx1ZSB0byBkaXNwbGF5IGZvciB0aGUgZ2l2ZW4gdGFnLiBVc2VzIGRpc3BsYXkgZnVuY3Rpb24vcHJvcGVydHkgbmFtZSBpZiBzZXQsIG90aGVyd2lzZSBhc3N1bWVzIHRoYXQgdGhlIHRhZyBpcyBhIHNpbXBsZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGdldFRhZ0Rpc3BsYXkodGFnOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkodGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YWdbPHN0cmluZz50aGlzLmRpc3BsYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBpbmRleCBpcyBzZWxlY3RlZCAodGFnIGluZGV4IG9yIGlucHV0IGZpZWxkKS5cclxuICAgICAqL1xyXG4gICAgaXNTZWxlY3RlZChpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSB0aGlzLnNlbGVjdGVkSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXguIERvZXMgbm90aGluZyBpZiBkaXNhYmxlZCBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBzZWxlY3RUYWdBdCh0YWdJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRhZ0luZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgaW5wdXQgZmllbGQsIGdpdmluZyBpdCBmb2N1cy4gRG9lcyBub3RoaW5nIGlmIGRpc2FibGVkIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdElucHV0KCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4LiBEb2VzIG5vdGhpbmcgaWYgZGlzYWJsZWQgaXMgdHJ1ZSBvciB0aGUgbWluVGFncyBwcm9wZXJ0eSBwcmV2ZW50cyByZW1vdmFsLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWdBdCh0YWdJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNhblJlbW92ZVRhZ0F0KHRhZ0luZGV4KSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdGFnSW5kZXggaXMgaW4gcmFuZ2VcclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnc1t0YWdJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ1JlbW92aW5nRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ1JlbW92aW5nLmVtaXQodGFnUmVtb3ZpbmdFdmVudCk7XHJcbiAgICAgICAgICAgIGlmICghdGFnUmVtb3ZpbmdFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpbnB1dCBmaXJzdCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBkcm9wcGluZyBmb2N1c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YWdcclxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5zcGxpY2UodGFnSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIGFnYWluIHNpbmNlIGluZGljZXMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ1JlbW92ZWQuZW1pdChuZXcgVGFnSW5wdXRFdmVudCh0YWcpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgY2FuUmVtb3ZlVGFnQXQodGFnSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoID4gdGhpcy5taW5UYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGZpZWxkIHNob3VsZCBiZSBhdmFpbGFibGUuXHJcbiAgICAgKi9cclxuICAgIGlzSW5wdXRWaXNpYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoIDwgdGhpcy5tYXhUYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IHBhcnQgb2YgdGhlIGNvbnRyb2wgaGFzIGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBoYXNGb2N1cygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU2VsZWN0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbm5lY3RUeXBlYWhlYWQodHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50eXBlYWhlYWQgPSB0eXBlYWhlYWQ7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkKSB7XHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciBzZWxlY3RlZCBvcHRpb25zXHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMudHlwZWFoZWFkLm9wdGlvblNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLnR5cGVhaGVhZE9wdGlvblNlbGVjdGVkSGFuZGxlci5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciB0aGUgaGlnaGxpZ2h0ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBBZGRlZCBhIGRlbGF5IHRvIG1vdmUgaXQgb3V0IG9mIHRoZSBjdXJyZW50IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGVcclxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkRWxlbWVudENoYW5nZS5waXBlKHRpY2soKSlcclxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChlbGVtZW50OiBIVE1MRWxlbWVudCkgPT4gdGhpcy5oaWdobGlnaHRlZEVsZW1lbnQgPSBlbGVtZW50KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBnaXZlbiB0YWdWYWx1ZSB3aXRoIHRoZSB0YWdQYXR0ZXJuLCBpZiBzZXQuIFVwZGF0ZSB2YWxpZGF0aW9uRXJyb3JzIG9uIHZhbGlkYXRpb24gZmFpbHVyZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVRhZyh0YWdWYWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGlucHV0UGF0dGVybiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnB1dFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy50YWdQYXR0ZXJuICYmICF0aGlzLnRhZ1BhdHRlcm4udGVzdCh0YWdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaW5wdXRQYXR0ZXJuID0ge1xyXG4gICAgICAgICAgICAgICAgZ2l2ZW46IHRhZ1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgcGF0dGVybjogdGhpcy50YWdQYXR0ZXJuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnNbJ2lucHV0UGF0dGVybiddID0gaW5wdXRQYXR0ZXJuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0VmFsaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSB0YWcgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gdGFnVmFsdWUuIElmIGNyZWF0ZVRhZ0hhbmRsZXIgaXMgc3BlY2lmaWVkLCB1c2UgaXQ7IG90aGVyd2lzZSBpZiBkaXNwbGF5UHJvcGVydHkgaXMgc3BlY2lmaWVkLCBjcmVhdGUgYW4gb2JqZWN0IHdpdGggdGhlIHRhZ1ZhbHVlIGFzIHRoZSBzaW5nbGUgbmFtZWQgcHJvcGVydHk7IG90aGVyd2lzZSByZXR1cm4gdGhlIHRhZ1ZhbHVlIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVUYWcodGFnVmFsdWU6IHN0cmluZyk6IGFueSB7XHJcbiAgICAgICAgbGV0IHRhZyA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRlVGFnSGFuZGxlciAmJiB0eXBlb2YgdGhpcy5jcmVhdGVUYWdIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRhZyA9IHRoaXMuY3JlYXRlVGFnSGFuZGxlcih0YWdWYWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0YWcgPSB7fTtcclxuICAgICAgICAgICAgdGFnWzxzdHJpbmc+dGhpcy5kaXNwbGF5XSA9IHRhZ1ZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhZyA9IHRhZ1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdGFnIG9iamVjdCwgY2FsbGluZyB0aGUgdGFnQWRkaW5nIGFuZCB0YWdBZGRlZCBldmVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIHdhcyBhZGRlZCB0byB0aGUgdGFncyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhZGRUYWcodGFnOiBhbnkpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBuZXcgdGFnIGNhbiBiZSBkaXNwbGF5ZWRcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxheVZhbHVlID0gdGhpcy5nZXRUYWdEaXNwbGF5KHRhZyk7XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5VmFsdWUgJiYgdHlwZW9mIGRpc3BsYXlWYWx1ZSA9PT0gJ3N0cmluZycgJiYgZGlzcGxheVZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0FkZGluZ0V2ZW50ID0gbmV3IFRhZ0lucHV0RXZlbnQodGFnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnQWRkaW5nLmVtaXQodGFnQWRkaW5nRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YWdBZGRpbmdFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2godGFnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ0FkZGVkLmVtaXQobmV3IFRhZ0lucHV0RXZlbnQodGFnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHRhZ0luZGV4IGlzIGEgdmFsaWQgdGFnIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzVmFsaWRUYWdJbmRleCh0YWdJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRhZ0luZGV4ID49IDAgJiYgdGFnSW5kZXggPCB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBpbmRleCBpcyBhIHZhbGlkIHNlbGVjdGlvbiBpbmRleCAodGFncyBvciBpbnB1dCBmaWVsZCkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNWYWxpZFNlbGVjdEluZGV4KGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8PSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2hhcmFjdGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleSBldmVudCwgbWFpbmx5IGZvciBJRSBjb21wYXRpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldEtleUNoYXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcclxuICAgICAgICAgICAgY2FzZSBTUEFDRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnICc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudC5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MgY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgc3RyaW5nIHNwbGl0IGJ5IHRoZSB0YWdEZWxpbWl0ZXJzIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3BsaXRUYWdJbnB1dChpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gICAgICAgIGxldCB0YWdWYWx1ZXMgPSBbaW5wdXRdO1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0RlbGltaXRlcnMgJiYgdHlwZW9mIHRoaXMudGFnRGVsaW1pdGVycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgZXNjYXBlZERlbGltaXRlcnMgPSB0aGlzLnRhZ0RlbGltaXRlcnMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlclJlZ2V4ID0gbmV3IFJlZ0V4cChgWyR7ZXNjYXBlZERlbGltaXRlcnN9XWAsICdnJyk7XHJcbiAgICAgICAgICAgIHRhZ1ZhbHVlcyA9IGlucHV0LnNwbGl0KGRlbGltaXRlclJlZ2V4KS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YWdWYWx1ZXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgQVBJIGF2YWlsYWJsZSB0byB0YWcgdGVtcGxhdGVzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUYWdBcGkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiB0YWcsIGFjY29yZGluZyB0byB0aGUgZGlzcGxheVByb3BlcnR5IHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBnZXRUYWdEaXNwbGF5OiAodGFnOiBhbnkpID0+IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIHBvc3NpYmxlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWdBdDogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgY2FuUmVtb3ZlVGFnQXQ6IChpbmRleDogbnVtYmVyKSA9PiBib29sZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIHVzZWQgdG8gcmV0dXJuIGN1c3RvbSBjbGFzcyBpbmZvcm1hdGlvbiwgZm9yIHVzZSBpbiBgbmdDbGFzc2AuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBUYWdDbGFzc0Z1bmN0aW9uID0gKHRhZzogYW55LCBpbmRleDogbnVtYmVyLCBzZWxlY3RlZDogYm9vbGVhbikgPT4gKHN0cmluZyB8IHN0cmluZ1tdIHwgU2V0PHN0cmluZz4pOyIsImltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XG5pbXBvcnQgeyBUYWdJbnB1dENvbXBvbmVudCB9IGZyb20gJy4vdGFnLWlucHV0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9jdXNJZk1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVGFnSW5wdXRDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1RhZ0lucHV0Q29tcG9uZW50XSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBUYWdJbnB1dE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluZmluaXRlU2Nyb2xsTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xuaW1wb3J0IHsgVGFnSW5wdXRNb2R1bGUgfSBmcm9tICcuLi90YWctaW5wdXQvaW5kZXgnO1xuaW1wb3J0IHsgVHlwZWFoZWFkTW9kdWxlIH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IFNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4vc2VsZWN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxNb2R1bGUsXG4gICAgICAgIFRhZ0lucHV0TW9kdWxlLFxuICAgICAgICBUeXBlYWhlYWRNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTZWxlY3RDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NlbGVjdENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0TW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnRDb250ZXh0IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jb21wb25lbnQtY29udGV4dC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1iYXNlLXNlYXJjaCcsXG4gICAgdGVtcGxhdGU6ICcnXG59KVxuZXhwb3J0IGNsYXNzIEJhc2VTZWFyY2hDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgdXgtc2VhcmNoLWJ1aWxkZXItc2VhcmNoLWNvbXBvbmVudC0ke3RoaXMuX2lkfWA7XG4gICAgfVxuXG4gICAgdHlwZTogc3RyaW5nO1xuICAgIGNvbmZpZzogYW55O1xuICAgIGNvbnRleHQ6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnRDb250ZXh0O1xuICAgIGZvY3VzOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLmNvbnRleHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlIYXNDaGFuZ2VkKCk7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgaGFzIGJlZW4gc2V0IHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gICAgfVxuXG4gICAgc2V0IHZhbGlkKHZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkID0gdmFsaWQ7XG4gICAgICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnNldFZhbGlkKHRoaXMuX2lkLCB2YWxpZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaWQ6IG51bWJlciA9IHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLmdlbmVyYXRlQ29tcG9uZW50SWQoKTtcbiAgICBwcml2YXRlIF92YWxpZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWFyY2hCdWlsZGVyU2VydmljZTogU2VhcmNoQnVpbGRlclNlcnZpY2UpIHsgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHdlIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlc1xuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFueSByZXF1aXJlZCB2YWxpZGF0aW9uIG9uIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIHZhbGlkYXRlKCk6IHZvaWQge1xuICAgICAgICAvLyBpZiBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGhhcyBiZWVuIHByb3ZpZGVkIHRoZW4gdXNlIGl0XG4gICAgICAgIHRoaXMudmFsaWQgPSB0aGlzLmNvbmZpZy52YWxpZGF0aW9uID8gdGhpcy5jb25maWcudmFsaWRhdGlvbih0aGlzLCB0aGlzLnZhbHVlKSA6IHRydWU7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgdmFsaWRhdGlvbj86ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2VhcmNoLWRhdGUtcmFuZ2UnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kYXRlLXJhbmdlLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50IHtcblxuICAgIHR5cGU6IHN0cmluZyA9ICdkYXRlLXJhbmdlJztcblxuICAgIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gICAgfVxuXG4gICAgZ2V0IGZyb20oKSB7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgZG9lcyBub3QgZXhpc3QgdGhlIHNldCBpdFxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBmcm9tIHZhbHVlIGlzIGEgZGF0ZSBvYmplY3RcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuZnJvbSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmZyb20gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLmZyb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZnJvbTtcbiAgICB9XG5cbiAgICBzZXQgZnJvbShmcm9tVmFsdWU6IGFueSkge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGZyb20gdmFsdWUgaXMgYSBkYXRlXG4gICAgICAgIGlmIChmcm9tVmFsdWUgaW5zdGFuY2VvZiBEYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gbmV3IERhdGUoZnJvbVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICAgIHZhbHVlLmZyb20gPSBmcm9tVmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvYmplY3Qgd2hpbGUgZW5zdXJpbmcgaW1tdXRhYmlsaXR5XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdG8oKSB7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgZG9lcyBub3QgZXhpc3QgdGhlIHNldCBpdFxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUudG8pIHtcbiAgICAgICAgICAgIHRoaXMudG8gPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRvIHZhbHVlIGlzIGEgZGF0ZSBvYmplY3RcbiAgICAgICAgaWYgKHRoaXMudmFsdWUudG8gaW5zdGFuY2VvZiBEYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS50byA9IG5ldyBEYXRlKHRoaXMudmFsdWUudG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG87XG4gICAgfVxuXG4gICAgc2V0IHRvKHRvVmFsdWU6IGFueSkge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRvIHZhbHVlIGlzIGEgZGF0ZVxuICAgICAgICBpZiAodG9WYWx1ZSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1ZhbHVlID0gbmV3IERhdGUodG9WYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGxhdGVzdCB2YWx1ZVxuICAgICAgICB2YWx1ZS50byA9IHRvVmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvYmplY3Qgd2hpbGUgZW5zdXJpbmcgaW1tdXRhYmlsaXR5XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZnJvbUxhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5mcm9tTGFiZWwgfHwgJ0Zyb20nO1xuICAgIH1cblxuICAgIGdldCB0b0xhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50b0xhYmVsIHx8ICdUbyc7XG4gICAgfVxuXG4gICAgZ2V0IGZyb21QbGFjZWhvbGRlcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZnJvbVBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIGdldCB0b1BsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50b1BsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbmZpZyB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudmFsaWRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBjb3BpZXMgb2YgdGhlIGRhdGVzIHNvIHdlIGNhbiBtb2RpZnkgdGltZSB2YWx1ZSAodG8gaWdub3JlIGl0KVxuICAgICAgICBjb25zdCBmcm9tID0gbmV3IERhdGUodGhpcy52YWx1ZS5mcm9tKTtcbiAgICAgICAgY29uc3QgdG8gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLnRvKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHRpbWUgdG8gdGhlIHNhbWUgc28gd2UgZG9udCBjb21wYXJlIGl0XG4gICAgICAgIGZyb20uc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHRvLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgICAgIC8vIHZhbGlkIGlmIHRoZSBmcm9tIGRhdGUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0byBkYXRlXG4gICAgICAgIHRoaXMudmFsaWQgPSBmcm9tIDw9IHRvO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hEYXRlUmFuZ2VDb25maWcge1xuICAgIGxhYmVsPzogc3RyaW5nO1xuICAgIGZyb21MYWJlbD86IHN0cmluZztcbiAgICB0b0xhYmVsPzogc3RyaW5nO1xuICAgIGZyb21QbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICB0b1BsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIHZhbGlkYXRpb246ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLWRhdGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vZGF0ZS5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoRGF0ZUNvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICdkYXRlJztcblxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgJ0VudGVyIGRhdGUnO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBieSBkZWZhdWx0IHNldCB0byB0aGUgY3VycmVudCBkYXRlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaERhdGVDb25maWcgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCwgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB9IGZyb20gJy4uL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL2luZGV4JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLXNlbGVjdCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9zZWxlY3QuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFNlbGVjdENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICdzZWxlY3QnO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxhYmVsO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm9wdGlvbnMgfHwgW107XG4gIH1cblxuICBnZXQgbXVsdGlwbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm11bHRpcGxlIHx8IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICdTZWxlY3QgaXRlbSc7XG4gIH1cblxuICBnZXQgZHJvcERpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kcm9wRGlyZWN0aW9uIHx8ICdkb3duJztcbiAgfVxuXG4gIGdldCBhbGxvd051bGwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmFsbG93TnVsbCB8fCBmYWxzZTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGlzYWJsZWQgfHwgZmFsc2U7XG4gIH1cblxuICBnZXQgbWF4SGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heEhlaWdodCB8fCAnMjUwcHgnO1xuICB9XG5cbiAgZ2V0IHBhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBhZ2VTaXplIHx8IDIwO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoU2VsZWN0Q29uZmlnIGV4dGVuZHMgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB7XG4gIG9wdGlvbnM/OiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xuICBtdWx0aXBsZT86IGJvb2xlYW47XG4gIGRyb3BEaXJlY3Rpb24/OiAndXAnIHwgJ2Rvd24nO1xuICBhbGxvd051bGw/OiBib29sZWFuO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIG1heEhlaWdodD86IHN0cmluZztcbiAgcGFnZVNpemU/OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLXRleHQnLFxuICB0ZW1wbGF0ZVVybDogJy4vdGV4dC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoVGV4dENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICd0ZXh0JztcblxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgJ0VudGVyIHRleHQnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoVGV4dENvbmZpZyBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgeyB9IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEFjY2Vzc2liaWxpdHlNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvaW5kZXgnO1xuaW1wb3J0IHsgRm9jdXNJZk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9jdXMtaWYvaW5kZXgnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJNb2R1bGUgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIubW9kdWxlJztcbmltcG9ydCB7IFBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9wb3BvdmVyL2luZGV4JztcbmltcG9ydCB7IFNlbGVjdE1vZHVsZSB9IGZyb20gJy4uL3NlbGVjdC9pbmRleCc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXItZ3JvdXAvc2VhcmNoLWJ1aWxkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLW91dGxldC9zZWFyY2gtYnVpbGRlci1vdXRsZXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9iYXNlLXNlYXJjaC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9kYXRlLXJhbmdlL2RhdGUtcmFuZ2UuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaERhdGVDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1jb21wb25lbnRzL2RhdGUvZGF0ZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoU2VsZWN0Q29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hUZXh0Q29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy90ZXh0L3RleHQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIEFjY2Vzc2liaWxpdHlNb2R1bGUsXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIERhdGVUaW1lUGlja2VyTW9kdWxlLFxuICAgIEZvY3VzSWZNb2R1bGUsXG4gICAgRm9ybXNNb2R1bGUsXG4gICAgUG9wb3Zlck1vZHVsZSxcbiAgICBTZWxlY3RNb2R1bGUsXG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBTZWFyY2hCdWlsZGVyQ29tcG9uZW50LFxuICAgIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCxcbiAgICBCYXNlU2VhcmNoQ29tcG9uZW50XG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW1xuICAgIFNlYXJjaEJ1aWxkZXJDb21wb25lbnQsXG4gICAgU2VhcmNoQnVpbGRlckdyb3VwQ29tcG9uZW50LFxuICAgIFNlYXJjaFRleHRDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZUNvbXBvbmVudCxcbiAgICBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQsXG4gICAgU2VhcmNoQnVpbGRlck91dGxldERpcmVjdGl2ZSxcbiAgICBTZWFyY2hTZWxlY3RDb21wb25lbnQsXG4gICAgQmFzZVNlYXJjaENvbXBvbmVudFxuICBdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICBTZWFyY2hUZXh0Q29tcG9uZW50LFxuICAgIFNlYXJjaERhdGVDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50LFxuICAgIFNlYXJjaFNlbGVjdENvbXBvbmVudFxuICBdLFxuICBwcm92aWRlcnM6IFtcbiAgICBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlXG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoQnVpbGRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZWxlY3Rpb24uc2VydmljZSc7XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHNlbGVjdGlvblNlcnZpY2U/OiBTZWxlY3Rpb25TZXJ2aWNlKSB7IH1cblxuICBzZXRTZWxlY3Rpb25TZXJ2aWNlKHNlbGVjdGlvblNlcnZpY2U6IFNlbGVjdGlvblNlcnZpY2UpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICB9XG5cbiAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHsgfVxuXG4gIGNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHsgfVxuXG4gIGtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQgeyB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgaXRlbSAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIHNlbGVjdCguLi5kYXRhOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3QoLi4uZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBpdGVtJ3Mgc2VsZWN0ZWQgc3RhdGUgLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICB0b2dnbGUoLi4uZGF0YTogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UudG9nZ2xlKC4uLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0IHRoZSBpdGVtIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgZGVzZWxlY3QoLi4uZGF0YTogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVzZWxlY3QoLi4uZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGFsbCBpdGVtcyAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIHNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdCguLi50aGlzLnNlbGVjdGlvblNlcnZpY2UuZGF0YXNldCk7XG4gIH1cblxuICAvKipcbiAgICogRGVzZWxlY3QgYWxsIGl0ZW1zIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgZGVzZWxlY3RBbGwoKTogdm9pZCB7XG5cbiAgICAvLyBjYWxsIGRlc2VsZWN0IG9uIGFsbCBpdGVtcyBpbiB0aGUgZGF0YXNldFxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdEFsbCgpO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHsgfVxufVxuIiwiaW1wb3J0IHsgRE9XTl9BUlJPVywgU1BBQ0UsIFVQX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5leHBvcnQgY2xhc3MgUm93U2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgcm93XG4gIHByaXZhdGUgX3NlbGVjdGlvbjogU2VsZWN0aW9uID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgb24gc2hpZnQgY2xpY2sgdGhlIGJyb3dzZXIgd2lsbCBoaWdobGlnaHRcbiAgICogdGV4dC4gVGhpcyBsb29rcyBiYWQgYW5kIHdlIGRvbid0IHdhbnQgdGhpcyB0byBvY2N1clxuICAgKi9cbiAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgcm93IGlzIGNsaWNrZWQgd2Ugd2FudCB0byBoYW5kbGUgc2VsZWN0aW9uXG4gICAqL1xuICBjbGljayhldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZFxuICAgIGNvbnN0IHsgY3RybEtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuXG4gICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIHdlIHdhbnQgdG8gcGVyZm9ybSBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGVTZWxlY3QoZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGNvbnRyb2wga2V5IGlzIHByZXNzZWQgd2Ugd2FudCB0byBwZXJmb3JtIGFuIGFkZGl0aXZlIHRvZ2dsZSBzZWxlY3Rpb25cbiAgICBpZiAoY3RybEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gYSBzaW5nbGUgc2VsZWN0aW9uIHdoZXJlIGFsbCBvdGhlciByb3dzIGFyZSBkZXNlbGVjdGVkXG4gICAgdGhpcy5zaW5nbGVTZWxlY3QoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVG8gc3VwcG9ydCBmdWxsIGtleWJvYXJkIGNvbnRyb2wgd2UgbmVlZCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmc6XG4gICAqIDEuIEFycm93IGtleXMgdG8gbmF2aWdhdGUgdXAgYW5kIGRvd25cbiAgICogMi4gU3BhY2ViYXIgdG8gdG9nZ2xlIHNlbGVjdGlvblxuICAgKiAzLiBTaGlmdCArIEFycm93IGtleXMgdG8gbXVsdGlwbGUgc2VsZWN0XG4gICAqIDQuIEN0cmwgKyBBcnJvdyBrZXlzIHRvIGFsbG93IHJldGFpbmVkIHNlbGVjdGlvbiBhbmQgbmF2aWdhdGlvblxuICAgKi9cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG5cbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZXZlbnQsIGRhdGEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnRvZ2dsZShkYXRhLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHN0YW5kYXJkIHRvZ2dsZSBmdW5jdGlvbiB0byBzdG9yZSBvciBjbGVhciB0aGVcbiAgICogbW9zdCByZWNlbnRseSBzZWxlY3RlZCBpdGVtXG4gICAqL1xuICB0b2dnbGUoZGF0YTogYW55LCBhY3RpdmF0ZTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgc3VwZXIudG9nZ2xlKGRhdGEpO1xuXG4gICAgLy8gc3RvcmUgb3IgY2xlYXIgdGhlIHNlbGVjdGlvblxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKGRhdGEpID8gdGhpcy5zZXRTZWxlY3Rpb25TdGFydChkYXRhKSA6IHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblxuICAgIC8vIGlmIHdlIHdhbnQgdG8ga2VlcCB0aGUgaXRlbSBhY3RpdmF0ZWQgdGhlbiBhY3RpdmF0ZVxuICAgIGlmIChhY3RpdmF0ZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb3RoZXIgc2VsZWN0ZWQgaXRlbXMgYW5kIHNlbGVjdCBvbmx5XG4gICAqIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgc2luZ2xlU2VsZWN0KGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGVzZWxlY3QgYWxsIG90aGVyIHJvd3MgaWYgbmVpdGhlciBtb2RpZmllciBrZXkgaXMgcHJlc3NlZFxuICAgIHRoaXMuZGVzZWxlY3RBbGwoKTtcblxuICAgIC8vIHNlbGVjdCB0aGUgY3VycmVudCByb3dcbiAgICB0aGlzLnNlbGVjdChkYXRhKTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IGl0ZW0gYXMgdGhlIHNlbGVjdGlvbiBzdGFydFxuICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG11bHRpcGxlIHNlbGVjdGlvbjpcbiAgICogMS4gSWYgbm8gc3RhcnQgaXRlbSBzZWxlY3RlZCAtIHNlbGVjdCBpdFxuICAgKiAyLiBJZiBhIHN0YXJ0IGl0ZW0gaGFzIGJlZW4gc2VsZWN0ZWQgLSBzZWxlY3QgYWxsIGluIGJldHdlZW5cbiAgICogMy4gSWYgYSBzdGFydCBhbmQgZW5kIGl0ZW0gaGF2ZSBiZWVuIHNlbGVjdGVkIGNsZWFyIHRoZSByYW5nZSBhbmQgdGhlbiBzZWxlY3QgdGhlIG5ldyByYW5nZVxuICAgKi9cbiAgcHJvdGVjdGVkIG11bHRpcGxlU2VsZWN0KGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gaWYgbm8gc2VsZWN0aW9uIGN1cnJlbnRseSBleGlzdHMgdGhlbiBwZXJmb3JtIGluaXRpYWwgc2VsZWN0aW9uXG4gICAgaWYgKCF0aGlzLl9zZWxlY3Rpb24uc3RhcnQpIHtcblxuICAgICAgLy8gc2VsZWN0IHRoZSByb3dcbiAgICAgIHRoaXMuc2VsZWN0KGRhdGEpO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLnNldFNlbGVjdGlvblN0YXJ0KGRhdGEpO1xuICAgIH1cblxuICAgIC8vIGlmIGEgbXVsdGlwbGUgc2VsZWN0aW9uIGFscmVhZHkgdG9vayBwbGFjZSAtIGNsZWFyIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uLnN0YXJ0ICYmIHRoaXMuX3NlbGVjdGlvbi5lbmQpIHtcbiAgICAgIHRoaXMuZGVzZWxlY3QoLi4udGhpcy5nZXRTZWxlY3RlZEl0ZW1zKCkpO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbmV3IHNlbGVjdGlvbiBlbmQgcG9pbnRcbiAgICB0aGlzLnNldFNlbGVjdGlvbkVuZChkYXRhKTtcblxuICAgIC8vIHNlbGVjdCBhbGwgdGhlIGl0ZW1zIGluIHRoZSByYW5nZVxuICAgIHRoaXMuc2VsZWN0KC4uLnRoaXMuZ2V0U2VsZWN0ZWRJdGVtcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiBzdGFydCBwb2ludC4gSWYgdGhlcmUgd2FzIHByZXZpb3VzbHkgYVxuICAgKiBzZWxlY3Rpb24gZW5kIHBvaW50IHRoZW4gY2xlYXIgaXQgYXMgdGhpcyBpcyBhIG5ldyBzZWxlY3Rpb25cbiAgICovXG4gIHByaXZhdGUgc2V0U2VsZWN0aW9uU3RhcnQoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fc2VsZWN0aW9uLnN0YXJ0ID0gZGF0YTtcbiAgICB0aGlzLl9zZWxlY3Rpb24uZW5kID0gbnVsbDtcblxuICAgIC8vIGFjdGl2YXRlIHRoZSBpdGVtXG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIGVuZCBwb2ludFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRTZWxlY3Rpb25FbmQoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fc2VsZWN0aW9uLmVuZCA9IGRhdGE7XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBib3RoIHN0YXJ0IGFuZCBlbmQgc2VsZWN0aW9uIHBvaW50c1xuICAgKi9cbiAgcHJvdGVjdGVkIGNsZWFyU2VsZWN0aW9uKGRlYWN0aXZhdGU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG5cbiAgICAvLyByZXNldCB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgIHRoaXMuX3NlbGVjdGlvbiA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtXG4gICAgaWYgKGRlYWN0aXZhdGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBhbGwgdGhlIGl0ZW1zIGFmZmVjdGVkIGJ5IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICogTm90ZSB0aGF0IHRoZSBlbmQgcG9pbnQgbWF5IGJlIGFib3ZlIHRoZSBzdGFydCBwb2ludCBzb1xuICAgKiB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAqL1xuICBwcml2YXRlIGdldFNlbGVjdGVkSXRlbXMoKTogYW55W10ge1xuXG4gICAgLy8gZ2V0IHRoZSBsYXRlc3QgZGF0YXNldFxuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlO1xuXG4gICAgLy8gZ2V0IHRoZSBpbmRleGVzIG9mIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50XG4gICAgY29uc3Qgc3RhcnRJZHggPSBkYXRhc2V0LmluZGV4T2YodGhpcy5fc2VsZWN0aW9uLnN0YXJ0KTtcbiAgICBjb25zdCBlbmRJZHggPSBkYXRhc2V0LmluZGV4T2YodGhpcy5fc2VsZWN0aW9uLmVuZCk7XG5cbiAgICAvLyBnZXQgdGhlIHJlZ2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBpcyBzZWxlY3RlZCAtIG5vdGUgdGhlIGVuZElkeCBtYXkgYmUgYmVmb3JlIHRoZSBzdGFydElkeCBzbyBhY2NvdW50IGZvciB0aGlzXG4gICAgcmV0dXJuIGRhdGFzZXQuc2xpY2UoTWF0aC5taW4oc3RhcnRJZHgsIGVuZElkeCksIE1hdGgubWF4KHN0YXJ0SWR4LCBlbmRJZHgpICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIHNpYmxpbmcgaXRlbSB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICovXG4gIHByaXZhdGUgbmF2aWdhdGUoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcbiAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblxuICAgIC8vIGlmIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQgdGhlbiBkZXNlbGVjdCBhbGwgYW5kIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICBpZiAoIWN0cmxLZXkgJiYgIXNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmRlc2VsZWN0QWxsKCk7XG4gICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgc2libGluZyAtIGlmIHRoZSB1cCBhcnJvdyBpcyBwcmVzc2VkIHRoZW4gbmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHNpYmxpbmdcbiAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyhldmVudC53aGljaCA9PT0gVVBfQVJST1cpO1xuXG4gICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIHRoZW4gd2UgYWxzbyB3YW50IHRvIHRvZ2dsZSB0aGUgc3RhdGUgaWYgdGhlIGl0ZW1cbiAgICBpZiAoc2hpZnRLZXkgJiYgc2libGluZykge1xuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbiBzdGFydCB0aGVuIHNlbGVjdCB0aGUgY3VycmVudCByb3dcbiAgICAgIGlmICghdGhpcy5fc2VsZWN0aW9uLnN0YXJ0KSB7XG4gICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3QoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3Qoc2libGluZyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0aW9uIHtcbiAgc3RhcnQ6IGFueTtcbiAgZW5kOiBhbnk7XG59XG4iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBTUEFDRSwgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xyXG5pbXBvcnQgeyBSb3dTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vcm93LXNlbGVjdGlvbi5zdHJhdGVneSc7XHJcblxyXG5leHBvcnQgY2xhc3MgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBSb3dTZWxlY3Rpb25TdHJhdGVneSB7XHJcbiAgICBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XHJcbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUN1cnNvcktleShldmVudCwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgU1BBQ0U6XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnRvZ2dsZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgc2libGluZyBpdGVtIHdoZW4gYXJyb3cga2V5cyBhcmUgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUN1cnNvcktleShldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcclxuICAgICAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcclxuXHJcbiAgICAgICAgLy8gaWYgbm8gbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZCB0aGVuIGRlc2VsZWN0IGFsbCBhbmQgY2xlYXIgdGhlIHNlbGVjdGlvblxyXG4gICAgICAgIGlmICghY3RybEtleSAmJiAhc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcoZXZlbnQud2hpY2ggPT09IFVQX0FSUk9XKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmdldFNpYmxpbmcoZXZlbnQud2hpY2ggPT09IFVQX0FSUk9XKTtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZVNlbGVjdChzaWJsaW5nID8gc2libGluZyA6IGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBTUEFDRSwgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3NlbGVjdGlvbi5zdHJhdGVneSc7XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVTZWxlY3Rpb25TdHJhdGVneSBleHRlbmRzIFNlbGVjdGlvblN0cmF0ZWd5IHtcblxuICAvKipcbiAgICogV2hlbiB0aGUgaXRlbSBpcyBjbGlja2VkIHNpbXBseSB0b2dnbGUgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgc3RhdGVcbiAgICovXG4gIGNsaWNrKF9ldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy50b2dnbGUoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGJhc2ljIGtleWJvYXJkIHN1cHBvcnQgZm9yIG5hdmlnYXRpbmdcbiAgICogYW5kIHNlbGVjdGluZy9kZXNlbGVjdGluZyBpdGVtc1xuICAgKi9cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG5cbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKHRydWUpO1xuXG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKGZhbHNlKTtcblxuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgc3RhbmRhcmQgdG9nZ2xlIGZ1bmN0aW9uIHRvIGFsd2F5cyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgKi9cbiAgdG9nZ2xlKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHN1cGVyLnRvZ2dsZShkYXRhKTtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LWFsdC1zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgUm93U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LXNlbGVjdGlvbi5zdHJhdGVneSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvc2ltcGxlLXNlbGVjdGlvbi5zdHJhdGVneSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBzZXQgZGF0YXNldChkYXRhc2V0OiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICB0aGlzLl9kYXRhc2V0ID0gZGF0YXNldDtcbiAgICBpZiAodGhpcy5fZGF0YXNldC5pbmRleE9mKHRoaXMuX2FjdGl2ZSkgPT09IC0xKSB7XG4gICAgICB0aGlzLnNldEZpcnN0SXRlbUZvY3VzYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBkYXRhc2V0KCk6IFJlYWRvbmx5QXJyYXk8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFzZXQ7XG4gIH1cblxuICBzdHJhdGVneTogU2VsZWN0aW9uU3RyYXRlZ3kgPSBuZXcgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gIGlzRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG4gIGlzQ2xpY2tFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgaXNLZXlib2FyZEVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGZvY3VzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcbiAgYWN0aXZlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcbiAgc2VsZWN0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55W10+KFtdKTtcblxuICBwcml2YXRlIF9hY3RpdmU6IGFueTtcbiAgcHJpdmF0ZSBfZGF0YXNldDogUmVhZG9ubHlBcnJheTxhbnk+ID0gW107XG4gIHByaXZhdGUgX3NlbGVjdGlvbiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfc3RyYXRlZ3lUb0Rlc3Ryb3k6IFNlbGVjdGlvblN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneTtcblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kpIHtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIGl0ZW0gaXMgbm90IGN1cnJlbnRseSBzZWxlY3RlZCB0aGVuIGFkZCBpdFxuICAgKiB0byB0aGUgbGlzdCBvZiBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG5cbiAgICAvLyBhZGQgZWFjaCBzZWxlY3Rpb24gdG8gdGhlIHNldFxuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5fc2VsZWN0aW9uLmFkZChzZWxlY3Rpb24pKTtcblxuICAgIC8vIHByb3BhZ2F0ZSB0aGUgY2hhbmdlc1xuICAgIHRoaXMuc2VsZWN0aW9uSGFzTXV0YXRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIGRlc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG4gICAgLy8gcmVtb3ZlIGVhY2ggaXRlbSBmcm9tIHRoZSBzZXRcbiAgICBzZWxlY3Rpb25zLmZvckVhY2goc2VsZWN0aW9uID0+IHRoaXMuX3NlbGVjdGlvbi5kZWxldGUoc2VsZWN0aW9uKSk7XG5cbiAgICAvLyBwcm9wYWdhdGUgdGhlIGNoYW5nZXNcbiAgICB0aGlzLnNlbGVjdGlvbkhhc011dGF0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIC8vIHJlbW92ZSBhbGwgaXRlbXMgaW4gdGhlIGFycmF5XG4gICAgdGhpcy5kZXNlbGVjdCguLi50aGlzLl9kYXRhc2V0KTtcblxuICAgIC8vIGNsZWFyIHRoZSBzZXQgaW4gY2FzZSBhbnkgaXRlbXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGJ1dCBhcmUgc3RpbGwgc2VsZWN0ZWRcbiAgICB0aGlzLl9zZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIGFueSBzcGVjaWZpZWQgaXRlbXNcbiAgICovXG4gIHRvZ2dsZSguLi5zZWxlY3Rpb25zOiBhbnlbXSk6IHZvaWQge1xuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5pc1NlbGVjdGVkKHNlbGVjdGlvbikgPyB0aGlzLmRlc2VsZWN0KHNlbGVjdGlvbikgOiB0aGlzLnNlbGVjdChzZWxlY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKi9cbiAgaXNTZWxlY3RlZChkYXRhOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmhhcyhkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JzZXJ2YWJsZSBzcGVjaWZpY2FsbHkgZm9yIG5vdGlmeWluZyB0aGUgc3Vic2NyaWJlclxuICAgKiBvbmx5IHdoZW4gdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiBhIHNwZWNpZmljIG9iamVjdCBoYXMgY2hhbmdlZFxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uU3RhdGUoZGF0YTogYW55KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uJC5waXBlKG1hcCgoKSA9PiB0aGlzLmlzU2VsZWN0ZWQoZGF0YSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgaG93IHNlbGVjdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAgICogVGhpcyBhbGxvd3MgdXMgdG8gdXNlIGFuIHN0cmF0ZWd5IHBhdHRlcm4gdG8gaGFuZGxlIHRoZSB2YXJpb3VzIGtleWJvYXJkXG4gICAqIGFuZCBtb3VzZSBpbnRlcmFjdGlvbnMgd2hpbGUga2VlcGluZyBlYWNoIG1vZGUgc2VwYXJhdGVkIGFuZFxuICAgKiBlYXNpbHkgZXh0ZW5zaWJsZSBpZiB3ZSB3YW50IHRvIGFkZCBtb3JlIG1vZGVzIGluIGZ1dHVyZSFcbiAgICovXG4gIHNldFN0cmF0ZWd5KG1vZGU6IFNlbGVjdGlvbk1vZGUgfCBTZWxlY3Rpb25TdHJhdGVneSk6IHZvaWQge1xuXG4gICAgaWYgKHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95KSB7XG4gICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHN0cmF0ZWd5IGlmIGl0IHdhcyBjcmVhdGVkIGludGVybmFsbHlcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobW9kZSBpbnN0YW5jZW9mIFNlbGVjdGlvblN0cmF0ZWd5KSB7XG5cbiAgICAgIC8vIEN1c3RvbSBzdHJhdGVneSAtIHBhc3MgaW4gdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgIHRoaXMuc3RyYXRlZ3kgPSBtb2RlO1xuICAgICAgdGhpcy5zdHJhdGVneS5zZXRTZWxlY3Rpb25TZXJ2aWNlKHRoaXMpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc3dpdGNoIChtb2RlLnRvTG93ZXJDYXNlKCkudHJpbSgpKSB7XG5cbiAgICAgICAgY2FzZSAnc2ltcGxlJzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgUm93U2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93LWFsdCc6XG4gICAgICAgICAgdGhpcy5zdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbmV3IFJvd0FsdFNlbGVjdGlvblN0cmF0ZWd5KHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2VsZWN0aW9uIG1vZGUgJyR7bW9kZX0nIGRvZXMgbm90IGV4aXN0LiBWYWxpZCBtb2RlcyBhcmUgJ3NpbXBsZScsICdyb3cnLCBvciAncm93LWFsdCcuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgKi9cbiAgYWN0aXZhdGUoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlID0gZGF0YTtcbiAgICB0aGlzLmFjdGl2ZSQubmV4dCh0aGlzLl9hY3RpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZlIGFsbCBpdGVtc1xuICAgKi9cbiAgZGVhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICAgIHRoaXMuYWN0aXZlJC5uZXh0KHRoaXMuX2FjdGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG9yIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGN1cnJlbnQgYWN0aXZlIGl0ZW0uXG4gICAqIEBwYXJhbSBwcmV2aW91cyBJZiB0cnVlLCB0aGUgcHJldmlvdXMgc2libGluZyB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0U2libGluZyhwcmV2aW91czogYm9vbGVhbiA9IGZhbHNlKTogYW55IHtcblxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBpdGVtXG4gICAgY29uc3QgaWR4ID0gdGhpcy5kYXRhc2V0LmluZGV4T2YodGhpcy5fYWN0aXZlKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmRhdGFzZXRbcHJldmlvdXMgPyBpZHggLSAxIDogaWR4ICsgMV07XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBzaWJsaW5nIG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtLlxuICAgKiBJZiBwcmV2aW91cyBpcyBzZXQgdG8gdHJ1ZSB0aGUgcHJldmlvdXMgc2libGluZyB3aWxsIGJlIGFjdGl2YXRlZFxuICAgKiByYXRoZXIgdGhhbiB0aGUgbmV4dCBzaWJsaW5nLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyByZXR1cm4gdGhlXG4gICAqIGRhdGEgb2YgdGhlIG5ld2x5IGFjdGl2YXRlZCBzaWJsaW5nXG4gICAqL1xuICBhY3RpdmF0ZVNpYmxpbmcocHJldmlvdXM6IGJvb2xlYW4gPSBmYWxzZSk6IGFueSB7XG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFNpYmxpbmcocHJldmlvdXMpO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhlIHRhcmdldCBleGlzdHNcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLmFjdGl2YXRlKHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHNldERpc2FibGVkKGRpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgLy8gc3RvcmUgdGhlIGN1cnJlbnQgZGlzYWJsZWQgc3RhdGVcbiAgICB0aGlzLmlzRW5hYmxlZCA9ICFkaXNhYmxlZDtcblxuICAgIC8vIGNsZWFyIGFueSBzdGF0ZWZ1bCBkYXRhXG4gICAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgICB0aGlzLmFjdGl2ZSQubmV4dCh0aGlzLl9hY3RpdmUpO1xuICAgIHRoaXMuX3NlbGVjdGlvbi5jbGVhcigpO1xuXG4gICAgLy8gZW1pdCB0aGUgc2VsZWN0aW9uIGNoYW5nZSBpbmZvcm1hdGlvblxuICAgIHRoaXMuc2VsZWN0aW9uSGFzTXV0YXRlZCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZWxlY3Rpb25IYXNNdXRhdGVkKCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uJC5uZXh0KEFycmF5LmZyb20odGhpcy5fc2VsZWN0aW9uKSk7XG4gIH1cblxuICBwcml2YXRlIHNldEZpcnN0SXRlbUZvY3VzYWJsZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZGF0YXNldC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmZvY3VzJC5uZXh0KHRoaXMuX2RhdGFzZXRbMF0pO1xuICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fZGF0YXNldFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2VsZWN0aW9uTW9kZSA9ICdzaW1wbGUnIHwgJ3JvdycgfCAncm93LWFsdCc7IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zZWxlY3QtbGlzdC1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VsZWN0LWxpc3QtaXRlbS5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICByb2xlOiAnbGlzdGl0ZW0nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3RMaXN0SXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQEhvc3RCaW5kaW5nKCd0YWJpbmRleCcpIHRhYmluZGV4OiBudW1iZXIgPSAtMTtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3Muc2VsZWN0ZWQnKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXNlbGVjdGVkJylcbiAgICBzZXQgc2VsZWN0ZWQoaXNTZWxlY3RlZDogYm9vbGVhbikge1xuICAgICAgICBpc1NlbGVjdGVkID8gdGhpcy5fc2VsZWN0aW9uLnNlbGVjdCh0aGlzLmRhdGEpIDogdGhpcy5fc2VsZWN0aW9uLmRlc2VsZWN0KHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmlzU2VsZWN0ZWQodGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VsZWN0aW9uOiBTZWxlY3Rpb25TZXJ2aWNlLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG5cbiAgICAgICAgX3NlbGVjdGlvbi5hY3RpdmUkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcihkYXRhID0+IGRhdGEgPT09IHRoaXMuZGF0YSkpLnN1YnNjcmliZShhY3RpdmUgPT4ge1xuICAgICAgICAgICAgX3NlbGVjdGlvbi5mb2N1cyQubmV4dChhY3RpdmUpO1xuICAgICAgICAgICAgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1ha2UgdGhpcyBpdGVtIHRhYmJhYmxlIG9yIG5vdCBiYXNlZCBvbiB0aGUgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgIF9zZWxlY3Rpb24uZm9jdXMkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZvY3VzZWQgPT4gdGhpcy50YWJpbmRleCA9IGZvY3VzZWQgPT09IHRoaXMuZGF0YSA/IDAgOiAtMSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50J10pXG4gICAgb25Nb3VzZURvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLnN0cmF0ZWd5Lm1vdXNlZG93bihldmVudCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgb25DbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc3RyYXRlZ3kuY2xpY2soZXZlbnQsIHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zdHJhdGVneS5rZXlkb3duKGV2ZW50LCB0aGlzLmRhdGEpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBFTlRFUiwgU1BBQ0UsIFVQX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5leHBvcnQgY2xhc3MgTXVsdGlwbGVTZWxlY3RMaXN0U3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgICBwcml2YXRlIF9sYXN0U2VsZWN0aW9uOiBhbnk7XG5cbiAgICAvKiogUHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGhpZ2hsaWdodGluZyB0ZXh0IG9uIHNoaWZ0IGNsaWNrICovXG4gICAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFjdGl2YXRlIHRoZSBjbGlja2VkIGl0ZW1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB3ZSB3YW50IHRvIHBlcmZvcm0gYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZVNlbGVjdChkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBwZXJmb3JtIGEgc2luZ2xlIHRvZ2dsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0KGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTZWxlY3Rpb24gPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC53aGljaCkge1xuXG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyh0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChkYXRhLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIERPV05fQVJST1c6IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChkYXRhLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIFNQQUNFOlxuICAgICAgICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNTZWxlY3RlZChkYXRhKSA/IGRhdGEgOiBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXVsdGlwbGVTZWxlY3QoZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gc3RhcnQgaXRlbSBzZWxlY3RlZFxuICAgICAgICBpZiAoIXRoaXMuX2xhc3RTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RTZWxlY3Rpb24gPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYWxyZWFkeSBpcyBhIHN0YXJ0IGl0ZW0gdGhlbiBmaW5kIHRoZSBpdGVtcyBpbiB0aGUgcmFuZ2VcbiAgICAgICAgdGhpcy5zZWxlY3QoLi4udGhpcy5nZXRTZWxlY3RlZEl0ZW1zKHRoaXMuX2xhc3RTZWxlY3Rpb24sIGRhdGEpKTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgc2VsZWN0aW9uIGVuZCBwb2ludFxuICAgICAgICB0aGlzLl9sYXN0U2VsZWN0aW9uID0gZGF0YTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFNlbGVjdGVkSXRlbXMoc3RhcnQ6IGFueSwgZW5kOiBhbnkpOiBhbnlbXSB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBsYXRlc3QgZGF0YXNldFxuICAgICAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXMuc2VsZWN0aW9uU2VydmljZTtcblxuICAgICAgICAvLyBnZXQgdGhlIGluZGV4ZXMgb2YgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRcbiAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBkYXRhc2V0LmluZGV4T2Yoc3RhcnQpO1xuICAgICAgICBjb25zdCBlbmRJZHggPSBkYXRhc2V0LmluZGV4T2YoZW5kKTtcblxuICAgICAgICAvLyBnZXQgdGhlIHJlZ2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBpcyBzZWxlY3RlZCAtIG5vdGUgdGhlIGVuZElkeCBtYXkgYmUgYmVmb3JlIHRoZSBzdGFydElkeCBzbyBhY2NvdW50IGZvciB0aGlzXG4gICAgICAgIHJldHVybiBkYXRhc2V0LnNsaWNlKE1hdGgubWluKHN0YXJ0SWR4LCBlbmRJZHgpLCBNYXRoLm1heChzdGFydElkeCwgZW5kSWR4KSArIDEpO1xuICAgIH1cblxufSIsImltcG9ydCB7IERPV05fQVJST1csIEVOVEVSLCBTUEFDRSwgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NlbGVjdGlvbi5zdHJhdGVneSc7XG5cbmV4cG9ydCBjbGFzcyBTaW5nbGVTZWxlY3RMaXN0U3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgICBjbGljayhfZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIGRlc2VsZWN0IGFsbCBvdGhlciBpdGVtc1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWN0aXZhdGUgdGhlIGNsaWNrZWQgaXRlbVxuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG5cbiAgICAgICAgLy8gdG9nZ2xlIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgaXRlbVxuICAgICAgICB0aGlzLnRvZ2dsZShkYXRhKTtcbiAgICB9XG5cbiAgICBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG5cbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzoge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGljayhudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTXVsdGlwbGVTZWxlY3RMaXN0U3RyYXRlZ3kgfSBmcm9tICcuL211bHRpcGxlLXNlbGVjdC1saXN0LnN0cmF0ZWd5JztcbmltcG9ydCB7IFNlbGVjdExpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9zZWxlY3QtbGlzdC1pdGVtL3NlbGVjdC1saXN0LWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IFNpbmdsZVNlbGVjdExpc3RTdHJhdGVneSB9IGZyb20gJy4vc2luZ2xlLXNlbGVjdC1saXN0LnN0cmF0ZWd5JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zZWxlY3QtbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlbGVjdC1saXN0LmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtTZWxlY3Rpb25TZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgIHJvbGU6ICdsaXN0J1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0TGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBzZXQgbXVsdGlwbGUobXVsdGlwbGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLnN0cmF0ZWd5LmRlc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zZXRTdHJhdGVneShtdWx0aXBsZSA/IG5ldyBNdWx0aXBsZVNlbGVjdExpc3RTdHJhdGVneSgpIDogbmV3IFNpbmdsZVNlbGVjdExpc3RTdHJhdGVneSgpKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzZWxlY3RlZDogYW55W10gPSBbXTtcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihTZWxlY3RMaXN0SXRlbUNvbXBvbmVudCkgaXRlbXM6IFF1ZXJ5TGlzdDxTZWxlY3RMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlbGVjdGlvbjogU2VsZWN0aW9uU2VydmljZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHNlbGVjdGlvbiBzdHJhdGVneSB0byBzaW5nbGUgYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc2V0U3RyYXRlZ3kobmV3IFNpbmdsZVNlbGVjdExpc3RTdHJhdGVneSgpKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBzZWxlY3Rpb24gY2hhbmdlcyB3aGVuIHRoZXkgb2NjdXJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fc2VsZWN0aW9uLnNlbGVjdGlvbiQuc3Vic2NyaWJlKHNlbGVjdGlvbiA9PiB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHN1cHBseSB0aGUgaW5pdGlhbCBpdGVtIHNldFxuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uZGF0YXNldCA9IHRoaXMuaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5kYXRhKTtcblxuICAgICAgICAvLyBpZiB0aGUgaXRlbSBzZXQgY2hhbmdlcyB1cGRhdGUgdGhlIGxpc3RcbiAgICAgICAgdGhpcy5pdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zZWxlY3Rpb24uZGF0YXNldCA9IHRoaXMuaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5kYXRhKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0TGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL3NlbGVjdC1saXN0LWl0ZW0vc2VsZWN0LWxpc3QtaXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0TGlzdENvbXBvbmVudCB9IGZyb20gJy4vc2VsZWN0LWxpc3QuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU2VsZWN0TGlzdENvbXBvbmVudCxcbiAgICAgICAgU2VsZWN0TGlzdEl0ZW1Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU2VsZWN0TGlzdENvbXBvbmVudCxcbiAgICAgICAgU2VsZWN0TGlzdEl0ZW1Db21wb25lbnRcbiAgICBdLFxufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3RMaXN0TW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNpZGVQYW5lbFNlcnZpY2UgfSBmcm9tICcuL3NpZGUtcGFuZWwuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2lkZVBhbmVsQ2xvc2VdJ1xufSlcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxDbG9zZURpcmVjdGl2ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZXJ2aWNlOiBTaWRlUGFuZWxTZXJ2aWNlKSB7IH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBjbGlja0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9jdXNJZk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9jdXMtaWYvZm9jdXMtaWYubW9kdWxlJztcbmltcG9ydCB7IFNpZGVQYW5lbENsb3NlRGlyZWN0aXZlIH0gZnJvbSAnLi9zaWRlLXBhbmVsLWNsb3NlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTaWRlUGFuZWxDb21wb25lbnQgfSBmcm9tICcuL3NpZGUtcGFuZWwuY29tcG9uZW50JztcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBTaWRlUGFuZWxDb21wb25lbnQsXG4gICAgU2lkZVBhbmVsQ2xvc2VEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IEVYUE9SVFMsXG4gICAgZGVjbGFyYXRpb25zOiBFWFBPUlRTXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbE1vZHVsZSB7IH0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgQ29sb3JJZGVudGlmaWVyIH0gZnJvbSAnLi4vLi4vaW5kZXgnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXNwYXJrJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BhcmsuY29tcG9uZW50Lmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFNwYXJrQ29tcG9uZW50IHtcblxuICAgIHZhbHVlczogbnVtYmVyW10gPSBbXTtcblxuICAgIEBJbnB1dCgpIGJhckhlaWdodDogbnVtYmVyID0gMTA7XG4gICAgQElucHV0KCkgaW5saW5lTGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b3BMZWZ0TGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b3BSaWdodExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYm90dG9tTGVmdExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYm90dG9tUmlnaHRMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHRvb2x0aXA6IHN0cmluZztcblxuICAgIHByaXZhdGUgX3RyYWNrQ29sb3I6IHN0cmluZztcbiAgICBwcml2YXRlIF90aGVtZTogQ29sb3JJZGVudGlmaWVyID0gJ3ByaW1hcnknOyAgICBcbiAgICBwcml2YXRlIF9iYXJDb2xvcjogc3RyaW5nIHwgc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBASW5wdXQoKSBcbiAgICBzZXQgdGhlbWUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl90aGVtZSA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlQ29sb3JOYW1lKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgdGhlbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIFxuICAgIHNldCB0cmFja0NvbG9yKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tDb2xvciA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgdHJhY2tDb2xvcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tDb2xvcjtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBcbiAgICBzZXQgYmFyQ29sb3IodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXJDb2xvciA9IHZhbHVlLm1hcChjb2xvciA9PiB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZShjb2xvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYmFyQ29sb3IgPSBbdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUodmFsdWUpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBiYXJDb2xvcigpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXJDb2xvcjtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyIHwgbnVtYmVyW10pIHtcblxuICAgICAgICAvLyBlbnN1cmUgJ3ZhbHVlJyBpcyBhbiBhcnJheSBhdCB0aGlzIHBvaW50XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuXG4gICAgICAgIC8vIGdldCB0aGUgdG90YWwgdmFsdWUgb2YgYWxsIGxpbmVzXG4gICAgICAgIGNvbnN0IHRvdGFsID0gTWF0aC5tYXgodmFsdWVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgY3VycmVudCwgMCksIDEwMCk7XG5cbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgcGVyY2VudGFnZXMgZm9yIGVhY2ggc3BhcmsgbGluZVxuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+ICh2YWwgLyB0b3RhbCkgKiAxMDApO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlKSB7IH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgU3BhcmtDb21wb25lbnQgfSBmcm9tICcuL3NwYXJrLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2VNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIENvbG9yU2VydmljZU1vZHVsZSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1NwYXJrQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTcGFya0NvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU3BhcmtNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi9yZXNpemFibGUtdGFibGUtY29sdW1uLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZXNpemFibGVUYWJsZVNlcnZpY2Uge1xuXG4gIC8qKiBJbmRpY2F0ZSB3aGVuIHRoZSBjb2x1bW5zIGFyZSByZWFkeSAqL1xuICBpc0luaXRpYWxpc2VkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG5cbiAgLyoqIERldGVybWluZSBpZiB3ZSBhcmUgY3VycmVudGx5IHJlc2l6aW5nICovXG4gIGlzUmVzaXppbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogU3RvcmUgdGhlIHBlcmNlbnRhZ2Ugd2lkdGhzIG9mIGVhY2ggY29sdW1uICovXG4gIGNvbHVtbnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiA9IFtdO1xuXG4gIC8qKiBTdG9yZSB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgdGFibGUgKi9cbiAgdGFibGVXaWR0aDogbnVtYmVyID0gMDtcblxuICAvKiogU3RvcmUgdGhlIFF1ZXJ5TGlzdCBvZiBjb2x1bW5zICovXG4gIHByaXZhdGUgX2NvbHVtbnM6IFF1ZXJ5TGlzdDxSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudD47XG5cbiAgLyoqIFN0b3JlIHRoZSBzaXplIG9mIGVhY2ggY29sdW1uICovXG4gIHNldENvbHVtbnMoY29sdW1uczogUXVlcnlMaXN0PFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50Pik6IHZvaWQge1xuXG4gICAgLy8gc3RvcmUgdGhlIGN1cnJlbnQgY29sdW1uc1xuICAgIHRoaXMuX2NvbHVtbnMgPSBjb2x1bW5zO1xuXG4gICAgLy8gc3RvcmUgdGhlIHNpemVzXG4gICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucy5tYXAoY29sdW1uID0+IChjb2x1bW4uZ2V0TmF0dXJhbFdpZHRoKCkgLyB0aGlzLnRhYmxlV2lkdGgpICogMTAwKTtcblxuICAgIC8vIGluZGljYXRlIHdlIGFyZSBub3cgaW5pdGlhbGlzZWRcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpc2VkLnZhbHVlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5pc0luaXRpYWxpc2VkLm5leHQodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFVwZGF0ZSB0aGUgcmVzaXppbmcgc3RhdGUgKi9cbiAgc2V0UmVzaXppbmcoaXNSZXNpemluZzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuaXNSZXNpemluZyA9IGlzUmVzaXppbmc7XG4gIH1cblxuICAvKiogR2V0IHRoZSB3aWR0aCBvZiBhIGNvbHVtbiBpbiBhIHNwZWNpZmljIHVuaXQgKi9cbiAgZ2V0Q29sdW1uV2lkdGgoaW5kZXg6IG51bWJlciwgdW5pdDogQ29sdW1uVW5pdCwgY29sdW1uczogUmVhZG9ubHlBcnJheTxudW1iZXI+ID0gdGhpcy5jb2x1bW5zKTogbnVtYmVyIHtcblxuICAgIHN3aXRjaCAodW5pdCkge1xuXG4gICAgICBjYXNlIENvbHVtblVuaXQuUGVyY2VudGFnZTpcbiAgICAgICAgcmV0dXJuIGNvbHVtbnNbaW5kZXhdO1xuXG4gICAgICBjYXNlIENvbHVtblVuaXQuUGl4ZWw6XG4gICAgICAgIHJldHVybiAodGhpcy50YWJsZVdpZHRoIC8gMTAwKSAqIGNvbHVtbnNbaW5kZXhdO1xuICAgIH1cblxuICB9XG5cbiAgLyoqIEFsbG93IHNldHRpbmcgdGhlIGNvbHVtbiBzaXplIGluIGFueSB1bml0ICovXG4gIHNldENvbHVtbldpZHRoKGluZGV4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIHVuaXQ6IENvbHVtblVuaXQsIGNvbHVtbnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiA9IHRoaXMuY29sdW1ucyk6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiB7XG5cbiAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgc28gd2Uga2VlcCB0aGUgaW5zdGFuY2UgYXJyYXkgaW1tdXRhYmxlXG4gICAgY29uc3Qgc2l6ZXMgPSBbLi4uY29sdW1uc107XG5cbiAgICBzd2l0Y2ggKHVuaXQpIHtcblxuICAgICAgY2FzZSBDb2x1bW5Vbml0LlBlcmNlbnRhZ2U6XG4gICAgICAgIHNpemVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2x1bW5Vbml0LlBpeGVsOlxuICAgICAgICBzaXplc1tpbmRleF0gPSAodmFsdWUgLyB0aGlzLnRhYmxlV2lkdGgpICogMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGluc3RhbmNlIHZhcmlhYmxlXG4gICAgcmV0dXJuIHNpemVzO1xuICB9XG5cbiAgLyoqIFJlc2l6ZSBhIGNvbHVtbiBieSBhIHNwZWNpZmljIHBpeGVsIGFtb3VudCAqL1xuICByZXNpemVDb2x1bW4oaW5kZXg6IG51bWJlciwgZGVsdGE6IG51bWJlcik6IHZvaWQge1xuXG4gICAgLy8gZ2V0IHRoZSBzaWJsaW5nIGNvbHVtbiB0aGF0IHdpbGwgYWxzbyBiZSByZXNpemVkXG4gICAgY29uc3Qgc2libGluZyA9IHRoaXMuZ2V0U2libGluZ0NvbHVtbihpbmRleCk7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBzaWJsaW5nIHRoYXQgY2FuIGJlIHJlc2l6ZWQgdGhlbiBzdG9wIGhlcmVcbiAgICBpZiAoIXNpYmxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgZm9yIHRoZSBzaXplc1xuICAgIGxldCBjb2x1bW5zID0gWy4uLnRoaXMuY29sdW1uc10gYXMgbnVtYmVyW107XG5cbiAgICAvLyByZXNpemUgdGhlIGNvbHVtbiB0byB0aGUgZGVzaXJlZCBzaXplXG4gICAgY29sdW1ucyA9IHRoaXMuc2V0Q29sdW1uV2lkdGgoaW5kZXgsIE1hdGgucm91bmQodGhpcy5nZXRDb2x1bW5XaWR0aChpbmRleCwgQ29sdW1uVW5pdC5QaXhlbCkgKyBkZWx0YSksIENvbHVtblVuaXQuUGl4ZWwsIGNvbHVtbnMpIGFzIG51bWJlcltdO1xuICAgIGNvbHVtbnMgPSB0aGlzLnNldENvbHVtbldpZHRoKHNpYmxpbmcsIE1hdGgucm91bmQodGhpcy5nZXRDb2x1bW5XaWR0aChzaWJsaW5nLCBDb2x1bW5Vbml0LlBpeGVsKSAtIGRlbHRhKSwgQ29sdW1uVW5pdC5QaXhlbCwgY29sdW1ucykgYXMgbnVtYmVyW107XG5cbiAgICAvLyBpZiB0aGUgbW92ZSBpcyBub3QgcG9zc2libGUgdGhlbiBzdG9wIGhlcmVcbiAgICBpZiAoIXRoaXMuaXNXaWR0aFZhbGlkKGluZGV4LCB0aGlzLmdldENvbHVtbldpZHRoKGluZGV4LCBDb2x1bW5Vbml0LlBpeGVsLCBjb2x1bW5zKSkgfHwgIXRoaXMuaXNXaWR0aFZhbGlkKHNpYmxpbmcsIHRoaXMuZ2V0Q29sdW1uV2lkdGgoc2libGluZywgQ29sdW1uVW5pdC5QaXhlbCwgY29sdW1ucykpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhhdCB3ZSBhZGQgdXAgdG8gZXhhY3RseSAxMDAlXG4gICAgY29uc3QgdG90YWwgPSBjb2x1bW5zLnJlZHVjZSgoY291bnQsIGNvbHVtbikgPT4gY29sdW1uICsgY291bnQsIDApO1xuXG4gICAgLy8gaWYgdGhlIGNvbHVtbnMgdG8gbm90IGFkZCB0byAxMDAgZW5zdXJlIHdlIG1ha2UgdGhlbVxuICAgIGlmICh0b3RhbCAhPT0gMTAwKSB7XG4gICAgICBjb2x1bW5zW2luZGV4XSArPSAoMTAwIC0gdG90YWwpO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBuZXcgc2l6ZXNcbiAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICB9XG5cbiAgLyoqIERldGVybWluZSB3aGV0aGVyIGEgY29sdW1uIGlzIGFib3ZlIG9yIGJlbG93IGl0cyBtaW5pbXVtIHdpZHRoICovXG4gIHByaXZhdGUgaXNXaWR0aFZhbGlkKGluZGV4OiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBib29sZWFuIHtcblxuICAgIC8vIGdldCB0aGUgY29sdW1uIGF0IGEgZ2l2ZW4gcG9zaXRpb25cbiAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkluc3RhbmNlKGluZGV4KTtcblxuICAgIC8vIGRldGVybWluZSBpZiB0aGUgc3BlY2lmaWVkIHdpZHRoIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWluIHdpZHRoXG4gICAgcmV0dXJuIGNvbHVtbiAmJiB3aWR0aCA+PSBjb2x1bW4ubWluV2lkdGg7XG4gIH1cblxuICAvKiogR2V0IHRoZSBuZXh0IGNvbHVtbiBpbiB0aGUgc2VxdWVuY2Ugb2YgY29sdW1ucyAqL1xuICBwcml2YXRlIGdldFNpYmxpbmdDb2x1bW4oaW5kZXg6IG51bWJlcik6IG51bWJlciB8IG51bGwge1xuXG4gICAgLy8gZmluZCB0aGUgZmlyc3Qgc2libGluZyB0aGF0IGlzIG5vdCBkaXNhYmxlZFxuICAgIGZvciAobGV0IGlkeCA9IGluZGV4ICsgMTsgaWR4IDwgdGhpcy5jb2x1bW5zLmxlbmd0aDsgaWR4KyspIHtcblxuICAgICAgY29uc3Qgc2libGluZyA9IHRoaXMuZ2V0Q29sdW1uSW5zdGFuY2UoaWR4KTtcblxuICAgICAgaWYgKCFzaWJsaW5nIHx8ICFzaWJsaW5nLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogR2V0IHRoZSBjb2x1bW4gY2xhc3MgZnJvbSBvdXIgcXVlcnkgbGlzdCAqL1xuICBwcml2YXRlIGdldENvbHVtbkluc3RhbmNlKGluZGV4OiBudW1iZXIpOiBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5zID8gdGhpcy5fY29sdW1ucy50b0FycmF5KClbaW5kZXhdIDogbnVsbDtcbiAgfVxuXG59XG5cbmV4cG9ydCBlbnVtIENvbHVtblVuaXQge1xuICBQaXhlbCxcbiAgUGVyY2VudGFnZVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbHVtblVuaXQsIFJlc2l6YWJsZVRhYmxlU2VydmljZSB9IGZyb20gJy4vcmVzaXphYmxlLXRhYmxlLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhSZXNpemFibGVUYWJsZUNlbGxdJ1xufSlcbmV4cG9ydCBjbGFzcyBSZXNpemFibGVUYWJsZUNlbGxEaXJlY3RpdmUge1xuXG5cbiAgLyoqIFRoZSBwZXJjZW50YWdlIHdpZHRoIG9mIHRoZSBjb2x1bW4gKi9cbiAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aCcpIGdldCB3aWR0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl90YWJsZS5pc1Jlc2l6aW5nID9cbiAgICAgIGAke3RoaXMuX3RhYmxlLmdldENvbHVtbldpZHRoKHRoaXMuZ2V0Q2VsbEluZGV4KCksIENvbHVtblVuaXQuUGl4ZWwpfXB4YCA6XG4gICAgICBgJHt0aGlzLl90YWJsZS5nZXRDb2x1bW5XaWR0aCh0aGlzLmdldENlbGxJbmRleCgpLCBDb2x1bW5Vbml0LlBlcmNlbnRhZ2UpfSVgO1xuICB9XG5cbiAgLyoqIFRoZSBmbGV4IHdpZHRoIG9mIHRoZSBjb2x1bW4gKi9cbiAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4JykgZ2V0IGZsZXgoKTogc3RyaW5nIHtcblxuICAgIC8vIGlmIHdlIGFyZSByZXNpemluZyB0aGVuIGFsd2F5cyByZXR1cm4gJ25vbmUnIHRvIGFsbG93IGZyZWUgbW92ZW1lbnRcbiAgICBpZiAodGhpcy5fdGFibGUuaXNSZXNpemluZykge1xuICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdGFibGUuaXNJbml0aWFsaXNlZC52YWx1ZSA/IGAwIDEgJHt0aGlzLl90YWJsZS5nZXRDb2x1bW5XaWR0aCh0aGlzLmdldENlbGxJbmRleCgpLCBDb2x1bW5Vbml0LlBlcmNlbnRhZ2UpfSVgIDogJyc7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF90YWJsZTogUmVzaXphYmxlVGFibGVTZXJ2aWNlKSB7IH1cblxuICAvKiogR2V0IHRoZSBjb2x1bW4gaW5kZXggdGhpcyBjZWxsIGlzIHBhcnQgb2YgKi9cbiAgcHJpdmF0ZSBnZXRDZWxsSW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MVGFibGVDZWxsRWxlbWVudCkuY2VsbEluZGV4O1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sdW1uVW5pdCwgUmVzaXphYmxlVGFibGVTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemFibGUtdGFibGUuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1t1eFJlc2l6YWJsZVRhYmxlQ29sdW1uXScsXG4gIHRlbXBsYXRlVXJsOiAnLi9yZXNpemFibGUtdGFibGUtY29sdW1uLmNvbXBvbmVudC5odG1sJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAndXgtcmVzaXphYmxlLXRhYmxlLWNvbHVtbidcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCB7XG5cbiAgLyoqIERpc2FibGVkIHRoZSBjb2x1bW4gcmVzaXppbmcgKi9cbiAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogVGhlIHBlcmNlbnRhZ2Ugd2lkdGggb2YgdGhlIGNvbHVtbiAqL1xuICBASG9zdEJpbmRpbmcoJ3N0eWxlLndpZHRoJykgZ2V0IHdpZHRoKCk6IHN0cmluZyB7XG5cbiAgICBpZiAoIXRoaXMuX3RhYmxlLmlzSW5pdGlhbGlzZWQudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdGFibGUuaXNSZXNpemluZyA/XG4gICAgICBgJHt0aGlzLl90YWJsZS5nZXRDb2x1bW5XaWR0aCh0aGlzLmdldENlbGxJbmRleCgpLCBDb2x1bW5Vbml0LlBpeGVsKX1weGAgOlxuICAgICAgYCR7dGhpcy5fdGFibGUuZ2V0Q29sdW1uV2lkdGgodGhpcy5nZXRDZWxsSW5kZXgoKSwgQ29sdW1uVW5pdC5QZXJjZW50YWdlKX0lYDtcbiAgfVxuXG4gIC8qKiBUaGUgZmxleCB3aWR0aCBvZiB0aGUgY29sdW1uICovXG4gIEBIb3N0QmluZGluZygnc3R5bGUuZmxleCcpIGdldCBmbGV4KCk6IHN0cmluZyB7XG5cbiAgICAvLyBpZiB3ZSBhcmUgcmVzaXppbmcgdGhlbiBhbHdheXMgcmV0dXJuICdub25lJyB0byBhbGxvdyBmcmVlIG1vdmVtZW50XG4gICAgaWYgKHRoaXMuX3RhYmxlLmlzUmVzaXppbmcpIHtcbiAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RhYmxlLmlzSW5pdGlhbGlzZWQudmFsdWUgPyBgMCAxICR7dGhpcy5fdGFibGUuZ2V0Q29sdW1uV2lkdGgodGhpcy5nZXRDZWxsSW5kZXgoKSwgQ29sdW1uVW5pdC5QZXJjZW50YWdlKX0lYCA6ICcnO1xuICB9XG5cbiAgLyoqIEdldCB0aGUgbWluaW11bSB3aWR0aCBhbGxvd2VkIGJ5IHRoZSBjb2x1bW4gKi9cbiAgZ2V0IG1pbldpZHRoKCk6IG51bWJlciB7XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSBjb2x1bW4gYmFzZWQgb24gaXRzIGNvbXB1dGVkIENTUyB2YWx1ZVxuICAgIGNvbnN0IGNvbXB1dGVkID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkubWluV2lkdGgpO1xuXG4gICAgLy8gaWYgaXQgaXMgZGlzYWJsZWQgdXNlIGl0cyBjdXJyZW50IHdpZHRoIC0gb3RoZXJ3aXNlIHVzZSBpdHMgQ1NTIG1pbiB3aWR0aCBpZiBpdCBpcyB2YWxpZFxuICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIDogaXNOYU4oY29tcHV0ZWQpID8gMCA6IGNvbXB1dGVkO1xuICB9XG5cbiAgLyoqIFN0b3JlIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW91c2Ugd2l0aGluIHRoZSBkcmFnIGhhbmxkZSAqL1xuICBwcml2YXRlIF9vZmZzZXQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF90YWJsZTogUmVzaXphYmxlVGFibGVTZXJ2aWNlKSB7IH1cblxuICAvKiogR2V0IHRoZSBuYXR1cmFsIHBpeGVsIHdpZHRoIG9mIHRoZSBjb2x1bW4gKi9cbiAgZ2V0TmF0dXJhbFdpZHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgfVxuXG4gIC8qKiBXaGVuIHRoZSBkcmFnZ2luZyBzdGFydHMgKi9cbiAgb25EcmFnU3RhcnQoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSB0aGUgbW91c2UgcG9zaXRpb24gd2l0aGluIHRoZSBoYW5kbGVcbiAgICB0aGlzLl9vZmZzZXQgPSBldmVudC5jbGllbnRYIC0gKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgfVxuXG4gIC8qKiBXaGVuIHRoZSBtb3VzZSBpcyBtb3ZlZCAqL1xuICBvbkRyYWdNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50LCBoYW5kbGU6IEhUTUxEaXZFbGVtZW50KTogdm9pZCB7XG5cbiAgICAvLyBnZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgICBjb25zdCBtb3VzZVggPSBldmVudC5wYWdlWCAtIHBhZ2VYT2Zmc2V0O1xuXG4gICAgLy8gcG9zaXRpb24gb2YgdGhlIGRyYWcgaGFuZGxlXG4gICAgY29uc3QgeyBsZWZ0IH0gPSBoYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgaG93IG11Y2ggdGhlIG1vdXNlIGhhcyBtb3ZlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcbiAgICBjb25zdCBkZWx0YSA9IG1vdXNlWCAtIChsZWZ0ICsgdGhpcy5fb2Zmc2V0KTtcblxuICAgIC8vIHBlcmZvcm0gcmVzaXppbmdcbiAgICB0aGlzLl90YWJsZS5yZXNpemVDb2x1bW4odGhpcy5nZXRDZWxsSW5kZXgoKSwgZGVsdGEpO1xuXG4gICAgdGhpcy5fdGFibGUuc2V0UmVzaXppbmcodHJ1ZSk7XG5cbiAgfVxuXG4gIC8qKiBXaGVuIHRoZSBkcmFnZ2luZyBlbmRzICovXG4gIG9uRHJhZ0VuZCgpOiB2b2lkIHtcbiAgICB0aGlzLl90YWJsZS5zZXRSZXNpemluZyhmYWxzZSk7XG4gIH1cblxuICBvbk1vdmVMZWZ0KCk6IHZvaWQge1xuICAgIHRoaXMuX3RhYmxlLnJlc2l6ZUNvbHVtbih0aGlzLmdldENlbGxJbmRleCgpLCAtMTApO1xuICB9XG5cbiAgb25Nb3ZlUmlnaHQoKTogdm9pZCB7XG4gICAgdGhpcy5fdGFibGUucmVzaXplQ29sdW1uKHRoaXMuZ2V0Q2VsbEluZGV4KCksIDEwKTtcbiAgfVxuXG4gIC8qKiBHZXQgdGhlIGNvbHVtbiBpbmRleCB0aGlzIGNlbGwgaXMgcGFydCBvZiAqL1xuICBwcml2YXRlIGdldENlbGxJbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50IGFzIEhUTUxUYWJsZUNlbGxFbGVtZW50KS5jZWxsSW5kZXg7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4vcmVzaXphYmxlLXRhYmxlLWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgUmVzaXphYmxlVGFibGVTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemFibGUtdGFibGUuc2VydmljZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhSZXNpemFibGVUYWJsZV0nLFxuICBwcm92aWRlcnM6IFtSZXNpemFibGVUYWJsZVNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICd1eC1yZXNpemFibGUtdGFibGUnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgUmVzaXphYmxlVGFibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKiBHZXQgYWxsIHRoZSBjb2x1bW4gaGVhZGVycyAqL1xuICBAQ29udGVudENoaWxkcmVuKFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pIGNvbHVtbnM6IFF1ZXJ5TGlzdDxSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudD47XG5cbiAgLyoqIFVuc3Vic2NyaWJlIGZyb20gdGhlIG9ic2VydmFibGVzICovXG4gIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfdGFibGU6IFJlc2l6YWJsZVRhYmxlU2VydmljZSwgcmVzaXplOiBSZXNpemVTZXJ2aWNlKSB7XG4gICAgLy8gd2F0Y2ggZm9yIHRoZSB0YWJsZSBiZWluZyByZXNpemVkXG4gICAgcmVzaXplLmFkZFJlc2l6ZUxpc3RlbmVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudClcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgLnN1YnNjcmliZShkaW1lbnNpb25zID0+IF90YWJsZS50YWJsZVdpZHRoID0gdGhpcy5nZXRTY3JvbGxXaWR0aCgpKTtcbiAgfVxuXG4gIC8qKiBPbmNlIHdlIGhhdmUgdGhlIGNvbHVtbnMgbWFrZSB0aGVtIHJlc2l6YWJsZSBhbmQgd2F0Y2ggZm9yIGNoYW5nZXMgdG8gY29sdW1ucyAqL1xuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG5cbiAgICAvLyBlbnN1cmUgd2UgaW5pdGlhbGx5IHNldCB0aGUgdGFibGUgd2lkdGhcbiAgICB0aGlzLl90YWJsZS50YWJsZVdpZHRoID0gdGhpcy5nZXRTY3JvbGxXaWR0aCgpO1xuXG4gICAgLy8gc2V0IHRoZSBjb2x1bW5zIC0gcHJldmVudCBleHByZXNzaW9uIGNoYW5nZWQgZXJyb3JcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5fdGFibGUuc2V0Q29sdW1ucyh0aGlzLmNvbHVtbnMpKTtcblxuICAgIC8vIHdhdGNoIGZvciBhbnkgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIGNvbHVtbnNcbiAgICB0aGlzLmNvbHVtbnMuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdGFibGUuc2V0Q29sdW1ucyh0aGlzLmNvbHVtbnMpKTtcbiAgfVxuXG4gIC8qKiBDbGVhbnVwIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogR2V0IHRoZSBzbWFsbGVzdCB0Ym9keSB3aWR0aCB0YWtpbmcgaW50byBhY2NvdW50IHNjcm9sbGJhcnMgKHV4Rml4ZWRIZWFkZXJUYWJsZSkgKi9cbiAgcHJpdmF0ZSBnZXRTY3JvbGxXaWR0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiBBcnJheS5mcm9tKCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTFRhYmxlRWxlbWVudCkudEJvZGllcylcbiAgICAgIC5yZWR1Y2UoKHdpZHRoLCB0Ym9keSkgPT4gTWF0aC5taW4od2lkdGgsIHRib2R5LnNjcm9sbFdpZHRoKSwgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MVGFibGVFbGVtZW50KS5vZmZzZXRXaWR0aCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEExMXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgUmVzaXphYmxlVGFibGVDZWxsRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJsZS1jb2x1bW4tcmVzaXplL3Jlc2l6YWJsZS10YWJsZS1jZWxsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4vdGFibGUtY29sdW1uLXJlc2l6ZS9yZXNpemFibGUtdGFibGUtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBSZXNpemFibGVUYWJsZURpcmVjdGl2ZSB9IGZyb20gJy4vdGFibGUtY29sdW1uLXJlc2l6ZS9yZXNpemFibGUtdGFibGUuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRHJhZ01vZHVsZSxcbiAgICAgICAgUmVzaXplTW9kdWxlLFxuICAgICAgICBBMTF5TW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmVzaXphYmxlVGFibGVEaXJlY3RpdmUsXG4gICAgICAgIFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50LFxuICAgICAgICBSZXNpemFibGVUYWJsZUNlbGxEaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVzaXphYmxlVGFibGVEaXJlY3RpdmUsXG4gICAgICAgIFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50LFxuICAgICAgICBSZXNpemFibGVUYWJsZUNlbGxEaXJlY3RpdmVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC10aW1lbGluZScsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGltZWxpbmUuY29tcG9uZW50Lmh0bWwnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUaW1lbGluZUNvbXBvbmVudCB7XHJcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5sZXQgdW5pcXVlSWQ6IG51bWJlciA9IDA7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtdGltZWxpbmUtZXZlbnQnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RpbWVsaW5lLWV2ZW50LmNvbXBvbmVudC5odG1sJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgVGltZWxpbmVFdmVudENvbXBvbmVudCB7XHJcblxyXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZyA9IGB1eC10aW1lbGluZS1ldmVudC0ke3VuaXF1ZUlkKyt9YDtcclxuICAgIEBJbnB1dCgpIGJhZGdlQ29sb3I6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGJhZGdlVGl0bGU6IHN0cmluZztcclxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IFRpbWVsaW5lQ29tcG9uZW50IH0gZnJvbSAnLi90aW1lbGluZS5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBUaW1lbGluZUV2ZW50Q29tcG9uZW50IH0gZnJvbSAnLi90aW1lbGluZS1ldmVudC90aW1lbGluZS1ldmVudC5jb21wb25lbnQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGVcclxuICAgIF0sXHJcbiAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgVGltZWxpbmVDb21wb25lbnQsXHJcbiAgICAgICAgVGltZWxpbmVFdmVudENvbXBvbmVudFxyXG4gICAgXSxcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIFRpbWVsaW5lQ29tcG9uZW50LFxyXG4gICAgICAgIFRpbWVsaW5lRXZlbnRDb21wb25lbnRcclxuICAgIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIFRpbWVsaW5lTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5jb25zdCBUT0dHTEVTV0lUQ0hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVG9nZ2xlU3dpdGNoQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxubGV0IHVuaXF1ZVRvZ2dsZVN3aXRjaElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10b2dnbGVzd2l0Y2gnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90b2dnbGVzd2l0Y2guY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1RPR0dMRVNXSVRDSF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfdG9nZ2xlU3dpdGNoSWQ6IHN0cmluZyA9IGB1eC10b2dnbGVzd2l0Y2gtJHsrK3VuaXF1ZVRvZ2dsZVN3aXRjaElkfWA7XG5cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nID0gdGhpcy5fdG9nZ2xlU3dpdGNoSWQ7XG4gICAgQElucHV0KCkgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBjbGlja2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmcgPSAnJztcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmcgPSBudWxsO1xuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB2YWx1ZSBvdXRwdXRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcblxuICAgICAgICAvLyBOb3RpZnkgbmdNb2RlbFxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZ2V0IGlucHV0SWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fdG9nZ2xlU3dpdGNoSWR9LWlucHV0YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gKCkgPT4geyB9O1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gISF2YWx1ZTtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IH0gZnJvbSAnLi90b2dnbGVzd2l0Y2guY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbIEZvcm1zTW9kdWxlIF0sXG4gICAgZXhwb3J0czogWyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFsgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IF1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VG9vbGJhclNlYXJjaEJ1dHRvbl0nXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmUge1xuXG4gICAgQE91dHB1dCgpXG4gICAgY2xpY2tlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIGNsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5jbGlja2VkLmVtaXQoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBPcHRpb25hbCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ01vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5jb25zdCBLRVlTID0ge1xuICAgIEVOVEVSOiAxMyxcbiAgICBFU0NBUEU6IDI3XG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRvb2xiYXJTZWFyY2hGaWVsZF0nXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSB7XG5cbiAgICBAT3V0cHV0KClcbiAgICBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIGdldCB0ZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIC8vIFVzZSBuZ01vZGVsIGlmIHNwZWNpZmllZCBvbiB0aGUgaG9zdDsgb3RoZXJ3aXNlIHJlYWQgdGhlIERPTVxuICAgICAgICBpZiAodGhpcy5fbmdNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25nTW9kZWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9uZ01vZGVsOiBOZ01vZGVsKSB7IH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBibHVyKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICAvLyBVc2UgbmdNb2RlbCBpZiBzcGVjaWZpZWQgb24gdGhlIGhvc3Q7IG90aGVyd2lzZSB1c2UgdGhlIERPTVxuICAgICAgICBpZiAodGhpcy5fbmdNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5fbmdNb2RlbC5yZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlTLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXQuZW1pdCh0aGlzLnRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlTLkVTQ0FQRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25FdmVudCwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2NvbG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWZpZWxkLmRpcmVjdGl2ZSc7XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10b29sYmFyLXNlYXJjaCcsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ2V4cGFuZGVkJywgW1xuICAgICAgICAgICAgc3RhdGUoXG4gICAgICAgICAgICAgICAgJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJ3t7aW5pdGlhbFdpZHRofX0nXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgaW5pdGlhbFdpZHRoOiAnMzBweCcgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzdGF0ZShcbiAgICAgICAgICAgICAgICAnZXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignY29sbGFwc2VkIDw9PiBleHBhbmRlZCcsIFthbmltYXRlKCcwLjNzIGVhc2Utb3V0JyldKVxuICAgICAgICBdKVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5leHBhbmRlZCcpXG4gICAgQElucHV0KClcbiAgICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgICB9XG5cbiAgICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWQgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBpbnB1dCB3aGVuIGV4cGFuZGVkXG4gICAgICAgICAgICB0aGlzLmZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0ZXh0IHdoZW4gY29udHJhY3RlZFxuICAgICAgICAgICAgdGhpcy5maWVsZC5jbGVhcigpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZm9jdXMgKHdvcmtzIGFyb3VuZCBhbiBJRSBpc3N1ZSB3aGVyZSB0aGUgY2FyZXQgcmVtYWlucyB2aXNpYmxlKVxuICAgICAgICAgICAgdGhpcy5maWVsZC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyA9ICdyaWdodCc7XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaW52ZXJzZScpXG4gICAgaW52ZXJzZSA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgYmFja2dyb3VuZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUodmFsdWUpIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpXG4gICAgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzZWFyY2ggPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIHByaXZhdGUgX2V4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASG9zdEJpbmRpbmcoJ0BleHBhbmRlZCcpXG4gICAgZ2V0IGV4cGFuZGVkQW5pbWF0aW9uKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5leHBhbmRlZCA/ICdleHBhbmRlZCcgOiAnY29sbGFwc2VkJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGluaXRpYWxXaWR0aDogdGhpcy5idXR0b24ud2lkdGggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5wb3NpdGlvbicpIHBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmJhY2tncm91bmQtY29sb3InKSBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgIEBDb250ZW50Q2hpbGQoVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlKSBmaWVsZDogVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlO1xuICAgIEBDb250ZW50Q2hpbGQoVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSkgYnV0dG9uOiBUb29sYmFyU2VhcmNoQnV0dG9uRGlyZWN0aXZlO1xuXG4gICAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHN1Ym1pdCBldmVudCBvbiB0aGUgaW5wdXQgZmllbGQsIHRyaWdnZXJpbmcgdGhlIHNlYXJjaCBldmVudFxuICAgICAgICB0aGlzLmZpZWxkLnN1Ym1pdC5zdWJzY3JpYmUoKHRleHQ6IHN0cmluZykgPT4gdGhpcy5zZWFyY2guZW1pdCh0ZXh0KSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNhbmNlbCBldmVudHMgY29taW5nIGZyb20gdGhlIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuZmllbGQuY2FuY2VsLnN1YnNjcmliZSgoKSA9PiB0aGlzLmV4cGFuZGVkID0gZmFsc2UpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgYnV0dG9uIGNsaWNrIGV2ZW50XG4gICAgICAgIHRoaXMuYnV0dG9uLmNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZGVkICYmIHRoaXMuZmllbGQudGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLmVtaXQodGhpcy5maWVsZC50ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgZWxlbWVudCB0byBhdm9pZCBjaGFuZ2luZyBsYXlvdXQgd2hlbiBzd2l0Y2hpbmcgdG8gcG9zaXRpb246IGFic29sdXRlXG4gICAgICAgIHRoaXMuY3JlYXRlUGxhY2Vob2xkZXIoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdAZXhwYW5kZWQuc3RhcnQnLCBbJyRldmVudCddKVxuICAgIGFuaW1hdGlvblN0YXJ0KGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ2V4cGFuZGVkJykge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignQGV4cGFuZGVkLmRvbmUnLCBbJyRldmVudCddKVxuICAgIGFuaW1hdGlvbkRvbmUoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAnY29sbGFwc2VkJykge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlUGxhY2Vob2xkZXIoKSB7XG4gICAgICAgIC8vIEdldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBpbnZpc2libGUgZGl2IHdpdGggdGhlIHNhbWUgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS53aWR0aCA9IHRoaXMuYnV0dG9uLndpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUuaGVpZ2h0ID0gc3R5bGVzLmhlaWdodDtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICAgIC8vIEFkZCBhcyBhIHNpYmxpbmdcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX3BsYWNlaG9sZGVyLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW5hYmxlUGxhY2Vob2xkZXIoZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gKGVuYWJsZWQgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hDb21wb25lbnQgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtZmllbGQuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtYnV0dG9uLmRpcmVjdGl2ZSc7XHJcblxyXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXHJcbiAgICBUb29sYmFyU2VhcmNoQ29tcG9uZW50LFxyXG4gICAgVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlLFxyXG4gICAgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZVxyXG5dO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGVcclxuICAgIF0sXHJcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXHJcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OUyxcclxuICAgIHByb3ZpZGVyczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUb29sYmFyU2VhcmNoTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IFxuICAgIHNlbGVjdG9yOiAnW3V4VmlydHVhbFNjcm9sbExvYWRpbmddJyBcbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VmlydHVhbFNjcm9sbExvYWRCdXR0b25dJyBcbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eFZpcnR1YWxTY3JvbGxDZWxsXScgXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIHtcblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCwgSW5wdXQsIEhvc3RMaXN0ZW5lciwgRWxlbWVudFJlZiwgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkLCBUZW1wbGF0ZVJlZiwgT25EZXN0cm95LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXZpcnR1YWwtc2Nyb2xsJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdmlydHVhbC1zY3JvbGwuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBjb2xsZWN0aW9uOiBPYnNlcnZhYmxlPGFueVtdPiA9IE9ic2VydmFibGUuY3JlYXRlKCk7XG4gICAgQElucHV0KCkgY2VsbEhlaWdodDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIGxvYWRPblNjcm9sbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBAT3V0cHV0KCkgbG9hZGluZzogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbENlbGxEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgbG9hZGluZ0luZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgbG9hZEJ1dHRvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgY2VsbHM6IEJlaGF2aW9yU3ViamVjdDxhbnlbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICBzY3JvbGxUb3A6IG51bWJlciA9IDA7XG4gICAgaXNMb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gICAgcGFnZU51bWJlcjogbnVtYmVyID0gMDtcbiAgICBkYXRhOiBhbnlbXSA9IFtdO1xuICAgIGxvYWRpbmdDb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfaGVpZ2h0OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGFueSBmdXR1cmUgY2hhbmdlcyB0byBzaXplXG4gICAgICAgIHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkuc3Vic2NyaWJlKGV2ZW50ID0+IHRoaXMuX2hlaWdodCA9IGV2ZW50LmhlaWdodCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNlbGxIZWlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmlydHVhbCBTY3JvbGwgQ29tcG9uZW50IHJlcXVpcmVzIFwiY2VsbEhlaWdodFwiIHByb3BlcnR5IHRvIGJlIGRlZmluZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5zZXR1cE9ic2VydmFibGUoKTtcblxuICAgICAgICAvLyBsb2FkIHRoZSBmaXJzdCBwYWdlIG9mIGRhdGFcbiAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHJlLXJlbmRlciBjZWxscyBub3cgdGhhdCB3ZSBjYW4gZGlzcGxheSBhbnkgbG9hZGluZyBpbmRpY2F0b3Igb3IgbG9hZGluZyBidXR0b25cbiAgICAgICAgdGhpcy5yZW5kZXJDZWxscygpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuY29sbGVjdGlvbiAmJiBjaGFuZ2VzLmNvbGxlY3Rpb24uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmNvbGxlY3Rpb24ucHJldmlvdXNWYWx1ZSAmJiAhY2hhbmdlcy5jb2xsZWN0aW9uLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cE9ic2VydmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXR1cE9ic2VydmFibGUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBjdXJyZW50IHN1YnNjcmlwdGlvbiwgdW5zdWJzY3JpYmVcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbiAmJiB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5jb2xsZWN0aW9uLnN1YnNjcmliZShjb2xsZWN0aW9uID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKC4uLmNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDZWxscygpO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdzY3JvbGwnKSByZW5kZXJDZWxscygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jZWxscy5uZXh0KHRoaXMuZ2V0VmlzaWJsZUNlbGxzKCkpO1xuXG4gICAgICAgIGlmICh0aGlzLmxvYWRPblNjcm9sbCAmJiAhdGhpcy5pc0xvYWRpbmcgJiYgIXRoaXMubG9hZGluZ0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdTY3JvbGwgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgKyB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbHMgdGFrZSB1cCBsZXNzIHRoYW4gdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IHRoZW4gbG9hZCB0aGUgbmV4dCBwYWdlXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nU2Nyb2xsIDw9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmlzaWJsZUNlbGxzKCk6IGFueVtdIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBlbGVtZW50IGhlaWdodFxuICAgICAgICBpZiAoIXRoaXMuX2hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gc29tZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gTWF0aC5mbG9vcihzY3JvbGxUb3AgLyB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICBjb25zdCBlbmRDZWxsID0gTWF0aC5jZWlsKHRoaXMuX2hlaWdodCAvIHRoaXMuY2VsbEhlaWdodCkgKyAxO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC0gKHNjcm9sbFRvcCAlIHRoaXMuY2VsbEhlaWdodCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGEgc3VibGlzdCBvZiBpdGVtcyB2aXNpYmxlIG9uIHRoZSBzY3JlZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydENlbGwsIHN0YXJ0Q2VsbCArIGVuZENlbGwpO1xuICAgIH1cblxuICAgIGdldFRvdGFsSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxIZWlnaHQgKiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGxvYWROZXh0UGFnZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvYWRpbmcubmV4dCh0aGlzLnBhZ2VOdW1iZXIpO1xuICAgICAgICB0aGlzLnBhZ2VOdW1iZXIrKztcbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcblxuICAgICAgICAvLyByZXNldCBhbGwgdmFsdWVzXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5sb2FkaW5nQ29tcGxldGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBzZXQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjdXJyZW50IGNlbGxzXG4gICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoKTtcblxuICAgICAgICAvLyByZWxvYWQgZmlyc3QgcGFnZVxuICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xuICAgIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsQ29tcG9uZW50IH0gZnJvbSAnLi92aXJ0dWFsLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlJztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFZpcnR1YWxTY3JvbGxDb21wb25lbnQsXG4gICAgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUsXG4gICAgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsXG4gICAgVmlydHVhbFNjcm9sbENlbGxEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJlc2l6ZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eEF1dG9Hcm93XSdcbn0pXG5leHBvcnQgY2xhc3MgQXV0b0dyb3dEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgLy8gZW5zdXJlIHRoaXMgaXMgYSB0ZXh0YXJlYSBvciBlbHNlIHRocm93IGVycm9yXG4gICAgaWYgKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGV4dGFyZWEnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V4QXV0b0dyb3cgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgb24gPHRleHRhcmVhPiBlbGVtZW50cy4nKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JylcbiAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgLy8gcGVyZm9ybSBzaXppbmdcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvd1knLCAnaGlkZGVuJyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgJ2F1dG8nKTtcblxuICAgIC8vIGdldCB0aGUgbmV3IHRvdGFsIGhlaWdodCBhbmQgZWxlbWVudCBoZWlnaHRcbiAgICBjb25zdCB7IHNjcm9sbEhlaWdodCB9ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IHsgbWF4SGVpZ2h0IH0gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hhdCB0aGUgbWF4aW11bSBhbGxvd2VkIGhlaWdodCBpc1xuICAgIGNvbnN0IG1heGltdW0gPSAhaXNOYU4ocGFyc2VGbG9hdChtYXhIZWlnaHQpKSA/IHBhcnNlRmxvYXQobWF4SGVpZ2h0KSA6IEluZmluaXR5O1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBtYXggaGVpZ2h0IHNwZWNpZmVkIHdlIHdhbnQgdG8gc2hvdyB0aGUgc2Nyb2xsYmFyc1xuICAgIGlmIChtYXhpbXVtIDwgc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvd1knLCAnYXV0bycpO1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgbWF4aW11bSArICdweCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCBzY3JvbGxIZWlnaHQgKyAncHgnKTtcbiAgICB9XG4gIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBBdXRvR3Jvd0RpcmVjdGl2ZSB9IGZyb20gJy4vYXV0by1ncm93LmRpcmVjdGl2ZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgZXhwb3J0czogW0F1dG9Hcm93RGlyZWN0aXZlXSxcclxuICAgIGRlY2xhcmF0aW9uczogW0F1dG9Hcm93RGlyZWN0aXZlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXV0b0dyb3dNb2R1bGUgeyB9XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhGaXhlZEhlYWRlclRhYmxlXSdcbn0pXG5leHBvcnQgY2xhc3MgRml4ZWRIZWFkZXJUYWJsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgdGFibGVIZWlnaHQ6IG51bWJlciB8IHN0cmluZztcbiAgQE91dHB1dCgpIHRhYmxlUGFnaW5nOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIHByaXZhdGUgX3RhYmxlSGVhZDogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgX3RhYmxlQm9keTogSFRNTEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikgeyB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBhZGQgY2xhc3MgdG8gdGhlIHRhYmxlXG4gICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndXgtZml4ZWQtaGVhZGVyLXRhYmxlJyk7XG5cbiAgICAvLyBsb2NhdGUgdGhlIGltcG9ydGFudCBlbGVtZW50c1xuICAgIHRoaXMuX3RhYmxlSGVhZCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpO1xuICAgIHRoaXMuX3RhYmxlQm9keSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpO1xuXG4gICAgLy8gYmluZCB0byBzY3JvbGwgZXZlbnRzIG9uIHRoZSB0YWJsZSBib2R5XG4gICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuX3RhYmxlQm9keSwgJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG5cbiAgICAvLyByZXNpemUgdGhlIHRhYmxlIGhlYWRlciB0byBhY2NvdW50IGZvciBzY3JvbGxiYXJcbiAgICB0aGlzLnNldExheW91dCgpO1xuXG4gICAgLy8gdHJpZ2dlciB0aGUgbG9hZGluZyBvZiB0aGUgZmlyc3QgcGFnZVxuICAgIHRoaXMudGFibGVQYWdpbmcuZW1pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFibGUgZWxlbWVudFxuICAgKiBQcmltYXJpbHkgdXNlZCBieSBjb2x1bW4gd2lkdGggZGlyZWN0aXZlXG4gICAqL1xuICBnZXRUYWJsZSgpOiBIVE1MVGFibGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzY3JvbGwgZXZlbnRzXG4gICAqL1xuICBwcml2YXRlIG9uU2Nyb2xsKCk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHdlIGFyZSBzY3JvbGxlZCB0byB0aGUgYm90dG9tIGFuZCBpZiBzbyBsb2FkIHRoZSBuZXh0IHBhZ2VcbiAgICBpZiAodGhpcy5fdGFibGVCb2R5LnNjcm9sbFRvcCA9PT0gKHRoaXMuX3RhYmxlQm9keS5zY3JvbGxIZWlnaHQgLSB0aGlzLl90YWJsZUJvZHkub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgdGhpcy50YWJsZVBhZ2luZy5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgdGFibGUgaGVhZGVyIHRvIGFjY291bnQgZm9yIHRoZSBzY3JvbGxiYXIuXG4gICAqIFRoaXMgaXMgaW1wb3J0YW50IHRvIGtlZXAgdGhlIGNvbHVtbnMgYWxpZ25lZFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRMYXlvdXQoKTogdm9pZCB7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhlIHNjcm9sbGJhclxuICAgIGNvbnN0IHNjcm9sbGJhciA9IHRoaXMuX3RhYmxlQm9keS5vZmZzZXRXaWR0aCAtIHRoaXMuX3RhYmxlQm9keS5jbGllbnRXaWR0aDtcblxuICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBoZWFkZXIgdG8gYWNjb3VudCBmb3IgdGhpc1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX3RhYmxlSGVhZCwgJ3BhZGRpbmctcmlnaHQnLCBzY3JvbGxiYXIgKyAncHgnKTtcblxuICAgIC8vIHNldCB0aGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIHRhYmxlIGJvZHlcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJsZUJvZHksICdoZWlnaHQnLCB0eXBlb2YgdGhpcy50YWJsZUhlaWdodCA9PT0gJ251bWJlcicgPyBgJHt0aGlzLnRhYmxlSGVpZ2h0fXB4YCA6IHRoaXMudGFibGVIZWlnaHQpO1xuICB9XG5cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZpeGVkSGVhZGVyVGFibGVEaXJlY3RpdmUgfSBmcm9tICcuL2ZpeGVkLWhlYWRlci10YWJsZS5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBGaXhlZEhlYWRlclRhYmxlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEZsb2F0TGFiZWxdJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd1eC1mbG9hdC1sYWJlbCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZsb2F0TGFiZWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgndXhGbG9hdExhYmVsJylcbiAgICBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcblxuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbW9kZTogJ2ZvY3VzJyB8ICdpbnB1dCcgPSAnZm9jdXMnO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy51eC1mbG9hdC1sYWJlbC1yYWlzZWQnKVxuICAgIHJhaXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBwcml2YXRlIF9mb2N1c2VkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfZXZlbnRIYW5kbGVzOiBhbnlbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVzLnB1c2goXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4odGhpcy5pbnB1dCwgJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuaW5wdXQsICdibHVyJywgdGhpcy5pbnB1dEJsdXIuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4odGhpcy5pbnB1dCwgJ2lucHV0JywgdGhpcy5pbnB1dENoYW5nZS5iaW5kKHRoaXMpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENoZWNrIGluaXRpYWwgaW5wdXQgdmFsdWVcbiAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYGZvcmAgYXR0cmlidXRlIGlzIHNldFxuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvcicpICYmIHRoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZm9yJywgdGhpcy5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgICAgIGlmICghKHRoaXMubW9kZSA9PT0gJ2ZvY3VzJyAmJiB0aGlzLl9mb2N1c2VkKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyBVbnN1YnNjcmliZSBldmVudCBoYW5kbGVzXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcy5mb3JFYWNoKChldmVudEhhbmRsZSkgPT4gZXZlbnRIYW5kbGUoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNUZXh0KCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmlucHV0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnB1dEZvY3VzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmFpc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW5wdXRCbHVyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJhaXNlZCA9IHRoaXMuaGFzVGV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnB1dENoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGbG9hdExhYmVsRGlyZWN0aXZlIH0gZnJvbSAnLi9mbG9hdC1sYWJlbC5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IFtGbG9hdExhYmVsRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGbG9hdExhYmVsRGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdExhYmVsTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGVscENlbnRlclNlcnZpY2Uge1xuXG4gICAgaXRlbXM6IEJlaGF2aW9yU3ViamVjdDxIZWxwQ2VudGVySXRlbVtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SGVscENlbnRlckl0ZW1bXT4oW10pO1xuXG4gICAgcmVnaXN0ZXJJdGVtKGl0ZW06IEhlbHBDZW50ZXJJdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGl0ZW1zXG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBpdGVtIHRvIHRoZSBsaXN0XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMuaXRlbXMubmV4dChpdGVtcyk7XG4gICAgfVxuXG4gICAgdW5yZWdpc3Rlckl0ZW0oaXRlbTogSGVscENlbnRlckl0ZW0pOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgaXRlbXNcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBiZWluZyB1bnJlZ2lzdGVyZWRcbiAgICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRtID0+IGl0bSAhPT0gaXRlbSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMuaXRlbXMubmV4dChpdGVtcyk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlbHBDZW50ZXJJdGVtIHtcbiAgICBpY29uPzogc3RyaW5nO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgc2VsZWN0PzogKCkgPT4gdm9pZDtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGVscENlbnRlclNlcnZpY2UsIEhlbHBDZW50ZXJJdGVtIH0gZnJvbSAnLi9oZWxwLWNlbnRlci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW3V4SGVscENlbnRlckl0ZW1dJyB9KVxuZXhwb3J0IGNsYXNzIEhlbHBDZW50ZXJJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgdXhIZWxwQ2VudGVySXRlbTogSGVscENlbnRlckl0ZW07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9oZWxwQ2VudGVyU2VydmljZTogSGVscENlbnRlclNlcnZpY2UpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGl0ZW0gaW4gdGhlIHNlcnZpY2VcbiAgICAgICAgdGhpcy5faGVscENlbnRlclNlcnZpY2UucmVnaXN0ZXJJdGVtKHRoaXMudXhIZWxwQ2VudGVySXRlbSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGlzIGl0ZW0gd2hlbiBpdCBpcyBkZXN0cm95ZWRcbiAgICAgICAgdGhpcy5faGVscENlbnRlclNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy51eEhlbHBDZW50ZXJJdGVtKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhlbHBDZW50ZXJJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9oZWxwLWNlbnRlci1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIZWxwQ2VudGVyU2VydmljZSB9IGZyb20gJy4vaGVscC1jZW50ZXIuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogW0hlbHBDZW50ZXJJdGVtRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtIZWxwQ2VudGVySXRlbURpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbSGVscENlbnRlclNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBIZWxwQ2VudGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmUgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi1jb250YWluZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24uZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uU2VydmljZSB7XG5cbiAgICBhY3RpdmU6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgcHJpdmF0ZSBfY29udGFpbmVyOiBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZTtcbiAgICBwcml2YXRlIF9mb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfaG92ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2FjdGlvbnM6IEhvdmVyQWN0aW9uRGlyZWN0aXZlW10gPSBbXTtcblxuICAgIHJlZ2lzdGVyKGFjdGlvbjogSG92ZXJBY3Rpb25EaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlcihhY3Rpb246IEhvdmVyQWN0aW9uRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLmZpbHRlcihhY3RuID0+IGFjdG4gIT09IGFjdGlvbik7XG4gICAgfVxuXG4gICAgc2V0Q29udGFpbmVyKGNvbnRhaW5lcjogSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cblxuICAgIHNldEZvY3VzU3RhdGUoZm9jdXM6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBzZXRIb3ZlclN0YXRlKGhvdmVyOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSBob3ZlcjtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBjb250YWluZXIgaGFzIGZvY3VzIHRoZW4gZm9jdXMgdGhlIGZpcnN0IGhvdmVyIGFjdGlvblxuICAgICAgICBpZiAodGhpcy5jb250YWluZXJIYXNGb2N1cygpKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWN0aW9uQXRJbmRleCgwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGEgaG92ZXIgYWN0aW9uIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBuZXh0IGFjdGlvblxuICAgICAgICBpZiAodGhpcy5hY3Rpb25IYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldEZvY3VzZWRBY3Rpb25JbmRleCgpICsgMTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNBY3Rpb25BdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIGEgaG92ZXIgYWN0aW9uIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBwcmV2aW91cyBhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uSGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRGb2N1c2VkQWN0aW9uSW5kZXgoKSAtIDE7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0FjdGlvbkF0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZpc2liaWxpdHkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWN0aXZlLm5leHQodGhpcy5fZm9jdXNlZCB8fCB0aGlzLl9ob3ZlcmVkIHx8IHRoaXMuYWN0aW9uSGFzRm9jdXMoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb2N1c0FjdGlvbkF0SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zW2luZGV4XS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGb2N1c2VkQWN0aW9uSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuZmluZEluZGV4KGFjdGlvbiA9PiBhY3Rpb24gPT09IHRoaXMuZ2V0Rm9jdXNlZEFjdGlvbigpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbnRhaW5lckhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFjdGlvbkhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldEZvY3VzZWRBY3Rpb24oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZvY3VzZWRBY3Rpb24oKTogSG92ZXJBY3Rpb25EaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5maW5kKGFjdGlvbiA9PiBhY3Rpb24uZm9jdXNlZCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBIb3ZlckFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhIb3ZlckFjdGlvbkNvbnRhaW5lcl0nLFxuICAgIHByb3ZpZGVyczogW0hvdmVyQWN0aW9uU2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1jb250YWluZXItYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAnW3RhYmluZGV4XSc6ICd0YWJpbmRleCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICAgIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBhY3RpdmUkOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9ob3ZlckFjdGlvblNlcnZpY2U6IEhvdmVyQWN0aW9uU2VydmljZSkge1xuICAgICAgICAvLyByZWdpc3RlciB0aGUgY29udGFpbmVyIGVsZW1lbnQgd2l0aCB0aGUgc2VydmljZVxuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Q29udGFpbmVyKHRoaXMpO1xuXG4gICAgICAgIC8vIGFwcGx5IGEgY2xhc3MgYmFzZWQgb24gdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgY29udGFpbmVyIGFuZCBpdCdzIGFjdGlvbnNcbiAgICAgICAgdGhpcy5hY3RpdmUkID0gdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLmFjdGl2ZS5zdWJzY3JpYmUoYWN0aXZlID0+IHRoaXMuYWN0aXZlID0gYWN0aXZlKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hY3RpdmUkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKSBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBvbkZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Rm9jdXNTdGF0ZSh0cnVlKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJykgb25CbHVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Rm9jdXNTdGF0ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpIG9uSG92ZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5zZXRIb3ZlclN0YXRlKHRydWUpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSBvbkxlYXZlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0SG92ZXJTdGF0ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3JpZ2h0JykgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLm5leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIE9uRGVzdHJveSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uU2VydmljZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEhvdmVyQWN0aW9uXScsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgICAgICdbY2xhc3MuaG92ZXItYWN0aW9uLWZvY3VzZWRdJzogJ2ZvY3VzZWQnLFxuICAgICAgICAnW3RhYmluZGV4XSc6ICd0YWJpbmRleCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAxO1xuICAgIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYWN0aXZlJDogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfaG92ZXJBY3Rpb25TZXJ2aWNlOiBIb3ZlckFjdGlvblNlcnZpY2UpIHtcblxuICAgICAgICAvLyByZWdpc3RlciB0aGUgYWN0aW9uXG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5yZWdpc3Rlcih0aGlzKTtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlcyB0byB0aGUgYWN0aXZlbmVzcyBvZiB0aGUgY29udGFpbmVyXG4gICAgICAgIHRoaXMuYWN0aXZlJCA9IHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5hY3RpdmUuc3Vic2NyaWJlKGFjdGl2ZSA9PiB0aGlzLmFjdGl2ZSA9IGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2ZSQudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBvbkZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2JsdXInKSBvbkJsdXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dsZWZ0JywgWyckZXZlbnQnXSkgcHJldmlvdXMoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7ICAgICAgICBcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3JpZ2h0JywgWyckZXZlbnQnXSkgbmV4dChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLm5leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24tY29udGFpbmVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZSc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBIb3ZlckFjdGlvbkRpcmVjdGl2ZSxcbiAgICBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgSG92ZXJBY3Rpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVtYmVkZGVkVmlld1JlZiwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TGF5b3V0U3dpdGNoZXJJdGVtXSdcbn0pXG5leHBvcnQgY2xhc3MgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgndXhMYXlvdXRTd2l0Y2hlckl0ZW0nKSBwcml2YXRlIF9jb25maWc6IExheW91dFN3aXRjaGVySXRlbTtcblxuICAgIHByaXZhdGUgX2VtYmVkZGVkVmlldzogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PiwgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikgeyB9XG5cbiAgICBnZXRMYXlvdXQoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZVJlZjtcbiAgICB9XG5cbiAgICBnZXRDb25maWcoKTogTGF5b3V0U3dpdGNoZXJJdGVtIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3ID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLl9lbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLnJlbW92ZShpbmRleCk7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlldyA9IG51bGw7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5b3V0U3dpdGNoZXJJdGVtIHtcbiAgICBncm91cD86IHN0cmluZztcbiAgICBtaW5XaWR0aD86IG51bWJlcjtcbiAgICBtYXhXaWR0aD86IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIFF1ZXJ5TGlzdCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgQWZ0ZXJDb250ZW50SW5pdCwgVmlld0NvbnRhaW5lclJlZiwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vcmVzaXplL2luZGV4JztcbmltcG9ydCB7IExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbGF5b3V0LXN3aXRjaGVyLWl0ZW0uZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhMYXlvdXRTd2l0Y2hlcl0nXG59KVxuZXhwb3J0IGNsYXNzIExheW91dFN3aXRjaGVyRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIEBJbnB1dCgpIGdyb3VwOiBzdHJpbmc7XG4gICAgQENvbnRlbnRDaGlsZHJlbihMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUpIHByaXZhdGUgX2xheW91dHM6IFF1ZXJ5TGlzdDxMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmU+O1xuICAgIFxuICAgIHByaXZhdGUgX3dpZHRoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfYWN0aXZlTGF5b3V0OiBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKSB7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIGNvbnRhaW5lciBzaXplXG4gICAgICAgIHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gZXZlbnQud2lkdGg7XG5cbiAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUxheW91dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGFjdGl2ZSBncm91cCBoYXMgY2hhbmdlZCB0aGVuIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgICAgIGlmIChjaGFuZ2VzLmdyb3VwLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5ncm91cC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QWN0aXZlTGF5b3V0KCk6IExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB8IG51bGwge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBjdXJyZW50bHkgbm8gbGF5b3V0cyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLl9sYXlvdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBmaW5kIGxheW91dHMgdGhhdCBtYXRjaCB0aGUgYWN0aXZlIGdyb3VwIGFuZCB0aGF0IG1lZXQgdGhlIGNvbnN0cmFpbnRzXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRzLmZpbHRlcihsYXlvdXQgPT4gdGhpcy5ncm91cCA9PT0gbGF5b3V0LmdldENvbmZpZygpLmdyb3VwKS5maW5kKGxheW91dCA9PiB7XG5cbiAgICAgICAgICAgIGxldCBtaW5XaWR0aCA9IGxheW91dC5nZXRDb25maWcoKS5taW5XaWR0aCB8fCAwO1xuICAgICAgICAgICAgbGV0IG1heFdpZHRoID0gbGF5b3V0LmdldENvbmZpZygpLm1heFdpZHRoIHx8IEluZmluaXR5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggPj0gbWluV2lkdGggJiYgdGhpcy5fd2lkdGggPCBtYXhXaWR0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlQWN0aXZlTGF5b3V0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgbGF5b3V0IHRoYXQgc2hvdWxkIGJlIHNob3duXG4gICAgICAgIGxldCBsYXlvdXQgPSB0aGlzLmdldEFjdGl2ZUxheW91dCgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgc2hvd2luZyB0aGUgbGF5b3V0XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVMYXlvdXQgPT09IGxheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGxheW91dFxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVMYXlvdXQuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG5ldyBhY3RpdmUgbGF5b3V0XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxheW91dCA9IGxheW91dDtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgbGF5b3V0IHRoZW4gYWN0aXZhdGVcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGF5b3V0LmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgY3VycmVudCBlbGVtZW50IHdpZHRoXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0IC0gbmVlZCBhIGRlbGF5IGFzIEFuZ3VsYXIgZG9lc24ndCBsaWtlIGNoYW5nZXMgbGlrZSB0aGlzIGluIHRoZXNlIGxpZmVjeWNsZSBob29rc1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVBY3RpdmVMYXlvdXQuYmluZCh0aGlzKSk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckRpcmVjdGl2ZSB9IGZyb20gJy4vbGF5b3V0LXN3aXRjaGVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi9yZXNpemUvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgTGF5b3V0U3dpdGNoZXJEaXJlY3RpdmUsXG4gICAgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgUmVzaXplTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgTGF5b3V0U3dpdGNoZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eE92ZXJmbG93T2JzZXJ2ZXJdLCBbdXhPdmVyZmxvd0hvcml6b250YWxPYnNlcnZlcl0sIFt1eE92ZXJmbG93VmVydGljYWxPYnNlcnZlcl0nLFxuICBleHBvcnRBczogJ3V4LW92ZXJmbG93LW9ic2VydmVyJ1xufSlcbmV4cG9ydCBjbGFzcyBPdmVyZmxvd0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAvKiogQWxsb3cgYSBvYnNlcnZhYmxlIHRvIGJlIHVzZWQgdG8gY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIEBJbnB1dCgpIHRyaWdnZXI6IE9ic2VydmFibGU8dm9pZD47XG5cbiAgLyoqIEFsbG93IG92ZXJmbG93IHRvIGJlIHdpdGhpbiBhIHJhbmdlIGJlZm9yZSBlbWl0dGluZyAqL1xuICBASW5wdXQoKSB0b2xlcmFuY2U6IG51bWJlciA9IDA7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSB0byB0aGUgb3ZlcmZsb3cgc3RhdGUgLSBob3Jpem9udGFsIG9yIHZlcnRpY2FsICovXG4gIEBPdXRwdXQoKSB1eE92ZXJmbG93T2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSB0byBvdmVyZmxvdyBvbiB0aGUgaG9yaXpvbnRhbCBheGlzICovXG4gIEBPdXRwdXQoKSB1eE92ZXJmbG93SG9yaXpvbnRhbE9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBFbWl0IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2UgdG8gb3ZlcmZsb3cgb24gdGhlIHZlcnRpY2FsIGF4aXMgKi9cbiAgQE91dHB1dCgpIHV4T3ZlcmZsb3dWZXJ0aWNhbE9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBTdG9yZSB0aGUgb3ZlcmZsb3cgc3RhdGUgb24gYm90aCBheGlzICovXG4gIHByaXZhdGUgX3N0YXRlID0geyBob3Jpem9udGFsT3ZlcmZsb3c6IGZhbHNlLCB2ZXJ0aWNhbE92ZXJmbG93OiBmYWxzZSB9O1xuXG4gIC8qKiBVbnN1YnNjcmliZSBmcm9tIGFsbCB0aGUgb2JzZXJ2YWJsZXMgKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAvKiogU2V0IHVwIHRoZSB0cmlnZ2VyIGlmIHNwZWNpZmllZCAqL1xuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50cmlnZ2VyKSB7XG4gICAgICB0aGlzLnRyaWdnZXIucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2hlY2tGb3JPdmVyZmxvdygpKTtcbiAgICB9XG4gIH1cblxuICAvKiogUGVyZm9ybSBhbiBpbnRpYWwgY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5jaGVja0Zvck92ZXJmbG93KCkpO1xuICB9XG5cbiAgLyoqIFVuc3Vic2NyaWJlIGZyb20gdGhlIHRyaWdnZXIgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBQcm9ncmFtbWF0aWNhbGx5IHRyaWdnZXIgY2hlY2sgZm9yIG92ZXJmbG93ICovXG4gIGNoZWNrRm9yT3ZlcmZsb3coKTogdm9pZCB7XG5cbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQsIHNjcm9sbFdpZHRoLCBzY3JvbGxIZWlnaHQgfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBob3Jpem9udGFsT3ZlcmZsb3cgPSAoc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aCkgPiB0aGlzLnRvbGVyYW5jZTtcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJmbG93ID0gKHNjcm9sbEhlaWdodCAtIG9mZnNldEhlaWdodCkgPiB0aGlzLnRvbGVyYW5jZTtcblxuICAgIGlmIChob3Jpem9udGFsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLmhvcml6b250YWxPdmVyZmxvdykge1xuICAgICAgdGhpcy51eE92ZXJmbG93SG9yaXpvbnRhbE9ic2VydmVyLmVtaXQoaG9yaXpvbnRhbE92ZXJmbG93KTtcbiAgICB9XG5cbiAgICBpZiAodmVydGljYWxPdmVyZmxvdyAhPT0gdGhpcy5fc3RhdGUudmVydGljYWxPdmVyZmxvdykge1xuICAgICAgdGhpcy51eE92ZXJmbG93VmVydGljYWxPYnNlcnZlci5lbWl0KHZlcnRpY2FsT3ZlcmZsb3cpO1xuICAgIH1cblxuICAgIGlmIChob3Jpem9udGFsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLmhvcml6b250YWxPdmVyZmxvdyB8fCB2ZXJ0aWNhbE92ZXJmbG93ICE9PSB0aGlzLl9zdGF0ZS52ZXJ0aWNhbE92ZXJmbG93KSB7XG4gICAgICB0aGlzLnV4T3ZlcmZsb3dPYnNlcnZlci5lbWl0KChob3Jpem9udGFsT3ZlcmZsb3cgfHwgdmVydGljYWxPdmVyZmxvdykpO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlID0geyBob3Jpem9udGFsT3ZlcmZsb3csIHZlcnRpY2FsT3ZlcmZsb3cgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE92ZXJmbG93RGlyZWN0aXZlIH0gZnJvbSAnLi9vdmVyZmxvdy9vdmVyZmxvdy1vYnNlcnZlci5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBleHBvcnRzOiBbT3ZlcmZsb3dEaXJlY3RpdmVdLFxuICBkZWNsYXJhdGlvbnM6IFtPdmVyZmxvd0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZXJzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IG1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vc2VsZWN0aW9uLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFNlbGVjdGlvbkl0ZW1dJyxcclxuICAgIGV4cG9ydEFzOiAndXgtc2VsZWN0aW9uLWl0ZW0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25JdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG5cclxuICAgIEBJbnB1dCgpIHV4U2VsZWN0aW9uSXRlbTogYW55O1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLnV4LXNlbGVjdGlvbi1zZWxlY3RlZCcpXHJcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1zZWxlY3RlZCcpXHJcbiAgICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBzZWxlY3RlZCA/IHRoaXMuc2VsZWN0KCkgOiB0aGlzLmRlc2VsZWN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy51eC1zZWxlY3Rpb24tZm9jdXNlZCcpIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXHJcbiAgICBnZXQgYXR0clRhYkluZGV4KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnRhYmluZGV4ICE9PSBudWxsKSA/IHRoaXMudGFiaW5kZXggOiB0aGlzLl9tYW5hZ2VkVGFiSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX21hbmFnZWRUYWJJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlbGVjdGlvblNlcnZpY2U6IFNlbGVjdGlvblNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBhc3NvY2lhdGVkIGRhdGEgdGhlbiB0aHJvdyBhbiBlcnJvclxyXG4gICAgICAgIGlmICghdGhpcy51eFNlbGVjdGlvbkl0ZW0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdXhTZWxlY3Rpb25JdGVtIGRpcmVjdGl2ZSBtdXN0IGhhdmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gc2VsZWN0aW9uIGNoYW5nZXMgb24gdGhpcyBpdGVtXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5nZXRTZWxlY3Rpb25TdGF0ZSh0aGlzLnV4U2VsZWN0aW9uSXRlbSkucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHNlbGVjdGVkID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzZWxlY3RlZCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG5cclxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgc2VsZWN0ZWQgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHNlbGVjdGVkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5fc2VsZWN0ZWQpO1xyXG5cclxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcyB0byB0aGUgYWN0aXZlIHN0YXRlXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmUkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIG1hcChhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzLnV4U2VsZWN0aW9uSXRlbSkpLnN1YnNjcmliZShhY3RpdmUgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGZvY3VzIHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgYWN0aXZlIHRoZW4gZm9jdXMgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQubmV4dCh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlcyB0byB0aGUgZm9jdXMgdGFyZ2V0XHJcbiAgICAgICAgLy8gVGhpcyBpcyBtb3N0bHkgdGhlIHNhbWUgYXMgYWN0aXZlJCwgZXhjZXB0IHRoYXQgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWUgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGZvY3VzVGFyZ2V0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZFRhYkluZGV4ID0gKGZvY3VzVGFyZ2V0ID09PSB0aGlzLnV4U2VsZWN0aW9uSXRlbSkgPyAwIDogLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXHJcbiAgICBjbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzRW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzQ2xpY2tFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuY2xpY2soZXZlbnQsIHRoaXMudXhTZWxlY3Rpb25JdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJywgWyckZXZlbnQnXSlcclxuICAgIG1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzRW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzQ2xpY2tFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kubW91c2Vkb3duKGV2ZW50LCB0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxyXG4gICAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzRW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzS2V5Ym9hcmRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kua2V5ZG93bihldmVudCwgdGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdmb2N1cycpXHJcbiAgICBmb2N1cygpOiB2b2lkIHtcclxuICAgICAgICAvLyBJZiB0YWJiZWQgdG8gZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQsIGFjdGl2YXRlLlxyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2ZSQuZ2V0VmFsdWUoKSAhPT0gdGhpcy51eFNlbGVjdGlvbkl0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZSh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoaXMgaXRlbSB1c2luZyB0aGUgY3VycmVudCBzdHJhdGVneVxyXG4gICAgICovXHJcbiAgICBzZWxlY3QoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuc2VsZWN0KHRoaXMudXhTZWxlY3Rpb25JdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNlbGVjdCB0aGlzIGl0ZW0gdXNpbmcgdGhlIGN1cnJlbnQgc3RyYXRlZ3lcclxuICAgICAqL1xyXG4gICAgZGVzZWxlY3QoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuZGVzZWxlY3QodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL3NlbGVjdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlLCBTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eFNlbGVjdGlvbl0nLFxuICBleHBvcnRBczogJ3V4LXNlbGVjdGlvbicsXG4gIHByb3ZpZGVyczogWyBTZWxlY3Rpb25TZXJ2aWNlIF1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBzZXQgdXhTZWxlY3Rpb24oaXRlbXM6IGFueVtdKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZWxlY3QoLi4uaXRlbXMpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGRpc2FibGVkKGRpc2FibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZXREaXNhYmxlZChkaXNhYmxlZCk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbW9kZShtb2RlOiBTZWxlY3Rpb25Nb2RlIHwgU2VsZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnNldFN0cmF0ZWd5KG1vZGUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGNsaWNrU2VsZWN0aW9uKGlzQ2xpY2tFbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5pc0NsaWNrRW5hYmxlZCA9IGlzQ2xpY2tFbmFibGVkO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGtleWJvYXJkU2VsZWN0aW9uKGlzS2V5Ym9hcmRFbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5pc0tleWJvYXJkRW5hYmxlZCA9IGlzS2V5Ym9hcmRFbmFibGVkO1xuICB9XG5cbiAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JykgdGFiaW5kZXg6IG51bWJlciA9IG51bGw7XG5cbiAgQE91dHB1dCgpIHV4U2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcblxuICBAQ29udGVudENoaWxkcmVuKFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUpIGl0ZW1zOiBRdWVyeUxpc3Q8U2VsZWN0aW9uSXRlbURpcmVjdGl2ZT47XG5cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlLCBwcml2YXRlIF9jZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICBfc2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb24kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShpdGVtcyA9PiB0aGlzLnV4U2VsZWN0aW9uQ2hhbmdlLmVtaXQoaXRlbXMpKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAvLyBwcm92aWRlIHRoZSBpbml0aWFsIGxpc3Qgb2Ygc2VsZWN0aW9uIGl0ZW1zXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIC8vIGlmIHRoZSBsaXN0IGNoYW5nZXMgdGhlbiBpbmZvcm0gdGhlIHNlcnZpY2VcbiAgICB0aGlzLml0ZW1zLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlKCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRhdGFzZXQgdG8gcmVmbGVjdCB0aGUgbGF0ZXN0IHNlbGVjdGlvbiBpdGVtc1xuICAgKi9cbiAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0ID0gdGhpcy5pdGVtcy5tYXAoaXRlbSA9PiBpdGVtLnV4U2VsZWN0aW9uSXRlbSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHRhYiB0YXJnZXQgaGFzIGJlZW4gZGVmaW5lZCBzbyB0aGF0IHRoZSBjb21wb25lbnQgY2FuIGJlIHRhYmJlZCB0by5cbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQuZ2V0VmFsdWUoKSA9PT0gbnVsbCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQubmV4dCh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXRbMF0pO1xuICAgIH1cblxuICAgIC8vIFRoZSBhYm92ZSBjb3VsZCB0cmlnZ2VyIGEgY2hhbmdlIGluIHRoZSBjb21wdXRlZCB0YWJpbmRleCBmb3Igc2VsZWN0aW9uIGl0ZW1zXG4gICAgdGhpcy5fY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhbGwgdGhlIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAqL1xuICBzZWxlY3RBbGwoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnNlbGVjdEFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhbGwgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5pc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuZGVzZWxlY3RBbGwoKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vc2VsZWN0aW9uLWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFNlbGVjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc2VsZWN0aW9uLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbU2VsZWN0aW9uRGlyZWN0aXZlLCBTZWxlY3Rpb25JdGVtRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1NlbGVjdGlvbkRpcmVjdGl2ZSwgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5leHBvcnQgY2xhc3MgVHJlZUdyaWRTdGF0ZSB7XG4gICAgcmVhZG9ubHkgbG9hZGluZyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbGV2ZWw6IG51bWJlcixcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHNldFNpemU6IG51bWJlcixcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHBvc2l0aW9uSW5TZXQ6IG51bWJlcikge31cbn1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBUcmVlR3JpZEl0ZW0gfSBmcm9tICcuL3RyZWUtZ3JpZC1pdGVtLmludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmVlR3JpZExvYWRGdW5jdGlvbiB9IGZyb20gJy4vdHJlZS1ncmlkLWxvYWQtZnVuY3Rpb24udHlwZSc7XG5pbXBvcnQgeyBUcmVlR3JpZFN0YXRlIH0gZnJvbSAnLi90cmVlLWdyaWQtc3RhdGUuY2xhc3MnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJlZUdyaWRTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIC8qKiBUaGUgcmF3IHRhYmxlIGRhdGEgKi9cbiAgICBkYXRhJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHJlZUdyaWRJdGVtW10+KFtdKTtcblxuICAgIC8qKiBUaGUgZmxhdHRlbmVkIHRhYmxlIGRhdGEgKi9cbiAgICByb3dzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHJlZUdyaWRJdGVtW10+KFtdKTtcblxuICAgIC8qKiBUaGUgZnVuY3Rpb24gdG8gbG9hZCBjaGlsZCBpdGVtcyAqL1xuICAgIGxvYWRDaGlsZHJlbjogVHJlZUdyaWRMb2FkRnVuY3Rpb247XG5cbiAgICAvKiogRW5zdXJlIHdlIGRlc3Ryb3kgYWxsIG9ic2VydmFibGVzIGNvcnJlY3RseSAqL1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5kYXRhJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZGF0YSA9PiB0aGlzLnJvd3MkLm5leHQodGhpcy5nZXRGbGF0dGVuZWRUcmVlKGRhdGEpKSk7XG4gICAgfVxuXG4gICAgLyoqIFVuc3Vic2NyaWJlIGZyb20gYWxsIG9ic2VydmFibGVzICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKiBTZXQgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIGEgcm93ICovXG4gICAgYXN5bmMgc2V0RXhwYW5kZWQoaXRlbTogVHJlZUdyaWRJdGVtLCBleHBhbmRlZDogYm9vbGVhbikge1xuICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0Q2hpbGRyZW4oaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydENoaWxkcmVuKGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbihpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKiogQSBmdW5jdGlvbiB0byBmbGF0dGVuIHRyZWUgZGF0YSAqL1xuICAgIHByaXZhdGUgZ2V0RmxhdHRlbmVkVHJlZShkYXRhOiBUcmVlR3JpZEl0ZW1bXSwgcGFyZW50PzogVHJlZUdyaWRJdGVtKTogVHJlZUdyaWRJdGVtW10ge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBub2RlcyBhdCB0aGlzIGxldmVsXG4gICAgICAgIHJldHVybiBkYXRhLnJlZHVjZSgocHJldmlvdXMsIGl0ZW0sIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGl0ZW0uc3RhdGUgPSBuZXcgVHJlZUdyaWRTdGF0ZShwYXJlbnQgPyBwYXJlbnQuc3RhdGUubGV2ZWwgKyAxIDogMCwgZGF0YS5sZW5ndGgsIGluZGV4ICsgMSk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgYW55IGNoaWxkIG5vZGVzXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uZXhwYW5kZWQpID8gdGhpcy5nZXRGbGF0dGVuZWRUcmVlKGl0ZW0uY2hpbGRyZW4sIGl0ZW0pIDogW107XG5cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbm9kZXMgaW4gYSBmbGF0dGVuZWQgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldmlvdXMsIGl0ZW0sIC4uLmNoaWxkcmVuXTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKiBMb2FkIGFueSBjaGlsZHJlbiBkeW5hbWljYWxseSAqL1xuICAgIHByaXZhdGUgYXN5bmMgZ2V0Q2hpbGRyZW4oaXRlbTogVHJlZUdyaWRJdGVtKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghaXRlbS5jaGlsZHJlbiAmJiB0aGlzLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgaXRlbS5zdGF0ZS5sb2FkaW5nJC5uZXh0KHRydWUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4gPSBhd2FpdCB0aGlzLmdldE5vcm1hbGl6ZWRDaGlsZHJlbih0aGlzLmxvYWRDaGlsZHJlbihpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXRlLmxvYWRpbmckLm5leHQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFdlIHdhbnQgdG8gc3VwcG9ydCBhbiBhcnJheSwgYSBwcm9taXNlIGFuZCBhbiBvYnNlcnZhYmxlLiBUaGlzIHdpbGwgcmV0dXJuIGFsbCB0eXBlcyBhcyBhIHByb21pc2UgKi9cbiAgICBwcml2YXRlIGFzeW5jIGdldE5vcm1hbGl6ZWRDaGlsZHJlbihyZXNwb25zZTogVHJlZUdyaWRJdGVtW10gfCBQcm9taXNlPFRyZWVHcmlkSXRlbVtdPiB8IE9ic2VydmFibGU8VHJlZUdyaWRJdGVtW10+KTogUHJvbWlzZTxUcmVlR3JpZEl0ZW1bXT4ge1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIGFscmVhZHkgYW4gb2JzZXJ2YWJsZSBkbyBub3RoaW5nXG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0IGlzIGEgcHJvbWlzZSB3cmFwIGl0IGFzIGFuIG9ic2VydmFibGVcbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgdGhlbiBtYWtlIGl0IGFuIG9ic2VydmFibGVcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKiBJbnNlcnQgdGhlIGNoaWxkcmVuIGludG8gdGhlIGZsYXR0ZW5lZCB0cmVlIGF0IHRoZSBjb3JyZWN0IGxvY2F0aW9uICovXG4gICAgcHJpdmF0ZSBpbnNlcnRDaGlsZHJlbihwYXJlbnQ6IFRyZWVHcmlkSXRlbSk6IHZvaWQge1xuICAgICAgICBpZiAoIXBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcm93LmluZGV4T2YocGFyZW50KTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTa2lwIGR1cGxpY2F0ZXMgLSB0aGlzIGNvdWxkIGhhcHBlbiBpZiBhbiBhbHJlYWR5IGV4cGFuZGVkIGNoaWxkIGhhcyBiZWVuIGluc2VydGVkXG4gICAgICAgIGNvbnN0IHVuaXF1ZUNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiByb3cuaW5kZXhPZihjaGlsZCkgPT09IC0xKTtcblxuICAgICAgICBjb25zdCBjaGlsZFJvd3MgPSB0aGlzLmdldEZsYXR0ZW5lZFRyZWUodW5pcXVlQ2hpbGRyZW4sIHBhcmVudCk7XG5cbiAgICAgICAgcm93LnNwbGljZShpbmRleCArIDEsIDAsIC4uLmNoaWxkUm93cyk7XG4gICAgfVxuXG4gICAgLyoqIFJlbW92ZSBhbGwgcm93cyBmcm9tIHRoZSBmbGF0dGVuZWQgdHJlZSAqL1xuICAgIHByaXZhdGUgcmVtb3ZlQ2hpbGRyZW4ocGFyZW50OiBUcmVlR3JpZEl0ZW0pOiB2b2lkIHtcblxuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5yb3dzJC5nZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJvd3MuaW5kZXhPZihwYXJlbnQpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCArIDEgPCByb3dzLmxlbmd0aCAmJiByb3dzW2luZGV4ICsgMV0uc3RhdGUubGV2ZWwgPiBwYXJlbnQuc3RhdGUubGV2ZWwpIHtcbiAgICAgICAgICAgIHJvd3Muc3BsaWNlKGluZGV4ICsgMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMtY29tcGF0L0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc2tpcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyB0aWNrIH0gZnJvbSAnLi4vLi4vY29tbW9uL29wZXJhdG9ycy90aWNrLm9wZXJhdG9yJztcbmltcG9ydCB7IFRyZWVHcmlkSXRlbSB9IGZyb20gJy4vdHJlZS1ncmlkLWl0ZW0uaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyZWVHcmlkU2VydmljZSB9IGZyb20gJy4vdHJlZS1ncmlkLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRyZWVHcmlkUm93XScsXG4gICAgZXhwb3J0QXM6ICd1eFRyZWVHcmlkUm93JyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MudHJlZWdyaWQtcm93XSc6ICd0cnVlJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVHJlZUdyaWRSb3dEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoJ3V4VHJlZUdyaWRSb3cnKVxuICAgIGl0ZW06IFRyZWVHcmlkSXRlbTtcblxuICAgIEBJbnB1dCgpXG4gICAgY2FuRXhwYW5kOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgZXhwYW5kZWQoZXhwYW5kZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWQkLm5leHQoISFleHBhbmRlZCk7XG4gICAgfVxuICAgIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZGVkJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIEBPdXRwdXQoKVxuICAgIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy50cmVlZ3JpZC1yb3ctbG9hZGluZycpXG4gICAgbG9hZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy50cmVlZ3JpZC1yb3ctZXhwYW5kZWQnKVxuICAgIGlzRXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX2V4cGFuZGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RyZWVHcmlkU2VydmljZTogVHJlZUdyaWRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkJC5waXBlKHNraXAoMSksIHRpY2soKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShleHBhbmRlZCA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQoZXhwYW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5fdHJlZUdyaWRTZXJ2aWNlLnNldEV4cGFuZGVkKHRoaXMuaXRlbSwgZXhwYW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIGlmICghdGhpcy5pdGVtIHx8ICF0aGlzLml0ZW0uc3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXhUcmVlR3JpZFJvdyBzaG91bGQgYmUgY29uZmlndXJlZCB3aXRoIGFuIG9iamVjdCBlbWl0dGVkIGJ5IHV4VHJlZUdyaWQucm93cy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXRlbS5zdGF0ZS5sb2FkaW5nJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShsb2FkaW5nID0+IHRoaXMubG9hZGluZyA9IGxvYWRpbmcpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkFycm93TGVmdCcsIFsnJGV2ZW50J10pXG4gICAgY29sbGFwc2UoZXZlbnQ/OiBFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkFycm93UmlnaHQnLCBbJyRldmVudCddKVxuICAgIGV4cGFuZChldmVudD86IEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgd2hldGhlciBvciBub3QgdGhlIGl0ZW0gY2FuIGV4cGFuZGVkXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0aGlzLmNhbkV4cGFuZCAmJiB0cnVlO1xuXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA/IHRoaXMuY29sbGFwc2UoKSA6IHRoaXMuZXhwYW5kKCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmVlR3JpZFJvd0RpcmVjdGl2ZSB9IGZyb20gJy4vdHJlZS1ncmlkLXJvdy5kaXJlY3RpdmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRyZWVHcmlkSW5kZW50XScsXG59KVxuZXhwb3J0IGNsYXNzIFRyZWVHcmlkSW5kZW50RGlyZWN0aXZlIHtcblxuICAgIC8qKiBUaGUgYW1vdW50IGVhY2ggbGV2ZWwgc2hvdWxkIGJlIGluZGVudGVkIGJ5ICovXG4gICAgQElucHV0KCkgdXhUcmVlR3JpZEluZGVudDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBwYWRkaW5nIHZhbHVlIGFwcGxpZWQgdG8gZWFjaCBsZXZlbCAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUucGFkZGluZy1sZWZ0LnB4JylcbiAgICBnZXQgaW5kZW50YXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdyAmJiB0aGlzLl9yb3cuaXRlbSA/IDcgKyAodGhpcy5fcm93Lml0ZW0uc3RhdGUubGV2ZWwgKiAodGhpcy51eFRyZWVHcmlkSW5kZW50IHx8IDI1KSkgOiA3O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3JvdzogVHJlZUdyaWRSb3dEaXJlY3RpdmUpIHt9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmVlR3JpZEl0ZW0gfSBmcm9tICcuL3RyZWUtZ3JpZC1pdGVtLmludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmVlR3JpZExvYWRGdW5jdGlvbiB9IGZyb20gJy4vdHJlZS1ncmlkLWxvYWQtZnVuY3Rpb24udHlwZSc7XG5pbXBvcnQgeyBUcmVlR3JpZFNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZ3JpZC5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRyZWVHcmlkXScsXG4gICAgcHJvdmlkZXJzOiBbVHJlZUdyaWRTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgIGNsYXNzOiAndHJlZWdyaWQnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBUcmVlR3JpZERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBASW5wdXQoJ3V4VHJlZUdyaWQnKVxuICAgIHNldCBkYXRhKGRhdGE6IFRyZWVHcmlkSXRlbVtdKSB7XG4gICAgICAgIHRoaXMuX3RyZWVHcmlkU2VydmljZS5kYXRhJC5uZXh0KGRhdGEpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGxvYWRDaGlsZHJlbihsb2FkQ2hpbGRyZW46IFRyZWVHcmlkTG9hZEZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3RyZWVHcmlkU2VydmljZS5sb2FkQ2hpbGRyZW4gPSBsb2FkQ2hpbGRyZW47XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICByb3dzOiBUcmVlR3JpZEl0ZW1bXTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHJvd3NDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPFRyZWVHcmlkSXRlbVtdPigpO1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RyZWVHcmlkU2VydmljZTogVHJlZUdyaWRTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RyZWVHcmlkU2VydmljZS5yb3dzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUocm93cyA9PiB0aGlzLnJvd3NDaGFuZ2UuZW1pdChyb3dzKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmVlR3JpZEluZGVudERpcmVjdGl2ZSB9IGZyb20gJy4vdHJlZS1ncmlkLWluZGVudC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVHJlZUdyaWRSb3dEaXJlY3RpdmUgfSBmcm9tICcuL3RyZWUtZ3JpZC1yb3cuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRyZWVHcmlkRGlyZWN0aXZlIH0gZnJvbSAnLi90cmVlLWdyaWQuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVHJlZUdyaWREaXJlY3RpdmUsXG4gICAgICAgIFRyZWVHcmlkUm93RGlyZWN0aXZlLFxuICAgICAgICBUcmVlR3JpZEluZGVudERpcmVjdGl2ZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBUcmVlR3JpZERpcmVjdGl2ZSxcbiAgICAgICAgVHJlZUdyaWRSb3dEaXJlY3RpdmUsXG4gICAgICAgIFRyZWVHcmlkSW5kZW50RGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBUcmVlR3JpZE1vZHVsZSB7fVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2NvbnRhY3QtZ3JvdXAnXG59KVxuZXhwb3J0IGNsYXNzIENvbnRhY3RzTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjb250YWN0czogQ29udGFjdFtdO1xuICAgIEBJbnB1dCgpIG9yZ2FuaXphdGlvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNpemU6ICdtZWRpdW0nIHwgJ3NtYWxsJztcbiAgICBASW5wdXQoKSBjb2xvcnM6IGFueTtcbiAgICBASW5wdXQoKSBtYXhDb250YWN0czogbnVtYmVyO1xuXG4gICAgQE91dHB1dCgpIG92ZXJmbG93Q2xpY2s6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignY29udGFjdEdyb3VwJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250YWN0IHtcbiAgICB0ZXN0OiBzdHJpbmc7XG4gICAgc3RhdHVzOiAnYWN0aXZlJyB8ICdwYXNzaXZlJztcbiAgICBjdXN0b21Ub29sdGlwPzoge1xuICAgICAgICB0ZW1wbGF0ZTogc3RyaW5nLFxuICAgICAgICB0b29sdGlwUG9zaXRpb246IHN0cmluZztcbiAgICAgICAgZGF0YT86IGFueTtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9yZ2FuaXphdGlvbiB7XG4gICAgdGV4dDogc3RyaW5nO1xuICAgIGxhYmVsOiAnZXh0ZXJuYWwnIHwgJ3Jpc2snO1xuICAgIHRvb2x0aXA/OiBzdHJpbmc7XG4gICAgY3VzdG9tVG9vbHRpcD86IHtcbiAgICAgICAgdGVtcGxhdGU6IHN0cmluZyxcbiAgICAgICAgdG9vbHRpcFBvc2l0aW9uOiBzdHJpbmc7XG4gICAgICAgIGRhdGE/OiBhbnk7XG4gICAgfTtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZXhwYW5kLWlucHV0J1xufSlcbmV4cG9ydCBjbGFzcyBFeHBhbmRJbnB1dE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZWxuYW1lOiBzdHJpbmc7XG4gICAgQElucHV0KCkgcGxhY2VIb2xkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBjbGFzc05hbWU6IHN0cmluZztcbiAgICBASW5wdXQoKSBjbGVhclRleHRJY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xvc2VTZWFyY2g6IHN0cmluZztcbiAgICBASW5wdXQoKSBleHBhbmRBbHdheXM6IGJvb2xlYW47XG4gICAgQElucHV0KCkgb25FbnRlcjogRnVuY3Rpb247XG5cbiAgICBAT3V0cHV0KCkgZm9jdXM6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2V4cGFuZElucHV0JywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdmbG9hdGluZy1hY3Rpb24tYnV0dG9uJ1xufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbk5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaXRlbXM6IEZsb2F0aW5nQWN0aW9uQnV0dG9uSXRlbVtdID0gW107XG4gICAgQElucHV0KCkgcHJpbWFyeTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGRpcmVjdGlvbjogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCc7XG4gICAgQElucHV0KCkgZmFiVG9vbHRpcDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGZhYlRvb2x0aXBQbGFjZW1lbnQ6ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdmbG9hdGluZ0FjdGlvbkJ1dHRvbicsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxvYXRpbmdBY3Rpb25CdXR0b25JdGVtIHtcbiAgICBpY29uOiBzdHJpbmc7XG4gICAgZXZlbnQ6IEZ1bmN0aW9uO1xuICAgIHRvb2x0aXA/OiBzdHJpbmc7XG4gICAgdG9vbHRpcFBsYWNlbWVudD86IHN0cmluZztcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZmxvdCdcbn0pXG5leHBvcnQgY2xhc3MgRmxvdE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YXNldDogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjYWxsYmFjazogYW55O1xuICAgIEBJbnB1dCgpIGRvbnV0TGFiZWxzOiBhbnk7XG4gICAgQE91dHB1dCgpIG9uUGxvdENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gICAgQE91dHB1dCgpIG9uUGxvdEhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4RmxvdE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZ3JpZCdcbn0pXG5leHBvcnQgY2xhc3MgR3JpZE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc291cmNlOiBhbnlbXSA9IFtdO1xuICAgIEBJbnB1dCgpIGNvbHVtbnM6IEdyaWRDb2x1bW5bXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbGxvd2luZyBpbnB1dHMgYXJlIHVuZG9jdW1lbnRlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBldmVudHM6IGFueTtcbiAgICBASW5wdXQoKSBwbHVnaW5zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2dyaWQnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRDb2x1bW4ge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgdGVtcGxhdGU6IHN0cmluZztcbiAgICB3aWR0aD86IHN0cmluZztcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdoaWVyYXJjaHktYmFyJ1xufSlcbmV4cG9ydCBjbGFzcyBIaWVyYXJjaHlCYXJOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueVtdO1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IEhpZXJhcmNoeUJhck9wdGlvbnM7XG4gICAgQElucHV0KCkgc2VsZWN0Tm9kZTogYW55O1xuICAgIEBJbnB1dCgpIGNvbnRhaW5lckNsYXNzOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2hpZXJhcmNoeUJhcicsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGllcmFyY2h5QmFyT3B0aW9ucyB7XG4gICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICBvdmVydmlldz86IEZ1bmN0aW9uO1xuICAgIGltYWdlOiBGdW5jdGlvbjtcbiAgICB2YWx1ZUZvcm1hdHRlcjogRnVuY3Rpb247XG4gICAgYWN0aW9uPzoge1xuICAgICAgICB0aXRsZTogc3RyaW5nO1xuICAgICAgICBldmVudDogRnVuY3Rpb247XG4gICAgfTtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnbWFycXVlZS13aXphcmQnXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIHdpemFyZEljb246IHN0cmluZztcbiAgICBASW5wdXQoKSB3aXphcmRTdGVwczogTWFycXVlZVdpemFyZFN0ZXBbXTtcbiAgICBASW5wdXQoKSBidXR0b25PcHRpb25zOiBNYXJxdWVlV2l6YXJkT3B0aW9ucztcbiAgICBASW5wdXQoKSBvbkNoYW5naW5nOiBGdW5jdGlvbjtcbiAgICBASW5wdXQoKSBvbkZpbmlzaGVkOiBGdW5jdGlvbjtcbiAgICBASW5wdXQoKSBvbkZpbmlzaGluZzogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25DYW5jZWxlZDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgaXNWaXNpdGVkOiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHNpZGVJbmZvOiBNYXJxdWVlV2l6YXJkU2lkZUluZm87XG5cbiAgICBAT3V0cHV0KCkgd2l6YXJkU3RlcHNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXJxdWVlV2l6YXJkU3RlcFtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8TWFycXVlZVdpemFyZFN0ZXBbXT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignbWFycXVlZVdpemFyZCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFN0ZXAge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgaHRtbD86IHN0cmluZztcbiAgICBoZWFkZXI/OiBzdHJpbmc7XG4gICAgdGVtcGxhdGVVcmw/OiBzdHJpbmc7XG4gICAgaGlkZGVuPzogYm9vbGVhbjtcbiAgICBlcnJvcj86IGJvb2xlYW47XG4gICAgY29tcGxldGVkPzogYm9vbGVhbjtcbiAgICB2aXNpdGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXJxdWVlV2l6YXJkT3B0aW9ucyB7XG4gICAgbmV4dFRleHQ/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNUZXh0Pzogc3RyaW5nO1xuICAgIGZpbmlzaFRleHQ/OiBzdHJpbmc7XG4gICAgc2hvd05leHQ/OiBib29sZWFuO1xuICAgIHNob3dQcmV2aW91cz86IGJvb2xlYW47XG4gICAgc2hvd0ZpbmlzaD86IGJvb2xlYW47XG4gICAgbmV4dFRvb2x0aXA/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNUb29sdGlwPzogc3RyaW5nO1xuICAgIGZpbmlzaFRvb2x0aXA/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNFbmFibGVkPzogYm9vbGVhbjtcbiAgICBuZXh0RW5hYmxlZD86IGJvb2xlYW47XG4gICAgZmluaXNoRW5hYmxlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFNpZGVJbmZvIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnbmVzdGVkLWRvbnV0J1xufSlcbmV4cG9ydCBjbGFzcyBOZXN0ZWREb251dE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YXNldDogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhOZXN0ZWREb251dE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ29yZ2FuaXphdGlvbi1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgT3JnYW5pemF0aW9uQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQE91dHB1dCgpIGRhdGFDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgICBAT3V0cHV0KCkgb3B0aW9uc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eE9yZ2FuaXphdGlvbkNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdwYXJ0aXRpb24tbWFwJ1xufSlcbmV4cG9ydCBjbGFzcyBQYXJ0aXRpb25NYXBOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGNoYXJ0RGF0YTogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0T3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0TG9hZGluZzogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBhcnRpdGlvbk1hcE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnYmFyLWNoYXJ0J1xufSlcbmV4cG9ydCBjbGFzcyBQZWl0eUJhckNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5QmFyQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2xpbmUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5TGluZUNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5TGluZUNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdwaWUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5UGllQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4UGVpdHlQaWVDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXBkYXRpbmctbGluZS1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YTogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBtZXRob2Q6IGFueTtcbiAgICBASW5wdXQoKSB1cGRhdGVpbnRlcnZhbDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5VXBkYXRpbmdMaW5lQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NhbmtleSdcbn0pXG5leHBvcnQgY2xhc3MgU2Fua2V5TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjaGFydFNpemU6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgY2xpY2s6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhTYW5rZXlOZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NlYXJjaC10b29sYmFyJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hUb29sYmFyTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBzZWFyY2hUeXBlYWhlYWQ6IGFueVtdO1xuICAgIEBJbnB1dCgpIHBsYWNlSG9sZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xvc2VTZWFyY2g6IHN0cmluZztcbiAgICBASW5wdXQoKSBvblNlYXJjaDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25Gb2N1czogRnVuY3Rpb247XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3NlYXJjaFRvb2xiYXInLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzZWxlY3QtdGFibGUnXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdFRhYmxlTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSB2YWx1ZXM6IGFueVtdO1xuICAgIEBJbnB1dCgpIG11bHRpcGxlU2VsZWN0OiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHNlbGVjdEtleTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2VhcmNoVGV4dDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHRhYmxlSGVpZ2h0OiBzdHJpbmc7XG4gICAgQElucHV0KCkgdGVtcGxhdGU6IHN0cmluZztcbiAgICBASW5wdXQoKSB0ZW1wbGF0ZVVybDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdEhpZGRlbkl0ZW1zOiAnY2xlYXInIHwgJ3Jlc2VsZWN0JztcblxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignc2VsZWN0VGFibGUnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFNMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNsaWRlckNoYXJ0TmcxQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzbGlkZXItY2hhcnQnLFxuICAgIHByb3ZpZGVyczogW1NMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgQElucHV0KCkgc2xpZGVyT3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIG5nTW9kZWw6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydE9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcblxuICAgIEBPdXRwdXQoKSBuZ01vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzbGlkZXJDaGFydCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKG9iajogYW55KTogdm9pZCB7IH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQgeyB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7IH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzb2NpYWwtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFNvY2lhbENoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIHdpZHRoOiBhbnk7XG4gICAgQElucHV0KCkgaGVpZ2h0OiBhbnk7XG4gICAgQElucHV0KCkgYXBpOiBhbnk7XG4gICAgQElucHV0KCkgY29tbXVuaXRpZXM6IGFueTtcbiAgICBASW5wdXQoKSBkZXRhaWxTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIHBvcG92ZXJTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVEZXRhaWw6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlRGV0YWlsOiBhbnk7XG4gICAgQElucHV0KCkgbm9kZVBvcG92ZXI6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlUG9wb3ZlcjogYW55O1xuICAgIEBJbnB1dCgpIGZvcmNlQXRsYXNEdXJhdGlvbjogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVTaXplQXR0cmlidXRlOiBhbnk7XG4gICAgQElucHV0KCkgc3RhcnRNYXhpbWl6ZWQ6IGFueTtcbiAgICBASW5wdXQoKSBzdGFydE1heGltaXNlZDogYW55O1xuICAgIEBJbnB1dCgpIHNob3dNYXhpbWl6ZUNvbnRyb2w6IGFueTtcbiAgICBASW5wdXQoKSBzaG93TWF4aW1pc2VDb250cm9sOiBhbnk7XG4gICAgQElucHV0KCkgc29jaWFsQ2hhcnRDb250YWluZXI6IGFueTtcbiAgICBASW5wdXQoKSBmdWxsc2NyZWVuQnV0dG9uUG9zaXRpb246IGFueTtcbiAgICBASW5wdXQoKSBsb2NhbFN0cmluZ3M6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydFRpdGxlOiBhbnk7XG4gICAgQElucHV0KCkgdGl0bGVEaXNwbGF5VGltZTogYW55O1xuICAgIEBJbnB1dCgpIGVkZ2VXZWlnaHRJbmZsdWVuY2U6IGFueTtcbiAgICBASW5wdXQoKSBtaW5MYWJlbHM6IGFueTtcbiAgICBcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhTb2NpYWxDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnc29ydC1kaXJlY3Rpb24tdG9nZ2xlJ1xufSlcbmV4cG9ydCBjbGFzcyBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNvcnRlcnM6IFNvcnREaXJlY3Rpb25Ub2dnbGVTb3J0ZXJbXTtcbiAgICBASW5wdXQoKSBkZXNjZW5kOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzb3J0RGlyZWN0aW9uVG9nZ2xlJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0RGlyZWN0aW9uVG9nZ2xlU29ydGVyIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc29ydDogc3RyaW5nO1xuICAgIGRlZmF1bHRTb3J0ZXI6IGJvb2xlYW47XG4gICAgc2VsZWN0OiBGdW5jdGlvbjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndHJlZWdyaWQnXG59KVxuZXhwb3J0IGNsYXNzIFRyZWVHcmlkTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnlbXSB8IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIGNvbHVtbnM6IFRyZWVHcmlkQ29sdW1uW107XG4gICAgQElucHV0KCkgdHJlZURhdGE6IFRyZWVHcmlkRGF0YVtdO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBhbnlbXTtcbiAgICBASW5wdXQoKSBjdXJyZW50Um93OiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogVHJlZUdyaWRPcHRpb25zO1xuXG4gICAgQE91dHB1dCgpIG9wdGlvbnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+KCk7XG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcbiAgICBAT3V0cHV0KCkgY3VycmVudFJvd0NoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgICBAT3V0cHV0KCkgdHJlZURhdGFDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZERhdGFbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPFRyZWVHcmlkRGF0YVtdPigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd0cmVlZ3JpZCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJlZUdyaWRDb2x1bW4ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZT86IHN0cmluZyB8IEZ1bmN0aW9uO1xuICAgIHRlbXBsYXRlPzogc3RyaW5nO1xuICAgIGhlYWRlckNsYXNzPzogc3RyaW5nO1xuICAgIGNlbGxDbGFzcz86IHN0cmluZztcbiAgICB3aWR0aD86IHN0cmluZztcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIHRvb2x0aXBQbGFjZW1lbnQ/OiAndG9wJyB8ICdib3R0b20nIHwgJ2xlZnQnIHwgJ3JpZ2h0Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmVlR3JpZERhdGEge1xuICAgIGRhdGFJdGVtOiBhbnk7XG4gICAgY2hpbGRyZW46IGFueVtdO1xuICAgIGV4cGFuZGVkOiBib29sZWFuO1xuICAgIGV4cGFuZGluZzogYm9vbGVhbjtcbiAgICBsZXZlbDogbnVtYmVyO1xuICAgIGFwaTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyZWVHcmlkT3B0aW9ucyB7XG4gICAgY2hpbGRyZW5Qcm9wZXJ0eT86IHN0cmluZztcbiAgICBoYXNDaGlsZHJlbj86IEZ1bmN0aW9uO1xuICAgIG1heERlcHRoPzogbnVtYmVyO1xuICAgIGV4cGFuZFRvcExldmVsPzogYm9vbGVhbjtcbiAgICBzZWxlY3Q/OiBhbnk7XG4gICAgZXhwYW5kZXI/OiBhbnk7XG4gICAgaWNvbnM/OiBhbnk7XG4gICAgcm93Q2xhc3M/OiBzdHJpbmcgfCBGdW5jdGlvbjtcbiAgICBzb3J0PzogRnVuY3Rpb247XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd0aHVtYm5haWwnXG59KVxuZXhwb3J0IGNsYXNzIFRodW1ibmFpbE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgdXJsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2hvdzogYm9vbGVhbjtcbiAgICBASW5wdXQoKSB3aWR0aDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGhlaWdodDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd0aHVtYm5haWwnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElOYXZpZ2F0aW9uTWVudVNlcnZpY2UgfSBmcm9tICcuL25hdmlnYXRpb24tbWVudS5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlIGltcGxlbWVudHMgSU5hdmlnYXRpb25NZW51U2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvciggQEluamVjdCgnJG5hdmlnYXRpb25NZW51JykgcHJpdmF0ZSBfbmF2aWdhdGlvbk1lbnVTZXJ2aWNlOiBJTmF2aWdhdGlvbk1lbnVTZXJ2aWNlKSB7IH1cblxuICAgIHNob3coKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5zaG93KCk7XG4gICAgfVxuXG4gICAgaGlkZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICB2aXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLnZpc2libGUoKTtcbiAgICB9XG5cbiAgICBjb2xsYXBzZUF0V2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5jb2xsYXBzZUF0V2lkdGgoKTtcbiAgICB9XG5cbiAgICBzZXRDb2xsYXBzZUF0V2lkdGgod2lkdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2Uuc2V0Q29sbGFwc2VBdFdpZHRoKHdpZHRoKTtcbiAgICB9XG5cbiAgICBzZXREZWZhdWx0Q29sbGFwc2VBdFdpZHRoKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2Uuc2V0RGVmYXVsdENvbGxhcHNlQXRXaWR0aCgpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGlvbk1lbnVTZXJ2aWNlRmFjdG9yeShpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KCckbmF2aWdhdGlvbk1lbnUnKTtcbn1cblxuZXhwb3J0IGNvbnN0IG5hdmlnYXRpb25NZW51U2VydmljZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6ICckbmF2aWdhdGlvbk1lbnUnLFxuICAgIHVzZUZhY3Rvcnk6IG5hdmlnYXRpb25NZW51U2VydmljZUZhY3RvcnksXG4gICAgZGVwczogWyckaW5qZWN0b3InXVxufTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJUGRmU2VydmljZSwgUGRmQ29sdW1ucywgUGRmT3B0aW9ucywgUGRmRG9jdW1lbnQgfSBmcm9tICcuL3BkZi5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGRmU2VydmljZSBpbXBsZW1lbnRzIElQZGZTZXJ2aWNlIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KCckcGRmJykgcHJpdmF0ZSBfcGRmU2VydmljZTogSVBkZlNlcnZpY2UpIHsgfVxuICAgIFxuICAgIGNyZWF0ZVRhYmxlKGNvbHVtbnM6IFBkZkNvbHVtbnMsIHJvd3M6IGFueVtdLCBvcHRpb25zOiBQZGZPcHRpb25zID0ge30pOiBQZGZEb2N1bWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZGZTZXJ2aWNlLmNyZWF0ZVRhYmxlKGNvbHVtbnMsIHJvd3MsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBkZlNlcnZpY2VGYWN0b3J5KGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHJldHVybiBpbmplY3Rvci5nZXQoJyRwZGYnKTtcbn1cblxuZXhwb3J0IGNvbnN0IHBkZlNlcnZpY2VQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiAnJHBkZicsXG4gICAgdXNlRmFjdG9yeTogcGRmU2VydmljZUZhY3RvcnksXG4gICAgZGVwczogWyckaW5qZWN0b3InXVxufTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJVGltZUFnb1NlcnZpY2UsIFRpbWVBZ29Mb2NhbGl6ZWRUaW1lcyB9IGZyb20gJy4vdGltZS1hZ28uaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRpbWVBZ29TZXJ2aWNlIGltcGxlbWVudHMgSVRpbWVBZ29TZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoJ3RpbWVBZ29TZXJ2aWNlJykgcHJpdmF0ZSBfdGltZUFnb1NlcnZpY2U6IElUaW1lQWdvU2VydmljZSkgeyB9XG5cbiAgICBzZXRTdHJpbmdzKHN0cmluZ3M6IFRpbWVBZ29Mb2NhbGl6ZWRUaW1lcyk6IHZvaWQge1xuICAgICAgICB0aGlzLl90aW1lQWdvU2VydmljZS5zZXRTdHJpbmdzKHN0cmluZ3MpO1xuICAgIH1cblxuICAgIHRpbWVTaW5jZShwYXN0OiBEYXRlLCBwcmVzZW50OiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVBZ29TZXJ2aWNlLnRpbWVTaW5jZShwYXN0LCBwcmVzZW50KTtcbiAgICB9XG5cbiAgICB0aW1lU2luY2VOb3cobW9tZW50OiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVBZ29TZXJ2aWNlLnRpbWVTaW5jZU5vdyhtb21lbnQpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUFnb1NlcnZpY2VGYWN0b3J5KGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHJldHVybiBpbmplY3Rvci5nZXQoJ3RpbWVBZ29TZXJ2aWNlJyk7XG59XG5cbmV4cG9ydCBjb25zdCB0aW1lQWdvU2VydmljZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6ICd0aW1lQWdvU2VydmljZScsXG4gICAgdXNlRmFjdG9yeTogdGltZUFnb1NlcnZpY2VGYWN0b3J5LFxuICAgIGRlcHM6IFsnJGluamVjdG9yJ11cbn07IiwiaW1wb3J0IHsgTmdNb2R1bGUsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmxvdE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9mbG90L2Zsb3QuY29tcG9uZW50JztcbmltcG9ydCB7IE5lc3RlZERvbnV0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL25lc3RlZC1kb251dC9uZXN0ZWQtZG9udXQuY29tcG9uZW50JztcbmltcG9ydCB7IE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL29yZ2FuaXphdGlvbi1jaGFydC9vcmdhbml6YXRpb24tY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFBhcnRpdGlvbk1hcE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wYXJ0aXRpb24tbWFwL3BhcnRpdGlvbi1tYXAuY29tcG9uZW50JztcbmltcG9ydCB7IFBlaXR5QmFyQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktYmFyLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eUxpbmVDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1saW5lLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eVBpZUNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LXBpZS1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS11cGRhdGluZy1saW5lLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTYW5rZXlOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2Fua2V5LWNoYXJ0L3NhbmtleS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU29jaWFsQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc29jaWFsLWNoYXJ0L3NvY2lhbC1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGltZUFnb1NlcnZpY2UsIHRpbWVBZ29TZXJ2aWNlUHJvdmlkZXIgfSBmcm9tICcuL3NlcnZpY2VzL3RpbWUtYWdvL3RpbWUtYWdvLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGRmU2VydmljZSwgcGRmU2VydmljZVByb3ZpZGVyIH0gZnJvbSAnLi9zZXJ2aWNlcy9wZGYvcGRmLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlLCBuYXZpZ2F0aW9uTWVudVNlcnZpY2VQcm92aWRlciB9IGZyb20gJy4vc2VydmljZXMvbmF2aWdhdGlvbi1tZW51L25hdmlnYXRpb24tbWVudS5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZ3JpZC9ncmlkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaHVtYm5haWxOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvdGh1bWJuYWlsL3RodW1ibmFpbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSGllcmFyY2h5QmFyTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29udGFjdHNOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvY29udGFjdHMvY29udGFjdHMuY29tcG9uZW50JztcbmltcG9ydCB7IEV4cGFuZElucHV0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2V4cGFuZC1pbnB1dC9leHBhbmQtaW5wdXQuY29tcG9uZW50JztcbmltcG9ydCB7IFNvcnREaXJlY3Rpb25Ub2dnbGVOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc29ydC1kaXJlY3Rpb24tdG9nZ2xlL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2gtdG9vbGJhci9zZWFyY2gtdG9vbGJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgVHJlZUdyaWROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0VGFibGVOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2VsZWN0LXRhYmxlL3NlbGVjdC10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2xpZGVyLWNoYXJ0L3NsaWRlci1jaGFydC5kaXJlY3RpdmUnO1xuXG5jb25zdCBkZWNsYXJhdGlvbnMgPSBbXG4gICAgQ29udGFjdHNOZzFDb21wb25lbnQsXG4gICAgRXhwYW5kSW5wdXROZzFDb21wb25lbnQsXG4gICAgRmxvYXRpbmdBY3Rpb25CdXR0b25OZzFDb21wb25lbnQsXG4gICAgRmxvdE5nMUNvbXBvbmVudCxcbiAgICBHcmlkTmcxQ29tcG9uZW50LFxuICAgIEhpZXJhcmNoeUJhck5nMUNvbXBvbmVudCxcbiAgICBNYXJxdWVlV2l6YXJkTmcxQ29tcG9uZW50LFxuICAgIE5lc3RlZERvbnV0TmcxQ29tcG9uZW50LFxuICAgIE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBhcnRpdGlvbk1hcE5nMUNvbXBvbmVudCxcbiAgICBQZWl0eUJhckNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBlaXR5TGluZUNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBlaXR5UGllQ2hhcnROZzFDb21wb25lbnQsXG4gICAgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTYW5rZXlOZzFDb21wb25lbnQsXG4gICAgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCxcbiAgICBTZWxlY3RUYWJsZU5nMUNvbXBvbmVudCxcbiAgICBTbGlkZXJDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTb2NpYWxDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50LFxuICAgIFRyZWVHcmlkTmcxQ29tcG9uZW50LFxuICAgIFRodW1ibmFpbE5nMUNvbXBvbmVudCxcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogZGVjbGFyYXRpb25zLFxuICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBuYXZpZ2F0aW9uTWVudVNlcnZpY2VQcm92aWRlcixcbiAgICAgICAgcGRmU2VydmljZVByb3ZpZGVyLFxuICAgICAgICB0aW1lQWdvU2VydmljZVByb3ZpZGVyLFxuICAgICAgICBUaW1lQWdvU2VydmljZSxcbiAgICAgICAgUGRmU2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlLFxuICAgIF0sXG59KVxuZXhwb3J0IGNsYXNzIEh5YnJpZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFBpcGUsIEluamVjdGFibGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICdzdHJpbmdGaWx0ZXInXG59KVxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0cmluZ0ZpbHRlclBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICB0cmFuc2Zvcm0oaXRlbXM6IGFueVtdLCB2YWx1ZTogc3RyaW5nKTogYW55W10geyAgXG4gICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGl0ID0+IGl0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWx1ZS50b0xvd2VyQ2FzZSgpKSA+PSAwKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgU3RyaW5nRmlsdGVyUGlwZSB9IGZyb20gJy4vc3RyaW5nLWZpbHRlci5waXBlJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW1N0cmluZ0ZpbHRlclBpcGVdLFxuICAgIGRlY2xhcmF0aW9uczogW1N0cmluZ0ZpbHRlclBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIFN0cmluZ0ZpbHRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9zdG9yYWdlLWFkYXB0ZXInO1xuXG5leHBvcnQgY2xhc3MgQ29va2llQWRhcHRlciBpbXBsZW1lbnRzIFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5jb29raWUpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IGFsbCB0aGUgY29va2llcyBmb3IgdGhpcyBzaXRlXG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGNvb2tpZXMgaW50byBhIGZyb20gd2UgY2FuIGVhc2lseSBtYW5hZ2VcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gY29va2llc1xuICAgICAgICAgICAgICAgIC5tYXAoY29va2llID0+ICh7IGtleTogY29va2llLnNwbGl0KCc9JylbMF0udHJpbSgpLCB2YWx1ZTogY29va2llLnNwbGl0KCc9JylbMV0udHJpbSgpIH0pKVxuICAgICAgICAgICAgICAgIC5maW5kKGNvb2tpZSA9PiBjb29raWUua2V5ID09PSBrZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC52YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke2tleX09JHt2YWx1ZX07IHBhdGg9L2A7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpLmZvckVhY2goY29va2llID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVxUG9zID0gY29va2llLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlcVBvcyA+IC0xID8gY29va2llLnN1YnN0cigwLCBlcVBvcykudHJpbSgpIDogY29va2llO1xuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLnRyaW0oKS5yZXBsYWNlKC89LiovLCBgPTtleHBpcmVzPSR7bmV3IERhdGUoKS50b1VUQ1N0cmluZygpfTtwYXRoPS9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gY2FsbCByZW1vdmUgaXRlbSBvbiBlYWNoIGNvb2tpZVxuICAgICAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKS5tYXAoY29va2llID0+IGNvb2tpZS5zcGxpdCgnPScpWzBdLnRyaW0oKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvb2tpZSA9PiB0aGlzLnJlbW92ZUl0ZW0oY29va2llKSk7XG4gICAgfVxuXG4gICAgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyIHtcbiAgICAgICAgLy8gY29va2llcyBhcmUgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vyc1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IENvb2tpZUFkYXB0ZXIgfSBmcm9tICcuL2Nvb2tpZS1hZGFwdGVyJztcblxuZXhwb3J0IGNsYXNzIExvY2FsU3RvcmFnZUFkYXB0ZXIgaW1wbGVtZW50cyBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgIH1cblxuICAgIGdldFN1cHBvcnRlZCgpOiBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICAgICAgLy8gaWYgbG9jYWwgc3RvcmFnZSB2YXJpYWJsZSBkb2VzIG5vdCBleGlzdCBmYWxsIGJhY2sgdG8gY29va2llc1xuICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gbWFrZSBhIHRlc3Qgc2F2ZSB0byBsb2NhbCBzdG9yYWdlIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IGV4Y2VwdGlvbnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScsICd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL3N0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBDb29raWVBZGFwdGVyIH0gZnJvbSAnLi9jb29raWUtYWRhcHRlcic7XG5cbmV4cG9ydCBjbGFzcyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIgaW1wbGVtZW50cyBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgICAgICAvLyBpZiBsb2NhbCBzdG9yYWdlIHZhcmlhYmxlIGRvZXMgbm90IGV4aXN0IGZhbGwgYmFjayB0byBjb29raWVzXG4gICAgICAgIGlmICghc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgYSB0ZXN0IHNhdmUgdG8gbG9jYWwgc3RvcmFnZSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBleGNlcHRpb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScsICd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IENvb2tpZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL2Nvb2tpZS1hZGFwdGVyJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL2xvY2FsLXN0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL3Nlc3Npb24tc3RvcmFnZS1hZGFwdGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBlcnNpc3RlbnREYXRhU2VydmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBpdGVtIGluIHNvbWUgZm9ybSBvZiBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgKi9cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCB0eXBlOiBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlID0gUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Mb2NhbFN0b3JhZ2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nZXRBZGFwdGVyKHR5cGUpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgZ2V0SXRlbShrZXk6IHN0cmluZywgdHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5nZXRJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZywgdHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgY2xlYXIodHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgYWRhcHRlciBiYXNlZCBvbiB0aGUgdHlwZSByZXF1ZXN0ZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEFkYXB0ZXIodHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSk6IFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkNvb2tpZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvb2tpZUFkYXB0ZXIoKTtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkxvY2FsU3RvcmFnZTpcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0b3JhZ2VBZGFwdGVyID0gbmV3IExvY2FsU3RvcmFnZUFkYXB0ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlQWRhcHRlci5nZXRTdXBwb3J0ZWQoKTtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLlNlc3Npb25TdG9yYWdlOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25TdG9yYWdlQWRhcHRlciA9IG5ldyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2VBZGFwdGVyLmdldFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlIHtcbiAgICBMb2NhbFN0b3JhZ2UsXG4gICAgQ29va2llLFxuICAgIFNlc3Npb25TdG9yYWdlXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUGVyc2lzdGVudERhdGFTZXJ2aWNlIH0gZnJvbSAnLi9wZXJzaXN0ZW50LWRhdGEuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgcHJvdmlkZXJzOiBbUGVyc2lzdGVudERhdGFTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgUGVyc2lzdGVudERhdGFNb2R1bGUgeyB9XG4iLCJleHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RvcmFnZUFkYXB0ZXIge1xuICAgIGFic3RyYWN0IGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgYWJzdHJhY3Qgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgY2xlYXIoKTogdm9pZDtcbiAgICBhYnN0cmFjdCBnZXRTdXBwb3J0ZWQoKTogU3RvcmFnZUFkYXB0ZXI7XG59Il0sIm5hbWVzIjpbIkRpcmVjdGl2ZSIsIlN1YmplY3QiLCJJbmplY3RhYmxlIiwiRXZlbnRFbWl0dGVyIiwiQ29tcG9uZW50IiwiSW5wdXQiLCJIb3N0QmluZGluZyIsIk91dHB1dCIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIiwiUm91dGVyTW9kdWxlIiwiUmVwbGF5U3ViamVjdCIsInRzbGliXzEuX192YWx1ZXMiLCJOZ1pvbmUiLCJkZWJvdW5jZVRpbWUiLCJFbGVtZW50UmVmIiwiQmVoYXZpb3JTdWJqZWN0IiwiZmlsdGVyIiwibWFwIiwiQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kiLCJDb250ZW50Q2hpbGQiLCJUZW1wbGF0ZVJlZiIsIlZpZXdDaGlsZCIsIk5HX1ZBTFVFX0FDQ0VTU09SIiwiZm9yd2FyZFJlZiIsIkZvcm1zTW9kdWxlIiwidW5pcXVlSWQiLCJwYWlyd2lzZSIsInRha2VVbnRpbCIsImNvbWJpbmVMYXRlc3QiLCJGb2N1c01vbml0b3IiLCJpc1BsYXRmb3JtQnJvd3NlciIsIlJlbmRlcmVyMiIsIkluamVjdCIsIlBMQVRGT1JNX0lEIiwiU3BsaXRDb21wb25lbnQiLCJDb250ZW50Q2hpbGRyZW4iLCJTcGxpdEFyZWFEaXJlY3RpdmUiLCJIb3N0TGlzdGVuZXIiLCJPYnNlcnZhYmxlIiwiRm9jdXNLZXlNYW5hZ2VyIiwiSE9NRSIsIkVORCIsIkRPV05fQVJST1ciLCJSSUdIVF9BUlJPVyIsIlVQX0FSUk9XIiwiTEVGVF9BUlJPVyIsIlF1ZXJ5TGlzdCIsIkExMXlNb2R1bGUiLCJDaGFuZ2VEZXRlY3RvclJlZiIsImZyb21FdmVudCIsIkNvbXBvbmVudFBvcnRhbCIsIlZpZXdDb250YWluZXJSZWYiLCJPdmVybGF5IiwiU2Nyb2xsRGlzcGF0Y2hlciIsIk92ZXJsYXlNb2R1bGUiLCJPYnNlcnZlcnNNb2R1bGUiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsIk9wdGlvbmFsIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJ0c2xpYl8xLl9fYXNzaWduIiwiZGVsYXkiLCJtb250aHMiLCJWaWV3RW5jYXBzdWxhdGlvbiIsIlBpcGUiLCJTdWJzY3JpcHRpb24iLCJmaWx0ZXJPcGVyYXRvciIsImF1ZGl0VGltZSIsIm9mIiwiZnJvbSIsImZpcnN0IiwiKChkcmFndWxhTmFtZXNwYWNlKSkuZGVmYXVsdCIsIkxpdmVBbm5vdW5jZXIiLCJIb3N0IiwiVmlld0NoaWxkcmVuIiwidGFwIiwibWVyZ2VNYXAiLCJERUNMQVJBVElPTlMiLCJyeEZpbHRlciIsIkJzRHJvcGRvd25EaXJlY3RpdmUiLCJFU0NBUEUiLCJET0NVTUVOVCIsIkVOVEVSIiwiU1BBQ0UiLCJCc0Ryb3Bkb3duTW9kdWxlIiwiQXR0cmlidXRlIiwidHJpZ2dlciIsInRyYW5zaXRpb24iLCJxdWVyeSIsInN0eWxlIiwic3RhZ2dlciIsImFuaW1hdGUiLCJjb25jYXQiLCJzd2l0Y2hNYXAiLCJ0aW1lciIsIkh0dHBDbGllbnQiLCJIdHRwQ2xpZW50TW9kdWxlIiwiTmF2aWdhdGlvbkVuZCIsIlNraXBTZWxmIiwiUm91dGVyIiwiTG9jYXRpb25TdHJhdGVneSIsInN0YXRlIiwiZHJvcGRvd24iLCJDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIiLCJOR19WQUxJREFUT1JTIiwiQkFDS1NQQUNFIiwiREVMRVRFIiwiRVhQT1JUUyIsInRzbGliXzEuX19zcHJlYWQiLCJOZ01vZGVsIiwic2tpcCIsIkluamVjdG9yIiwiVXBncmFkZUNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7O29CQUVDQSxjQUFTLFNBQUM7d0JBQ1QsUUFBUSxFQUFFLDJCQUEyQjtxQkFDdEM7OzZDQUpEOzs7Ozs7O0FDQUE7O2tDQU04QixLQUFLOzRCQUNwQixJQUFJQyxlQUFPLEVBQVE7Ozs7O1FBRTlCLHNDQUFXOzs7WUFBWDtnQkFDSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3hCOztvQkFSSkMsZUFBVTs7K0JBSFg7Ozs7Ozs7QUNBQSxJQUdBLHFCQUFJLFFBQVEsR0FBVyxDQUFDLENBQUM7O1FBcUJyQixpQ0FBbUIsU0FBMkI7WUFBOUMsaUJBRUM7WUFGa0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7MkJBVG5CLHdCQUFzQixRQUFRLEVBQUk7NkJBQzdCLElBQUksQ0FBQyxPQUFPLGFBQVU7NEJBRXpCLEtBQUs7NEJBRTRCLEtBQUs7a0NBRXhDLElBQUlDLGlCQUFZLEVBQVc7WUFHbEQsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxRQUFRLEVBQUUsR0FBQSxDQUFDLENBQUM7U0FDdkQ7Ozs7UUFFRCx3Q0FBTTs7O1lBQU47Z0JBRUks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R0FBRyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTt3QkFBRSxPQUFPLENBQUMsQ0FBQztvQkFDbkgsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7d0JBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO3dCQUNULEtBQUssQ0FBQyxDQUFDO3dCQUFDLEtBQUssQ0FBQzs0QkFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDOzRCQUFDLE1BQU07d0JBQzlCLEtBQUssQ0FBQzs0QkFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7NEJBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDO3dCQUN4RCxLQUFLLENBQUM7NEJBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDOzRCQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQUMsU0FBUzt3QkFDakQsS0FBSyxDQUFDOzRCQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDOzRCQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7NEJBQUMsU0FBUzt3QkFDakQ7NEJBQ0ksSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO2dDQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7Z0NBQUMsU0FBUzs2QkFBRTs0QkFDNUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0NBQUUsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBQUMsTUFBTTs2QkFBRTs0QkFDdEYsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dDQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7Z0NBQUMsTUFBTTs2QkFBRTs0QkFDckUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0NBQUUsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7Z0NBQUMsTUFBTTs2QkFBRTs0QkFDbkUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7NEJBQ3RCLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7NEJBQUMsU0FBUztxQkFDOUI7b0JBQ0QsRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUM5QjtnQkFBQyxPQUFPLENBQUMs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QUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7UUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUU7UUFDN0IsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUU7UUFDMUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUM5QixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFO1FBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7UUFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtRQUMvQixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFO1FBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7UUFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtRQUMvQixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFF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SUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3pDOzs7Ozs7Ozs7UUFLRCxxQ0FBSzs7Ozs7WUFBTCxVQUFNLElBQXdFO2dCQUF4RSxxQkFBQTtvQkFBQSxPQUFrQyx5QkFBeUIsQ0FBQyxZQUFZOztnQkFDMUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNqQzs7Ozs7O1FBS08sMENBQVU7Ozs7O3NCQUFDLElBQStCO2dCQUU5QyxRQUFRLElBQUk7b0JBRVIsS0FBSyx5QkFBeUIsQ0FBQyxNQUFNO3dCQUNqQyxPQUFPLElBQUksYUFBYSxFQUFFLENBQUM7b0JBRS9CLEtBQUsseUJBQXlCLENBQUMsWUFBWTt3QkFDdkMscUJBQU0sbUJBQW1CLEdBQUcsSUFBSSxtQkFBbUIsRUFBRSxDQUFDO3dCQUN0RCxPQUFPLG1CQUFtQixDQUFDLFlBQVksRUFBRSxDQUFDO29CQUU5QyxLQUFLLHlCQUF5QixDQUFDLGNBQWM7d0JBQ3pDLHFCQUFNLHFCQUFxQixHQUFHLElBQUkscUJBQXFCLEVBQUUsQ0FBQzt3QkFDMUQsT0FBTyxxQkFBcUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztpQkFDbkQ7OztvQkFoRFJOLGVBQVU7O29DQU5YOzs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7b0JBSUNNLGFBQVEsU0FBQzt3QkFDTixTQUFTLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQztxQkFDckM7O21DQU5EOzs7Ozs7Ozs7O0FDQUE7O1FBQUE7Ozs2QkFBQTtRQU1DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9